var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var require_assets = __commonJS({
  "assets/index.js"(exports, module) {
    function _mergeNamespaces(n2, m2) {
      for (var i2 = 0; i2 < m2.length; i2++) {
        const e2 = m2[i2];
        if (typeof e2 !== "string" && !Array.isArray(e2)) {
          for (const k2 in e2) {
            if (k2 !== "default" && !(k2 in n2)) {
              const d2 = Object.getOwnPropertyDescriptor(e2, k2);
              if (d2) {
                Object.defineProperty(n2, k2, d2.get ? d2 : {
                  enumerable: true,
                  get: () => e2[k2]
                });
              }
            }
          }
        }
      }
      return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
    }
    (function polyfill() {
      const relList = document.createElement("link").relList;
      if (relList && relList.supports && relList.supports("modulepreload")) {
        return;
      }
      for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
        processPreload(link);
      }
      new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "childList") {
            continue;
          }
          for (const node2 of mutation.addedNodes) {
            if (node2.tagName === "LINK" && node2.rel === "modulepreload")
              processPreload(node2);
          }
        }
      }).observe(document, { childList: true, subtree: true });
      function getFetchOpts(link) {
        const fetchOpts = {};
        if (link.integrity)
          fetchOpts.integrity = link.integrity;
        if (link.referrerPolicy)
          fetchOpts.referrerPolicy = link.referrerPolicy;
        if (link.crossOrigin === "use-credentials")
          fetchOpts.credentials = "include";
        else if (link.crossOrigin === "anonymous")
          fetchOpts.credentials = "omit";
        else
          fetchOpts.credentials = "same-origin";
        return fetchOpts;
      }
      function processPreload(link) {
        if (link.ep)
          return;
        link.ep = true;
        const fetchOpts = getFetchOpts(link);
        fetch(link.href, fetchOpts);
      }
    })();
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x2) {
      return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
    }
    var jsxRuntime = { exports: {} };
    var reactJsxRuntime_production_min = {};
    var react = { exports: {} };
    var react_production_min = {};
    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var l$5 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$7 = Symbol.for("react.fragment"), q$8 = Symbol.for("react.strict_mode"), r$5 = Symbol.for("react.profiler"), t$5 = Symbol.for("react.provider"), u$5 = Symbol.for("react.context"), v$6 = Symbol.for("react.forward_ref"), w$4 = Symbol.for("react.suspense"), x$4 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$5 = Symbol.iterator;
    function A$4(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = z$5 && a2[z$5] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var B$5 = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function() {
    }, enqueueReplaceState: function() {
    }, enqueueSetState: function() {
    } }, C$3 = Object.assign, D$5 = {};
    function E$3(a2, b2, e2) {
      this.props = a2;
      this.context = b2;
      this.refs = D$5;
      this.updater = e2 || B$5;
    }
    E$3.prototype.isReactComponent = {};
    E$3.prototype.setState = function(a2, b2) {
      if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, a2, b2, "setState");
    };
    E$3.prototype.forceUpdate = function(a2) {
      this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
    };
    function F$4() {
    }
    F$4.prototype = E$3.prototype;
    function G$4(a2, b2, e2) {
      this.props = a2;
      this.context = b2;
      this.refs = D$5;
      this.updater = e2 || B$5;
    }
    var H$4 = G$4.prototype = new F$4();
    H$4.constructor = G$4;
    C$3(H$4, E$3.prototype);
    H$4.isPureReactComponent = true;
    var I$4 = Array.isArray, J$2 = Object.prototype.hasOwnProperty, K$3 = { current: null }, L$5 = { key: true, ref: true, __self: true, __source: true };
    function M$4(a2, b2, e2) {
      var d2, c2 = {}, k2 = null, h2 = null;
      if (null != b2)
        for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
          J$2.call(b2, d2) && !L$5.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
      var g2 = arguments.length - 2;
      if (1 === g2)
        c2.children = e2;
      else if (1 < g2) {
        for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
          f2[m2] = arguments[m2 + 2];
        c2.children = f2;
      }
      if (a2 && a2.defaultProps)
        for (d2 in g2 = a2.defaultProps, g2)
          void 0 === c2[d2] && (c2[d2] = g2[d2]);
      return { $$typeof: l$5, type: a2, key: k2, ref: h2, props: c2, _owner: K$3.current };
    }
    function N$3(a2, b2) {
      return { $$typeof: l$5, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
    }
    function O$3(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$5;
    }
    function escape$1(a2) {
      var b2 = { "=": "=0", ":": "=2" };
      return "$" + a2.replace(/[=:]/g, function(a3) {
        return b2[a3];
      });
    }
    var P$5 = /\/+/g;
    function Q$3(a2, b2) {
      return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
    }
    function R$4(a2, b2, e2, d2, c2) {
      var k2 = typeof a2;
      if ("undefined" === k2 || "boolean" === k2)
        a2 = null;
      var h2 = false;
      if (null === a2)
        h2 = true;
      else
        switch (k2) {
          case "string":
          case "number":
            h2 = true;
            break;
          case "object":
            switch (a2.$$typeof) {
              case l$5:
              case n$6:
                h2 = true;
            }
        }
      if (h2)
        return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$3(h2, 0) : d2, I$4(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$5, "$&/") + "/"), R$4(c2, b2, e2, "", function(a3) {
          return a3;
        })) : null != c2 && (O$3(c2) && (c2 = N$3(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$5, "$&/") + "/") + a2)), b2.push(c2)), 1;
      h2 = 0;
      d2 = "" === d2 ? "." : d2 + ":";
      if (I$4(a2))
        for (var g2 = 0; g2 < a2.length; g2++) {
          k2 = a2[g2];
          var f2 = d2 + Q$3(k2, g2);
          h2 += R$4(k2, b2, e2, f2, c2);
        }
      else if (f2 = A$4(a2), "function" === typeof f2)
        for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
          k2 = k2.value, f2 = d2 + Q$3(k2, g2++), h2 += R$4(k2, b2, e2, f2, c2);
      else if ("object" === k2)
        throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
      return h2;
    }
    function S$2(a2, b2, e2) {
      if (null == a2)
        return a2;
      var d2 = [], c2 = 0;
      R$4(a2, d2, "", "", function(a3) {
        return b2.call(e2, a3, c2++);
      });
      return d2;
    }
    function T$3(a2) {
      if (-1 === a2._status) {
        var b2 = a2._result;
        b2 = b2();
        b2.then(function(b3) {
          if (0 === a2._status || -1 === a2._status)
            a2._status = 1, a2._result = b3;
        }, function(b3) {
          if (0 === a2._status || -1 === a2._status)
            a2._status = 2, a2._result = b3;
        });
        -1 === a2._status && (a2._status = 0, a2._result = b2);
      }
      if (1 === a2._status)
        return a2._result.default;
      throw a2._result;
    }
    var U$5 = { current: null }, V$3 = { transition: null }, W$3 = { ReactCurrentDispatcher: U$5, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$3 };
    react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
      S$2(a2, function() {
        b2.apply(this, arguments);
      }, e2);
    }, count: function(a2) {
      var b2 = 0;
      S$2(a2, function() {
        b2++;
      });
      return b2;
    }, toArray: function(a2) {
      return S$2(a2, function(a3) {
        return a3;
      }) || [];
    }, only: function(a2) {
      if (!O$3(a2))
        throw Error("React.Children.only expected to receive a single React element child.");
      return a2;
    } };
    react_production_min.Component = E$3;
    react_production_min.Fragment = p$7;
    react_production_min.Profiler = r$5;
    react_production_min.PureComponent = G$4;
    react_production_min.StrictMode = q$8;
    react_production_min.Suspense = w$4;
    react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$3;
    react_production_min.cloneElement = function(a2, b2, e2) {
      if (null === a2 || void 0 === a2)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
      var d2 = C$3({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
      if (null != b2) {
        void 0 !== b2.ref && (k2 = b2.ref, h2 = K$3.current);
        void 0 !== b2.key && (c2 = "" + b2.key);
        if (a2.type && a2.type.defaultProps)
          var g2 = a2.type.defaultProps;
        for (f2 in b2)
          J$2.call(b2, f2) && !L$5.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
      }
      var f2 = arguments.length - 2;
      if (1 === f2)
        d2.children = e2;
      else if (1 < f2) {
        g2 = Array(f2);
        for (var m2 = 0; m2 < f2; m2++)
          g2[m2] = arguments[m2 + 2];
        d2.children = g2;
      }
      return { $$typeof: l$5, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
    };
    react_production_min.createContext = function(a2) {
      a2 = { $$typeof: u$5, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
      a2.Provider = { $$typeof: t$5, _context: a2 };
      return a2.Consumer = a2;
    };
    react_production_min.createElement = M$4;
    react_production_min.createFactory = function(a2) {
      var b2 = M$4.bind(null, a2);
      b2.type = a2;
      return b2;
    };
    react_production_min.createRef = function() {
      return { current: null };
    };
    react_production_min.forwardRef = function(a2) {
      return { $$typeof: v$6, render: a2 };
    };
    react_production_min.isValidElement = O$3;
    react_production_min.lazy = function(a2) {
      return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$3 };
    };
    react_production_min.memo = function(a2, b2) {
      return { $$typeof: x$4, type: a2, compare: void 0 === b2 ? null : b2 };
    };
    react_production_min.startTransition = function(a2) {
      var b2 = V$3.transition;
      V$3.transition = {};
      try {
        a2();
      } finally {
        V$3.transition = b2;
      }
    };
    react_production_min.unstable_act = function() {
      throw Error("act(...) is not supported in production builds of React.");
    };
    react_production_min.useCallback = function(a2, b2) {
      return U$5.current.useCallback(a2, b2);
    };
    react_production_min.useContext = function(a2) {
      return U$5.current.useContext(a2);
    };
    react_production_min.useDebugValue = function() {
    };
    react_production_min.useDeferredValue = function(a2) {
      return U$5.current.useDeferredValue(a2);
    };
    react_production_min.useEffect = function(a2, b2) {
      return U$5.current.useEffect(a2, b2);
    };
    react_production_min.useId = function() {
      return U$5.current.useId();
    };
    react_production_min.useImperativeHandle = function(a2, b2, e2) {
      return U$5.current.useImperativeHandle(a2, b2, e2);
    };
    react_production_min.useInsertionEffect = function(a2, b2) {
      return U$5.current.useInsertionEffect(a2, b2);
    };
    react_production_min.useLayoutEffect = function(a2, b2) {
      return U$5.current.useLayoutEffect(a2, b2);
    };
    react_production_min.useMemo = function(a2, b2) {
      return U$5.current.useMemo(a2, b2);
    };
    react_production_min.useReducer = function(a2, b2, e2) {
      return U$5.current.useReducer(a2, b2, e2);
    };
    react_production_min.useRef = function(a2) {
      return U$5.current.useRef(a2);
    };
    react_production_min.useState = function(a2) {
      return U$5.current.useState(a2);
    };
    react_production_min.useSyncExternalStore = function(a2, b2, e2) {
      return U$5.current.useSyncExternalStore(a2, b2, e2);
    };
    react_production_min.useTransition = function() {
      return U$5.current.useTransition();
    };
    react_production_min.version = "18.2.0";
    {
      react.exports = react_production_min;
    }
    var reactExports = react.exports;
    const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
    const React$1 = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: React
    }, [reactExports]);
    /**
     * @license React
     * react-jsx-runtime.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var f$4 = reactExports, k$5 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$7 = Object.prototype.hasOwnProperty, n$5 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$6 = { key: true, ref: true, __self: true, __source: true };
    function q$7(c2, a2, g2) {
      var b2, d2 = {}, e2 = null, h2 = null;
      void 0 !== g2 && (e2 = "" + g2);
      void 0 !== a2.key && (e2 = "" + a2.key);
      void 0 !== a2.ref && (h2 = a2.ref);
      for (b2 in a2)
        m$7.call(a2, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
      if (c2 && c2.defaultProps)
        for (b2 in a2 = c2.defaultProps, a2)
          void 0 === d2[b2] && (d2[b2] = a2[b2]);
      return { $$typeof: k$5, type: c2, key: e2, ref: h2, props: d2, _owner: n$5.current };
    }
    reactJsxRuntime_production_min.Fragment = l$4;
    reactJsxRuntime_production_min.jsx = q$7;
    reactJsxRuntime_production_min.jsxs = q$7;
    {
      jsxRuntime.exports = reactJsxRuntime_production_min;
    }
    var jsxRuntimeExports = jsxRuntime.exports;
    var client = {};
    var reactDom = { exports: {} };
    var reactDom_production_min = {};
    var scheduler = { exports: {} };
    var scheduler_production_min = {};
    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    (function(exports2) {
      function f2(a2, b2) {
        var c2 = a2.length;
        a2.push(b2);
        a:
          for (; 0 < c2; ) {
            var d2 = c2 - 1 >>> 1, e2 = a2[d2];
            if (0 < g2(e2, b2))
              a2[d2] = b2, a2[c2] = e2, c2 = d2;
            else
              break a;
          }
      }
      function h2(a2) {
        return 0 === a2.length ? null : a2[0];
      }
      function k2(a2) {
        if (0 === a2.length)
          return null;
        var b2 = a2[0], c2 = a2.pop();
        if (c2 !== b2) {
          a2[0] = c2;
          a:
            for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
              var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
              if (0 > g2(C2, c2))
                n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
              else if (n2 < e2 && 0 > g2(x2, c2))
                a2[d2] = x2, a2[n2] = c2, d2 = n2;
              else
                break a;
            }
        }
        return b2;
      }
      function g2(a2, b2) {
        var c2 = a2.sortIndex - b2.sortIndex;
        return 0 !== c2 ? c2 : a2.id - b2.id;
      }
      if ("object" === typeof performance && "function" === typeof performance.now) {
        var l2 = performance;
        exports2.unstable_now = function() {
          return l2.now();
        };
      } else {
        var p2 = Date, q2 = p2.now();
        exports2.unstable_now = function() {
          return p2.now() - q2;
        };
      }
      var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
      "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function G2(a2) {
        for (var b2 = h2(t2); null !== b2; ) {
          if (null === b2.callback)
            k2(t2);
          else if (b2.startTime <= a2)
            k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
          else
            break;
          b2 = h2(t2);
        }
      }
      function H2(a2) {
        B2 = false;
        G2(a2);
        if (!A2)
          if (null !== h2(r2))
            A2 = true, I2(J2);
          else {
            var b2 = h2(t2);
            null !== b2 && K2(H2, b2.startTime - a2);
          }
      }
      function J2(a2, b2) {
        A2 = false;
        B2 && (B2 = false, E2(L2), L2 = -1);
        z2 = true;
        var c2 = y2;
        try {
          G2(b2);
          for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
            var d2 = v2.callback;
            if ("function" === typeof d2) {
              v2.callback = null;
              y2 = v2.priorityLevel;
              var e2 = d2(v2.expirationTime <= b2);
              b2 = exports2.unstable_now();
              "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
              G2(b2);
            } else
              k2(r2);
            v2 = h2(r2);
          }
          if (null !== v2)
            var w2 = true;
          else {
            var m2 = h2(t2);
            null !== m2 && K2(H2, m2.startTime - b2);
            w2 = false;
          }
          return w2;
        } finally {
          v2 = null, y2 = c2, z2 = false;
        }
      }
      var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
      function M2() {
        return exports2.unstable_now() - Q2 < P2 ? false : true;
      }
      function R2() {
        if (null !== O2) {
          var a2 = exports2.unstable_now();
          Q2 = a2;
          var b2 = true;
          try {
            b2 = O2(true, a2);
          } finally {
            b2 ? S2() : (N2 = false, O2 = null);
          }
        } else
          N2 = false;
      }
      var S2;
      if ("function" === typeof F2)
        S2 = function() {
          F2(R2);
        };
      else if ("undefined" !== typeof MessageChannel) {
        var T2 = new MessageChannel(), U2 = T2.port2;
        T2.port1.onmessage = R2;
        S2 = function() {
          U2.postMessage(null);
        };
      } else
        S2 = function() {
          D2(R2, 0);
        };
      function I2(a2) {
        O2 = a2;
        N2 || (N2 = true, S2());
      }
      function K2(a2, b2) {
        L2 = D2(function() {
          a2(exports2.unstable_now());
        }, b2);
      }
      exports2.unstable_IdlePriority = 5;
      exports2.unstable_ImmediatePriority = 1;
      exports2.unstable_LowPriority = 4;
      exports2.unstable_NormalPriority = 3;
      exports2.unstable_Profiling = null;
      exports2.unstable_UserBlockingPriority = 2;
      exports2.unstable_cancelCallback = function(a2) {
        a2.callback = null;
      };
      exports2.unstable_continueExecution = function() {
        A2 || z2 || (A2 = true, I2(J2));
      };
      exports2.unstable_forceFrameRate = function(a2) {
        0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
      };
      exports2.unstable_getCurrentPriorityLevel = function() {
        return y2;
      };
      exports2.unstable_getFirstCallbackNode = function() {
        return h2(r2);
      };
      exports2.unstable_next = function(a2) {
        switch (y2) {
          case 1:
          case 2:
          case 3:
            var b2 = 3;
            break;
          default:
            b2 = y2;
        }
        var c2 = y2;
        y2 = b2;
        try {
          return a2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_pauseExecution = function() {
      };
      exports2.unstable_requestPaint = function() {
      };
      exports2.unstable_runWithPriority = function(a2, b2) {
        switch (a2) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            a2 = 3;
        }
        var c2 = y2;
        y2 = a2;
        try {
          return b2();
        } finally {
          y2 = c2;
        }
      };
      exports2.unstable_scheduleCallback = function(a2, b2, c2) {
        var d2 = exports2.unstable_now();
        "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
        switch (a2) {
          case 1:
            var e2 = -1;
            break;
          case 2:
            e2 = 250;
            break;
          case 5:
            e2 = 1073741823;
            break;
          case 4:
            e2 = 1e4;
            break;
          default:
            e2 = 5e3;
        }
        e2 = c2 + e2;
        a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
        c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
        return a2;
      };
      exports2.unstable_shouldYield = M2;
      exports2.unstable_wrapCallback = function(a2) {
        var b2 = y2;
        return function() {
          var c2 = y2;
          y2 = b2;
          try {
            return a2.apply(this, arguments);
          } finally {
            y2 = c2;
          }
        };
      };
    })(scheduler_production_min);
    {
      scheduler.exports = scheduler_production_min;
    }
    var schedulerExports = scheduler.exports;
    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var aa = reactExports, ca = schedulerExports;
    function p$5(a2) {
      for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
        b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
      return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    var da = /* @__PURE__ */ new Set(), ea = {};
    function fa(a2, b2) {
      ha(a2, b2);
      ha(a2 + "Capture", b2);
    }
    function ha(a2, b2) {
      ea[a2] = b2;
      for (a2 = 0; a2 < b2.length; a2++)
        da.add(b2[a2]);
    }
    var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
    function oa(a2) {
      if (ja.call(ma, a2))
        return true;
      if (ja.call(la, a2))
        return false;
      if (ka.test(a2))
        return ma[a2] = true;
      la[a2] = true;
      return false;
    }
    function pa(a2, b2, c2, d2) {
      if (null !== c2 && 0 === c2.type)
        return false;
      switch (typeof b2) {
        case "function":
        case "symbol":
          return true;
        case "boolean":
          if (d2)
            return false;
          if (null !== c2)
            return !c2.acceptsBooleans;
          a2 = a2.toLowerCase().slice(0, 5);
          return "data-" !== a2 && "aria-" !== a2;
        default:
          return false;
      }
    }
    function qa(a2, b2, c2, d2) {
      if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
        return true;
      if (d2)
        return false;
      if (null !== c2)
        switch (c2.type) {
          case 3:
            return !b2;
          case 4:
            return false === b2;
          case 5:
            return isNaN(b2);
          case 6:
            return isNaN(b2) || 1 > b2;
        }
      return false;
    }
    function v$5(a2, b2, c2, d2, e2, f2, g2) {
      this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
      this.attributeName = d2;
      this.attributeNamespace = e2;
      this.mustUseProperty = c2;
      this.propertyName = a2;
      this.type = b2;
      this.sanitizeURL = f2;
      this.removeEmptyString = g2;
    }
    var z$4 = {};
    "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
      z$4[a2] = new v$5(a2, 0, false, a2, null, false, false);
    });
    [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
      var b2 = a2[0];
      z$4[b2] = new v$5(b2, 1, false, a2[1], null, false, false);
    });
    ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
      z$4[a2] = new v$5(a2, 2, false, a2.toLowerCase(), null, false, false);
    });
    ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
      z$4[a2] = new v$5(a2, 2, false, a2, null, false, false);
    });
    "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
      z$4[a2] = new v$5(a2, 3, false, a2.toLowerCase(), null, false, false);
    });
    ["checked", "multiple", "muted", "selected"].forEach(function(a2) {
      z$4[a2] = new v$5(a2, 3, true, a2, null, false, false);
    });
    ["capture", "download"].forEach(function(a2) {
      z$4[a2] = new v$5(a2, 4, false, a2, null, false, false);
    });
    ["cols", "rows", "size", "span"].forEach(function(a2) {
      z$4[a2] = new v$5(a2, 6, false, a2, null, false, false);
    });
    ["rowSpan", "start"].forEach(function(a2) {
      z$4[a2] = new v$5(a2, 5, false, a2.toLowerCase(), null, false, false);
    });
    var ra = /[\-:]([a-z])/g;
    function sa(a2) {
      return a2[1].toUpperCase();
    }
    "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
      var b2 = a2.replace(
        ra,
        sa
      );
      z$4[b2] = new v$5(b2, 1, false, a2, null, false, false);
    });
    "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
      var b2 = a2.replace(ra, sa);
      z$4[b2] = new v$5(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
    });
    ["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
      var b2 = a2.replace(ra, sa);
      z$4[b2] = new v$5(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
    });
    ["tabIndex", "crossOrigin"].forEach(function(a2) {
      z$4[a2] = new v$5(a2, 1, false, a2.toLowerCase(), null, false, false);
    });
    z$4.xlinkHref = new v$5("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
    ["src", "href", "action", "formAction"].forEach(function(a2) {
      z$4[a2] = new v$5(a2, 1, false, a2.toLowerCase(), null, true, true);
    });
    function ta(a2, b2, c2, d2) {
      var e2 = z$4.hasOwnProperty(b2) ? z$4[b2] : null;
      if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
        qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
    }
    var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
    var Ia = Symbol.for("react.offscreen");
    var Ja = Symbol.iterator;
    function Ka(a2) {
      if (null === a2 || "object" !== typeof a2)
        return null;
      a2 = Ja && a2[Ja] || a2["@@iterator"];
      return "function" === typeof a2 ? a2 : null;
    }
    var A$3 = Object.assign, La;
    function Ma(a2) {
      if (void 0 === La)
        try {
          throw Error();
        } catch (c2) {
          var b2 = c2.stack.trim().match(/\n( *(at )?)/);
          La = b2 && b2[1] || "";
        }
      return "\n" + La + a2;
    }
    var Na = false;
    function Oa(a2, b2) {
      if (!a2 || Na)
        return "";
      Na = true;
      var c2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        if (b2)
          if (b2 = function() {
            throw Error();
          }, Object.defineProperty(b2.prototype, "props", { set: function() {
            throw Error();
          } }), "object" === typeof Reflect && Reflect.construct) {
            try {
              Reflect.construct(b2, []);
            } catch (l2) {
              var d2 = l2;
            }
            Reflect.construct(a2, [], b2);
          } else {
            try {
              b2.call();
            } catch (l2) {
              d2 = l2;
            }
            a2.call(b2.prototype);
          }
        else {
          try {
            throw Error();
          } catch (l2) {
            d2 = l2;
          }
          a2();
        }
      } catch (l2) {
        if (l2 && d2 && "string" === typeof l2.stack) {
          for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
            h2--;
          for (; 1 <= g2 && 0 <= h2; g2--, h2--)
            if (e2[g2] !== f2[h2]) {
              if (1 !== g2 || 1 !== h2) {
                do
                  if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                    var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                    a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                    return k2;
                  }
                while (1 <= g2 && 0 <= h2);
              }
              break;
            }
        }
      } finally {
        Na = false, Error.prepareStackTrace = c2;
      }
      return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
    }
    function Pa(a2) {
      switch (a2.tag) {
        case 5:
          return Ma(a2.type);
        case 16:
          return Ma("Lazy");
        case 13:
          return Ma("Suspense");
        case 19:
          return Ma("SuspenseList");
        case 0:
        case 2:
        case 15:
          return a2 = Oa(a2.type, false), a2;
        case 11:
          return a2 = Oa(a2.type.render, false), a2;
        case 1:
          return a2 = Oa(a2.type, true), a2;
        default:
          return "";
      }
    }
    function Qa(a2) {
      if (null == a2)
        return null;
      if ("function" === typeof a2)
        return a2.displayName || a2.name || null;
      if ("string" === typeof a2)
        return a2;
      switch (a2) {
        case ya:
          return "Fragment";
        case wa:
          return "Portal";
        case Aa:
          return "Profiler";
        case za:
          return "StrictMode";
        case Ea:
          return "Suspense";
        case Fa:
          return "SuspenseList";
      }
      if ("object" === typeof a2)
        switch (a2.$$typeof) {
          case Ca:
            return (a2.displayName || "Context") + ".Consumer";
          case Ba:
            return (a2._context.displayName || "Context") + ".Provider";
          case Da:
            var b2 = a2.render;
            a2 = a2.displayName;
            a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
            return a2;
          case Ga:
            return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
          case Ha:
            b2 = a2._payload;
            a2 = a2._init;
            try {
              return Qa(a2(b2));
            } catch (c2) {
            }
        }
      return null;
    }
    function Ra(a2) {
      var b2 = a2.type;
      switch (a2.tag) {
        case 24:
          return "Cache";
        case 9:
          return (b2.displayName || "Context") + ".Consumer";
        case 10:
          return (b2._context.displayName || "Context") + ".Provider";
        case 18:
          return "DehydratedFragment";
        case 11:
          return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        case 7:
          return "Fragment";
        case 5:
          return b2;
        case 4:
          return "Portal";
        case 3:
          return "Root";
        case 6:
          return "Text";
        case 16:
          return Qa(b2);
        case 8:
          return b2 === za ? "StrictMode" : "Mode";
        case 22:
          return "Offscreen";
        case 12:
          return "Profiler";
        case 21:
          return "Scope";
        case 13:
          return "Suspense";
        case 19:
          return "SuspenseList";
        case 25:
          return "TracingMarker";
        case 1:
        case 0:
        case 17:
        case 2:
        case 14:
        case 15:
          if ("function" === typeof b2)
            return b2.displayName || b2.name || null;
          if ("string" === typeof b2)
            return b2;
      }
      return null;
    }
    function Sa(a2) {
      switch (typeof a2) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return a2;
        case "object":
          return a2;
        default:
          return "";
      }
    }
    function Ta(a2) {
      var b2 = a2.type;
      return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
    }
    function Ua(a2) {
      var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
      if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
        var e2 = c2.get, f2 = c2.set;
        Object.defineProperty(a2, b2, { configurable: true, get: function() {
          return e2.call(this);
        }, set: function(a3) {
          d2 = "" + a3;
          f2.call(this, a3);
        } });
        Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
        return { getValue: function() {
          return d2;
        }, setValue: function(a3) {
          d2 = "" + a3;
        }, stopTracking: function() {
          a2._valueTracker = null;
          delete a2[b2];
        } };
      }
    }
    function Va(a2) {
      a2._valueTracker || (a2._valueTracker = Ua(a2));
    }
    function Wa(a2) {
      if (!a2)
        return false;
      var b2 = a2._valueTracker;
      if (!b2)
        return true;
      var c2 = b2.getValue();
      var d2 = "";
      a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
      a2 = d2;
      return a2 !== c2 ? (b2.setValue(a2), true) : false;
    }
    function Xa(a2) {
      a2 = a2 || ("undefined" !== typeof document ? document : void 0);
      if ("undefined" === typeof a2)
        return null;
      try {
        return a2.activeElement || a2.body;
      } catch (b2) {
        return a2.body;
      }
    }
    function Ya(a2, b2) {
      var c2 = b2.checked;
      return A$3({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
    }
    function Za(a2, b2) {
      var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
      c2 = Sa(null != b2.value ? b2.value : c2);
      a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
    }
    function ab(a2, b2) {
      b2 = b2.checked;
      null != b2 && ta(a2, "checked", b2, false);
    }
    function bb(a2, b2) {
      ab(a2, b2);
      var c2 = Sa(b2.value), d2 = b2.type;
      if (null != c2)
        if ("number" === d2) {
          if (0 === c2 && "" === a2.value || a2.value != c2)
            a2.value = "" + c2;
        } else
          a2.value !== "" + c2 && (a2.value = "" + c2);
      else if ("submit" === d2 || "reset" === d2) {
        a2.removeAttribute("value");
        return;
      }
      b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
      null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
    }
    function db(a2, b2, c2) {
      if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
        var d2 = b2.type;
        if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
          return;
        b2 = "" + a2._wrapperState.initialValue;
        c2 || b2 === a2.value || (a2.value = b2);
        a2.defaultValue = b2;
      }
      c2 = a2.name;
      "" !== c2 && (a2.name = "");
      a2.defaultChecked = !!a2._wrapperState.initialChecked;
      "" !== c2 && (a2.name = c2);
    }
    function cb(a2, b2, c2) {
      if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
        null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
    }
    var eb = Array.isArray;
    function fb(a2, b2, c2, d2) {
      a2 = a2.options;
      if (b2) {
        b2 = {};
        for (var e2 = 0; e2 < c2.length; e2++)
          b2["$" + c2[e2]] = true;
        for (c2 = 0; c2 < a2.length; c2++)
          e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
      } else {
        c2 = "" + Sa(c2);
        b2 = null;
        for (e2 = 0; e2 < a2.length; e2++) {
          if (a2[e2].value === c2) {
            a2[e2].selected = true;
            d2 && (a2[e2].defaultSelected = true);
            return;
          }
          null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
        }
        null !== b2 && (b2.selected = true);
      }
    }
    function gb(a2, b2) {
      if (null != b2.dangerouslySetInnerHTML)
        throw Error(p$5(91));
      return A$3({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
    }
    function hb(a2, b2) {
      var c2 = b2.value;
      if (null == c2) {
        c2 = b2.children;
        b2 = b2.defaultValue;
        if (null != c2) {
          if (null != b2)
            throw Error(p$5(92));
          if (eb(c2)) {
            if (1 < c2.length)
              throw Error(p$5(93));
            c2 = c2[0];
          }
          b2 = c2;
        }
        null == b2 && (b2 = "");
        c2 = b2;
      }
      a2._wrapperState = { initialValue: Sa(c2) };
    }
    function ib(a2, b2) {
      var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
      null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
      null != d2 && (a2.defaultValue = "" + d2);
    }
    function jb(a2) {
      var b2 = a2.textContent;
      b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
    }
    function kb(a2) {
      switch (a2) {
        case "svg":
          return "http://www.w3.org/2000/svg";
        case "math":
          return "http://www.w3.org/1998/Math/MathML";
        default:
          return "http://www.w3.org/1999/xhtml";
      }
    }
    function lb(a2, b2) {
      return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
    }
    var mb, nb = function(a2) {
      return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
        MSApp.execUnsafeLocalFunction(function() {
          return a2(b2, c2, d2, e2);
        });
      } : a2;
    }(function(a2, b2) {
      if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
        a2.innerHTML = b2;
      else {
        mb = mb || document.createElement("div");
        mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
        for (b2 = mb.firstChild; a2.firstChild; )
          a2.removeChild(a2.firstChild);
        for (; b2.firstChild; )
          a2.appendChild(b2.firstChild);
      }
    });
    function ob(a2, b2) {
      if (b2) {
        var c2 = a2.firstChild;
        if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
          c2.nodeValue = b2;
          return;
        }
      }
      a2.textContent = b2;
    }
    var pb = {
      animationIterationCount: true,
      aspectRatio: true,
      borderImageOutset: true,
      borderImageSlice: true,
      borderImageWidth: true,
      boxFlex: true,
      boxFlexGroup: true,
      boxOrdinalGroup: true,
      columnCount: true,
      columns: true,
      flex: true,
      flexGrow: true,
      flexPositive: true,
      flexShrink: true,
      flexNegative: true,
      flexOrder: true,
      gridArea: true,
      gridRow: true,
      gridRowEnd: true,
      gridRowSpan: true,
      gridRowStart: true,
      gridColumn: true,
      gridColumnEnd: true,
      gridColumnSpan: true,
      gridColumnStart: true,
      fontWeight: true,
      lineClamp: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      tabSize: true,
      widows: true,
      zIndex: true,
      zoom: true,
      fillOpacity: true,
      floodOpacity: true,
      stopOpacity: true,
      strokeDasharray: true,
      strokeDashoffset: true,
      strokeMiterlimit: true,
      strokeOpacity: true,
      strokeWidth: true
    }, qb = ["Webkit", "ms", "Moz", "O"];
    Object.keys(pb).forEach(function(a2) {
      qb.forEach(function(b2) {
        b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
        pb[b2] = pb[a2];
      });
    });
    function rb(a2, b2, c2) {
      return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
    }
    function sb(a2, b2) {
      a2 = a2.style;
      for (var c2 in b2)
        if (b2.hasOwnProperty(c2)) {
          var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
          "float" === c2 && (c2 = "cssFloat");
          d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
        }
    }
    var tb = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
    function ub(a2, b2) {
      if (b2) {
        if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
          throw Error(p$5(137, a2));
        if (null != b2.dangerouslySetInnerHTML) {
          if (null != b2.children)
            throw Error(p$5(60));
          if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
            throw Error(p$5(61));
        }
        if (null != b2.style && "object" !== typeof b2.style)
          throw Error(p$5(62));
      }
    }
    function vb(a2, b2) {
      if (-1 === a2.indexOf("-"))
        return "string" === typeof b2.is;
      switch (a2) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var wb = null;
    function xb(a2) {
      a2 = a2.target || a2.srcElement || window;
      a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
      return 3 === a2.nodeType ? a2.parentNode : a2;
    }
    var yb = null, zb = null, Ab = null;
    function Bb(a2) {
      if (a2 = Cb(a2)) {
        if ("function" !== typeof yb)
          throw Error(p$5(280));
        var b2 = a2.stateNode;
        b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
      }
    }
    function Eb(a2) {
      zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
    }
    function Fb() {
      if (zb) {
        var a2 = zb, b2 = Ab;
        Ab = zb = null;
        Bb(a2);
        if (b2)
          for (a2 = 0; a2 < b2.length; a2++)
            Bb(b2[a2]);
      }
    }
    function Gb(a2, b2) {
      return a2(b2);
    }
    function Hb() {
    }
    var Ib = false;
    function Jb(a2, b2, c2) {
      if (Ib)
        return a2(b2, c2);
      Ib = true;
      try {
        return Gb(a2, b2, c2);
      } finally {
        if (Ib = false, null !== zb || null !== Ab)
          Hb(), Fb();
      }
    }
    function Kb(a2, b2) {
      var c2 = a2.stateNode;
      if (null === c2)
        return null;
      var d2 = Db(c2);
      if (null === d2)
        return null;
      c2 = d2[b2];
      a:
        switch (b2) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
            a2 = !d2;
            break a;
          default:
            a2 = false;
        }
      if (a2)
        return null;
      if (c2 && "function" !== typeof c2)
        throw Error(p$5(231, b2, typeof c2));
      return c2;
    }
    var Lb = false;
    if (ia)
      try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", { get: function() {
          Lb = true;
        } });
        window.addEventListener("test", Mb, Mb);
        window.removeEventListener("test", Mb, Mb);
      } catch (a2) {
        Lb = false;
      }
    function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      var l2 = Array.prototype.slice.call(arguments, 3);
      try {
        b2.apply(c2, l2);
      } catch (m2) {
        this.onError(m2);
      }
    }
    var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
      Ob = true;
      Pb = a2;
    } };
    function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      Ob = false;
      Pb = null;
      Nb.apply(Sb, arguments);
    }
    function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      Tb.apply(this, arguments);
      if (Ob) {
        if (Ob) {
          var l2 = Pb;
          Ob = false;
          Pb = null;
        } else
          throw Error(p$5(198));
        Qb || (Qb = true, Rb = l2);
      }
    }
    function Vb(a2) {
      var b2 = a2, c2 = a2;
      if (a2.alternate)
        for (; b2.return; )
          b2 = b2.return;
      else {
        a2 = b2;
        do
          b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
        while (a2);
      }
      return 3 === b2.tag ? c2 : null;
    }
    function Wb(a2) {
      if (13 === a2.tag) {
        var b2 = a2.memoizedState;
        null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
        if (null !== b2)
          return b2.dehydrated;
      }
      return null;
    }
    function Xb(a2) {
      if (Vb(a2) !== a2)
        throw Error(p$5(188));
    }
    function Yb(a2) {
      var b2 = a2.alternate;
      if (!b2) {
        b2 = Vb(a2);
        if (null === b2)
          throw Error(p$5(188));
        return b2 !== a2 ? null : a2;
      }
      for (var c2 = a2, d2 = b2; ; ) {
        var e2 = c2.return;
        if (null === e2)
          break;
        var f2 = e2.alternate;
        if (null === f2) {
          d2 = e2.return;
          if (null !== d2) {
            c2 = d2;
            continue;
          }
          break;
        }
        if (e2.child === f2.child) {
          for (f2 = e2.child; f2; ) {
            if (f2 === c2)
              return Xb(e2), a2;
            if (f2 === d2)
              return Xb(e2), b2;
            f2 = f2.sibling;
          }
          throw Error(p$5(188));
        }
        if (c2.return !== d2.return)
          c2 = e2, d2 = f2;
        else {
          for (var g2 = false, h2 = e2.child; h2; ) {
            if (h2 === c2) {
              g2 = true;
              c2 = e2;
              d2 = f2;
              break;
            }
            if (h2 === d2) {
              g2 = true;
              d2 = e2;
              c2 = f2;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) {
            for (h2 = f2.child; h2; ) {
              if (h2 === c2) {
                g2 = true;
                c2 = f2;
                d2 = e2;
                break;
              }
              if (h2 === d2) {
                g2 = true;
                d2 = f2;
                c2 = e2;
                break;
              }
              h2 = h2.sibling;
            }
            if (!g2)
              throw Error(p$5(189));
          }
        }
        if (c2.alternate !== d2)
          throw Error(p$5(190));
      }
      if (3 !== c2.tag)
        throw Error(p$5(188));
      return c2.stateNode.current === c2 ? a2 : b2;
    }
    function Zb(a2) {
      a2 = Yb(a2);
      return null !== a2 ? $b(a2) : null;
    }
    function $b(a2) {
      if (5 === a2.tag || 6 === a2.tag)
        return a2;
      for (a2 = a2.child; null !== a2; ) {
        var b2 = $b(a2);
        if (null !== b2)
          return b2;
        a2 = a2.sibling;
      }
      return null;
    }
    var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$4 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
    function mc(a2) {
      if (lc && "function" === typeof lc.onCommitFiberRoot)
        try {
          lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
        } catch (b2) {
        }
    }
    var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
    function nc(a2) {
      a2 >>>= 0;
      return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
    }
    var rc = 64, sc = 4194304;
    function tc(a2) {
      switch (a2 & -a2) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return a2 & 4194240;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return a2 & 130023424;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 1073741824;
        default:
          return a2;
      }
    }
    function uc(a2, b2) {
      var c2 = a2.pendingLanes;
      if (0 === c2)
        return 0;
      var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
      if (0 !== g2) {
        var h2 = g2 & ~e2;
        0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
      } else
        g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
      if (0 === d2)
        return 0;
      if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
        return b2;
      0 !== (d2 & 4) && (d2 |= c2 & 16);
      b2 = a2.entangledLanes;
      if (0 !== b2)
        for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
          c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
      return d2;
    }
    function vc(a2, b2) {
      switch (a2) {
        case 1:
        case 2:
        case 4:
          return b2 + 250;
        case 8:
        case 16:
        case 32:
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return b2 + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          return -1;
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function wc(a2, b2) {
      for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
        var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
        if (-1 === k2) {
          if (0 === (h2 & c2) || 0 !== (h2 & d2))
            e2[g2] = vc(h2, b2);
        } else
          k2 <= b2 && (a2.expiredLanes |= h2);
        f2 &= ~h2;
      }
    }
    function xc(a2) {
      a2 = a2.pendingLanes & -1073741825;
      return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
    }
    function yc() {
      var a2 = rc;
      rc <<= 1;
      0 === (rc & 4194240) && (rc = 64);
      return a2;
    }
    function zc(a2) {
      for (var b2 = [], c2 = 0; 31 > c2; c2++)
        b2.push(a2);
      return b2;
    }
    function Ac(a2, b2, c2) {
      a2.pendingLanes |= b2;
      536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
      a2 = a2.eventTimes;
      b2 = 31 - oc(b2);
      a2[b2] = c2;
    }
    function Bc(a2, b2) {
      var c2 = a2.pendingLanes & ~b2;
      a2.pendingLanes = b2;
      a2.suspendedLanes = 0;
      a2.pingedLanes = 0;
      a2.expiredLanes &= b2;
      a2.mutableReadLanes &= b2;
      a2.entangledLanes &= b2;
      b2 = a2.entanglements;
      var d2 = a2.eventTimes;
      for (a2 = a2.expirationTimes; 0 < c2; ) {
        var e2 = 31 - oc(c2), f2 = 1 << e2;
        b2[e2] = 0;
        d2[e2] = -1;
        a2[e2] = -1;
        c2 &= ~f2;
      }
    }
    function Cc(a2, b2) {
      var c2 = a2.entangledLanes |= b2;
      for (a2 = a2.entanglements; c2; ) {
        var d2 = 31 - oc(c2), e2 = 1 << d2;
        e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
        c2 &= ~e2;
      }
    }
    var C$2 = 0;
    function Dc(a2) {
      a2 &= -a2;
      return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
    }
    var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    function Sc(a2, b2) {
      switch (a2) {
        case "focusin":
        case "focusout":
          Lc = null;
          break;
        case "dragenter":
        case "dragleave":
          Mc = null;
          break;
        case "mouseover":
        case "mouseout":
          Nc = null;
          break;
        case "pointerover":
        case "pointerout":
          Oc.delete(b2.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Pc.delete(b2.pointerId);
      }
    }
    function Tc(a2, b2, c2, d2, e2, f2) {
      if (null === a2 || a2.nativeEvent !== f2)
        return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
      a2.eventSystemFlags |= d2;
      b2 = a2.targetContainers;
      null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
      return a2;
    }
    function Uc(a2, b2, c2, d2, e2) {
      switch (b2) {
        case "focusin":
          return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
        case "dragenter":
          return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
        case "mouseover":
          return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
        case "pointerover":
          var f2 = e2.pointerId;
          Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
          return true;
        case "gotpointercapture":
          return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
      }
      return false;
    }
    function Vc(a2) {
      var b2 = Wc(a2.target);
      if (null !== b2) {
        var c2 = Vb(b2);
        if (null !== c2) {
          if (b2 = c2.tag, 13 === b2) {
            if (b2 = Wb(c2), null !== b2) {
              a2.blockedOn = b2;
              Ic(a2.priority, function() {
                Gc(c2);
              });
              return;
            }
          } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
            a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
            return;
          }
        }
      }
      a2.blockedOn = null;
    }
    function Xc(a2) {
      if (null !== a2.blockedOn)
        return false;
      for (var b2 = a2.targetContainers; 0 < b2.length; ) {
        var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
        if (null === c2) {
          c2 = a2.nativeEvent;
          var d2 = new c2.constructor(c2.type, c2);
          wb = d2;
          c2.target.dispatchEvent(d2);
          wb = null;
        } else
          return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
        b2.shift();
      }
      return true;
    }
    function Zc(a2, b2, c2) {
      Xc(a2) && c2.delete(b2);
    }
    function $c() {
      Jc = false;
      null !== Lc && Xc(Lc) && (Lc = null);
      null !== Mc && Xc(Mc) && (Mc = null);
      null !== Nc && Xc(Nc) && (Nc = null);
      Oc.forEach(Zc);
      Pc.forEach(Zc);
    }
    function ad(a2, b2) {
      a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
    }
    function bd(a2) {
      function b2(b3) {
        return ad(b3, a2);
      }
      if (0 < Kc.length) {
        ad(Kc[0], a2);
        for (var c2 = 1; c2 < Kc.length; c2++) {
          var d2 = Kc[c2];
          d2.blockedOn === a2 && (d2.blockedOn = null);
        }
      }
      null !== Lc && ad(Lc, a2);
      null !== Mc && ad(Mc, a2);
      null !== Nc && ad(Nc, a2);
      Oc.forEach(b2);
      Pc.forEach(b2);
      for (c2 = 0; c2 < Qc.length; c2++)
        d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
      for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
        Vc(c2), null === c2.blockedOn && Qc.shift();
    }
    var cd = ua.ReactCurrentBatchConfig, dd = true;
    function ed(a2, b2, c2, d2) {
      var e2 = C$2, f2 = cd.transition;
      cd.transition = null;
      try {
        C$2 = 1, fd(a2, b2, c2, d2);
      } finally {
        C$2 = e2, cd.transition = f2;
      }
    }
    function gd(a2, b2, c2, d2) {
      var e2 = C$2, f2 = cd.transition;
      cd.transition = null;
      try {
        C$2 = 4, fd(a2, b2, c2, d2);
      } finally {
        C$2 = e2, cd.transition = f2;
      }
    }
    function fd(a2, b2, c2, d2) {
      if (dd) {
        var e2 = Yc(a2, b2, c2, d2);
        if (null === e2)
          hd(a2, b2, d2, id, c2), Sc(a2, d2);
        else if (Uc(e2, a2, b2, c2, d2))
          d2.stopPropagation();
        else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
          for (; null !== e2; ) {
            var f2 = Cb(e2);
            null !== f2 && Ec(f2);
            f2 = Yc(a2, b2, c2, d2);
            null === f2 && hd(a2, b2, d2, id, c2);
            if (f2 === e2)
              break;
            e2 = f2;
          }
          null !== e2 && d2.stopPropagation();
        } else
          hd(a2, b2, d2, null, c2);
      }
    }
    var id = null;
    function Yc(a2, b2, c2, d2) {
      id = null;
      a2 = xb(d2);
      a2 = Wc(a2);
      if (null !== a2)
        if (b2 = Vb(a2), null === b2)
          a2 = null;
        else if (c2 = b2.tag, 13 === c2) {
          a2 = Wb(b2);
          if (null !== a2)
            return a2;
          a2 = null;
        } else if (3 === c2) {
          if (b2.stateNode.current.memoizedState.isDehydrated)
            return 3 === b2.tag ? b2.stateNode.containerInfo : null;
          a2 = null;
        } else
          b2 !== a2 && (a2 = null);
      id = a2;
      return null;
    }
    function jd(a2) {
      switch (a2) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 1;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 4;
        case "message":
          switch (ec()) {
            case fc:
              return 1;
            case gc:
              return 4;
            case hc:
            case ic:
              return 16;
            case jc:
              return 536870912;
            default:
              return 16;
          }
        default:
          return 16;
      }
    }
    var kd = null, ld = null, md = null;
    function nd() {
      if (md)
        return md;
      var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
      for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
        ;
      var g2 = c2 - a2;
      for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
        ;
      return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
    }
    function od(a2) {
      var b2 = a2.keyCode;
      "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
      10 === a2 && (a2 = 13);
      return 32 <= a2 || 13 === a2 ? a2 : 0;
    }
    function pd() {
      return true;
    }
    function qd() {
      return false;
    }
    function rd(a2) {
      function b2(b3, d2, e2, f2, g2) {
        this._reactName = b3;
        this._targetInst = e2;
        this.type = d2;
        this.nativeEvent = f2;
        this.target = g2;
        this.currentTarget = null;
        for (var c2 in a2)
          a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
        this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
        this.isPropagationStopped = qd;
        return this;
      }
      A$3(b2.prototype, { preventDefault: function() {
        this.defaultPrevented = true;
        var a3 = this.nativeEvent;
        a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
      }, stopPropagation: function() {
        var a3 = this.nativeEvent;
        a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
      }, persist: function() {
      }, isPersistent: pd });
      return b2;
    }
    var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
      return a2.timeStamp || Date.now();
    }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$3({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$3({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
      return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
    }, movementX: function(a2) {
      if ("movementX" in a2)
        return a2.movementX;
      a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
      return wd;
    }, movementY: function(a2) {
      return "movementY" in a2 ? a2.movementY : xd;
    } }), Bd = rd(Ad), Cd = A$3({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$3({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$3({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$3({}, sd, { clipboardData: function(a2) {
      return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
    } }), Jd = rd(Id), Kd = A$3({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, Nd = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
    function Pd(a2) {
      var b2 = this.nativeEvent;
      return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
    }
    function zd() {
      return Pd;
    }
    var Qd = A$3({}, ud, { key: function(a2) {
      if (a2.key) {
        var b2 = Md[a2.key] || a2.key;
        if ("Unidentified" !== b2)
          return b2;
      }
      return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
    }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
      return "keypress" === a2.type ? od(a2) : 0;
    }, keyCode: function(a2) {
      return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    }, which: function(a2) {
      return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
    } }), Rd = rd(Qd), Sd = A$3({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$3({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$3({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$3({}, Ad, {
      deltaX: function(a2) {
        return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
      },
      deltaY: function(a2) {
        return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$2 = null;
    ia && "documentMode" in document && (be$2 = document.documentMode);
    var ce$2 = ia && "TextEvent" in window && !be$2, de$1 = ia && (!ae$1 || be$2 && 8 < be$2 && 11 >= be$2), ee$2 = String.fromCharCode(32), fe$2 = false;
    function ge$2(a2, b2) {
      switch (a2) {
        case "keyup":
          return -1 !== $d.indexOf(b2.keyCode);
        case "keydown":
          return 229 !== b2.keyCode;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function he$2(a2) {
      a2 = a2.detail;
      return "object" === typeof a2 && "data" in a2 ? a2.data : null;
    }
    var ie$1 = false;
    function je$1(a2, b2) {
      switch (a2) {
        case "compositionend":
          return he$2(b2);
        case "keypress":
          if (32 !== b2.which)
            return null;
          fe$2 = true;
          return ee$2;
        case "textInput":
          return a2 = b2.data, a2 === ee$2 && fe$2 ? null : a2;
        default:
          return null;
      }
    }
    function ke$2(a2, b2) {
      if (ie$1)
        return "compositionend" === a2 || !ae$1 && ge$2(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
      switch (a2) {
        case "paste":
          return null;
        case "keypress":
          if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
            if (b2.char && 1 < b2.char.length)
              return b2.char;
            if (b2.which)
              return String.fromCharCode(b2.which);
          }
          return null;
        case "compositionend":
          return de$1 && "ko" !== b2.locale ? null : b2.data;
        default:
          return null;
      }
    }
    var le$2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
    function me$2(a2) {
      var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return "input" === b2 ? !!le$2[a2.type] : "textarea" === b2 ? true : false;
    }
    function ne$2(a2, b2, c2, d2) {
      Eb(d2);
      b2 = oe$2(b2, "onChange");
      0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
    }
    var pe$2 = null, qe$2 = null;
    function re$2(a2) {
      se$2(a2, 0);
    }
    function te$2(a2) {
      var b2 = ue$2(a2);
      if (Wa(b2))
        return a2;
    }
    function ve$2(a2, b2) {
      if ("change" === a2)
        return b2;
    }
    var we$2 = false;
    if (ia) {
      var xe$1;
      if (ia) {
        var ye$2 = "oninput" in document;
        if (!ye$2) {
          var ze$2 = document.createElement("div");
          ze$2.setAttribute("oninput", "return;");
          ye$2 = "function" === typeof ze$2.oninput;
        }
        xe$1 = ye$2;
      } else
        xe$1 = false;
      we$2 = xe$1 && (!document.documentMode || 9 < document.documentMode);
    }
    function Ae$2() {
      pe$2 && (pe$2.detachEvent("onpropertychange", Be$2), qe$2 = pe$2 = null);
    }
    function Be$2(a2) {
      if ("value" === a2.propertyName && te$2(qe$2)) {
        var b2 = [];
        ne$2(b2, qe$2, a2, xb(a2));
        Jb(re$2, b2);
      }
    }
    function Ce$2(a2, b2, c2) {
      "focusin" === a2 ? (Ae$2(), pe$2 = b2, qe$2 = c2, pe$2.attachEvent("onpropertychange", Be$2)) : "focusout" === a2 && Ae$2();
    }
    function De$2(a2) {
      if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
        return te$2(qe$2);
    }
    function Ee$1(a2, b2) {
      if ("click" === a2)
        return te$2(b2);
    }
    function Fe$1(a2, b2) {
      if ("input" === a2 || "change" === a2)
        return te$2(b2);
    }
    function Ge$2(a2, b2) {
      return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var He$2 = "function" === typeof Object.is ? Object.is : Ge$2;
    function Ie$2(a2, b2) {
      if (He$2(a2, b2))
        return true;
      if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
        return false;
      var c2 = Object.keys(a2), d2 = Object.keys(b2);
      if (c2.length !== d2.length)
        return false;
      for (d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2];
        if (!ja.call(b2, e2) || !He$2(a2[e2], b2[e2]))
          return false;
      }
      return true;
    }
    function Je$1(a2) {
      for (; a2 && a2.firstChild; )
        a2 = a2.firstChild;
      return a2;
    }
    function Ke$2(a2, b2) {
      var c2 = Je$1(a2);
      a2 = 0;
      for (var d2; c2; ) {
        if (3 === c2.nodeType) {
          d2 = a2 + c2.textContent.length;
          if (a2 <= b2 && d2 >= b2)
            return { node: c2, offset: b2 - a2 };
          a2 = d2;
        }
        a: {
          for (; c2; ) {
            if (c2.nextSibling) {
              c2 = c2.nextSibling;
              break a;
            }
            c2 = c2.parentNode;
          }
          c2 = void 0;
        }
        c2 = Je$1(c2);
      }
    }
    function Le$2(a2, b2) {
      return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$2(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
    }
    function Me$2() {
      for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
        try {
          var c2 = "string" === typeof b2.contentWindow.location.href;
        } catch (d2) {
          c2 = false;
        }
        if (c2)
          a2 = b2.contentWindow;
        else
          break;
        b2 = Xa(a2.document);
      }
      return b2;
    }
    function Ne$2(a2) {
      var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
      return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
    }
    function Oe$2(a2) {
      var b2 = Me$2(), c2 = a2.focusedElem, d2 = a2.selectionRange;
      if (b2 !== c2 && c2 && c2.ownerDocument && Le$2(c2.ownerDocument.documentElement, c2)) {
        if (null !== d2 && Ne$2(c2)) {
          if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
            c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
          else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
            a2 = a2.getSelection();
            var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
            d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
            !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
            e2 = Ke$2(c2, f2);
            var g2 = Ke$2(
              c2,
              d2
            );
            e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
          }
        }
        b2 = [];
        for (a2 = c2; a2 = a2.parentNode; )
          1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
        "function" === typeof c2.focus && c2.focus();
        for (c2 = 0; c2 < b2.length; c2++)
          a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
      }
    }
    var Pe$2 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$2 = null, Re$2 = null, Se$2 = null, Te$2 = false;
    function Ue$1(a2, b2, c2) {
      var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
      Te$2 || null == Qe$2 || Qe$2 !== Xa(d2) || (d2 = Qe$2, "selectionStart" in d2 && Ne$2(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$2 && Ie$2(Se$2, d2) || (Se$2 = d2, d2 = oe$2(Re$2, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$2)));
    }
    function Ve$1(a2, b2) {
      var c2 = {};
      c2[a2.toLowerCase()] = b2.toLowerCase();
      c2["Webkit" + a2] = "webkit" + b2;
      c2["Moz" + a2] = "moz" + b2;
      return c2;
    }
    var We$2 = { animationend: Ve$1("Animation", "AnimationEnd"), animationiteration: Ve$1("Animation", "AnimationIteration"), animationstart: Ve$1("Animation", "AnimationStart"), transitionend: Ve$1("Transition", "TransitionEnd") }, Xe$2 = {}, Ye$2 = {};
    ia && (Ye$2 = document.createElement("div").style, "AnimationEvent" in window || (delete We$2.animationend.animation, delete We$2.animationiteration.animation, delete We$2.animationstart.animation), "TransitionEvent" in window || delete We$2.transitionend.transition);
    function Ze$2(a2) {
      if (Xe$2[a2])
        return Xe$2[a2];
      if (!We$2[a2])
        return a2;
      var b2 = We$2[a2], c2;
      for (c2 in b2)
        if (b2.hasOwnProperty(c2) && c2 in Ye$2)
          return Xe$2[a2] = b2[c2];
      return a2;
    }
    var $e$2 = Ze$2("animationend"), af = Ze$2("animationiteration"), bf = Ze$2("animationstart"), cf = Ze$2("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    function ff(a2, b2) {
      df.set(a2, b2);
      fa(b2, [a2]);
    }
    for (var gf = 0; gf < ef.length; gf++) {
      var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
      ff(jf, "on" + kf);
    }
    ff($e$2, "onAnimationEnd");
    ff(af, "onAnimationIteration");
    ff(bf, "onAnimationStart");
    ff("dblclick", "onDoubleClick");
    ff("focusin", "onFocus");
    ff("focusout", "onBlur");
    ff(cf, "onTransitionEnd");
    ha("onMouseEnter", ["mouseout", "mouseover"]);
    ha("onMouseLeave", ["mouseout", "mouseover"]);
    ha("onPointerEnter", ["pointerout", "pointerover"]);
    ha("onPointerLeave", ["pointerout", "pointerover"]);
    fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
    fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
    fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
    fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
    fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    function nf(a2, b2, c2) {
      var d2 = a2.type || "unknown-event";
      a2.currentTarget = c2;
      Ub(d2, b2, void 0, a2);
      a2.currentTarget = null;
    }
    function se$2(a2, b2) {
      b2 = 0 !== (b2 & 4);
      for (var c2 = 0; c2 < a2.length; c2++) {
        var d2 = a2[c2], e2 = d2.event;
        d2 = d2.listeners;
        a: {
          var f2 = void 0;
          if (b2)
            for (var g2 = d2.length - 1; 0 <= g2; g2--) {
              var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
          else
            for (g2 = 0; g2 < d2.length; g2++) {
              h2 = d2[g2];
              k2 = h2.instance;
              l2 = h2.currentTarget;
              h2 = h2.listener;
              if (k2 !== f2 && e2.isPropagationStopped())
                break a;
              nf(e2, h2, l2);
              f2 = k2;
            }
        }
      }
      if (Qb)
        throw a2 = Rb, Qb = false, Rb = null, a2;
    }
    function D$4(a2, b2) {
      var c2 = b2[of];
      void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
      var d2 = a2 + "__bubble";
      c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
    }
    function qf(a2, b2, c2) {
      var d2 = 0;
      b2 && (d2 |= 4);
      pf(c2, a2, d2, b2);
    }
    var rf = "_reactListening" + Math.random().toString(36).slice(2);
    function sf(a2) {
      if (!a2[rf]) {
        a2[rf] = true;
        da.forEach(function(b3) {
          "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
        });
        var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
        null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
      }
    }
    function pf(a2, b2, c2, d2) {
      switch (jd(b2)) {
        case 1:
          var e2 = ed;
          break;
        case 4:
          e2 = gd;
          break;
        default:
          e2 = fd;
      }
      c2 = e2.bind(null, b2, c2, a2);
      e2 = void 0;
      !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
      d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
    }
    function hd(a2, b2, c2, d2, e2) {
      var f2 = d2;
      if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
        a:
          for (; ; ) {
            if (null === d2)
              return;
            var g2 = d2.tag;
            if (3 === g2 || 4 === g2) {
              var h2 = d2.stateNode.containerInfo;
              if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
                break;
              if (4 === g2)
                for (g2 = d2.return; null !== g2; ) {
                  var k2 = g2.tag;
                  if (3 === k2 || 4 === k2) {
                    if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                      return;
                  }
                  g2 = g2.return;
                }
              for (; null !== h2; ) {
                g2 = Wc(h2);
                if (null === g2)
                  return;
                k2 = g2.tag;
                if (5 === k2 || 6 === k2) {
                  d2 = f2 = g2;
                  continue a;
                }
                h2 = h2.parentNode;
              }
            }
            d2 = d2.return;
          }
      Jb(function() {
        var d3 = f2, e3 = xb(c2), g3 = [];
        a: {
          var h3 = df.get(a2);
          if (void 0 !== h3) {
            var k3 = td, n2 = a2;
            switch (a2) {
              case "keypress":
                if (0 === od(c2))
                  break a;
              case "keydown":
              case "keyup":
                k3 = Rd;
                break;
              case "focusin":
                n2 = "focus";
                k3 = Fd;
                break;
              case "focusout":
                n2 = "blur";
                k3 = Fd;
                break;
              case "beforeblur":
              case "afterblur":
                k3 = Fd;
                break;
              case "click":
                if (2 === c2.button)
                  break a;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                k3 = Bd;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                k3 = Dd;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                k3 = Vd;
                break;
              case $e$2:
              case af:
              case bf:
                k3 = Hd;
                break;
              case cf:
                k3 = Xd;
                break;
              case "scroll":
                k3 = vd;
                break;
              case "wheel":
                k3 = Zd;
                break;
              case "copy":
              case "cut":
              case "paste":
                k3 = Jd;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                k3 = Td;
            }
            var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
            t2 = [];
            for (var w2 = d3, u2; null !== w2; ) {
              u2 = w2;
              var F2 = u2.stateNode;
              5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
              if (J2)
                break;
              w2 = w2.return;
            }
            0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
          }
        }
        if (0 === (b2 & 7)) {
          a: {
            h3 = "mouseover" === a2 || "pointerover" === a2;
            k3 = "mouseout" === a2 || "pointerout" === a2;
            if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
              break a;
            if (k3 || h3) {
              h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
              if (k3) {
                if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
                  n2 = null;
              } else
                k3 = null, n2 = d3;
              if (k3 !== n2) {
                t2 = Bd;
                F2 = "onMouseLeave";
                x2 = "onMouseEnter";
                w2 = "mouse";
                if ("pointerout" === a2 || "pointerover" === a2)
                  t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
                J2 = null == k3 ? h3 : ue$2(k3);
                u2 = null == n2 ? h3 : ue$2(n2);
                h3 = new t2(F2, w2 + "leave", k3, c2, e3);
                h3.target = J2;
                h3.relatedTarget = u2;
                F2 = null;
                Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
                J2 = F2;
                if (k3 && n2)
                  b: {
                    t2 = k3;
                    x2 = n2;
                    w2 = 0;
                    for (u2 = t2; u2; u2 = vf(u2))
                      w2++;
                    u2 = 0;
                    for (F2 = x2; F2; F2 = vf(F2))
                      u2++;
                    for (; 0 < w2 - u2; )
                      t2 = vf(t2), w2--;
                    for (; 0 < u2 - w2; )
                      x2 = vf(x2), u2--;
                    for (; w2--; ) {
                      if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                        break b;
                      t2 = vf(t2);
                      x2 = vf(x2);
                    }
                    t2 = null;
                  }
                else
                  t2 = null;
                null !== k3 && wf(g3, h3, k3, t2, false);
                null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
              }
            }
          }
          a: {
            h3 = d3 ? ue$2(d3) : window;
            k3 = h3.nodeName && h3.nodeName.toLowerCase();
            if ("select" === k3 || "input" === k3 && "file" === h3.type)
              var na = ve$2;
            else if (me$2(h3))
              if (we$2)
                na = Fe$1;
              else {
                na = De$2;
                var xa = Ce$2;
              }
            else
              (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$1);
            if (na && (na = na(a2, d3))) {
              ne$2(g3, na, c2, e3);
              break a;
            }
            xa && xa(a2, h3, d3);
            "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
          }
          xa = d3 ? ue$2(d3) : window;
          switch (a2) {
            case "focusin":
              if (me$2(xa) || "true" === xa.contentEditable)
                Qe$2 = xa, Re$2 = d3, Se$2 = null;
              break;
            case "focusout":
              Se$2 = Re$2 = Qe$2 = null;
              break;
            case "mousedown":
              Te$2 = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Te$2 = false;
              Ue$1(g3, c2, e3);
              break;
            case "selectionchange":
              if (Pe$2)
                break;
            case "keydown":
            case "keyup":
              Ue$1(g3, c2, e3);
          }
          var $a;
          if (ae$1)
            b: {
              switch (a2) {
                case "compositionstart":
                  var ba = "onCompositionStart";
                  break b;
                case "compositionend":
                  ba = "onCompositionEnd";
                  break b;
                case "compositionupdate":
                  ba = "onCompositionUpdate";
                  break b;
              }
              ba = void 0;
            }
          else
            ie$1 ? ge$2(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
          ba && (de$1 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$2(c2), null !== $a && (ba.data = $a))));
          if ($a = ce$2 ? je$1(a2, c2) : ke$2(a2, c2))
            d3 = oe$2(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
        }
        se$2(g3, b2);
      });
    }
    function tf(a2, b2, c2) {
      return { instance: a2, listener: b2, currentTarget: c2 };
    }
    function oe$2(a2, b2) {
      for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
        var e2 = a2, f2 = e2.stateNode;
        5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
        a2 = a2.return;
      }
      return d2;
    }
    function vf(a2) {
      if (null === a2)
        return null;
      do
        a2 = a2.return;
      while (a2 && 5 !== a2.tag);
      return a2 ? a2 : null;
    }
    function wf(a2, b2, c2, d2, e2) {
      for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
        var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
        if (null !== k2 && k2 === d2)
          break;
        5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
        c2 = c2.return;
      }
      0 !== g2.length && a2.push({ event: b2, listeners: g2 });
    }
    var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
    function zf(a2) {
      return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
    }
    function Af(a2, b2, c2) {
      b2 = zf(b2);
      if (zf(a2) !== b2 && c2)
        throw Error(p$5(425));
    }
    function Bf() {
    }
    var Cf = null, Df = null;
    function Ef(a2, b2) {
      return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
    }
    var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
      return Hf.resolve(null).then(a2).catch(If);
    } : Ff;
    function If(a2) {
      setTimeout(function() {
        throw a2;
      });
    }
    function Kf(a2, b2) {
      var c2 = b2, d2 = 0;
      do {
        var e2 = c2.nextSibling;
        a2.removeChild(c2);
        if (e2 && 8 === e2.nodeType)
          if (c2 = e2.data, "/$" === c2) {
            if (0 === d2) {
              a2.removeChild(e2);
              bd(b2);
              return;
            }
            d2--;
          } else
            "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
        c2 = e2;
      } while (c2);
      bd(b2);
    }
    function Lf(a2) {
      for (; null != a2; a2 = a2.nextSibling) {
        var b2 = a2.nodeType;
        if (1 === b2 || 3 === b2)
          break;
        if (8 === b2) {
          b2 = a2.data;
          if ("$" === b2 || "$!" === b2 || "$?" === b2)
            break;
          if ("/$" === b2)
            return null;
        }
      }
      return a2;
    }
    function Mf(a2) {
      a2 = a2.previousSibling;
      for (var b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("$" === c2 || "$!" === c2 || "$?" === c2) {
            if (0 === b2)
              return a2;
            b2--;
          } else
            "/$" === c2 && b2++;
        }
        a2 = a2.previousSibling;
      }
      return null;
    }
    var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
    function Wc(a2) {
      var b2 = a2[Of];
      if (b2)
        return b2;
      for (var c2 = a2.parentNode; c2; ) {
        if (b2 = c2[uf] || c2[Of]) {
          c2 = b2.alternate;
          if (null !== b2.child || null !== c2 && null !== c2.child)
            for (a2 = Mf(a2); null !== a2; ) {
              if (c2 = a2[Of])
                return c2;
              a2 = Mf(a2);
            }
          return b2;
        }
        a2 = c2;
        c2 = a2.parentNode;
      }
      return null;
    }
    function Cb(a2) {
      a2 = a2[Of] || a2[uf];
      return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
    }
    function ue$2(a2) {
      if (5 === a2.tag || 6 === a2.tag)
        return a2.stateNode;
      throw Error(p$5(33));
    }
    function Db(a2) {
      return a2[Pf] || null;
    }
    var Sf = [], Tf = -1;
    function Uf(a2) {
      return { current: a2 };
    }
    function E$2(a2) {
      0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
    }
    function G$3(a2, b2) {
      Tf++;
      Sf[Tf] = a2.current;
      a2.current = b2;
    }
    var Vf = {}, H$3 = Uf(Vf), Wf = Uf(false), Xf = Vf;
    function Yf(a2, b2) {
      var c2 = a2.type.contextTypes;
      if (!c2)
        return Vf;
      var d2 = a2.stateNode;
      if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
        return d2.__reactInternalMemoizedMaskedChildContext;
      var e2 = {}, f2;
      for (f2 in c2)
        e2[f2] = b2[f2];
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
      return e2;
    }
    function Zf(a2) {
      a2 = a2.childContextTypes;
      return null !== a2 && void 0 !== a2;
    }
    function $f() {
      E$2(Wf);
      E$2(H$3);
    }
    function ag(a2, b2, c2) {
      if (H$3.current !== Vf)
        throw Error(p$5(168));
      G$3(H$3, b2);
      G$3(Wf, c2);
    }
    function bg(a2, b2, c2) {
      var d2 = a2.stateNode;
      b2 = b2.childContextTypes;
      if ("function" !== typeof d2.getChildContext)
        return c2;
      d2 = d2.getChildContext();
      for (var e2 in d2)
        if (!(e2 in b2))
          throw Error(p$5(108, Ra(a2) || "Unknown", e2));
      return A$3({}, c2, d2);
    }
    function cg(a2) {
      a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
      Xf = H$3.current;
      G$3(H$3, a2);
      G$3(Wf, Wf.current);
      return true;
    }
    function dg(a2, b2, c2) {
      var d2 = a2.stateNode;
      if (!d2)
        throw Error(p$5(169));
      c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$3), G$3(H$3, a2)) : E$2(Wf);
      G$3(Wf, c2);
    }
    var eg = null, fg = false, gg = false;
    function hg(a2) {
      null === eg ? eg = [a2] : eg.push(a2);
    }
    function ig(a2) {
      fg = true;
      hg(a2);
    }
    function jg() {
      if (!gg && null !== eg) {
        gg = true;
        var a2 = 0, b2 = C$2;
        try {
          var c2 = eg;
          for (C$2 = 1; a2 < c2.length; a2++) {
            var d2 = c2[a2];
            do
              d2 = d2(true);
            while (null !== d2);
          }
          eg = null;
          fg = false;
        } catch (e2) {
          throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
        } finally {
          C$2 = b2, gg = false;
        }
      }
      return null;
    }
    var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
    function tg(a2, b2) {
      kg[lg++] = ng;
      kg[lg++] = mg;
      mg = a2;
      ng = b2;
    }
    function ug(a2, b2, c2) {
      og[pg++] = rg;
      og[pg++] = sg;
      og[pg++] = qg;
      qg = a2;
      var d2 = rg;
      a2 = sg;
      var e2 = 32 - oc(d2) - 1;
      d2 &= ~(1 << e2);
      c2 += 1;
      var f2 = 32 - oc(b2) + e2;
      if (30 < f2) {
        var g2 = e2 - e2 % 5;
        f2 = (d2 & (1 << g2) - 1).toString(32);
        d2 >>= g2;
        e2 -= g2;
        rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
        sg = f2 + a2;
      } else
        rg = 1 << f2 | c2 << e2 | d2, sg = a2;
    }
    function vg(a2) {
      null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
    }
    function wg(a2) {
      for (; a2 === mg; )
        mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
      for (; a2 === qg; )
        qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
    }
    var xg = null, yg = null, I$3 = false, zg = null;
    function Ag(a2, b2) {
      var c2 = Bg(5, null, null, 0);
      c2.elementType = "DELETED";
      c2.stateNode = b2;
      c2.return = a2;
      b2 = a2.deletions;
      null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
    }
    function Cg(a2, b2) {
      switch (a2.tag) {
        case 5:
          var c2 = a2.type;
          b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
          return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
        case 6:
          return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
        case 13:
          return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
        default:
          return false;
      }
    }
    function Dg(a2) {
      return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
    }
    function Eg(a2) {
      if (I$3) {
        var b2 = yg;
        if (b2) {
          var c2 = b2;
          if (!Cg(a2, b2)) {
            if (Dg(a2))
              throw Error(p$5(418));
            b2 = Lf(c2.nextSibling);
            var d2 = xg;
            b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$3 = false, xg = a2);
          }
        } else {
          if (Dg(a2))
            throw Error(p$5(418));
          a2.flags = a2.flags & -4097 | 2;
          I$3 = false;
          xg = a2;
        }
      }
    }
    function Fg(a2) {
      for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
        a2 = a2.return;
      xg = a2;
    }
    function Gg(a2) {
      if (a2 !== xg)
        return false;
      if (!I$3)
        return Fg(a2), I$3 = true, false;
      var b2;
      (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
      if (b2 && (b2 = yg)) {
        if (Dg(a2))
          throw Hg(), Error(p$5(418));
        for (; b2; )
          Ag(a2, b2), b2 = Lf(b2.nextSibling);
      }
      Fg(a2);
      if (13 === a2.tag) {
        a2 = a2.memoizedState;
        a2 = null !== a2 ? a2.dehydrated : null;
        if (!a2)
          throw Error(p$5(317));
        a: {
          a2 = a2.nextSibling;
          for (b2 = 0; a2; ) {
            if (8 === a2.nodeType) {
              var c2 = a2.data;
              if ("/$" === c2) {
                if (0 === b2) {
                  yg = Lf(a2.nextSibling);
                  break a;
                }
                b2--;
              } else
                "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
            }
            a2 = a2.nextSibling;
          }
          yg = null;
        }
      } else
        yg = xg ? Lf(a2.stateNode.nextSibling) : null;
      return true;
    }
    function Hg() {
      for (var a2 = yg; a2; )
        a2 = Lf(a2.nextSibling);
    }
    function Ig() {
      yg = xg = null;
      I$3 = false;
    }
    function Jg(a2) {
      null === zg ? zg = [a2] : zg.push(a2);
    }
    var Kg = ua.ReactCurrentBatchConfig;
    function Lg(a2, b2) {
      if (a2 && a2.defaultProps) {
        b2 = A$3({}, b2);
        a2 = a2.defaultProps;
        for (var c2 in a2)
          void 0 === b2[c2] && (b2[c2] = a2[c2]);
        return b2;
      }
      return b2;
    }
    var Mg = Uf(null), Ng = null, Og = null, Pg = null;
    function Qg() {
      Pg = Og = Ng = null;
    }
    function Rg(a2) {
      var b2 = Mg.current;
      E$2(Mg);
      a2._currentValue = b2;
    }
    function Sg(a2, b2, c2) {
      for (; null !== a2; ) {
        var d2 = a2.alternate;
        (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
        if (a2 === c2)
          break;
        a2 = a2.return;
      }
    }
    function Tg(a2, b2) {
      Ng = a2;
      Pg = Og = null;
      a2 = a2.dependencies;
      null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
    }
    function Vg(a2) {
      var b2 = a2._currentValue;
      if (Pg !== a2)
        if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
          if (null === Ng)
            throw Error(p$5(308));
          Og = a2;
          Ng.dependencies = { lanes: 0, firstContext: a2 };
        } else
          Og = Og.next = a2;
      return b2;
    }
    var Wg = null;
    function Xg(a2) {
      null === Wg ? Wg = [a2] : Wg.push(a2);
    }
    function Yg(a2, b2, c2, d2) {
      var e2 = b2.interleaved;
      null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
      b2.interleaved = c2;
      return Zg(a2, d2);
    }
    function Zg(a2, b2) {
      a2.lanes |= b2;
      var c2 = a2.alternate;
      null !== c2 && (c2.lanes |= b2);
      c2 = a2;
      for (a2 = a2.return; null !== a2; )
        a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
      return 3 === c2.tag ? c2.stateNode : null;
    }
    var $g = false;
    function ah(a2) {
      a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
    }
    function bh(a2, b2) {
      a2 = a2.updateQueue;
      b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
    }
    function ch(a2, b2) {
      return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
    }
    function dh(a2, b2, c2) {
      var d2 = a2.updateQueue;
      if (null === d2)
        return null;
      d2 = d2.shared;
      if (0 !== (K$2 & 2)) {
        var e2 = d2.pending;
        null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
        d2.pending = b2;
        return Zg(a2, c2);
      }
      e2 = d2.interleaved;
      null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
      d2.interleaved = b2;
      return Zg(a2, c2);
    }
    function eh(a2, b2, c2) {
      b2 = b2.updateQueue;
      if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
        var d2 = b2.lanes;
        d2 &= a2.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a2, c2);
      }
    }
    function fh(a2, b2) {
      var c2 = a2.updateQueue, d2 = a2.alternate;
      if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
        var e2 = null, f2 = null;
        c2 = c2.firstBaseUpdate;
        if (null !== c2) {
          do {
            var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
            null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
            c2 = c2.next;
          } while (null !== c2);
          null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
        } else
          e2 = f2 = b2;
        c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
        a2.updateQueue = c2;
        return;
      }
      a2 = c2.lastBaseUpdate;
      null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
      c2.lastBaseUpdate = b2;
    }
    function gh(a2, b2, c2, d2) {
      var e2 = a2.updateQueue;
      $g = false;
      var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
      if (null !== h2) {
        e2.shared.pending = null;
        var k2 = h2, l2 = k2.next;
        k2.next = null;
        null === g2 ? f2 = l2 : g2.next = l2;
        g2 = k2;
        var m2 = a2.alternate;
        null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
      }
      if (null !== f2) {
        var q2 = e2.baseState;
        g2 = 0;
        m2 = l2 = k2 = null;
        h2 = f2;
        do {
          var r2 = h2.lane, y2 = h2.eventTime;
          if ((d2 & r2) === r2) {
            null !== m2 && (m2 = m2.next = {
              eventTime: y2,
              lane: 0,
              tag: h2.tag,
              payload: h2.payload,
              callback: h2.callback,
              next: null
            });
            a: {
              var n2 = a2, t2 = h2;
              r2 = b2;
              y2 = c2;
              switch (t2.tag) {
                case 1:
                  n2 = t2.payload;
                  if ("function" === typeof n2) {
                    q2 = n2.call(y2, q2, r2);
                    break a;
                  }
                  q2 = n2;
                  break a;
                case 3:
                  n2.flags = n2.flags & -65537 | 128;
                case 0:
                  n2 = t2.payload;
                  r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
                  if (null === r2 || void 0 === r2)
                    break a;
                  q2 = A$3({}, q2, r2);
                  break a;
                case 2:
                  $g = true;
              }
            }
            null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
          } else
            y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
          h2 = h2.next;
          if (null === h2)
            if (h2 = e2.shared.pending, null === h2)
              break;
            else
              r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
        } while (1);
        null === m2 && (k2 = q2);
        e2.baseState = k2;
        e2.firstBaseUpdate = l2;
        e2.lastBaseUpdate = m2;
        b2 = e2.shared.interleaved;
        if (null !== b2) {
          e2 = b2;
          do
            g2 |= e2.lane, e2 = e2.next;
          while (e2 !== b2);
        } else
          null === f2 && (e2.shared.lanes = 0);
        hh |= g2;
        a2.lanes = g2;
        a2.memoizedState = q2;
      }
    }
    function ih(a2, b2, c2) {
      a2 = b2.effects;
      b2.effects = null;
      if (null !== a2)
        for (b2 = 0; b2 < a2.length; b2++) {
          var d2 = a2[b2], e2 = d2.callback;
          if (null !== e2) {
            d2.callback = null;
            d2 = c2;
            if ("function" !== typeof e2)
              throw Error(p$5(191, e2));
            e2.call(d2);
          }
        }
    }
    var jh = new aa.Component().refs;
    function kh(a2, b2, c2, d2) {
      b2 = a2.memoizedState;
      c2 = c2(d2, b2);
      c2 = null === c2 || void 0 === c2 ? b2 : A$3({}, b2, c2);
      a2.memoizedState = c2;
      0 === a2.lanes && (a2.updateQueue.baseState = c2);
    }
    var nh = { isMounted: function(a2) {
      return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
    }, enqueueSetState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = L$4(), e2 = lh(a2), f2 = ch(d2, e2);
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a2, f2, e2);
      null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
    }, enqueueReplaceState: function(a2, b2, c2) {
      a2 = a2._reactInternals;
      var d2 = L$4(), e2 = lh(a2), f2 = ch(d2, e2);
      f2.tag = 1;
      f2.payload = b2;
      void 0 !== c2 && null !== c2 && (f2.callback = c2);
      b2 = dh(a2, f2, e2);
      null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
    }, enqueueForceUpdate: function(a2, b2) {
      a2 = a2._reactInternals;
      var c2 = L$4(), d2 = lh(a2), e2 = ch(c2, d2);
      e2.tag = 2;
      void 0 !== b2 && null !== b2 && (e2.callback = b2);
      b2 = dh(a2, e2, d2);
      null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
    } };
    function oh(a2, b2, c2, d2, e2, f2, g2) {
      a2 = a2.stateNode;
      return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$2(c2, d2) || !Ie$2(e2, f2) : true;
    }
    function ph(a2, b2, c2) {
      var d2 = false, e2 = Vf;
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$3.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
      b2 = new b2(c2, f2);
      a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
      b2.updater = nh;
      a2.stateNode = b2;
      b2._reactInternals = a2;
      d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
      return b2;
    }
    function qh(a2, b2, c2, d2) {
      a2 = b2.state;
      "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
      "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
      b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
    }
    function rh(a2, b2, c2, d2) {
      var e2 = a2.stateNode;
      e2.props = c2;
      e2.state = a2.memoizedState;
      e2.refs = jh;
      ah(a2);
      var f2 = b2.contextType;
      "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$3.current, e2.context = Yf(a2, f2));
      e2.state = a2.memoizedState;
      f2 = b2.getDerivedStateFromProps;
      "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
      "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
      "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
    }
    function sh(a2, b2, c2) {
      a2 = c2.ref;
      if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
        if (c2._owner) {
          c2 = c2._owner;
          if (c2) {
            if (1 !== c2.tag)
              throw Error(p$5(309));
            var d2 = c2.stateNode;
          }
          if (!d2)
            throw Error(p$5(147, a2));
          var e2 = d2, f2 = "" + a2;
          if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
            return b2.ref;
          b2 = function(a3) {
            var b3 = e2.refs;
            b3 === jh && (b3 = e2.refs = {});
            null === a3 ? delete b3[f2] : b3[f2] = a3;
          };
          b2._stringRef = f2;
          return b2;
        }
        if ("string" !== typeof a2)
          throw Error(p$5(284));
        if (!c2._owner)
          throw Error(p$5(290, a2));
      }
      return a2;
    }
    function th(a2, b2) {
      a2 = Object.prototype.toString.call(b2);
      throw Error(p$5(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
    }
    function uh(a2) {
      var b2 = a2._init;
      return b2(a2._payload);
    }
    function vh(a2) {
      function b2(b3, c3) {
        if (a2) {
          var d3 = b3.deletions;
          null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
        }
      }
      function c2(c3, d3) {
        if (!a2)
          return null;
        for (; null !== d3; )
          b2(c3, d3), d3 = d3.sibling;
        return null;
      }
      function d2(a3, b3) {
        for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
          null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
        return a3;
      }
      function e2(a3, b3) {
        a3 = wh(a3, b3);
        a3.index = 0;
        a3.sibling = null;
        return a3;
      }
      function f2(b3, c3, d3) {
        b3.index = d3;
        if (!a2)
          return b3.flags |= 1048576, c3;
        d3 = b3.alternate;
        if (null !== d3)
          return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
        b3.flags |= 2;
        return c3;
      }
      function g2(b3) {
        a2 && null === b3.alternate && (b3.flags |= 2);
        return b3;
      }
      function h2(a3, b3, c3, d3) {
        if (null === b3 || 6 !== b3.tag)
          return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
        b3 = e2(b3, c3);
        b3.return = a3;
        return b3;
      }
      function k2(a3, b3, c3, d3) {
        var f3 = c3.type;
        if (f3 === ya)
          return m2(a3, b3, c3.props.children, d3, c3.key);
        if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
          return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
        d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
        d3.ref = sh(a3, b3, c3);
        d3.return = a3;
        return d3;
      }
      function l2(a3, b3, c3, d3) {
        if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
          return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
        b3 = e2(b3, c3.children || []);
        b3.return = a3;
        return b3;
      }
      function m2(a3, b3, c3, d3, f3) {
        if (null === b3 || 7 !== b3.tag)
          return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
        b3 = e2(b3, c3);
        b3.return = a3;
        return b3;
      }
      function q2(a3, b3, c3) {
        if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
          return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
        if ("object" === typeof b3 && null !== b3) {
          switch (b3.$$typeof) {
            case va:
              return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
            case wa:
              return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
            case Ha:
              var d3 = b3._init;
              return q2(a3, d3(b3._payload), c3);
          }
          if (eb(b3) || Ka(b3))
            return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
          th(a3, b3);
        }
        return null;
      }
      function r2(a3, b3, c3, d3) {
        var e3 = null !== b3 ? b3.key : null;
        if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
          return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
        if ("object" === typeof c3 && null !== c3) {
          switch (c3.$$typeof) {
            case va:
              return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
            case wa:
              return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
            case Ha:
              return e3 = c3._init, r2(
                a3,
                b3,
                e3(c3._payload),
                d3
              );
          }
          if (eb(c3) || Ka(c3))
            return null !== e3 ? null : m2(a3, b3, c3, d3, null);
          th(a3, c3);
        }
        return null;
      }
      function y2(a3, b3, c3, d3, e3) {
        if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
          return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
        if ("object" === typeof d3 && null !== d3) {
          switch (d3.$$typeof) {
            case va:
              return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
            case wa:
              return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
            case Ha:
              var f3 = d3._init;
              return y2(a3, b3, c3, f3(d3._payload), e3);
          }
          if (eb(d3) || Ka(d3))
            return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
          th(b3, d3);
        }
        return null;
      }
      function n2(e3, g3, h3, k3) {
        for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
          u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
          var n3 = r2(e3, u2, h3[w2], k3);
          if (null === n3) {
            null === u2 && (u2 = x2);
            break;
          }
          a2 && u2 && null === n3.alternate && b2(e3, u2);
          g3 = f2(n3, g3, w2);
          null === m3 ? l3 = n3 : m3.sibling = n3;
          m3 = n3;
          u2 = x2;
        }
        if (w2 === h3.length)
          return c2(e3, u2), I$3 && tg(e3, w2), l3;
        if (null === u2) {
          for (; w2 < h3.length; w2++)
            u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
          I$3 && tg(e3, w2);
          return l3;
        }
        for (u2 = d2(e3, u2); w2 < h3.length; w2++)
          x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
        a2 && u2.forEach(function(a3) {
          return b2(e3, a3);
        });
        I$3 && tg(e3, w2);
        return l3;
      }
      function t2(e3, g3, h3, k3) {
        var l3 = Ka(h3);
        if ("function" !== typeof l3)
          throw Error(p$5(150));
        h3 = l3.call(h3);
        if (null == h3)
          throw Error(p$5(151));
        for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
          m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
          var t3 = r2(e3, m3, n3.value, k3);
          if (null === t3) {
            null === m3 && (m3 = x2);
            break;
          }
          a2 && m3 && null === t3.alternate && b2(e3, m3);
          g3 = f2(t3, g3, w2);
          null === u2 ? l3 = t3 : u2.sibling = t3;
          u2 = t3;
          m3 = x2;
        }
        if (n3.done)
          return c2(
            e3,
            m3
          ), I$3 && tg(e3, w2), l3;
        if (null === m3) {
          for (; !n3.done; w2++, n3 = h3.next())
            n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
          I$3 && tg(e3, w2);
          return l3;
        }
        for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
          n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
        a2 && m3.forEach(function(a3) {
          return b2(e3, a3);
        });
        I$3 && tg(e3, w2);
        return l3;
      }
      function J2(a3, d3, f3, h3) {
        "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
        if ("object" === typeof f3 && null !== f3) {
          switch (f3.$$typeof) {
            case va:
              a: {
                for (var k3 = f3.key, l3 = d3; null !== l3; ) {
                  if (l3.key === k3) {
                    k3 = f3.type;
                    if (k3 === ya) {
                      if (7 === l3.tag) {
                        c2(a3, l3.sibling);
                        d3 = e2(l3, f3.props.children);
                        d3.return = a3;
                        a3 = d3;
                        break a;
                      }
                    } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                      c2(a3, l3.sibling);
                      d3 = e2(l3, f3.props);
                      d3.ref = sh(a3, l3, f3);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    }
                    c2(a3, l3);
                    break;
                  } else
                    b2(a3, l3);
                  l3 = l3.sibling;
                }
                f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
              }
              return g2(a3);
            case wa:
              a: {
                for (l3 = f3.key; null !== d3; ) {
                  if (d3.key === l3)
                    if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                      c2(a3, d3.sibling);
                      d3 = e2(d3, f3.children || []);
                      d3.return = a3;
                      a3 = d3;
                      break a;
                    } else {
                      c2(a3, d3);
                      break;
                    }
                  else
                    b2(a3, d3);
                  d3 = d3.sibling;
                }
                d3 = zh(f3, a3.mode, h3);
                d3.return = a3;
                a3 = d3;
              }
              return g2(a3);
            case Ha:
              return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
          }
          if (eb(f3))
            return n2(a3, d3, f3, h3);
          if (Ka(f3))
            return t2(a3, d3, f3, h3);
          th(a3, f3);
        }
        return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
      }
      return J2;
    }
    var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
    function Hh(a2) {
      if (a2 === Dh)
        throw Error(p$5(174));
      return a2;
    }
    function Ih(a2, b2) {
      G$3(Gh, b2);
      G$3(Fh, a2);
      G$3(Eh, Dh);
      a2 = b2.nodeType;
      switch (a2) {
        case 9:
        case 11:
          b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
          break;
        default:
          a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
      }
      E$2(Eh);
      G$3(Eh, b2);
    }
    function Jh() {
      E$2(Eh);
      E$2(Fh);
      E$2(Gh);
    }
    function Kh(a2) {
      Hh(Gh.current);
      var b2 = Hh(Eh.current);
      var c2 = lb(b2, a2.type);
      b2 !== c2 && (G$3(Fh, a2), G$3(Eh, c2));
    }
    function Lh(a2) {
      Fh.current === a2 && (E$2(Eh), E$2(Fh));
    }
    var M$3 = Uf(0);
    function Mh(a2) {
      for (var b2 = a2; null !== b2; ) {
        if (13 === b2.tag) {
          var c2 = b2.memoizedState;
          if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
            return b2;
        } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
          if (0 !== (b2.flags & 128))
            return b2;
        } else if (null !== b2.child) {
          b2.child.return = b2;
          b2 = b2.child;
          continue;
        }
        if (b2 === a2)
          break;
        for (; null === b2.sibling; ) {
          if (null === b2.return || b2.return === a2)
            return null;
          b2 = b2.return;
        }
        b2.sibling.return = b2.return;
        b2 = b2.sibling;
      }
      return null;
    }
    var Nh = [];
    function Oh() {
      for (var a2 = 0; a2 < Nh.length; a2++)
        Nh[a2]._workInProgressVersionPrimary = null;
      Nh.length = 0;
    }
    var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$2 = null, O$2 = null, P$4 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
    function Q$2() {
      throw Error(p$5(321));
    }
    function Wh(a2, b2) {
      if (null === b2)
        return false;
      for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
        if (!He$2(a2[c2], b2[c2]))
          return false;
      return true;
    }
    function Xh(a2, b2, c2, d2, e2, f2) {
      Rh = f2;
      N$2 = b2;
      b2.memoizedState = null;
      b2.updateQueue = null;
      b2.lanes = 0;
      Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
      a2 = c2(d2, e2);
      if (Th) {
        f2 = 0;
        do {
          Th = false;
          Uh = 0;
          if (25 <= f2)
            throw Error(p$5(301));
          f2 += 1;
          P$4 = O$2 = null;
          b2.updateQueue = null;
          Ph.current = $h;
          a2 = c2(d2, e2);
        } while (Th);
      }
      Ph.current = ai$1;
      b2 = null !== O$2 && null !== O$2.next;
      Rh = 0;
      P$4 = O$2 = N$2 = null;
      Sh = false;
      if (b2)
        throw Error(p$5(300));
      return a2;
    }
    function bi$1() {
      var a2 = 0 !== Uh;
      Uh = 0;
      return a2;
    }
    function ci$1() {
      var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
      null === P$4 ? N$2.memoizedState = P$4 = a2 : P$4 = P$4.next = a2;
      return P$4;
    }
    function di$1() {
      if (null === O$2) {
        var a2 = N$2.alternate;
        a2 = null !== a2 ? a2.memoizedState : null;
      } else
        a2 = O$2.next;
      var b2 = null === P$4 ? N$2.memoizedState : P$4.next;
      if (null !== b2)
        P$4 = b2, O$2 = a2;
      else {
        if (null === a2)
          throw Error(p$5(310));
        O$2 = a2;
        a2 = { memoizedState: O$2.memoizedState, baseState: O$2.baseState, baseQueue: O$2.baseQueue, queue: O$2.queue, next: null };
        null === P$4 ? N$2.memoizedState = P$4 = a2 : P$4 = P$4.next = a2;
      }
      return P$4;
    }
    function ei$1(a2, b2) {
      return "function" === typeof b2 ? b2(a2) : b2;
    }
    function fi$1(a2) {
      var b2 = di$1(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$5(311));
      c2.lastRenderedReducer = a2;
      var d2 = O$2, e2 = d2.baseQueue, f2 = c2.pending;
      if (null !== f2) {
        if (null !== e2) {
          var g2 = e2.next;
          e2.next = f2.next;
          f2.next = g2;
        }
        d2.baseQueue = e2 = f2;
        c2.pending = null;
      }
      if (null !== e2) {
        f2 = e2.next;
        d2 = d2.baseState;
        var h2 = g2 = null, k2 = null, l2 = f2;
        do {
          var m2 = l2.lane;
          if ((Rh & m2) === m2)
            null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
          else {
            var q2 = {
              lane: m2,
              action: l2.action,
              hasEagerState: l2.hasEagerState,
              eagerState: l2.eagerState,
              next: null
            };
            null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
            N$2.lanes |= m2;
            hh |= m2;
          }
          l2 = l2.next;
        } while (null !== l2 && l2 !== f2);
        null === k2 ? g2 = d2 : k2.next = h2;
        He$2(d2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = d2;
        b2.baseState = g2;
        b2.baseQueue = k2;
        c2.lastRenderedState = d2;
      }
      a2 = c2.interleaved;
      if (null !== a2) {
        e2 = a2;
        do
          f2 = e2.lane, N$2.lanes |= f2, hh |= f2, e2 = e2.next;
        while (e2 !== a2);
      } else
        null === e2 && (c2.lanes = 0);
      return [b2.memoizedState, c2.dispatch];
    }
    function gi$1(a2) {
      var b2 = di$1(), c2 = b2.queue;
      if (null === c2)
        throw Error(p$5(311));
      c2.lastRenderedReducer = a2;
      var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
      if (null !== e2) {
        c2.pending = null;
        var g2 = e2 = e2.next;
        do
          f2 = a2(f2, g2.action), g2 = g2.next;
        while (g2 !== e2);
        He$2(f2, b2.memoizedState) || (Ug = true);
        b2.memoizedState = f2;
        null === b2.baseQueue && (b2.baseState = f2);
        c2.lastRenderedState = f2;
      }
      return [f2, d2];
    }
    function hi$1() {
    }
    function ii$1(a2, b2) {
      var c2 = N$2, d2 = di$1(), e2 = b2(), f2 = !He$2(d2.memoizedState, e2);
      f2 && (d2.memoizedState = e2, Ug = true);
      d2 = d2.queue;
      ji(ki$1.bind(null, c2, d2, a2), [a2]);
      if (d2.getSnapshot !== b2 || f2 || null !== P$4 && P$4.memoizedState.tag & 1) {
        c2.flags |= 2048;
        li$1(9, mi$1.bind(null, c2, d2, e2, b2), void 0, null);
        if (null === R$3)
          throw Error(p$5(349));
        0 !== (Rh & 30) || ni$1(c2, b2, e2);
      }
      return e2;
    }
    function ni$1(a2, b2, c2) {
      a2.flags |= 16384;
      a2 = { getSnapshot: b2, value: c2 };
      b2 = N$2.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
    }
    function mi$1(a2, b2, c2, d2) {
      b2.value = c2;
      b2.getSnapshot = d2;
      oi$1(b2) && pi$1(a2);
    }
    function ki$1(a2, b2, c2) {
      return c2(function() {
        oi$1(b2) && pi$1(a2);
      });
    }
    function oi$1(a2) {
      var b2 = a2.getSnapshot;
      a2 = a2.value;
      try {
        var c2 = b2();
        return !He$2(a2, c2);
      } catch (d2) {
        return true;
      }
    }
    function pi$1(a2) {
      var b2 = Zg(a2, 1);
      null !== b2 && mh(b2, a2, 1, -1);
    }
    function qi(a2) {
      var b2 = ci$1();
      "function" === typeof a2 && (a2 = a2());
      b2.memoizedState = b2.baseState = a2;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: a2 };
      b2.queue = a2;
      a2 = a2.dispatch = ri$1.bind(null, N$2, a2);
      return [b2.memoizedState, a2];
    }
    function li$1(a2, b2, c2, d2) {
      a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
      b2 = N$2.updateQueue;
      null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
      return a2;
    }
    function si$1() {
      return di$1().memoizedState;
    }
    function ti$1(a2, b2, c2, d2) {
      var e2 = ci$1();
      N$2.flags |= a2;
      e2.memoizedState = li$1(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
    }
    function ui$1(a2, b2, c2, d2) {
      var e2 = di$1();
      d2 = void 0 === d2 ? null : d2;
      var f2 = void 0;
      if (null !== O$2) {
        var g2 = O$2.memoizedState;
        f2 = g2.destroy;
        if (null !== d2 && Wh(d2, g2.deps)) {
          e2.memoizedState = li$1(b2, c2, f2, d2);
          return;
        }
      }
      N$2.flags |= a2;
      e2.memoizedState = li$1(1 | b2, c2, f2, d2);
    }
    function vi$1(a2, b2) {
      return ti$1(8390656, 8, a2, b2);
    }
    function ji(a2, b2) {
      return ui$1(2048, 8, a2, b2);
    }
    function wi(a2, b2) {
      return ui$1(4, 2, a2, b2);
    }
    function xi(a2, b2) {
      return ui$1(4, 4, a2, b2);
    }
    function yi(a2, b2) {
      if ("function" === typeof b2)
        return a2 = a2(), b2(a2), function() {
          b2(null);
        };
      if (null !== b2 && void 0 !== b2)
        return a2 = a2(), b2.current = a2, function() {
          b2.current = null;
        };
    }
    function zi(a2, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return ui$1(4, 4, yi.bind(null, b2, a2), c2);
    }
    function Ai() {
    }
    function Bi(a2, b2) {
      var c2 = di$1();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      c2.memoizedState = [a2, b2];
      return a2;
    }
    function Ci(a2, b2) {
      var c2 = di$1();
      b2 = void 0 === b2 ? null : b2;
      var d2 = c2.memoizedState;
      if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
        return d2[0];
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }
    function Di(a2, b2, c2) {
      if (0 === (Rh & 21))
        return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
      He$2(c2, b2) || (c2 = yc(), N$2.lanes |= c2, hh |= c2, a2.baseState = true);
      return b2;
    }
    function Ei(a2, b2) {
      var c2 = C$2;
      C$2 = 0 !== c2 && 4 > c2 ? c2 : 4;
      a2(true);
      var d2 = Qh.transition;
      Qh.transition = {};
      try {
        a2(false), b2();
      } finally {
        C$2 = c2, Qh.transition = d2;
      }
    }
    function Fi() {
      return di$1().memoizedState;
    }
    function Gi(a2, b2, c2) {
      var d2 = lh(a2);
      c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a2))
        Ii(b2, c2);
      else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
        var e2 = L$4();
        mh(c2, a2, d2, e2);
        Ji(c2, b2, d2);
      }
    }
    function ri$1(a2, b2, c2) {
      var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
      if (Hi(a2))
        Ii(b2, e2);
      else {
        var f2 = a2.alternate;
        if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
          try {
            var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
            e2.hasEagerState = true;
            e2.eagerState = h2;
            if (He$2(h2, g2)) {
              var k2 = b2.interleaved;
              null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
              b2.interleaved = e2;
              return;
            }
          } catch (l2) {
          } finally {
          }
        c2 = Yg(a2, b2, e2, d2);
        null !== c2 && (e2 = L$4(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
      }
    }
    function Hi(a2) {
      var b2 = a2.alternate;
      return a2 === N$2 || null !== b2 && b2 === N$2;
    }
    function Ii(a2, b2) {
      Th = Sh = true;
      var c2 = a2.pending;
      null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
      a2.pending = b2;
    }
    function Ji(a2, b2, c2) {
      if (0 !== (c2 & 4194240)) {
        var d2 = b2.lanes;
        d2 &= a2.pendingLanes;
        c2 |= d2;
        b2.lanes = c2;
        Cc(a2, c2);
      }
    }
    var ai$1 = { readContext: Vg, useCallback: Q$2, useContext: Q$2, useEffect: Q$2, useImperativeHandle: Q$2, useInsertionEffect: Q$2, useLayoutEffect: Q$2, useMemo: Q$2, useReducer: Q$2, useRef: Q$2, useState: Q$2, useDebugValue: Q$2, useDeferredValue: Q$2, useTransition: Q$2, useMutableSource: Q$2, useSyncExternalStore: Q$2, useId: Q$2, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
      ci$1().memoizedState = [a2, void 0 === b2 ? null : b2];
      return a2;
    }, useContext: Vg, useEffect: vi$1, useImperativeHandle: function(a2, b2, c2) {
      c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
      return ti$1(
        4194308,
        4,
        yi.bind(null, b2, a2),
        c2
      );
    }, useLayoutEffect: function(a2, b2) {
      return ti$1(4194308, 4, a2, b2);
    }, useInsertionEffect: function(a2, b2) {
      return ti$1(4, 2, a2, b2);
    }, useMemo: function(a2, b2) {
      var c2 = ci$1();
      b2 = void 0 === b2 ? null : b2;
      a2 = a2();
      c2.memoizedState = [a2, b2];
      return a2;
    }, useReducer: function(a2, b2, c2) {
      var d2 = ci$1();
      b2 = void 0 !== c2 ? c2(b2) : b2;
      d2.memoizedState = d2.baseState = b2;
      a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
      d2.queue = a2;
      a2 = a2.dispatch = Gi.bind(null, N$2, a2);
      return [d2.memoizedState, a2];
    }, useRef: function(a2) {
      var b2 = ci$1();
      a2 = { current: a2 };
      return b2.memoizedState = a2;
    }, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
      return ci$1().memoizedState = a2;
    }, useTransition: function() {
      var a2 = qi(false), b2 = a2[0];
      a2 = Ei.bind(null, a2[1]);
      ci$1().memoizedState = a2;
      return [b2, a2];
    }, useMutableSource: function() {
    }, useSyncExternalStore: function(a2, b2, c2) {
      var d2 = N$2, e2 = ci$1();
      if (I$3) {
        if (void 0 === c2)
          throw Error(p$5(407));
        c2 = c2();
      } else {
        c2 = b2();
        if (null === R$3)
          throw Error(p$5(349));
        0 !== (Rh & 30) || ni$1(d2, b2, c2);
      }
      e2.memoizedState = c2;
      var f2 = { value: c2, getSnapshot: b2 };
      e2.queue = f2;
      vi$1(ki$1.bind(
        null,
        d2,
        f2,
        a2
      ), [a2]);
      d2.flags |= 2048;
      li$1(9, mi$1.bind(null, d2, f2, c2, b2), void 0, null);
      return c2;
    }, useId: function() {
      var a2 = ci$1(), b2 = R$3.identifierPrefix;
      if (I$3) {
        var c2 = sg;
        var d2 = rg;
        c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
        b2 = ":" + b2 + "R" + c2;
        c2 = Uh++;
        0 < c2 && (b2 += "H" + c2.toString(32));
        b2 += ":";
      } else
        c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
      return a2.memoizedState = b2;
    }, unstable_isNewReconciler: false }, Zh = {
      readContext: Vg,
      useCallback: Bi,
      useContext: Vg,
      useEffect: ji,
      useImperativeHandle: zi,
      useInsertionEffect: wi,
      useLayoutEffect: xi,
      useMemo: Ci,
      useReducer: fi$1,
      useRef: si$1,
      useState: function() {
        return fi$1(ei$1);
      },
      useDebugValue: Ai,
      useDeferredValue: function(a2) {
        var b2 = di$1();
        return Di(b2, O$2.memoizedState, a2);
      },
      useTransition: function() {
        var a2 = fi$1(ei$1)[0], b2 = di$1().memoizedState;
        return [a2, b2];
      },
      useMutableSource: hi$1,
      useSyncExternalStore: ii$1,
      useId: Fi,
      unstable_isNewReconciler: false
    }, $h = { readContext: Vg, useCallback: Bi, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi, useLayoutEffect: xi, useMemo: Ci, useReducer: gi$1, useRef: si$1, useState: function() {
      return gi$1(ei$1);
    }, useDebugValue: Ai, useDeferredValue: function(a2) {
      var b2 = di$1();
      return null === O$2 ? b2.memoizedState = a2 : Di(b2, O$2.memoizedState, a2);
    }, useTransition: function() {
      var a2 = gi$1(ei$1)[0], b2 = di$1().memoizedState;
      return [a2, b2];
    }, useMutableSource: hi$1, useSyncExternalStore: ii$1, useId: Fi, unstable_isNewReconciler: false };
    function Ki(a2, b2) {
      try {
        var c2 = "", d2 = b2;
        do
          c2 += Pa(d2), d2 = d2.return;
        while (d2);
        var e2 = c2;
      } catch (f2) {
        e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
      }
      return { value: a2, source: b2, stack: e2, digest: null };
    }
    function Li(a2, b2, c2) {
      return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
    }
    function Mi(a2, b2) {
      try {
        console.error(b2.value);
      } catch (c2) {
        setTimeout(function() {
          throw c2;
        });
      }
    }
    var Ni = "function" === typeof WeakMap ? WeakMap : Map;
    function Oi(a2, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      c2.payload = { element: null };
      var d2 = b2.value;
      c2.callback = function() {
        Pi || (Pi = true, Qi = d2);
        Mi(a2, b2);
      };
      return c2;
    }
    function Ri(a2, b2, c2) {
      c2 = ch(-1, c2);
      c2.tag = 3;
      var d2 = a2.type.getDerivedStateFromError;
      if ("function" === typeof d2) {
        var e2 = b2.value;
        c2.payload = function() {
          return d2(e2);
        };
        c2.callback = function() {
          Mi(a2, b2);
        };
      }
      var f2 = a2.stateNode;
      null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
        Mi(a2, b2);
        "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
        var c3 = b2.stack;
        this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
      });
      return c2;
    }
    function Ti(a2, b2, c2) {
      var d2 = a2.pingCache;
      if (null === d2) {
        d2 = a2.pingCache = new Ni();
        var e2 = /* @__PURE__ */ new Set();
        d2.set(b2, e2);
      } else
        e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
      e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
    }
    function Vi(a2) {
      do {
        var b2;
        if (b2 = 13 === a2.tag)
          b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
        if (b2)
          return a2;
        a2 = a2.return;
      } while (null !== a2);
      return null;
    }
    function Wi(a2, b2, c2, d2, e2) {
      if (0 === (a2.mode & 1))
        return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
      a2.flags |= 65536;
      a2.lanes = e2;
      return a2;
    }
    var Xi = ua.ReactCurrentOwner, Ug = false;
    function Yi(a2, b2, c2, d2) {
      b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
    }
    function Zi(a2, b2, c2, d2, e2) {
      c2 = c2.render;
      var f2 = b2.ref;
      Tg(b2, e2);
      d2 = Xh(a2, b2, c2, d2, f2, e2);
      c2 = bi$1();
      if (null !== a2 && !Ug)
        return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
      I$3 && c2 && vg(b2);
      b2.flags |= 1;
      Yi(a2, b2, d2, e2);
      return b2.child;
    }
    function aj(a2, b2, c2, d2, e2) {
      if (null === a2) {
        var f2 = c2.type;
        if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
          return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
        a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
        a2.ref = b2.ref;
        a2.return = b2;
        return b2.child = a2;
      }
      f2 = a2.child;
      if (0 === (a2.lanes & e2)) {
        var g2 = f2.memoizedProps;
        c2 = c2.compare;
        c2 = null !== c2 ? c2 : Ie$2;
        if (c2(g2, d2) && a2.ref === b2.ref)
          return $i(a2, b2, e2);
      }
      b2.flags |= 1;
      a2 = wh(f2, d2);
      a2.ref = b2.ref;
      a2.return = b2;
      return b2.child = a2;
    }
    function cj(a2, b2, c2, d2, e2) {
      if (null !== a2) {
        var f2 = a2.memoizedProps;
        if (Ie$2(f2, d2) && a2.ref === b2.ref)
          if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
            0 !== (a2.flags & 131072) && (Ug = true);
          else
            return b2.lanes = a2.lanes, $i(a2, b2, e2);
      }
      return dj(a2, b2, c2, d2, e2);
    }
    function ej(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
      if ("hidden" === d2.mode)
        if (0 === (b2.mode & 1))
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$3(fj, gj), gj |= c2;
        else {
          if (0 === (c2 & 1073741824))
            return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$3(fj, gj), gj |= a2, null;
          b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
          d2 = null !== f2 ? f2.baseLanes : c2;
          G$3(fj, gj);
          gj |= d2;
        }
      else
        null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$3(fj, gj), gj |= d2;
      Yi(a2, b2, e2, c2);
      return b2.child;
    }
    function hj(a2, b2) {
      var c2 = b2.ref;
      if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
        b2.flags |= 512, b2.flags |= 2097152;
    }
    function dj(a2, b2, c2, d2, e2) {
      var f2 = Zf(c2) ? Xf : H$3.current;
      f2 = Yf(b2, f2);
      Tg(b2, e2);
      c2 = Xh(a2, b2, c2, d2, f2, e2);
      d2 = bi$1();
      if (null !== a2 && !Ug)
        return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
      I$3 && d2 && vg(b2);
      b2.flags |= 1;
      Yi(a2, b2, c2, e2);
      return b2.child;
    }
    function ij(a2, b2, c2, d2, e2) {
      if (Zf(c2)) {
        var f2 = true;
        cg(b2);
      } else
        f2 = false;
      Tg(b2, e2);
      if (null === b2.stateNode)
        jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
      else if (null === a2) {
        var g2 = b2.stateNode, h2 = b2.memoizedProps;
        g2.props = h2;
        var k2 = g2.context, l2 = c2.contextType;
        "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$3.current, l2 = Yf(b2, l2));
        var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
        q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
        $g = false;
        var r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        k2 = b2.memoizedState;
        h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
      } else {
        g2 = b2.stateNode;
        bh(a2, b2);
        h2 = b2.memoizedProps;
        l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
        g2.props = l2;
        q2 = b2.pendingProps;
        r2 = g2.context;
        k2 = c2.contextType;
        "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$3.current, k2 = Yf(b2, k2));
        var y2 = c2.getDerivedStateFromProps;
        (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
        $g = false;
        r2 = b2.memoizedState;
        g2.state = r2;
        gh(b2, d2, g2, e2);
        var n2 = b2.memoizedState;
        h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
      }
      return kj(a2, b2, c2, d2, f2, e2);
    }
    function kj(a2, b2, c2, d2, e2, f2) {
      hj(a2, b2);
      var g2 = 0 !== (b2.flags & 128);
      if (!d2 && !g2)
        return e2 && dg(b2, c2, false), $i(a2, b2, f2);
      d2 = b2.stateNode;
      Xi.current = b2;
      var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
      b2.flags |= 1;
      null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
      b2.memoizedState = d2.state;
      e2 && dg(b2, c2, true);
      return b2.child;
    }
    function lj(a2) {
      var b2 = a2.stateNode;
      b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
      Ih(a2, b2.containerInfo);
    }
    function mj(a2, b2, c2, d2, e2) {
      Ig();
      Jg(e2);
      b2.flags |= 256;
      Yi(a2, b2, c2, d2);
      return b2.child;
    }
    var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
    function oj(a2) {
      return { baseLanes: a2, cachePool: null, transitions: null };
    }
    function pj(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = M$3.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
      (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
      if (h2)
        f2 = true, b2.flags &= -129;
      else if (null === a2 || null !== a2.memoizedState)
        e2 |= 1;
      G$3(M$3, e2 & 1);
      if (null === a2) {
        Eg(b2);
        a2 = b2.memoizedState;
        if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
          return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
        g2 = d2.children;
        a2 = d2.fallback;
        return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
      }
      e2 = a2.memoizedState;
      if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
        return sj(a2, b2, g2, d2, h2, e2, c2);
      if (f2) {
        f2 = d2.fallback;
        g2 = b2.mode;
        e2 = a2.child;
        h2 = e2.sibling;
        var k2 = { mode: "hidden", children: d2.children };
        0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
        null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
        f2.return = b2;
        d2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        d2 = f2;
        f2 = b2.child;
        g2 = a2.child.memoizedState;
        g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
        f2.memoizedState = g2;
        f2.childLanes = a2.childLanes & ~c2;
        b2.memoizedState = nj;
        return d2;
      }
      f2 = a2.child;
      a2 = f2.sibling;
      d2 = wh(f2, { mode: "visible", children: d2.children });
      0 === (b2.mode & 1) && (d2.lanes = c2);
      d2.return = b2;
      d2.sibling = null;
      null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
      b2.child = d2;
      b2.memoizedState = null;
      return d2;
    }
    function rj(a2, b2) {
      b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
      b2.return = a2;
      return a2.child = b2;
    }
    function tj(a2, b2, c2, d2) {
      null !== d2 && Jg(d2);
      Bh(b2, a2.child, null, c2);
      a2 = rj(b2, b2.pendingProps.children);
      a2.flags |= 2;
      b2.memoizedState = null;
      return a2;
    }
    function sj(a2, b2, c2, d2, e2, f2, g2) {
      if (c2) {
        if (b2.flags & 256)
          return b2.flags &= -257, d2 = Li(Error(p$5(422))), tj(a2, b2, g2, d2);
        if (null !== b2.memoizedState)
          return b2.child = a2.child, b2.flags |= 128, null;
        f2 = d2.fallback;
        e2 = b2.mode;
        d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
        f2 = Ah(f2, e2, g2, null);
        f2.flags |= 2;
        d2.return = b2;
        f2.return = b2;
        d2.sibling = f2;
        b2.child = d2;
        0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
        b2.child.memoizedState = oj(g2);
        b2.memoizedState = nj;
        return f2;
      }
      if (0 === (b2.mode & 1))
        return tj(a2, b2, g2, null);
      if ("$!" === e2.data) {
        d2 = e2.nextSibling && e2.nextSibling.dataset;
        if (d2)
          var h2 = d2.dgst;
        d2 = h2;
        f2 = Error(p$5(419));
        d2 = Li(f2, d2, void 0);
        return tj(a2, b2, g2, d2);
      }
      h2 = 0 !== (g2 & a2.childLanes);
      if (Ug || h2) {
        d2 = R$3;
        if (null !== d2) {
          switch (g2 & -g2) {
            case 4:
              e2 = 2;
              break;
            case 16:
              e2 = 8;
              break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
              e2 = 32;
              break;
            case 536870912:
              e2 = 268435456;
              break;
            default:
              e2 = 0;
          }
          e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
          0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
        }
        uj();
        d2 = Li(Error(p$5(421)));
        return tj(a2, b2, g2, d2);
      }
      if ("$?" === e2.data)
        return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
      a2 = f2.treeContext;
      yg = Lf(e2.nextSibling);
      xg = b2;
      I$3 = true;
      zg = null;
      null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
      b2 = rj(b2, d2.children);
      b2.flags |= 4096;
      return b2;
    }
    function wj(a2, b2, c2) {
      a2.lanes |= b2;
      var d2 = a2.alternate;
      null !== d2 && (d2.lanes |= b2);
      Sg(a2.return, b2, c2);
    }
    function xj(a2, b2, c2, d2, e2) {
      var f2 = a2.memoizedState;
      null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
    }
    function yj(a2, b2, c2) {
      var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
      Yi(a2, b2, d2.children, c2);
      d2 = M$3.current;
      if (0 !== (d2 & 2))
        d2 = d2 & 1 | 2, b2.flags |= 128;
      else {
        if (null !== a2 && 0 !== (a2.flags & 128))
          a:
            for (a2 = b2.child; null !== a2; ) {
              if (13 === a2.tag)
                null !== a2.memoizedState && wj(a2, c2, b2);
              else if (19 === a2.tag)
                wj(a2, c2, b2);
              else if (null !== a2.child) {
                a2.child.return = a2;
                a2 = a2.child;
                continue;
              }
              if (a2 === b2)
                break a;
              for (; null === a2.sibling; ) {
                if (null === a2.return || a2.return === b2)
                  break a;
                a2 = a2.return;
              }
              a2.sibling.return = a2.return;
              a2 = a2.sibling;
            }
        d2 &= 1;
      }
      G$3(M$3, d2);
      if (0 === (b2.mode & 1))
        b2.memoizedState = null;
      else
        switch (e2) {
          case "forwards":
            c2 = b2.child;
            for (e2 = null; null !== c2; )
              a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
            c2 = e2;
            null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
            xj(b2, false, e2, c2, f2);
            break;
          case "backwards":
            c2 = null;
            e2 = b2.child;
            for (b2.child = null; null !== e2; ) {
              a2 = e2.alternate;
              if (null !== a2 && null === Mh(a2)) {
                b2.child = e2;
                break;
              }
              a2 = e2.sibling;
              e2.sibling = c2;
              c2 = e2;
              e2 = a2;
            }
            xj(b2, true, c2, null, f2);
            break;
          case "together":
            xj(b2, false, null, null, void 0);
            break;
          default:
            b2.memoizedState = null;
        }
      return b2.child;
    }
    function jj(a2, b2) {
      0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
    }
    function $i(a2, b2, c2) {
      null !== a2 && (b2.dependencies = a2.dependencies);
      hh |= b2.lanes;
      if (0 === (c2 & b2.childLanes))
        return null;
      if (null !== a2 && b2.child !== a2.child)
        throw Error(p$5(153));
      if (null !== b2.child) {
        a2 = b2.child;
        c2 = wh(a2, a2.pendingProps);
        b2.child = c2;
        for (c2.return = b2; null !== a2.sibling; )
          a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
        c2.sibling = null;
      }
      return b2.child;
    }
    function zj(a2, b2, c2) {
      switch (b2.tag) {
        case 3:
          lj(b2);
          Ig();
          break;
        case 5:
          Kh(b2);
          break;
        case 1:
          Zf(b2.type) && cg(b2);
          break;
        case 4:
          Ih(b2, b2.stateNode.containerInfo);
          break;
        case 10:
          var d2 = b2.type._context, e2 = b2.memoizedProps.value;
          G$3(Mg, d2._currentValue);
          d2._currentValue = e2;
          break;
        case 13:
          d2 = b2.memoizedState;
          if (null !== d2) {
            if (null !== d2.dehydrated)
              return G$3(M$3, M$3.current & 1), b2.flags |= 128, null;
            if (0 !== (c2 & b2.child.childLanes))
              return pj(a2, b2, c2);
            G$3(M$3, M$3.current & 1);
            a2 = $i(a2, b2, c2);
            return null !== a2 ? a2.sibling : null;
          }
          G$3(M$3, M$3.current & 1);
          break;
        case 19:
          d2 = 0 !== (c2 & b2.childLanes);
          if (0 !== (a2.flags & 128)) {
            if (d2)
              return yj(a2, b2, c2);
            b2.flags |= 128;
          }
          e2 = b2.memoizedState;
          null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
          G$3(M$3, M$3.current);
          if (d2)
            break;
          else
            return null;
        case 22:
        case 23:
          return b2.lanes = 0, ej(a2, b2, c2);
      }
      return $i(a2, b2, c2);
    }
    var Aj, Bj, Cj, Dj;
    Aj = function(a2, b2) {
      for (var c2 = b2.child; null !== c2; ) {
        if (5 === c2.tag || 6 === c2.tag)
          a2.appendChild(c2.stateNode);
        else if (4 !== c2.tag && null !== c2.child) {
          c2.child.return = c2;
          c2 = c2.child;
          continue;
        }
        if (c2 === b2)
          break;
        for (; null === c2.sibling; ) {
          if (null === c2.return || c2.return === b2)
            return;
          c2 = c2.return;
        }
        c2.sibling.return = c2.return;
        c2 = c2.sibling;
      }
    };
    Bj = function() {
    };
    Cj = function(a2, b2, c2, d2) {
      var e2 = a2.memoizedProps;
      if (e2 !== d2) {
        a2 = b2.stateNode;
        Hh(Eh.current);
        var f2 = null;
        switch (c2) {
          case "input":
            e2 = Ya(a2, e2);
            d2 = Ya(a2, d2);
            f2 = [];
            break;
          case "select":
            e2 = A$3({}, e2, { value: void 0 });
            d2 = A$3({}, d2, { value: void 0 });
            f2 = [];
            break;
          case "textarea":
            e2 = gb(a2, e2);
            d2 = gb(a2, d2);
            f2 = [];
            break;
          default:
            "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
        }
        ub(c2, d2);
        var g2;
        c2 = null;
        for (l2 in e2)
          if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
            if ("style" === l2) {
              var h2 = e2[l2];
              for (g2 in h2)
                h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
            } else
              "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
        for (l2 in d2) {
          var k2 = d2[l2];
          h2 = null != e2 ? e2[l2] : void 0;
          if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
            if ("style" === l2)
              if (h2) {
                for (g2 in h2)
                  !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
                for (g2 in k2)
                  k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
              } else
                c2 || (f2 || (f2 = []), f2.push(
                  l2,
                  c2
                )), c2 = k2;
            else
              "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$4("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
        }
        c2 && (f2 = f2 || []).push("style", c2);
        var l2 = f2;
        if (b2.updateQueue = l2)
          b2.flags |= 4;
      }
    };
    Dj = function(a2, b2, c2, d2) {
      c2 !== d2 && (b2.flags |= 4);
    };
    function Ej(a2, b2) {
      if (!I$3)
        switch (a2.tailMode) {
          case "hidden":
            b2 = a2.tail;
            for (var c2 = null; null !== b2; )
              null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
            null === c2 ? a2.tail = null : c2.sibling = null;
            break;
          case "collapsed":
            c2 = a2.tail;
            for (var d2 = null; null !== c2; )
              null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
            null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
        }
    }
    function S$1(a2) {
      var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
      if (b2)
        for (var e2 = a2.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
      else
        for (e2 = a2.child; null !== e2; )
          c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
      a2.subtreeFlags |= d2;
      a2.childLanes = c2;
      return b2;
    }
    function Fj(a2, b2, c2) {
      var d2 = b2.pendingProps;
      wg(b2);
      switch (b2.tag) {
        case 2:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return S$1(b2), null;
        case 1:
          return Zf(b2.type) && $f(), S$1(b2), null;
        case 3:
          d2 = b2.stateNode;
          Jh();
          E$2(Wf);
          E$2(H$3);
          Oh();
          d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
          if (null === a2 || null === a2.child)
            Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
          Bj(a2, b2);
          S$1(b2);
          return null;
        case 5:
          Lh(b2);
          var e2 = Hh(Gh.current);
          c2 = b2.type;
          if (null !== a2 && null != b2.stateNode)
            Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          else {
            if (!d2) {
              if (null === b2.stateNode)
                throw Error(p$5(166));
              S$1(b2);
              return null;
            }
            a2 = Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.type;
              var f2 = b2.memoizedProps;
              d2[Of] = b2;
              d2[Pf] = f2;
              a2 = 0 !== (b2.mode & 1);
              switch (c2) {
                case "dialog":
                  D$4("cancel", d2);
                  D$4("close", d2);
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D$4("load", d2);
                  break;
                case "video":
                case "audio":
                  for (e2 = 0; e2 < lf.length; e2++)
                    D$4(lf[e2], d2);
                  break;
                case "source":
                  D$4("error", d2);
                  break;
                case "img":
                case "image":
                case "link":
                  D$4(
                    "error",
                    d2
                  );
                  D$4("load", d2);
                  break;
                case "details":
                  D$4("toggle", d2);
                  break;
                case "input":
                  Za(d2, f2);
                  D$4("invalid", d2);
                  break;
                case "select":
                  d2._wrapperState = { wasMultiple: !!f2.multiple };
                  D$4("invalid", d2);
                  break;
                case "textarea":
                  hb(d2, f2), D$4("invalid", d2);
              }
              ub(c2, f2);
              e2 = null;
              for (var g2 in f2)
                if (f2.hasOwnProperty(g2)) {
                  var h2 = f2[g2];
                  "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                    d2.textContent,
                    h2,
                    a2
                  ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$4("scroll", d2);
                }
              switch (c2) {
                case "input":
                  Va(d2);
                  db(d2, f2, true);
                  break;
                case "textarea":
                  Va(d2);
                  jb(d2);
                  break;
                case "select":
                case "option":
                  break;
                default:
                  "function" === typeof f2.onClick && (d2.onclick = Bf);
              }
              d2 = e2;
              b2.updateQueue = d2;
              null !== d2 && (b2.flags |= 4);
            } else {
              g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
              "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
              "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
              a2[Of] = b2;
              a2[Pf] = d2;
              Aj(a2, b2, false, false);
              b2.stateNode = a2;
              a: {
                g2 = vb(c2, d2);
                switch (c2) {
                  case "dialog":
                    D$4("cancel", a2);
                    D$4("close", a2);
                    e2 = d2;
                    break;
                  case "iframe":
                  case "object":
                  case "embed":
                    D$4("load", a2);
                    e2 = d2;
                    break;
                  case "video":
                  case "audio":
                    for (e2 = 0; e2 < lf.length; e2++)
                      D$4(lf[e2], a2);
                    e2 = d2;
                    break;
                  case "source":
                    D$4("error", a2);
                    e2 = d2;
                    break;
                  case "img":
                  case "image":
                  case "link":
                    D$4(
                      "error",
                      a2
                    );
                    D$4("load", a2);
                    e2 = d2;
                    break;
                  case "details":
                    D$4("toggle", a2);
                    e2 = d2;
                    break;
                  case "input":
                    Za(a2, d2);
                    e2 = Ya(a2, d2);
                    D$4("invalid", a2);
                    break;
                  case "option":
                    e2 = d2;
                    break;
                  case "select":
                    a2._wrapperState = { wasMultiple: !!d2.multiple };
                    e2 = A$3({}, d2, { value: void 0 });
                    D$4("invalid", a2);
                    break;
                  case "textarea":
                    hb(a2, d2);
                    e2 = gb(a2, d2);
                    D$4("invalid", a2);
                    break;
                  default:
                    e2 = d2;
                }
                ub(c2, e2);
                h2 = e2;
                for (f2 in h2)
                  if (h2.hasOwnProperty(f2)) {
                    var k2 = h2[f2];
                    "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$4("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
                  }
                switch (c2) {
                  case "input":
                    Va(a2);
                    db(a2, d2, false);
                    break;
                  case "textarea":
                    Va(a2);
                    jb(a2);
                    break;
                  case "option":
                    null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                    break;
                  case "select":
                    a2.multiple = !!d2.multiple;
                    f2 = d2.value;
                    null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                      a2,
                      !!d2.multiple,
                      d2.defaultValue,
                      true
                    );
                    break;
                  default:
                    "function" === typeof e2.onClick && (a2.onclick = Bf);
                }
                switch (c2) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    d2 = !!d2.autoFocus;
                    break a;
                  case "img":
                    d2 = true;
                    break a;
                  default:
                    d2 = false;
                }
              }
              d2 && (b2.flags |= 4);
            }
            null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
          }
          S$1(b2);
          return null;
        case 6:
          if (a2 && null != b2.stateNode)
            Dj(a2, b2, a2.memoizedProps, d2);
          else {
            if ("string" !== typeof d2 && null === b2.stateNode)
              throw Error(p$5(166));
            c2 = Hh(Gh.current);
            Hh(Eh.current);
            if (Gg(b2)) {
              d2 = b2.stateNode;
              c2 = b2.memoizedProps;
              d2[Of] = b2;
              if (f2 = d2.nodeValue !== c2) {
                if (a2 = xg, null !== a2)
                  switch (a2.tag) {
                    case 3:
                      Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                      break;
                    case 5:
                      true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  }
              }
              f2 && (b2.flags |= 4);
            } else
              d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
          }
          S$1(b2);
          return null;
        case 13:
          E$2(M$3);
          d2 = b2.memoizedState;
          if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
            if (I$3 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
              Hg(), Ig(), b2.flags |= 98560, f2 = false;
            else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
              if (null === a2) {
                if (!f2)
                  throw Error(p$5(318));
                f2 = b2.memoizedState;
                f2 = null !== f2 ? f2.dehydrated : null;
                if (!f2)
                  throw Error(p$5(317));
                f2[Of] = b2;
              } else
                Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
              S$1(b2);
              f2 = false;
            } else
              null !== zg && (Gj(zg), zg = null), f2 = true;
            if (!f2)
              return b2.flags & 65536 ? b2 : null;
          }
          if (0 !== (b2.flags & 128))
            return b2.lanes = c2, b2;
          d2 = null !== d2;
          d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$3.current & 1) ? 0 === T$2 && (T$2 = 3) : uj()));
          null !== b2.updateQueue && (b2.flags |= 4);
          S$1(b2);
          return null;
        case 4:
          return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
        case 10:
          return Rg(b2.type._context), S$1(b2), null;
        case 17:
          return Zf(b2.type) && $f(), S$1(b2), null;
        case 19:
          E$2(M$3);
          f2 = b2.memoizedState;
          if (null === f2)
            return S$1(b2), null;
          d2 = 0 !== (b2.flags & 128);
          g2 = f2.rendering;
          if (null === g2)
            if (d2)
              Ej(f2, false);
            else {
              if (0 !== T$2 || null !== a2 && 0 !== (a2.flags & 128))
                for (a2 = b2.child; null !== a2; ) {
                  g2 = Mh(a2);
                  if (null !== g2) {
                    b2.flags |= 128;
                    Ej(f2, false);
                    d2 = g2.updateQueue;
                    null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                    b2.subtreeFlags = 0;
                    d2 = c2;
                    for (c2 = b2.child; null !== c2; )
                      f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                    G$3(M$3, M$3.current & 1 | 2);
                    return b2.child;
                  }
                  a2 = a2.sibling;
                }
              null !== f2.tail && B$4() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            }
          else {
            if (!d2)
              if (a2 = Mh(g2), null !== a2) {
                if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$3)
                  return S$1(b2), null;
              } else
                2 * B$4() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
            f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
          }
          if (null !== f2.tail)
            return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$4(), b2.sibling = null, c2 = M$3.current, G$3(M$3, d2 ? c2 & 1 | 2 : c2 & 1), b2;
          S$1(b2);
          return null;
        case 22:
        case 23:
          return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
        case 24:
          return null;
        case 25:
          return null;
      }
      throw Error(p$5(156, b2.tag));
    }
    function Jj(a2, b2) {
      wg(b2);
      switch (b2.tag) {
        case 1:
          return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
        case 3:
          return Jh(), E$2(Wf), E$2(H$3), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
        case 5:
          return Lh(b2), null;
        case 13:
          E$2(M$3);
          a2 = b2.memoizedState;
          if (null !== a2 && null !== a2.dehydrated) {
            if (null === b2.alternate)
              throw Error(p$5(340));
            Ig();
          }
          a2 = b2.flags;
          return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
        case 19:
          return E$2(M$3), null;
        case 4:
          return Jh(), null;
        case 10:
          return Rg(b2.type._context), null;
        case 22:
        case 23:
          return Ij(), null;
        case 24:
          return null;
        default:
          return null;
      }
    }
    var Kj = false, U$4 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$2 = null;
    function Mj(a2, b2) {
      var c2 = a2.ref;
      if (null !== c2)
        if ("function" === typeof c2)
          try {
            c2(null);
          } catch (d2) {
            W$2(a2, b2, d2);
          }
        else
          c2.current = null;
    }
    function Nj(a2, b2, c2) {
      try {
        c2();
      } catch (d2) {
        W$2(a2, b2, d2);
      }
    }
    var Oj = false;
    function Pj(a2, b2) {
      Cf = dd;
      a2 = Me$2();
      if (Ne$2(a2)) {
        if ("selectionStart" in a2)
          var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
        else
          a: {
            c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
            var d2 = c2.getSelection && c2.getSelection();
            if (d2 && 0 !== d2.rangeCount) {
              c2 = d2.anchorNode;
              var e2 = d2.anchorOffset, f2 = d2.focusNode;
              d2 = d2.focusOffset;
              try {
                c2.nodeType, f2.nodeType;
              } catch (F2) {
                c2 = null;
                break a;
              }
              var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
              b:
                for (; ; ) {
                  for (var y2; ; ) {
                    q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                    q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                    3 === q2.nodeType && (g2 += q2.nodeValue.length);
                    if (null === (y2 = q2.firstChild))
                      break;
                    r2 = q2;
                    q2 = y2;
                  }
                  for (; ; ) {
                    if (q2 === a2)
                      break b;
                    r2 === c2 && ++l2 === e2 && (h2 = g2);
                    r2 === f2 && ++m2 === d2 && (k2 = g2);
                    if (null !== (y2 = q2.nextSibling))
                      break;
                    q2 = r2;
                    r2 = q2.parentNode;
                  }
                  q2 = y2;
                }
              c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
            } else
              c2 = null;
          }
        c2 = c2 || { start: 0, end: 0 };
      } else
        c2 = null;
      Df = { focusedElem: a2, selectionRange: c2 };
      dd = false;
      for (V$2 = b2; null !== V$2; )
        if (b2 = V$2, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
          a2.return = b2, V$2 = a2;
        else
          for (; null !== V$2; ) {
            b2 = V$2;
            try {
              var n2 = b2.alternate;
              if (0 !== (b2.flags & 1024))
                switch (b2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    break;
                  case 1:
                    if (null !== n2) {
                      var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                      x2.__reactInternalSnapshotBeforeUpdate = w2;
                    }
                    break;
                  case 3:
                    var u2 = b2.stateNode.containerInfo;
                    1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                    break;
                  case 5:
                  case 6:
                  case 4:
                  case 17:
                    break;
                  default:
                    throw Error(p$5(163));
                }
            } catch (F2) {
              W$2(b2, b2.return, F2);
            }
            a2 = b2.sibling;
            if (null !== a2) {
              a2.return = b2.return;
              V$2 = a2;
              break;
            }
            V$2 = b2.return;
          }
      n2 = Oj;
      Oj = false;
      return n2;
    }
    function Qj(a2, b2, c2) {
      var d2 = b2.updateQueue;
      d2 = null !== d2 ? d2.lastEffect : null;
      if (null !== d2) {
        var e2 = d2 = d2.next;
        do {
          if ((e2.tag & a2) === a2) {
            var f2 = e2.destroy;
            e2.destroy = void 0;
            void 0 !== f2 && Nj(b2, c2, f2);
          }
          e2 = e2.next;
        } while (e2 !== d2);
      }
    }
    function Rj(a2, b2) {
      b2 = b2.updateQueue;
      b2 = null !== b2 ? b2.lastEffect : null;
      if (null !== b2) {
        var c2 = b2 = b2.next;
        do {
          if ((c2.tag & a2) === a2) {
            var d2 = c2.create;
            c2.destroy = d2();
          }
          c2 = c2.next;
        } while (c2 !== b2);
      }
    }
    function Sj(a2) {
      var b2 = a2.ref;
      if (null !== b2) {
        var c2 = a2.stateNode;
        switch (a2.tag) {
          case 5:
            a2 = c2;
            break;
          default:
            a2 = c2;
        }
        "function" === typeof b2 ? b2(a2) : b2.current = a2;
      }
    }
    function Tj(a2) {
      var b2 = a2.alternate;
      null !== b2 && (a2.alternate = null, Tj(b2));
      a2.child = null;
      a2.deletions = null;
      a2.sibling = null;
      5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
      a2.stateNode = null;
      a2.return = null;
      a2.dependencies = null;
      a2.memoizedProps = null;
      a2.memoizedState = null;
      a2.pendingProps = null;
      a2.stateNode = null;
      a2.updateQueue = null;
    }
    function Uj(a2) {
      return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
    }
    function Vj(a2) {
      a:
        for (; ; ) {
          for (; null === a2.sibling; ) {
            if (null === a2.return || Uj(a2.return))
              return null;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
            if (a2.flags & 2)
              continue a;
            if (null === a2.child || 4 === a2.tag)
              continue a;
            else
              a2.child.return = a2, a2 = a2.child;
          }
          if (!(a2.flags & 2))
            return a2.stateNode;
        }
    }
    function Wj(a2, b2, c2) {
      var d2 = a2.tag;
      if (5 === d2 || 6 === d2)
        a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
      else if (4 !== d2 && (a2 = a2.child, null !== a2))
        for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
          Wj(a2, b2, c2), a2 = a2.sibling;
    }
    function Xj(a2, b2, c2) {
      var d2 = a2.tag;
      if (5 === d2 || 6 === d2)
        a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
      else if (4 !== d2 && (a2 = a2.child, null !== a2))
        for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
          Xj(a2, b2, c2), a2 = a2.sibling;
    }
    var X$3 = null, Yj = false;
    function Zj(a2, b2, c2) {
      for (c2 = c2.child; null !== c2; )
        ak(a2, b2, c2), c2 = c2.sibling;
    }
    function ak(a2, b2, c2) {
      if (lc && "function" === typeof lc.onCommitFiberUnmount)
        try {
          lc.onCommitFiberUnmount(kc, c2);
        } catch (h2) {
        }
      switch (c2.tag) {
        case 5:
          U$4 || Mj(c2, b2);
        case 6:
          var d2 = X$3, e2 = Yj;
          X$3 = null;
          Zj(a2, b2, c2);
          X$3 = d2;
          Yj = e2;
          null !== X$3 && (Yj ? (a2 = X$3, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$3.removeChild(c2.stateNode));
          break;
        case 18:
          null !== X$3 && (Yj ? (a2 = X$3, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$3, c2.stateNode));
          break;
        case 4:
          d2 = X$3;
          e2 = Yj;
          X$3 = c2.stateNode.containerInfo;
          Yj = true;
          Zj(a2, b2, c2);
          X$3 = d2;
          Yj = e2;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          if (!U$4 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
            e2 = d2 = d2.next;
            do {
              var f2 = e2, g2 = f2.destroy;
              f2 = f2.tag;
              void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
              e2 = e2.next;
            } while (e2 !== d2);
          }
          Zj(a2, b2, c2);
          break;
        case 1:
          if (!U$4 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
            try {
              d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
            } catch (h2) {
              W$2(c2, b2, h2);
            }
          Zj(a2, b2, c2);
          break;
        case 21:
          Zj(a2, b2, c2);
          break;
        case 22:
          c2.mode & 1 ? (U$4 = (d2 = U$4) || null !== c2.memoizedState, Zj(a2, b2, c2), U$4 = d2) : Zj(a2, b2, c2);
          break;
        default:
          Zj(a2, b2, c2);
      }
    }
    function bk(a2) {
      var b2 = a2.updateQueue;
      if (null !== b2) {
        a2.updateQueue = null;
        var c2 = a2.stateNode;
        null === c2 && (c2 = a2.stateNode = new Lj());
        b2.forEach(function(b3) {
          var d2 = ck.bind(null, a2, b3);
          c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
        });
      }
    }
    function dk(a2, b2) {
      var c2 = b2.deletions;
      if (null !== c2)
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2];
          try {
            var f2 = a2, g2 = b2, h2 = g2;
            a:
              for (; null !== h2; ) {
                switch (h2.tag) {
                  case 5:
                    X$3 = h2.stateNode;
                    Yj = false;
                    break a;
                  case 3:
                    X$3 = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                  case 4:
                    X$3 = h2.stateNode.containerInfo;
                    Yj = true;
                    break a;
                }
                h2 = h2.return;
              }
            if (null === X$3)
              throw Error(p$5(160));
            ak(f2, g2, e2);
            X$3 = null;
            Yj = false;
            var k2 = e2.alternate;
            null !== k2 && (k2.return = null);
            e2.return = null;
          } catch (l2) {
            W$2(e2, b2, l2);
          }
        }
      if (b2.subtreeFlags & 12854)
        for (b2 = b2.child; null !== b2; )
          ek(b2, a2), b2 = b2.sibling;
    }
    function ek(a2, b2) {
      var c2 = a2.alternate, d2 = a2.flags;
      switch (a2.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          dk(b2, a2);
          fk(a2);
          if (d2 & 4) {
            try {
              Qj(3, a2, a2.return), Rj(3, a2);
            } catch (t2) {
              W$2(a2, a2.return, t2);
            }
            try {
              Qj(5, a2, a2.return);
            } catch (t2) {
              W$2(a2, a2.return, t2);
            }
          }
          break;
        case 1:
          dk(b2, a2);
          fk(a2);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          break;
        case 5:
          dk(b2, a2);
          fk(a2);
          d2 & 512 && null !== c2 && Mj(c2, c2.return);
          if (a2.flags & 32) {
            var e2 = a2.stateNode;
            try {
              ob(e2, "");
            } catch (t2) {
              W$2(a2, a2.return, t2);
            }
          }
          if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
            var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
            a2.updateQueue = null;
            if (null !== k2)
              try {
                "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
                vb(h2, g2);
                var l2 = vb(h2, f2);
                for (g2 = 0; g2 < k2.length; g2 += 2) {
                  var m2 = k2[g2], q2 = k2[g2 + 1];
                  "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
                }
                switch (h2) {
                  case "input":
                    bb(e2, f2);
                    break;
                  case "textarea":
                    ib(e2, f2);
                    break;
                  case "select":
                    var r2 = e2._wrapperState.wasMultiple;
                    e2._wrapperState.wasMultiple = !!f2.multiple;
                    var y2 = f2.value;
                    null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                      e2,
                      !!f2.multiple,
                      f2.defaultValue,
                      true
                    ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
                }
                e2[Pf] = f2;
              } catch (t2) {
                W$2(a2, a2.return, t2);
              }
          }
          break;
        case 6:
          dk(b2, a2);
          fk(a2);
          if (d2 & 4) {
            if (null === a2.stateNode)
              throw Error(p$5(162));
            e2 = a2.stateNode;
            f2 = a2.memoizedProps;
            try {
              e2.nodeValue = f2;
            } catch (t2) {
              W$2(a2, a2.return, t2);
            }
          }
          break;
        case 3:
          dk(b2, a2);
          fk(a2);
          if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
            try {
              bd(b2.containerInfo);
            } catch (t2) {
              W$2(a2, a2.return, t2);
            }
          break;
        case 4:
          dk(b2, a2);
          fk(a2);
          break;
        case 13:
          dk(b2, a2);
          fk(a2);
          e2 = a2.child;
          e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$4()));
          d2 & 4 && bk(a2);
          break;
        case 22:
          m2 = null !== c2 && null !== c2.memoizedState;
          a2.mode & 1 ? (U$4 = (l2 = U$4) || m2, dk(b2, a2), U$4 = l2) : dk(b2, a2);
          fk(a2);
          if (d2 & 8192) {
            l2 = null !== a2.memoizedState;
            if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
              for (V$2 = a2, m2 = a2.child; null !== m2; ) {
                for (q2 = V$2 = m2; null !== V$2; ) {
                  r2 = V$2;
                  y2 = r2.child;
                  switch (r2.tag) {
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                      Qj(4, r2, r2.return);
                      break;
                    case 1:
                      Mj(r2, r2.return);
                      var n2 = r2.stateNode;
                      if ("function" === typeof n2.componentWillUnmount) {
                        d2 = r2;
                        c2 = r2.return;
                        try {
                          b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                        } catch (t2) {
                          W$2(d2, c2, t2);
                        }
                      }
                      break;
                    case 5:
                      Mj(r2, r2.return);
                      break;
                    case 22:
                      if (null !== r2.memoizedState) {
                        hk(q2);
                        continue;
                      }
                  }
                  null !== y2 ? (y2.return = r2, V$2 = y2) : hk(q2);
                }
                m2 = m2.sibling;
              }
            a:
              for (m2 = null, q2 = a2; ; ) {
                if (5 === q2.tag) {
                  if (null === m2) {
                    m2 = q2;
                    try {
                      e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                    } catch (t2) {
                      W$2(a2, a2.return, t2);
                    }
                  }
                } else if (6 === q2.tag) {
                  if (null === m2)
                    try {
                      q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                    } catch (t2) {
                      W$2(a2, a2.return, t2);
                    }
                } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
                  q2.child.return = q2;
                  q2 = q2.child;
                  continue;
                }
                if (q2 === a2)
                  break a;
                for (; null === q2.sibling; ) {
                  if (null === q2.return || q2.return === a2)
                    break a;
                  m2 === q2 && (m2 = null);
                  q2 = q2.return;
                }
                m2 === q2 && (m2 = null);
                q2.sibling.return = q2.return;
                q2 = q2.sibling;
              }
          }
          break;
        case 19:
          dk(b2, a2);
          fk(a2);
          d2 & 4 && bk(a2);
          break;
        case 21:
          break;
        default:
          dk(
            b2,
            a2
          ), fk(a2);
      }
    }
    function fk(a2) {
      var b2 = a2.flags;
      if (b2 & 2) {
        try {
          a: {
            for (var c2 = a2.return; null !== c2; ) {
              if (Uj(c2)) {
                var d2 = c2;
                break a;
              }
              c2 = c2.return;
            }
            throw Error(p$5(160));
          }
          switch (d2.tag) {
            case 5:
              var e2 = d2.stateNode;
              d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
              var f2 = Vj(a2);
              Xj(a2, f2, e2);
              break;
            case 3:
            case 4:
              var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
              Wj(a2, h2, g2);
              break;
            default:
              throw Error(p$5(161));
          }
        } catch (k2) {
          W$2(a2, a2.return, k2);
        }
        a2.flags &= -3;
      }
      b2 & 4096 && (a2.flags &= -4097);
    }
    function ik(a2, b2, c2) {
      V$2 = a2;
      jk(a2);
    }
    function jk(a2, b2, c2) {
      for (var d2 = 0 !== (a2.mode & 1); null !== V$2; ) {
        var e2 = V$2, f2 = e2.child;
        if (22 === e2.tag && d2) {
          var g2 = null !== e2.memoizedState || Kj;
          if (!g2) {
            var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$4;
            h2 = Kj;
            var l2 = U$4;
            Kj = g2;
            if ((U$4 = k2) && !l2)
              for (V$2 = e2; null !== V$2; )
                g2 = V$2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$2 = k2) : kk(e2);
            for (; null !== f2; )
              V$2 = f2, jk(f2), f2 = f2.sibling;
            V$2 = e2;
            Kj = h2;
            U$4 = l2;
          }
          lk(a2);
        } else
          0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$2 = f2) : lk(a2);
      }
    }
    function lk(a2) {
      for (; null !== V$2; ) {
        var b2 = V$2;
        if (0 !== (b2.flags & 8772)) {
          var c2 = b2.alternate;
          try {
            if (0 !== (b2.flags & 8772))
              switch (b2.tag) {
                case 0:
                case 11:
                case 15:
                  U$4 || Rj(5, b2);
                  break;
                case 1:
                  var d2 = b2.stateNode;
                  if (b2.flags & 4 && !U$4)
                    if (null === c2)
                      d2.componentDidMount();
                    else {
                      var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                      d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                    }
                  var f2 = b2.updateQueue;
                  null !== f2 && ih(b2, f2, d2);
                  break;
                case 3:
                  var g2 = b2.updateQueue;
                  if (null !== g2) {
                    c2 = null;
                    if (null !== b2.child)
                      switch (b2.child.tag) {
                        case 5:
                          c2 = b2.child.stateNode;
                          break;
                        case 1:
                          c2 = b2.child.stateNode;
                      }
                    ih(b2, g2, c2);
                  }
                  break;
                case 5:
                  var h2 = b2.stateNode;
                  if (null === c2 && b2.flags & 4) {
                    c2 = h2;
                    var k2 = b2.memoizedProps;
                    switch (b2.type) {
                      case "button":
                      case "input":
                      case "select":
                      case "textarea":
                        k2.autoFocus && c2.focus();
                        break;
                      case "img":
                        k2.src && (c2.src = k2.src);
                    }
                  }
                  break;
                case 6:
                  break;
                case 4:
                  break;
                case 12:
                  break;
                case 13:
                  if (null === b2.memoizedState) {
                    var l2 = b2.alternate;
                    if (null !== l2) {
                      var m2 = l2.memoizedState;
                      if (null !== m2) {
                        var q2 = m2.dehydrated;
                        null !== q2 && bd(q2);
                      }
                    }
                  }
                  break;
                case 19:
                case 17:
                case 21:
                case 22:
                case 23:
                case 25:
                  break;
                default:
                  throw Error(p$5(163));
              }
            U$4 || b2.flags & 512 && Sj(b2);
          } catch (r2) {
            W$2(b2, b2.return, r2);
          }
        }
        if (b2 === a2) {
          V$2 = null;
          break;
        }
        c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V$2 = c2;
          break;
        }
        V$2 = b2.return;
      }
    }
    function hk(a2) {
      for (; null !== V$2; ) {
        var b2 = V$2;
        if (b2 === a2) {
          V$2 = null;
          break;
        }
        var c2 = b2.sibling;
        if (null !== c2) {
          c2.return = b2.return;
          V$2 = c2;
          break;
        }
        V$2 = b2.return;
      }
    }
    function kk(a2) {
      for (; null !== V$2; ) {
        var b2 = V$2;
        try {
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              var c2 = b2.return;
              try {
                Rj(4, b2);
              } catch (k2) {
                W$2(b2, c2, k2);
              }
              break;
            case 1:
              var d2 = b2.stateNode;
              if ("function" === typeof d2.componentDidMount) {
                var e2 = b2.return;
                try {
                  d2.componentDidMount();
                } catch (k2) {
                  W$2(b2, e2, k2);
                }
              }
              var f2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W$2(b2, f2, k2);
              }
              break;
            case 5:
              var g2 = b2.return;
              try {
                Sj(b2);
              } catch (k2) {
                W$2(b2, g2, k2);
              }
          }
        } catch (k2) {
          W$2(b2, b2.return, k2);
        }
        if (b2 === a2) {
          V$2 = null;
          break;
        }
        var h2 = b2.sibling;
        if (null !== h2) {
          h2.return = b2.return;
          V$2 = h2;
          break;
        }
        V$2 = b2.return;
      }
    }
    var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$2 = 0, R$3 = null, Y$2 = null, Z$3 = 0, gj = 0, fj = Uf(0), T$2 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
    function L$4() {
      return 0 !== (K$2 & 6) ? B$4() : -1 !== Bk ? Bk : Bk = B$4();
    }
    function lh(a2) {
      if (0 === (a2.mode & 1))
        return 1;
      if (0 !== (K$2 & 2) && 0 !== Z$3)
        return Z$3 & -Z$3;
      if (null !== Kg.transition)
        return 0 === Ck && (Ck = yc()), Ck;
      a2 = C$2;
      if (0 !== a2)
        return a2;
      a2 = window.event;
      a2 = void 0 === a2 ? 16 : jd(a2.type);
      return a2;
    }
    function mh(a2, b2, c2, d2) {
      if (50 < zk)
        throw zk = 0, Ak = null, Error(p$5(185));
      Ac(a2, c2, d2);
      if (0 === (K$2 & 2) || a2 !== R$3)
        a2 === R$3 && (0 === (K$2 & 2) && (rk |= c2), 4 === T$2 && Dk(a2, Z$3)), Ek(a2, d2), 1 === c2 && 0 === K$2 && 0 === (b2.mode & 1) && (Hj = B$4() + 500, fg && jg());
    }
    function Ek(a2, b2) {
      var c2 = a2.callbackNode;
      wc(a2, b2);
      var d2 = uc(a2, a2 === R$3 ? Z$3 : 0);
      if (0 === d2)
        null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
      else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
        null != c2 && bc(c2);
        if (1 === b2)
          0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
            0 === (K$2 & 6) && jg();
          }), c2 = null;
        else {
          switch (Dc(d2)) {
            case 1:
              c2 = fc;
              break;
            case 4:
              c2 = gc;
              break;
            case 16:
              c2 = hc;
              break;
            case 536870912:
              c2 = jc;
              break;
            default:
              c2 = hc;
          }
          c2 = Gk(c2, Hk.bind(null, a2));
        }
        a2.callbackPriority = b2;
        a2.callbackNode = c2;
      }
    }
    function Hk(a2, b2) {
      Bk = -1;
      Ck = 0;
      if (0 !== (K$2 & 6))
        throw Error(p$5(327));
      var c2 = a2.callbackNode;
      if (Ik() && a2.callbackNode !== c2)
        return null;
      var d2 = uc(a2, a2 === R$3 ? Z$3 : 0);
      if (0 === d2)
        return null;
      if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
        b2 = Jk(a2, d2);
      else {
        b2 = d2;
        var e2 = K$2;
        K$2 |= 2;
        var f2 = Kk();
        if (R$3 !== a2 || Z$3 !== b2)
          vk = null, Hj = B$4() + 500, Lk(a2, b2);
        do
          try {
            Mk();
            break;
          } catch (h2) {
            Nk(a2, h2);
          }
        while (1);
        Qg();
        nk.current = f2;
        K$2 = e2;
        null !== Y$2 ? b2 = 0 : (R$3 = null, Z$3 = 0, b2 = T$2);
      }
      if (0 !== b2) {
        2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
        if (1 === b2)
          throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$4()), c2;
        if (6 === b2)
          Dk(a2, d2);
        else {
          e2 = a2.current.alternate;
          if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
            throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$4()), c2;
          a2.finishedWork = e2;
          a2.finishedLanes = d2;
          switch (b2) {
            case 0:
            case 1:
              throw Error(p$5(345));
            case 2:
              Qk(a2, uk, vk);
              break;
            case 3:
              Dk(a2, d2);
              if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$4(), 10 < b2)) {
                if (0 !== uc(a2, 0))
                  break;
                e2 = a2.suspendedLanes;
                if ((e2 & d2) !== d2) {
                  L$4();
                  a2.pingedLanes |= a2.suspendedLanes & e2;
                  break;
                }
                a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
                break;
              }
              Qk(a2, uk, vk);
              break;
            case 4:
              Dk(a2, d2);
              if ((d2 & 4194240) === d2)
                break;
              b2 = a2.eventTimes;
              for (e2 = -1; 0 < d2; ) {
                var g2 = 31 - oc(d2);
                f2 = 1 << g2;
                g2 = b2[g2];
                g2 > e2 && (e2 = g2);
                d2 &= ~f2;
              }
              d2 = e2;
              d2 = B$4() - d2;
              d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
              if (10 < d2) {
                a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
                break;
              }
              Qk(a2, uk, vk);
              break;
            case 5:
              Qk(a2, uk, vk);
              break;
            default:
              throw Error(p$5(329));
          }
        }
      }
      Ek(a2, B$4());
      return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
    }
    function Ok(a2, b2) {
      var c2 = tk;
      a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
      a2 = Jk(a2, b2);
      2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
      return a2;
    }
    function Gj(a2) {
      null === uk ? uk = a2 : uk.push.apply(uk, a2);
    }
    function Pk(a2) {
      for (var b2 = a2; ; ) {
        if (b2.flags & 16384) {
          var c2 = b2.updateQueue;
          if (null !== c2 && (c2 = c2.stores, null !== c2))
            for (var d2 = 0; d2 < c2.length; d2++) {
              var e2 = c2[d2], f2 = e2.getSnapshot;
              e2 = e2.value;
              try {
                if (!He$2(f2(), e2))
                  return false;
              } catch (g2) {
                return false;
              }
            }
        }
        c2 = b2.child;
        if (b2.subtreeFlags & 16384 && null !== c2)
          c2.return = b2, b2 = c2;
        else {
          if (b2 === a2)
            break;
          for (; null === b2.sibling; ) {
            if (null === b2.return || b2.return === a2)
              return true;
            b2 = b2.return;
          }
          b2.sibling.return = b2.return;
          b2 = b2.sibling;
        }
      }
      return true;
    }
    function Dk(a2, b2) {
      b2 &= ~sk;
      b2 &= ~rk;
      a2.suspendedLanes |= b2;
      a2.pingedLanes &= ~b2;
      for (a2 = a2.expirationTimes; 0 < b2; ) {
        var c2 = 31 - oc(b2), d2 = 1 << c2;
        a2[c2] = -1;
        b2 &= ~d2;
      }
    }
    function Fk(a2) {
      if (0 !== (K$2 & 6))
        throw Error(p$5(327));
      Ik();
      var b2 = uc(a2, 0);
      if (0 === (b2 & 1))
        return Ek(a2, B$4()), null;
      var c2 = Jk(a2, b2);
      if (0 !== a2.tag && 2 === c2) {
        var d2 = xc(a2);
        0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
      }
      if (1 === c2)
        throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$4()), c2;
      if (6 === c2)
        throw Error(p$5(345));
      a2.finishedWork = a2.current.alternate;
      a2.finishedLanes = b2;
      Qk(a2, uk, vk);
      Ek(a2, B$4());
      return null;
    }
    function Rk(a2, b2) {
      var c2 = K$2;
      K$2 |= 1;
      try {
        return a2(b2);
      } finally {
        K$2 = c2, 0 === K$2 && (Hj = B$4() + 500, fg && jg());
      }
    }
    function Sk(a2) {
      null !== xk && 0 === xk.tag && 0 === (K$2 & 6) && Ik();
      var b2 = K$2;
      K$2 |= 1;
      var c2 = pk.transition, d2 = C$2;
      try {
        if (pk.transition = null, C$2 = 1, a2)
          return a2();
      } finally {
        C$2 = d2, pk.transition = c2, K$2 = b2, 0 === (K$2 & 6) && jg();
      }
    }
    function Ij() {
      gj = fj.current;
      E$2(fj);
    }
    function Lk(a2, b2) {
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      var c2 = a2.timeoutHandle;
      -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
      if (null !== Y$2)
        for (c2 = Y$2.return; null !== c2; ) {
          var d2 = c2;
          wg(d2);
          switch (d2.tag) {
            case 1:
              d2 = d2.type.childContextTypes;
              null !== d2 && void 0 !== d2 && $f();
              break;
            case 3:
              Jh();
              E$2(Wf);
              E$2(H$3);
              Oh();
              break;
            case 5:
              Lh(d2);
              break;
            case 4:
              Jh();
              break;
            case 13:
              E$2(M$3);
              break;
            case 19:
              E$2(M$3);
              break;
            case 10:
              Rg(d2.type._context);
              break;
            case 22:
            case 23:
              Ij();
          }
          c2 = c2.return;
        }
      R$3 = a2;
      Y$2 = a2 = wh(a2.current, null);
      Z$3 = gj = b2;
      T$2 = 0;
      qk = null;
      sk = rk = hh = 0;
      uk = tk = null;
      if (null !== Wg) {
        for (b2 = 0; b2 < Wg.length; b2++)
          if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
            c2.interleaved = null;
            var e2 = d2.next, f2 = c2.pending;
            if (null !== f2) {
              var g2 = f2.next;
              f2.next = e2;
              d2.next = g2;
            }
            c2.pending = d2;
          }
        Wg = null;
      }
      return a2;
    }
    function Nk(a2, b2) {
      do {
        var c2 = Y$2;
        try {
          Qg();
          Ph.current = ai$1;
          if (Sh) {
            for (var d2 = N$2.memoizedState; null !== d2; ) {
              var e2 = d2.queue;
              null !== e2 && (e2.pending = null);
              d2 = d2.next;
            }
            Sh = false;
          }
          Rh = 0;
          P$4 = O$2 = N$2 = null;
          Th = false;
          Uh = 0;
          ok.current = null;
          if (null === c2 || null === c2.return) {
            T$2 = 1;
            qk = b2;
            Y$2 = null;
            break;
          }
          a: {
            var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
            b2 = Z$3;
            h2.flags |= 32768;
            if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
              var l2 = k2, m2 = h2, q2 = m2.tag;
              if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
                var r2 = m2.alternate;
                r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
              }
              var y2 = Vi(g2);
              if (null !== y2) {
                y2.flags &= -257;
                Wi(y2, g2, h2, f2, b2);
                y2.mode & 1 && Ti(f2, l2, b2);
                b2 = y2;
                k2 = l2;
                var n2 = b2.updateQueue;
                if (null === n2) {
                  var t2 = /* @__PURE__ */ new Set();
                  t2.add(k2);
                  b2.updateQueue = t2;
                } else
                  n2.add(k2);
                break a;
              } else {
                if (0 === (b2 & 1)) {
                  Ti(f2, l2, b2);
                  uj();
                  break a;
                }
                k2 = Error(p$5(426));
              }
            } else if (I$3 && h2.mode & 1) {
              var J2 = Vi(g2);
              if (null !== J2) {
                0 === (J2.flags & 65536) && (J2.flags |= 256);
                Wi(J2, g2, h2, f2, b2);
                Jg(Ki(k2, h2));
                break a;
              }
            }
            f2 = k2 = Ki(k2, h2);
            4 !== T$2 && (T$2 = 2);
            null === tk ? tk = [f2] : tk.push(f2);
            f2 = g2;
            do {
              switch (f2.tag) {
                case 3:
                  f2.flags |= 65536;
                  b2 &= -b2;
                  f2.lanes |= b2;
                  var x2 = Oi(f2, k2, b2);
                  fh(f2, x2);
                  break a;
                case 1:
                  h2 = k2;
                  var w2 = f2.type, u2 = f2.stateNode;
                  if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                    f2.flags |= 65536;
                    b2 &= -b2;
                    f2.lanes |= b2;
                    var F2 = Ri(f2, h2, b2);
                    fh(f2, F2);
                    break a;
                  }
              }
              f2 = f2.return;
            } while (null !== f2);
          }
          Tk(c2);
        } catch (na) {
          b2 = na;
          Y$2 === c2 && null !== c2 && (Y$2 = c2 = c2.return);
          continue;
        }
        break;
      } while (1);
    }
    function Kk() {
      var a2 = nk.current;
      nk.current = ai$1;
      return null === a2 ? ai$1 : a2;
    }
    function uj() {
      if (0 === T$2 || 3 === T$2 || 2 === T$2)
        T$2 = 4;
      null === R$3 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$3, Z$3);
    }
    function Jk(a2, b2) {
      var c2 = K$2;
      K$2 |= 2;
      var d2 = Kk();
      if (R$3 !== a2 || Z$3 !== b2)
        vk = null, Lk(a2, b2);
      do
        try {
          Uk();
          break;
        } catch (e2) {
          Nk(a2, e2);
        }
      while (1);
      Qg();
      K$2 = c2;
      nk.current = d2;
      if (null !== Y$2)
        throw Error(p$5(261));
      R$3 = null;
      Z$3 = 0;
      return T$2;
    }
    function Uk() {
      for (; null !== Y$2; )
        Vk(Y$2);
    }
    function Mk() {
      for (; null !== Y$2 && !cc(); )
        Vk(Y$2);
    }
    function Vk(a2) {
      var b2 = Wk(a2.alternate, a2, gj);
      a2.memoizedProps = a2.pendingProps;
      null === b2 ? Tk(a2) : Y$2 = b2;
      ok.current = null;
    }
    function Tk(a2) {
      var b2 = a2;
      do {
        var c2 = b2.alternate;
        a2 = b2.return;
        if (0 === (b2.flags & 32768)) {
          if (c2 = Fj(c2, b2, gj), null !== c2) {
            Y$2 = c2;
            return;
          }
        } else {
          c2 = Jj(c2, b2);
          if (null !== c2) {
            c2.flags &= 32767;
            Y$2 = c2;
            return;
          }
          if (null !== a2)
            a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
          else {
            T$2 = 6;
            Y$2 = null;
            return;
          }
        }
        b2 = b2.sibling;
        if (null !== b2) {
          Y$2 = b2;
          return;
        }
        Y$2 = b2 = a2;
      } while (null !== b2);
      0 === T$2 && (T$2 = 5);
    }
    function Qk(a2, b2, c2) {
      var d2 = C$2, e2 = pk.transition;
      try {
        pk.transition = null, C$2 = 1, Xk(a2, b2, c2, d2);
      } finally {
        pk.transition = e2, C$2 = d2;
      }
      return null;
    }
    function Xk(a2, b2, c2, d2) {
      do
        Ik();
      while (null !== xk);
      if (0 !== (K$2 & 6))
        throw Error(p$5(327));
      c2 = a2.finishedWork;
      var e2 = a2.finishedLanes;
      if (null === c2)
        return null;
      a2.finishedWork = null;
      a2.finishedLanes = 0;
      if (c2 === a2.current)
        throw Error(p$5(177));
      a2.callbackNode = null;
      a2.callbackPriority = 0;
      var f2 = c2.lanes | c2.childLanes;
      Bc(a2, f2);
      a2 === R$3 && (Y$2 = R$3 = null, Z$3 = 0);
      0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
        Ik();
        return null;
      }));
      f2 = 0 !== (c2.flags & 15990);
      if (0 !== (c2.subtreeFlags & 15990) || f2) {
        f2 = pk.transition;
        pk.transition = null;
        var g2 = C$2;
        C$2 = 1;
        var h2 = K$2;
        K$2 |= 4;
        ok.current = null;
        Pj(a2, c2);
        ek(c2, a2);
        Oe$2(Df);
        dd = !!Cf;
        Df = Cf = null;
        a2.current = c2;
        ik(c2);
        dc();
        K$2 = h2;
        C$2 = g2;
        pk.transition = f2;
      } else
        a2.current = c2;
      wk && (wk = false, xk = a2, yk = e2);
      f2 = a2.pendingLanes;
      0 === f2 && (Si = null);
      mc(c2.stateNode);
      Ek(a2, B$4());
      if (null !== b2)
        for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
          e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
      if (Pi)
        throw Pi = false, a2 = Qi, Qi = null, a2;
      0 !== (yk & 1) && 0 !== a2.tag && Ik();
      f2 = a2.pendingLanes;
      0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
      jg();
      return null;
    }
    function Ik() {
      if (null !== xk) {
        var a2 = Dc(yk), b2 = pk.transition, c2 = C$2;
        try {
          pk.transition = null;
          C$2 = 16 > a2 ? 16 : a2;
          if (null === xk)
            var d2 = false;
          else {
            a2 = xk;
            xk = null;
            yk = 0;
            if (0 !== (K$2 & 6))
              throw Error(p$5(331));
            var e2 = K$2;
            K$2 |= 4;
            for (V$2 = a2.current; null !== V$2; ) {
              var f2 = V$2, g2 = f2.child;
              if (0 !== (V$2.flags & 16)) {
                var h2 = f2.deletions;
                if (null !== h2) {
                  for (var k2 = 0; k2 < h2.length; k2++) {
                    var l2 = h2[k2];
                    for (V$2 = l2; null !== V$2; ) {
                      var m2 = V$2;
                      switch (m2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(8, m2, f2);
                      }
                      var q2 = m2.child;
                      if (null !== q2)
                        q2.return = m2, V$2 = q2;
                      else
                        for (; null !== V$2; ) {
                          m2 = V$2;
                          var r2 = m2.sibling, y2 = m2.return;
                          Tj(m2);
                          if (m2 === l2) {
                            V$2 = null;
                            break;
                          }
                          if (null !== r2) {
                            r2.return = y2;
                            V$2 = r2;
                            break;
                          }
                          V$2 = y2;
                        }
                    }
                  }
                  var n2 = f2.alternate;
                  if (null !== n2) {
                    var t2 = n2.child;
                    if (null !== t2) {
                      n2.child = null;
                      do {
                        var J2 = t2.sibling;
                        t2.sibling = null;
                        t2 = J2;
                      } while (null !== t2);
                    }
                  }
                  V$2 = f2;
                }
              }
              if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
                g2.return = f2, V$2 = g2;
              else
                b:
                  for (; null !== V$2; ) {
                    f2 = V$2;
                    if (0 !== (f2.flags & 2048))
                      switch (f2.tag) {
                        case 0:
                        case 11:
                        case 15:
                          Qj(9, f2, f2.return);
                      }
                    var x2 = f2.sibling;
                    if (null !== x2) {
                      x2.return = f2.return;
                      V$2 = x2;
                      break b;
                    }
                    V$2 = f2.return;
                  }
            }
            var w2 = a2.current;
            for (V$2 = w2; null !== V$2; ) {
              g2 = V$2;
              var u2 = g2.child;
              if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
                u2.return = g2, V$2 = u2;
              else
                b:
                  for (g2 = w2; null !== V$2; ) {
                    h2 = V$2;
                    if (0 !== (h2.flags & 2048))
                      try {
                        switch (h2.tag) {
                          case 0:
                          case 11:
                          case 15:
                            Rj(9, h2);
                        }
                      } catch (na) {
                        W$2(h2, h2.return, na);
                      }
                    if (h2 === g2) {
                      V$2 = null;
                      break b;
                    }
                    var F2 = h2.sibling;
                    if (null !== F2) {
                      F2.return = h2.return;
                      V$2 = F2;
                      break b;
                    }
                    V$2 = h2.return;
                  }
            }
            K$2 = e2;
            jg();
            if (lc && "function" === typeof lc.onPostCommitFiberRoot)
              try {
                lc.onPostCommitFiberRoot(kc, a2);
              } catch (na) {
              }
            d2 = true;
          }
          return d2;
        } finally {
          C$2 = c2, pk.transition = b2;
        }
      }
      return false;
    }
    function Yk(a2, b2, c2) {
      b2 = Ki(c2, b2);
      b2 = Oi(a2, b2, 1);
      a2 = dh(a2, b2, 1);
      b2 = L$4();
      null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
    }
    function W$2(a2, b2, c2) {
      if (3 === a2.tag)
        Yk(a2, a2, c2);
      else
        for (; null !== b2; ) {
          if (3 === b2.tag) {
            Yk(b2, a2, c2);
            break;
          } else if (1 === b2.tag) {
            var d2 = b2.stateNode;
            if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
              a2 = Ki(c2, a2);
              a2 = Ri(b2, a2, 1);
              b2 = dh(b2, a2, 1);
              a2 = L$4();
              null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
              break;
            }
          }
          b2 = b2.return;
        }
    }
    function Ui(a2, b2, c2) {
      var d2 = a2.pingCache;
      null !== d2 && d2.delete(b2);
      b2 = L$4();
      a2.pingedLanes |= a2.suspendedLanes & c2;
      R$3 === a2 && (Z$3 & c2) === c2 && (4 === T$2 || 3 === T$2 && (Z$3 & 130023424) === Z$3 && 500 > B$4() - gk ? Lk(a2, 0) : sk |= c2);
      Ek(a2, b2);
    }
    function Zk(a2, b2) {
      0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
      var c2 = L$4();
      a2 = Zg(a2, b2);
      null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
    }
    function vj(a2) {
      var b2 = a2.memoizedState, c2 = 0;
      null !== b2 && (c2 = b2.retryLane);
      Zk(a2, c2);
    }
    function ck(a2, b2) {
      var c2 = 0;
      switch (a2.tag) {
        case 13:
          var d2 = a2.stateNode;
          var e2 = a2.memoizedState;
          null !== e2 && (c2 = e2.retryLane);
          break;
        case 19:
          d2 = a2.stateNode;
          break;
        default:
          throw Error(p$5(314));
      }
      null !== d2 && d2.delete(b2);
      Zk(a2, c2);
    }
    var Wk;
    Wk = function(a2, b2, c2) {
      if (null !== a2)
        if (a2.memoizedProps !== b2.pendingProps || Wf.current)
          Ug = true;
        else {
          if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
            return Ug = false, zj(a2, b2, c2);
          Ug = 0 !== (a2.flags & 131072) ? true : false;
        }
      else
        Ug = false, I$3 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
      b2.lanes = 0;
      switch (b2.tag) {
        case 2:
          var d2 = b2.type;
          jj(a2, b2);
          a2 = b2.pendingProps;
          var e2 = Yf(b2, H$3.current);
          Tg(b2, c2);
          e2 = Xh(null, b2, d2, a2, e2, c2);
          var f2 = bi$1();
          b2.flags |= 1;
          "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$3 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
          return b2;
        case 16:
          d2 = b2.elementType;
          a: {
            jj(a2, b2);
            a2 = b2.pendingProps;
            e2 = d2._init;
            d2 = e2(d2._payload);
            b2.type = d2;
            e2 = b2.tag = $k(d2);
            a2 = Lg(d2, a2);
            switch (e2) {
              case 0:
                b2 = dj(null, b2, d2, a2, c2);
                break a;
              case 1:
                b2 = ij(null, b2, d2, a2, c2);
                break a;
              case 11:
                b2 = Zi(null, b2, d2, a2, c2);
                break a;
              case 14:
                b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
                break a;
            }
            throw Error(p$5(
              306,
              d2,
              ""
            ));
          }
          return b2;
        case 0:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
        case 1:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
        case 3:
          a: {
            lj(b2);
            if (null === a2)
              throw Error(p$5(387));
            d2 = b2.pendingProps;
            f2 = b2.memoizedState;
            e2 = f2.element;
            bh(a2, b2);
            gh(b2, d2, null, c2);
            var g2 = b2.memoizedState;
            d2 = g2.element;
            if (f2.isDehydrated)
              if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
                e2 = Ki(Error(p$5(423)), b2);
                b2 = mj(a2, b2, d2, c2, e2);
                break a;
              } else if (d2 !== e2) {
                e2 = Ki(Error(p$5(424)), b2);
                b2 = mj(a2, b2, d2, c2, e2);
                break a;
              } else
                for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$3 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
                  c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
            else {
              Ig();
              if (d2 === e2) {
                b2 = $i(a2, b2, c2);
                break a;
              }
              Yi(a2, b2, d2, c2);
            }
            b2 = b2.child;
          }
          return b2;
        case 5:
          return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
        case 6:
          return null === a2 && Eg(b2), null;
        case 13:
          return pj(a2, b2, c2);
        case 4:
          return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
        case 11:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
        case 7:
          return Yi(a2, b2, b2.pendingProps, c2), b2.child;
        case 8:
          return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 12:
          return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
        case 10:
          a: {
            d2 = b2.type._context;
            e2 = b2.pendingProps;
            f2 = b2.memoizedProps;
            g2 = e2.value;
            G$3(Mg, d2._currentValue);
            d2._currentValue = g2;
            if (null !== f2)
              if (He$2(f2.value, g2)) {
                if (f2.children === e2.children && !Wf.current) {
                  b2 = $i(a2, b2, c2);
                  break a;
                }
              } else
                for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
                  var h2 = f2.dependencies;
                  if (null !== h2) {
                    g2 = f2.child;
                    for (var k2 = h2.firstContext; null !== k2; ) {
                      if (k2.context === d2) {
                        if (1 === f2.tag) {
                          k2 = ch(-1, c2 & -c2);
                          k2.tag = 2;
                          var l2 = f2.updateQueue;
                          if (null !== l2) {
                            l2 = l2.shared;
                            var m2 = l2.pending;
                            null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                            l2.pending = k2;
                          }
                        }
                        f2.lanes |= c2;
                        k2 = f2.alternate;
                        null !== k2 && (k2.lanes |= c2);
                        Sg(
                          f2.return,
                          c2,
                          b2
                        );
                        h2.lanes |= c2;
                        break;
                      }
                      k2 = k2.next;
                    }
                  } else if (10 === f2.tag)
                    g2 = f2.type === b2.type ? null : f2.child;
                  else if (18 === f2.tag) {
                    g2 = f2.return;
                    if (null === g2)
                      throw Error(p$5(341));
                    g2.lanes |= c2;
                    h2 = g2.alternate;
                    null !== h2 && (h2.lanes |= c2);
                    Sg(g2, c2, b2);
                    g2 = f2.sibling;
                  } else
                    g2 = f2.child;
                  if (null !== g2)
                    g2.return = f2;
                  else
                    for (g2 = f2; null !== g2; ) {
                      if (g2 === b2) {
                        g2 = null;
                        break;
                      }
                      f2 = g2.sibling;
                      if (null !== f2) {
                        f2.return = g2.return;
                        g2 = f2;
                        break;
                      }
                      g2 = g2.return;
                    }
                  f2 = g2;
                }
            Yi(a2, b2, e2.children, c2);
            b2 = b2.child;
          }
          return b2;
        case 9:
          return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
        case 14:
          return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
        case 15:
          return cj(a2, b2, b2.type, b2.pendingProps, c2);
        case 17:
          return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
        case 19:
          return yj(a2, b2, c2);
        case 22:
          return ej(a2, b2, c2);
      }
      throw Error(p$5(156, b2.tag));
    };
    function Gk(a2, b2) {
      return ac(a2, b2);
    }
    function al(a2, b2, c2, d2) {
      this.tag = a2;
      this.key = c2;
      this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
      this.index = 0;
      this.ref = null;
      this.pendingProps = b2;
      this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
      this.mode = d2;
      this.subtreeFlags = this.flags = 0;
      this.deletions = null;
      this.childLanes = this.lanes = 0;
      this.alternate = null;
    }
    function Bg(a2, b2, c2, d2) {
      return new al(a2, b2, c2, d2);
    }
    function bj(a2) {
      a2 = a2.prototype;
      return !(!a2 || !a2.isReactComponent);
    }
    function $k(a2) {
      if ("function" === typeof a2)
        return bj(a2) ? 1 : 0;
      if (void 0 !== a2 && null !== a2) {
        a2 = a2.$$typeof;
        if (a2 === Da)
          return 11;
        if (a2 === Ga)
          return 14;
      }
      return 2;
    }
    function wh(a2, b2) {
      var c2 = a2.alternate;
      null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
      c2.flags = a2.flags & 14680064;
      c2.childLanes = a2.childLanes;
      c2.lanes = a2.lanes;
      c2.child = a2.child;
      c2.memoizedProps = a2.memoizedProps;
      c2.memoizedState = a2.memoizedState;
      c2.updateQueue = a2.updateQueue;
      b2 = a2.dependencies;
      c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
      c2.sibling = a2.sibling;
      c2.index = a2.index;
      c2.ref = a2.ref;
      return c2;
    }
    function yh(a2, b2, c2, d2, e2, f2) {
      var g2 = 2;
      d2 = a2;
      if ("function" === typeof a2)
        bj(a2) && (g2 = 1);
      else if ("string" === typeof a2)
        g2 = 5;
      else
        a:
          switch (a2) {
            case ya:
              return Ah(c2.children, e2, f2, b2);
            case za:
              g2 = 8;
              e2 |= 8;
              break;
            case Aa:
              return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
            case Ea:
              return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
            case Fa:
              return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
            case Ia:
              return qj(c2, e2, f2, b2);
            default:
              if ("object" === typeof a2 && null !== a2)
                switch (a2.$$typeof) {
                  case Ba:
                    g2 = 10;
                    break a;
                  case Ca:
                    g2 = 9;
                    break a;
                  case Da:
                    g2 = 11;
                    break a;
                  case Ga:
                    g2 = 14;
                    break a;
                  case Ha:
                    g2 = 16;
                    d2 = null;
                    break a;
                }
              throw Error(p$5(130, null == a2 ? a2 : typeof a2, ""));
          }
      b2 = Bg(g2, c2, b2, e2);
      b2.elementType = a2;
      b2.type = d2;
      b2.lanes = f2;
      return b2;
    }
    function Ah(a2, b2, c2, d2) {
      a2 = Bg(7, a2, d2, b2);
      a2.lanes = c2;
      return a2;
    }
    function qj(a2, b2, c2, d2) {
      a2 = Bg(22, a2, d2, b2);
      a2.elementType = Ia;
      a2.lanes = c2;
      a2.stateNode = { isHidden: false };
      return a2;
    }
    function xh(a2, b2, c2) {
      a2 = Bg(6, a2, null, b2);
      a2.lanes = c2;
      return a2;
    }
    function zh(a2, b2, c2) {
      b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
      b2.lanes = c2;
      b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
      return b2;
    }
    function bl(a2, b2, c2, d2, e2) {
      this.tag = b2;
      this.containerInfo = a2;
      this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
      this.timeoutHandle = -1;
      this.callbackNode = this.pendingContext = this.context = null;
      this.callbackPriority = 0;
      this.eventTimes = zc(0);
      this.expirationTimes = zc(-1);
      this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
      this.entanglements = zc(0);
      this.identifierPrefix = d2;
      this.onRecoverableError = e2;
      this.mutableSourceEagerHydrationData = null;
    }
    function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      a2 = new bl(a2, b2, c2, h2, k2);
      1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
      f2 = Bg(3, null, null, b2);
      a2.current = f2;
      f2.stateNode = a2;
      f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
      ah(f2);
      return a2;
    }
    function dl(a2, b2, c2) {
      var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
      return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
    }
    function el(a2) {
      if (!a2)
        return Vf;
      a2 = a2._reactInternals;
      a: {
        if (Vb(a2) !== a2 || 1 !== a2.tag)
          throw Error(p$5(170));
        var b2 = a2;
        do {
          switch (b2.tag) {
            case 3:
              b2 = b2.stateNode.context;
              break a;
            case 1:
              if (Zf(b2.type)) {
                b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
                break a;
              }
          }
          b2 = b2.return;
        } while (null !== b2);
        throw Error(p$5(171));
      }
      if (1 === a2.tag) {
        var c2 = a2.type;
        if (Zf(c2))
          return bg(a2, c2, b2);
      }
      return b2;
    }
    function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
      a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
      a2.context = el(null);
      c2 = a2.current;
      d2 = L$4();
      e2 = lh(c2);
      f2 = ch(d2, e2);
      f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
      dh(c2, f2, e2);
      a2.current.lanes = e2;
      Ac(a2, e2, d2);
      Ek(a2, d2);
      return a2;
    }
    function gl(a2, b2, c2, d2) {
      var e2 = b2.current, f2 = L$4(), g2 = lh(e2);
      c2 = el(c2);
      null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
      b2 = ch(f2, g2);
      b2.payload = { element: a2 };
      d2 = void 0 === d2 ? null : d2;
      null !== d2 && (b2.callback = d2);
      a2 = dh(e2, b2, g2);
      null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
      return g2;
    }
    function hl(a2) {
      a2 = a2.current;
      if (!a2.child)
        return null;
      switch (a2.child.tag) {
        case 5:
          return a2.child.stateNode;
        default:
          return a2.child.stateNode;
      }
    }
    function il(a2, b2) {
      a2 = a2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        var c2 = a2.retryLane;
        a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
      }
    }
    function jl(a2, b2) {
      il(a2, b2);
      (a2 = a2.alternate) && il(a2, b2);
    }
    function kl() {
      return null;
    }
    var ll = "function" === typeof reportError ? reportError : function(a2) {
      console.error(a2);
    };
    function ml(a2) {
      this._internalRoot = a2;
    }
    nl.prototype.render = ml.prototype.render = function(a2) {
      var b2 = this._internalRoot;
      if (null === b2)
        throw Error(p$5(409));
      gl(a2, b2, null, null);
    };
    nl.prototype.unmount = ml.prototype.unmount = function() {
      var a2 = this._internalRoot;
      if (null !== a2) {
        this._internalRoot = null;
        var b2 = a2.containerInfo;
        Sk(function() {
          gl(null, a2, null, null);
        });
        b2[uf] = null;
      }
    };
    function nl(a2) {
      this._internalRoot = a2;
    }
    nl.prototype.unstable_scheduleHydration = function(a2) {
      if (a2) {
        var b2 = Hc();
        a2 = { blockedOn: null, target: a2, priority: b2 };
        for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
          ;
        Qc.splice(c2, 0, a2);
        0 === c2 && Vc(a2);
      }
    };
    function ol(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
    }
    function pl(a2) {
      return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
    }
    function ql() {
    }
    function rl(a2, b2, c2, d2, e2) {
      if (e2) {
        if ("function" === typeof d2) {
          var f2 = d2;
          d2 = function() {
            var a3 = hl(g2);
            f2.call(a3);
          };
        }
        var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
        a2._reactRootContainer = g2;
        a2[uf] = g2.current;
        sf(8 === a2.nodeType ? a2.parentNode : a2);
        Sk();
        return g2;
      }
      for (; e2 = a2.lastChild; )
        a2.removeChild(e2);
      if ("function" === typeof d2) {
        var h2 = d2;
        d2 = function() {
          var a3 = hl(k2);
          h2.call(a3);
        };
      }
      var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
      a2._reactRootContainer = k2;
      a2[uf] = k2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      Sk(function() {
        gl(b2, k2, c2, d2);
      });
      return k2;
    }
    function sl(a2, b2, c2, d2, e2) {
      var f2 = c2._reactRootContainer;
      if (f2) {
        var g2 = f2;
        if ("function" === typeof e2) {
          var h2 = e2;
          e2 = function() {
            var a3 = hl(g2);
            h2.call(a3);
          };
        }
        gl(b2, g2, a2, e2);
      } else
        g2 = rl(c2, b2, a2, e2, d2);
      return hl(g2);
    }
    Ec = function(a2) {
      switch (a2.tag) {
        case 3:
          var b2 = a2.stateNode;
          if (b2.current.memoizedState.isDehydrated) {
            var c2 = tc(b2.pendingLanes);
            0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$4()), 0 === (K$2 & 6) && (Hj = B$4() + 500, jg()));
          }
          break;
        case 13:
          Sk(function() {
            var b3 = Zg(a2, 1);
            if (null !== b3) {
              var c3 = L$4();
              mh(b3, a2, 1, c3);
            }
          }), jl(a2, 1);
      }
    };
    Fc = function(a2) {
      if (13 === a2.tag) {
        var b2 = Zg(a2, 134217728);
        if (null !== b2) {
          var c2 = L$4();
          mh(b2, a2, 134217728, c2);
        }
        jl(a2, 134217728);
      }
    };
    Gc = function(a2) {
      if (13 === a2.tag) {
        var b2 = lh(a2), c2 = Zg(a2, b2);
        if (null !== c2) {
          var d2 = L$4();
          mh(c2, a2, b2, d2);
        }
        jl(a2, b2);
      }
    };
    Hc = function() {
      return C$2;
    };
    Ic = function(a2, b2) {
      var c2 = C$2;
      try {
        return C$2 = a2, b2();
      } finally {
        C$2 = c2;
      }
    };
    yb = function(a2, b2, c2) {
      switch (b2) {
        case "input":
          bb(a2, c2);
          b2 = c2.name;
          if ("radio" === c2.type && null != b2) {
            for (c2 = a2; c2.parentNode; )
              c2 = c2.parentNode;
            c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
            for (b2 = 0; b2 < c2.length; b2++) {
              var d2 = c2[b2];
              if (d2 !== a2 && d2.form === a2.form) {
                var e2 = Db(d2);
                if (!e2)
                  throw Error(p$5(90));
                Wa(d2);
                bb(d2, e2);
              }
            }
          }
          break;
        case "textarea":
          ib(a2, c2);
          break;
        case "select":
          b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
      }
    };
    Gb = Rk;
    Hb = Sk;
    var tl = { usingClientEntryPoint: false, Events: [Cb, ue$2, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
    var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
      a2 = Zb(a2);
      return null === a2 ? null : a2.stateNode;
    }, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
    if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
      var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!wl.isDisabled && wl.supportsFiber)
        try {
          kc = wl.inject(vl), lc = wl;
        } catch (a2) {
        }
    }
    reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
    reactDom_production_min.createPortal = function(a2, b2) {
      var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
      if (!ol(b2))
        throw Error(p$5(200));
      return dl(a2, b2, null, c2);
    };
    reactDom_production_min.createRoot = function(a2, b2) {
      if (!ol(a2))
        throw Error(p$5(299));
      var c2 = false, d2 = "", e2 = ll;
      null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
      b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
      a2[uf] = b2.current;
      sf(8 === a2.nodeType ? a2.parentNode : a2);
      return new ml(b2);
    };
    reactDom_production_min.findDOMNode = function(a2) {
      if (null == a2)
        return null;
      if (1 === a2.nodeType)
        return a2;
      var b2 = a2._reactInternals;
      if (void 0 === b2) {
        if ("function" === typeof a2.render)
          throw Error(p$5(188));
        a2 = Object.keys(a2).join(",");
        throw Error(p$5(268, a2));
      }
      a2 = Zb(b2);
      a2 = null === a2 ? null : a2.stateNode;
      return a2;
    };
    reactDom_production_min.flushSync = function(a2) {
      return Sk(a2);
    };
    reactDom_production_min.hydrate = function(a2, b2, c2) {
      if (!pl(b2))
        throw Error(p$5(200));
      return sl(null, a2, b2, true, c2);
    };
    reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
      if (!ol(a2))
        throw Error(p$5(405));
      var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
      null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
      b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
      a2[uf] = b2.current;
      sf(a2);
      if (d2)
        for (a2 = 0; a2 < d2.length; a2++)
          c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
            c2,
            e2
          );
      return new nl(b2);
    };
    reactDom_production_min.render = function(a2, b2, c2) {
      if (!pl(b2))
        throw Error(p$5(200));
      return sl(null, a2, b2, false, c2);
    };
    reactDom_production_min.unmountComponentAtNode = function(a2) {
      if (!pl(a2))
        throw Error(p$5(40));
      return a2._reactRootContainer ? (Sk(function() {
        sl(null, null, a2, false, function() {
          a2._reactRootContainer = null;
          a2[uf] = null;
        });
      }), true) : false;
    };
    reactDom_production_min.unstable_batchedUpdates = Rk;
    reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
      if (!pl(c2))
        throw Error(p$5(200));
      if (null == a2 || void 0 === a2._reactInternals)
        throw Error(p$5(38));
      return sl(a2, b2, c2, false, d2);
    };
    reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
    function checkDCE() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
        return;
      }
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
      } catch (err) {
        console.error(err);
      }
    }
    {
      checkDCE();
      reactDom.exports = reactDom_production_min;
    }
    var reactDomExports = reactDom.exports;
    const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
    var m$6 = reactDomExports;
    {
      client.createRoot = m$6.createRoot;
      client.hydrateRoot = m$6.hydrateRoot;
    }
    /**
     * @remix-run/router v1.11.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$4() {
      _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$4.apply(this, arguments);
    }
    var Action;
    (function(Action2) {
      Action2["Pop"] = "POP";
      Action2["Push"] = "PUSH";
      Action2["Replace"] = "REPLACE";
    })(Action || (Action = {}));
    const PopStateEventType = "popstate";
    function createBrowserHistory(options) {
      if (options === void 0) {
        options = {};
      }
      function createBrowserLocation(window2, globalHistory) {
        let {
          pathname,
          search,
          hash: hash2
        } = window2.location;
        return createLocation(
          "",
          {
            pathname,
            search,
            hash: hash2
          },
          // state defaults to `null` because `window.history.state` does
          globalHistory.state && globalHistory.state.usr || null,
          globalHistory.state && globalHistory.state.key || "default"
        );
      }
      function createBrowserHref(window2, to2) {
        return typeof to2 === "string" ? to2 : createPath(to2);
      }
      return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
    }
    function invariant(value, message) {
      if (value === false || value === null || typeof value === "undefined") {
        throw new Error(message);
      }
    }
    function warning(cond, message) {
      if (!cond) {
        if (typeof console !== "undefined")
          console.warn(message);
        try {
          throw new Error(message);
        } catch (e2) {
        }
      }
    }
    function createKey() {
      return Math.random().toString(36).substr(2, 8);
    }
    function getHistoryState(location, index) {
      return {
        usr: location.state,
        key: location.key,
        idx: index
      };
    }
    function createLocation(current, to2, state, key) {
      if (state === void 0) {
        state = null;
      }
      let location = _extends$4({
        pathname: typeof current === "string" ? current : current.pathname,
        search: "",
        hash: ""
      }, typeof to2 === "string" ? parsePath(to2) : to2, {
        state,
        // TODO: This could be cleaned up.  push/replace should probably just take
        // full Locations now and avoid the need to run through this flow at all
        // But that's a pretty big refactor to the current test suite so going to
        // keep as is for the time being and just let any incoming keys take precedence
        key: to2 && to2.key || key || createKey()
      });
      return location;
    }
    function createPath(_ref) {
      let {
        pathname = "/",
        search = "",
        hash: hash2 = ""
      } = _ref;
      if (search && search !== "?")
        pathname += search.charAt(0) === "?" ? search : "?" + search;
      if (hash2 && hash2 !== "#")
        pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
      return pathname;
    }
    function parsePath(path) {
      let parsedPath = {};
      if (path) {
        let hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
          parsedPath.hash = path.substr(hashIndex);
          path = path.substr(0, hashIndex);
        }
        let searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
          parsedPath.search = path.substr(searchIndex);
          path = path.substr(0, searchIndex);
        }
        if (path) {
          parsedPath.pathname = path;
        }
      }
      return parsedPath;
    }
    function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
      if (options === void 0) {
        options = {};
      }
      let {
        window: window2 = document.defaultView,
        v5Compat = false
      } = options;
      let globalHistory = window2.history;
      let action = Action.Pop;
      let listener = null;
      let index = getIndex();
      if (index == null) {
        index = 0;
        globalHistory.replaceState(_extends$4({}, globalHistory.state, {
          idx: index
        }), "");
      }
      function getIndex() {
        let state = globalHistory.state || {
          idx: null
        };
        return state.idx;
      }
      function handlePop() {
        action = Action.Pop;
        let nextIndex = getIndex();
        let delta = nextIndex == null ? null : nextIndex - index;
        index = nextIndex;
        if (listener) {
          listener({
            action,
            location: history.location,
            delta
          });
        }
      }
      function push(to2, state) {
        action = Action.Push;
        let location = createLocation(history.location, to2, state);
        if (validateLocation)
          validateLocation(location, to2);
        index = getIndex() + 1;
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        try {
          globalHistory.pushState(historyState, "", url);
        } catch (error) {
          if (error instanceof DOMException && error.name === "DataCloneError") {
            throw error;
          }
          window2.location.assign(url);
        }
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 1
          });
        }
      }
      function replace2(to2, state) {
        action = Action.Replace;
        let location = createLocation(history.location, to2, state);
        if (validateLocation)
          validateLocation(location, to2);
        index = getIndex();
        let historyState = getHistoryState(location, index);
        let url = history.createHref(location);
        globalHistory.replaceState(historyState, "", url);
        if (v5Compat && listener) {
          listener({
            action,
            location: history.location,
            delta: 0
          });
        }
      }
      function createURL(to2) {
        let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
        let href = typeof to2 === "string" ? to2 : createPath(to2);
        invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
        return new URL(href, base);
      }
      let history = {
        get action() {
          return action;
        },
        get location() {
          return getLocation(window2, globalHistory);
        },
        listen(fn2) {
          if (listener) {
            throw new Error("A history only accepts one active listener");
          }
          window2.addEventListener(PopStateEventType, handlePop);
          listener = fn2;
          return () => {
            window2.removeEventListener(PopStateEventType, handlePop);
            listener = null;
          };
        },
        createHref(to2) {
          return createHref(window2, to2);
        },
        createURL,
        encodeLocation(to2) {
          let url = createURL(to2);
          return {
            pathname: url.pathname,
            search: url.search,
            hash: url.hash
          };
        },
        push,
        replace: replace2,
        go(n2) {
          return globalHistory.go(n2);
        }
      };
      return history;
    }
    var ResultType;
    (function(ResultType2) {
      ResultType2["data"] = "data";
      ResultType2["deferred"] = "deferred";
      ResultType2["redirect"] = "redirect";
      ResultType2["error"] = "error";
    })(ResultType || (ResultType = {}));
    function matchRoutes(routes, locationArg, basename) {
      if (basename === void 0) {
        basename = "/";
      }
      let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
      let pathname = stripBasename(location.pathname || "/", basename);
      if (pathname == null) {
        return null;
      }
      let branches = flattenRoutes(routes);
      rankRouteBranches(branches);
      let matches2 = null;
      for (let i2 = 0; matches2 == null && i2 < branches.length; ++i2) {
        matches2 = matchRouteBranch(
          branches[i2],
          // Incoming pathnames are generally encoded from either window.location
          // or from router.navigate, but we want to match against the unencoded
          // paths in the route definitions.  Memory router locations won't be
          // encoded here but there also shouldn't be anything to decode so this
          // should be a safe operation.  This avoids needing matchRoutes to be
          // history-aware.
          safelyDecodeURI(pathname)
        );
      }
      return matches2;
    }
    function flattenRoutes(routes, branches, parentsMeta, parentPath) {
      if (branches === void 0) {
        branches = [];
      }
      if (parentsMeta === void 0) {
        parentsMeta = [];
      }
      if (parentPath === void 0) {
        parentPath = "";
      }
      let flattenRoute = (route, index, relativePath) => {
        let meta = {
          relativePath: relativePath === void 0 ? route.path || "" : relativePath,
          caseSensitive: route.caseSensitive === true,
          childrenIndex: index,
          route
        };
        if (meta.relativePath.startsWith("/")) {
          invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
          meta.relativePath = meta.relativePath.slice(parentPath.length);
        }
        let path = joinPaths([parentPath, meta.relativePath]);
        let routesMeta = parentsMeta.concat(meta);
        if (route.children && route.children.length > 0) {
          invariant(
            // Our types know better, but runtime JS may not!
            // @ts-expect-error
            route.index !== true,
            "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
          );
          flattenRoutes(route.children, branches, routesMeta, path);
        }
        if (route.path == null && !route.index) {
          return;
        }
        branches.push({
          path,
          score: computeScore(path, route.index),
          routesMeta
        });
      };
      routes.forEach((route, index) => {
        var _route$path;
        if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
          flattenRoute(route, index);
        } else {
          for (let exploded of explodeOptionalSegments(route.path)) {
            flattenRoute(route, index, exploded);
          }
        }
      });
      return branches;
    }
    function explodeOptionalSegments(path) {
      let segments = path.split("/");
      if (segments.length === 0)
        return [];
      let [first, ...rest] = segments;
      let isOptional = first.endsWith("?");
      let required = first.replace(/\?$/, "");
      if (rest.length === 0) {
        return isOptional ? [required, ""] : [required];
      }
      let restExploded = explodeOptionalSegments(rest.join("/"));
      let result = [];
      result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
      if (isOptional) {
        result.push(...restExploded);
      }
      return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
    }
    function rankRouteBranches(branches) {
      branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
    }
    const paramRe = /^:\w+$/;
    const dynamicSegmentValue = 3;
    const indexRouteValue = 2;
    const emptySegmentValue = 1;
    const staticSegmentValue = 10;
    const splatPenalty = -2;
    const isSplat = (s2) => s2 === "*";
    function computeScore(path, index) {
      let segments = path.split("/");
      let initialScore = segments.length;
      if (segments.some(isSplat)) {
        initialScore += splatPenalty;
      }
      if (index) {
        initialScore += indexRouteValue;
      }
      return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
    }
    function compareIndexes(a2, b2) {
      let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
      return siblings ? (
        // If two routes are siblings, we should try to match the earlier sibling
        // first. This allows people to have fine-grained control over the matching
        // behavior by simply putting routes with identical paths in the order they
        // want them tried.
        a2[a2.length - 1] - b2[b2.length - 1]
      ) : (
        // Otherwise, it doesn't really make sense to rank non-siblings by index,
        // so they sort equally.
        0
      );
    }
    function matchRouteBranch(branch, pathname) {
      let {
        routesMeta
      } = branch;
      let matchedParams = {};
      let matchedPathname = "/";
      let matches2 = [];
      for (let i2 = 0; i2 < routesMeta.length; ++i2) {
        let meta = routesMeta[i2];
        let end = i2 === routesMeta.length - 1;
        let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
        let match2 = matchPath({
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end
        }, remainingPathname);
        if (!match2)
          return null;
        Object.assign(matchedParams, match2.params);
        let route = meta.route;
        matches2.push({
          // TODO: Can this as be avoided?
          params: matchedParams,
          pathname: joinPaths([matchedPathname, match2.pathname]),
          pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
          route
        });
        if (match2.pathnameBase !== "/") {
          matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
        }
      }
      return matches2;
    }
    function generatePath(originalPath, params) {
      if (params === void 0) {
        params = {};
      }
      let path = originalPath;
      if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
        warning(false, 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
        path = path.replace(/\*$/, "/*");
      }
      const prefix2 = path.startsWith("/") ? "/" : "";
      const stringify2 = (p2) => p2 == null ? "" : typeof p2 === "string" ? p2 : String(p2);
      const segments = path.split(/\/+/).map((segment, index, array) => {
        const isLastSegment = index === array.length - 1;
        if (isLastSegment && segment === "*") {
          const star2 = "*";
          return stringify2(params[star2]);
        }
        const keyMatch = segment.match(/^:(\w+)(\??)$/);
        if (keyMatch) {
          const [, key, optional] = keyMatch;
          let param = params[key];
          invariant(optional === "?" || param != null, 'Missing ":' + key + '" param');
          return stringify2(param);
        }
        return segment.replace(/\?$/g, "");
      }).filter((segment) => !!segment);
      return prefix2 + segments.join("/");
    }
    function matchPath(pattern, pathname) {
      if (typeof pattern === "string") {
        pattern = {
          path: pattern,
          caseSensitive: false,
          end: true
        };
      }
      let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
      let match2 = pathname.match(matcher);
      if (!match2)
        return null;
      let matchedPathname = match2[0];
      let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
      let captureGroups = match2.slice(1);
      let params = compiledParams.reduce((memo, _ref, index) => {
        let {
          paramName,
          isOptional
        } = _ref;
        if (paramName === "*") {
          let splatValue = captureGroups[index] || "";
          pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
        }
        const value = captureGroups[index];
        if (isOptional && !value) {
          memo[paramName] = void 0;
        } else {
          memo[paramName] = safelyDecodeURIComponent(value || "", paramName);
        }
        return memo;
      }, {});
      return {
        params,
        pathname: matchedPathname,
        pathnameBase,
        pattern
      };
    }
    function compilePath(path, caseSensitive, end) {
      if (caseSensitive === void 0) {
        caseSensitive = false;
      }
      if (end === void 0) {
        end = true;
      }
      warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
      let params = [];
      let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:(\w+)(\?)?/g, (_2, paramName, isOptional) => {
        params.push({
          paramName,
          isOptional: isOptional != null
        });
        return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
      });
      if (path.endsWith("*")) {
        params.push({
          paramName: "*"
        });
        regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
      } else if (end) {
        regexpSource += "\\/*$";
      } else if (path !== "" && path !== "/") {
        regexpSource += "(?:(?=\\/|$))";
      } else
        ;
      let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
      return [matcher, params];
    }
    function safelyDecodeURI(value) {
      try {
        return decodeURI(value);
      } catch (error) {
        warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
        return value;
      }
    }
    function safelyDecodeURIComponent(value, paramName) {
      try {
        return decodeURIComponent(value);
      } catch (error) {
        warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
        return value;
      }
    }
    function stripBasename(pathname, basename) {
      if (basename === "/")
        return pathname;
      if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
        return null;
      }
      let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
      let nextChar = pathname.charAt(startIndex);
      if (nextChar && nextChar !== "/") {
        return null;
      }
      return pathname.slice(startIndex) || "/";
    }
    function resolvePath(to2, fromPathname) {
      if (fromPathname === void 0) {
        fromPathname = "/";
      }
      let {
        pathname: toPathname,
        search = "",
        hash: hash2 = ""
      } = typeof to2 === "string" ? parsePath(to2) : to2;
      let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
      return {
        pathname,
        search: normalizeSearch(search),
        hash: normalizeHash(hash2)
      };
    }
    function resolvePathname(relativePath, fromPathname) {
      let segments = fromPathname.replace(/\/+$/, "").split("/");
      let relativeSegments = relativePath.split("/");
      relativeSegments.forEach((segment) => {
        if (segment === "..") {
          if (segments.length > 1)
            segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });
      return segments.length > 1 ? segments.join("/") : "/";
    }
    function getInvalidPathError(char2, field, dest, path) {
      return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
    }
    function getPathContributingMatches(matches2) {
      return matches2.filter((match2, index) => index === 0 || match2.route.path && match2.route.path.length > 0);
    }
    function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
      if (isPathRelative === void 0) {
        isPathRelative = false;
      }
      let to2;
      if (typeof toArg === "string") {
        to2 = parsePath(toArg);
      } else {
        to2 = _extends$4({}, toArg);
        invariant(!to2.pathname || !to2.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to2));
        invariant(!to2.pathname || !to2.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to2));
        invariant(!to2.search || !to2.search.includes("#"), getInvalidPathError("#", "search", "hash", to2));
      }
      let isEmptyPath = toArg === "" || to2.pathname === "";
      let toPathname = isEmptyPath ? "/" : to2.pathname;
      let from2;
      if (isPathRelative || toPathname == null) {
        from2 = locationPathname;
      } else {
        let routePathnameIndex = routePathnames.length - 1;
        if (toPathname.startsWith("..")) {
          let toSegments = toPathname.split("/");
          while (toSegments[0] === "..") {
            toSegments.shift();
            routePathnameIndex -= 1;
          }
          to2.pathname = toSegments.join("/");
        }
        from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
      }
      let path = resolvePath(to2, from2);
      let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
      let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
      if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
        path.pathname += "/";
      }
      return path;
    }
    const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
    const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
    const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
    const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
    function isRouteErrorResponse(error) {
      return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
    }
    const validMutationMethodsArr = ["post", "put", "patch", "delete"];
    new Set(validMutationMethodsArr);
    const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
    new Set(validRequestMethodsArr);
    /**
     * React Router v6.18.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$3() {
      _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$3.apply(this, arguments);
    }
    const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
    const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
    const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
    const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
    const RouteContext = /* @__PURE__ */ reactExports.createContext({
      outlet: null,
      matches: [],
      isDataRoute: false
    });
    const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
    function useHref(to2, _temp) {
      let {
        relative
      } = _temp === void 0 ? {} : _temp;
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        basename,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        hash: hash2,
        pathname,
        search
      } = useResolvedPath(to2, {
        relative
      });
      let joinedPathname = pathname;
      if (basename !== "/") {
        joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
      }
      return navigator2.createHref({
        pathname: joinedPathname,
        search,
        hash: hash2
      });
    }
    function useInRouterContext() {
      return reactExports.useContext(LocationContext) != null;
    }
    function useLocation() {
      !useInRouterContext() ? invariant(false) : void 0;
      return reactExports.useContext(LocationContext).location;
    }
    function useIsomorphicLayoutEffect$3(cb2) {
      let isStatic = reactExports.useContext(NavigationContext).static;
      if (!isStatic) {
        reactExports.useLayoutEffect(cb2);
      }
    }
    function useNavigate() {
      let {
        isDataRoute
      } = reactExports.useContext(RouteContext);
      return isDataRoute ? useNavigateStable() : useNavigateUnstable();
    }
    function useNavigateUnstable() {
      !useInRouterContext() ? invariant(false) : void 0;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      let {
        basename,
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: matches2
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches2).map((match2) => match2.pathnameBase));
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$3(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to2, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to2 === "number") {
          navigator2.go(to2);
          return;
        }
        let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
        if (dataRouterContext == null && basename !== "/") {
          path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
        }
        (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
      }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
      return navigate;
    }
    function useParams() {
      let {
        matches: matches2
      } = reactExports.useContext(RouteContext);
      let routeMatch = matches2[matches2.length - 1];
      return routeMatch ? routeMatch.params : {};
    }
    function useResolvedPath(to2, _temp2) {
      let {
        relative
      } = _temp2 === void 0 ? {} : _temp2;
      let {
        matches: matches2
      } = reactExports.useContext(RouteContext);
      let {
        pathname: locationPathname
      } = useLocation();
      let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches2).map((match2) => match2.pathnameBase));
      return reactExports.useMemo(() => resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to2, routePathnamesJson, locationPathname, relative]);
    }
    function useRoutes(routes, locationArg) {
      return useRoutesImpl(routes, locationArg);
    }
    function useRoutesImpl(routes, locationArg, dataRouterState) {
      !useInRouterContext() ? invariant(false) : void 0;
      let {
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let {
        matches: parentMatches
      } = reactExports.useContext(RouteContext);
      let routeMatch = parentMatches[parentMatches.length - 1];
      let parentParams = routeMatch ? routeMatch.params : {};
      routeMatch ? routeMatch.pathname : "/";
      let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
      routeMatch && routeMatch.route;
      let locationFromContext = useLocation();
      let location;
      if (locationArg) {
        var _parsedLocationArg$pa;
        let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
        !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
        location = parsedLocationArg;
      } else {
        location = locationFromContext;
      }
      let pathname = location.pathname || "/";
      let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
      let matches2 = matchRoutes(routes, {
        pathname: remainingPathname
      });
      let renderedMatches = _renderMatches(matches2 && matches2.map((match2) => Object.assign({}, match2, {
        params: Object.assign({}, parentParams, match2.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
        ]),
        pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
        ])
      })), parentMatches, dataRouterState);
      if (locationArg && renderedMatches) {
        return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
          value: {
            location: _extends$3({
              pathname: "/",
              search: "",
              hash: "",
              state: null,
              key: "default"
            }, location),
            navigationType: Action.Pop
          }
        }, renderedMatches);
      }
      return renderedMatches;
    }
    function DefaultErrorComponent() {
      let error = useRouteError();
      let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
      let stack = error instanceof Error ? error.stack : null;
      let lightgrey = "rgba(200,200,200, 0.5)";
      let preStyles = {
        padding: "0.5rem",
        backgroundColor: lightgrey
      };
      let devInfo = null;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
        style: {
          fontStyle: "italic"
        }
      }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
        style: preStyles
      }, stack) : null, devInfo);
    }
    const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
    class RenderErrorBoundary extends reactExports.Component {
      constructor(props) {
        super(props);
        this.state = {
          location: props.location,
          revalidation: props.revalidation,
          error: props.error
        };
      }
      static getDerivedStateFromError(error) {
        return {
          error
        };
      }
      static getDerivedStateFromProps(props, state) {
        if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
          return {
            error: props.error,
            location: props.location,
            revalidation: props.revalidation
          };
        }
        return {
          error: props.error || state.error,
          location: state.location,
          revalidation: props.revalidation || state.revalidation
        };
      }
      componentDidCatch(error, errorInfo) {
        console.error("React Router caught the following error during render", error, errorInfo);
      }
      render() {
        return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
          value: this.props.routeContext
        }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
          value: this.state.error,
          children: this.props.component
        })) : this.props.children;
      }
    }
    function RenderedRoute(_ref) {
      let {
        routeContext,
        match: match2,
        children
      } = _ref;
      let dataRouterContext = reactExports.useContext(DataRouterContext);
      if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
        dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
      }
      return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
        value: routeContext
      }, children);
    }
    function _renderMatches(matches2, parentMatches, dataRouterState) {
      var _dataRouterState2;
      if (parentMatches === void 0) {
        parentMatches = [];
      }
      if (dataRouterState === void 0) {
        dataRouterState = null;
      }
      if (matches2 == null) {
        var _dataRouterState;
        if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
          matches2 = dataRouterState.matches;
        } else {
          return null;
        }
      }
      let renderedMatches = matches2;
      let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
      if (errors != null) {
        let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
        !(errorIndex >= 0) ? invariant(false) : void 0;
        renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
      }
      return renderedMatches.reduceRight((outlet, match2, index) => {
        let error = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
        let errorElement = null;
        if (dataRouterState) {
          errorElement = match2.route.errorElement || defaultErrorElement;
        }
        let matches3 = parentMatches.concat(renderedMatches.slice(0, index + 1));
        let getChildren2 = () => {
          let children;
          if (error) {
            children = errorElement;
          } else if (match2.route.Component) {
            children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
          } else if (match2.route.element) {
            children = match2.route.element;
          } else {
            children = outlet;
          }
          return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
            match: match2,
            routeContext: {
              outlet,
              matches: matches3,
              isDataRoute: dataRouterState != null
            },
            children
          });
        };
        return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error,
          children: getChildren2(),
          routeContext: {
            outlet: null,
            matches: matches3,
            isDataRoute: true
          }
        }) : getChildren2();
      }, null);
    }
    var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
      DataRouterHook2["UseBlocker"] = "useBlocker";
      DataRouterHook2["UseRevalidator"] = "useRevalidator";
      DataRouterHook2["UseNavigateStable"] = "useNavigate";
      return DataRouterHook2;
    }(DataRouterHook$1 || {});
    var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
      DataRouterStateHook2["UseBlocker"] = "useBlocker";
      DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
      DataRouterStateHook2["UseActionData"] = "useActionData";
      DataRouterStateHook2["UseRouteError"] = "useRouteError";
      DataRouterStateHook2["UseNavigation"] = "useNavigation";
      DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
      DataRouterStateHook2["UseMatches"] = "useMatches";
      DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
      DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
      DataRouterStateHook2["UseRouteId"] = "useRouteId";
      return DataRouterStateHook2;
    }(DataRouterStateHook$1 || {});
    function useDataRouterContext$1(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      !ctx ? invariant(false) : void 0;
      return ctx;
    }
    function useDataRouterState(hookName) {
      let state = reactExports.useContext(DataRouterStateContext);
      !state ? invariant(false) : void 0;
      return state;
    }
    function useRouteContext(hookName) {
      let route = reactExports.useContext(RouteContext);
      !route ? invariant(false) : void 0;
      return route;
    }
    function useCurrentRouteId(hookName) {
      let route = useRouteContext();
      let thisRoute = route.matches[route.matches.length - 1];
      !thisRoute.route.id ? invariant(false) : void 0;
      return thisRoute.route.id;
    }
    function useRouteError() {
      var _state$errors;
      let error = reactExports.useContext(RouteErrorContext);
      let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
      let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
      if (error) {
        return error;
      }
      return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
    }
    function useNavigateStable() {
      let {
        router
      } = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable);
      let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
      let activeRef = reactExports.useRef(false);
      useIsomorphicLayoutEffect$3(() => {
        activeRef.current = true;
      });
      let navigate = reactExports.useCallback(function(to2, options) {
        if (options === void 0) {
          options = {};
        }
        if (!activeRef.current)
          return;
        if (typeof to2 === "number") {
          router.navigate(to2);
        } else {
          router.navigate(to2, _extends$3({
            fromRouteId: id2
          }, options));
        }
      }, [router, id2]);
      return navigate;
    }
    function Route(_props) {
      invariant(false);
    }
    function Router(_ref5) {
      let {
        basename: basenameProp = "/",
        children = null,
        location: locationProp,
        navigationType = Action.Pop,
        navigator: navigator2,
        static: staticProp = false
      } = _ref5;
      !!useInRouterContext() ? invariant(false) : void 0;
      let basename = basenameProp.replace(/^\/*/, "/");
      let navigationContext = reactExports.useMemo(() => ({
        basename,
        navigator: navigator2,
        static: staticProp
      }), [basename, navigator2, staticProp]);
      if (typeof locationProp === "string") {
        locationProp = parsePath(locationProp);
      }
      let {
        pathname = "/",
        search = "",
        hash: hash2 = "",
        state = null,
        key = "default"
      } = locationProp;
      let locationContext = reactExports.useMemo(() => {
        let trailingPathname = stripBasename(pathname, basename);
        if (trailingPathname == null) {
          return null;
        }
        return {
          location: {
            pathname: trailingPathname,
            search,
            hash: hash2,
            state,
            key
          },
          navigationType
        };
      }, [basename, pathname, search, hash2, state, key, navigationType]);
      if (locationContext == null) {
        return null;
      }
      return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
        value: navigationContext
      }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
        children,
        value: locationContext
      }));
    }
    function Routes(_ref6) {
      let {
        children,
        location
      } = _ref6;
      return useRoutes(createRoutesFromChildren(children), location);
    }
    new Promise(() => {
    });
    function createRoutesFromChildren(children, parentPath) {
      if (parentPath === void 0) {
        parentPath = [];
      }
      let routes = [];
      reactExports.Children.forEach(children, (element, index) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
          return;
        }
        let treePath = [...parentPath, index];
        if (element.type === reactExports.Fragment) {
          routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
          return;
        }
        !(element.type === Route) ? invariant(false) : void 0;
        !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
        let route = {
          id: element.props.id || treePath.join("-"),
          caseSensitive: element.props.caseSensitive,
          element: element.props.element,
          Component: element.props.Component,
          index: element.props.index,
          path: element.props.path,
          loader: element.props.loader,
          action: element.props.action,
          errorElement: element.props.errorElement,
          ErrorBoundary: element.props.ErrorBoundary,
          hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
          shouldRevalidate: element.props.shouldRevalidate,
          handle: element.props.handle,
          lazy: element.props.lazy
        };
        if (element.props.children) {
          route.children = createRoutesFromChildren(element.props.children, treePath);
        }
        routes.push(route);
      });
      return routes;
    }
    /**
     * React Router DOM v6.18.0
     *
     * Copyright (c) Remix Software Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE.md file in the root directory of this source tree.
     *
     * @license MIT
     */
    function _extends$2() {
      _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$2.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose$1(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    function isModifiedEvent(event) {
      return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
    }
    function shouldProcessLinkClick(event, target) {
      return event.button === 0 && // Ignore everything but left clicks
      (!target || target === "_self") && // Let browser handle "target=_blank" etc.
      !isModifiedEvent(event);
    }
    function createSearchParams(init2) {
      if (init2 === void 0) {
        init2 = "";
      }
      return new URLSearchParams(typeof init2 === "string" || Array.isArray(init2) || init2 instanceof URLSearchParams ? init2 : Object.keys(init2).reduce((memo, key) => {
        let value = init2[key];
        return memo.concat(Array.isArray(value) ? value.map((v2) => [key, v2]) : [[key, value]]);
      }, []));
    }
    function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
      let searchParams = createSearchParams(locationSearch);
      if (defaultSearchParams) {
        defaultSearchParams.forEach((_2, key) => {
          if (!searchParams.has(key)) {
            defaultSearchParams.getAll(key).forEach((value) => {
              searchParams.append(key, value);
            });
          }
        });
      }
      return searchParams;
    }
    const _excluded$z = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "unstable_viewTransition"], _excluded2$3 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "unstable_viewTransition", "children"];
    const ViewTransitionContext = /* @__PURE__ */ reactExports.createContext({
      isTransitioning: false
    });
    const START_TRANSITION = "startTransition";
    const startTransitionImpl = React$1[START_TRANSITION];
    function BrowserRouter(_ref4) {
      let {
        basename,
        children,
        future,
        window: window2
      } = _ref4;
      let historyRef = reactExports.useRef();
      if (historyRef.current == null) {
        historyRef.current = createBrowserHistory({
          window: window2,
          v5Compat: true
        });
      }
      let history = historyRef.current;
      let [state, setStateImpl] = reactExports.useState({
        action: history.action,
        location: history.location
      });
      let {
        v7_startTransition
      } = future || {};
      let setState = reactExports.useCallback((newState) => {
        v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
      }, [setStateImpl, v7_startTransition]);
      reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
      return /* @__PURE__ */ reactExports.createElement(Router, {
        basename,
        children,
        location: state.location,
        navigationType: state.action,
        navigator: history
      });
    }
    const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
    const Link$1 = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
      let {
        onClick: onClick2,
        relative,
        reloadDocument,
        replace: replace2,
        state,
        target,
        to: to2,
        preventScrollReset,
        unstable_viewTransition
      } = _ref7, rest = _objectWithoutPropertiesLoose$1(_ref7, _excluded$z);
      let {
        basename
      } = reactExports.useContext(NavigationContext);
      let absoluteHref;
      let isExternal = false;
      if (typeof to2 === "string" && ABSOLUTE_URL_REGEX.test(to2)) {
        absoluteHref = to2;
        if (isBrowser$1) {
          try {
            let currentUrl = new URL(window.location.href);
            let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
            let path = stripBasename(targetUrl.pathname, basename);
            if (targetUrl.origin === currentUrl.origin && path != null) {
              to2 = path + targetUrl.search + targetUrl.hash;
            } else {
              isExternal = true;
            }
          } catch (e2) {
          }
        }
      }
      let href = useHref(to2, {
        relative
      });
      let internalOnClick = useLinkClickHandler(to2, {
        replace: replace2,
        state,
        target,
        preventScrollReset,
        relative,
        unstable_viewTransition
      });
      function handleClick(event) {
        if (onClick2)
          onClick2(event);
        if (!event.defaultPrevented) {
          internalOnClick(event);
        }
      }
      return (
        // eslint-disable-next-line jsx-a11y/anchor-has-content
        /* @__PURE__ */ reactExports.createElement("a", _extends$2({}, rest, {
          href: absoluteHref || href,
          onClick: isExternal || reloadDocument ? onClick2 : handleClick,
          ref,
          target
        }))
      );
    });
    const NavLink = /* @__PURE__ */ reactExports.forwardRef(function NavLinkWithRef(_ref8, ref) {
      let {
        "aria-current": ariaCurrentProp = "page",
        caseSensitive = false,
        className: classNameProp = "",
        end = false,
        style: styleProp,
        to: to2,
        unstable_viewTransition,
        children
      } = _ref8, rest = _objectWithoutPropertiesLoose$1(_ref8, _excluded2$3);
      let path = useResolvedPath(to2, {
        relative: rest.relative
      });
      let location = useLocation();
      let routerState = reactExports.useContext(DataRouterStateContext);
      let {
        navigator: navigator2
      } = reactExports.useContext(NavigationContext);
      let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
      // eslint-disable-next-line react-hooks/rules-of-hooks
      useViewTransitionState(path) && unstable_viewTransition === true;
      let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
      let locationPathname = location.pathname;
      let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
      if (!caseSensitive) {
        locationPathname = locationPathname.toLowerCase();
        nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
        toPathname = toPathname.toLowerCase();
      }
      let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
      let isPending2 = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
      let renderProps = {
        isActive,
        isPending: isPending2,
        isTransitioning
      };
      let ariaCurrent = isActive ? ariaCurrentProp : void 0;
      let className;
      if (typeof classNameProp === "function") {
        className = classNameProp(renderProps);
      } else {
        className = [classNameProp, isActive ? "active" : null, isPending2 ? "pending" : null, isTransitioning ? "transitioning" : null].filter(Boolean).join(" ");
      }
      let style2 = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
      return /* @__PURE__ */ reactExports.createElement(Link$1, _extends$2({}, rest, {
        "aria-current": ariaCurrent,
        className,
        ref,
        style: style2,
        to: to2,
        unstable_viewTransition
      }), typeof children === "function" ? children(renderProps) : children);
    });
    var DataRouterHook;
    (function(DataRouterHook2) {
      DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
      DataRouterHook2["UseSubmit"] = "useSubmit";
      DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
      DataRouterHook2["UseFetcher"] = "useFetcher";
      DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
    })(DataRouterHook || (DataRouterHook = {}));
    var DataRouterStateHook;
    (function(DataRouterStateHook2) {
      DataRouterStateHook2["UseFetcher"] = "useFetcher";
      DataRouterStateHook2["UseFetchers"] = "useFetchers";
      DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
    })(DataRouterStateHook || (DataRouterStateHook = {}));
    function useDataRouterContext(hookName) {
      let ctx = reactExports.useContext(DataRouterContext);
      !ctx ? invariant(false) : void 0;
      return ctx;
    }
    function useLinkClickHandler(to2, _temp) {
      let {
        target,
        replace: replaceProp,
        state,
        preventScrollReset,
        relative,
        unstable_viewTransition
      } = _temp === void 0 ? {} : _temp;
      let navigate = useNavigate();
      let location = useLocation();
      let path = useResolvedPath(to2, {
        relative
      });
      return reactExports.useCallback((event) => {
        if (shouldProcessLinkClick(event, target)) {
          event.preventDefault();
          let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
          navigate(to2, {
            replace: replace2,
            state,
            preventScrollReset,
            relative,
            unstable_viewTransition
          });
        }
      }, [location, navigate, path, replaceProp, state, target, to2, preventScrollReset, relative, unstable_viewTransition]);
    }
    function useSearchParams(defaultInit) {
      let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
      let hasSetSearchParamsRef = reactExports.useRef(false);
      let location = useLocation();
      let searchParams = reactExports.useMemo(() => (
        // Only merge in the defaults if we haven't yet called setSearchParams.
        // Once we call that we want those to take precedence, otherwise you can't
        // remove a param with setSearchParams({}) if it has an initial value
        getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
      ), [location.search]);
      let navigate = useNavigate();
      let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
        const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
        hasSetSearchParamsRef.current = true;
        navigate("?" + newSearchParams, navigateOptions);
      }, [navigate, searchParams]);
      return [searchParams, setSearchParams];
    }
    function useViewTransitionState(to2, opts) {
      if (opts === void 0) {
        opts = {};
      }
      let vtContext = reactExports.useContext(ViewTransitionContext);
      !(vtContext != null) ? invariant(false) : void 0;
      let {
        basename
      } = useDataRouterContext(DataRouterHook.useViewTransitionState);
      let path = useResolvedPath(to2, {
        relative: opts.relative
      });
      if (!vtContext.isTransitioning) {
        return false;
      }
      let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
      let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
      return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
    }
    var __assign = function() {
      __assign = Object.assign || function __assign2(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2)
            if (Object.prototype.hasOwnProperty.call(s2, p2))
              t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    function __spreadArray$3(to2, from2, pack) {
      if (pack || arguments.length === 2)
        for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
          if (ar || !(i2 in from2)) {
            if (!ar)
              ar = Array.prototype.slice.call(from2, 0, i2);
            ar[i2] = from2[i2];
          }
        }
      return to2.concat(ar || Array.prototype.slice.call(from2));
    }
    typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e2 = new Error(message);
      return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
    };
    function memoize$1(fn2) {
      var cache2 = /* @__PURE__ */ Object.create(null);
      return function(arg) {
        if (cache2[arg] === void 0)
          cache2[arg] = fn2(arg);
        return cache2[arg];
      };
    }
    var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    var isPropValid = /* @__PURE__ */ memoize$1(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
    var MS$1 = "-ms-";
    var MOZ$1 = "-moz-";
    var WEBKIT$1 = "-webkit-";
    var COMMENT$1 = "comm";
    var RULESET$1 = "rule";
    var DECLARATION$1 = "decl";
    var IMPORT$1 = "@import";
    var KEYFRAMES$1 = "@keyframes";
    var LAYER$1 = "@layer";
    var abs$1 = Math.abs;
    var from$1 = String.fromCharCode;
    var assign$1 = Object.assign;
    function hash$1(value, length2) {
      return charat$1(value, 0) ^ 45 ? (((length2 << 2 ^ charat$1(value, 0)) << 2 ^ charat$1(value, 1)) << 2 ^ charat$1(value, 2)) << 2 ^ charat$1(value, 3) : 0;
    }
    function trim$1(value) {
      return value.trim();
    }
    function match$1(value, pattern) {
      return (value = pattern.exec(value)) ? value[0] : value;
    }
    function replace$1(value, pattern, replacement) {
      return value.replace(pattern, replacement);
    }
    function indexof$1(value, search) {
      return value.indexOf(search);
    }
    function charat$1(value, index) {
      return value.charCodeAt(index) | 0;
    }
    function substr$1(value, begin, end) {
      return value.slice(begin, end);
    }
    function strlen$1(value) {
      return value.length;
    }
    function sizeof$1(value) {
      return value.length;
    }
    function append$1(value, array) {
      return array.push(value), value;
    }
    function combine$1(array, callback) {
      return array.map(callback).join("");
    }
    function filter(array, pattern) {
      return array.filter(function(value) {
        return !match$1(value, pattern);
      });
    }
    var line$1 = 1;
    var column$1 = 1;
    var length$1 = 0;
    var position$1 = 0;
    var character$1 = 0;
    var characters$1 = "";
    function node$1(value, root, parent, type, props, children, length2, siblings) {
      return { value, root, parent, type, props, children, line: line$1, column: column$1, length: length2, return: "", siblings };
    }
    function copy$1(root, props) {
      return assign$1(node$1("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
    }
    function lift(root) {
      while (root.root)
        root = copy$1(root.root, { children: [root] });
      append$1(root, root.siblings);
    }
    function char$1() {
      return character$1;
    }
    function prev$1() {
      character$1 = position$1 > 0 ? charat$1(characters$1, --position$1) : 0;
      if (column$1--, character$1 === 10)
        column$1 = 1, line$1--;
      return character$1;
    }
    function next$1() {
      character$1 = position$1 < length$1 ? charat$1(characters$1, position$1++) : 0;
      if (column$1++, character$1 === 10)
        column$1 = 1, line$1++;
      return character$1;
    }
    function peek$1() {
      return charat$1(characters$1, position$1);
    }
    function caret$1() {
      return position$1;
    }
    function slice$1(begin, end) {
      return substr$1(characters$1, begin, end);
    }
    function token$1(type) {
      switch (type) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc$1(value) {
      return line$1 = column$1 = 1, length$1 = strlen$1(characters$1 = value), position$1 = 0, [];
    }
    function dealloc$1(value) {
      return characters$1 = "", value;
    }
    function delimit$1(type) {
      return trim$1(slice$1(position$1 - 1, delimiter$1(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
    }
    function whitespace$1(type) {
      while (character$1 = peek$1())
        if (character$1 < 33)
          next$1();
        else
          break;
      return token$1(type) > 2 || token$1(character$1) > 3 ? "" : " ";
    }
    function escaping$1(index, count) {
      while (--count && next$1())
        if (character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97)
          break;
      return slice$1(index, caret$1() + (count < 6 && peek$1() == 32 && next$1() == 32));
    }
    function delimiter$1(type) {
      while (next$1())
        switch (character$1) {
          case type:
            return position$1;
          case 34:
          case 39:
            if (type !== 34 && type !== 39)
              delimiter$1(character$1);
            break;
          case 40:
            if (type === 41)
              delimiter$1(type);
            break;
          case 92:
            next$1();
            break;
        }
      return position$1;
    }
    function commenter$1(type, index) {
      while (next$1())
        if (type + character$1 === 47 + 10)
          break;
        else if (type + character$1 === 42 + 42 && peek$1() === 47)
          break;
      return "/*" + slice$1(index, position$1 - 1) + "*" + from$1(type === 47 ? type : next$1());
    }
    function identifier$1(index) {
      while (!token$1(peek$1()))
        next$1();
      return slice$1(index, position$1);
    }
    function compile$1(value) {
      return dealloc$1(parse$1("", null, null, null, [""], value = alloc$1(value), 0, [0], value));
    }
    function parse$1(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
      var index = 0;
      var offset = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property = 0;
      var previous = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type = "";
      var props = rules;
      var children = rulesets;
      var reference = rule;
      var characters2 = type;
      while (scanning)
        switch (previous = character2, character2 = next$1()) {
          case 40:
            if (previous != 108 && charat$1(characters2, length2 - 1) == 58) {
              if (indexof$1(characters2 += replace$1(delimit$1(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit$1(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace$1(previous);
            break;
          case 92:
            characters2 += escaping$1(caret$1() - 1, 7);
            continue;
          case 47:
            switch (peek$1()) {
              case 42:
              case 47:
                append$1(comment$1(commenter$1(next$1(), caret$1()), root, parent, declarations), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index++] = strlen$1(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset:
                if (ampersand == -1)
                  characters2 = replace$1(characters2, /\f/g, "");
                if (property > 0 && strlen$1(characters2) - length2)
                  append$1(property > 32 ? declaration$1(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration$1(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append$1(reference = ruleset$1(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2, rulesets), rulesets);
                if (character2 === 123)
                  if (offset === 0)
                    parse$1(characters2, root, reference, reference, props, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat$1(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 108:
                      case 109:
                      case 115:
                        parse$1(value, reference, reference, rule && append$1(ruleset$1(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                        break;
                      default:
                        parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                    }
            }
            index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen$1(characters2), property = previous;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
                continue;
            }
            switch (characters2 += from$1(character2), character2 * variable) {
              case 38:
                ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index++] = (strlen$1(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek$1() === 45)
                  characters2 += delimit$1(next$1());
                atrule = peek$1(), offset = length2 = strlen$1(type = characters2 += identifier$1(caret$1())), character2++;
                break;
              case 45:
                if (previous === 45 && strlen$1(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset$1(value, root, parent, index, offset, rules, points, type, props, children, length2, siblings) {
      var post = offset - 1;
      var rule = offset === 0 ? rules : [""];
      var size = sizeof$1(rule);
      for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
        for (var x2 = 0, y2 = substr$1(value, post + 1, post = abs$1(j2 = points[i2])), z2 = value; x2 < size; ++x2)
          if (z2 = trim$1(j2 > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node$1(value, root, parent, offset === 0 ? RULESET$1 : type, props, children, length2, siblings);
    }
    function comment$1(value, root, parent, siblings) {
      return node$1(value, root, parent, COMMENT$1, from$1(char$1()), substr$1(value, 2, -2), 0, siblings);
    }
    function declaration$1(value, root, parent, length2, siblings) {
      return node$1(value, root, parent, DECLARATION$1, substr$1(value, 0, length2), substr$1(value, length2 + 1, -1), length2, siblings);
    }
    function prefix$1(value, length2, children) {
      switch (hash$1(value, length2)) {
        case 5103:
          return WEBKIT$1 + "print-" + value + value;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
          return WEBKIT$1 + value + value;
        case 4789:
          return MOZ$1 + value + value;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
          return WEBKIT$1 + value + MOZ$1 + value + MS$1 + value + value;
        case 5936:
          switch (charat$1(value, length2 + 11)) {
            case 114:
              return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
            case 108:
              return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
            case 45:
              return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
          }
        case 6828:
        case 4268:
        case 2903:
          return WEBKIT$1 + value + MS$1 + value + value;
        case 6165:
          return WEBKIT$1 + value + MS$1 + "flex-" + value + value;
        case 5187:
          return WEBKIT$1 + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT$1 + "box-$1$2" + MS$1 + "flex-$1$2") + value;
        case 5443:
          return WEBKIT$1 + value + MS$1 + "flex-item-" + replace$1(value, /flex-|-self/g, "") + (!match$1(value, /flex-|baseline/) ? MS$1 + "grid-row-" + replace$1(value, /flex-|-self/g, "") : "") + value;
        case 4675:
          return WEBKIT$1 + value + MS$1 + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/g, "") + value;
        case 5548:
          return WEBKIT$1 + value + MS$1 + replace$1(value, "shrink", "negative") + value;
        case 5292:
          return WEBKIT$1 + value + MS$1 + replace$1(value, "basis", "preferred-size") + value;
        case 6060:
          return WEBKIT$1 + "box-" + replace$1(value, "-grow", "") + WEBKIT$1 + value + MS$1 + replace$1(value, "grow", "positive") + value;
        case 4554:
          return WEBKIT$1 + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT$1 + "$2") + value;
        case 6187:
          return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT$1 + "$1"), /(image-set)/, WEBKIT$1 + "$1"), value, "") + value;
        case 5495:
        case 3959:
          return replace$1(value, /(image-set\([^]*)/, WEBKIT$1 + "$1$`$1");
        case 4968:
          return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT$1 + "box-pack:$3" + MS$1 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT$1 + value + value;
        case 4200:
          if (!match$1(value, /flex-|baseline/))
            return MS$1 + "grid-column-align" + substr$1(value, length2) + value;
          break;
        case 2592:
        case 3360:
          return MS$1 + replace$1(value, "template-", "") + value;
        case 4384:
        case 3616:
          if (children && children.some(function(element, index) {
            return length2 = index, match$1(element.props, /grid-\w+-end/);
          })) {
            return ~indexof$1(value + (children = children[length2].value), "span") ? value : MS$1 + replace$1(value, "-start", "") + value + MS$1 + "grid-row-span:" + (~indexof$1(children, "span") ? match$1(children, /\d+/) : +match$1(children, /\d+/) - +match$1(value, /\d+/)) + ";";
          }
          return MS$1 + replace$1(value, "-start", "") + value;
        case 4896:
        case 4128:
          return children && children.some(function(element) {
            return match$1(element.props, /grid-\w+-start/);
          }) ? value : MS$1 + replace$1(replace$1(value, "-end", "-span"), "span ", "") + value;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
          return replace$1(value, /(.+)-inline(.+)/, WEBKIT$1 + "$1$2") + value;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
          if (strlen$1(value) - 1 - length2 > 6)
            switch (charat$1(value, length2 + 1)) {
              case 109:
                if (charat$1(value, length2 + 4) !== 45)
                  break;
              case 102:
                return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT$1 + "$2-$3$1" + MOZ$1 + (charat$1(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
              case 115:
                return ~indexof$1(value, "stretch") ? prefix$1(replace$1(value, "stretch", "fill-available"), length2, children) + value : value;
            }
          break;
        case 5152:
        case 5920:
          return replace$1(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a2, b2, c2, d2, e2, f2) {
            return MS$1 + a2 + ":" + b2 + f2 + (c2 ? MS$1 + a2 + "-span:" + (d2 ? e2 : +e2 - +b2) + f2 : "") + value;
          });
        case 4949:
          if (charat$1(value, length2 + 6) === 121)
            return replace$1(value, ":", ":" + WEBKIT$1) + value;
          break;
        case 6444:
          switch (charat$1(value, charat$1(value, 14) === 45 ? 18 : 11)) {
            case 120:
              return replace$1(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT$1 + (charat$1(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT$1 + "$2$3$1" + MS$1 + "$2box$3") + value;
            case 100:
              return replace$1(value, ":", ":" + MS$1) + value;
          }
          break;
        case 5719:
        case 2647:
        case 2135:
        case 3927:
        case 2391:
          return replace$1(value, "scroll-", "scroll-snap-") + value;
      }
      return value;
    }
    function serialize$1(children, callback) {
      var output = "";
      for (var i2 = 0; i2 < children.length; i2++)
        output += callback(children[i2], i2, children, callback) || "";
      return output;
    }
    function stringify$1(element, index, children, callback) {
      switch (element.type) {
        case LAYER$1:
          if (element.children.length)
            break;
        case IMPORT$1:
        case DECLARATION$1:
          return element.return = element.return || element.value;
        case COMMENT$1:
          return "";
        case KEYFRAMES$1:
          return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
        case RULESET$1:
          if (!strlen$1(element.value = element.props.join(",")))
            return "";
      }
      return strlen$1(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    function middleware$1(collection) {
      var length2 = sizeof$1(collection);
      return function(element, index, children, callback) {
        var output = "";
        for (var i2 = 0; i2 < length2; i2++)
          output += collection[i2](element, index, children, callback) || "";
        return output;
      };
    }
    function rulesheet$1(callback) {
      return function(element) {
        if (!element.root) {
          if (element = element.return)
            callback(element);
        }
      };
    }
    function prefixer$1(element, index, children, callback) {
      if (element.length > -1) {
        if (!element.return)
          switch (element.type) {
            case DECLARATION$1:
              element.return = prefix$1(element.value, element.length, children);
              return;
            case KEYFRAMES$1:
              return serialize$1([copy$1(element, { value: replace$1(element.value, "@", "@" + WEBKIT$1) })], callback);
            case RULESET$1:
              if (element.length)
                return combine$1(children = element.props, function(value) {
                  switch (match$1(value, callback = /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      lift(copy$1(element, { props: [replace$1(value, /:(read-\w+)/, ":" + MOZ$1 + "$1")] }));
                      lift(copy$1(element, { props: [value] }));
                      assign$1(element, { props: filter(children, callback) });
                      break;
                    case "::placeholder":
                      lift(copy$1(element, { props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT$1 + "input-$1")] }));
                      lift(copy$1(element, { props: [replace$1(value, /:(plac\w+)/, ":" + MOZ$1 + "$1")] }));
                      lift(copy$1(element, { props: [replace$1(value, /:(plac\w+)/, MS$1 + "input-$1")] }));
                      lift(copy$1(element, { props: [value] }));
                      assign$1(element, { props: filter(children, callback) });
                      break;
                  }
                  return "";
                });
          }
      }
    }
    var unitlessKeys = {
      animationIterationCount: 1,
      aspectRatio: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };
    var f$3 = "undefined" != typeof process && void 0 !== process.env && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", y$2 = "undefined" != typeof window && "HTMLElement" in window, v$4 = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== {}.REACT_APP_SC_DISABLE_SPEEDY && "" !== {}.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== {}.REACT_APP_SC_DISABLE_SPEEDY && {}.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== {}.SC_DISABLE_SPEEDY && "" !== {}.SC_DISABLE_SPEEDY ? "false" !== {}.SC_DISABLE_SPEEDY && {}.SC_DISABLE_SPEEDY : false), g$4 = {}, E$1 = Object.freeze([]), N$1 = Object.freeze({});
    function P$3(e2, t2, n2) {
      return void 0 === n2 && (n2 = N$1), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
    }
    var _$3 = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), C$1 = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, I$2 = /(^-|-$)/g;
    function A$2(e2) {
      return e2.replace(C$1, "-").replace(I$2, "");
    }
    var O$1 = /(a)(d)/gi, D$3 = function(e2) {
      return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
    };
    function R$2(e2) {
      var t2, n2 = "";
      for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0)
        n2 = D$3(t2 % 52) + n2;
      return (D$3(t2 % 52) + n2).replace(O$1, "$1-$2");
    }
    var T$1, k$4 = function(e2, t2) {
      for (var n2 = t2.length; n2; )
        e2 = 33 * e2 ^ t2.charCodeAt(--n2);
      return e2;
    }, j$3 = function(e2) {
      return k$4(5381, e2);
    };
    function x$3(e2) {
      return R$2(j$3(e2) >>> 0);
    }
    function V$1(e2) {
      return e2.displayName || e2.name || "Component";
    }
    function F$3(e2) {
      return "string" == typeof e2 && true;
    }
    var M$2 = "function" == typeof Symbol && Symbol.for, $$1 = M$2 ? Symbol.for("react.memo") : 60115, z$3 = M$2 ? Symbol.for("react.forward_ref") : 60112, B$3 = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true }, L$3 = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true }, G$2 = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, Y$1 = ((T$1 = {})[z$3] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, T$1[$$1] = G$2, T$1);
    function W$1(e2) {
      return ("type" in (t2 = e2) && t2.type.$$typeof) === $$1 ? G$2 : "$$typeof" in e2 ? Y$1[e2.$$typeof] : B$3;
      var t2;
    }
    var q$6 = Object.defineProperty, H$2 = Object.getOwnPropertyNames, U$3 = Object.getOwnPropertySymbols, J$1 = Object.getOwnPropertyDescriptor, X$2 = Object.getPrototypeOf, Z$2 = Object.prototype;
    function K$1(e2, t2, n2) {
      if ("string" != typeof t2) {
        if (Z$2) {
          var o2 = X$2(t2);
          o2 && o2 !== Z$2 && K$1(e2, o2, n2);
        }
        var r2 = H$2(t2);
        U$3 && (r2 = r2.concat(U$3(t2)));
        for (var s2 = W$1(e2), i2 = W$1(t2), a2 = 0; a2 < r2.length; ++a2) {
          var c2 = r2[a2];
          if (!(c2 in L$3 || n2 && n2[c2] || i2 && c2 in i2 || s2 && c2 in s2)) {
            var l2 = J$1(t2, c2);
            try {
              q$6(e2, c2, l2);
            } catch (e3) {
            }
          }
        }
      }
      return e2;
    }
    function Q$1(e2) {
      return "function" == typeof e2;
    }
    function ee$1(e2) {
      return "object" == typeof e2 && "styledComponentId" in e2;
    }
    function te$1(e2, t2) {
      return e2 && t2 ? "".concat(e2, " ").concat(t2) : e2 || t2 || "";
    }
    function ne$1(e2, t2) {
      if (0 === e2.length)
        return "";
      for (var n2 = e2[0], o2 = 1; o2 < e2.length; o2++)
        n2 += t2 ? t2 + e2[o2] : e2[o2];
      return n2;
    }
    function oe$1(e2) {
      return null !== e2 && "object" == typeof e2 && e2.constructor.name === Object.name && !("props" in e2 && e2.$$typeof);
    }
    function re$1(e2, t2, n2) {
      if (void 0 === n2 && (n2 = false), !n2 && !oe$1(e2) && !Array.isArray(e2))
        return t2;
      if (Array.isArray(t2))
        for (var o2 = 0; o2 < t2.length; o2++)
          e2[o2] = re$1(e2[o2], t2[o2]);
      else if (oe$1(t2))
        for (var o2 in t2)
          e2[o2] = re$1(e2[o2], t2[o2]);
      return e2;
    }
    function se$1(e2, t2) {
      Object.defineProperty(e2, "toString", { value: t2 });
    }
    function ce$1(t2) {
      for (var n2 = [], o2 = 1; o2 < arguments.length; o2++)
        n2[o2 - 1] = arguments[o2];
      return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t2, " for more information.").concat(n2.length > 0 ? " Args: ".concat(n2.join(", ")) : ""));
    }
    var le$1 = function() {
      function e2(e3) {
        this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
      }
      return e2.prototype.indexOfGroup = function(e3) {
        for (var t2 = 0, n2 = 0; n2 < e3; n2++)
          t2 += this.groupSizes[n2];
        return t2;
      }, e2.prototype.insertRules = function(e3, t2) {
        if (e3 >= this.groupSizes.length) {
          for (var n2 = this.groupSizes, o2 = n2.length, r2 = o2; e3 >= r2; )
            if ((r2 <<= 1) < 0)
              throw ce$1(16, "".concat(e3));
          this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n2), this.length = r2;
          for (var s2 = o2; s2 < r2; s2++)
            this.groupSizes[s2] = 0;
        }
        for (var i2 = this.indexOfGroup(e3 + 1), a2 = (s2 = 0, t2.length); s2 < a2; s2++)
          this.tag.insertRule(i2, t2[s2]) && (this.groupSizes[e3]++, i2++);
      }, e2.prototype.clearGroup = function(e3) {
        if (e3 < this.length) {
          var t2 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), o2 = n2 + t2;
          this.groupSizes[e3] = 0;
          for (var r2 = n2; r2 < o2; r2++)
            this.tag.deleteRule(n2);
        }
      }, e2.prototype.getGroup = function(e3) {
        var t2 = "";
        if (e3 >= this.length || 0 === this.groupSizes[e3])
          return t2;
        for (var n2 = this.groupSizes[e3], o2 = this.indexOfGroup(e3), r2 = o2 + n2, s2 = o2; s2 < r2; s2++)
          t2 += "".concat(this.tag.getRule(s2)).concat("/*!sc*/\n");
        return t2;
      }, e2;
    }(), ue$1 = /* @__PURE__ */ new Map(), pe$1 = /* @__PURE__ */ new Map(), de = 1, he$1 = function(e2) {
      if (ue$1.has(e2))
        return ue$1.get(e2);
      for (; pe$1.has(de); )
        de++;
      var t2 = de++;
      return ue$1.set(e2, t2), pe$1.set(t2, e2), t2;
    }, fe$1 = function(e2, t2) {
      de = t2 + 1, ue$1.set(e2, t2), pe$1.set(t2, e2);
    }, me$1 = "style[".concat(f$3, "][").concat("data-styled-version", '="').concat("6.1.1", '"]'), ye$1 = new RegExp("^".concat(f$3, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), ve$1 = function(e2, t2, n2) {
      for (var o2, r2 = n2.split(","), s2 = 0, i2 = r2.length; s2 < i2; s2++)
        (o2 = r2[s2]) && e2.registerName(t2, o2);
    }, ge$1 = function(e2, t2) {
      for (var n2, o2 = (null !== (n2 = t2.textContent) && void 0 !== n2 ? n2 : "").split("/*!sc*/\n"), r2 = [], s2 = 0, i2 = o2.length; s2 < i2; s2++) {
        var a2 = o2[s2].trim();
        if (a2) {
          var c2 = a2.match(ye$1);
          if (c2) {
            var l2 = 0 | parseInt(c2[1], 10), u2 = c2[2];
            0 !== l2 && (fe$1(u2, l2), ve$1(e2, u2, c2[3]), e2.getTag().insertRules(l2, r2)), r2.length = 0;
          } else
            r2.push(a2);
        }
      }
    };
    function Se$1() {
      return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
    }
    var we$1 = function(e2) {
      var t2 = document.head, n2 = e2 || t2, o2 = document.createElement("style"), r2 = function(e3) {
        var t3 = Array.from(e3.querySelectorAll("style[".concat(f$3, "]")));
        return t3[t3.length - 1];
      }(n2), s2 = void 0 !== r2 ? r2.nextSibling : null;
      o2.setAttribute(f$3, "active"), o2.setAttribute("data-styled-version", "6.1.1");
      var i2 = Se$1();
      return i2 && o2.setAttribute("nonce", i2), n2.insertBefore(o2, s2), o2;
    }, be$1 = function() {
      function e2(e3) {
        this.element = we$1(e3), this.element.appendChild(document.createTextNode("")), this.sheet = function(e4) {
          if (e4.sheet)
            return e4.sheet;
          for (var t2 = document.styleSheets, n2 = 0, o2 = t2.length; n2 < o2; n2++) {
            var r2 = t2[n2];
            if (r2.ownerNode === e4)
              return r2;
          }
          throw ce$1(17);
        }(this.element), this.length = 0;
      }
      return e2.prototype.insertRule = function(e3, t2) {
        try {
          return this.sheet.insertRule(t2, e3), this.length++, true;
        } catch (e4) {
          return false;
        }
      }, e2.prototype.deleteRule = function(e3) {
        this.sheet.deleteRule(e3), this.length--;
      }, e2.prototype.getRule = function(e3) {
        var t2 = this.sheet.cssRules[e3];
        return t2 && t2.cssText ? t2.cssText : "";
      }, e2;
    }(), Ee = function() {
      function e2(e3) {
        this.element = we$1(e3), this.nodes = this.element.childNodes, this.length = 0;
      }
      return e2.prototype.insertRule = function(e3, t2) {
        if (e3 <= this.length && e3 >= 0) {
          var n2 = document.createTextNode(t2);
          return this.element.insertBefore(n2, this.nodes[e3] || null), this.length++, true;
        }
        return false;
      }, e2.prototype.deleteRule = function(e3) {
        this.element.removeChild(this.nodes[e3]), this.length--;
      }, e2.prototype.getRule = function(e3) {
        return e3 < this.length ? this.nodes[e3].textContent : "";
      }, e2;
    }(), Ne$1 = function() {
      function e2(e3) {
        this.rules = [], this.length = 0;
      }
      return e2.prototype.insertRule = function(e3, t2) {
        return e3 <= this.length && (this.rules.splice(e3, 0, t2), this.length++, true);
      }, e2.prototype.deleteRule = function(e3) {
        this.rules.splice(e3, 1), this.length--;
      }, e2.prototype.getRule = function(e3) {
        return e3 < this.length ? this.rules[e3] : "";
      }, e2;
    }(), Pe$1 = y$2, _e$1 = { isServer: !y$2, useCSSOMInjection: !v$4 }, Ce$1 = function() {
      function e2(e3, n2, o2) {
        void 0 === e3 && (e3 = N$1), void 0 === n2 && (n2 = {});
        var r2 = this;
        this.options = __assign(__assign({}, _e$1), e3), this.gs = n2, this.names = new Map(o2), this.server = !!e3.isServer, !this.server && y$2 && Pe$1 && (Pe$1 = false, function(e4) {
          for (var t2 = document.querySelectorAll(me$1), n3 = 0, o3 = t2.length; n3 < o3; n3++) {
            var r3 = t2[n3];
            r3 && "active" !== r3.getAttribute(f$3) && (ge$1(e4, r3), r3.parentNode && r3.parentNode.removeChild(r3));
          }
        }(this)), se$1(this, function() {
          return function(e4) {
            for (var t2 = e4.getTag(), n3 = t2.length, o3 = "", r3 = function(n4) {
              var r4 = function(e5) {
                return pe$1.get(e5);
              }(n4);
              if (void 0 === r4)
                return "continue";
              var s3 = e4.names.get(r4), i2 = t2.getGroup(n4);
              if (void 0 === s3 || 0 === i2.length)
                return "continue";
              var a2 = "".concat(f$3, ".g").concat(n4, '[id="').concat(r4, '"]'), c2 = "";
              void 0 !== s3 && s3.forEach(function(e5) {
                e5.length > 0 && (c2 += "".concat(e5, ","));
              }), o3 += "".concat(i2).concat(a2, '{content:"').concat(c2, '"}').concat("/*!sc*/\n");
            }, s2 = 0; s2 < n3; s2++)
              r3(s2);
            return o3;
          }(r2);
        });
      }
      return e2.registerId = function(e3) {
        return he$1(e3);
      }, e2.prototype.reconstructWithOptions = function(n2, o2) {
        return void 0 === o2 && (o2 = true), new e2(__assign(__assign({}, this.options), n2), this.gs, o2 && this.names || void 0);
      }, e2.prototype.allocateGSInstance = function(e3) {
        return this.gs[e3] = (this.gs[e3] || 0) + 1;
      }, e2.prototype.getTag = function() {
        return this.tag || (this.tag = (e3 = function(e4) {
          var t2 = e4.useCSSOMInjection, n2 = e4.target;
          return e4.isServer ? new Ne$1(n2) : t2 ? new be$1(n2) : new Ee(n2);
        }(this.options), new le$1(e3)));
        var e3;
      }, e2.prototype.hasNameForId = function(e3, t2) {
        return this.names.has(e3) && this.names.get(e3).has(t2);
      }, e2.prototype.registerName = function(e3, t2) {
        if (he$1(e3), this.names.has(e3))
          this.names.get(e3).add(t2);
        else {
          var n2 = /* @__PURE__ */ new Set();
          n2.add(t2), this.names.set(e3, n2);
        }
      }, e2.prototype.insertRules = function(e3, t2, n2) {
        this.registerName(e3, t2), this.getTag().insertRules(he$1(e3), n2);
      }, e2.prototype.clearNames = function(e3) {
        this.names.has(e3) && this.names.get(e3).clear();
      }, e2.prototype.clearRules = function(e3) {
        this.getTag().clearGroup(he$1(e3)), this.clearNames(e3);
      }, e2.prototype.clearTag = function() {
        this.tag = void 0;
      }, e2;
    }(), Ie$1 = /&/g, Ae$1 = /^\s*\/\/.*$/gm;
    function Oe$1(e2, t2) {
      return e2.map(function(e3) {
        return "rule" === e3.type && (e3.value = "".concat(t2, " ").concat(e3.value), e3.value = e3.value.replaceAll(",", ",".concat(t2, " ")), e3.props = e3.props.map(function(e4) {
          return "".concat(t2, " ").concat(e4);
        })), Array.isArray(e3.children) && "@keyframes" !== e3.type && (e3.children = Oe$1(e3.children, t2)), e3;
      });
    }
    function De$1(e2) {
      var t2, n2, o2, r2 = void 0 === e2 ? N$1 : e2, s2 = r2.options, i2 = void 0 === s2 ? N$1 : s2, a2 = r2.plugins, c2 = void 0 === a2 ? E$1 : a2, l2 = function(e3, o3, r3) {
        return r3 === n2 || r3.startsWith(n2) && r3.endsWith(n2) && r3.replaceAll(n2, "").length > 0 ? ".".concat(t2) : e3;
      }, u2 = c2.slice();
      u2.push(function(e3) {
        e3.type === RULESET$1 && e3.value.includes("&") && (e3.props[0] = e3.props[0].replace(Ie$1, n2).replace(o2, l2));
      }), i2.prefix && u2.push(prefixer$1), u2.push(stringify$1);
      var p2 = function(e3, r3, s3, a3) {
        void 0 === r3 && (r3 = ""), void 0 === s3 && (s3 = ""), void 0 === a3 && (a3 = "&"), t2 = a3, n2 = r3, o2 = new RegExp("\\".concat(n2, "\\b"), "g");
        var c3 = e3.replace(Ae$1, ""), l3 = compile$1(s3 || r3 ? "".concat(s3, " ").concat(r3, " { ").concat(c3, " }") : c3);
        i2.namespace && (l3 = Oe$1(l3, i2.namespace));
        var p3 = [];
        return serialize$1(l3, middleware$1(u2.concat(rulesheet$1(function(e4) {
          return p3.push(e4);
        })))), p3;
      };
      return p2.hash = c2.length ? c2.reduce(function(e3, t3) {
        return t3.name || ce$1(15), k$4(e3, t3.name);
      }, 5381).toString() : "", p2;
    }
    var Re$1 = new Ce$1(), Te$1 = De$1(), ke$1 = React.createContext({ shouldForwardProp: void 0, styleSheet: Re$1, stylis: Te$1 });
    ke$1.Consumer;
    React.createContext(void 0);
    function Ve() {
      return reactExports.useContext(ke$1);
    }
    var Me$1 = function() {
      function e2(e3, t2) {
        var n2 = this;
        this.inject = function(e4, t3) {
          void 0 === t3 && (t3 = Te$1);
          var o2 = n2.name + t3.hash;
          e4.hasNameForId(n2.id, o2) || e4.insertRules(n2.id, o2, t3(n2.rules, o2, "@keyframes"));
        }, this.name = e3, this.id = "sc-keyframes-".concat(e3), this.rules = t2, se$1(this, function() {
          throw ce$1(12, String(n2.name));
        });
      }
      return e2.prototype.getName = function(e3) {
        return void 0 === e3 && (e3 = Te$1), this.name + e3.hash;
      }, e2;
    }(), $e$1 = function(e2) {
      return e2 >= "A" && e2 <= "Z";
    };
    function ze$1(e2) {
      for (var t2 = "", n2 = 0; n2 < e2.length; n2++) {
        var o2 = e2[n2];
        if (1 === n2 && "-" === o2 && "-" === e2[0])
          return e2;
        $e$1(o2) ? t2 += "-" + o2.toLowerCase() : t2 += o2;
      }
      return t2.startsWith("ms-") ? "-" + t2 : t2;
    }
    var Be$1 = function(e2) {
      return null == e2 || false === e2 || "" === e2;
    }, Le$1 = function(t2) {
      var n2, o2, r2 = [];
      for (var s2 in t2) {
        var i2 = t2[s2];
        t2.hasOwnProperty(s2) && !Be$1(i2) && (Array.isArray(i2) && i2.isCss || Q$1(i2) ? r2.push("".concat(ze$1(s2), ":"), i2, ";") : oe$1(i2) ? r2.push.apply(r2, __spreadArray$3(__spreadArray$3(["".concat(s2, " {")], Le$1(i2), false), ["}"], false)) : r2.push("".concat(ze$1(s2), ": ").concat((n2 = s2, null == (o2 = i2) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || n2 in unitlessKeys || n2.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
      }
      return r2;
    };
    function Ge$1(e2, t2, n2, o2) {
      if (Be$1(e2))
        return [];
      if (ee$1(e2))
        return [".".concat(e2.styledComponentId)];
      if (Q$1(e2)) {
        if (!Q$1(s2 = e2) || s2.prototype && s2.prototype.isReactComponent || !t2)
          return [e2];
        var r2 = e2(t2);
        return Ge$1(r2, t2, n2, o2);
      }
      var s2;
      return e2 instanceof Me$1 ? n2 ? (e2.inject(n2, o2), [e2.getName(o2)]) : [e2] : oe$1(e2) ? Le$1(e2) : Array.isArray(e2) ? Array.prototype.concat.apply(E$1, e2.map(function(e3) {
        return Ge$1(e3, t2, n2, o2);
      })) : [e2.toString()];
    }
    function Ye$1(e2) {
      for (var t2 = 0; t2 < e2.length; t2 += 1) {
        var n2 = e2[t2];
        if (Q$1(n2) && !ee$1(n2))
          return false;
      }
      return true;
    }
    var We$1 = j$3("6.1.1"), qe$1 = function() {
      function e2(e3, t2, n2) {
        this.rules = e3, this.staticRulesId = "", this.isStatic = (void 0 === n2 || n2.isStatic) && Ye$1(e3), this.componentId = t2, this.baseHash = k$4(We$1, t2), this.baseStyle = n2, Ce$1.registerId(t2);
      }
      return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
        var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e3, t2, n2) : "";
        if (this.isStatic && !n2.hash)
          if (this.staticRulesId && t2.hasNameForId(this.componentId, this.staticRulesId))
            o2 = te$1(o2, this.staticRulesId);
          else {
            var r2 = ne$1(Ge$1(this.rules, e3, t2, n2)), s2 = R$2(k$4(this.baseHash, r2) >>> 0);
            if (!t2.hasNameForId(this.componentId, s2)) {
              var i2 = n2(r2, ".".concat(s2), void 0, this.componentId);
              t2.insertRules(this.componentId, s2, i2);
            }
            o2 = te$1(o2, s2), this.staticRulesId = s2;
          }
        else {
          for (var a2 = k$4(this.baseHash, n2.hash), c2 = "", l2 = 0; l2 < this.rules.length; l2++) {
            var u2 = this.rules[l2];
            if ("string" == typeof u2)
              c2 += u2;
            else if (u2) {
              var p2 = ne$1(Ge$1(u2, e3, t2, n2));
              a2 = k$4(a2, p2 + l2), c2 += p2;
            }
          }
          if (c2) {
            var d2 = R$2(a2 >>> 0);
            t2.hasNameForId(this.componentId, d2) || t2.insertRules(this.componentId, d2, n2(c2, ".".concat(d2), void 0, this.componentId)), o2 = te$1(o2, d2);
          }
        }
        return o2;
      }, e2;
    }(), He$1 = React.createContext(void 0);
    He$1.Consumer;
    function Xe$1(e2) {
      var n2 = React.useContext(He$1), r2 = reactExports.useMemo(function() {
        return function(e3, n3) {
          if (!e3)
            throw ce$1(14);
          if (Q$1(e3)) {
            var o2 = e3(n3);
            return o2;
          }
          if (Array.isArray(e3) || "object" != typeof e3)
            throw ce$1(8);
          return n3 ? __assign(__assign({}, n3), e3) : e3;
        }(e2.theme, n2);
      }, [e2.theme, n2]);
      return e2.children ? React.createElement(He$1.Provider, { value: r2 }, e2.children) : null;
    }
    var Ze$1 = {}, Ke$1 = /* @__PURE__ */ new Set();
    function Qe$1(e2, r2, s2) {
      var i2 = ee$1(e2), a2 = e2, c2 = !F$3(e2), p2 = r2.attrs, d2 = void 0 === p2 ? E$1 : p2, h2 = r2.componentId, f2 = void 0 === h2 ? function(e3, t2) {
        var n2 = "string" != typeof e3 ? "sc" : A$2(e3);
        Ze$1[n2] = (Ze$1[n2] || 0) + 1;
        var o2 = "".concat(n2, "-").concat(x$3("6.1.1" + n2 + Ze$1[n2]));
        return t2 ? "".concat(t2, "-").concat(o2) : o2;
      }(r2.displayName, r2.parentComponentId) : h2, m2 = r2.displayName, y2 = void 0 === m2 ? function(e3) {
        return F$3(e3) ? "styled.".concat(e3) : "Styled(".concat(V$1(e3), ")");
      }(e2) : m2, v2 = r2.displayName && r2.componentId ? "".concat(A$2(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2, g2 = i2 && a2.attrs ? a2.attrs.concat(d2).filter(Boolean) : d2, S2 = r2.shouldForwardProp;
      if (i2 && a2.shouldForwardProp) {
        var w2 = a2.shouldForwardProp;
        if (r2.shouldForwardProp) {
          var C2 = r2.shouldForwardProp;
          S2 = function(e3, t2) {
            return w2(e3, t2) && C2(e3, t2);
          };
        } else
          S2 = w2;
      }
      var I2 = new qe$1(s2, v2, i2 ? a2.componentStyle : void 0);
      function O2(e3, r3) {
        return function(e4, r4, s3) {
          var i3 = e4.attrs, a3 = e4.componentStyle, c3 = e4.defaultProps, p3 = e4.foldedComponentIds, d3 = e4.styledComponentId, h3 = e4.target, f3 = React.useContext(He$1), m3 = Ve(), y3 = e4.shouldForwardProp || m3.shouldForwardProp;
          var v3 = function(e5, n2, o2) {
            for (var r5, s4 = __assign(__assign({}, n2), { className: void 0, theme: o2 }), i4 = 0; i4 < e5.length; i4 += 1) {
              var a4 = Q$1(r5 = e5[i4]) ? r5(s4) : r5;
              for (var c4 in a4)
                s4[c4] = "className" === c4 ? te$1(s4[c4], a4[c4]) : "style" === c4 ? __assign(__assign({}, s4[c4]), a4[c4]) : a4[c4];
            }
            return n2.className && (s4.className = te$1(s4.className, n2.className)), s4;
          }(i3, r4, P$3(r4, f3, c3) || N$1), g3 = v3.as || h3, S3 = {};
          for (var w3 in v3)
            void 0 === v3[w3] || "$" === w3[0] || "as" === w3 || "theme" === w3 || ("forwardedAs" === w3 ? S3.as = v3.forwardedAs : y3 && !y3(w3, g3) || (S3[w3] = v3[w3], y3 || true));
          var b2 = function(e5, t2) {
            var n2 = Ve(), o2 = e5.generateAndInjectStyles(t2, n2.styleSheet, n2.stylis);
            return o2;
          }(a3, v3);
          var E2 = te$1(p3, d3);
          return b2 && (E2 += " " + b2), v3.className && (E2 += " " + v3.className), S3[F$3(g3) && !_$3.has(g3) ? "class" : "className"] = E2, S3.ref = s3, reactExports.createElement(g3, S3);
        }(D2, e3, r3);
      }
      O2.displayName = y2;
      var D2 = React.forwardRef(O2);
      return D2.attrs = g2, D2.componentStyle = I2, D2.displayName = y2, D2.shouldForwardProp = S2, D2.foldedComponentIds = i2 ? te$1(a2.foldedComponentIds, a2.styledComponentId) : "", D2.styledComponentId = v2, D2.target = i2 ? a2.target : e2, Object.defineProperty(D2, "defaultProps", { get: function() {
        return this._foldedDefaultProps;
      }, set: function(e3) {
        this._foldedDefaultProps = i2 ? function(e4) {
          for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
            t2[n2 - 1] = arguments[n2];
          for (var o2 = 0, r3 = t2; o2 < r3.length; o2++)
            re$1(e4, r3[o2], true);
          return e4;
        }({}, a2.defaultProps, e3) : e3;
      } }), se$1(D2, function() {
        return ".".concat(D2.styledComponentId);
      }), c2 && K$1(D2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
    }
    function et$1(e2, t2) {
      for (var n2 = [e2[0]], o2 = 0, r2 = t2.length; o2 < r2; o2 += 1)
        n2.push(t2[o2], e2[o2 + 1]);
      return n2;
    }
    var tt$1 = function(e2) {
      return Object.assign(e2, { isCss: true });
    };
    function nt$1(t2) {
      for (var n2 = [], o2 = 1; o2 < arguments.length; o2++)
        n2[o2 - 1] = arguments[o2];
      if (Q$1(t2) || oe$1(t2)) {
        var r2 = t2;
        return tt$1(Ge$1(et$1(E$1, __spreadArray$3([r2], n2, true))));
      }
      var s2 = t2;
      return 0 === n2.length && 1 === s2.length && "string" == typeof s2[0] ? Ge$1(s2) : tt$1(Ge$1(et$1(s2, n2)));
    }
    function ot$1(n2, o2, r2) {
      if (void 0 === r2 && (r2 = N$1), !o2)
        throw ce$1(1, o2);
      var s2 = function(t2) {
        for (var s3 = [], i2 = 1; i2 < arguments.length; i2++)
          s3[i2 - 1] = arguments[i2];
        return n2(o2, r2, nt$1.apply(void 0, __spreadArray$3([t2], s3, false)));
      };
      return s2.attrs = function(e2) {
        return ot$1(n2, o2, __assign(__assign({}, r2), { attrs: Array.prototype.concat(r2.attrs, e2).filter(Boolean) }));
      }, s2.withConfig = function(e2) {
        return ot$1(n2, o2, __assign(__assign({}, r2), e2));
      }, s2;
    }
    var rt$1 = function(e2) {
      return ot$1(Qe$1, e2);
    }, st$1 = rt$1;
    _$3.forEach(function(e2) {
      st$1[e2] = rt$1(e2);
    });
    var it$1 = function() {
      function e2(e3, t2) {
        this.rules = e3, this.componentId = t2, this.isStatic = Ye$1(e3), Ce$1.registerId(this.componentId + 1);
      }
      return e2.prototype.createStyles = function(e3, t2, n2, o2) {
        var r2 = o2(ne$1(Ge$1(this.rules, t2, n2, o2)), ""), s2 = this.componentId + e3;
        n2.insertRules(s2, s2, r2);
      }, e2.prototype.removeStyles = function(e3, t2) {
        t2.clearRules(this.componentId + e3);
      }, e2.prototype.renderStyles = function(e3, t2, n2, o2) {
        e3 > 2 && Ce$1.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t2, n2, o2);
      }, e2;
    }();
    function at$1(n2) {
      for (var r2 = [], s2 = 1; s2 < arguments.length; s2++)
        r2[s2 - 1] = arguments[s2];
      var i2 = nt$1.apply(void 0, __spreadArray$3([n2], r2, false)), a2 = "sc-global-".concat(x$3(JSON.stringify(i2))), c2 = new it$1(i2, a2);
      var l2 = function(e2) {
        var t2 = Ve(), n3 = React.useContext(He$1), r3 = React.useRef(t2.styleSheet.allocateGSInstance(a2)).current;
        return t2.styleSheet.server && u2(r3, e2, t2.styleSheet, n3, t2.stylis), React.useLayoutEffect(function() {
          if (!t2.styleSheet.server)
            return u2(r3, e2, t2.styleSheet, n3, t2.stylis), function() {
              return c2.removeStyles(r3, t2.styleSheet);
            };
        }, [r3, e2, t2.styleSheet, n3, t2.stylis]), null;
      };
      function u2(e2, n3, o2, r3, s3) {
        if (c2.isStatic)
          c2.renderStyles(e2, g$4, o2, s3);
        else {
          var i3 = __assign(__assign({}, n3), { theme: P$3(n3, r3, l2.defaultProps) });
          c2.renderStyles(e2, i3, o2, s3);
        }
      }
      return React.memo(l2);
    }
    const Layout$1 = st$1.div`
  width: ${(props) => props.$width ? props.$width : "100%"};
  /* max-width: 1920px; */
  margin: 0 auto;
  /* overflow-x: hidden; */
`;
    function Layout({ children }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout$1, { children });
    }
    const Header$3 = st$1.header`
  display: flex;
  align-items: center;
  padding: 0 15px;
  border-bottom: 1px solid ${(props) => props.theme.colors.greyF1};
  background-color: ${(props) => props.theme.colors.realWhite};
  @media ${(props) => props.theme.media.mobile} {
    padding: 3.125%;
  }
`;
    const MainLogo$1 = st$1.img`
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const mainLogo = "/assets/mainLogo.svg";
    function MainLogo() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        MainLogo$1,
        {
          src: mainLogo
        }
      );
    }
    const ADMIN_BTN_TYPES = {
      edit: "edit",
      add: "add"
    };
    const DEFAULT_WIDTH = "1267px";
    const MODAL_TYPES = {
      createCourse: "createCourse",
      createCompetition: "createCompetition",
      createChapter: "createChapter",
      createTheme: "createTheme",
      editCourse: "editCourse",
      editChapter: "editChapter",
      editTheme: "editTheme",
      newsCategory: "newsCategory"
    };
    window.matchMedia("(max-width: 768px)").matches;
    const USER_ROLES = {
      admin: "admin",
      user: "user"
    };
    const NAV_LINKS = {
      news: {
        url: "/news",
        name: "",
        icon: {
          withIcon: false,
          iconUrl: ""
        }
      },
      education: {
        url: "/courses",
        name: "",
        icon: {
          withIcon: false,
          iconUrl: ""
        }
      }
      // tasks: {
      //   url: '/tasks',
      //   name: '',
      //   icon: {
      //     withIcon: false,
      //     iconUrl: '',
      //   },
      // },
    };
    const APHORISMS = [
      {
        text: "  ,     .",
        author: " "
      },
      {
        text: "    ,   .",
        author: " "
      },
      {
        text: "   ,    .",
        author: " "
      },
      {
        text: "      ,   ,           .",
        author: " "
      },
      {
        text: ",                          ,          ,   .",
        author: " "
      },
      {
        text: "    .     ,       ,       ,  .    .",
        author: " "
      },
      {
        text: "     ,    .",
        author: " "
      },
      {
        text: "    ,     .",
        author: " "
      },
      {
        text: "           .       .",
        author: " "
      },
      {
        text: "      ,     ,     .",
        author: " "
      },
      {
        text: "    .",
        author: " "
      },
      {
        text: ",    ,    ",
        author: " "
      }
    ];
    var MediaQueries = /* @__PURE__ */ ((MediaQueries2) => {
      MediaQueries2["mobile"] = "(max-width: 768px)";
      MediaQueries2["desktop"] = "(min-width: 768px)";
      return MediaQueries2;
    })(MediaQueries || {});
    var Steps = /* @__PURE__ */ ((Steps2) => {
      Steps2["chapter"] = "chapter";
      Steps2["theme"] = "theme";
      return Steps2;
    })(Steps || {});
    const doneIcon = "/assets/done.svg";
    const selectIcon = "/assets/accordionIcon.svg";
    const TextStyles = nt$1`
  font-size: 18px;
  font-weight: 700;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realBlack};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 5.625vw;
  }
`;
    const DarkOverlay = st$1.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0, 0, 0, 0.5);
`;
    st$1.div`
  width: 100%;
  max-width: ${(props) => props.$maxWidth};
  height: 100%;
  backdrop-filter: blur(${(props) => props.$blurValue});
`;
    const DefaultBtn = st$1.button`
  min-height: 60px;
  padding: 0 3%;
  font-size: 18px;
  font-weight: 700;
  line-height: 100%;
  color: ${(props) => props.theme.colors.realWhite};
  background-color: ${(props) => props.theme.colors.mainBlue};
  border-radius: ${(props) => props.theme.utils.br};
  transition: ${(props) => props.theme.utils.transition};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.6875vw;
  }

  &:hover {
    background-color: ${(props) => props.theme.colors.darkBlue};
  }
`;
    st$1.table``;
    const Text$6 = st$1.p`
  font-size: 18px;
  font-weight: 700;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realBlack};
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};

  @media ${(props) => props.theme.media.mobile} {
    font-size: 5.625vw;
  }
`;
    const Input$4 = st$1.input`
  width: 100%;
  min-height: 60px;
  padding: 19px 29px;
  border: 1px solid ${(props) => props.theme.colors.greyEO};
  font-size: 18px;
  font-weight: 700;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realBlack};
  border-radius: ${(props) => props.theme.utils.br};
  @media ${(props) => props.theme.media.mobile} {
    min-height: 12.5vw;
    padding: 4.0625vw 5.3125vw;
    font-size: 3.75vw;
  }

  &::placeholder {
    color: ${(props) => props.theme.colors.grey93};
  }

  &:focus {
    color: ${(props) => props.theme.colors.realBlack};
    background-color: transparent;
  }
`;
    const SvgIcon$2 = st$1.svg.attrs({
      width: "24",
      height: "24",
      viewBox: "0 0 24 24",
      fill: "none"
    })`
  path {
    transition: ${(props) => props.theme.utils.transition};
  }
`;
    const InputWithState = st$1(Input$4)`
  ${(props) => {
      if (props.$isChanged && props.$isValid) {
        return nt$1`
        color: ${props.theme.colors.grey93};
        background-color: ${props.theme.colors.greyF1};
      `;
      } else if (props.$isChanged) {
        return nt$1`
        border-color: ${props.theme.colors.yRed};
      `;
      }
    }}
`;
    st$1.button`
  font-size: 18px;
  font-weight: 400;
  line-height: 120%;
  color: ${(props) => props.theme.colors.mainBlue};
  text-decoration: underline;
  background-color: transparent;
  transition: ${(props) => props.theme.utils.transition};

  &:hover {
    text-decoration: unset;
    color: ${(props) => props.theme.colors.darkBlue};
  }
`;
    const DefaultContainer = st$1.div`
  width: 100%;
  max-width: ${DEFAULT_WIDTH};
  margin: 0 auto;
`;
    const FlexContainer = st$1.div`
  display: flex;
  width: 100%;
`;
    const ProgressBar$1 = st$1(FlexContainer)`
  position: relative;
  height: 10px;
  border-radius: 5px;
  background-color: ${(props) => props.theme.colors.greyF1};
  @media ${(props) => props.theme.media.mobile} {
    height: 1.5625vw;
    border-radius: 2.532px;
  }

  &::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: ${(props) => props.$progress + "%"};
    height: 100%;
    border-radius: inherit;
    background-color: ${(props) => props.theme.colors.realBlack};
    transition: width .2s linear;
  }
`;
    const Icon$2 = st$1.div`
  display: block;
  width: 24px;
  height: 24px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;
  @media ${(props) => props.theme.media.mobile} {
    width: 7.5vw;
    height: 7.5vw;
  }
`;
    const DoneIcon$2 = st$1(Icon$2)`
  margin-right: 26px;
  /* margin-left: auto; */
  background-image: url(${doneIcon});
`;
    const AccordionIcon = st$1(Icon$2)`
  display: block;
  width: 24px;
  height: 24px;
  margin-right: 5px;
  transition: ${(props) => props.theme.utils.transition};
  transform: ${(props) => props.$active ? "rotate(-180deg)" : "none"};
  background-image: url(${selectIcon});
`;
    st$1(Text$6)`
  margin-bottom: 30px;
  font-weight: 400;
  line-height: 150%;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.6875vw;
    padding: 0 3.125vw;
    margin-bottom: 10%;
  }
`;
    st$1(FlexContainer)`
  width: 310px;
  height: 400px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.grey93};
  animation: pulse 0.5s ease-in-out infinite alternate;

  @keyframes pulse {
    100% {
      background-color: ${(props) => props.theme.colors.greyEO};
    }
  }
`;
    st$1.ol`
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin-bottom: 30px;
  list-style: decimal inside;
`;
    st$1.ul`
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin-bottom: 30px;
  list-style: disc inside;
  @media ${(props) => props.theme.media.mobile} {
    gap: 6.25vw;
    padding: 0 3.125vw;
    margin-bottom: 10%;
  }
`;
    st$1.li`
  display: list-item;
  ${TextStyles}
  font-weight: 400;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.6875vw;
  }
`;
    st$1.img`
  width: 100%;
  margin-bottom: 30px;
  border-radius: ${(props) => props.theme.utils.br};
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 10%;
    border-radius: unset;
  }
`;
    st$1(FlexContainer)`
  flex-direction: column;
`;
    const LinkContent = st$1(Text$6)`
  display: flex;
  align-items: center;
  position: relative;
  height: 100%;
  padding: 15px 0;
  color: ${(props) => props.$isActive ? props.theme.colors.dark : props.theme.colors.mainBlue};
  transition: color .2s ease-in-out;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0;
    font-weight: ${(props) => props.$isActive ? "700" : "600"};
  }

  &:hover {
    color: ${(props) => props.theme.colors.dark};
  }

  &::before {
    display: ${(props) => props.$isActive ? "block" : "none"};
    position: absolute;
    left: 50%;
    bottom: 0;
    width: 100%;
    height: 0;
    content: '';
    transform: translateX(-50%);
    background-color: ${(props) => props.theme.colors.mainBlue};
    animation: elastic .2s ease-in-out forwards;
    @media ${(props) => props.theme.media.mobile} {
      display: none;
    }
  }

  @keyframes elastic {
    100% {
      height: 4px;
    }
  }
`;
    const Icon$1 = st$1(SvgIcon$2)`
  margin-right: 5px;
  path {
    fill: ${(props) => props.$isActive ? props.theme.colors.mainBlue : props.theme.colors.dark};
  }
`;
    function CustomNavLink({ url, name, icon, onClick: onClick2 = () => {
    } }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        NavLink,
        {
          to: url,
          style: () => {
            return { textDecoration: "unset", height: "100%" };
          },
          children: ({ isActive }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkContent, { $isActive: isActive, onClick: onClick2, children: [
            icon.withIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { $isActive: isActive }),
            name
          ] })
        }
      );
    }
    const Container$N = st$1(FlexContainer)`
  max-width: min(1360px, 73%);
  margin: 0 auto;
  width: 100%;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const NavBar$1 = st$1.ul`
  display: flex;
  align-items: center;
  gap: 80px;
  height: 1px;
  min-height: 60px;
`;
    function Nav$1() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$N, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(NavBar$1, { children: Object.values(NAV_LINKS).map((navLink, index) => /* @__PURE__ */ reactExports.createElement(
        CustomNavLink,
        {
          ...navLink,
          key: index
        }
      )) }) });
    }
    var shim = { exports: {} };
    var useSyncExternalStoreShim_production_min = {};
    /**
     * @license React
     * use-sync-external-store-shim.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var e$3 = reactExports;
    function h$4(a2, b2) {
      return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var k$3 = "function" === typeof Object.is ? Object.is : h$4, l$3 = e$3.useState, m$5 = e$3.useEffect, n$4 = e$3.useLayoutEffect, p$4 = e$3.useDebugValue;
    function q$5(a2, b2) {
      var d2 = b2(), f2 = l$3({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
      n$4(function() {
        c2.value = d2;
        c2.getSnapshot = b2;
        r$4(c2) && g2({ inst: c2 });
      }, [a2, d2, b2]);
      m$5(function() {
        r$4(c2) && g2({ inst: c2 });
        return a2(function() {
          r$4(c2) && g2({ inst: c2 });
        });
      }, [a2]);
      p$4(d2);
      return d2;
    }
    function r$4(a2) {
      var b2 = a2.getSnapshot;
      a2 = a2.value;
      try {
        var d2 = b2();
        return !k$3(a2, d2);
      } catch (f2) {
        return true;
      }
    }
    function t$4(a2, b2) {
      return b2();
    }
    var u$4 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$4 : q$5;
    useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$3.useSyncExternalStore ? e$3.useSyncExternalStore : u$4;
    {
      shim.exports = useSyncExternalStoreShim_production_min;
    }
    var shimExports = shim.exports;
    var withSelector = { exports: {} };
    var withSelector_production_min = {};
    /**
     * @license React
     * use-sync-external-store-shim/with-selector.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var h$3 = reactExports, n$3 = shimExports;
    function p$3(a2, b2) {
      return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
    }
    var q$4 = "function" === typeof Object.is ? Object.is : p$3, r$3 = n$3.useSyncExternalStore, t$3 = h$3.useRef, u$3 = h$3.useEffect, v$3 = h$3.useMemo, w$3 = h$3.useDebugValue;
    withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
      var c2 = t$3(null);
      if (null === c2.current) {
        var f2 = { hasValue: false, value: null };
        c2.current = f2;
      } else
        f2 = c2.current;
      c2 = v$3(function() {
        function a3(a4) {
          if (!c3) {
            c3 = true;
            d3 = a4;
            a4 = l2(a4);
            if (void 0 !== g2 && f2.hasValue) {
              var b3 = f2.value;
              if (g2(b3, a4))
                return k2 = b3;
            }
            return k2 = a4;
          }
          b3 = k2;
          if (q$4(d3, a4))
            return b3;
          var e3 = l2(a4);
          if (void 0 !== g2 && g2(b3, e3))
            return b3;
          d3 = a4;
          return k2 = e3;
        }
        var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
        return [function() {
          return a3(b2());
        }, null === m2 ? void 0 : function() {
          return a3(m2());
        }];
      }, [b2, e2, l2, g2]);
      var d2 = r$3(a2, c2[0], c2[1]);
      u$3(function() {
        f2.hasValue = true;
        f2.value = d2;
      }, [d2]);
      w$3(d2);
      return d2;
    };
    {
      withSelector.exports = withSelector_production_min;
    }
    var withSelectorExports = withSelector.exports;
    function defaultNoopBatch(callback) {
      callback();
    }
    let batch = defaultNoopBatch;
    const setBatch = (newBatch) => batch = newBatch;
    const getBatch = () => batch;
    const ContextKey = Symbol.for(`react-redux-context`);
    const gT = typeof globalThis !== "undefined" ? globalThis : (
      /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
      {}
    );
    function getContext() {
      var _gT$ContextKey;
      if (!reactExports.createContext)
        return {};
      const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */ new Map();
      let realContext = contextMap.get(reactExports.createContext);
      if (!realContext) {
        realContext = reactExports.createContext(null);
        contextMap.set(reactExports.createContext, realContext);
      }
      return realContext;
    }
    const ReactReduxContext = /* @__PURE__ */ getContext();
    function createReduxContextHook(context = ReactReduxContext) {
      return function useReduxContext2() {
        const contextValue = reactExports.useContext(context);
        return contextValue;
      };
    }
    const useReduxContext = /* @__PURE__ */ createReduxContextHook();
    const notInitialized = () => {
      throw new Error("uSES not initialized!");
    };
    let useSyncExternalStoreWithSelector = notInitialized;
    const initializeUseSelector = (fn2) => {
      useSyncExternalStoreWithSelector = fn2;
    };
    const refEquality = (a2, b2) => a2 === b2;
    function createSelectorHook(context = ReactReduxContext) {
      const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
      return function useSelector2(selector, equalityFnOrOptions = {}) {
        const {
          equalityFn = refEquality,
          stabilityCheck = void 0,
          noopCheck = void 0
        } = typeof equalityFnOrOptions === "function" ? {
          equalityFn: equalityFnOrOptions
        } : equalityFnOrOptions;
        const {
          store: store2,
          subscription,
          getServerState,
          stabilityCheck: globalStabilityCheck,
          noopCheck: globalNoopCheck
        } = useReduxContext$1();
        reactExports.useRef(true);
        const wrappedSelector = reactExports.useCallback({
          [selector.name](state) {
            const selected = selector(state);
            return selected;
          }
        }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);
        const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store2.getState, getServerState || store2.getState, wrappedSelector, equalityFn);
        reactExports.useDebugValue(selectedState);
        return selectedState;
      };
    }
    const useSelector = /* @__PURE__ */ createSelectorHook();
    function _extends$1() {
      _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends$1.apply(this, arguments);
    }
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null)
        return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i2;
      for (i2 = 0; i2 < sourceKeys.length; i2++) {
        key = sourceKeys[i2];
        if (excluded.indexOf(key) >= 0)
          continue;
        target[key] = source[key];
      }
      return target;
    }
    var reactIs$1 = { exports: {} };
    var reactIs_production_min$1 = {};
    /** @license React v16.13.1
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$2 = "function" === typeof Symbol && Symbol.for, c$2 = b$2 ? Symbol.for("react.element") : 60103, d$4 = b$2 ? Symbol.for("react.portal") : 60106, e$2 = b$2 ? Symbol.for("react.fragment") : 60107, f$2 = b$2 ? Symbol.for("react.strict_mode") : 60108, g$3 = b$2 ? Symbol.for("react.profiler") : 60114, h$2 = b$2 ? Symbol.for("react.provider") : 60109, k$2 = b$2 ? Symbol.for("react.context") : 60110, l$2 = b$2 ? Symbol.for("react.async_mode") : 60111, m$4 = b$2 ? Symbol.for("react.concurrent_mode") : 60111, n$2 = b$2 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$2 ? Symbol.for("react.suspense") : 60113, q$3 = b$2 ? Symbol.for("react.suspense_list") : 60120, r$2 = b$2 ? Symbol.for("react.memo") : 60115, t$2 = b$2 ? Symbol.for("react.lazy") : 60116, v$2 = b$2 ? Symbol.for("react.block") : 60121, w$2 = b$2 ? Symbol.for("react.fundamental") : 60117, x$2 = b$2 ? Symbol.for("react.responder") : 60118, y$1 = b$2 ? Symbol.for("react.scope") : 60119;
    function z$2(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var u2 = a2.$$typeof;
        switch (u2) {
          case c$2:
            switch (a2 = a2.type, a2) {
              case l$2:
              case m$4:
              case e$2:
              case g$3:
              case f$2:
              case p$2:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k$2:
                  case n$2:
                  case t$2:
                  case r$2:
                  case h$2:
                    return a2;
                  default:
                    return u2;
                }
            }
          case d$4:
            return u2;
        }
      }
    }
    function A$1(a2) {
      return z$2(a2) === m$4;
    }
    reactIs_production_min$1.AsyncMode = l$2;
    reactIs_production_min$1.ConcurrentMode = m$4;
    reactIs_production_min$1.ContextConsumer = k$2;
    reactIs_production_min$1.ContextProvider = h$2;
    reactIs_production_min$1.Element = c$2;
    reactIs_production_min$1.ForwardRef = n$2;
    reactIs_production_min$1.Fragment = e$2;
    reactIs_production_min$1.Lazy = t$2;
    reactIs_production_min$1.Memo = r$2;
    reactIs_production_min$1.Portal = d$4;
    reactIs_production_min$1.Profiler = g$3;
    reactIs_production_min$1.StrictMode = f$2;
    reactIs_production_min$1.Suspense = p$2;
    reactIs_production_min$1.isAsyncMode = function(a2) {
      return A$1(a2) || z$2(a2) === l$2;
    };
    reactIs_production_min$1.isConcurrentMode = A$1;
    reactIs_production_min$1.isContextConsumer = function(a2) {
      return z$2(a2) === k$2;
    };
    reactIs_production_min$1.isContextProvider = function(a2) {
      return z$2(a2) === h$2;
    };
    reactIs_production_min$1.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
    };
    reactIs_production_min$1.isForwardRef = function(a2) {
      return z$2(a2) === n$2;
    };
    reactIs_production_min$1.isFragment = function(a2) {
      return z$2(a2) === e$2;
    };
    reactIs_production_min$1.isLazy = function(a2) {
      return z$2(a2) === t$2;
    };
    reactIs_production_min$1.isMemo = function(a2) {
      return z$2(a2) === r$2;
    };
    reactIs_production_min$1.isPortal = function(a2) {
      return z$2(a2) === d$4;
    };
    reactIs_production_min$1.isProfiler = function(a2) {
      return z$2(a2) === g$3;
    };
    reactIs_production_min$1.isStrictMode = function(a2) {
      return z$2(a2) === f$2;
    };
    reactIs_production_min$1.isSuspense = function(a2) {
      return z$2(a2) === p$2;
    };
    reactIs_production_min$1.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$4 || a2 === g$3 || a2 === f$2 || a2 === p$2 || a2 === q$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$2 || a2.$$typeof === r$2 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === n$2 || a2.$$typeof === w$2 || a2.$$typeof === x$2 || a2.$$typeof === y$1 || a2.$$typeof === v$2);
    };
    reactIs_production_min$1.typeOf = z$2;
    {
      reactIs$1.exports = reactIs_production_min$1;
    }
    var reactIsExports = reactIs$1.exports;
    var reactIs = reactIsExports;
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    var reactIs_production_min = {};
    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    var b$1 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$3 = Symbol.for("react.fragment"), e$1 = Symbol.for("react.strict_mode"), f$1 = Symbol.for("react.profiler"), g$2 = Symbol.for("react.provider"), h$1 = Symbol.for("react.context"), k$1 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$3 = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q$2 = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u$2;
    u$2 = Symbol.for("react.module.reference");
    function v$1(a2) {
      if ("object" === typeof a2 && null !== a2) {
        var r2 = a2.$$typeof;
        switch (r2) {
          case b$1:
            switch (a2 = a2.type, a2) {
              case d$3:
              case f$1:
              case e$1:
              case m$3:
              case n$1:
                return a2;
              default:
                switch (a2 = a2 && a2.$$typeof, a2) {
                  case k$1:
                  case h$1:
                  case l$1:
                  case q$2:
                  case p$1:
                  case g$2:
                    return a2;
                  default:
                    return r2;
                }
            }
          case c$1:
            return r2;
        }
      }
    }
    reactIs_production_min.ContextConsumer = h$1;
    reactIs_production_min.ContextProvider = g$2;
    reactIs_production_min.Element = b$1;
    reactIs_production_min.ForwardRef = l$1;
    reactIs_production_min.Fragment = d$3;
    reactIs_production_min.Lazy = q$2;
    reactIs_production_min.Memo = p$1;
    reactIs_production_min.Portal = c$1;
    reactIs_production_min.Profiler = f$1;
    reactIs_production_min.StrictMode = e$1;
    reactIs_production_min.Suspense = m$3;
    reactIs_production_min.SuspenseList = n$1;
    reactIs_production_min.isAsyncMode = function() {
      return false;
    };
    reactIs_production_min.isConcurrentMode = function() {
      return false;
    };
    reactIs_production_min.isContextConsumer = function(a2) {
      return v$1(a2) === h$1;
    };
    reactIs_production_min.isContextProvider = function(a2) {
      return v$1(a2) === g$2;
    };
    reactIs_production_min.isElement = function(a2) {
      return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$1;
    };
    reactIs_production_min.isForwardRef = function(a2) {
      return v$1(a2) === l$1;
    };
    reactIs_production_min.isFragment = function(a2) {
      return v$1(a2) === d$3;
    };
    reactIs_production_min.isLazy = function(a2) {
      return v$1(a2) === q$2;
    };
    reactIs_production_min.isMemo = function(a2) {
      return v$1(a2) === p$1;
    };
    reactIs_production_min.isPortal = function(a2) {
      return v$1(a2) === c$1;
    };
    reactIs_production_min.isProfiler = function(a2) {
      return v$1(a2) === f$1;
    };
    reactIs_production_min.isStrictMode = function(a2) {
      return v$1(a2) === e$1;
    };
    reactIs_production_min.isSuspense = function(a2) {
      return v$1(a2) === m$3;
    };
    reactIs_production_min.isSuspenseList = function(a2) {
      return v$1(a2) === n$1;
    };
    reactIs_production_min.isValidElementType = function(a2) {
      return "string" === typeof a2 || "function" === typeof a2 || a2 === d$3 || a2 === f$1 || a2 === e$1 || a2 === m$3 || a2 === n$1 || a2 === t$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$2 || a2.$$typeof === p$1 || a2.$$typeof === g$2 || a2.$$typeof === h$1 || a2.$$typeof === l$1 || a2.$$typeof === u$2 || void 0 !== a2.getModuleId) ? true : false;
    };
    reactIs_production_min.typeOf = v$1;
    function createListenerCollection() {
      const batch2 = getBatch();
      let first = null;
      let last = null;
      return {
        clear() {
          first = null;
          last = null;
        },
        notify() {
          batch2(() => {
            let listener = first;
            while (listener) {
              listener.callback();
              listener = listener.next;
            }
          });
        },
        get() {
          let listeners = [];
          let listener = first;
          while (listener) {
            listeners.push(listener);
            listener = listener.next;
          }
          return listeners;
        },
        subscribe(callback) {
          let isSubscribed = true;
          let listener = last = {
            callback,
            next: null,
            prev: last
          };
          if (listener.prev) {
            listener.prev.next = listener;
          } else {
            first = listener;
          }
          return function unsubscribe() {
            if (!isSubscribed || first === null)
              return;
            isSubscribed = false;
            if (listener.next) {
              listener.next.prev = listener.prev;
            } else {
              last = listener.prev;
            }
            if (listener.prev) {
              listener.prev.next = listener.next;
            } else {
              first = listener.next;
            }
          };
        }
      };
    }
    const nullListeners = {
      notify() {
      },
      get: () => []
    };
    function createSubscription(store2, parentSub) {
      let unsubscribe;
      let listeners = nullListeners;
      let subscriptionsAmount = 0;
      let selfSubscribed = false;
      function addNestedSub(listener) {
        trySubscribe();
        const cleanupListener = listeners.subscribe(listener);
        let removed = false;
        return () => {
          if (!removed) {
            removed = true;
            cleanupListener();
            tryUnsubscribe();
          }
        };
      }
      function notifyNestedSubs() {
        listeners.notify();
      }
      function handleChangeWrapper() {
        if (subscription.onStateChange) {
          subscription.onStateChange();
        }
      }
      function isSubscribed() {
        return selfSubscribed;
      }
      function trySubscribe() {
        subscriptionsAmount++;
        if (!unsubscribe) {
          unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store2.subscribe(handleChangeWrapper);
          listeners = createListenerCollection();
        }
      }
      function tryUnsubscribe() {
        subscriptionsAmount--;
        if (unsubscribe && subscriptionsAmount === 0) {
          unsubscribe();
          unsubscribe = void 0;
          listeners.clear();
          listeners = nullListeners;
        }
      }
      function trySubscribeSelf() {
        if (!selfSubscribed) {
          selfSubscribed = true;
          trySubscribe();
        }
      }
      function tryUnsubscribeSelf() {
        if (selfSubscribed) {
          selfSubscribed = false;
          tryUnsubscribe();
        }
      }
      const subscription = {
        addNestedSub,
        notifyNestedSubs,
        handleChangeWrapper,
        isSubscribed,
        trySubscribe: trySubscribeSelf,
        tryUnsubscribe: tryUnsubscribeSelf,
        getListeners: () => listeners
      };
      return subscription;
    }
    const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
    const useIsomorphicLayoutEffect$2 = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
    function is(x2, y2) {
      if (x2 === y2) {
        return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
      } else {
        return x2 !== x2 && y2 !== y2;
      }
    }
    function shallowEqual(objA, objB) {
      if (is(objA, objB))
        return true;
      if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
        return false;
      }
      const keysA = Object.keys(objA);
      const keysB = Object.keys(objB);
      if (keysA.length !== keysB.length)
        return false;
      for (let i2 = 0; i2 < keysA.length; i2++) {
        if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is(objA[keysA[i2]], objB[keysA[i2]])) {
          return false;
        }
      }
      return true;
    }
    function Provider({
      store: store2,
      context,
      children,
      serverState,
      stabilityCheck = "once",
      noopCheck = "once"
    }) {
      const contextValue = reactExports.useMemo(() => {
        const subscription = createSubscription(store2);
        return {
          store: store2,
          subscription,
          getServerState: serverState ? () => serverState : void 0,
          stabilityCheck,
          noopCheck
        };
      }, [store2, serverState, stabilityCheck, noopCheck]);
      const previousState = reactExports.useMemo(() => store2.getState(), [store2]);
      useIsomorphicLayoutEffect$2(() => {
        const {
          subscription
        } = contextValue;
        subscription.onStateChange = subscription.notifyNestedSubs;
        subscription.trySubscribe();
        if (previousState !== store2.getState()) {
          subscription.notifyNestedSubs();
        }
        return () => {
          subscription.tryUnsubscribe();
          subscription.onStateChange = void 0;
        };
      }, [contextValue, previousState]);
      const Context = context || ReactReduxContext;
      return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
        value: contextValue
      }, children);
    }
    function createStoreHook(context = ReactReduxContext) {
      const useReduxContext$1 = (
        // @ts-ignore
        context === ReactReduxContext ? useReduxContext : (
          // @ts-ignore
          createReduxContextHook(context)
        )
      );
      return function useStore2() {
        const {
          store: store2
        } = useReduxContext$1();
        return store2;
      };
    }
    const useStore = /* @__PURE__ */ createStoreHook();
    function createDispatchHook(context = ReactReduxContext) {
      const useStore$1 = (
        // @ts-ignore
        context === ReactReduxContext ? useStore : createStoreHook(context)
      );
      return function useDispatch2() {
        const store2 = useStore$1();
        return store2.dispatch;
      };
    }
    const useDispatch = /* @__PURE__ */ createDispatchHook();
    initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
    setBatch(reactDomExports.unstable_batchedUpdates);
    const useTypedSelector = useSelector;
    function n(n2) {
      for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++)
        t2[e2 - 1] = arguments[e2];
      throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
        return "'" + n3 + "'";
      }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
    }
    function r$1(n2) {
      return !!n2 && !!n2[Q];
    }
    function t(n2) {
      var r2;
      return !!n2 && (function(n3) {
        if (!n3 || "object" != typeof n3)
          return false;
        var r3 = Object.getPrototypeOf(n3);
        if (null === r3)
          return true;
        var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
        return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z$1;
      }(n2) || Array.isArray(n2) || !!n2[L$2] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L$2]) || s$1(n2) || v(n2));
    }
    function e(t2) {
      return r$1(t2) || n(23, t2), t2[Q].t;
    }
    function i(n2, r2, t2) {
      void 0 === t2 && (t2 = false), 0 === o$2(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e2) {
        t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
      }) : n2.forEach(function(t3, e2) {
        return r2(e2, t3, n2);
      });
    }
    function o$2(n2) {
      var r2 = n2[Q];
      return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s$1(n2) ? 2 : v(n2) ? 3 : 0;
    }
    function u$1(n2, r2) {
      return 2 === o$2(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
    }
    function a$1(n2, r2) {
      return 2 === o$2(n2) ? n2.get(r2) : n2[r2];
    }
    function f(n2, r2, t2) {
      var e2 = o$2(n2);
      2 === e2 ? n2.set(r2, t2) : 3 === e2 ? n2.add(t2) : n2[r2] = t2;
    }
    function c(n2, r2) {
      return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
    }
    function s$1(n2) {
      return X$1 && n2 instanceof Map;
    }
    function v(n2) {
      return q$1 && n2 instanceof Set;
    }
    function p(n2) {
      return n2.o || n2.t;
    }
    function l(n2) {
      if (Array.isArray(n2))
        return Array.prototype.slice.call(n2);
      var r2 = rn(n2);
      delete r2[Q];
      for (var t2 = nn(r2), e2 = 0; e2 < t2.length; e2++) {
        var i2 = t2[e2], o2 = r2[i2];
        false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
      }
      return Object.create(Object.getPrototypeOf(n2), r2);
    }
    function d$2(n2, e2) {
      return void 0 === e2 && (e2 = false), y(n2) || r$1(n2) || !t(n2) || (o$2(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e2 && i(n2, function(n3, r2) {
        return d$2(r2, true);
      }, true)), n2;
    }
    function h() {
      n(2);
    }
    function y(n2) {
      return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
    }
    function b(r2) {
      var t2 = tn[r2];
      return t2 || n(18, r2), t2;
    }
    function m$2(n2, r2) {
      tn[n2] || (tn[n2] = r2);
    }
    function _$2() {
      return U$2;
    }
    function j$2(n2, r2) {
      r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
    }
    function g$1(n2) {
      O(n2), n2.p.forEach(S), n2.p = null;
    }
    function O(n2) {
      n2 === U$2 && (U$2 = n2.l);
    }
    function w$1(n2) {
      return U$2 = { p: [], l: U$2, h: n2, m: true, _: 0 };
    }
    function S(n2) {
      var r2 = n2[Q];
      0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
    }
    function P$2(r2, e2) {
      e2._ = e2.p.length;
      var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
      return e2.h.O || b("ES5").S(e2, r2, o2), o2 ? (i2[Q].P && (g$1(e2), n(4)), t(r2) && (r2 = M$1(e2, r2), e2.l || x$1(e2, r2)), e2.u && b("Patches").M(i2[Q].t, r2, e2.u, e2.s)) : r2 = M$1(e2, i2, []), g$1(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H$1 ? r2 : void 0;
    }
    function M$1(n2, r2, t2) {
      if (y(r2))
        return r2;
      var e2 = r2[Q];
      if (!e2)
        return i(r2, function(i2, o3) {
          return A(n2, e2, r2, i2, o3, t2);
        }, true), r2;
      if (e2.A !== n2)
        return r2;
      if (!e2.P)
        return x$1(n2, e2.t, true), e2.t;
      if (!e2.I) {
        e2.I = true, e2.A._--;
        var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l(e2.k) : e2.o, u2 = o2, a2 = false;
        3 === e2.i && (u2 = new Set(o2), o2.clear(), a2 = true), i(u2, function(r3, i2) {
          return A(n2, e2, o2, r3, i2, t2, a2);
        }), x$1(n2, o2, false), t2 && n2.u && b("Patches").N(e2, t2, n2.u, n2.s);
      }
      return e2.o;
    }
    function A(e2, i2, o2, a2, c2, s2, v2) {
      if (r$1(c2)) {
        var p2 = M$1(e2, c2, s2 && i2 && 3 !== i2.i && !u$1(i2.R, a2) ? s2.concat(a2) : void 0);
        if (f(o2, a2, p2), !r$1(p2))
          return;
        e2.m = false;
      } else
        v2 && o2.add(c2);
      if (t(c2) && !y(c2)) {
        if (!e2.h.D && e2._ < 1)
          return;
        M$1(e2, c2), i2 && i2.A.l || x$1(e2, c2);
      }
    }
    function x$1(n2, r2, t2) {
      void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d$2(r2, t2);
    }
    function z$1(n2, r2) {
      var t2 = n2[Q];
      return (t2 ? p(t2) : n2)[r2];
    }
    function I$1(n2, r2) {
      if (r2 in n2)
        for (var t2 = Object.getPrototypeOf(n2); t2; ) {
          var e2 = Object.getOwnPropertyDescriptor(t2, r2);
          if (e2)
            return e2;
          t2 = Object.getPrototypeOf(t2);
        }
    }
    function k(n2) {
      n2.P || (n2.P = true, n2.l && k(n2.l));
    }
    function E(n2) {
      n2.o || (n2.o = l(n2.t));
    }
    function N(n2, r2, t2) {
      var e2 = s$1(r2) ? b("MapSet").F(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.O ? function(n3, r3) {
        var t3 = Array.isArray(n3), e3 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _$2(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en;
        t3 && (i2 = [e3], o2 = on);
        var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
        return e3.k = f2, e3.j = a2, f2;
      }(r2, t2) : b("ES5").J(r2, t2);
      return (t2 ? t2.A : _$2()).p.push(e2), e2;
    }
    function R$1(e2) {
      return r$1(e2) || n(22, e2), function n2(r2) {
        if (!t(r2))
          return r2;
        var e3, u2 = r2[Q], c2 = o$2(r2);
        if (u2) {
          if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
            return u2.t;
          u2.I = true, e3 = D$2(r2, c2), u2.I = false;
        } else
          e3 = D$2(r2, c2);
        return i(e3, function(r3, t2) {
          u2 && a$1(u2.t, r3) === t2 || f(e3, r3, n2(t2));
        }), 3 === c2 ? new Set(e3) : e3;
      }(e2);
    }
    function D$2(n2, r2) {
      switch (r2) {
        case 2:
          return new Map(n2);
        case 3:
          return Array.from(n2);
      }
      return l(n2);
    }
    function F$2() {
      function t2(n2, r2) {
        var t3 = s2[n2];
        return t3 ? t3.enumerable = r2 : s2[n2] = t3 = { configurable: true, enumerable: r2, get: function() {
          var r3 = this[Q];
          return en.get(r3, n2);
        }, set: function(r3) {
          var t4 = this[Q];
          en.set(t4, n2, r3);
        } }, t3;
      }
      function e2(n2) {
        for (var r2 = n2.length - 1; r2 >= 0; r2--) {
          var t3 = n2[r2][Q];
          if (!t3.P)
            switch (t3.i) {
              case 5:
                a2(t3) && k(t3);
                break;
              case 4:
                o2(t3) && k(t3);
            }
        }
      }
      function o2(n2) {
        for (var r2 = n2.t, t3 = n2.k, e3 = nn(t3), i2 = e3.length - 1; i2 >= 0; i2--) {
          var o3 = e3[i2];
          if (o3 !== Q) {
            var a3 = r2[o3];
            if (void 0 === a3 && !u$1(r2, o3))
              return true;
            var f2 = t3[o3], s3 = f2 && f2[Q];
            if (s3 ? s3.t !== a3 : !c(f2, a3))
              return true;
          }
        }
        var v2 = !!r2[Q];
        return e3.length !== nn(r2).length + (v2 ? 0 : 1);
      }
      function a2(n2) {
        var r2 = n2.k;
        if (r2.length !== n2.t.length)
          return true;
        var t3 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
        if (t3 && !t3.get)
          return true;
        for (var e3 = 0; e3 < r2.length; e3++)
          if (!r2.hasOwnProperty(e3))
            return true;
        return false;
      }
      var s2 = {};
      m$2("ES5", { J: function(n2, r2) {
        var e3 = Array.isArray(n2), i2 = function(n3, r3) {
          if (n3) {
            for (var e4 = Array(r3.length), i3 = 0; i3 < r3.length; i3++)
              Object.defineProperty(e4, "" + i3, t2(i3, true));
            return e4;
          }
          var o4 = rn(r3);
          delete o4[Q];
          for (var u2 = nn(o4), a3 = 0; a3 < u2.length; a3++) {
            var f2 = u2[a3];
            o4[f2] = t2(f2, n3 || !!o4[f2].enumerable);
          }
          return Object.create(Object.getPrototypeOf(r3), o4);
        }(e3, n2), o3 = { i: e3 ? 5 : 4, A: r2 ? r2.A : _$2(), P: false, I: false, R: {}, l: r2, t: n2, k: i2, o: null, g: false, C: false };
        return Object.defineProperty(i2, Q, { value: o3, writable: true }), i2;
      }, S: function(n2, t3, o3) {
        o3 ? r$1(t3) && t3[Q].A === n2 && e2(n2.p) : (n2.u && function n3(r2) {
          if (r2 && "object" == typeof r2) {
            var t4 = r2[Q];
            if (t4) {
              var e3 = t4.t, o4 = t4.k, f2 = t4.R, c2 = t4.i;
              if (4 === c2)
                i(o4, function(r3) {
                  r3 !== Q && (void 0 !== e3[r3] || u$1(e3, r3) ? f2[r3] || n3(o4[r3]) : (f2[r3] = true, k(t4)));
                }), i(e3, function(n4) {
                  void 0 !== o4[n4] || u$1(o4, n4) || (f2[n4] = false, k(t4));
                });
              else if (5 === c2) {
                if (a2(t4) && (k(t4), f2.length = true), o4.length < e3.length)
                  for (var s3 = o4.length; s3 < e3.length; s3++)
                    f2[s3] = false;
                else
                  for (var v2 = e3.length; v2 < o4.length; v2++)
                    f2[v2] = true;
                for (var p2 = Math.min(o4.length, e3.length), l2 = 0; l2 < p2; l2++)
                  o4.hasOwnProperty(l2) || (f2[l2] = true), void 0 === f2[l2] && n3(o4[l2]);
              }
            }
          }
        }(n2.p[0]), e2(n2.p));
      }, K: function(n2) {
        return 4 === n2.i ? o2(n2) : a2(n2);
      } });
    }
    function T() {
      function e2(n2) {
        if (!t(n2))
          return n2;
        if (Array.isArray(n2))
          return n2.map(e2);
        if (s$1(n2))
          return new Map(Array.from(n2.entries()).map(function(n3) {
            return [n3[0], e2(n3[1])];
          }));
        if (v(n2))
          return new Set(Array.from(n2).map(e2));
        var r2 = Object.create(Object.getPrototypeOf(n2));
        for (var i2 in n2)
          r2[i2] = e2(n2[i2]);
        return u$1(n2, L$2) && (r2[L$2] = n2[L$2]), r2;
      }
      function f2(n2) {
        return r$1(n2) ? e2(n2) : n2;
      }
      var c2 = "add";
      m$2("Patches", { $: function(r2, t2) {
        return t2.forEach(function(t3) {
          for (var i2 = t3.path, u2 = t3.op, f3 = r2, s2 = 0; s2 < i2.length - 1; s2++) {
            var v2 = o$2(f3), p2 = i2[s2];
            "string" != typeof p2 && "number" != typeof p2 && (p2 = "" + p2), 0 !== v2 && 1 !== v2 || "__proto__" !== p2 && "constructor" !== p2 || n(24), "function" == typeof f3 && "prototype" === p2 && n(24), "object" != typeof (f3 = a$1(f3, p2)) && n(15, i2.join("/"));
          }
          var l2 = o$2(f3), d2 = e2(t3.value), h2 = i2[i2.length - 1];
          switch (u2) {
            case "replace":
              switch (l2) {
                case 2:
                  return f3.set(h2, d2);
                case 3:
                  n(16);
                default:
                  return f3[h2] = d2;
              }
            case c2:
              switch (l2) {
                case 1:
                  return "-" === h2 ? f3.push(d2) : f3.splice(h2, 0, d2);
                case 2:
                  return f3.set(h2, d2);
                case 3:
                  return f3.add(d2);
                default:
                  return f3[h2] = d2;
              }
            case "remove":
              switch (l2) {
                case 1:
                  return f3.splice(h2, 1);
                case 2:
                  return f3.delete(h2);
                case 3:
                  return f3.delete(t3.value);
                default:
                  return delete f3[h2];
              }
            default:
              n(17, u2);
          }
        }), r2;
      }, N: function(n2, r2, t2, e3) {
        switch (n2.i) {
          case 0:
          case 4:
          case 2:
            return function(n3, r3, t3, e4) {
              var o2 = n3.t, s2 = n3.o;
              i(n3.R, function(n4, i2) {
                var v2 = a$1(o2, n4), p2 = a$1(s2, n4), l2 = i2 ? u$1(o2, n4) ? "replace" : c2 : "remove";
                if (v2 !== p2 || "replace" !== l2) {
                  var d2 = r3.concat(n4);
                  t3.push("remove" === l2 ? { op: l2, path: d2 } : { op: l2, path: d2, value: p2 }), e4.push(l2 === c2 ? { op: "remove", path: d2 } : "remove" === l2 ? { op: c2, path: d2, value: f2(v2) } : { op: "replace", path: d2, value: f2(v2) });
                }
              });
            }(n2, r2, t2, e3);
          case 5:
          case 1:
            return function(n3, r3, t3, e4) {
              var i2 = n3.t, o2 = n3.R, u2 = n3.o;
              if (u2.length < i2.length) {
                var a2 = [u2, i2];
                i2 = a2[0], u2 = a2[1];
                var s2 = [e4, t3];
                t3 = s2[0], e4 = s2[1];
              }
              for (var v2 = 0; v2 < i2.length; v2++)
                if (o2[v2] && u2[v2] !== i2[v2]) {
                  var p2 = r3.concat([v2]);
                  t3.push({ op: "replace", path: p2, value: f2(u2[v2]) }), e4.push({ op: "replace", path: p2, value: f2(i2[v2]) });
                }
              for (var l2 = i2.length; l2 < u2.length; l2++) {
                var d2 = r3.concat([l2]);
                t3.push({ op: c2, path: d2, value: f2(u2[l2]) });
              }
              i2.length < u2.length && e4.push({ op: "replace", path: r3.concat(["length"]), value: i2.length });
            }(n2, r2, t2, e3);
          case 3:
            return function(n3, r3, t3, e4) {
              var i2 = n3.t, o2 = n3.o, u2 = 0;
              i2.forEach(function(n4) {
                if (!o2.has(n4)) {
                  var i3 = r3.concat([u2]);
                  t3.push({ op: "remove", path: i3, value: n4 }), e4.unshift({ op: c2, path: i3, value: n4 });
                }
                u2++;
              }), u2 = 0, o2.forEach(function(n4) {
                if (!i2.has(n4)) {
                  var o3 = r3.concat([u2]);
                  t3.push({ op: c2, path: o3, value: n4 }), e4.unshift({ op: "remove", path: o3, value: n4 });
                }
                u2++;
              });
            }(n2, r2, t2, e3);
        }
      }, M: function(n2, r2, t2, e3) {
        t2.push({ op: "replace", path: [], value: r2 === H$1 ? void 0 : r2 }), e3.push({ op: "replace", path: [], value: n2 });
      } });
    }
    var G$1, U$2, W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X$1 = "undefined" != typeof Map, q$1 = "undefined" != typeof Set, B$2 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H$1 = W ? Symbol.for("immer-nothing") : ((G$1 = {})["immer-nothing"] = true, G$1), L$2 = W ? Symbol.for("immer-draftable") : "__$immer_draftable", Q = W ? Symbol.for("immer-state") : "__$immer_state", Z$1 = "" + Object.prototype.constructor, nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
      return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
    } : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n2) {
      var r2 = {};
      return nn(n2).forEach(function(t2) {
        r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
      }), r2;
    }, tn = {}, en = { get: function(n2, r2) {
      if (r2 === Q)
        return n2;
      var e2 = p(n2);
      if (!u$1(e2, r2))
        return function(n3, r3, t2) {
          var e3, i3 = I$1(r3, t2);
          return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
        }(n2, e2, r2);
      var i2 = e2[r2];
      return n2.I || !t(i2) ? i2 : i2 === z$1(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
    }, has: function(n2, r2) {
      return r2 in p(n2);
    }, ownKeys: function(n2) {
      return Reflect.ownKeys(p(n2));
    }, set: function(n2, r2, t2) {
      var e2 = I$1(p(n2), r2);
      if (null == e2 ? void 0 : e2.set)
        return e2.set.call(n2.k, t2), true;
      if (!n2.P) {
        var i2 = z$1(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q];
        if (o2 && o2.t === t2)
          return n2.o[r2] = t2, n2.R[r2] = false, true;
        if (c(t2, i2) && (void 0 !== t2 || u$1(n2.t, r2)))
          return true;
        E(n2), k(n2);
      }
      return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
    }, deleteProperty: function(n2, r2) {
      return void 0 !== z$1(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
    }, getOwnPropertyDescriptor: function(n2, r2) {
      var t2 = p(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
      return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
    }, defineProperty: function() {
      n(11);
    }, getPrototypeOf: function(n2) {
      return Object.getPrototypeOf(n2.t);
    }, setPrototypeOf: function() {
      n(12);
    } }, on = {};
    i(en, function(n2, r2) {
      on[n2] = function() {
        return arguments[0] = arguments[0][0], r2.apply(this, arguments);
      };
    }), on.deleteProperty = function(r2, t2) {
      return on.set.call(this, r2, t2, void 0);
    }, on.set = function(r2, t2, e2) {
      return en.set.call(this, r2[0], t2, e2, r2[0]);
    };
    var un = function() {
      function e2(r2) {
        var e3 = this;
        this.O = B$2, this.D = true, this.produce = function(r3, i3, o2) {
          if ("function" == typeof r3 && "function" != typeof i3) {
            var u2 = i3;
            i3 = r3;
            var a2 = e3;
            return function(n2) {
              var r4 = this;
              void 0 === n2 && (n2 = u2);
              for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
                e4[o3 - 1] = arguments[o3];
              return a2.produce(n2, function(n3) {
                var t3;
                return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
              });
            };
          }
          var f2;
          if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
            var c2 = w$1(e3), s2 = N(e3, r3, void 0), v2 = true;
            try {
              f2 = i3(s2), v2 = false;
            } finally {
              v2 ? g$1(c2) : O(c2);
            }
            return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
              return j$2(c2, o2), P$2(n2, c2);
            }, function(n2) {
              throw g$1(c2), n2;
            }) : (j$2(c2, o2), P$2(f2, c2));
          }
          if (!r3 || "object" != typeof r3) {
            if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H$1 && (f2 = void 0), e3.D && d$2(f2, true), o2) {
              var p2 = [], l2 = [];
              b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
            }
            return f2;
          }
          n(21, r3);
        }, this.produceWithPatches = function(n2, r3) {
          if ("function" == typeof n2)
            return function(r4) {
              for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
                i4[o3 - 1] = arguments[o3];
              return e3.produceWithPatches(r4, function(r5) {
                return n2.apply(void 0, [r5].concat(i4));
              });
            };
          var t2, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
            t2 = n3, i3 = r4;
          });
          return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
            return [n3, t2, i3];
          }) : [o2, t2, i3];
        }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
      }
      var i2 = e2.prototype;
      return i2.createDraft = function(e3) {
        t(e3) || n(8), r$1(e3) && (e3 = R$1(e3));
        var i3 = w$1(this), o2 = N(this, e3, void 0);
        return o2[Q].C = true, O(i3), o2;
      }, i2.finishDraft = function(r2, t2) {
        var e3 = r2 && r2[Q];
        var i3 = e3.A;
        return j$2(i3, t2), P$2(void 0, i3);
      }, i2.setAutoFreeze = function(n2) {
        this.D = n2;
      }, i2.setUseProxies = function(r2) {
        r2 && !B$2 && n(20), this.O = r2;
      }, i2.applyPatches = function(n2, t2) {
        var e3;
        for (e3 = t2.length - 1; e3 >= 0; e3--) {
          var i3 = t2[e3];
          if (0 === i3.path.length && "replace" === i3.op) {
            n2 = i3.value;
            break;
          }
        }
        e3 > -1 && (t2 = t2.slice(e3 + 1));
        var o2 = b("Patches").$;
        return r$1(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
          return o2(n3, t2);
        });
      }, e2;
    }(), an = new un(), fn = an.produce, cn = an.produceWithPatches.bind(an);
    an.setAutoFreeze.bind(an);
    an.setUseProxies.bind(an);
    var pn = an.applyPatches.bind(an);
    an.createDraft.bind(an);
    an.finishDraft.bind(an);
    function _typeof(o2) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
        return typeof o3;
      } : function(o3) {
        return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
      }, _typeof(o2);
    }
    function _toPrimitive(input, hint) {
      if (_typeof(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof(key) === "symbol" ? key : String(key);
    }
    function _defineProperty(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function ownKeys(e2, r2) {
      var t2 = Object.keys(e2);
      if (Object.getOwnPropertySymbols) {
        var o2 = Object.getOwnPropertySymbols(e2);
        r2 && (o2 = o2.filter(function(r3) {
          return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
        })), t2.push.apply(t2, o2);
      }
      return t2;
    }
    function _objectSpread2(e2) {
      for (var r2 = 1; r2 < arguments.length; r2++) {
        var t2 = null != arguments[r2] ? arguments[r2] : {};
        r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
          _defineProperty(e2, r3, t2[r3]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
          Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
        });
      }
      return e2;
    }
    function formatProdErrorMessage(code) {
      return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
    }
    var $$observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
    var randomString = function randomString2() {
      return Math.random().toString(36).substring(7).split("").join(".");
    };
    var ActionTypes = {
      INIT: "@@redux/INIT" + randomString(),
      REPLACE: "@@redux/REPLACE" + randomString(),
      PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
      }
    };
    function isPlainObject$3(obj) {
      if (typeof obj !== "object" || obj === null)
        return false;
      var proto = obj;
      while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
      }
      return Object.getPrototypeOf(obj) === proto;
    }
    function createStore(reducer2, preloadedState, enhancer) {
      var _ref2;
      if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
        throw new Error(formatProdErrorMessage(0));
      }
      if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
        enhancer = preloadedState;
        preloadedState = void 0;
      }
      if (typeof enhancer !== "undefined") {
        if (typeof enhancer !== "function") {
          throw new Error(formatProdErrorMessage(1));
        }
        return enhancer(createStore)(reducer2, preloadedState);
      }
      if (typeof reducer2 !== "function") {
        throw new Error(formatProdErrorMessage(2));
      }
      var currentReducer = reducer2;
      var currentState = preloadedState;
      var currentListeners = [];
      var nextListeners = currentListeners;
      var isDispatching = false;
      function ensureCanMutateNextListeners() {
        if (nextListeners === currentListeners) {
          nextListeners = currentListeners.slice();
        }
      }
      function getState() {
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(3));
        }
        return currentState;
      }
      function subscribe(listener) {
        if (typeof listener !== "function") {
          throw new Error(formatProdErrorMessage(4));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(5));
        }
        var isSubscribed = true;
        ensureCanMutateNextListeners();
        nextListeners.push(listener);
        return function unsubscribe() {
          if (!isSubscribed) {
            return;
          }
          if (isDispatching) {
            throw new Error(formatProdErrorMessage(6));
          }
          isSubscribed = false;
          ensureCanMutateNextListeners();
          var index = nextListeners.indexOf(listener);
          nextListeners.splice(index, 1);
          currentListeners = null;
        };
      }
      function dispatch(action) {
        if (!isPlainObject$3(action)) {
          throw new Error(formatProdErrorMessage(7));
        }
        if (typeof action.type === "undefined") {
          throw new Error(formatProdErrorMessage(8));
        }
        if (isDispatching) {
          throw new Error(formatProdErrorMessage(9));
        }
        try {
          isDispatching = true;
          currentState = currentReducer(currentState, action);
        } finally {
          isDispatching = false;
        }
        var listeners = currentListeners = nextListeners;
        for (var i2 = 0; i2 < listeners.length; i2++) {
          var listener = listeners[i2];
          listener();
        }
        return action;
      }
      function replaceReducer(nextReducer) {
        if (typeof nextReducer !== "function") {
          throw new Error(formatProdErrorMessage(10));
        }
        currentReducer = nextReducer;
        dispatch({
          type: ActionTypes.REPLACE
        });
      }
      function observable() {
        var _ref;
        var outerSubscribe = subscribe;
        return _ref = {
          /**
           * The minimal observable subscription method.
           * @param {Object} observer Any object that can be used as an observer.
           * The observer object should have a `next` method.
           * @returns {subscription} An object with an `unsubscribe` method that can
           * be used to unsubscribe the observable from the store, and prevent further
           * emission of values from the observable.
           */
          subscribe: function subscribe2(observer) {
            if (typeof observer !== "object" || observer === null) {
              throw new Error(formatProdErrorMessage(11));
            }
            function observeState() {
              if (observer.next) {
                observer.next(getState());
              }
            }
            observeState();
            var unsubscribe = outerSubscribe(observeState);
            return {
              unsubscribe
            };
          }
        }, _ref[$$observable] = function() {
          return this;
        }, _ref;
      }
      dispatch({
        type: ActionTypes.INIT
      });
      return _ref2 = {
        dispatch,
        subscribe,
        getState,
        replaceReducer
      }, _ref2[$$observable] = observable, _ref2;
    }
    function assertReducerShape(reducers) {
      Object.keys(reducers).forEach(function(key) {
        var reducer2 = reducers[key];
        var initialState2 = reducer2(void 0, {
          type: ActionTypes.INIT
        });
        if (typeof initialState2 === "undefined") {
          throw new Error(formatProdErrorMessage(12));
        }
        if (typeof reducer2(void 0, {
          type: ActionTypes.PROBE_UNKNOWN_ACTION()
        }) === "undefined") {
          throw new Error(formatProdErrorMessage(13));
        }
      });
    }
    function combineReducers(reducers) {
      var reducerKeys = Object.keys(reducers);
      var finalReducers = {};
      for (var i2 = 0; i2 < reducerKeys.length; i2++) {
        var key = reducerKeys[i2];
        if (typeof reducers[key] === "function") {
          finalReducers[key] = reducers[key];
        }
      }
      var finalReducerKeys = Object.keys(finalReducers);
      var shapeAssertionError;
      try {
        assertReducerShape(finalReducers);
      } catch (e2) {
        shapeAssertionError = e2;
      }
      return function combination(state, action) {
        if (state === void 0) {
          state = {};
        }
        if (shapeAssertionError) {
          throw shapeAssertionError;
        }
        var hasChanged = false;
        var nextState = {};
        for (var _i = 0; _i < finalReducerKeys.length; _i++) {
          var _key = finalReducerKeys[_i];
          var reducer2 = finalReducers[_key];
          var previousStateForKey = state[_key];
          var nextStateForKey = reducer2(previousStateForKey, action);
          if (typeof nextStateForKey === "undefined") {
            action && action.type;
            throw new Error(formatProdErrorMessage(14));
          }
          nextState[_key] = nextStateForKey;
          hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
        }
        hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
        return hasChanged ? nextState : state;
      };
    }
    function bindActionCreator(actionCreator, dispatch) {
      return function() {
        return dispatch(actionCreator.apply(this, arguments));
      };
    }
    function bindActionCreators(actionCreators, dispatch) {
      if (typeof actionCreators === "function") {
        return bindActionCreator(actionCreators, dispatch);
      }
      if (typeof actionCreators !== "object" || actionCreators === null) {
        throw new Error(formatProdErrorMessage(16));
      }
      var boundActionCreators = {};
      for (var key in actionCreators) {
        var actionCreator = actionCreators[key];
        if (typeof actionCreator === "function") {
          boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
        }
      }
      return boundActionCreators;
    }
    function compose$1() {
      for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
        funcs[_key] = arguments[_key];
      }
      if (funcs.length === 0) {
        return function(arg) {
          return arg;
        };
      }
      if (funcs.length === 1) {
        return funcs[0];
      }
      return funcs.reduce(function(a2, b2) {
        return function() {
          return a2(b2.apply(void 0, arguments));
        };
      });
    }
    function applyMiddleware() {
      for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
        middlewares[_key] = arguments[_key];
      }
      return function(createStore2) {
        return function() {
          var store2 = createStore2.apply(void 0, arguments);
          var _dispatch = function dispatch() {
            throw new Error(formatProdErrorMessage(15));
          };
          var middlewareAPI = {
            getState: store2.getState,
            dispatch: function dispatch() {
              return _dispatch.apply(void 0, arguments);
            }
          };
          var chain = middlewares.map(function(middleware2) {
            return middleware2(middlewareAPI);
          });
          _dispatch = compose$1.apply(void 0, chain)(store2.dispatch);
          return _objectSpread2(_objectSpread2({}, store2), {}, {
            dispatch: _dispatch
          });
        };
      };
    }
    var NOT_FOUND = "NOT_FOUND";
    function createSingletonCache(equals) {
      var entry;
      return {
        get: function get(key) {
          if (entry && equals(entry.key, key)) {
            return entry.value;
          }
          return NOT_FOUND;
        },
        put: function put(key, value) {
          entry = {
            key,
            value
          };
        },
        getEntries: function getEntries() {
          return entry ? [entry] : [];
        },
        clear: function clear() {
          entry = void 0;
        }
      };
    }
    function createLruCache(maxSize, equals) {
      var entries = [];
      function get(key) {
        var cacheIndex = entries.findIndex(function(entry2) {
          return equals(key, entry2.key);
        });
        if (cacheIndex > -1) {
          var entry = entries[cacheIndex];
          if (cacheIndex > 0) {
            entries.splice(cacheIndex, 1);
            entries.unshift(entry);
          }
          return entry.value;
        }
        return NOT_FOUND;
      }
      function put(key, value) {
        if (get(key) === NOT_FOUND) {
          entries.unshift({
            key,
            value
          });
          if (entries.length > maxSize) {
            entries.pop();
          }
        }
      }
      function getEntries() {
        return entries;
      }
      function clear() {
        entries = [];
      }
      return {
        get,
        put,
        getEntries,
        clear
      };
    }
    var defaultEqualityCheck = function defaultEqualityCheck2(a2, b2) {
      return a2 === b2;
    };
    function createCacheKeyComparator(equalityCheck) {
      return function areArgumentsShallowlyEqual(prev2, next2) {
        if (prev2 === null || next2 === null || prev2.length !== next2.length) {
          return false;
        }
        var length2 = prev2.length;
        for (var i2 = 0; i2 < length2; i2++) {
          if (!equalityCheck(prev2[i2], next2[i2])) {
            return false;
          }
        }
        return true;
      };
    }
    function defaultMemoize(func, equalityCheckOrOptions) {
      var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
        equalityCheck: equalityCheckOrOptions
      };
      var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
      var comparator = createCacheKeyComparator(equalityCheck);
      var cache2 = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
      function memoized() {
        var value = cache2.get(arguments);
        if (value === NOT_FOUND) {
          value = func.apply(null, arguments);
          if (resultEqualityCheck) {
            var entries = cache2.getEntries();
            var matchingEntry = entries.find(function(entry) {
              return resultEqualityCheck(entry.value, value);
            });
            if (matchingEntry) {
              value = matchingEntry.value;
            }
          }
          cache2.put(arguments, value);
        }
        return value;
      }
      memoized.clearCache = function() {
        return cache2.clear();
      };
      return memoized;
    }
    function getDependencies(funcs) {
      var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
      if (!dependencies.every(function(dep) {
        return typeof dep === "function";
      })) {
        var dependencyTypes = dependencies.map(function(dep) {
          return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
        }).join(", ");
        throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
      }
      return dependencies;
    }
    function createSelectorCreator(memoize2) {
      for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        memoizeOptionsFromArgs[_key - 1] = arguments[_key];
      }
      var createSelector2 = function createSelector3() {
        for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          funcs[_key2] = arguments[_key2];
        }
        var _recomputations = 0;
        var _lastResult;
        var directlyPassedOptions = {
          memoizeOptions: void 0
        };
        var resultFunc = funcs.pop();
        if (typeof resultFunc === "object") {
          directlyPassedOptions = resultFunc;
          resultFunc = funcs.pop();
        }
        if (typeof resultFunc !== "function") {
          throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
        }
        var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
        var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
        var dependencies = getDependencies(funcs);
        var memoizedResultFunc = memoize2.apply(void 0, [function recomputationWrapper() {
          _recomputations++;
          return resultFunc.apply(null, arguments);
        }].concat(finalMemoizeOptions));
        var selector = memoize2(function dependenciesChecker() {
          var params = [];
          var length2 = dependencies.length;
          for (var i2 = 0; i2 < length2; i2++) {
            params.push(dependencies[i2].apply(null, arguments));
          }
          _lastResult = memoizedResultFunc.apply(null, params);
          return _lastResult;
        });
        Object.assign(selector, {
          resultFunc,
          memoizedResultFunc,
          dependencies,
          lastResult: function lastResult() {
            return _lastResult;
          },
          recomputations: function recomputations() {
            return _recomputations;
          },
          resetRecomputations: function resetRecomputations() {
            return _recomputations = 0;
          }
        });
        return selector;
      };
      return createSelector2;
    }
    var createSelector = /* @__PURE__ */ createSelectorCreator(defaultMemoize);
    function createThunkMiddleware(extraArgument) {
      var middleware2 = function middleware3(_ref) {
        var dispatch = _ref.dispatch, getState = _ref.getState;
        return function(next2) {
          return function(action) {
            if (typeof action === "function") {
              return action(dispatch, getState, extraArgument);
            }
            return next2(action);
          };
        };
      };
      return middleware2;
    }
    var thunk = createThunkMiddleware();
    thunk.withExtraArgument = createThunkMiddleware;
    const thunkMiddleware = thunk;
    var __extends = globalThis && globalThis.__extends || function() {
      var extendStatics = function(d2, b2) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
          d3.__proto__ = b3;
        } || function(d3, b3) {
          for (var p2 in b3)
            if (Object.prototype.hasOwnProperty.call(b3, p2))
              d3[p2] = b3[p2];
        };
        return extendStatics(d2, b2);
      };
      return function(d2, b2) {
        if (typeof b2 !== "function" && b2 !== null)
          throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
        extendStatics(d2, b2);
        function __() {
          this.constructor = d2;
        }
        d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
      };
    }();
    var __generator$1 = globalThis && globalThis.__generator || function(thisArg, body2) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y2, t2, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
              return t2;
            if (y2 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body2.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray$2 = globalThis && globalThis.__spreadArray || function(to2, from2) {
      for (var i2 = 0, il2 = from2.length, j2 = to2.length; i2 < il2; i2++, j2++)
        to2[j2] = from2[i2];
      return to2;
    };
    var __defProp$2 = Object.defineProperty;
    var __defProps$2 = Object.defineProperties;
    var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
    var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
    var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$2 = function(obj, key, value) {
      return key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    };
    var __spreadValues$2 = function(a2, b2) {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp$2.call(b2, prop))
          __defNormalProp$2(a2, prop, b2[prop]);
      if (__getOwnPropSymbols$2)
        for (var _i = 0, _c = __getOwnPropSymbols$2(b2); _i < _c.length; _i++) {
          var prop = _c[_i];
          if (__propIsEnum$2.call(b2, prop))
            __defNormalProp$2(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps$2 = function(a2, b2) {
      return __defProps$2(a2, __getOwnPropDescs$2(b2));
    };
    var __async$1 = function(__this, __arguments, generator) {
      return new Promise(function(resolve, reject) {
        var fulfilled = function(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var rejected = function(value) {
          try {
            step(generator.throw(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var step = function(x2) {
          return x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
        };
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
      if (arguments.length === 0)
        return void 0;
      if (typeof arguments[0] === "object")
        return compose$1;
      return compose$1.apply(null, arguments);
    };
    function isPlainObject$2(value) {
      if (typeof value !== "object" || value === null)
        return false;
      var proto = Object.getPrototypeOf(value);
      if (proto === null)
        return true;
      var baseProto = proto;
      while (Object.getPrototypeOf(baseProto) !== null) {
        baseProto = Object.getPrototypeOf(baseProto);
      }
      return proto === baseProto;
    }
    var hasMatchFunction = function(v2) {
      return v2 && typeof v2.match === "function";
    };
    function createAction(type, prepareAction) {
      function actionCreator() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (prepareAction) {
          var prepared = prepareAction.apply(void 0, args);
          if (!prepared) {
            throw new Error("prepareAction did not return an object");
          }
          return __spreadValues$2(__spreadValues$2({
            type,
            payload: prepared.payload
          }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
        }
        return { type, payload: args[0] };
      }
      actionCreator.toString = function() {
        return "" + type;
      };
      actionCreator.type = type;
      actionCreator.match = function(action) {
        return action.type === type;
      };
      return actionCreator;
    }
    var MiddlewareArray = (
      /** @class */
      function(_super) {
        __extends(MiddlewareArray2, _super);
        function MiddlewareArray2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.apply(this, args) || this;
          Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
          return _this;
        }
        Object.defineProperty(MiddlewareArray2, Symbol.species, {
          get: function() {
            return MiddlewareArray2;
          },
          enumerable: false,
          configurable: true
        });
        MiddlewareArray2.prototype.concat = function() {
          var arr = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
          }
          return _super.prototype.concat.apply(this, arr);
        };
        MiddlewareArray2.prototype.prepend = function() {
          var arr = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
          }
          if (arr.length === 1 && Array.isArray(arr[0])) {
            return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray$2([void 0], arr[0].concat(this))))();
          }
          return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray$2([void 0], arr.concat(this))))();
        };
        return MiddlewareArray2;
      }(Array)
    );
    var EnhancerArray = (
      /** @class */
      function(_super) {
        __extends(EnhancerArray2, _super);
        function EnhancerArray2() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _this = _super.apply(this, args) || this;
          Object.setPrototypeOf(_this, EnhancerArray2.prototype);
          return _this;
        }
        Object.defineProperty(EnhancerArray2, Symbol.species, {
          get: function() {
            return EnhancerArray2;
          },
          enumerable: false,
          configurable: true
        });
        EnhancerArray2.prototype.concat = function() {
          var arr = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
          }
          return _super.prototype.concat.apply(this, arr);
        };
        EnhancerArray2.prototype.prepend = function() {
          var arr = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            arr[_i] = arguments[_i];
          }
          if (arr.length === 1 && Array.isArray(arr[0])) {
            return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray$2([void 0], arr[0].concat(this))))();
          }
          return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray$2([void 0], arr.concat(this))))();
        };
        return EnhancerArray2;
      }(Array)
    );
    function freezeDraftable(val) {
      return t(val) ? fn(val, function() {
      }) : val;
    }
    function isBoolean(x2) {
      return typeof x2 === "boolean";
    }
    function curryGetDefaultMiddleware() {
      return function curriedGetDefaultMiddleware(options) {
        return getDefaultMiddleware(options);
      };
    }
    function getDefaultMiddleware(options) {
      if (options === void 0) {
        options = {};
      }
      var _c = options.thunk, thunk2 = _c === void 0 ? true : _c;
      options.immutableCheck;
      options.serializableCheck;
      options.actionCreatorCheck;
      var middlewareArray = new MiddlewareArray();
      if (thunk2) {
        if (isBoolean(thunk2)) {
          middlewareArray.push(thunkMiddleware);
        } else {
          middlewareArray.push(thunkMiddleware.withExtraArgument(thunk2.extraArgument));
        }
      }
      return middlewareArray;
    }
    var IS_PRODUCTION = true;
    function configureStore(options) {
      var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
      var _c = options || {}, _d = _c.reducer, reducer2 = _d === void 0 ? void 0 : _d, _e2 = _c.middleware, middleware2 = _e2 === void 0 ? curriedGetDefaultMiddleware() : _e2, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
      var rootReducer;
      if (typeof reducer2 === "function") {
        rootReducer = reducer2;
      } else if (isPlainObject$2(reducer2)) {
        rootReducer = combineReducers(reducer2);
      } else {
        throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
      }
      var finalMiddleware = middleware2;
      if (typeof finalMiddleware === "function") {
        finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
      }
      var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
      var finalCompose = compose$1;
      if (devTools) {
        finalCompose = composeWithDevTools(__spreadValues$2({
          trace: !IS_PRODUCTION
        }, typeof devTools === "object" && devTools));
      }
      var defaultEnhancers = new EnhancerArray(middlewareEnhancer);
      var storeEnhancers = defaultEnhancers;
      if (Array.isArray(enhancers)) {
        storeEnhancers = __spreadArray$2([middlewareEnhancer], enhancers);
      } else if (typeof enhancers === "function") {
        storeEnhancers = enhancers(defaultEnhancers);
      }
      var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
      return createStore(rootReducer, preloadedState, composedEnhancer);
    }
    function executeReducerBuilderCallback(builderCallback) {
      var actionsMap = {};
      var actionMatchers = [];
      var defaultCaseReducer;
      var builder = {
        addCase: function(typeOrActionCreator, reducer2) {
          var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
          if (!type) {
            throw new Error("`builder.addCase` cannot be called with an empty action type");
          }
          if (type in actionsMap) {
            throw new Error("`builder.addCase` cannot be called with two reducers for the same action type");
          }
          actionsMap[type] = reducer2;
          return builder;
        },
        addMatcher: function(matcher, reducer2) {
          actionMatchers.push({ matcher, reducer: reducer2 });
          return builder;
        },
        addDefaultCase: function(reducer2) {
          defaultCaseReducer = reducer2;
          return builder;
        }
      };
      builderCallback(builder);
      return [actionsMap, actionMatchers, defaultCaseReducer];
    }
    function isStateFunction(x2) {
      return typeof x2 === "function";
    }
    function createReducer(initialState2, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
      if (actionMatchers === void 0) {
        actionMatchers = [];
      }
      var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
      var getInitialState;
      if (isStateFunction(initialState2)) {
        getInitialState = function() {
          return freezeDraftable(initialState2());
        };
      } else {
        var frozenInitialState_1 = freezeDraftable(initialState2);
        getInitialState = function() {
          return frozenInitialState_1;
        };
      }
      function reducer2(state, action) {
        if (state === void 0) {
          state = getInitialState();
        }
        var caseReducers = __spreadArray$2([
          actionsMap[action.type]
        ], finalActionMatchers.filter(function(_c2) {
          var matcher = _c2.matcher;
          return matcher(action);
        }).map(function(_c2) {
          var reducer22 = _c2.reducer;
          return reducer22;
        }));
        if (caseReducers.filter(function(cr) {
          return !!cr;
        }).length === 0) {
          caseReducers = [finalDefaultCaseReducer];
        }
        return caseReducers.reduce(function(previousState, caseReducer) {
          if (caseReducer) {
            if (r$1(previousState)) {
              var draft = previousState;
              var result = caseReducer(draft, action);
              if (result === void 0) {
                return previousState;
              }
              return result;
            } else if (!t(previousState)) {
              var result = caseReducer(previousState, action);
              if (result === void 0) {
                if (previousState === null) {
                  return previousState;
                }
                throw Error("A case reducer on a non-draftable value must not return undefined");
              }
              return result;
            } else {
              return fn(previousState, function(draft2) {
                return caseReducer(draft2, action);
              });
            }
          }
          return previousState;
        }, state);
      }
      reducer2.getInitialState = getInitialState;
      return reducer2;
    }
    function getType2(slice2, actionKey) {
      return slice2 + "/" + actionKey;
    }
    function createSlice(options) {
      var name = options.name;
      if (!name) {
        throw new Error("`name` is a required option for createSlice");
      }
      if (typeof process !== "undefined" && false) {
        if (options.initialState === void 0) {
          console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
        }
      }
      var initialState2 = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
      var reducers = options.reducers || {};
      var reducerNames = Object.keys(reducers);
      var sliceCaseReducersByName = {};
      var sliceCaseReducersByType = {};
      var actionCreators = {};
      reducerNames.forEach(function(reducerName) {
        var maybeReducerWithPrepare = reducers[reducerName];
        var type = getType2(name, reducerName);
        var caseReducer;
        var prepareCallback;
        if ("reducer" in maybeReducerWithPrepare) {
          caseReducer = maybeReducerWithPrepare.reducer;
          prepareCallback = maybeReducerWithPrepare.prepare;
        } else {
          caseReducer = maybeReducerWithPrepare;
        }
        sliceCaseReducersByName[reducerName] = caseReducer;
        sliceCaseReducersByType[type] = caseReducer;
        actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
      });
      function buildReducer() {
        var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e2 = _c[1], actionMatchers = _e2 === void 0 ? [] : _e2, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
        var finalCaseReducers = __spreadValues$2(__spreadValues$2({}, extraReducers), sliceCaseReducersByType);
        return createReducer(initialState2, function(builder) {
          for (var key in finalCaseReducers) {
            builder.addCase(key, finalCaseReducers[key]);
          }
          for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
            var m2 = actionMatchers_1[_i];
            builder.addMatcher(m2.matcher, m2.reducer);
          }
          if (defaultCaseReducer) {
            builder.addDefaultCase(defaultCaseReducer);
          }
        });
      }
      var _reducer;
      return {
        name,
        reducer: function(state, action) {
          if (!_reducer)
            _reducer = buildReducer();
          return _reducer(state, action);
        },
        actions: actionCreators,
        caseReducers: sliceCaseReducersByName,
        getInitialState: function() {
          if (!_reducer)
            _reducer = buildReducer();
          return _reducer.getInitialState();
        }
      };
    }
    var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
    var nanoid = function(size) {
      if (size === void 0) {
        size = 21;
      }
      var id2 = "";
      var i2 = size;
      while (i2--) {
        id2 += urlAlphabet[Math.random() * 64 | 0];
      }
      return id2;
    };
    var commonProperties = [
      "name",
      "message",
      "stack",
      "code"
    ];
    var RejectWithValue = (
      /** @class */
      function() {
        function RejectWithValue2(payload, meta) {
          this.payload = payload;
          this.meta = meta;
        }
        return RejectWithValue2;
      }()
    );
    var FulfillWithMeta = (
      /** @class */
      function() {
        function FulfillWithMeta2(payload, meta) {
          this.payload = payload;
          this.meta = meta;
        }
        return FulfillWithMeta2;
      }()
    );
    var miniSerializeError = function(value) {
      if (typeof value === "object" && value !== null) {
        var simpleError = {};
        for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
          var property = commonProperties_1[_i];
          if (typeof value[property] === "string") {
            simpleError[property] = value[property];
          }
        }
        return simpleError;
      }
      return { message: String(value) };
    };
    var createAsyncThunk = function() {
      function createAsyncThunk2(typePrefix, payloadCreator, options) {
        var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
          return {
            payload,
            meta: __spreadProps$2(__spreadValues$2({}, meta || {}), {
              arg,
              requestId,
              requestStatus: "fulfilled"
            })
          };
        });
        var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
          return {
            payload: void 0,
            meta: __spreadProps$2(__spreadValues$2({}, meta || {}), {
              arg,
              requestId,
              requestStatus: "pending"
            })
          };
        });
        var rejected = createAction(typePrefix + "/rejected", function(error, requestId, arg, payload, meta) {
          return {
            payload,
            error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
            meta: __spreadProps$2(__spreadValues$2({}, meta || {}), {
              arg,
              requestId,
              rejectedWithValue: !!payload,
              requestStatus: "rejected",
              aborted: (error == null ? void 0 : error.name) === "AbortError",
              condition: (error == null ? void 0 : error.name) === "ConditionError"
            })
          };
        });
        var AC = typeof AbortController !== "undefined" ? AbortController : (
          /** @class */
          function() {
            function class_1() {
              this.signal = {
                aborted: false,
                addEventListener: function() {
                },
                dispatchEvent: function() {
                  return false;
                },
                onabort: function() {
                },
                removeEventListener: function() {
                },
                reason: void 0,
                throwIfAborted: function() {
                }
              };
            }
            class_1.prototype.abort = function() {
            };
            return class_1;
          }()
        );
        function actionCreator(arg) {
          return function(dispatch, getState, extra) {
            var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
            var abortController = new AC();
            var abortReason;
            function abort(reason) {
              abortReason = reason;
              abortController.abort();
            }
            var promise2 = function() {
              return __async$1(this, null, function() {
                var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
                return __generator$1(this, function(_c) {
                  switch (_c.label) {
                    case 0:
                      _c.trys.push([0, 4, , 5]);
                      conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, { getState, extra });
                      if (!isThenable(conditionResult))
                        return [3, 2];
                      return [4, conditionResult];
                    case 1:
                      conditionResult = _c.sent();
                      _c.label = 2;
                    case 2:
                      if (conditionResult === false || abortController.signal.aborted) {
                        throw {
                          name: "ConditionError",
                          message: "Aborted due to condition callback returning false."
                        };
                      }
                      abortedPromise = new Promise(function(_2, reject) {
                        return abortController.signal.addEventListener("abort", function() {
                          return reject({
                            name: "AbortError",
                            message: abortReason || "Aborted"
                          });
                        });
                      });
                      dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, { requestId, arg }, { getState, extra })));
                      return [4, Promise.race([
                        abortedPromise,
                        Promise.resolve(payloadCreator(arg, {
                          dispatch,
                          getState,
                          extra,
                          requestId,
                          signal: abortController.signal,
                          abort,
                          rejectWithValue: function(value, meta) {
                            return new RejectWithValue(value, meta);
                          },
                          fulfillWithValue: function(value, meta) {
                            return new FulfillWithMeta(value, meta);
                          }
                        })).then(function(result) {
                          if (result instanceof RejectWithValue) {
                            throw result;
                          }
                          if (result instanceof FulfillWithMeta) {
                            return fulfilled(result.payload, requestId, arg, result.meta);
                          }
                          return fulfilled(result, requestId, arg);
                        })
                      ])];
                    case 3:
                      finalAction = _c.sent();
                      return [3, 5];
                    case 4:
                      err_1 = _c.sent();
                      finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                      return [3, 5];
                    case 5:
                      skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                      if (!skipDispatch) {
                        dispatch(finalAction);
                      }
                      return [2, finalAction];
                  }
                });
              });
            }();
            return Object.assign(promise2, {
              abort,
              requestId,
              arg,
              unwrap: function() {
                return promise2.then(unwrapResult);
              }
            });
          };
        }
        return Object.assign(actionCreator, {
          pending,
          rejected,
          fulfilled,
          typePrefix
        });
      }
      createAsyncThunk2.withTypes = function() {
        return createAsyncThunk2;
      };
      return createAsyncThunk2;
    }();
    function unwrapResult(action) {
      if (action.meta && action.meta.rejectedWithValue) {
        throw action.payload;
      }
      if (action.error) {
        throw action.error;
      }
      return action.payload;
    }
    function isThenable(value) {
      return value !== null && typeof value === "object" && typeof value.then === "function";
    }
    var matches = function(matcher, action) {
      if (hasMatchFunction(matcher)) {
        return matcher.match(action);
      } else {
        return matcher(action);
      }
    };
    function isAnyOf() {
      var matchers = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        matchers[_i] = arguments[_i];
      }
      return function(action) {
        return matchers.some(function(matcher) {
          return matches(matcher, action);
        });
      };
    }
    function isAllOf() {
      var matchers = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        matchers[_i] = arguments[_i];
      }
      return function(action) {
        return matchers.every(function(matcher) {
          return matches(matcher, action);
        });
      };
    }
    function hasExpectedRequestMetadata(action, validStatus) {
      if (!action || !action.meta)
        return false;
      var hasValidRequestId = typeof action.meta.requestId === "string";
      var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
      return hasValidRequestId && hasValidRequestStatus;
    }
    function isAsyncThunkArray(a2) {
      return typeof a2[0] === "function" && "pending" in a2[0] && "fulfilled" in a2[0] && "rejected" in a2[0];
    }
    function isPending() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      if (asyncThunks.length === 0) {
        return function(action) {
          return hasExpectedRequestMetadata(action, ["pending"]);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isPending()(asyncThunks[0]);
      }
      return function(action) {
        var matchers = asyncThunks.map(function(asyncThunk) {
          return asyncThunk.pending;
        });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
      };
    }
    function isRejected() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      if (asyncThunks.length === 0) {
        return function(action) {
          return hasExpectedRequestMetadata(action, ["rejected"]);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isRejected()(asyncThunks[0]);
      }
      return function(action) {
        var matchers = asyncThunks.map(function(asyncThunk) {
          return asyncThunk.rejected;
        });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
      };
    }
    function isRejectedWithValue() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      var hasFlag = function(action) {
        return action && action.meta && action.meta.rejectedWithValue;
      };
      if (asyncThunks.length === 0) {
        return function(action) {
          var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);
          return combinedMatcher(action);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isRejectedWithValue()(asyncThunks[0]);
      }
      return function(action) {
        var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);
        return combinedMatcher(action);
      };
    }
    function isFulfilled() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      if (asyncThunks.length === 0) {
        return function(action) {
          return hasExpectedRequestMetadata(action, ["fulfilled"]);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isFulfilled()(asyncThunks[0]);
      }
      return function(action) {
        var matchers = asyncThunks.map(function(asyncThunk) {
          return asyncThunk.fulfilled;
        });
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
      };
    }
    function isAsyncThunkAction() {
      var asyncThunks = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        asyncThunks[_i] = arguments[_i];
      }
      if (asyncThunks.length === 0) {
        return function(action) {
          return hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
        };
      }
      if (!isAsyncThunkArray(asyncThunks)) {
        return isAsyncThunkAction()(asyncThunks[0]);
      }
      return function(action) {
        var matchers = [];
        for (var _i2 = 0, asyncThunks_1 = asyncThunks; _i2 < asyncThunks_1.length; _i2++) {
          var asyncThunk = asyncThunks_1[_i2];
          matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);
        }
        var combinedMatcher = isAnyOf.apply(void 0, matchers);
        return combinedMatcher(action);
      };
    }
    var alm = "listenerMiddleware";
    createAction(alm + "/add");
    createAction(alm + "/removeAll");
    createAction(alm + "/remove");
    var SHOULD_AUTOBATCH = "RTK_autoBatch";
    var prepareAutoBatched = function() {
      return function(payload) {
        var _c;
        return {
          payload,
          meta: (_c = {}, _c[SHOULD_AUTOBATCH] = true, _c)
        };
      };
    };
    var promise$1;
    typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb2) {
      return (promise$1 || (promise$1 = Promise.resolve())).then(cb2).catch(function(err) {
        return setTimeout(function() {
          throw err;
        }, 0);
      });
    };
    F$2();
    var __generator = globalThis && globalThis.__generator || function(thisArg, body2) {
      var _2 = { label: 0, sent: function() {
        if (t2[0] & 1)
          throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f2, y2, t2, g2;
      return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
        return this;
      }), g2;
      function verb(n2) {
        return function(v2) {
          return step([n2, v2]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
              return t2;
            if (y2 = 0, t2)
              op = [op[0] & 2, t2.value];
            switch (op[0]) {
              case 0:
              case 1:
                t2 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y2 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t2[1]) {
                  _2.label = t2[1];
                  t2 = op;
                  break;
                }
                if (t2 && _2.label < t2[2]) {
                  _2.label = t2[2];
                  _2.ops.push(op);
                  break;
                }
                if (t2[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body2.call(thisArg, _2);
          } catch (e2) {
            op = [6, e2];
            y2 = 0;
          } finally {
            f2 = t2 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to2, from2) {
      for (var i2 = 0, il2 = from2.length, j2 = to2.length; i2 < il2; i2++, j2++)
        to2[j2] = from2[i2];
      return to2;
    };
    var __defProp$1 = Object.defineProperty;
    var __defProps$1 = Object.defineProperties;
    var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
    var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
    var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$1 = function(obj, key, value) {
      return key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    };
    var __spreadValues$1 = function(a2, b2) {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp$1.call(b2, prop))
          __defNormalProp$1(a2, prop, b2[prop]);
      if (__getOwnPropSymbols$1)
        for (var _j = 0, _k = __getOwnPropSymbols$1(b2); _j < _k.length; _j++) {
          var prop = _k[_j];
          if (__propIsEnum$1.call(b2, prop))
            __defNormalProp$1(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps$1 = function(a2, b2) {
      return __defProps$1(a2, __getOwnPropDescs$1(b2));
    };
    var __objRest = function(source, exclude) {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$1)
        for (var _j = 0, _k = __getOwnPropSymbols$1(source); _j < _k.length; _j++) {
          var prop = _k[_j];
          if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __async = function(__this, __arguments, generator) {
      return new Promise(function(resolve, reject) {
        var fulfilled = function(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var rejected = function(value) {
          try {
            step(generator.throw(value));
          } catch (e2) {
            reject(e2);
          }
        };
        var step = function(x2) {
          return x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
        };
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var QueryStatus;
    (function(QueryStatus2) {
      QueryStatus2["uninitialized"] = "uninitialized";
      QueryStatus2["pending"] = "pending";
      QueryStatus2["fulfilled"] = "fulfilled";
      QueryStatus2["rejected"] = "rejected";
    })(QueryStatus || (QueryStatus = {}));
    function getRequestStatusFlags(status) {
      return {
        status,
        isUninitialized: status === QueryStatus.uninitialized,
        isLoading: status === QueryStatus.pending,
        isSuccess: status === QueryStatus.fulfilled,
        isError: status === QueryStatus.rejected
      };
    }
    function isAbsoluteUrl(url) {
      return new RegExp("(^|:)//").test(url);
    }
    var withoutTrailingSlash = function(url) {
      return url.replace(/\/$/, "");
    };
    var withoutLeadingSlash = function(url) {
      return url.replace(/^\//, "");
    };
    function joinUrls(base, url) {
      if (!base) {
        return url;
      }
      if (!url) {
        return base;
      }
      if (isAbsoluteUrl(url)) {
        return url;
      }
      var delimiter2 = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
      base = withoutTrailingSlash(base);
      url = withoutLeadingSlash(url);
      return "" + base + delimiter2 + url;
    }
    var flatten = function(arr) {
      return [].concat.apply([], arr);
    };
    function isOnline() {
      return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
    }
    function isDocumentVisible() {
      if (typeof document === "undefined") {
        return true;
      }
      return document.visibilityState !== "hidden";
    }
    var isPlainObject$1 = isPlainObject$2;
    function copyWithStructuralSharing(oldObj, newObj) {
      if (oldObj === newObj || !(isPlainObject$1(oldObj) && isPlainObject$1(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
        return newObj;
      }
      var newKeys = Object.keys(newObj);
      var oldKeys = Object.keys(oldObj);
      var isSameObject = newKeys.length === oldKeys.length;
      var mergeObj = Array.isArray(newObj) ? [] : {};
      for (var _j = 0, newKeys_1 = newKeys; _j < newKeys_1.length; _j++) {
        var key = newKeys_1[_j];
        mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
        if (isSameObject)
          isSameObject = oldObj[key] === mergeObj[key];
      }
      return isSameObject ? oldObj : mergeObj;
    }
    var defaultFetchFn = function() {
      var args = [];
      for (var _j = 0; _j < arguments.length; _j++) {
        args[_j] = arguments[_j];
      }
      return fetch.apply(void 0, args);
    };
    var defaultValidateStatus = function(response) {
      return response.status >= 200 && response.status <= 299;
    };
    var defaultIsJsonContentType = function(headers) {
      return /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || "");
    };
    function stripUndefined(obj) {
      if (!isPlainObject$2(obj)) {
        return obj;
      }
      var copy2 = __spreadValues$1({}, obj);
      for (var _j = 0, _k = Object.entries(copy2); _j < _k.length; _j++) {
        var _l = _k[_j], k2 = _l[0], v2 = _l[1];
        if (v2 === void 0)
          delete copy2[k2];
      }
      return copy2;
    }
    function fetchBaseQuery(_a) {
      var _this = this;
      if (_a === void 0) {
        _a = {};
      }
      var _b = _a, baseUrl = _b.baseUrl, _j = _b.prepareHeaders, prepareHeaders = _j === void 0 ? function(x2) {
        return x2;
      } : _j, _k = _b.fetchFn, fetchFn = _k === void 0 ? defaultFetchFn : _k, paramsSerializer = _b.paramsSerializer, _l = _b.isJsonContentType, isJsonContentType = _l === void 0 ? defaultIsJsonContentType : _l, _m = _b.jsonContentType, jsonContentType = _m === void 0 ? "application/json" : _m, jsonReplacer = _b.jsonReplacer, defaultTimeout = _b.timeout, globalResponseHandler = _b.responseHandler, globalValidateStatus = _b.validateStatus, baseFetchOptions = __objRest(_b, [
        "baseUrl",
        "prepareHeaders",
        "fetchFn",
        "paramsSerializer",
        "isJsonContentType",
        "jsonContentType",
        "jsonReplacer",
        "timeout",
        "responseHandler",
        "validateStatus"
      ]);
      if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
        console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
      }
      return function(arg, api2) {
        return __async(_this, null, function() {
          var signal, getState, extra, endpoint, forced, type, meta, _a2, url, _j2, headers, _k2, params, _l2, responseHandler, _m2, validateStatus, _o2, timeout, rest, config2, _p, isJsonifiable, divider, query, request, requestClone, response, timedOut, timeoutId, e_1, responseClone, resultData, responseText, handleResponseError_1, e_2;
          return __generator(this, function(_q) {
            switch (_q.label) {
              case 0:
                signal = api2.signal, getState = api2.getState, extra = api2.extra, endpoint = api2.endpoint, forced = api2.forced, type = api2.type;
                _a2 = typeof arg == "string" ? { url: arg } : arg, url = _a2.url, _j2 = _a2.headers, headers = _j2 === void 0 ? new Headers(baseFetchOptions.headers) : _j2, _k2 = _a2.params, params = _k2 === void 0 ? void 0 : _k2, _l2 = _a2.responseHandler, responseHandler = _l2 === void 0 ? globalResponseHandler != null ? globalResponseHandler : "json" : _l2, _m2 = _a2.validateStatus, validateStatus = _m2 === void 0 ? globalValidateStatus != null ? globalValidateStatus : defaultValidateStatus : _m2, _o2 = _a2.timeout, timeout = _o2 === void 0 ? defaultTimeout : _o2, rest = __objRest(_a2, [
                  "url",
                  "headers",
                  "params",
                  "responseHandler",
                  "validateStatus",
                  "timeout"
                ]);
                config2 = __spreadValues$1(__spreadProps$1(__spreadValues$1({}, baseFetchOptions), {
                  signal
                }), rest);
                headers = new Headers(stripUndefined(headers));
                _p = config2;
                return [4, prepareHeaders(headers, {
                  getState,
                  extra,
                  endpoint,
                  forced,
                  type
                })];
              case 1:
                _p.headers = _q.sent() || headers;
                isJsonifiable = function(body2) {
                  return typeof body2 === "object" && (isPlainObject$2(body2) || Array.isArray(body2) || typeof body2.toJSON === "function");
                };
                if (!config2.headers.has("content-type") && isJsonifiable(config2.body)) {
                  config2.headers.set("content-type", jsonContentType);
                }
                if (isJsonifiable(config2.body) && isJsonContentType(config2.headers)) {
                  config2.body = JSON.stringify(config2.body, jsonReplacer);
                }
                if (params) {
                  divider = ~url.indexOf("?") ? "&" : "?";
                  query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
                  url += divider + query;
                }
                url = joinUrls(baseUrl, url);
                request = new Request(url, config2);
                requestClone = new Request(url, config2);
                meta = { request: requestClone };
                timedOut = false, timeoutId = timeout && setTimeout(function() {
                  timedOut = true;
                  api2.abort();
                }, timeout);
                _q.label = 2;
              case 2:
                _q.trys.push([2, 4, 5, 6]);
                return [4, fetchFn(request)];
              case 3:
                response = _q.sent();
                return [3, 6];
              case 4:
                e_1 = _q.sent();
                return [2, {
                  error: {
                    status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
                    error: String(e_1)
                  },
                  meta
                }];
              case 5:
                if (timeoutId)
                  clearTimeout(timeoutId);
                return [
                  7
                  /*endfinally*/
                ];
              case 6:
                responseClone = response.clone();
                meta.response = responseClone;
                responseText = "";
                _q.label = 7;
              case 7:
                _q.trys.push([7, 9, , 10]);
                return [4, Promise.all([
                  handleResponse(response, responseHandler).then(function(r2) {
                    return resultData = r2;
                  }, function(e2) {
                    return handleResponseError_1 = e2;
                  }),
                  responseClone.text().then(function(r2) {
                    return responseText = r2;
                  }, function() {
                  })
                ])];
              case 8:
                _q.sent();
                if (handleResponseError_1)
                  throw handleResponseError_1;
                return [3, 10];
              case 9:
                e_2 = _q.sent();
                return [2, {
                  error: {
                    status: "PARSING_ERROR",
                    originalStatus: response.status,
                    data: responseText,
                    error: String(e_2)
                  },
                  meta
                }];
              case 10:
                return [2, validateStatus(response, resultData) ? {
                  data: resultData,
                  meta
                } : {
                  error: {
                    status: response.status,
                    data: resultData
                  },
                  meta
                }];
            }
          });
        });
      };
      function handleResponse(response, responseHandler) {
        return __async(this, null, function() {
          var text;
          return __generator(this, function(_j2) {
            switch (_j2.label) {
              case 0:
                if (typeof responseHandler === "function") {
                  return [2, responseHandler(response)];
                }
                if (responseHandler === "content-type") {
                  responseHandler = isJsonContentType(response.headers) ? "json" : "text";
                }
                if (!(responseHandler === "json"))
                  return [3, 2];
                return [4, response.text()];
              case 1:
                text = _j2.sent();
                return [2, text.length ? JSON.parse(text) : null];
              case 2:
                return [2, response.text()];
            }
          });
        });
      }
    }
    var HandledError = (
      /** @class */
      function() {
        function HandledError2(value, meta) {
          if (meta === void 0) {
            meta = void 0;
          }
          this.value = value;
          this.meta = meta;
        }
        return HandledError2;
      }()
    );
    var onFocus = /* @__PURE__ */ createAction("__rtkq/focused");
    var onFocusLost = /* @__PURE__ */ createAction("__rtkq/unfocused");
    var onOnline = /* @__PURE__ */ createAction("__rtkq/online");
    var onOffline = /* @__PURE__ */ createAction("__rtkq/offline");
    var DefinitionType$1;
    (function(DefinitionType2) {
      DefinitionType2["query"] = "query";
      DefinitionType2["mutation"] = "mutation";
    })(DefinitionType$1 || (DefinitionType$1 = {}));
    function isQueryDefinition$1(e2) {
      return e2.type === DefinitionType$1.query;
    }
    function isMutationDefinition$1(e2) {
      return e2.type === DefinitionType$1.mutation;
    }
    function calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {
      if (isFunction(description)) {
        return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);
      }
      if (Array.isArray(description)) {
        return description.map(expandTagDescription).map(assertTagTypes);
      }
      return [];
    }
    function isFunction(t2) {
      return typeof t2 === "function";
    }
    function expandTagDescription(description) {
      return typeof description === "string" ? { type: description } : description;
    }
    function isNotNullish(v2) {
      return v2 != null;
    }
    var forceQueryFnSymbol = Symbol("forceQueryFn");
    var isUpsertQuery = function(arg) {
      return typeof arg[forceQueryFnSymbol] === "function";
    };
    function buildInitiate(_j) {
      var serializeQueryArgs = _j.serializeQueryArgs, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, api2 = _j.api, context = _j.context;
      var runningQueries = /* @__PURE__ */ new Map();
      var runningMutations = /* @__PURE__ */ new Map();
      var _k = api2.internalActions, unsubscribeQueryResult = _k.unsubscribeQueryResult, removeMutationResult = _k.removeMutationResult, updateSubscriptionOptions = _k.updateSubscriptionOptions;
      return {
        buildInitiateQuery,
        buildInitiateMutation,
        getRunningQueryThunk,
        getRunningMutationThunk,
        getRunningQueriesThunk,
        getRunningMutationsThunk,
        getRunningOperationPromises,
        removalWarning
      };
      function removalWarning() {
        throw new Error("This method had to be removed due to a conceptual bug in RTK.\n       Please see https://github.com/reduxjs/redux-toolkit/pull/2481 for details.\n       See https://redux-toolkit.js.org/rtk-query/usage/server-side-rendering for new guidance on SSR.");
      }
      function getRunningOperationPromises() {
        if (typeof process !== "undefined" && false) {
          removalWarning();
        } else {
          var extract = function(v2) {
            return Array.from(v2.values()).flatMap(function(queriesForStore) {
              return queriesForStore ? Object.values(queriesForStore) : [];
            });
          };
          return __spreadArray$1(__spreadArray$1([], extract(runningQueries)), extract(runningMutations)).filter(isNotNullish);
        }
      }
      function getRunningQueryThunk(endpointName, queryArgs) {
        return function(dispatch) {
          var _a;
          var endpointDefinition = context.endpointDefinitions[endpointName];
          var queryCacheKey = serializeQueryArgs({
            queryArgs,
            endpointDefinition,
            endpointName
          });
          return (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
        };
      }
      function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
        return function(dispatch) {
          var _a;
          return (_a = runningMutations.get(dispatch)) == null ? void 0 : _a[fixedCacheKeyOrRequestId];
        };
      }
      function getRunningQueriesThunk() {
        return function(dispatch) {
          return Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
        };
      }
      function getRunningMutationsThunk() {
        return function(dispatch) {
          return Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
        };
      }
      function buildInitiateQuery(endpointName, endpointDefinition) {
        var queryAction = function(arg, _j2) {
          var _k2 = _j2 === void 0 ? {} : _j2, _l = _k2.subscribe, subscribe = _l === void 0 ? true : _l, forceRefetch = _k2.forceRefetch, subscriptionOptions = _k2.subscriptionOptions, _m = forceQueryFnSymbol, forceQueryFn = _k2[_m];
          return function(dispatch, getState) {
            var _j3;
            var _a;
            var queryCacheKey = serializeQueryArgs({
              queryArgs: arg,
              endpointDefinition,
              endpointName
            });
            var thunk2 = queryThunk((_j3 = {
              type: "query",
              subscribe,
              forceRefetch,
              subscriptionOptions,
              endpointName,
              originalArgs: arg,
              queryCacheKey
            }, _j3[forceQueryFnSymbol] = forceQueryFn, _j3));
            var selector = api2.endpoints[endpointName].select(arg);
            var thunkResult = dispatch(thunk2);
            var stateAfter = selector(getState());
            var requestId = thunkResult.requestId, abort = thunkResult.abort;
            var skippedSynchronously = stateAfter.requestId !== requestId;
            var runningQuery = (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
            var selectFromState = function() {
              return selector(getState());
            };
            var statePromise = Object.assign(forceQueryFn ? thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ? Promise.resolve(stateAfter) : Promise.all([runningQuery, thunkResult]).then(selectFromState), {
              arg,
              requestId,
              subscriptionOptions,
              queryCacheKey,
              abort,
              unwrap: function() {
                return __async(this, null, function() {
                  var result;
                  return __generator(this, function(_j4) {
                    switch (_j4.label) {
                      case 0:
                        return [4, statePromise];
                      case 1:
                        result = _j4.sent();
                        if (result.isError) {
                          throw result.error;
                        }
                        return [2, result.data];
                    }
                  });
                });
              },
              refetch: function() {
                return dispatch(queryAction(arg, { subscribe: false, forceRefetch: true }));
              },
              unsubscribe: function() {
                if (subscribe)
                  dispatch(unsubscribeQueryResult({
                    queryCacheKey,
                    requestId
                  }));
              },
              updateSubscriptionOptions: function(options) {
                statePromise.subscriptionOptions = options;
                dispatch(updateSubscriptionOptions({
                  endpointName,
                  requestId,
                  queryCacheKey,
                  options
                }));
              }
            });
            if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
              var running_1 = runningQueries.get(dispatch) || {};
              running_1[queryCacheKey] = statePromise;
              runningQueries.set(dispatch, running_1);
              statePromise.then(function() {
                delete running_1[queryCacheKey];
                if (!Object.keys(running_1).length) {
                  runningQueries.delete(dispatch);
                }
              });
            }
            return statePromise;
          };
        };
        return queryAction;
      }
      function buildInitiateMutation(endpointName) {
        return function(arg, _j2) {
          var _k2 = _j2 === void 0 ? {} : _j2, _l = _k2.track, track = _l === void 0 ? true : _l, fixedCacheKey = _k2.fixedCacheKey;
          return function(dispatch, getState) {
            var thunk2 = mutationThunk({
              type: "mutation",
              endpointName,
              originalArgs: arg,
              track,
              fixedCacheKey
            });
            var thunkResult = dispatch(thunk2);
            var requestId = thunkResult.requestId, abort = thunkResult.abort, unwrap = thunkResult.unwrap;
            var returnValuePromise = thunkResult.unwrap().then(function(data) {
              return { data };
            }).catch(function(error) {
              return { error };
            });
            var reset = function() {
              dispatch(removeMutationResult({ requestId, fixedCacheKey }));
            };
            var ret = Object.assign(returnValuePromise, {
              arg: thunkResult.arg,
              requestId,
              abort,
              unwrap,
              unsubscribe: reset,
              reset
            });
            var running = runningMutations.get(dispatch) || {};
            runningMutations.set(dispatch, running);
            running[requestId] = ret;
            ret.then(function() {
              delete running[requestId];
              if (!Object.keys(running).length) {
                runningMutations.delete(dispatch);
              }
            });
            if (fixedCacheKey) {
              running[fixedCacheKey] = ret;
              ret.then(function() {
                if (running[fixedCacheKey] === ret) {
                  delete running[fixedCacheKey];
                  if (!Object.keys(running).length) {
                    runningMutations.delete(dispatch);
                  }
                }
              });
            }
            return ret;
          };
        };
      }
    }
    function defaultTransformResponse(baseQueryReturnValue) {
      return baseQueryReturnValue;
    }
    function buildThunks(_j) {
      var _this = this;
      var reducerPath = _j.reducerPath, baseQuery = _j.baseQuery, endpointDefinitions = _j.context.endpointDefinitions, serializeQueryArgs = _j.serializeQueryArgs, api2 = _j.api, assertTagType = _j.assertTagType;
      var patchQueryData = function(endpointName, args, patches, updateProvided) {
        return function(dispatch, getState) {
          var endpointDefinition = endpointDefinitions[endpointName];
          var queryCacheKey = serializeQueryArgs({
            queryArgs: args,
            endpointDefinition,
            endpointName
          });
          dispatch(api2.internalActions.queryResultPatched({ queryCacheKey, patches }));
          if (!updateProvided) {
            return;
          }
          var newValue = api2.endpoints[endpointName].select(args)(getState());
          var providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, args, {}, assertTagType);
          dispatch(api2.internalActions.updateProvidedBy({ queryCacheKey, providedTags }));
        };
      };
      var updateQueryData = function(endpointName, args, updateRecipe, updateProvided) {
        if (updateProvided === void 0) {
          updateProvided = true;
        }
        return function(dispatch, getState) {
          var _j2, _k;
          var endpointDefinition = api2.endpoints[endpointName];
          var currentState = endpointDefinition.select(args)(getState());
          var ret = {
            patches: [],
            inversePatches: [],
            undo: function() {
              return dispatch(api2.util.patchQueryData(endpointName, args, ret.inversePatches, updateProvided));
            }
          };
          if (currentState.status === QueryStatus.uninitialized) {
            return ret;
          }
          var newValue;
          if ("data" in currentState) {
            if (t(currentState.data)) {
              var _l = cn(currentState.data, updateRecipe), value = _l[0], patches = _l[1], inversePatches = _l[2];
              (_j2 = ret.patches).push.apply(_j2, patches);
              (_k = ret.inversePatches).push.apply(_k, inversePatches);
              newValue = value;
            } else {
              newValue = updateRecipe(currentState.data);
              ret.patches.push({ op: "replace", path: [], value: newValue });
              ret.inversePatches.push({
                op: "replace",
                path: [],
                value: currentState.data
              });
            }
          }
          dispatch(api2.util.patchQueryData(endpointName, args, ret.patches, updateProvided));
          return ret;
        };
      };
      var upsertQueryData = function(endpointName, args, value) {
        return function(dispatch) {
          var _j2;
          return dispatch(api2.endpoints[endpointName].initiate(args, (_j2 = {
            subscribe: false,
            forceRefetch: true
          }, _j2[forceQueryFnSymbol] = function() {
            return {
              data: value
            };
          }, _j2)));
        };
      };
      var executeEndpoint = function(_0, _1) {
        return __async(_this, [_0, _1], function(arg, _j2) {
          var endpointDefinition, transformResponse, result, baseQueryApi_1, forceQueryFn, what, err, _k, _l, key, _m, error_1, catchedError, transformErrorResponse, _o2, e_4;
          var _p, _q;
          var signal = _j2.signal, abort = _j2.abort, rejectWithValue = _j2.rejectWithValue, fulfillWithValue = _j2.fulfillWithValue, dispatch = _j2.dispatch, getState = _j2.getState, extra = _j2.extra;
          return __generator(this, function(_r) {
            switch (_r.label) {
              case 0:
                endpointDefinition = endpointDefinitions[arg.endpointName];
                _r.label = 1;
              case 1:
                _r.trys.push([1, 8, , 13]);
                transformResponse = defaultTransformResponse;
                result = void 0;
                baseQueryApi_1 = {
                  signal,
                  abort,
                  dispatch,
                  getState,
                  extra,
                  endpoint: arg.endpointName,
                  type: arg.type,
                  forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0
                };
                forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
                if (!forceQueryFn)
                  return [3, 2];
                result = forceQueryFn();
                return [3, 6];
              case 2:
                if (!endpointDefinition.query)
                  return [3, 4];
                return [4, baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi_1, endpointDefinition.extraOptions)];
              case 3:
                result = _r.sent();
                if (endpointDefinition.transformResponse) {
                  transformResponse = endpointDefinition.transformResponse;
                }
                return [3, 6];
              case 4:
                return [4, endpointDefinition.queryFn(arg.originalArgs, baseQueryApi_1, endpointDefinition.extraOptions, function(arg2) {
                  return baseQuery(arg2, baseQueryApi_1, endpointDefinition.extraOptions);
                })];
              case 5:
                result = _r.sent();
                _r.label = 6;
              case 6:
                if (typeof process !== "undefined" && false) {
                  what = endpointDefinition.query ? "`baseQuery`" : "`queryFn`";
                  err = void 0;
                  if (!result) {
                    err = what + " did not return anything.";
                  } else if (typeof result !== "object") {
                    err = what + " did not return an object.";
                  } else if (result.error && result.data) {
                    err = what + " returned an object containing both `error` and `result`.";
                  } else if (result.error === void 0 && result.data === void 0) {
                    err = what + " returned an object containing neither a valid `error` and `result`. At least one of them should not be `undefined`";
                  } else {
                    for (_k = 0, _l = Object.keys(result); _k < _l.length; _k++) {
                      key = _l[_k];
                      if (key !== "error" && key !== "data" && key !== "meta") {
                        err = "The object returned by " + what + " has the unknown property " + key + ".";
                        break;
                      }
                    }
                  }
                  if (err) {
                    console.error("Error encountered handling the endpoint " + arg.endpointName + ".\n              " + err + "\n              It needs to return an object with either the shape `{ data: <value> }` or `{ error: <value> }` that may contain an optional `meta` property.\n              Object returned was:", result);
                  }
                }
                if (result.error)
                  throw new HandledError(result.error, result.meta);
                _m = fulfillWithValue;
                return [4, transformResponse(result.data, result.meta, arg.originalArgs)];
              case 7:
                return [2, _m.apply(void 0, [_r.sent(), (_p = {
                  fulfilledTimeStamp: Date.now(),
                  baseQueryMeta: result.meta
                }, _p[SHOULD_AUTOBATCH] = true, _p)])];
              case 8:
                error_1 = _r.sent();
                catchedError = error_1;
                if (!(catchedError instanceof HandledError))
                  return [3, 12];
                transformErrorResponse = defaultTransformResponse;
                if (endpointDefinition.query && endpointDefinition.transformErrorResponse) {
                  transformErrorResponse = endpointDefinition.transformErrorResponse;
                }
                _r.label = 9;
              case 9:
                _r.trys.push([9, 11, , 12]);
                _o2 = rejectWithValue;
                return [4, transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs)];
              case 10:
                return [2, _o2.apply(void 0, [_r.sent(), (_q = { baseQueryMeta: catchedError.meta }, _q[SHOULD_AUTOBATCH] = true, _q)])];
              case 11:
                e_4 = _r.sent();
                catchedError = e_4;
                return [3, 12];
              case 12:
                if (typeof process !== "undefined" && false) {
                  console.error('An unhandled error occurred processing a request for the endpoint "' + arg.endpointName + '".\nIn the case of an unhandled error, no tags will be "provided" or "invalidated".', catchedError);
                } else {
                  console.error(catchedError);
                }
                throw catchedError;
              case 13:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      function isForcedQuery(arg, state) {
        var _a, _b, _c, _d;
        var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[arg.queryCacheKey];
        var baseFetchOnMountOrArgChange = (_c = state[reducerPath]) == null ? void 0 : _c.config.refetchOnMountOrArgChange;
        var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
        var refetchVal = (_d = arg.forceRefetch) != null ? _d : arg.subscribe && baseFetchOnMountOrArgChange;
        if (refetchVal) {
          return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
        }
        return false;
      }
      var queryThunk = createAsyncThunk(reducerPath + "/executeQuery", executeEndpoint, {
        getPendingMeta: function() {
          var _j2;
          return _j2 = { startedTimeStamp: Date.now() }, _j2[SHOULD_AUTOBATCH] = true, _j2;
        },
        condition: function(queryThunkArgs, _j2) {
          var getState = _j2.getState;
          var _a, _b, _c;
          var state = getState();
          var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[queryThunkArgs.queryCacheKey];
          var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
          var currentArg = queryThunkArgs.originalArgs;
          var previousArg = requestState == null ? void 0 : requestState.originalArgs;
          var endpointDefinition = endpointDefinitions[queryThunkArgs.endpointName];
          if (isUpsertQuery(queryThunkArgs)) {
            return true;
          }
          if ((requestState == null ? void 0 : requestState.status) === "pending") {
            return false;
          }
          if (isForcedQuery(queryThunkArgs, state)) {
            return true;
          }
          if (isQueryDefinition$1(endpointDefinition) && ((_c = endpointDefinition == null ? void 0 : endpointDefinition.forceRefetch) == null ? void 0 : _c.call(endpointDefinition, {
            currentArg,
            previousArg,
            endpointState: requestState,
            state
          }))) {
            return true;
          }
          if (fulfilledVal) {
            return false;
          }
          return true;
        },
        dispatchConditionRejection: true
      });
      var mutationThunk = createAsyncThunk(reducerPath + "/executeMutation", executeEndpoint, {
        getPendingMeta: function() {
          var _j2;
          return _j2 = { startedTimeStamp: Date.now() }, _j2[SHOULD_AUTOBATCH] = true, _j2;
        }
      });
      var hasTheForce = function(options) {
        return "force" in options;
      };
      var hasMaxAge = function(options) {
        return "ifOlderThan" in options;
      };
      var prefetch = function(endpointName, arg, options) {
        return function(dispatch, getState) {
          var force = hasTheForce(options) && options.force;
          var maxAge = hasMaxAge(options) && options.ifOlderThan;
          var queryAction = function(force2) {
            if (force2 === void 0) {
              force2 = true;
            }
            return api2.endpoints[endpointName].initiate(arg, { forceRefetch: force2 });
          };
          var latestStateValue = api2.endpoints[endpointName].select(arg)(getState());
          if (force) {
            dispatch(queryAction());
          } else if (maxAge) {
            var lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;
            if (!lastFulfilledTs) {
              dispatch(queryAction());
              return;
            }
            var shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
            if (shouldRetrigger) {
              dispatch(queryAction());
            }
          } else {
            dispatch(queryAction(false));
          }
        };
      };
      function matchesEndpoint(endpointName) {
        return function(action) {
          var _a, _b;
          return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;
        };
      }
      function buildMatchThunkActions(thunk2, endpointName) {
        return {
          matchPending: isAllOf(isPending(thunk2), matchesEndpoint(endpointName)),
          matchFulfilled: isAllOf(isFulfilled(thunk2), matchesEndpoint(endpointName)),
          matchRejected: isAllOf(isRejected(thunk2), matchesEndpoint(endpointName))
        };
      }
      return {
        queryThunk,
        mutationThunk,
        prefetch,
        updateQueryData,
        upsertQueryData,
        patchQueryData,
        buildMatchThunkActions
      };
    }
    function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
      return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
    }
    function updateQuerySubstateIfExists(state, queryCacheKey, update2) {
      var substate = state[queryCacheKey];
      if (substate) {
        update2(substate);
      }
    }
    function getMutationCacheKey(id2) {
      var _a;
      return (_a = "arg" in id2 ? id2.arg.fixedCacheKey : id2.fixedCacheKey) != null ? _a : id2.requestId;
    }
    function updateMutationSubstateIfExists(state, id2, update2) {
      var substate = state[getMutationCacheKey(id2)];
      if (substate) {
        update2(substate);
      }
    }
    var initialState$1 = {};
    function buildSlice(_j) {
      var reducerPath = _j.reducerPath, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, _k = _j.context, definitions = _k.endpointDefinitions, apiUid = _k.apiUid, extractRehydrationInfo = _k.extractRehydrationInfo, hasRehydrationInfo = _k.hasRehydrationInfo, assertTagType = _j.assertTagType, config2 = _j.config;
      var resetApiState = createAction(reducerPath + "/resetApiState");
      var querySlice = createSlice({
        name: reducerPath + "/queries",
        initialState: initialState$1,
        reducers: {
          removeQueryResult: {
            reducer: function(draft, _j2) {
              var queryCacheKey = _j2.payload.queryCacheKey;
              delete draft[queryCacheKey];
            },
            prepare: prepareAutoBatched()
          },
          queryResultPatched: {
            reducer: function(draft, _j2) {
              var _k2 = _j2.payload, queryCacheKey = _k2.queryCacheKey, patches = _k2.patches;
              updateQuerySubstateIfExists(draft, queryCacheKey, function(substate) {
                substate.data = pn(substate.data, patches.concat());
              });
            },
            prepare: prepareAutoBatched()
          }
        },
        extraReducers: function(builder) {
          builder.addCase(queryThunk.pending, function(draft, _j2) {
            var meta = _j2.meta, arg = _j2.meta.arg;
            var _a, _b;
            var upserting = isUpsertQuery(arg);
            if (arg.subscribe || upserting) {
              (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {
                status: QueryStatus.uninitialized,
                endpointName: arg.endpointName
              };
            }
            updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {
              substate.status = QueryStatus.pending;
              substate.requestId = upserting && substate.requestId ? substate.requestId : meta.requestId;
              if (arg.originalArgs !== void 0) {
                substate.originalArgs = arg.originalArgs;
              }
              substate.startedTimeStamp = meta.startedTimeStamp;
            });
          }).addCase(queryThunk.fulfilled, function(draft, _j2) {
            var meta = _j2.meta, payload = _j2.payload;
            updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, function(substate) {
              var _a;
              if (substate.requestId !== meta.requestId && !isUpsertQuery(meta.arg))
                return;
              var merge2 = definitions[meta.arg.endpointName].merge;
              substate.status = QueryStatus.fulfilled;
              if (merge2) {
                if (substate.data !== void 0) {
                  var fulfilledTimeStamp_1 = meta.fulfilledTimeStamp, arg_1 = meta.arg, baseQueryMeta_1 = meta.baseQueryMeta, requestId_1 = meta.requestId;
                  var newData = fn(substate.data, function(draftSubstateData) {
                    return merge2(draftSubstateData, payload, {
                      arg: arg_1.originalArgs,
                      baseQueryMeta: baseQueryMeta_1,
                      fulfilledTimeStamp: fulfilledTimeStamp_1,
                      requestId: requestId_1
                    });
                  });
                  substate.data = newData;
                } else {
                  substate.data = payload;
                }
              } else {
                substate.data = ((_a = definitions[meta.arg.endpointName].structuralSharing) != null ? _a : true) ? copyWithStructuralSharing(r$1(substate.data) ? e(substate.data) : substate.data, payload) : payload;
              }
              delete substate.error;
              substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
            });
          }).addCase(queryThunk.rejected, function(draft, _j2) {
            var _k2 = _j2.meta, condition = _k2.condition, arg = _k2.arg, requestId = _k2.requestId, error = _j2.error, payload = _j2.payload;
            updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {
              if (condition)
                ;
              else {
                if (substate.requestId !== requestId)
                  return;
                substate.status = QueryStatus.rejected;
                substate.error = payload != null ? payload : error;
              }
            });
          }).addMatcher(hasRehydrationInfo, function(draft, action) {
            var queries = extractRehydrationInfo(action).queries;
            for (var _j2 = 0, _k2 = Object.entries(queries); _j2 < _k2.length; _j2++) {
              var _l = _k2[_j2], key = _l[0], entry = _l[1];
              if ((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) {
                draft[key] = entry;
              }
            }
          });
        }
      });
      var mutationSlice = createSlice({
        name: reducerPath + "/mutations",
        initialState: initialState$1,
        reducers: {
          removeMutationResult: {
            reducer: function(draft, _j2) {
              var payload = _j2.payload;
              var cacheKey = getMutationCacheKey(payload);
              if (cacheKey in draft) {
                delete draft[cacheKey];
              }
            },
            prepare: prepareAutoBatched()
          }
        },
        extraReducers: function(builder) {
          builder.addCase(mutationThunk.pending, function(draft, _j2) {
            var meta = _j2.meta, _k2 = _j2.meta, requestId = _k2.requestId, arg = _k2.arg, startedTimeStamp = _k2.startedTimeStamp;
            if (!arg.track)
              return;
            draft[getMutationCacheKey(meta)] = {
              requestId,
              status: QueryStatus.pending,
              endpointName: arg.endpointName,
              startedTimeStamp
            };
          }).addCase(mutationThunk.fulfilled, function(draft, _j2) {
            var payload = _j2.payload, meta = _j2.meta;
            if (!meta.arg.track)
              return;
            updateMutationSubstateIfExists(draft, meta, function(substate) {
              if (substate.requestId !== meta.requestId)
                return;
              substate.status = QueryStatus.fulfilled;
              substate.data = payload;
              substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
            });
          }).addCase(mutationThunk.rejected, function(draft, _j2) {
            var payload = _j2.payload, error = _j2.error, meta = _j2.meta;
            if (!meta.arg.track)
              return;
            updateMutationSubstateIfExists(draft, meta, function(substate) {
              if (substate.requestId !== meta.requestId)
                return;
              substate.status = QueryStatus.rejected;
              substate.error = payload != null ? payload : error;
            });
          }).addMatcher(hasRehydrationInfo, function(draft, action) {
            var mutations = extractRehydrationInfo(action).mutations;
            for (var _j2 = 0, _k2 = Object.entries(mutations); _j2 < _k2.length; _j2++) {
              var _l = _k2[_j2], key = _l[0], entry = _l[1];
              if (((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) && key !== (entry == null ? void 0 : entry.requestId)) {
                draft[key] = entry;
              }
            }
          });
        }
      });
      var invalidationSlice = createSlice({
        name: reducerPath + "/invalidation",
        initialState: initialState$1,
        reducers: {
          updateProvidedBy: {
            reducer: function(draft, action) {
              var _a, _b, _c, _d;
              var _j2 = action.payload, queryCacheKey = _j2.queryCacheKey, providedTags = _j2.providedTags;
              for (var _k2 = 0, _l = Object.values(draft); _k2 < _l.length; _k2++) {
                var tagTypeSubscriptions = _l[_k2];
                for (var _m = 0, _o2 = Object.values(tagTypeSubscriptions); _m < _o2.length; _m++) {
                  var idSubscriptions = _o2[_m];
                  var foundAt = idSubscriptions.indexOf(queryCacheKey);
                  if (foundAt !== -1) {
                    idSubscriptions.splice(foundAt, 1);
                  }
                }
              }
              for (var _p = 0, providedTags_1 = providedTags; _p < providedTags_1.length; _p++) {
                var _q = providedTags_1[_p], type = _q.type, id2 = _q.id;
                var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id2 || "__internal_without_id"]) != null ? _d : _b[_c] = [];
                var alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                if (!alreadySubscribed) {
                  subscribedQueries.push(queryCacheKey);
                }
              }
            },
            prepare: prepareAutoBatched()
          }
        },
        extraReducers: function(builder) {
          builder.addCase(querySlice.actions.removeQueryResult, function(draft, _j2) {
            var queryCacheKey = _j2.payload.queryCacheKey;
            for (var _k2 = 0, _l = Object.values(draft); _k2 < _l.length; _k2++) {
              var tagTypeSubscriptions = _l[_k2];
              for (var _m = 0, _o2 = Object.values(tagTypeSubscriptions); _m < _o2.length; _m++) {
                var idSubscriptions = _o2[_m];
                var foundAt = idSubscriptions.indexOf(queryCacheKey);
                if (foundAt !== -1) {
                  idSubscriptions.splice(foundAt, 1);
                }
              }
            }
          }).addMatcher(hasRehydrationInfo, function(draft, action) {
            var _a, _b, _c, _d;
            var provided = extractRehydrationInfo(action).provided;
            for (var _j2 = 0, _k2 = Object.entries(provided); _j2 < _k2.length; _j2++) {
              var _l = _k2[_j2], type = _l[0], incomingTags = _l[1];
              for (var _m = 0, _o2 = Object.entries(incomingTags); _m < _o2.length; _m++) {
                var _p = _o2[_m], id2 = _p[0], cacheKeys = _p[1];
                var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id2 || "__internal_without_id"]) != null ? _d : _b[_c] = [];
                for (var _q = 0, cacheKeys_1 = cacheKeys; _q < cacheKeys_1.length; _q++) {
                  var queryCacheKey = cacheKeys_1[_q];
                  var alreadySubscribed = subscribedQueries.includes(queryCacheKey);
                  if (!alreadySubscribed) {
                    subscribedQueries.push(queryCacheKey);
                  }
                }
              }
            }
          }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), function(draft, action) {
            var providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
            var queryCacheKey = action.meta.arg.queryCacheKey;
            invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({
              queryCacheKey,
              providedTags
            }));
          });
        }
      });
      var subscriptionSlice = createSlice({
        name: reducerPath + "/subscriptions",
        initialState: initialState$1,
        reducers: {
          updateSubscriptionOptions: function(d2, a2) {
          },
          unsubscribeQueryResult: function(d2, a2) {
          },
          internal_probeSubscription: function(d2, a2) {
          }
        }
      });
      var internalSubscriptionsSlice = createSlice({
        name: reducerPath + "/internalSubscriptions",
        initialState: initialState$1,
        reducers: {
          subscriptionsUpdated: {
            reducer: function(state, action) {
              return pn(state, action.payload);
            },
            prepare: prepareAutoBatched()
          }
        }
      });
      var configSlice = createSlice({
        name: reducerPath + "/config",
        initialState: __spreadValues$1({
          online: isOnline(),
          focused: isDocumentVisible(),
          middlewareRegistered: false
        }, config2),
        reducers: {
          middlewareRegistered: function(state, _j2) {
            var payload = _j2.payload;
            state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
          }
        },
        extraReducers: function(builder) {
          builder.addCase(onOnline, function(state) {
            state.online = true;
          }).addCase(onOffline, function(state) {
            state.online = false;
          }).addCase(onFocus, function(state) {
            state.focused = true;
          }).addCase(onFocusLost, function(state) {
            state.focused = false;
          }).addMatcher(hasRehydrationInfo, function(draft) {
            return __spreadValues$1({}, draft);
          });
        }
      });
      var combinedReducer = combineReducers({
        queries: querySlice.reducer,
        mutations: mutationSlice.reducer,
        provided: invalidationSlice.reducer,
        subscriptions: internalSubscriptionsSlice.reducer,
        config: configSlice.reducer
      });
      var reducer2 = function(state, action) {
        return combinedReducer(resetApiState.match(action) ? void 0 : state, action);
      };
      var actions2 = __spreadProps$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1({}, configSlice.actions), querySlice.actions), subscriptionSlice.actions), internalSubscriptionsSlice.actions), mutationSlice.actions), invalidationSlice.actions), {
        unsubscribeMutationResult: mutationSlice.actions.removeMutationResult,
        resetApiState
      });
      return { reducer: reducer2, actions: actions2 };
    }
    var skipToken = /* @__PURE__ */ Symbol.for("RTKQ/skipToken");
    var initialSubState = {
      status: QueryStatus.uninitialized
    };
    var defaultQuerySubState = /* @__PURE__ */ fn(initialSubState, function() {
    });
    var defaultMutationSubState = /* @__PURE__ */ fn(initialSubState, function() {
    });
    function buildSelectors(_j) {
      var serializeQueryArgs = _j.serializeQueryArgs, reducerPath = _j.reducerPath;
      var selectSkippedQuery = function(state) {
        return defaultQuerySubState;
      };
      var selectSkippedMutation = function(state) {
        return defaultMutationSubState;
      };
      return { buildQuerySelector, buildMutationSelector, selectInvalidatedBy };
      function withRequestFlags(substate) {
        return __spreadValues$1(__spreadValues$1({}, substate), getRequestStatusFlags(substate.status));
      }
      function selectInternalState(rootState) {
        var state = rootState[reducerPath];
        return state;
      }
      function buildQuerySelector(endpointName, endpointDefinition) {
        return function(queryArgs) {
          var serializedArgs = serializeQueryArgs({
            queryArgs,
            endpointDefinition,
            endpointName
          });
          var selectQuerySubstate = function(state) {
            var _a, _b, _c;
            return (_c = (_b = (_a = selectInternalState(state)) == null ? void 0 : _a.queries) == null ? void 0 : _b[serializedArgs]) != null ? _c : defaultQuerySubState;
          };
          var finalSelectQuerySubState = queryArgs === skipToken ? selectSkippedQuery : selectQuerySubstate;
          return createSelector(finalSelectQuerySubState, withRequestFlags);
        };
      }
      function buildMutationSelector() {
        return function(id2) {
          var _a;
          var mutationId;
          if (typeof id2 === "object") {
            mutationId = (_a = getMutationCacheKey(id2)) != null ? _a : skipToken;
          } else {
            mutationId = id2;
          }
          var selectMutationSubstate = function(state) {
            var _a2, _b, _c;
            return (_c = (_b = (_a2 = selectInternalState(state)) == null ? void 0 : _a2.mutations) == null ? void 0 : _b[mutationId]) != null ? _c : defaultMutationSubState;
          };
          var finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
          return createSelector(finalSelectMutationSubstate, withRequestFlags);
        };
      }
      function selectInvalidatedBy(state, tags2) {
        var _a;
        var apiState = state[reducerPath];
        var toInvalidate = /* @__PURE__ */ new Set();
        for (var _j2 = 0, _k = tags2.map(expandTagDescription); _j2 < _k.length; _j2++) {
          var tag = _k[_j2];
          var provided = apiState.provided[tag.type];
          if (!provided) {
            continue;
          }
          var invalidateSubscriptions = (_a = tag.id !== void 0 ? provided[tag.id] : flatten(Object.values(provided))) != null ? _a : [];
          for (var _l = 0, invalidateSubscriptions_1 = invalidateSubscriptions; _l < invalidateSubscriptions_1.length; _l++) {
            var invalidate = invalidateSubscriptions_1[_l];
            toInvalidate.add(invalidate);
          }
        }
        return flatten(Array.from(toInvalidate.values()).map(function(queryCacheKey) {
          var querySubState = apiState.queries[queryCacheKey];
          return querySubState ? [
            {
              queryCacheKey,
              endpointName: querySubState.endpointName,
              originalArgs: querySubState.originalArgs
            }
          ] : [];
        }));
      }
    }
    var cache$1 = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
    var defaultSerializeQueryArgs$1 = function(_j) {
      var endpointName = _j.endpointName, queryArgs = _j.queryArgs;
      var serialized = "";
      var cached = cache$1 == null ? void 0 : cache$1.get(queryArgs);
      if (typeof cached === "string") {
        serialized = cached;
      } else {
        var stringified = JSON.stringify(queryArgs, function(key, value) {
          return isPlainObject$2(value) ? Object.keys(value).sort().reduce(function(acc, key2) {
            acc[key2] = value[key2];
            return acc;
          }, {}) : value;
        });
        if (isPlainObject$2(queryArgs)) {
          cache$1 == null ? void 0 : cache$1.set(queryArgs, stringified);
        }
        serialized = stringified;
      }
      return endpointName + "(" + serialized + ")";
    };
    function buildCreateApi() {
      var modules = [];
      for (var _j = 0; _j < arguments.length; _j++) {
        modules[_j] = arguments[_j];
      }
      return function baseCreateApi(options) {
        var extractRehydrationInfo = defaultMemoize(function(action) {
          var _a, _b;
          return (_b = options.extractRehydrationInfo) == null ? void 0 : _b.call(options, action, {
            reducerPath: (_a = options.reducerPath) != null ? _a : "api"
          });
        });
        var optionsWithDefaults = __spreadProps$1(__spreadValues$1({
          reducerPath: "api",
          keepUnusedDataFor: 60,
          refetchOnMountOrArgChange: false,
          refetchOnFocus: false,
          refetchOnReconnect: false
        }, options), {
          extractRehydrationInfo,
          serializeQueryArgs: function(queryArgsApi) {
            var finalSerializeQueryArgs = defaultSerializeQueryArgs$1;
            if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
              var endpointSQA_1 = queryArgsApi.endpointDefinition.serializeQueryArgs;
              finalSerializeQueryArgs = function(queryArgsApi2) {
                var initialResult = endpointSQA_1(queryArgsApi2);
                if (typeof initialResult === "string") {
                  return initialResult;
                } else {
                  return defaultSerializeQueryArgs$1(__spreadProps$1(__spreadValues$1({}, queryArgsApi2), {
                    queryArgs: initialResult
                  }));
                }
              };
            } else if (options.serializeQueryArgs) {
              finalSerializeQueryArgs = options.serializeQueryArgs;
            }
            return finalSerializeQueryArgs(queryArgsApi);
          },
          tagTypes: __spreadArray$1([], options.tagTypes || [])
        });
        var context = {
          endpointDefinitions: {},
          batch: function(fn2) {
            fn2();
          },
          apiUid: nanoid(),
          extractRehydrationInfo,
          hasRehydrationInfo: defaultMemoize(function(action) {
            return extractRehydrationInfo(action) != null;
          })
        };
        var api2 = {
          injectEndpoints,
          enhanceEndpoints: function(_j2) {
            var addTagTypes = _j2.addTagTypes, endpoints = _j2.endpoints;
            if (addTagTypes) {
              for (var _k = 0, addTagTypes_1 = addTagTypes; _k < addTagTypes_1.length; _k++) {
                var eT = addTagTypes_1[_k];
                if (!optionsWithDefaults.tagTypes.includes(eT)) {
                  optionsWithDefaults.tagTypes.push(eT);
                }
              }
            }
            if (endpoints) {
              for (var _l = 0, _m = Object.entries(endpoints); _l < _m.length; _l++) {
                var _o2 = _m[_l], endpointName = _o2[0], partialDefinition = _o2[1];
                if (typeof partialDefinition === "function") {
                  partialDefinition(context.endpointDefinitions[endpointName]);
                } else {
                  Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
                }
              }
            }
            return api2;
          }
        };
        var initializedModules = modules.map(function(m2) {
          return m2.init(api2, optionsWithDefaults, context);
        });
        function injectEndpoints(inject) {
          var evaluatedEndpoints = inject.endpoints({
            query: function(x2) {
              return __spreadProps$1(__spreadValues$1({}, x2), { type: DefinitionType$1.query });
            },
            mutation: function(x2) {
              return __spreadProps$1(__spreadValues$1({}, x2), { type: DefinitionType$1.mutation });
            }
          });
          for (var _j2 = 0, _k = Object.entries(evaluatedEndpoints); _j2 < _k.length; _j2++) {
            var _l = _k[_j2], endpointName = _l[0], definition = _l[1];
            if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {
              if (typeof process !== "undefined" && false) {
                console.error("called `injectEndpoints` to override already-existing endpointName " + endpointName + " without specifying `overrideExisting: true`");
              }
              continue;
            }
            context.endpointDefinitions[endpointName] = definition;
            for (var _m = 0, initializedModules_1 = initializedModules; _m < initializedModules_1.length; _m++) {
              var m2 = initializedModules_1[_m];
              m2.injectEndpoint(endpointName, definition);
            }
          }
          return api2;
        }
        return api2.injectEndpoints({ endpoints: options.endpoints });
      };
    }
    function isObjectEmpty$1(obj) {
      for (var k2 in obj) {
        return false;
      }
      return true;
    }
    var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
    var buildCacheCollectionHandler = function(_j) {
      var reducerPath = _j.reducerPath, api2 = _j.api, context = _j.context, internalState = _j.internalState;
      var _k = api2.internalActions, removeQueryResult = _k.removeQueryResult, unsubscribeQueryResult = _k.unsubscribeQueryResult;
      function anySubscriptionsRemainingForKey(queryCacheKey) {
        var subscriptions = internalState.currentSubscriptions[queryCacheKey];
        return !!subscriptions && !isObjectEmpty$1(subscriptions);
      }
      var currentRemovalTimeouts = {};
      var handler = function(action, mwApi, internalState2) {
        var _a;
        if (unsubscribeQueryResult.match(action)) {
          var state = mwApi.getState()[reducerPath];
          var queryCacheKey = action.payload.queryCacheKey;
          handleUnsubscribe(queryCacheKey, (_a = state.queries[queryCacheKey]) == null ? void 0 : _a.endpointName, mwApi, state.config);
        }
        if (api2.util.resetApiState.match(action)) {
          for (var _j2 = 0, _k2 = Object.entries(currentRemovalTimeouts); _j2 < _k2.length; _j2++) {
            var _l = _k2[_j2], key = _l[0], timeout = _l[1];
            if (timeout)
              clearTimeout(timeout);
            delete currentRemovalTimeouts[key];
          }
        }
        if (context.hasRehydrationInfo(action)) {
          var state = mwApi.getState()[reducerPath];
          var queries = context.extractRehydrationInfo(action).queries;
          for (var _m = 0, _o2 = Object.entries(queries); _m < _o2.length; _m++) {
            var _p = _o2[_m], queryCacheKey = _p[0], queryState = _p[1];
            handleUnsubscribe(queryCacheKey, queryState == null ? void 0 : queryState.endpointName, mwApi, state.config);
          }
        }
      };
      function handleUnsubscribe(queryCacheKey, endpointName, api22, config2) {
        var _a;
        var endpointDefinition = context.endpointDefinitions[endpointName];
        var keepUnusedDataFor = (_a = endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) != null ? _a : config2.keepUnusedDataFor;
        if (keepUnusedDataFor === Infinity) {
          return;
        }
        var finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
          var currentTimeout = currentRemovalTimeouts[queryCacheKey];
          if (currentTimeout) {
            clearTimeout(currentTimeout);
          }
          currentRemovalTimeouts[queryCacheKey] = setTimeout(function() {
            if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
              api22.dispatch(removeQueryResult({ queryCacheKey }));
            }
            delete currentRemovalTimeouts[queryCacheKey];
          }, finalKeepUnusedDataFor * 1e3);
        }
      }
      return handler;
    };
    var buildInvalidationByTagsHandler = function(_j) {
      var reducerPath = _j.reducerPath, context = _j.context, endpointDefinitions = _j.context.endpointDefinitions, mutationThunk = _j.mutationThunk, api2 = _j.api, assertTagType = _j.assertTagType, refetchQuery = _j.refetchQuery;
      var removeQueryResult = api2.internalActions.removeQueryResult;
      var isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));
      var handler = function(action, mwApi) {
        if (isThunkActionWithTags(action)) {
          invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
        }
        if (api2.util.invalidateTags.match(action)) {
          invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
        }
      };
      function invalidateTags(tags2, mwApi) {
        var rootState = mwApi.getState();
        var state = rootState[reducerPath];
        var toInvalidate = api2.util.selectInvalidatedBy(rootState, tags2);
        context.batch(function() {
          var _a;
          var valuesArray = Array.from(toInvalidate.values());
          for (var _j2 = 0, valuesArray_1 = valuesArray; _j2 < valuesArray_1.length; _j2++) {
            var queryCacheKey = valuesArray_1[_j2].queryCacheKey;
            var querySubState = state.queries[queryCacheKey];
            var subscriptionSubState = (_a = state.subscriptions[queryCacheKey]) != null ? _a : {};
            if (querySubState) {
              if (Object.keys(subscriptionSubState).length === 0) {
                mwApi.dispatch(removeQueryResult({
                  queryCacheKey
                }));
              } else if (querySubState.status !== QueryStatus.uninitialized) {
                mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));
              }
            }
          }
        });
      }
      return handler;
    };
    var buildPollingHandler = function(_j) {
      var reducerPath = _j.reducerPath, queryThunk = _j.queryThunk, api2 = _j.api, refetchQuery = _j.refetchQuery, internalState = _j.internalState;
      var currentPolls = {};
      var handler = function(action, mwApi) {
        if (api2.internalActions.updateSubscriptionOptions.match(action) || api2.internalActions.unsubscribeQueryResult.match(action)) {
          updatePollingInterval(action.payload, mwApi);
        }
        if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
          updatePollingInterval(action.meta.arg, mwApi);
        }
        if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
          startNextPoll(action.meta.arg, mwApi);
        }
        if (api2.util.resetApiState.match(action)) {
          clearPolls();
        }
      };
      function startNextPoll(_j2, api22) {
        var queryCacheKey = _j2.queryCacheKey;
        var state = api22.getState()[reducerPath];
        var querySubState = state.queries[queryCacheKey];
        var subscriptions = internalState.currentSubscriptions[queryCacheKey];
        if (!querySubState || querySubState.status === QueryStatus.uninitialized)
          return;
        var lowestPollingInterval = findLowestPollingInterval(subscriptions);
        if (!Number.isFinite(lowestPollingInterval))
          return;
        var currentPoll = currentPolls[queryCacheKey];
        if (currentPoll == null ? void 0 : currentPoll.timeout) {
          clearTimeout(currentPoll.timeout);
          currentPoll.timeout = void 0;
        }
        var nextPollTimestamp = Date.now() + lowestPollingInterval;
        var currentInterval = currentPolls[queryCacheKey] = {
          nextPollTimestamp,
          pollingInterval: lowestPollingInterval,
          timeout: setTimeout(function() {
            currentInterval.timeout = void 0;
            api22.dispatch(refetchQuery(querySubState, queryCacheKey));
          }, lowestPollingInterval)
        };
      }
      function updatePollingInterval(_j2, api22) {
        var queryCacheKey = _j2.queryCacheKey;
        var state = api22.getState()[reducerPath];
        var querySubState = state.queries[queryCacheKey];
        var subscriptions = internalState.currentSubscriptions[queryCacheKey];
        if (!querySubState || querySubState.status === QueryStatus.uninitialized) {
          return;
        }
        var lowestPollingInterval = findLowestPollingInterval(subscriptions);
        if (!Number.isFinite(lowestPollingInterval)) {
          cleanupPollForKey(queryCacheKey);
          return;
        }
        var currentPoll = currentPolls[queryCacheKey];
        var nextPollTimestamp = Date.now() + lowestPollingInterval;
        if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
          startNextPoll({ queryCacheKey }, api22);
        }
      }
      function cleanupPollForKey(key) {
        var existingPoll = currentPolls[key];
        if (existingPoll == null ? void 0 : existingPoll.timeout) {
          clearTimeout(existingPoll.timeout);
        }
        delete currentPolls[key];
      }
      function clearPolls() {
        for (var _j2 = 0, _k = Object.keys(currentPolls); _j2 < _k.length; _j2++) {
          var key = _k[_j2];
          cleanupPollForKey(key);
        }
      }
      function findLowestPollingInterval(subscribers) {
        if (subscribers === void 0) {
          subscribers = {};
        }
        var lowestPollingInterval = Number.POSITIVE_INFINITY;
        for (var key in subscribers) {
          if (!!subscribers[key].pollingInterval) {
            lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);
          }
        }
        return lowestPollingInterval;
      }
      return handler;
    };
    var buildWindowEventHandler = function(_j) {
      var reducerPath = _j.reducerPath, context = _j.context, api2 = _j.api, refetchQuery = _j.refetchQuery, internalState = _j.internalState;
      var removeQueryResult = api2.internalActions.removeQueryResult;
      var handler = function(action, mwApi) {
        if (onFocus.match(action)) {
          refetchValidQueries(mwApi, "refetchOnFocus");
        }
        if (onOnline.match(action)) {
          refetchValidQueries(mwApi, "refetchOnReconnect");
        }
      };
      function refetchValidQueries(api22, type) {
        var state = api22.getState()[reducerPath];
        var queries = state.queries;
        var subscriptions = internalState.currentSubscriptions;
        context.batch(function() {
          for (var _j2 = 0, _k = Object.keys(subscriptions); _j2 < _k.length; _j2++) {
            var queryCacheKey = _k[_j2];
            var querySubState = queries[queryCacheKey];
            var subscriptionSubState = subscriptions[queryCacheKey];
            if (!subscriptionSubState || !querySubState)
              continue;
            var shouldRefetch = Object.values(subscriptionSubState).some(function(sub) {
              return sub[type] === true;
            }) || Object.values(subscriptionSubState).every(function(sub) {
              return sub[type] === void 0;
            }) && state.config[type];
            if (shouldRefetch) {
              if (Object.keys(subscriptionSubState).length === 0) {
                api22.dispatch(removeQueryResult({
                  queryCacheKey
                }));
              } else if (querySubState.status !== QueryStatus.uninitialized) {
                api22.dispatch(refetchQuery(querySubState, queryCacheKey));
              }
            }
          }
        });
      }
      return handler;
    };
    var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
    var buildCacheLifecycleHandler = function(_j) {
      var api2 = _j.api, reducerPath = _j.reducerPath, context = _j.context, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk;
      _j.internalState;
      var isQueryThunk = isAsyncThunkAction(queryThunk);
      var isMutationThunk = isAsyncThunkAction(mutationThunk);
      var isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);
      var lifecycleMap = {};
      var handler = function(action, mwApi, stateBefore) {
        var cacheKey = getCacheKey(action);
        if (queryThunk.pending.match(action)) {
          var oldState = stateBefore[reducerPath].queries[cacheKey];
          var state = mwApi.getState()[reducerPath].queries[cacheKey];
          if (!oldState && state) {
            handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
          }
        } else if (mutationThunk.pending.match(action)) {
          var state = mwApi.getState()[reducerPath].mutations[cacheKey];
          if (state) {
            handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
          }
        } else if (isFulfilledThunk(action)) {
          var lifecycle = lifecycleMap[cacheKey];
          if (lifecycle == null ? void 0 : lifecycle.valueResolved) {
            lifecycle.valueResolved({
              data: action.payload,
              meta: action.meta.baseQueryMeta
            });
            delete lifecycle.valueResolved;
          }
        } else if (api2.internalActions.removeQueryResult.match(action) || api2.internalActions.removeMutationResult.match(action)) {
          var lifecycle = lifecycleMap[cacheKey];
          if (lifecycle) {
            delete lifecycleMap[cacheKey];
            lifecycle.cacheEntryRemoved();
          }
        } else if (api2.util.resetApiState.match(action)) {
          for (var _j2 = 0, _k = Object.entries(lifecycleMap); _j2 < _k.length; _j2++) {
            var _l = _k[_j2], cacheKey2 = _l[0], lifecycle = _l[1];
            delete lifecycleMap[cacheKey2];
            lifecycle.cacheEntryRemoved();
          }
        }
      };
      function getCacheKey(action) {
        if (isQueryThunk(action))
          return action.meta.arg.queryCacheKey;
        if (isMutationThunk(action))
          return action.meta.requestId;
        if (api2.internalActions.removeQueryResult.match(action))
          return action.payload.queryCacheKey;
        if (api2.internalActions.removeMutationResult.match(action))
          return getMutationCacheKey(action.payload);
        return "";
      }
      function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
        var endpointDefinition = context.endpointDefinitions[endpointName];
        var onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;
        if (!onCacheEntryAdded)
          return;
        var lifecycle = {};
        var cacheEntryRemoved = new Promise(function(resolve) {
          lifecycle.cacheEntryRemoved = resolve;
        });
        var cacheDataLoaded = Promise.race([
          new Promise(function(resolve) {
            lifecycle.valueResolved = resolve;
          }),
          cacheEntryRemoved.then(function() {
            throw neverResolvedError;
          })
        ]);
        cacheDataLoaded.catch(function() {
        });
        lifecycleMap[queryCacheKey] = lifecycle;
        var selector = api2.endpoints[endpointName].select(endpointDefinition.type === DefinitionType$1.query ? originalArgs : queryCacheKey);
        var extra = mwApi.dispatch(function(_2, __, extra2) {
          return extra2;
        });
        var lifecycleApi = __spreadProps$1(__spreadValues$1({}, mwApi), {
          getCacheEntry: function() {
            return selector(mwApi.getState());
          },
          requestId,
          extra,
          updateCachedData: endpointDefinition.type === DefinitionType$1.query ? function(updateRecipe) {
            return mwApi.dispatch(api2.util.updateQueryData(endpointName, originalArgs, updateRecipe));
          } : void 0,
          cacheDataLoaded,
          cacheEntryRemoved
        });
        var runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
        Promise.resolve(runningHandler).catch(function(e2) {
          if (e2 === neverResolvedError)
            return;
          throw e2;
        });
      }
      return handler;
    };
    var buildQueryLifecycleHandler = function(_j) {
      var api2 = _j.api, context = _j.context, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk;
      var isPendingThunk = isPending(queryThunk, mutationThunk);
      var isRejectedThunk = isRejected(queryThunk, mutationThunk);
      var isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);
      var lifecycleMap = {};
      var handler = function(action, mwApi) {
        var _a, _b, _c;
        if (isPendingThunk(action)) {
          var _j2 = action.meta, requestId = _j2.requestId, _k = _j2.arg, endpointName_1 = _k.endpointName, originalArgs_1 = _k.originalArgs;
          var endpointDefinition = context.endpointDefinitions[endpointName_1];
          var onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;
          if (onQueryStarted) {
            var lifecycle_1 = {};
            var queryFulfilled = new Promise(function(resolve, reject) {
              lifecycle_1.resolve = resolve;
              lifecycle_1.reject = reject;
            });
            queryFulfilled.catch(function() {
            });
            lifecycleMap[requestId] = lifecycle_1;
            var selector_1 = api2.endpoints[endpointName_1].select(endpointDefinition.type === DefinitionType$1.query ? originalArgs_1 : requestId);
            var extra = mwApi.dispatch(function(_2, __, extra2) {
              return extra2;
            });
            var lifecycleApi = __spreadProps$1(__spreadValues$1({}, mwApi), {
              getCacheEntry: function() {
                return selector_1(mwApi.getState());
              },
              requestId,
              extra,
              updateCachedData: endpointDefinition.type === DefinitionType$1.query ? function(updateRecipe) {
                return mwApi.dispatch(api2.util.updateQueryData(endpointName_1, originalArgs_1, updateRecipe));
              } : void 0,
              queryFulfilled
            });
            onQueryStarted(originalArgs_1, lifecycleApi);
          }
        } else if (isFullfilledThunk(action)) {
          var _l = action.meta, requestId = _l.requestId, baseQueryMeta = _l.baseQueryMeta;
          (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({
            data: action.payload,
            meta: baseQueryMeta
          });
          delete lifecycleMap[requestId];
        } else if (isRejectedThunk(action)) {
          var _m = action.meta, requestId = _m.requestId, rejectedWithValue = _m.rejectedWithValue, baseQueryMeta = _m.baseQueryMeta;
          (_c = lifecycleMap[requestId]) == null ? void 0 : _c.reject({
            error: (_b = action.payload) != null ? _b : action.error,
            isUnhandledError: !rejectedWithValue,
            meta: baseQueryMeta
          });
          delete lifecycleMap[requestId];
        }
      };
      return handler;
    };
    var buildDevCheckHandler = function(_j) {
      var api2 = _j.api, apiUid = _j.context.apiUid, reducerPath = _j.reducerPath;
      return function(action, mwApi) {
        var _a, _b;
        if (api2.util.resetApiState.match(action)) {
          mwApi.dispatch(api2.internalActions.middlewareRegistered(apiUid));
        }
        if (typeof process !== "undefined" && false) {
          if (api2.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && ((_b = (_a = mwApi.getState()[reducerPath]) == null ? void 0 : _a.config) == null ? void 0 : _b.middlewareRegistered) === "conflict") {
            console.warn('There is a mismatch between slice and middleware for the reducerPath "' + reducerPath + '".\nYou can only have one api per reducer path, this will lead to crashes in various situations!' + (reducerPath === "api" ? "\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!" : ""));
          }
        }
      };
    };
    var promise;
    var queueMicrotaskShim = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb2) {
      return (promise || (promise = Promise.resolve())).then(cb2).catch(function(err) {
        return setTimeout(function() {
          throw err;
        }, 0);
      });
    };
    var buildBatchedActionsHandler = function(_j) {
      var api2 = _j.api, queryThunk = _j.queryThunk, internalState = _j.internalState;
      var subscriptionsPrefix = api2.reducerPath + "/subscriptions";
      var previousSubscriptions = null;
      var dispatchQueued = false;
      var _k = api2.internalActions, updateSubscriptionOptions = _k.updateSubscriptionOptions, unsubscribeQueryResult = _k.unsubscribeQueryResult;
      var actuallyMutateSubscriptions = function(mutableState, action) {
        var _a, _b, _c, _d, _e2, _f, _g, _h, _i;
        if (updateSubscriptionOptions.match(action)) {
          var _j2 = action.payload, queryCacheKey = _j2.queryCacheKey, requestId = _j2.requestId, options = _j2.options;
          if ((_a = mutableState == null ? void 0 : mutableState[queryCacheKey]) == null ? void 0 : _a[requestId]) {
            mutableState[queryCacheKey][requestId] = options;
          }
          return true;
        }
        if (unsubscribeQueryResult.match(action)) {
          var _k2 = action.payload, queryCacheKey = _k2.queryCacheKey, requestId = _k2.requestId;
          if (mutableState[queryCacheKey]) {
            delete mutableState[queryCacheKey][requestId];
          }
          return true;
        }
        if (api2.internalActions.removeQueryResult.match(action)) {
          delete mutableState[action.payload.queryCacheKey];
          return true;
        }
        if (queryThunk.pending.match(action)) {
          var _l = action.meta, arg = _l.arg, requestId = _l.requestId;
          if (arg.subscribe) {
            var substate = (_c = mutableState[_b = arg.queryCacheKey]) != null ? _c : mutableState[_b] = {};
            substate[requestId] = (_e2 = (_d = arg.subscriptionOptions) != null ? _d : substate[requestId]) != null ? _e2 : {};
            return true;
          }
        }
        if (queryThunk.rejected.match(action)) {
          var _m = action.meta, condition = _m.condition, arg = _m.arg, requestId = _m.requestId;
          if (condition && arg.subscribe) {
            var substate = (_g = mutableState[_f = arg.queryCacheKey]) != null ? _g : mutableState[_f] = {};
            substate[requestId] = (_i = (_h = arg.subscriptionOptions) != null ? _h : substate[requestId]) != null ? _i : {};
            return true;
          }
        }
        return false;
      };
      return function(action, mwApi) {
        var _a, _b;
        if (!previousSubscriptions) {
          previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
        }
        if (api2.util.resetApiState.match(action)) {
          previousSubscriptions = internalState.currentSubscriptions = {};
          return [true, false];
        }
        if (api2.internalActions.internal_probeSubscription.match(action)) {
          var _j2 = action.payload, queryCacheKey = _j2.queryCacheKey, requestId = _j2.requestId;
          var hasSubscription = !!((_a = internalState.currentSubscriptions[queryCacheKey]) == null ? void 0 : _a[requestId]);
          return [false, hasSubscription];
        }
        var didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
        if (didMutate) {
          if (!dispatchQueued) {
            queueMicrotaskShim(function() {
              var newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
              var _j3 = cn(previousSubscriptions, function() {
                return newSubscriptions;
              }), patches = _j3[1];
              mwApi.next(api2.internalActions.subscriptionsUpdated(patches));
              previousSubscriptions = newSubscriptions;
              dispatchQueued = false;
            });
            dispatchQueued = true;
          }
          var isSubscriptionSliceAction = !!((_b = action.type) == null ? void 0 : _b.startsWith(subscriptionsPrefix));
          var isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
          var actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
          return [actionShouldContinue, false];
        }
        return [true, false];
      };
    };
    function buildMiddleware(input) {
      var reducerPath = input.reducerPath, queryThunk = input.queryThunk, api2 = input.api, context = input.context;
      var apiUid = context.apiUid;
      var actions2 = {
        invalidateTags: createAction(reducerPath + "/invalidateTags")
      };
      var isThisApiSliceAction = function(action) {
        return !!action && typeof action.type === "string" && action.type.startsWith(reducerPath + "/");
      };
      var handlerBuilders = [
        buildDevCheckHandler,
        buildCacheCollectionHandler,
        buildInvalidationByTagsHandler,
        buildPollingHandler,
        buildCacheLifecycleHandler,
        buildQueryLifecycleHandler
      ];
      var middleware2 = function(mwApi) {
        var initialized2 = false;
        var internalState = {
          currentSubscriptions: {}
        };
        var builderArgs = __spreadProps$1(__spreadValues$1({}, input), {
          internalState,
          refetchQuery
        });
        var handlers = handlerBuilders.map(function(build) {
          return build(builderArgs);
        });
        var batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
        var windowEventsHandler = buildWindowEventHandler(builderArgs);
        return function(next2) {
          return function(action) {
            if (!initialized2) {
              initialized2 = true;
              mwApi.dispatch(api2.internalActions.middlewareRegistered(apiUid));
            }
            var mwApiWithNext = __spreadProps$1(__spreadValues$1({}, mwApi), { next: next2 });
            var stateBefore = mwApi.getState();
            var _j = batchedActionsHandler(action, mwApiWithNext, stateBefore), actionShouldContinue = _j[0], hasSubscription = _j[1];
            var res;
            if (actionShouldContinue) {
              res = next2(action);
            } else {
              res = hasSubscription;
            }
            if (!!mwApi.getState()[reducerPath]) {
              windowEventsHandler(action, mwApiWithNext, stateBefore);
              if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {
                for (var _k = 0, handlers_1 = handlers; _k < handlers_1.length; _k++) {
                  var handler = handlers_1[_k];
                  handler(action, mwApiWithNext, stateBefore);
                }
              }
            }
            return res;
          };
        };
      };
      return { middleware: middleware2, actions: actions2 };
      function refetchQuery(querySubState, queryCacheKey, override) {
        if (override === void 0) {
          override = {};
        }
        return queryThunk(__spreadValues$1({
          type: "query",
          endpointName: querySubState.endpointName,
          originalArgs: querySubState.originalArgs,
          subscribe: false,
          forceRefetch: true,
          queryCacheKey
        }, override));
      }
    }
    function safeAssign$1(target) {
      var args = [];
      for (var _j = 1; _j < arguments.length; _j++) {
        args[_j - 1] = arguments[_j];
      }
      Object.assign.apply(Object, __spreadArray$1([target], args));
    }
    var coreModuleName = /* @__PURE__ */ Symbol();
    var coreModule = function() {
      return {
        name: coreModuleName,
        init: function(api2, _j, context) {
          var baseQuery = _j.baseQuery, tagTypes = _j.tagTypes, reducerPath = _j.reducerPath, serializeQueryArgs = _j.serializeQueryArgs, keepUnusedDataFor = _j.keepUnusedDataFor, refetchOnMountOrArgChange = _j.refetchOnMountOrArgChange, refetchOnFocus = _j.refetchOnFocus, refetchOnReconnect = _j.refetchOnReconnect;
          T();
          var assertTagType = function(tag) {
            if (typeof process !== "undefined" && false) {
              if (!tagTypes.includes(tag.type)) {
                console.error("Tag type '" + tag.type + "' was used, but not specified in `tagTypes`!");
              }
            }
            return tag;
          };
          Object.assign(api2, {
            reducerPath,
            endpoints: {},
            internalActions: {
              onOnline,
              onOffline,
              onFocus,
              onFocusLost
            },
            util: {}
          });
          var _k = buildThunks({
            baseQuery,
            reducerPath,
            context,
            api: api2,
            serializeQueryArgs,
            assertTagType
          }), queryThunk = _k.queryThunk, mutationThunk = _k.mutationThunk, patchQueryData = _k.patchQueryData, updateQueryData = _k.updateQueryData, upsertQueryData = _k.upsertQueryData, prefetch = _k.prefetch, buildMatchThunkActions = _k.buildMatchThunkActions;
          var _l = buildSlice({
            context,
            queryThunk,
            mutationThunk,
            reducerPath,
            assertTagType,
            config: {
              refetchOnFocus,
              refetchOnReconnect,
              refetchOnMountOrArgChange,
              keepUnusedDataFor,
              reducerPath
            }
          }), reducer2 = _l.reducer, sliceActions = _l.actions;
          safeAssign$1(api2.util, {
            patchQueryData,
            updateQueryData,
            upsertQueryData,
            prefetch,
            resetApiState: sliceActions.resetApiState
          });
          safeAssign$1(api2.internalActions, sliceActions);
          var _m = buildMiddleware({
            reducerPath,
            context,
            queryThunk,
            mutationThunk,
            api: api2,
            assertTagType
          }), middleware2 = _m.middleware, middlewareActions = _m.actions;
          safeAssign$1(api2.util, middlewareActions);
          safeAssign$1(api2, { reducer: reducer2, middleware: middleware2 });
          var _o2 = buildSelectors({
            serializeQueryArgs,
            reducerPath
          }), buildQuerySelector = _o2.buildQuerySelector, buildMutationSelector = _o2.buildMutationSelector, selectInvalidatedBy = _o2.selectInvalidatedBy;
          safeAssign$1(api2.util, { selectInvalidatedBy });
          var _p = buildInitiate({
            queryThunk,
            mutationThunk,
            api: api2,
            serializeQueryArgs,
            context
          }), buildInitiateQuery = _p.buildInitiateQuery, buildInitiateMutation = _p.buildInitiateMutation, getRunningMutationThunk = _p.getRunningMutationThunk, getRunningMutationsThunk = _p.getRunningMutationsThunk, getRunningQueriesThunk = _p.getRunningQueriesThunk, getRunningQueryThunk = _p.getRunningQueryThunk, getRunningOperationPromises = _p.getRunningOperationPromises, removalWarning = _p.removalWarning;
          safeAssign$1(api2.util, {
            getRunningOperationPromises,
            getRunningOperationPromise: removalWarning,
            getRunningMutationThunk,
            getRunningMutationsThunk,
            getRunningQueryThunk,
            getRunningQueriesThunk
          });
          return {
            name: coreModuleName,
            injectEndpoint: function(endpointName, definition) {
              var _a, _b;
              var anyApi = api2;
              (_b = (_a = anyApi.endpoints)[endpointName]) != null ? _b : _a[endpointName] = {};
              if (isQueryDefinition$1(definition)) {
                safeAssign$1(anyApi.endpoints[endpointName], {
                  name: endpointName,
                  select: buildQuerySelector(endpointName, definition),
                  initiate: buildInitiateQuery(endpointName, definition)
                }, buildMatchThunkActions(queryThunk, endpointName));
              } else if (isMutationDefinition$1(definition)) {
                safeAssign$1(anyApi.endpoints[endpointName], {
                  name: endpointName,
                  select: buildMutationSelector(),
                  initiate: buildInitiateMutation(endpointName)
                }, buildMatchThunkActions(mutationThunk, endpointName));
              }
            }
          };
        }
      };
    };
    var __spreadArray = globalThis && globalThis.__spreadArray || function(to2, from2) {
      for (var i2 = 0, il2 = from2.length, j2 = to2.length; i2 < il2; i2++, j2++)
        to2[j2] = from2[i2];
      return to2;
    };
    var __defProp2 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp2 = function(obj, key, value) {
      return key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    };
    var __spreadValues = function(a2, b2) {
      for (var prop in b2 || (b2 = {}))
        if (__hasOwnProp.call(b2, prop))
          __defNormalProp2(a2, prop, b2[prop]);
      if (__getOwnPropSymbols)
        for (var _i = 0, _c = __getOwnPropSymbols(b2); _i < _c.length; _i++) {
          var prop = _c[_i];
          if (__propIsEnum.call(b2, prop))
            __defNormalProp2(a2, prop, b2[prop]);
        }
      return a2;
    };
    var __spreadProps = function(a2, b2) {
      return __defProps(a2, __getOwnPropDescs(b2));
    };
    function useStableQueryArgs(queryArgs, serialize2, endpointDefinition, endpointName) {
      var incoming = reactExports.useMemo(function() {
        return {
          queryArgs,
          serialized: typeof queryArgs == "object" ? serialize2({ queryArgs, endpointDefinition, endpointName }) : queryArgs
        };
      }, [queryArgs, serialize2, endpointDefinition, endpointName]);
      var cache2 = reactExports.useRef(incoming);
      reactExports.useEffect(function() {
        if (cache2.current.serialized !== incoming.serialized) {
          cache2.current = incoming;
        }
      }, [incoming]);
      return cache2.current.serialized === incoming.serialized ? cache2.current.queryArgs : queryArgs;
    }
    var UNINITIALIZED_VALUE = Symbol();
    function useShallowStableValue(value) {
      var cache2 = reactExports.useRef(value);
      reactExports.useEffect(function() {
        if (!shallowEqual(cache2.current, value)) {
          cache2.current = value;
        }
      }, [value]);
      return shallowEqual(cache2.current, value) ? cache2.current : value;
    }
    var cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
    var defaultSerializeQueryArgs = function(_c) {
      var endpointName = _c.endpointName, queryArgs = _c.queryArgs;
      var serialized = "";
      var cached = cache == null ? void 0 : cache.get(queryArgs);
      if (typeof cached === "string") {
        serialized = cached;
      } else {
        var stringified = JSON.stringify(queryArgs, function(key, value) {
          return isPlainObject$2(value) ? Object.keys(value).sort().reduce(function(acc, key2) {
            acc[key2] = value[key2];
            return acc;
          }, {}) : value;
        });
        if (isPlainObject$2(queryArgs)) {
          cache == null ? void 0 : cache.set(queryArgs, stringified);
        }
        serialized = stringified;
      }
      return endpointName + "(" + serialized + ")";
    };
    var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && !!window.document && !!window.document.createElement ? reactExports.useLayoutEffect : reactExports.useEffect;
    var defaultMutationStateSelector = function(x2) {
      return x2;
    };
    var noPendingQueryStateSelector = function(selected) {
      if (selected.isUninitialized) {
        return __spreadProps(__spreadValues({}, selected), {
          isUninitialized: false,
          isFetching: true,
          isLoading: selected.data !== void 0 ? false : true,
          status: QueryStatus.pending
        });
      }
      return selected;
    };
    function buildHooks(_c) {
      var api2 = _c.api, _d = _c.moduleOptions, batch2 = _d.batch, useDispatch2 = _d.useDispatch, useSelector2 = _d.useSelector, useStore2 = _d.useStore, unstable__sideEffectsInRender = _d.unstable__sideEffectsInRender, serializeQueryArgs = _c.serializeQueryArgs, context = _c.context;
      var usePossiblyImmediateEffect = unstable__sideEffectsInRender ? function(cb2) {
        return cb2();
      } : reactExports.useEffect;
      return { buildQueryHooks, buildMutationHook, usePrefetch };
      function queryStatePreSelector(currentState, lastResult, queryArgs) {
        if ((lastResult == null ? void 0 : lastResult.endpointName) && currentState.isUninitialized) {
          var endpointName = lastResult.endpointName;
          var endpointDefinition = context.endpointDefinitions[endpointName];
          if (serializeQueryArgs({
            queryArgs: lastResult.originalArgs,
            endpointDefinition,
            endpointName
          }) === serializeQueryArgs({
            queryArgs,
            endpointDefinition,
            endpointName
          }))
            lastResult = void 0;
        }
        var data = currentState.isSuccess ? currentState.data : lastResult == null ? void 0 : lastResult.data;
        if (data === void 0)
          data = currentState.data;
        var hasData = data !== void 0;
        var isFetching = currentState.isLoading;
        var isLoading = !hasData && isFetching;
        var isSuccess = currentState.isSuccess || isFetching && hasData;
        return __spreadProps(__spreadValues({}, currentState), {
          data,
          currentData: currentState.data,
          isFetching,
          isLoading,
          isSuccess
        });
      }
      function usePrefetch(endpointName, defaultOptions) {
        var dispatch = useDispatch2();
        var stableDefaultOptions = useShallowStableValue(defaultOptions);
        return reactExports.useCallback(function(arg, options) {
          return dispatch(api2.util.prefetch(endpointName, arg, __spreadValues(__spreadValues({}, stableDefaultOptions), options)));
        }, [endpointName, dispatch, stableDefaultOptions]);
      }
      function buildQueryHooks(name) {
        var useQuerySubscription = function(arg, _c2) {
          var _d2 = _c2 === void 0 ? {} : _c2, refetchOnReconnect = _d2.refetchOnReconnect, refetchOnFocus = _d2.refetchOnFocus, refetchOnMountOrArgChange = _d2.refetchOnMountOrArgChange, _e2 = _d2.skip, skip = _e2 === void 0 ? false : _e2, _f = _d2.pollingInterval, pollingInterval = _f === void 0 ? 0 : _f;
          var initiate = api2.endpoints[name].initiate;
          var dispatch = useDispatch2();
          var stableArg = useStableQueryArgs(skip ? skipToken : arg, defaultSerializeQueryArgs, context.endpointDefinitions[name], name);
          var stableSubscriptionOptions = useShallowStableValue({
            refetchOnReconnect,
            refetchOnFocus,
            pollingInterval
          });
          var lastRenderHadSubscription = reactExports.useRef(false);
          var promiseRef = reactExports.useRef();
          var _g = promiseRef.current || {}, queryCacheKey = _g.queryCacheKey, requestId = _g.requestId;
          var currentRenderHasSubscription = false;
          if (queryCacheKey && requestId) {
            var returnedValue = dispatch(api2.internalActions.internal_probeSubscription({
              queryCacheKey,
              requestId
            }));
            currentRenderHasSubscription = !!returnedValue;
          }
          var subscriptionRemoved = !currentRenderHasSubscription && lastRenderHadSubscription.current;
          usePossiblyImmediateEffect(function() {
            lastRenderHadSubscription.current = currentRenderHasSubscription;
          });
          usePossiblyImmediateEffect(function() {
            if (subscriptionRemoved) {
              promiseRef.current = void 0;
            }
          }, [subscriptionRemoved]);
          usePossiblyImmediateEffect(function() {
            var _a;
            var lastPromise = promiseRef.current;
            if (typeof process !== "undefined" && false) {
              console.log(subscriptionRemoved);
            }
            if (stableArg === skipToken) {
              lastPromise == null ? void 0 : lastPromise.unsubscribe();
              promiseRef.current = void 0;
              return;
            }
            var lastSubscriptionOptions = (_a = promiseRef.current) == null ? void 0 : _a.subscriptionOptions;
            if (!lastPromise || lastPromise.arg !== stableArg) {
              lastPromise == null ? void 0 : lastPromise.unsubscribe();
              var promise2 = dispatch(initiate(stableArg, {
                subscriptionOptions: stableSubscriptionOptions,
                forceRefetch: refetchOnMountOrArgChange
              }));
              promiseRef.current = promise2;
            } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {
              lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
            }
          }, [
            dispatch,
            initiate,
            refetchOnMountOrArgChange,
            stableArg,
            stableSubscriptionOptions,
            subscriptionRemoved
          ]);
          reactExports.useEffect(function() {
            return function() {
              var _a;
              (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe();
              promiseRef.current = void 0;
            };
          }, []);
          return reactExports.useMemo(function() {
            return {
              refetch: function() {
                var _a;
                if (!promiseRef.current)
                  throw new Error("Cannot refetch a query that has not been started yet.");
                return (_a = promiseRef.current) == null ? void 0 : _a.refetch();
              }
            };
          }, []);
        };
        var useLazyQuerySubscription = function(_c2) {
          var _d2 = _c2 === void 0 ? {} : _c2, refetchOnReconnect = _d2.refetchOnReconnect, refetchOnFocus = _d2.refetchOnFocus, _e2 = _d2.pollingInterval, pollingInterval = _e2 === void 0 ? 0 : _e2;
          var initiate = api2.endpoints[name].initiate;
          var dispatch = useDispatch2();
          var _f = reactExports.useState(UNINITIALIZED_VALUE), arg = _f[0], setArg = _f[1];
          var promiseRef = reactExports.useRef();
          var stableSubscriptionOptions = useShallowStableValue({
            refetchOnReconnect,
            refetchOnFocus,
            pollingInterval
          });
          usePossiblyImmediateEffect(function() {
            var _a, _b;
            var lastSubscriptionOptions = (_a = promiseRef.current) == null ? void 0 : _a.subscriptionOptions;
            if (stableSubscriptionOptions !== lastSubscriptionOptions) {
              (_b = promiseRef.current) == null ? void 0 : _b.updateSubscriptionOptions(stableSubscriptionOptions);
            }
          }, [stableSubscriptionOptions]);
          var subscriptionOptionsRef = reactExports.useRef(stableSubscriptionOptions);
          usePossiblyImmediateEffect(function() {
            subscriptionOptionsRef.current = stableSubscriptionOptions;
          }, [stableSubscriptionOptions]);
          var trigger = reactExports.useCallback(function(arg2, preferCacheValue) {
            if (preferCacheValue === void 0) {
              preferCacheValue = false;
            }
            var promise2;
            batch2(function() {
              var _a;
              (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe();
              promiseRef.current = promise2 = dispatch(initiate(arg2, {
                subscriptionOptions: subscriptionOptionsRef.current,
                forceRefetch: !preferCacheValue
              }));
              setArg(arg2);
            });
            return promise2;
          }, [dispatch, initiate]);
          reactExports.useEffect(function() {
            return function() {
              var _a;
              (_a = promiseRef == null ? void 0 : promiseRef.current) == null ? void 0 : _a.unsubscribe();
            };
          }, []);
          reactExports.useEffect(function() {
            if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {
              trigger(arg, true);
            }
          }, [arg, trigger]);
          return reactExports.useMemo(function() {
            return [trigger, arg];
          }, [trigger, arg]);
        };
        var useQueryState = function(arg, _c2) {
          var _d2 = _c2 === void 0 ? {} : _c2, _e2 = _d2.skip, skip = _e2 === void 0 ? false : _e2, selectFromResult = _d2.selectFromResult;
          var select = api2.endpoints[name].select;
          var stableArg = useStableQueryArgs(skip ? skipToken : arg, serializeQueryArgs, context.endpointDefinitions[name], name);
          var lastValue = reactExports.useRef();
          var selectDefaultResult = reactExports.useMemo(function() {
            return createSelector([
              select(stableArg),
              function(_2, lastResult) {
                return lastResult;
              },
              function(_2) {
                return stableArg;
              }
            ], queryStatePreSelector);
          }, [select, stableArg]);
          var querySelector = reactExports.useMemo(function() {
            return selectFromResult ? createSelector([selectDefaultResult], selectFromResult) : selectDefaultResult;
          }, [selectDefaultResult, selectFromResult]);
          var currentState = useSelector2(function(state) {
            return querySelector(state, lastValue.current);
          }, shallowEqual);
          var store2 = useStore2();
          var newLastValue = selectDefaultResult(store2.getState(), lastValue.current);
          useIsomorphicLayoutEffect$1(function() {
            lastValue.current = newLastValue;
          }, [newLastValue]);
          return currentState;
        };
        return {
          useQueryState,
          useQuerySubscription,
          useLazyQuerySubscription,
          useLazyQuery: function(options) {
            var _c2 = useLazyQuerySubscription(options), trigger = _c2[0], arg = _c2[1];
            var queryStateResults = useQueryState(arg, __spreadProps(__spreadValues({}, options), {
              skip: arg === UNINITIALIZED_VALUE
            }));
            var info = reactExports.useMemo(function() {
              return { lastArg: arg };
            }, [arg]);
            return reactExports.useMemo(function() {
              return [trigger, queryStateResults, info];
            }, [trigger, queryStateResults, info]);
          },
          useQuery: function(arg, options) {
            var querySubscriptionResults = useQuerySubscription(arg, options);
            var queryStateResults = useQueryState(arg, __spreadValues({
              selectFromResult: arg === skipToken || (options == null ? void 0 : options.skip) ? void 0 : noPendingQueryStateSelector
            }, options));
            var data = queryStateResults.data, status = queryStateResults.status, isLoading = queryStateResults.isLoading, isSuccess = queryStateResults.isSuccess, isError = queryStateResults.isError, error = queryStateResults.error;
            reactExports.useDebugValue({ data, status, isLoading, isSuccess, isError, error });
            return reactExports.useMemo(function() {
              return __spreadValues(__spreadValues({}, queryStateResults), querySubscriptionResults);
            }, [queryStateResults, querySubscriptionResults]);
          }
        };
      }
      function buildMutationHook(name) {
        return function(_c2) {
          var _d2 = _c2 === void 0 ? {} : _c2, _e2 = _d2.selectFromResult, selectFromResult = _e2 === void 0 ? defaultMutationStateSelector : _e2, fixedCacheKey = _d2.fixedCacheKey;
          var _f = api2.endpoints[name], select = _f.select, initiate = _f.initiate;
          var dispatch = useDispatch2();
          var _g = reactExports.useState(), promise2 = _g[0], setPromise = _g[1];
          reactExports.useEffect(function() {
            return function() {
              if (!(promise2 == null ? void 0 : promise2.arg.fixedCacheKey)) {
                promise2 == null ? void 0 : promise2.reset();
              }
            };
          }, [promise2]);
          var triggerMutation = reactExports.useCallback(function(arg) {
            var promise22 = dispatch(initiate(arg, { fixedCacheKey }));
            setPromise(promise22);
            return promise22;
          }, [dispatch, initiate, fixedCacheKey]);
          var requestId = (promise2 || {}).requestId;
          var mutationSelector = reactExports.useMemo(function() {
            return createSelector([select({ fixedCacheKey, requestId: promise2 == null ? void 0 : promise2.requestId })], selectFromResult);
          }, [select, promise2, selectFromResult, fixedCacheKey]);
          var currentState = useSelector2(mutationSelector, shallowEqual);
          var originalArgs = fixedCacheKey == null ? promise2 == null ? void 0 : promise2.arg.originalArgs : void 0;
          var reset = reactExports.useCallback(function() {
            batch2(function() {
              if (promise2) {
                setPromise(void 0);
              }
              if (fixedCacheKey) {
                dispatch(api2.internalActions.removeMutationResult({
                  requestId,
                  fixedCacheKey
                }));
              }
            });
          }, [dispatch, fixedCacheKey, promise2, requestId]);
          var endpointName = currentState.endpointName, data = currentState.data, status = currentState.status, isLoading = currentState.isLoading, isSuccess = currentState.isSuccess, isError = currentState.isError, error = currentState.error;
          reactExports.useDebugValue({
            endpointName,
            data,
            status,
            isLoading,
            isSuccess,
            isError,
            error
          });
          var finalState = reactExports.useMemo(function() {
            return __spreadProps(__spreadValues({}, currentState), { originalArgs, reset });
          }, [currentState, originalArgs, reset]);
          return reactExports.useMemo(function() {
            return [triggerMutation, finalState];
          }, [triggerMutation, finalState]);
        };
      }
    }
    var DefinitionType;
    (function(DefinitionType2) {
      DefinitionType2["query"] = "query";
      DefinitionType2["mutation"] = "mutation";
    })(DefinitionType || (DefinitionType = {}));
    function isQueryDefinition(e2) {
      return e2.type === DefinitionType.query;
    }
    function isMutationDefinition(e2) {
      return e2.type === DefinitionType.mutation;
    }
    function capitalize$1(str) {
      return str.replace(str[0], str[0].toUpperCase());
    }
    function safeAssign(target) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      Object.assign.apply(Object, __spreadArray([target], args));
    }
    var reactHooksModuleName = /* @__PURE__ */ Symbol();
    var reactHooksModule = function(_c) {
      var _d = _c === void 0 ? {} : _c, _e2 = _d.batch, batch2 = _e2 === void 0 ? reactDomExports.unstable_batchedUpdates : _e2, _f = _d.useDispatch, useDispatch$1 = _f === void 0 ? useDispatch : _f, _g = _d.useSelector, useSelector$1 = _g === void 0 ? useSelector : _g, _h = _d.useStore, useStore$1 = _h === void 0 ? useStore : _h, _j = _d.unstable__sideEffectsInRender, unstable__sideEffectsInRender = _j === void 0 ? false : _j;
      return {
        name: reactHooksModuleName,
        init: function(api2, _c2, context) {
          var serializeQueryArgs = _c2.serializeQueryArgs;
          var anyApi = api2;
          var _d2 = buildHooks({
            api: api2,
            moduleOptions: {
              batch: batch2,
              useDispatch: useDispatch$1,
              useSelector: useSelector$1,
              useStore: useStore$1,
              unstable__sideEffectsInRender
            },
            serializeQueryArgs,
            context
          }), buildQueryHooks = _d2.buildQueryHooks, buildMutationHook = _d2.buildMutationHook, usePrefetch = _d2.usePrefetch;
          safeAssign(anyApi, { usePrefetch });
          safeAssign(context, { batch: batch2 });
          return {
            injectEndpoint: function(endpointName, definition) {
              if (isQueryDefinition(definition)) {
                var _c3 = buildQueryHooks(endpointName), useQuery = _c3.useQuery, useLazyQuery = _c3.useLazyQuery, useLazyQuerySubscription = _c3.useLazyQuerySubscription, useQueryState = _c3.useQueryState, useQuerySubscription = _c3.useQuerySubscription;
                safeAssign(anyApi.endpoints[endpointName], {
                  useQuery,
                  useLazyQuery,
                  useLazyQuerySubscription,
                  useQueryState,
                  useQuerySubscription
                });
                api2["use" + capitalize$1(endpointName) + "Query"] = useQuery;
                api2["useLazy" + capitalize$1(endpointName) + "Query"] = useLazyQuery;
              } else if (isMutationDefinition(definition)) {
                var useMutation = buildMutationHook(endpointName);
                safeAssign(anyApi.endpoints[endpointName], {
                  useMutation
                });
                api2["use" + capitalize$1(endpointName) + "Mutation"] = useMutation;
              }
            }
          };
        }
      };
    };
    var createApi = /* @__PURE__ */ buildCreateApi(coreModule(), reactHooksModule());
    const API_URL = "/api/";
    const api = createApi({
      reducerPath: "api",
      tagTypes: [
        "News",
        "NewsById",
        "NewsCategory",
        "Courses",
        "ThemeById",
        "CourseById",
        "ChapterById",
        "LessonById",
        "User",
        "Competition",
        "CourseProgress",
        "NewsByCategory",
        "CompetitionById"
      ],
      baseQuery: fetchBaseQuery({
        baseUrl: API_URL,
        prepareHeaders: (headers, { getState }) => {
          const token2 = getState().auth.token;
          if (token2) {
            headers.set("X-CSRF-Token", token2);
          }
          return headers;
        }
      }),
      endpoints: () => ({})
    });
    const userApi = api.injectEndpoints({
      endpoints: (builder) => ({
        checkUser: builder.query({
          query: () => "whoami",
          providesTags: () => [
            {
              type: "User"
            }
          ]
        })
      }),
      overrideExisting: false
    });
    const selectUser = userApi.endpoints.checkUser.select();
    const { useCheckUserQuery } = userApi;
    const Container$M = st$1.div`
  display: flex;
  align-items: center;
  gap: 10px;
  margin-left: auto;
`;
    const Container$L = st$1.div``;
    const InitialsWrapper = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  border: 1px solid ${(props) => props.theme.colors.greyF1};
  @media ${(props) => props.theme.media.mobile} {
    width: 8.75vw;
    height: 8.75vw;
  }
`;
    const Initials = st$1.p`
width: fit-content;
text-align: center;
font-size: 15px;
font-weight: 400;
line-height: 148%;
text-transform: uppercase;
color: ${(props) => props.theme.colors.mainBlue};
@media ${(props) => props.theme.media.mobile} {
  font-size: 3.125vw;
}
`;
    const getInitials = (fullName) => {
      if (!fullName) {
        return "";
      }
      const [firstName, lastName] = fullName.split(" ");
      if (!lastName || !firstName) {
        return "";
      }
      return `${firstName[0]}${lastName[0]}`;
    };
    function Profile({ userData }) {
      const [initials, setInitials] = reactExports.useState(null);
      reactExports.useEffect(() => {
        if (userData.name) {
          const initials2 = getInitials(userData.name);
          initials2.length > 1 ? setInitials(initials2) : setInitials(null);
        }
      }, [userData.name]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$L, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(InitialsWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Initials, { children: initials }) }) });
    }
    function ProfileBlock() {
      const user = useTypedSelector((state) => {
        var _a;
        return (_a = selectUser(state).data) == null ? void 0 : _a.user;
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$M, { children: user && /* @__PURE__ */ jsxRuntimeExports.jsx(Profile, { userData: user }) });
    }
    const burgerIconOpen = "/assets/burger-icon-open.svg";
    const burgerIconClose = "/assets/burger-icon-close.svg";
    const Button$2 = st$1.button`
  display: none;
  background-color: transparent;
  padding: 0;
  margin: 0;
  width: fit-content;
  @media ${(props) => props.theme.media.mobile} {
    display: block;
  }
`;
    const OpenIcon = st$1(Icon$2)`
  width: 7.5vw;
  height: 7.5vw;
  background-image: url(${burgerIconOpen});
`;
    const CloseIcon = st$1(OpenIcon)`
  background-image: url(${burgerIconClose});
`;
    function BurgerBtn({ onClick: onClick2, isOpen }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { onClick: onClick2, children: isOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {}) });
    }
    const Container$K = st$1.div`
  display: flex;
  align-items: center;
  padding: 3.125%;
  margin-bottom: 5%;
  border-bottom: 1px solid ${(props) => props.theme.colors.greyF1};
`;
    const ProfileWrapper = st$1.div`
  display: flex;
  align-items: center;
  margin-left: auto;
  gap: 3vw;
`;
    const UserName = st$1.div`
  display: flex;
  flex-direction: column;
`;
    const Name = st$1.p`
  font-size: 3.75vw;
  font-weight: 500;
  color: ${(props) => props.theme.colors.dark};
`;
    const Surname = st$1(Name)``;
    const getUsername = (username) => {
      if (!username)
        return null;
      const [firstName, lastName] = username.split(" ");
      if (!firstName || !lastName)
        return null;
      return {
        firstName,
        lastName
      };
    };
    function Head$3({ onClose }) {
      const user = useTypedSelector((state) => {
        var _a;
        return (_a = selectUser(state).data) == null ? void 0 : _a.user;
      });
      const username = getUsername(user == null ? void 0 : user.name);
      reactExports.useEffect(() => {
        setTimeout(() => {
          document.body.addEventListener("click", onClose);
        });
        return () => {
          document.body.removeEventListener("click", onClose);
        };
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$K, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          BurgerBtn,
          {
            isOpen: true,
            onClick: onClose
          }
        ),
        user && /* @__PURE__ */ jsxRuntimeExports.jsxs(ProfileWrapper, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Profile, { userData: user }),
          username && /* @__PURE__ */ jsxRuntimeExports.jsxs(UserName, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Name, { children: username.firstName }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Surname, { children: username.lastName })
          ] })
        ] })
      ] });
    }
    const Container$J = st$1.div`
  display: flex;
  flex-direction: column;
  position: fixed;
  top: 0;
  left: 0;
  z-index: ${(props) => props.theme.utils.zIndex.burgerMenu};
  width: 100vw;
  height: 100%;
  background-color: ${(props) => props.theme.colors.realWhite};
  overflow-y: auto;
`;
    const Container$I = st$1.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5.6vw;
`;
    function Nav({ onClose }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$I, { children: Object.values(NAV_LINKS).map((navLink, index) => /* @__PURE__ */ reactExports.createElement(
        CustomNavLink,
        {
          ...navLink,
          key: index,
          onClick: onClose
        }
      )) });
    }
    const Container$H = st$1.div`
  display: none;
  flex-direction: column;
  padding: 0 3.125%;
  margin-bottom: 5%;
  @media ${(props) => props.theme.media.mobile} {
    display: flex;
  }
`;
    function Body({ onClose }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$H, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Nav, { onClose }) });
    }
    const useAphorism = () => {
      const defaultAphorism = {
        text: "    .",
        author: " "
      };
      const aphorisms = APHORISMS;
      if (!aphorisms || aphorisms.length === 0) {
        return defaultAphorism;
      }
      const randomIndex = Math.floor(Math.random() * aphorisms.length);
      return aphorisms[randomIndex];
    };
    const Container$G = st$1.div`
  display: none;
  @media ${(props) => props.theme.media.mobile} {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 18.75vw;
  }
`;
    const Title$g = st$1.h3`
  margin-bottom: 3.125vw;
  font-size: 3.125vw;
  font-weight: 700;
  line-height: 148%;
  color: ${(props) => props.theme.colors.grey93};
  text-align: center;
`;
    const Aphorism$1 = st$1.p`
  margin-bottom: 9.375vw;
  font-size: 3.75vw;
  font-weight: 500;
  line-height: 148%;
  color: ${(props) => props.theme.colors.realBlack};
  text-align: center;
`;
    const Author$1 = st$1(Aphorism$1)`
  margin-bottom: 0;
  font-weight: 400;
`;
    function Aphorism() {
      const { text, author } = useAphorism();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$G, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$g, { children: " " }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Aphorism$1, { children: text }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Author$1, { children: author })
      ] });
    }
    const Container$F = st$1.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0 3.125% 2.1875vw;
  margin-top: auto;
`;
    const Bottom$1 = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
`;
    const Logo$1 = st$1.img`
  display: block;
  width: 20.25vw;
`;
    const Copyright = st$1.p`
  color: ${(props) => props.theme.colors.dark};
  font-size: 3.125vw;
  font-weight: 400;
  line-height: 148%;
`;
    const logoMobile = "/assets/logo-mobile.svg";
    function Footer$2() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$F, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Aphorism, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Bottom$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Logo$1,
            {
              src: logoMobile,
              alt: "Kaizen"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Copyright, { children: "     () 2023" })
        ] })
      ] });
    }
    function BurgerMenu({ onClose }) {
      const modalRoot = document.querySelector("#modal-root");
      if (!modalRoot)
        return null;
      return ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$J, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Head$3, { onClose }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Body, { onClose }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Footer$2, {})
        ] }),
        modalRoot
      );
    }
    const common = {
      black: "#000",
      white: "#fff"
    };
    const common$1 = common;
    const red = {
      50: "#ffebee",
      100: "#ffcdd2",
      200: "#ef9a9a",
      300: "#e57373",
      400: "#ef5350",
      500: "#f44336",
      600: "#e53935",
      700: "#d32f2f",
      800: "#c62828",
      900: "#b71c1c",
      A100: "#ff8a80",
      A200: "#ff5252",
      A400: "#ff1744",
      A700: "#d50000"
    };
    const red$1 = red;
    const purple = {
      50: "#f3e5f5",
      100: "#e1bee7",
      200: "#ce93d8",
      300: "#ba68c8",
      400: "#ab47bc",
      500: "#9c27b0",
      600: "#8e24aa",
      700: "#7b1fa2",
      800: "#6a1b9a",
      900: "#4a148c",
      A100: "#ea80fc",
      A200: "#e040fb",
      A400: "#d500f9",
      A700: "#aa00ff"
    };
    const purple$1 = purple;
    const blue = {
      50: "#e3f2fd",
      100: "#bbdefb",
      200: "#90caf9",
      300: "#64b5f6",
      400: "#42a5f5",
      500: "#2196f3",
      600: "#1e88e5",
      700: "#1976d2",
      800: "#1565c0",
      900: "#0d47a1",
      A100: "#82b1ff",
      A200: "#448aff",
      A400: "#2979ff",
      A700: "#2962ff"
    };
    const blue$1 = blue;
    const lightBlue = {
      50: "#e1f5fe",
      100: "#b3e5fc",
      200: "#81d4fa",
      300: "#4fc3f7",
      400: "#29b6f6",
      500: "#03a9f4",
      600: "#039be5",
      700: "#0288d1",
      800: "#0277bd",
      900: "#01579b",
      A100: "#80d8ff",
      A200: "#40c4ff",
      A400: "#00b0ff",
      A700: "#0091ea"
    };
    const lightBlue$1 = lightBlue;
    const green = {
      50: "#e8f5e9",
      100: "#c8e6c9",
      200: "#a5d6a7",
      300: "#81c784",
      400: "#66bb6a",
      500: "#4caf50",
      600: "#43a047",
      700: "#388e3c",
      800: "#2e7d32",
      900: "#1b5e20",
      A100: "#b9f6ca",
      A200: "#69f0ae",
      A400: "#00e676",
      A700: "#00c853"
    };
    const green$1 = green;
    const orange = {
      50: "#fff3e0",
      100: "#ffe0b2",
      200: "#ffcc80",
      300: "#ffb74d",
      400: "#ffa726",
      500: "#ff9800",
      600: "#fb8c00",
      700: "#f57c00",
      800: "#ef6c00",
      900: "#e65100",
      A100: "#ffd180",
      A200: "#ffab40",
      A400: "#ff9100",
      A700: "#ff6d00"
    };
    const orange$1 = orange;
    const grey = {
      50: "#fafafa",
      100: "#f5f5f5",
      200: "#eeeeee",
      300: "#e0e0e0",
      400: "#bdbdbd",
      500: "#9e9e9e",
      600: "#757575",
      700: "#616161",
      800: "#424242",
      900: "#212121",
      A100: "#f5f5f5",
      A200: "#eeeeee",
      A400: "#bdbdbd",
      A700: "#616161"
    };
    const grey$1 = grey;
    function isPlainObject(item) {
      return item !== null && typeof item === "object" && item.constructor === Object;
    }
    function deepClone(source) {
      if (!isPlainObject(source)) {
        return source;
      }
      const output = {};
      Object.keys(source).forEach((key) => {
        output[key] = deepClone(source[key]);
      });
      return output;
    }
    function deepmerge(target, source, options = {
      clone: true
    }) {
      const output = options.clone ? _extends$1({}, target) : target;
      if (isPlainObject(target) && isPlainObject(source)) {
        Object.keys(source).forEach((key) => {
          if (key === "__proto__") {
            return;
          }
          if (isPlainObject(source[key]) && key in target && isPlainObject(target[key])) {
            output[key] = deepmerge(target[key], source[key], options);
          } else if (options.clone) {
            output[key] = isPlainObject(source[key]) ? deepClone(source[key]) : source[key];
          } else {
            output[key] = source[key];
          }
        });
      }
      return output;
    }
    function formatMuiErrorMessage(code) {
      let url = "https://mui.com/production-error/?code=" + code;
      for (let i2 = 1; i2 < arguments.length; i2 += 1) {
        url += "&args[]=" + encodeURIComponent(arguments[i2]);
      }
      return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
    }
    function capitalize(string) {
      if (typeof string !== "string") {
        throw new Error(formatMuiErrorMessage(7));
      }
      return string.charAt(0).toUpperCase() + string.slice(1);
    }
    function createChainedFunction(...funcs) {
      return funcs.reduce((acc, func) => {
        if (func == null) {
          return acc;
        }
        return function chainedFunction(...args) {
          acc.apply(this, args);
          func.apply(this, args);
        };
      }, () => {
      });
    }
    function debounce(func, wait = 166) {
      let timeout;
      function debounced(...args) {
        const later = () => {
          func.apply(this, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      }
      debounced.clear = () => {
        clearTimeout(timeout);
      };
      return debounced;
    }
    function ownerDocument(node2) {
      return node2 && node2.ownerDocument || document;
    }
    function ownerWindow(node2) {
      const doc = ownerDocument(node2);
      return doc.defaultView || window;
    }
    function setRef(ref, value) {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref) {
        ref.current = value;
      }
    }
    const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
    const useEnhancedEffect$1 = useEnhancedEffect;
    let globalId = 0;
    function useGlobalId(idOverride) {
      const [defaultId, setDefaultId] = reactExports.useState(idOverride);
      const id2 = idOverride || defaultId;
      reactExports.useEffect(() => {
        if (defaultId == null) {
          globalId += 1;
          setDefaultId(`mui-${globalId}`);
        }
      }, [defaultId]);
      return id2;
    }
    const maybeReactUseId = React$1["useId".toString()];
    function useId(idOverride) {
      if (maybeReactUseId !== void 0) {
        const reactId = maybeReactUseId();
        return idOverride != null ? idOverride : reactId;
      }
      return useGlobalId(idOverride);
    }
    function useControlled({
      controlled,
      default: defaultProp,
      name,
      state = "value"
    }) {
      const {
        current: isControlled
      } = reactExports.useRef(controlled !== void 0);
      const [valueState, setValue] = reactExports.useState(defaultProp);
      const value = isControlled ? controlled : valueState;
      const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
        if (!isControlled) {
          setValue(newValue);
        }
      }, []);
      return [value, setValueIfUncontrolled];
    }
    function useEventCallback(fn2) {
      const ref = reactExports.useRef(fn2);
      useEnhancedEffect$1(() => {
        ref.current = fn2;
      });
      return reactExports.useRef((...args) => (
        // @ts-expect-error hide `this`
        // tslint:disable-next-line:ban-comma-operator
        (0, ref.current)(...args)
      )).current;
    }
    function useForkRef(...refs) {
      return reactExports.useMemo(() => {
        if (refs.every((ref) => ref == null)) {
          return null;
        }
        return (instance) => {
          refs.forEach((ref) => {
            setRef(ref, instance);
          });
        };
      }, refs);
    }
    let hadKeyboardEvent = true;
    let hadFocusVisibleRecently = false;
    let hadFocusVisibleRecentlyTimeout;
    const inputTypesWhitelist = {
      text: true,
      search: true,
      url: true,
      tel: true,
      email: true,
      password: true,
      number: true,
      date: true,
      month: true,
      week: true,
      time: true,
      datetime: true,
      "datetime-local": true
    };
    function focusTriggersKeyboardModality(node2) {
      const {
        type,
        tagName
      } = node2;
      if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
        return true;
      }
      if (tagName === "TEXTAREA" && !node2.readOnly) {
        return true;
      }
      if (node2.isContentEditable) {
        return true;
      }
      return false;
    }
    function handleKeyDown(event) {
      if (event.metaKey || event.altKey || event.ctrlKey) {
        return;
      }
      hadKeyboardEvent = true;
    }
    function handlePointerDown() {
      hadKeyboardEvent = false;
    }
    function handleVisibilityChange() {
      if (this.visibilityState === "hidden") {
        if (hadFocusVisibleRecently) {
          hadKeyboardEvent = true;
        }
      }
    }
    function prepare(doc) {
      doc.addEventListener("keydown", handleKeyDown, true);
      doc.addEventListener("mousedown", handlePointerDown, true);
      doc.addEventListener("pointerdown", handlePointerDown, true);
      doc.addEventListener("touchstart", handlePointerDown, true);
      doc.addEventListener("visibilitychange", handleVisibilityChange, true);
    }
    function isFocusVisible(event) {
      const {
        target
      } = event;
      try {
        return target.matches(":focus-visible");
      } catch (error) {
      }
      return hadKeyboardEvent || focusTriggersKeyboardModality(target);
    }
    function useIsFocusVisible() {
      const ref = reactExports.useCallback((node2) => {
        if (node2 != null) {
          prepare(node2.ownerDocument);
        }
      }, []);
      const isFocusVisibleRef = reactExports.useRef(false);
      function handleBlurVisible() {
        if (isFocusVisibleRef.current) {
          hadFocusVisibleRecently = true;
          window.clearTimeout(hadFocusVisibleRecentlyTimeout);
          hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
            hadFocusVisibleRecently = false;
          }, 100);
          isFocusVisibleRef.current = false;
          return true;
        }
        return false;
      }
      function handleFocusVisible(event) {
        if (isFocusVisible(event)) {
          isFocusVisibleRef.current = true;
          return true;
        }
        return false;
      }
      return {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref
      };
    }
    function getScrollbarSize(doc) {
      const documentWidth = doc.documentElement.clientWidth;
      return Math.abs(window.innerWidth - documentWidth);
    }
    function resolveProps(defaultProps2, props) {
      const output = _extends$1({}, props);
      Object.keys(defaultProps2).forEach((propName) => {
        if (propName.toString().match(/^(components|slots)$/)) {
          output[propName] = _extends$1({}, defaultProps2[propName], output[propName]);
        } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
          const defaultSlotProps = defaultProps2[propName] || {};
          const slotProps = props[propName];
          output[propName] = {};
          if (!slotProps || !Object.keys(slotProps)) {
            output[propName] = defaultSlotProps;
          } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
            output[propName] = slotProps;
          } else {
            output[propName] = _extends$1({}, slotProps);
            Object.keys(defaultSlotProps).forEach((slotPropName) => {
              output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
            });
          }
        } else if (output[propName] === void 0) {
          output[propName] = defaultProps2[propName];
        }
      });
      return output;
    }
    function composeClasses(slots, getUtilityClass, classes2 = void 0) {
      const output = {};
      Object.keys(slots).forEach(
        // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
        // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
        (slot) => {
          output[slot] = slots[slot].reduce((acc, key) => {
            if (key) {
              const utilityClass = getUtilityClass(key);
              if (utilityClass !== "") {
                acc.push(utilityClass);
              }
              if (classes2 && classes2[key]) {
                acc.push(classes2[key]);
              }
            }
            return acc;
          }, []).join(" ");
        }
      );
      return output;
    }
    const defaultGenerator = (componentName) => componentName;
    const createClassNameGenerator = () => {
      let generate = defaultGenerator;
      return {
        configure(generator) {
          generate = generator;
        },
        generate(componentName) {
          return generate(componentName);
        },
        reset() {
          generate = defaultGenerator;
        }
      };
    };
    const ClassNameGenerator = createClassNameGenerator();
    const ClassNameGenerator$1 = ClassNameGenerator;
    const globalStateClassesMapping = {
      active: "active",
      checked: "checked",
      completed: "completed",
      disabled: "disabled",
      error: "error",
      expanded: "expanded",
      focused: "focused",
      focusVisible: "focusVisible",
      open: "open",
      readOnly: "readOnly",
      required: "required",
      selected: "selected"
    };
    function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
      const globalStateClass = globalStateClassesMapping[slot];
      return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
    }
    function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
      const result = {};
      slots.forEach((slot) => {
        result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
      });
      return result;
    }
    const THEME_ID = "$$material";
    function sheetForTag(tag) {
      if (tag.sheet) {
        return tag.sheet;
      }
      for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
        if (document.styleSheets[i2].ownerNode === tag) {
          return document.styleSheets[i2];
        }
      }
    }
    function createStyleElement(options) {
      var tag = document.createElement("style");
      tag.setAttribute("data-emotion", options.key);
      if (options.nonce !== void 0) {
        tag.setAttribute("nonce", options.nonce);
      }
      tag.appendChild(document.createTextNode(""));
      tag.setAttribute("data-s", "");
      return tag;
    }
    var StyleSheet = /* @__PURE__ */ function() {
      function StyleSheet2(options) {
        var _this = this;
        this._insertTag = function(tag) {
          var before;
          if (_this.tags.length === 0) {
            if (_this.insertionPoint) {
              before = _this.insertionPoint.nextSibling;
            } else if (_this.prepend) {
              before = _this.container.firstChild;
            } else {
              before = _this.before;
            }
          } else {
            before = _this.tags[_this.tags.length - 1].nextSibling;
          }
          _this.container.insertBefore(tag, before);
          _this.tags.push(tag);
        };
        this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
        this.tags = [];
        this.ctr = 0;
        this.nonce = options.nonce;
        this.key = options.key;
        this.container = options.container;
        this.prepend = options.prepend;
        this.insertionPoint = options.insertionPoint;
        this.before = null;
      }
      var _proto = StyleSheet2.prototype;
      _proto.hydrate = function hydrate(nodes) {
        nodes.forEach(this._insertTag);
      };
      _proto.insert = function insert(rule) {
        if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
          this._insertTag(createStyleElement(this));
        }
        var tag = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
          var sheet = sheetForTag(tag);
          try {
            sheet.insertRule(rule, sheet.cssRules.length);
          } catch (e2) {
          }
        } else {
          tag.appendChild(document.createTextNode(rule));
        }
        this.ctr++;
      };
      _proto.flush = function flush() {
        this.tags.forEach(function(tag) {
          return tag.parentNode && tag.parentNode.removeChild(tag);
        });
        this.tags = [];
        this.ctr = 0;
      };
      return StyleSheet2;
    }();
    var MS = "-ms-";
    var MOZ = "-moz-";
    var WEBKIT = "-webkit-";
    var COMMENT = "comm";
    var RULESET = "rule";
    var DECLARATION = "decl";
    var IMPORT = "@import";
    var KEYFRAMES = "@keyframes";
    var LAYER = "@layer";
    var abs = Math.abs;
    var from = String.fromCharCode;
    var assign = Object.assign;
    function hash(value, length2) {
      return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
    }
    function trim(value) {
      return value.trim();
    }
    function match(value, pattern) {
      return (value = pattern.exec(value)) ? value[0] : value;
    }
    function replace(value, pattern, replacement) {
      return value.replace(pattern, replacement);
    }
    function indexof(value, search) {
      return value.indexOf(search);
    }
    function charat(value, index) {
      return value.charCodeAt(index) | 0;
    }
    function substr(value, begin, end) {
      return value.slice(begin, end);
    }
    function strlen(value) {
      return value.length;
    }
    function sizeof(value) {
      return value.length;
    }
    function append(value, array) {
      return array.push(value), value;
    }
    function combine(array, callback) {
      return array.map(callback).join("");
    }
    var line = 1;
    var column = 1;
    var length = 0;
    var position = 0;
    var character = 0;
    var characters = "";
    function node(value, root, parent, type, props, children, length2) {
      return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
    }
    function copy(root, props) {
      return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
    }
    function char() {
      return character;
    }
    function prev() {
      character = position > 0 ? charat(characters, --position) : 0;
      if (column--, character === 10)
        column = 1, line--;
      return character;
    }
    function next() {
      character = position < length ? charat(characters, position++) : 0;
      if (column++, character === 10)
        column = 1, line++;
      return character;
    }
    function peek() {
      return charat(characters, position);
    }
    function caret() {
      return position;
    }
    function slice(begin, end) {
      return substr(characters, begin, end);
    }
    function token(type) {
      switch (type) {
        case 0:
        case 9:
        case 10:
        case 13:
        case 32:
          return 5;
        case 33:
        case 43:
        case 44:
        case 47:
        case 62:
        case 64:
        case 126:
        case 59:
        case 123:
        case 125:
          return 4;
        case 58:
          return 3;
        case 34:
        case 39:
        case 40:
        case 91:
          return 2;
        case 41:
        case 93:
          return 1;
      }
      return 0;
    }
    function alloc(value) {
      return line = column = 1, length = strlen(characters = value), position = 0, [];
    }
    function dealloc(value) {
      return characters = "", value;
    }
    function delimit(type) {
      return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
    }
    function whitespace(type) {
      while (character = peek())
        if (character < 33)
          next();
        else
          break;
      return token(type) > 2 || token(character) > 3 ? "" : " ";
    }
    function escaping(index, count) {
      while (--count && next())
        if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
          break;
      return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
    }
    function delimiter(type) {
      while (next())
        switch (character) {
          case type:
            return position;
          case 34:
          case 39:
            if (type !== 34 && type !== 39)
              delimiter(character);
            break;
          case 40:
            if (type === 41)
              delimiter(type);
            break;
          case 92:
            next();
            break;
        }
      return position;
    }
    function commenter(type, index) {
      while (next())
        if (type + character === 47 + 10)
          break;
        else if (type + character === 42 + 42 && peek() === 47)
          break;
      return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
    }
    function identifier(index) {
      while (!token(peek()))
        next();
      return slice(index, position);
    }
    function compile(value) {
      return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
    }
    function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
      var index = 0;
      var offset = 0;
      var length2 = pseudo;
      var atrule = 0;
      var property = 0;
      var previous = 0;
      var variable = 1;
      var scanning = 1;
      var ampersand = 1;
      var character2 = 0;
      var type = "";
      var props = rules;
      var children = rulesets;
      var reference = rule;
      var characters2 = type;
      while (scanning)
        switch (previous = character2, character2 = next()) {
          case 40:
            if (previous != 108 && charat(characters2, length2 - 1) == 58) {
              if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
                ampersand = -1;
              break;
            }
          case 34:
          case 39:
          case 91:
            characters2 += delimit(character2);
            break;
          case 9:
          case 10:
          case 13:
          case 32:
            characters2 += whitespace(previous);
            break;
          case 92:
            characters2 += escaping(caret() - 1, 7);
            continue;
          case 47:
            switch (peek()) {
              case 42:
              case 47:
                append(comment(commenter(next(), caret()), root, parent), declarations);
                break;
              default:
                characters2 += "/";
            }
            break;
          case 123 * variable:
            points[index++] = strlen(characters2) * ampersand;
          case 125 * variable:
          case 59:
          case 0:
            switch (character2) {
              case 0:
              case 125:
                scanning = 0;
              case 59 + offset:
                if (ampersand == -1)
                  characters2 = replace(characters2, /\f/g, "");
                if (property > 0 && strlen(characters2) - length2)
                  append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
                break;
              case 59:
                characters2 += ";";
              default:
                append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
                if (character2 === 123)
                  if (offset === 0)
                    parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
                  else
                    switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                      case 100:
                      case 108:
                      case 109:
                      case 115:
                        parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                        break;
                      default:
                        parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                    }
            }
            index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
            break;
          case 58:
            length2 = 1 + strlen(characters2), property = previous;
          default:
            if (variable < 1) {
              if (character2 == 123)
                --variable;
              else if (character2 == 125 && variable++ == 0 && prev() == 125)
                continue;
            }
            switch (characters2 += from(character2), character2 * variable) {
              case 38:
                ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
                break;
              case 44:
                points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
                break;
              case 64:
                if (peek() === 45)
                  characters2 += delimit(next());
                atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
                break;
              case 45:
                if (previous === 45 && strlen(characters2) == 2)
                  variable = 0;
            }
        }
      return rulesets;
    }
    function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length2) {
      var post = offset - 1;
      var rule = offset === 0 ? rules : [""];
      var size = sizeof(rule);
      for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
        for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
          if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
            props[k2++] = z2;
      return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
    }
    function comment(value, root, parent) {
      return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
    }
    function declaration(value, root, parent, length2) {
      return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
    }
    function serialize(children, callback) {
      var output = "";
      var length2 = sizeof(children);
      for (var i2 = 0; i2 < length2; i2++)
        output += callback(children[i2], i2, children, callback) || "";
      return output;
    }
    function stringify(element, index, children, callback) {
      switch (element.type) {
        case LAYER:
          if (element.children.length)
            break;
        case IMPORT:
        case DECLARATION:
          return element.return = element.return || element.value;
        case COMMENT:
          return "";
        case KEYFRAMES:
          return element.return = element.value + "{" + serialize(element.children, callback) + "}";
        case RULESET:
          element.value = element.props.join(",");
      }
      return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
    }
    function middleware(collection) {
      var length2 = sizeof(collection);
      return function(element, index, children, callback) {
        var output = "";
        for (var i2 = 0; i2 < length2; i2++)
          output += collection[i2](element, index, children, callback) || "";
        return output;
      };
    }
    function rulesheet(callback) {
      return function(element) {
        if (!element.root) {
          if (element = element.return)
            callback(element);
        }
      };
    }
    var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
      var previous = 0;
      var character2 = 0;
      while (true) {
        previous = character2;
        character2 = peek();
        if (previous === 38 && character2 === 12) {
          points[index] = 1;
        }
        if (token(character2)) {
          break;
        }
        next();
      }
      return slice(begin, position);
    };
    var toRules = function toRules2(parsed, points) {
      var index = -1;
      var character2 = 44;
      do {
        switch (token(character2)) {
          case 0:
            if (character2 === 38 && peek() === 12) {
              points[index] = 1;
            }
            parsed[index] += identifierWithPointTracking(position - 1, points, index);
            break;
          case 2:
            parsed[index] += delimit(character2);
            break;
          case 4:
            if (character2 === 44) {
              parsed[++index] = peek() === 58 ? "&\f" : "";
              points[index] = parsed[index].length;
              break;
            }
          default:
            parsed[index] += from(character2);
        }
      } while (character2 = next());
      return parsed;
    };
    var getRules = function getRules2(value, points) {
      return dealloc(toRules(alloc(value), points));
    };
    var fixedElements = /* @__PURE__ */ new WeakMap();
    var compat = function compat2(element) {
      if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
      // negative .length indicates that this rule has been already prefixed
      element.length < 1) {
        return;
      }
      var value = element.value, parent = element.parent;
      var isImplicitRule = element.column === parent.column && element.line === parent.line;
      while (parent.type !== "rule") {
        parent = parent.parent;
        if (!parent)
          return;
      }
      if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
        return;
      }
      if (isImplicitRule) {
        return;
      }
      fixedElements.set(element, true);
      var points = [];
      var rules = getRules(value, points);
      var parentRules = parent.props;
      for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
        for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
          element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
        }
      }
    };
    var removeLabel = function removeLabel2(element) {
      if (element.type === "decl") {
        var value = element.value;
        if (
          // charcode for l
          value.charCodeAt(0) === 108 && // charcode for b
          value.charCodeAt(2) === 98
        ) {
          element["return"] = "";
          element.value = "";
        }
      }
    };
    function prefix(value, length2) {
      switch (hash(value, length2)) {
        case 5103:
          return WEBKIT + "print-" + value + value;
        case 5737:
        case 4201:
        case 3177:
        case 3433:
        case 1641:
        case 4457:
        case 2921:
        case 5572:
        case 6356:
        case 5844:
        case 3191:
        case 6645:
        case 3005:
        case 6391:
        case 5879:
        case 5623:
        case 6135:
        case 4599:
        case 4855:
        case 4215:
        case 6389:
        case 5109:
        case 5365:
        case 5621:
        case 3829:
          return WEBKIT + value + value;
        case 5349:
        case 4246:
        case 4810:
        case 6968:
        case 2756:
          return WEBKIT + value + MOZ + value + MS + value + value;
        case 6828:
        case 4268:
          return WEBKIT + value + MS + value + value;
        case 6165:
          return WEBKIT + value + MS + "flex-" + value + value;
        case 5187:
          return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
        case 5443:
          return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
        case 4675:
          return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
        case 5548:
          return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
        case 5292:
          return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
        case 6060:
          return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
        case 4554:
          return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
        case 6187:
          return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
        case 5495:
        case 3959:
          return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
        case 4968:
          return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
        case 4095:
        case 3583:
        case 4068:
        case 2532:
          return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
        case 8116:
        case 7059:
        case 5753:
        case 5535:
        case 5445:
        case 5701:
        case 4933:
        case 4677:
        case 5533:
        case 5789:
        case 5021:
        case 4765:
          if (strlen(value) - 1 - length2 > 6)
            switch (charat(value, length2 + 1)) {
              case 109:
                if (charat(value, length2 + 4) !== 45)
                  break;
              case 102:
                return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
              case 115:
                return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
            }
          break;
        case 4949:
          if (charat(value, length2 + 1) !== 115)
            break;
        case 6444:
          switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
            case 107:
              return replace(value, ":", ":" + WEBKIT) + value;
            case 101:
              return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
          }
          break;
        case 5936:
          switch (charat(value, length2 + 11)) {
            case 114:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
            case 108:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
            case 45:
              return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
          }
          return WEBKIT + value + MS + value + value;
      }
      return value;
    }
    var prefixer = function prefixer2(element, index, children, callback) {
      if (element.length > -1) {
        if (!element["return"])
          switch (element.type) {
            case DECLARATION:
              element["return"] = prefix(element.value, element.length);
              break;
            case KEYFRAMES:
              return serialize([copy(element, {
                value: replace(element.value, "@", "@" + WEBKIT)
              })], callback);
            case RULESET:
              if (element.length)
                return combine(element.props, function(value) {
                  switch (match(value, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                      return serialize([copy(element, {
                        props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                      })], callback);
                    case "::placeholder":
                      return serialize([copy(element, {
                        props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                      }), copy(element, {
                        props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                      }), copy(element, {
                        props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                      })], callback);
                  }
                  return "";
                });
          }
      }
    };
    var defaultStylisPlugins = [prefixer];
    var createCache = function createCache2(options) {
      var key = options.key;
      if (key === "css") {
        var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(ssrStyles, function(node2) {
          var dataEmotionAttribute = node2.getAttribute("data-emotion");
          if (dataEmotionAttribute.indexOf(" ") === -1) {
            return;
          }
          document.head.appendChild(node2);
          node2.setAttribute("data-s", "");
        });
      }
      var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
      var inserted = {};
      var container;
      var nodesToHydrate = [];
      {
        container = options.container || document.head;
        Array.prototype.forEach.call(
          // this means we will ignore elements which don't have a space in them which
          // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
          document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
          function(node2) {
            var attrib = node2.getAttribute("data-emotion").split(" ");
            for (var i2 = 1; i2 < attrib.length; i2++) {
              inserted[attrib[i2]] = true;
            }
            nodesToHydrate.push(node2);
          }
        );
      }
      var _insert;
      var omnipresentPlugins = [compat, removeLabel];
      {
        var currentSheet;
        var finalizingPlugins = [stringify, rulesheet(function(rule) {
          currentSheet.insert(rule);
        })];
        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
        var stylis = function stylis2(styles2) {
          return serialize(compile(styles2), serializer);
        };
        _insert = function insert(selector, serialized, sheet, shouldCache) {
          currentSheet = sheet;
          stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
          if (shouldCache) {
            cache2.inserted[serialized.name] = true;
          }
        };
      }
      var cache2 = {
        key,
        sheet: new StyleSheet({
          key,
          container,
          nonce: options.nonce,
          speedy: options.speedy,
          prepend: options.prepend,
          insertionPoint: options.insertionPoint
        }),
        nonce: options.nonce,
        inserted,
        registered: {},
        insert: _insert
      };
      cache2.sheet.hydrate(nodesToHydrate);
      return cache2;
    };
    var isBrowser = true;
    function getRegisteredStyles(registered, registeredStyles, classNames) {
      var rawClassName = "";
      classNames.split(" ").forEach(function(className) {
        if (registered[className] !== void 0) {
          registeredStyles.push(registered[className] + ";");
        } else {
          rawClassName += className + " ";
        }
      });
      return rawClassName;
    }
    var registerStyles = function registerStyles2(cache2, serialized, isStringTag2) {
      var className = cache2.key + "-" + serialized.name;
      if (
        // we only need to add the styles to the registered cache if the
        // class name could be used further down
        // the tree but if it's a string tag, we know it won't
        // so we don't have to add it to registered cache.
        // this improves memory usage since we can avoid storing the whole style string
        (isStringTag2 === false || // we need to always store it if we're in compat mode and
        // in node since emotion-server relies on whether a style is in
        // the registered cache to know whether a style is global or not
        // also, note that this check will be dead code eliminated in the browser
        isBrowser === false) && cache2.registered[className] === void 0
      ) {
        cache2.registered[className] = serialized.styles;
      }
    };
    var insertStyles = function insertStyles2(cache2, serialized, isStringTag2) {
      registerStyles(cache2, serialized, isStringTag2);
      var className = cache2.key + "-" + serialized.name;
      if (cache2.inserted[serialized.name] === void 0) {
        var current = serialized;
        do {
          cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
          current = current.next;
        } while (current !== void 0);
      }
    };
    function murmur2(str) {
      var h2 = 0;
      var k2, i2 = 0, len = str.length;
      for (; len >= 4; ++i2, len -= 4) {
        k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
        k2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
        k2 ^= /* k >>> r: */
        k2 >>> 24;
        h2 = /* Math.imul(k, m): */
        (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      switch (len) {
        case 3:
          h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
        case 2:
          h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
        case 1:
          h2 ^= str.charCodeAt(i2) & 255;
          h2 = /* Math.imul(h, m): */
          (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      }
      h2 ^= h2 >>> 13;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
      return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
    }
    var hyphenateRegex = /[A-Z]|^ms/g;
    var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
    var isCustomProperty = function isCustomProperty2(property) {
      return property.charCodeAt(1) === 45;
    };
    var isProcessableValue = function isProcessableValue2(value) {
      return value != null && typeof value !== "boolean";
    };
    var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
      return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
    });
    var processStyleValue = function processStyleValue2(key, value) {
      switch (key) {
        case "animation":
        case "animationName": {
          if (typeof value === "string") {
            return value.replace(animationRegex, function(match2, p1, p2) {
              cursor = {
                name: p1,
                styles: p2,
                next: cursor
              };
              return p1;
            });
          }
        }
      }
      if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
        return value + "px";
      }
      return value;
    };
    var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
    function handleInterpolation(mergedProps, registered, interpolation) {
      if (interpolation == null) {
        return "";
      }
      if (interpolation.__emotion_styles !== void 0) {
        return interpolation;
      }
      switch (typeof interpolation) {
        case "boolean": {
          return "";
        }
        case "object": {
          if (interpolation.anim === 1) {
            cursor = {
              name: interpolation.name,
              styles: interpolation.styles,
              next: cursor
            };
            return interpolation.name;
          }
          if (interpolation.styles !== void 0) {
            var next2 = interpolation.next;
            if (next2 !== void 0) {
              while (next2 !== void 0) {
                cursor = {
                  name: next2.name,
                  styles: next2.styles,
                  next: cursor
                };
                next2 = next2.next;
              }
            }
            var styles2 = interpolation.styles + ";";
            return styles2;
          }
          return createStringFromObject(mergedProps, registered, interpolation);
        }
        case "function": {
          if (mergedProps !== void 0) {
            var previousCursor = cursor;
            var result = interpolation(mergedProps);
            cursor = previousCursor;
            return handleInterpolation(mergedProps, registered, result);
          }
          break;
        }
      }
      if (registered == null) {
        return interpolation;
      }
      var cached = registered[interpolation];
      return cached !== void 0 ? cached : interpolation;
    }
    function createStringFromObject(mergedProps, registered, obj) {
      var string = "";
      if (Array.isArray(obj)) {
        for (var i2 = 0; i2 < obj.length; i2++) {
          string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
        }
      } else {
        for (var _key in obj) {
          var value = obj[_key];
          if (typeof value !== "object") {
            if (registered != null && registered[value] !== void 0) {
              string += _key + "{" + registered[value] + "}";
            } else if (isProcessableValue(value)) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
            }
          } else {
            if (_key === "NO_COMPONENT_SELECTOR" && false) {
              throw new Error(noComponentSelectorMessage);
            }
            if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
              for (var _i = 0; _i < value.length; _i++) {
                if (isProcessableValue(value[_i])) {
                  string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
                }
              }
            } else {
              var interpolated = handleInterpolation(mergedProps, registered, value);
              switch (_key) {
                case "animation":
                case "animationName": {
                  string += processStyleName(_key) + ":" + interpolated + ";";
                  break;
                }
                default: {
                  string += _key + "{" + interpolated + "}";
                }
              }
            }
          }
        }
      }
      return string;
    }
    var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
    var cursor;
    var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
      if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
        return args[0];
      }
      var stringMode = true;
      var styles2 = "";
      cursor = void 0;
      var strings = args[0];
      if (strings == null || strings.raw === void 0) {
        stringMode = false;
        styles2 += handleInterpolation(mergedProps, registered, strings);
      } else {
        styles2 += strings[0];
      }
      for (var i2 = 1; i2 < args.length; i2++) {
        styles2 += handleInterpolation(mergedProps, registered, args[i2]);
        if (stringMode) {
          styles2 += strings[i2];
        }
      }
      labelPattern.lastIndex = 0;
      var identifierName = "";
      var match2;
      while ((match2 = labelPattern.exec(styles2)) !== null) {
        identifierName += "-" + // $FlowFixMe we know it's not null
        match2[1];
      }
      var name = murmur2(styles2) + identifierName;
      return {
        name,
        styles: styles2,
        next: cursor
      };
    };
    var syncFallback = function syncFallback2(create) {
      return create();
    };
    var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
    var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
    var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
    var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
      // we're doing this to avoid preconstruct's dead code elimination in this one case
      // because this module is primarily intended for the browser and node
      // but it's also required in react native and similar environments sometimes
      // and we could have a special build just for that
      // but this is much easier and the native packages
      // might use a different theme context in the future anyway
      typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
        key: "css"
      }) : null
    );
    EmotionCacheContext.Provider;
    var withEmotionCache = function withEmotionCache2(func) {
      return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
        var cache2 = reactExports.useContext(EmotionCacheContext);
        return func(props, cache2, ref);
      });
    };
    var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
    var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
      var styles2 = props.styles;
      var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
      var sheetRef = reactExports.useRef();
      useInsertionEffectWithLayoutFallback(function() {
        var key = cache2.key + "-global";
        var sheet = new cache2.sheet.constructor({
          key,
          nonce: cache2.sheet.nonce,
          container: cache2.sheet.container,
          speedy: cache2.sheet.isSpeedy
        });
        var rehydrating = false;
        var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
        if (cache2.sheet.tags.length) {
          sheet.before = cache2.sheet.tags[0];
        }
        if (node2 !== null) {
          rehydrating = true;
          node2.setAttribute("data-emotion", key);
          sheet.hydrate([node2]);
        }
        sheetRef.current = [sheet, rehydrating];
        return function() {
          sheet.flush();
        };
      }, [cache2]);
      useInsertionEffectWithLayoutFallback(function() {
        var sheetRefCurrent = sheetRef.current;
        var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
        if (rehydrating) {
          sheetRefCurrent[1] = false;
          return;
        }
        if (serialized.next !== void 0) {
          insertStyles(cache2, serialized.next, true);
        }
        if (sheet.tags.length) {
          var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
          sheet.before = element;
          sheet.flush();
        }
        cache2.insert("", serialized, sheet, false);
      }, [cache2, serialized.name]);
      return null;
    });
    function css() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return serializeStyles(args);
    }
    var keyframes = function keyframes2() {
      var insertable = css.apply(void 0, arguments);
      var name = "animation-" + insertable.name;
      return {
        name,
        styles: "@keyframes " + name + "{" + insertable.styles + "}",
        anim: 1,
        toString: function toString() {
          return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
        }
      };
    };
    var testOmitPropsOnStringTag = isPropValid;
    var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
      return key !== "theme";
    };
    var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
      return typeof tag === "string" && // 96 is one less than the char code
      // for "a" so this is checking that
      // it's a lowercase character
      tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
    };
    var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
      var shouldForwardProp2;
      if (options) {
        var optionsShouldForwardProp = options.shouldForwardProp;
        shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
          return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
        } : optionsShouldForwardProp;
      }
      if (typeof shouldForwardProp2 !== "function" && isReal) {
        shouldForwardProp2 = tag.__emotion_forwardProp;
      }
      return shouldForwardProp2;
    };
    var Insertion = function Insertion2(_ref) {
      var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
      registerStyles(cache2, serialized, isStringTag2);
      useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(cache2, serialized, isStringTag2);
      });
      return null;
    };
    var createStyled$1 = function createStyled2(tag, options) {
      var isReal = tag.__emotion_real === tag;
      var baseTag = isReal && tag.__emotion_base || tag;
      var identifierName;
      var targetClassName;
      if (options !== void 0) {
        identifierName = options.label;
        targetClassName = options.target;
      }
      var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
      var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
      var shouldUseAs = !defaultShouldForwardProp("as");
      return function() {
        var args = arguments;
        var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
        if (identifierName !== void 0) {
          styles2.push("label:" + identifierName + ";");
        }
        if (args[0] == null || args[0].raw === void 0) {
          styles2.push.apply(styles2, args);
        } else {
          styles2.push(args[0][0]);
          var len = args.length;
          var i2 = 1;
          for (; i2 < len; i2++) {
            styles2.push(args[i2], args[0][i2]);
          }
        }
        var Styled = withEmotionCache(function(props, cache2, ref) {
          var FinalTag = shouldUseAs && props.as || baseTag;
          var className = "";
          var classInterpolations = [];
          var mergedProps = props;
          if (props.theme == null) {
            mergedProps = {};
            for (var key in props) {
              mergedProps[key] = props[key];
            }
            mergedProps.theme = reactExports.useContext(ThemeContext);
          }
          if (typeof props.className === "string") {
            className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
          } else if (props.className != null) {
            className = props.className + " ";
          }
          var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
          className += cache2.key + "-" + serialized.name;
          if (targetClassName !== void 0) {
            className += " " + targetClassName;
          }
          var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
          var newProps = {};
          for (var _key in props) {
            if (shouldUseAs && _key === "as")
              continue;
            if (
              // $FlowFixMe
              finalShouldForwardProp(_key)
            ) {
              newProps[_key] = props[_key];
            }
          }
          newProps.className = className;
          newProps.ref = ref;
          return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
            cache: cache2,
            serialized,
            isStringTag: typeof FinalTag === "string"
          }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
        });
        Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
        Styled.defaultProps = tag.defaultProps;
        Styled.__emotion_real = Styled;
        Styled.__emotion_base = baseTag;
        Styled.__emotion_styles = styles2;
        Styled.__emotion_forwardProp = shouldForwardProp2;
        Object.defineProperty(Styled, "toString", {
          value: function value() {
            if (targetClassName === void 0 && false) {
              return "NO_COMPONENT_SELECTOR";
            }
            return "." + targetClassName;
          }
        });
        Styled.withComponent = function(nextTag, nextOptions) {
          return createStyled2(nextTag, _extends$1({}, options, nextOptions, {
            shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
          })).apply(void 0, styles2);
        };
        return Styled;
      };
    };
    var tags = [
      "a",
      "abbr",
      "address",
      "area",
      "article",
      "aside",
      "audio",
      "b",
      "base",
      "bdi",
      "bdo",
      "big",
      "blockquote",
      "body",
      "br",
      "button",
      "canvas",
      "caption",
      "cite",
      "code",
      "col",
      "colgroup",
      "data",
      "datalist",
      "dd",
      "del",
      "details",
      "dfn",
      "dialog",
      "div",
      "dl",
      "dt",
      "em",
      "embed",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hgroup",
      "hr",
      "html",
      "i",
      "iframe",
      "img",
      "input",
      "ins",
      "kbd",
      "keygen",
      "label",
      "legend",
      "li",
      "link",
      "main",
      "map",
      "mark",
      "marquee",
      "menu",
      "menuitem",
      "meta",
      "meter",
      "nav",
      "noscript",
      "object",
      "ol",
      "optgroup",
      "option",
      "output",
      "p",
      "param",
      "picture",
      "pre",
      "progress",
      "q",
      "rp",
      "rt",
      "ruby",
      "s",
      "samp",
      "script",
      "section",
      "select",
      "small",
      "source",
      "span",
      "strong",
      "style",
      "sub",
      "summary",
      "sup",
      "table",
      "tbody",
      "td",
      "textarea",
      "tfoot",
      "th",
      "thead",
      "time",
      "title",
      "tr",
      "track",
      "u",
      "ul",
      "var",
      "video",
      "wbr",
      // SVG
      "circle",
      "clipPath",
      "defs",
      "ellipse",
      "foreignObject",
      "g",
      "image",
      "line",
      "linearGradient",
      "mask",
      "path",
      "pattern",
      "polygon",
      "polyline",
      "radialGradient",
      "rect",
      "stop",
      "svg",
      "text",
      "tspan"
    ];
    var newStyled = createStyled$1.bind();
    tags.forEach(function(tagName) {
      newStyled[tagName] = newStyled(tagName);
    });
    function isEmpty$4(obj) {
      return obj === void 0 || obj === null || Object.keys(obj).length === 0;
    }
    function GlobalStyles$2(props) {
      const {
        styles: styles2,
        defaultTheme: defaultTheme2 = {}
      } = props;
      const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$4(themeInput) ? defaultTheme2 : themeInput) : styles2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
        styles: globalStyles
      });
    }
    /**
     * @mui/styled-engine v5.14.18
     *
     * @license MIT
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    function styled$2(tag, options) {
      const stylesFactory = newStyled(tag, options);
      return stylesFactory;
    }
    const internal_processStyles = (tag, processor) => {
      if (Array.isArray(tag.__emotion_styles)) {
        tag.__emotion_styles = processor(tag.__emotion_styles);
      }
    };
    const _excluded$y = ["values", "unit", "step"];
    const sortBreakpointsValues = (values2) => {
      const breakpointsAsArray = Object.keys(values2).map((key) => ({
        key,
        val: values2[key]
      })) || [];
      breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
      return breakpointsAsArray.reduce((acc, obj) => {
        return _extends$1({}, acc, {
          [obj.key]: obj.val
        });
      }, {});
    };
    function createBreakpoints(breakpoints2) {
      const {
        // The breakpoint **start** at this value.
        // For instance with the first breakpoint xs: [xs, sm).
        values: values2 = {
          xs: 0,
          // phone
          sm: 600,
          // tablet
          md: 900,
          // small laptop
          lg: 1200,
          // desktop
          xl: 1536
          // large screen
        },
        unit = "px",
        step = 5
      } = breakpoints2, other = _objectWithoutPropertiesLoose(breakpoints2, _excluded$y);
      const sortedValues = sortBreakpointsValues(values2);
      const keys = Object.keys(sortedValues);
      function up(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (min-width:${value}${unit})`;
      }
      function down(key) {
        const value = typeof values2[key] === "number" ? values2[key] : key;
        return `@media (max-width:${value - step / 100}${unit})`;
      }
      function between(start, end) {
        const endIndex = keys.indexOf(end);
        return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
      }
      function only(key) {
        if (keys.indexOf(key) + 1 < keys.length) {
          return between(key, keys[keys.indexOf(key) + 1]);
        }
        return up(key);
      }
      function not(key) {
        const keyIndex = keys.indexOf(key);
        if (keyIndex === 0) {
          return up(keys[1]);
        }
        if (keyIndex === keys.length - 1) {
          return down(keys[keyIndex]);
        }
        return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
      }
      return _extends$1({
        keys,
        values: sortedValues,
        up,
        down,
        between,
        only,
        not,
        unit
      }, other);
    }
    const shape = {
      borderRadius: 4
    };
    const shape$1 = shape;
    function merge(acc, item) {
      if (!item) {
        return acc;
      }
      return deepmerge(acc, item, {
        clone: false
        // No need to clone deep, it's way faster.
      });
    }
    const values$1 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    };
    const defaultBreakpoints = {
      // Sorted ASC by size. That's important.
      // It can't be configured as it's used statically for propTypes.
      keys: ["xs", "sm", "md", "lg", "xl"],
      up: (key) => `@media (min-width:${values$1[key]}px)`
    };
    function handleBreakpoints(props, propValue, styleFromPropValue) {
      const theme = props.theme || {};
      if (Array.isArray(propValue)) {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return propValue.reduce((acc, item, index) => {
          acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
          return acc;
        }, {});
      }
      if (typeof propValue === "object") {
        const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
        return Object.keys(propValue).reduce((acc, breakpoint) => {
          if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
            const mediaKey = themeBreakpoints.up(breakpoint);
            acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
          } else {
            const cssKey = breakpoint;
            acc[cssKey] = propValue[cssKey];
          }
          return acc;
        }, {});
      }
      const output = styleFromPropValue(propValue);
      return output;
    }
    function createEmptyBreakpointObject(breakpointsInput = {}) {
      var _breakpointsInput$key;
      const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
        const breakpointStyleKey = breakpointsInput.up(key);
        acc[breakpointStyleKey] = {};
        return acc;
      }, {});
      return breakpointsInOrder || {};
    }
    function removeUnusedBreakpoints(breakpointKeys, style2) {
      return breakpointKeys.reduce((acc, key) => {
        const breakpointOutput = acc[key];
        const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
        if (isBreakpointUnused) {
          delete acc[key];
        }
        return acc;
      }, style2);
    }
    function getPath(obj, path, checkVars = true) {
      if (!path || typeof path !== "string") {
        return null;
      }
      if (obj && obj.vars && checkVars) {
        const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
        if (val != null) {
          return val;
        }
      }
      return path.split(".").reduce((acc, item) => {
        if (acc && acc[item] != null) {
          return acc[item];
        }
        return null;
      }, obj);
    }
    function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
      let value;
      if (typeof themeMapping === "function") {
        value = themeMapping(propValueFinal);
      } else if (Array.isArray(themeMapping)) {
        value = themeMapping[propValueFinal] || userValue;
      } else {
        value = getPath(themeMapping, propValueFinal) || userValue;
      }
      if (transform) {
        value = transform(value, userValue, themeMapping);
      }
      return value;
    }
    function style$1(options) {
      const {
        prop,
        cssProperty = options.prop,
        themeKey,
        transform
      } = options;
      const fn2 = (props) => {
        if (props[prop] == null) {
          return null;
        }
        const propValue = props[prop];
        const theme = props.theme;
        const themeMapping = getPath(theme, themeKey) || {};
        const styleFromPropValue = (propValueFinal) => {
          let value = getStyleValue$1(themeMapping, transform, propValueFinal);
          if (propValueFinal === value && typeof propValueFinal === "string") {
            value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
          }
          if (cssProperty === false) {
            return value;
          }
          return {
            [cssProperty]: value
          };
        };
        return handleBreakpoints(props, propValue, styleFromPropValue);
      };
      fn2.propTypes = {};
      fn2.filterProps = [prop];
      return fn2;
    }
    function memoize(fn2) {
      const cache2 = {};
      return (arg) => {
        if (cache2[arg] === void 0) {
          cache2[arg] = fn2(arg);
        }
        return cache2[arg];
      };
    }
    const properties = {
      m: "margin",
      p: "padding"
    };
    const directions = {
      t: "Top",
      r: "Right",
      b: "Bottom",
      l: "Left",
      x: ["Left", "Right"],
      y: ["Top", "Bottom"]
    };
    const aliases = {
      marginX: "mx",
      marginY: "my",
      paddingX: "px",
      paddingY: "py"
    };
    const getCssProperties = memoize((prop) => {
      if (prop.length > 2) {
        if (aliases[prop]) {
          prop = aliases[prop];
        } else {
          return [prop];
        }
      }
      const [a2, b2] = prop.split("");
      const property = properties[a2];
      const direction = directions[b2] || "";
      return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
    });
    const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
    const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
    [...marginKeys, ...paddingKeys];
    function createUnaryUnit(theme, themeKey, defaultValue, propName) {
      var _getPath;
      const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
      if (typeof themeSpacing === "number") {
        return (abs2) => {
          if (typeof abs2 === "string") {
            return abs2;
          }
          return themeSpacing * abs2;
        };
      }
      if (Array.isArray(themeSpacing)) {
        return (abs2) => {
          if (typeof abs2 === "string") {
            return abs2;
          }
          return themeSpacing[abs2];
        };
      }
      if (typeof themeSpacing === "function") {
        return themeSpacing;
      }
      return () => void 0;
    }
    function createUnarySpacing(theme) {
      return createUnaryUnit(theme, "spacing", 8);
    }
    function getValue(transformer, propValue) {
      if (typeof propValue === "string" || propValue == null) {
        return propValue;
      }
      const abs2 = Math.abs(propValue);
      const transformed = transformer(abs2);
      if (propValue >= 0) {
        return transformed;
      }
      if (typeof transformed === "number") {
        return -transformed;
      }
      return `-${transformed}`;
    }
    function getStyleFromPropValue(cssProperties, transformer) {
      return (propValue) => cssProperties.reduce((acc, cssProperty) => {
        acc[cssProperty] = getValue(transformer, propValue);
        return acc;
      }, {});
    }
    function resolveCssProperty(props, keys, prop, transformer) {
      if (keys.indexOf(prop) === -1) {
        return null;
      }
      const cssProperties = getCssProperties(prop);
      const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
      const propValue = props[prop];
      return handleBreakpoints(props, propValue, styleFromPropValue);
    }
    function style(props, keys) {
      const transformer = createUnarySpacing(props.theme);
      return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge, {});
    }
    function margin(props) {
      return style(props, marginKeys);
    }
    margin.propTypes = {};
    margin.filterProps = marginKeys;
    function padding(props) {
      return style(props, paddingKeys);
    }
    padding.propTypes = {};
    padding.filterProps = paddingKeys;
    function createSpacing(spacingInput = 8) {
      if (spacingInput.mui) {
        return spacingInput;
      }
      const transform = createUnarySpacing({
        spacing: spacingInput
      });
      const spacing = (...argsInput) => {
        const args = argsInput.length === 0 ? [1] : argsInput;
        return args.map((argument) => {
          const output = transform(argument);
          return typeof output === "number" ? `${output}px` : output;
        }).join(" ");
      };
      spacing.mui = true;
      return spacing;
    }
    function compose(...styles2) {
      const handlers = styles2.reduce((acc, style2) => {
        style2.filterProps.forEach((prop) => {
          acc[prop] = style2;
        });
        return acc;
      }, {});
      const fn2 = (props) => {
        return Object.keys(props).reduce((acc, prop) => {
          if (handlers[prop]) {
            return merge(acc, handlers[prop](props));
          }
          return acc;
        }, {});
      };
      fn2.propTypes = {};
      fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
      return fn2;
    }
    function borderTransform(value) {
      if (typeof value !== "number") {
        return value;
      }
      return `${value}px solid`;
    }
    const border = style$1({
      prop: "border",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderTop = style$1({
      prop: "borderTop",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderRight = style$1({
      prop: "borderRight",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderBottom = style$1({
      prop: "borderBottom",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderLeft = style$1({
      prop: "borderLeft",
      themeKey: "borders",
      transform: borderTransform
    });
    const borderColor = style$1({
      prop: "borderColor",
      themeKey: "palette"
    });
    const borderTopColor = style$1({
      prop: "borderTopColor",
      themeKey: "palette"
    });
    const borderRightColor = style$1({
      prop: "borderRightColor",
      themeKey: "palette"
    });
    const borderBottomColor = style$1({
      prop: "borderBottomColor",
      themeKey: "palette"
    });
    const borderLeftColor = style$1({
      prop: "borderLeftColor",
      themeKey: "palette"
    });
    const borderRadius = (props) => {
      if (props.borderRadius !== void 0 && props.borderRadius !== null) {
        const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
        const styleFromPropValue = (propValue) => ({
          borderRadius: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
      }
      return null;
    };
    borderRadius.propTypes = {};
    borderRadius.filterProps = ["borderRadius"];
    compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
    const gap = (props) => {
      if (props.gap !== void 0 && props.gap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          gap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.gap, styleFromPropValue);
      }
      return null;
    };
    gap.propTypes = {};
    gap.filterProps = ["gap"];
    const columnGap = (props) => {
      if (props.columnGap !== void 0 && props.columnGap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          columnGap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.columnGap, styleFromPropValue);
      }
      return null;
    };
    columnGap.propTypes = {};
    columnGap.filterProps = ["columnGap"];
    const rowGap = (props) => {
      if (props.rowGap !== void 0 && props.rowGap !== null) {
        const transformer = createUnaryUnit(props.theme, "spacing", 8);
        const styleFromPropValue = (propValue) => ({
          rowGap: getValue(transformer, propValue)
        });
        return handleBreakpoints(props, props.rowGap, styleFromPropValue);
      }
      return null;
    };
    rowGap.propTypes = {};
    rowGap.filterProps = ["rowGap"];
    const gridColumn = style$1({
      prop: "gridColumn"
    });
    const gridRow = style$1({
      prop: "gridRow"
    });
    const gridAutoFlow = style$1({
      prop: "gridAutoFlow"
    });
    const gridAutoColumns = style$1({
      prop: "gridAutoColumns"
    });
    const gridAutoRows = style$1({
      prop: "gridAutoRows"
    });
    const gridTemplateColumns = style$1({
      prop: "gridTemplateColumns"
    });
    const gridTemplateRows = style$1({
      prop: "gridTemplateRows"
    });
    const gridTemplateAreas = style$1({
      prop: "gridTemplateAreas"
    });
    const gridArea = style$1({
      prop: "gridArea"
    });
    compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
    function paletteTransform(value, userValue) {
      if (userValue === "grey") {
        return userValue;
      }
      return value;
    }
    const color = style$1({
      prop: "color",
      themeKey: "palette",
      transform: paletteTransform
    });
    const bgcolor = style$1({
      prop: "bgcolor",
      cssProperty: "backgroundColor",
      themeKey: "palette",
      transform: paletteTransform
    });
    const backgroundColor = style$1({
      prop: "backgroundColor",
      themeKey: "palette",
      transform: paletteTransform
    });
    compose(color, bgcolor, backgroundColor);
    function sizingTransform(value) {
      return value <= 1 && value !== 0 ? `${value * 100}%` : value;
    }
    const width = style$1({
      prop: "width",
      transform: sizingTransform
    });
    const maxWidth = (props) => {
      if (props.maxWidth !== void 0 && props.maxWidth !== null) {
        const styleFromPropValue = (propValue) => {
          var _props$theme, _props$theme2;
          const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
          if (!breakpoint) {
            return {
              maxWidth: sizingTransform(propValue)
            };
          }
          if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
            return {
              maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
            };
          }
          return {
            maxWidth: breakpoint
          };
        };
        return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
      }
      return null;
    };
    maxWidth.filterProps = ["maxWidth"];
    const minWidth = style$1({
      prop: "minWidth",
      transform: sizingTransform
    });
    const height = style$1({
      prop: "height",
      transform: sizingTransform
    });
    const maxHeight = style$1({
      prop: "maxHeight",
      transform: sizingTransform
    });
    const minHeight = style$1({
      prop: "minHeight",
      transform: sizingTransform
    });
    style$1({
      prop: "size",
      cssProperty: "width",
      transform: sizingTransform
    });
    style$1({
      prop: "size",
      cssProperty: "height",
      transform: sizingTransform
    });
    const boxSizing = style$1({
      prop: "boxSizing"
    });
    compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
    const defaultSxConfig = {
      // borders
      border: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderTop: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderRight: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderBottom: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderLeft: {
        themeKey: "borders",
        transform: borderTransform
      },
      borderColor: {
        themeKey: "palette"
      },
      borderTopColor: {
        themeKey: "palette"
      },
      borderRightColor: {
        themeKey: "palette"
      },
      borderBottomColor: {
        themeKey: "palette"
      },
      borderLeftColor: {
        themeKey: "palette"
      },
      borderRadius: {
        themeKey: "shape.borderRadius",
        style: borderRadius
      },
      // palette
      color: {
        themeKey: "palette",
        transform: paletteTransform
      },
      bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform
      },
      backgroundColor: {
        themeKey: "palette",
        transform: paletteTransform
      },
      // spacing
      p: {
        style: padding
      },
      pt: {
        style: padding
      },
      pr: {
        style: padding
      },
      pb: {
        style: padding
      },
      pl: {
        style: padding
      },
      px: {
        style: padding
      },
      py: {
        style: padding
      },
      padding: {
        style: padding
      },
      paddingTop: {
        style: padding
      },
      paddingRight: {
        style: padding
      },
      paddingBottom: {
        style: padding
      },
      paddingLeft: {
        style: padding
      },
      paddingX: {
        style: padding
      },
      paddingY: {
        style: padding
      },
      paddingInline: {
        style: padding
      },
      paddingInlineStart: {
        style: padding
      },
      paddingInlineEnd: {
        style: padding
      },
      paddingBlock: {
        style: padding
      },
      paddingBlockStart: {
        style: padding
      },
      paddingBlockEnd: {
        style: padding
      },
      m: {
        style: margin
      },
      mt: {
        style: margin
      },
      mr: {
        style: margin
      },
      mb: {
        style: margin
      },
      ml: {
        style: margin
      },
      mx: {
        style: margin
      },
      my: {
        style: margin
      },
      margin: {
        style: margin
      },
      marginTop: {
        style: margin
      },
      marginRight: {
        style: margin
      },
      marginBottom: {
        style: margin
      },
      marginLeft: {
        style: margin
      },
      marginX: {
        style: margin
      },
      marginY: {
        style: margin
      },
      marginInline: {
        style: margin
      },
      marginInlineStart: {
        style: margin
      },
      marginInlineEnd: {
        style: margin
      },
      marginBlock: {
        style: margin
      },
      marginBlockStart: {
        style: margin
      },
      marginBlockEnd: {
        style: margin
      },
      // display
      displayPrint: {
        cssProperty: false,
        transform: (value) => ({
          "@media print": {
            display: value
          }
        })
      },
      display: {},
      overflow: {},
      textOverflow: {},
      visibility: {},
      whiteSpace: {},
      // flexbox
      flexBasis: {},
      flexDirection: {},
      flexWrap: {},
      justifyContent: {},
      alignItems: {},
      alignContent: {},
      order: {},
      flex: {},
      flexGrow: {},
      flexShrink: {},
      alignSelf: {},
      justifyItems: {},
      justifySelf: {},
      // grid
      gap: {
        style: gap
      },
      rowGap: {
        style: rowGap
      },
      columnGap: {
        style: columnGap
      },
      gridColumn: {},
      gridRow: {},
      gridAutoFlow: {},
      gridAutoColumns: {},
      gridAutoRows: {},
      gridTemplateColumns: {},
      gridTemplateRows: {},
      gridTemplateAreas: {},
      gridArea: {},
      // positions
      position: {},
      zIndex: {
        themeKey: "zIndex"
      },
      top: {},
      right: {},
      bottom: {},
      left: {},
      // shadows
      boxShadow: {
        themeKey: "shadows"
      },
      // sizing
      width: {
        transform: sizingTransform
      },
      maxWidth: {
        style: maxWidth
      },
      minWidth: {
        transform: sizingTransform
      },
      height: {
        transform: sizingTransform
      },
      maxHeight: {
        transform: sizingTransform
      },
      minHeight: {
        transform: sizingTransform
      },
      boxSizing: {},
      // typography
      fontFamily: {
        themeKey: "typography"
      },
      fontSize: {
        themeKey: "typography"
      },
      fontStyle: {
        themeKey: "typography"
      },
      fontWeight: {
        themeKey: "typography"
      },
      letterSpacing: {},
      textTransform: {},
      lineHeight: {},
      textAlign: {},
      typography: {
        cssProperty: false,
        themeKey: "typography"
      }
    };
    const defaultSxConfig$1 = defaultSxConfig;
    function objectsHaveSameKeys(...objects) {
      const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
      const union = new Set(allKeys);
      return objects.every((object) => union.size === Object.keys(object).length);
    }
    function callIfFn(maybeFn, arg) {
      return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
    }
    function unstable_createStyleFunctionSx() {
      function getThemeValue(prop, val, theme, config2) {
        const props = {
          [prop]: val,
          theme
        };
        const options = config2[prop];
        if (!options) {
          return {
            [prop]: val
          };
        }
        const {
          cssProperty = prop,
          themeKey,
          transform,
          style: style2
        } = options;
        if (val == null) {
          return null;
        }
        if (themeKey === "typography" && val === "inherit") {
          return {
            [prop]: val
          };
        }
        const themeMapping = getPath(theme, themeKey) || {};
        if (style2) {
          return style2(props);
        }
        const styleFromPropValue = (propValueFinal) => {
          let value = getStyleValue$1(themeMapping, transform, propValueFinal);
          if (propValueFinal === value && typeof propValueFinal === "string") {
            value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
          }
          if (cssProperty === false) {
            return value;
          }
          return {
            [cssProperty]: value
          };
        };
        return handleBreakpoints(props, val, styleFromPropValue);
      }
      function styleFunctionSx2(props) {
        var _theme$unstable_sxCon;
        const {
          sx,
          theme = {}
        } = props || {};
        if (!sx) {
          return null;
        }
        const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
        function traverse(sxInput) {
          let sxObject = sxInput;
          if (typeof sxInput === "function") {
            sxObject = sxInput(theme);
          } else if (typeof sxInput !== "object") {
            return sxInput;
          }
          if (!sxObject) {
            return null;
          }
          const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
          const breakpointsKeys = Object.keys(emptyBreakpoints);
          let css2 = emptyBreakpoints;
          Object.keys(sxObject).forEach((styleKey) => {
            const value = callIfFn(sxObject[styleKey], theme);
            if (value !== null && value !== void 0) {
              if (typeof value === "object") {
                if (config2[styleKey]) {
                  css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
                } else {
                  const breakpointsValues = handleBreakpoints({
                    theme
                  }, value, (x2) => ({
                    [styleKey]: x2
                  }));
                  if (objectsHaveSameKeys(breakpointsValues, value)) {
                    css2[styleKey] = styleFunctionSx2({
                      sx: value,
                      theme
                    });
                  } else {
                    css2 = merge(css2, breakpointsValues);
                  }
                }
              } else {
                css2 = merge(css2, getThemeValue(styleKey, value, theme, config2));
              }
            }
          });
          return removeUnusedBreakpoints(breakpointsKeys, css2);
        }
        return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
      }
      return styleFunctionSx2;
    }
    const styleFunctionSx = unstable_createStyleFunctionSx();
    styleFunctionSx.filterProps = ["sx"];
    const styleFunctionSx$1 = styleFunctionSx;
    const _excluded$x = ["breakpoints", "palette", "spacing", "shape"];
    function createTheme$1(options = {}, ...args) {
      const {
        breakpoints: breakpointsInput = {},
        palette: paletteInput = {},
        spacing: spacingInput,
        shape: shapeInput = {}
      } = options, other = _objectWithoutPropertiesLoose(options, _excluded$x);
      const breakpoints2 = createBreakpoints(breakpointsInput);
      const spacing = createSpacing(spacingInput);
      let muiTheme = deepmerge({
        breakpoints: breakpoints2,
        direction: "ltr",
        components: {},
        // Inject component definitions.
        palette: _extends$1({
          mode: "light"
        }, paletteInput),
        spacing,
        shape: _extends$1({}, shape$1, shapeInput)
      }, other);
      muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
      muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
      muiTheme.unstable_sx = function sx(props) {
        return styleFunctionSx$1({
          sx: props,
          theme: this
        });
      };
      return muiTheme;
    }
    function isObjectEmpty(obj) {
      return Object.keys(obj).length === 0;
    }
    function useTheme$2(defaultTheme2 = null) {
      const contextTheme = reactExports.useContext(ThemeContext);
      return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
    }
    const systemDefaultTheme$1 = createTheme$1();
    function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
      return useTheme$2(defaultTheme2);
    }
    function GlobalStyles$1({
      styles: styles2,
      themeId,
      defaultTheme: defaultTheme2 = {}
    }) {
      const upperTheme = useTheme$1(defaultTheme2);
      const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
        styles: globalStyles
      });
    }
    function r(e2) {
      var t2, f2, n2 = "";
      if ("string" == typeof e2 || "number" == typeof e2)
        n2 += e2;
      else if ("object" == typeof e2)
        if (Array.isArray(e2))
          for (t2 = 0; t2 < e2.length; t2++)
            e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
        else
          for (t2 in e2)
            e2[t2] && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    function clsx() {
      for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
        (e2 = arguments[f2++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
      return n2;
    }
    const _excluded$w = ["variant"];
    function isEmpty$3(string) {
      return string.length === 0;
    }
    function propsToClassKey(props) {
      const {
        variant
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$w);
      let classKey = variant || "";
      Object.keys(other).sort().forEach((key) => {
        if (key === "color") {
          classKey += isEmpty$3(classKey) ? props[key] : capitalize(props[key]);
        } else {
          classKey += `${isEmpty$3(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
        }
      });
      return classKey;
    }
    const _excluded$v = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
    function isEmpty$2(obj) {
      return Object.keys(obj).length === 0;
    }
    function isStringTag(tag) {
      return typeof tag === "string" && // 96 is one less than the char code
      // for "a" so this is checking that
      // it's a lowercase character
      tag.charCodeAt(0) > 96;
    }
    const getStyleOverrides = (name, theme) => {
      if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
        return theme.components[name].styleOverrides;
      }
      return null;
    };
    const transformVariants = (variants) => {
      const variantsStyles = {};
      if (variants) {
        variants.forEach((definition) => {
          const key = propsToClassKey(definition.props);
          variantsStyles[key] = definition.style;
        });
      }
      return variantsStyles;
    };
    const getVariantStyles = (name, theme) => {
      let variants = [];
      if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
        variants = theme.components[name].variants;
      }
      return transformVariants(variants);
    };
    const variantsResolver = (props, styles2, variants) => {
      const {
        ownerState = {}
      } = props;
      const variantsStyles = [];
      if (variants) {
        variants.forEach((variant) => {
          let isMatch = true;
          Object.keys(variant.props).forEach((key) => {
            if (ownerState[key] !== variant.props[key] && props[key] !== variant.props[key]) {
              isMatch = false;
            }
          });
          if (isMatch) {
            variantsStyles.push(styles2[propsToClassKey(variant.props)]);
          }
        });
      }
      return variantsStyles;
    };
    const themeVariantsResolver = (props, styles2, theme, name) => {
      var _theme$components;
      const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[name]) == null ? void 0 : _theme$components.variants;
      return variantsResolver(props, styles2, themeVariants);
    };
    function shouldForwardProp(prop) {
      return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
    }
    const systemDefaultTheme = createTheme$1();
    const lowercaseFirstLetter = (string) => {
      if (!string) {
        return string;
      }
      return string.charAt(0).toLowerCase() + string.slice(1);
    };
    function resolveTheme({
      defaultTheme: defaultTheme2,
      theme,
      themeId
    }) {
      return isEmpty$2(theme) ? defaultTheme2 : theme[themeId] || theme;
    }
    function defaultOverridesResolver(slot) {
      if (!slot) {
        return null;
      }
      return (props, styles2) => styles2[slot];
    }
    const muiStyledFunctionResolver = ({
      styledArg,
      props,
      defaultTheme: defaultTheme2,
      themeId
    }) => {
      const resolvedStyles = styledArg(_extends$1({}, props, {
        theme: resolveTheme(_extends$1({}, props, {
          defaultTheme: defaultTheme2,
          themeId
        }))
      }));
      let optionalVariants;
      if (resolvedStyles && resolvedStyles.variants) {
        optionalVariants = resolvedStyles.variants;
        delete resolvedStyles.variants;
      }
      if (optionalVariants) {
        const variantsStyles = variantsResolver(props, transformVariants(optionalVariants), optionalVariants);
        return [resolvedStyles, ...variantsStyles];
      }
      return resolvedStyles;
    };
    function createStyled(input = {}) {
      const {
        themeId,
        defaultTheme: defaultTheme2 = systemDefaultTheme,
        rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
        slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
      } = input;
      const systemSx = (props) => {
        return styleFunctionSx$1(_extends$1({}, props, {
          theme: resolveTheme(_extends$1({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }))
        }));
      };
      systemSx.__mui_systemSx = true;
      return (tag, inputOptions = {}) => {
        internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
        const {
          name: componentName,
          slot: componentSlot,
          skipVariantsResolver: inputSkipVariantsResolver,
          skipSx: inputSkipSx,
          // TODO v6: remove `lowercaseFirstLetter()` in the next major release
          // For more details: https://github.com/mui/material-ui/pull/37908
          overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
        } = inputOptions, options = _objectWithoutPropertiesLoose(inputOptions, _excluded$v);
        const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
          // TODO v6: remove `Root` in the next major release
          // For more details: https://github.com/mui/material-ui/pull/37908
          componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
        );
        const skipSx = inputSkipSx || false;
        let label;
        let shouldForwardPropOption = shouldForwardProp;
        if (componentSlot === "Root" || componentSlot === "root") {
          shouldForwardPropOption = rootShouldForwardProp2;
        } else if (componentSlot) {
          shouldForwardPropOption = slotShouldForwardProp2;
        } else if (isStringTag(tag)) {
          shouldForwardPropOption = void 0;
        }
        const defaultStyledResolver = styled$2(tag, _extends$1({
          shouldForwardProp: shouldForwardPropOption,
          label
        }, options));
        const muiStyledResolver = (styleArg, ...expressions) => {
          const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
            if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg) {
              return (props) => muiStyledFunctionResolver({
                styledArg: stylesArg,
                props,
                defaultTheme: defaultTheme2,
                themeId
              });
            }
            if (isPlainObject(stylesArg)) {
              let transformedStylesArg = stylesArg;
              let styledArgVariants;
              if (stylesArg && stylesArg.variants) {
                styledArgVariants = stylesArg.variants;
                delete transformedStylesArg.variants;
                transformedStylesArg = (props) => {
                  let result = stylesArg;
                  const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
                  variantStyles.forEach((variantStyle) => {
                    result = deepmerge(result, variantStyle);
                  });
                  return result;
                };
              }
              return transformedStylesArg;
            }
            return stylesArg;
          }) : [];
          let transformedStyleArg = styleArg;
          if (isPlainObject(styleArg)) {
            let styledArgVariants;
            if (styleArg && styleArg.variants) {
              styledArgVariants = styleArg.variants;
              delete transformedStyleArg.variants;
              transformedStyleArg = (props) => {
                let result = styleArg;
                const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
                variantStyles.forEach((variantStyle) => {
                  result = deepmerge(result, variantStyle);
                });
                return result;
              };
            }
          } else if (typeof styleArg === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
          // component stays as a function. This condition makes sure that we do not interpolate functions
          // which are basically components used as a selectors.
          styleArg.__emotion_real !== styleArg) {
            transformedStyleArg = (props) => muiStyledFunctionResolver({
              styledArg: styleArg,
              props,
              defaultTheme: defaultTheme2,
              themeId
            });
          }
          if (componentName && overridesResolver2) {
            expressionsWithDefaultTheme.push((props) => {
              const theme = resolveTheme(_extends$1({}, props, {
                defaultTheme: defaultTheme2,
                themeId
              }));
              const styleOverrides = getStyleOverrides(componentName, theme);
              if (styleOverrides) {
                const resolvedStyleOverrides = {};
                Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
                  resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends$1({}, props, {
                    theme
                  })) : slotStyle;
                });
                return overridesResolver2(props, resolvedStyleOverrides);
              }
              return null;
            });
          }
          if (componentName && !skipVariantsResolver) {
            expressionsWithDefaultTheme.push((props) => {
              const theme = resolveTheme(_extends$1({}, props, {
                defaultTheme: defaultTheme2,
                themeId
              }));
              return themeVariantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
            });
          }
          if (!skipSx) {
            expressionsWithDefaultTheme.push(systemSx);
          }
          const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
          if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
            const placeholders = new Array(numOfCustomFnsApplied).fill("");
            transformedStyleArg = [...styleArg, ...placeholders];
            transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
          }
          const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
          if (tag.muiName) {
            Component.muiName = tag.muiName;
          }
          return Component;
        };
        if (defaultStyledResolver.withConfig) {
          muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
        }
        return muiStyledResolver;
      };
    }
    function getThemeProps(params) {
      const {
        theme,
        name,
        props
      } = params;
      if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
        return props;
      }
      return resolveProps(theme.components[name].defaultProps, props);
    }
    function useThemeProps$1({
      props,
      name,
      defaultTheme: defaultTheme2,
      themeId
    }) {
      let theme = useTheme$1(defaultTheme2);
      if (themeId) {
        theme = theme[themeId] || theme;
      }
      const mergedProps = getThemeProps({
        theme,
        name,
        props
      });
      return mergedProps;
    }
    function clamp(value, min = 0, max = 1) {
      return Math.min(Math.max(min, value), max);
    }
    function hexToRgb(color2) {
      color2 = color2.slice(1);
      const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
      let colors = color2.match(re2);
      if (colors && colors[0].length === 1) {
        colors = colors.map((n2) => n2 + n2);
      }
      return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index) => {
        return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
      }).join(", ")})` : "";
    }
    function decomposeColor(color2) {
      if (color2.type) {
        return color2;
      }
      if (color2.charAt(0) === "#") {
        return decomposeColor(hexToRgb(color2));
      }
      const marker = color2.indexOf("(");
      const type = color2.substring(0, marker);
      if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
        throw new Error(formatMuiErrorMessage(9, color2));
      }
      let values2 = color2.substring(marker + 1, color2.length - 1);
      let colorSpace;
      if (type === "color") {
        values2 = values2.split(" ");
        colorSpace = values2.shift();
        if (values2.length === 4 && values2[3].charAt(0) === "/") {
          values2[3] = values2[3].slice(1);
        }
        if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
          throw new Error(formatMuiErrorMessage(10, colorSpace));
        }
      } else {
        values2 = values2.split(",");
      }
      values2 = values2.map((value) => parseFloat(value));
      return {
        type,
        values: values2,
        colorSpace
      };
    }
    function recomposeColor(color2) {
      const {
        type,
        colorSpace
      } = color2;
      let {
        values: values2
      } = color2;
      if (type.indexOf("rgb") !== -1) {
        values2 = values2.map((n2, i2) => i2 < 3 ? parseInt(n2, 10) : n2);
      } else if (type.indexOf("hsl") !== -1) {
        values2[1] = `${values2[1]}%`;
        values2[2] = `${values2[2]}%`;
      }
      if (type.indexOf("color") !== -1) {
        values2 = `${colorSpace} ${values2.join(" ")}`;
      } else {
        values2 = `${values2.join(", ")}`;
      }
      return `${type}(${values2})`;
    }
    function hslToRgb(color2) {
      color2 = decomposeColor(color2);
      const {
        values: values2
      } = color2;
      const h2 = values2[0];
      const s2 = values2[1] / 100;
      const l2 = values2[2] / 100;
      const a2 = s2 * Math.min(l2, 1 - l2);
      const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
      let type = "rgb";
      const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
      if (color2.type === "hsla") {
        type += "a";
        rgb.push(values2[3]);
      }
      return recomposeColor({
        type,
        values: rgb
      });
    }
    function getLuminance(color2) {
      color2 = decomposeColor(color2);
      let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
      rgb = rgb.map((val) => {
        if (color2.type !== "color") {
          val /= 255;
        }
        return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
      });
      return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
    }
    function getContrastRatio(foreground, background) {
      const lumA = getLuminance(foreground);
      const lumB = getLuminance(background);
      return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
    }
    function alpha(color2, value) {
      color2 = decomposeColor(color2);
      value = clamp(value);
      if (color2.type === "rgb" || color2.type === "hsl") {
        color2.type += "a";
      }
      if (color2.type === "color") {
        color2.values[3] = `/${value}`;
      } else {
        color2.values[3] = value;
      }
      return recomposeColor(color2);
    }
    function darken(color2, coefficient) {
      color2 = decomposeColor(color2);
      coefficient = clamp(coefficient);
      if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] *= 1 - coefficient;
      } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
        for (let i2 = 0; i2 < 3; i2 += 1) {
          color2.values[i2] *= 1 - coefficient;
        }
      }
      return recomposeColor(color2);
    }
    function lighten(color2, coefficient) {
      color2 = decomposeColor(color2);
      coefficient = clamp(coefficient);
      if (color2.type.indexOf("hsl") !== -1) {
        color2.values[2] += (100 - color2.values[2]) * coefficient;
      } else if (color2.type.indexOf("rgb") !== -1) {
        for (let i2 = 0; i2 < 3; i2 += 1) {
          color2.values[i2] += (255 - color2.values[i2]) * coefficient;
        }
      } else if (color2.type.indexOf("color") !== -1) {
        for (let i2 = 0; i2 < 3; i2 += 1) {
          color2.values[i2] += (1 - color2.values[i2]) * coefficient;
        }
      }
      return recomposeColor(color2);
    }
    function createMixins(breakpoints2, mixins) {
      return _extends$1({
        toolbar: {
          minHeight: 56,
          [breakpoints2.up("xs")]: {
            "@media (orientation: landscape)": {
              minHeight: 48
            }
          },
          [breakpoints2.up("sm")]: {
            minHeight: 64
          }
        }
      }, mixins);
    }
    const _excluded$u = ["mode", "contrastThreshold", "tonalOffset"];
    const light = {
      // The colors used to style the text.
      text: {
        // The most important text.
        primary: "rgba(0, 0, 0, 0.87)",
        // Secondary text.
        secondary: "rgba(0, 0, 0, 0.6)",
        // Disabled text have even lower visual prominence.
        disabled: "rgba(0, 0, 0, 0.38)"
      },
      // The color used to divide different elements.
      divider: "rgba(0, 0, 0, 0.12)",
      // The background colors used to style the surfaces.
      // Consistency between these values is important.
      background: {
        paper: common$1.white,
        default: common$1.white
      },
      // The colors used to style the action elements.
      action: {
        // The color of an active action like an icon button.
        active: "rgba(0, 0, 0, 0.54)",
        // The color of an hovered action.
        hover: "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        // The color of a selected action.
        selected: "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        // The color of a disabled action.
        disabled: "rgba(0, 0, 0, 0.26)",
        // The background color of a disabled action.
        disabledBackground: "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      }
    };
    const dark = {
      text: {
        primary: common$1.white,
        secondary: "rgba(255, 255, 255, 0.7)",
        disabled: "rgba(255, 255, 255, 0.5)",
        icon: "rgba(255, 255, 255, 0.5)"
      },
      divider: "rgba(255, 255, 255, 0.12)",
      background: {
        paper: "#121212",
        default: "#121212"
      },
      action: {
        active: common$1.white,
        hover: "rgba(255, 255, 255, 0.08)",
        hoverOpacity: 0.08,
        selected: "rgba(255, 255, 255, 0.16)",
        selectedOpacity: 0.16,
        disabled: "rgba(255, 255, 255, 0.3)",
        disabledBackground: "rgba(255, 255, 255, 0.12)",
        disabledOpacity: 0.38,
        focus: "rgba(255, 255, 255, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.24
      }
    };
    function addLightOrDark(intent, direction, shade, tonalOffset) {
      const tonalOffsetLight = tonalOffset.light || tonalOffset;
      const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
      if (!intent[direction]) {
        if (intent.hasOwnProperty(shade)) {
          intent[direction] = intent[shade];
        } else if (direction === "light") {
          intent.light = lighten(intent.main, tonalOffsetLight);
        } else if (direction === "dark") {
          intent.dark = darken(intent.main, tonalOffsetDark);
        }
      }
    }
    function getDefaultPrimary(mode = "light") {
      if (mode === "dark") {
        return {
          main: blue$1[200],
          light: blue$1[50],
          dark: blue$1[400]
        };
      }
      return {
        main: blue$1[700],
        light: blue$1[400],
        dark: blue$1[800]
      };
    }
    function getDefaultSecondary(mode = "light") {
      if (mode === "dark") {
        return {
          main: purple$1[200],
          light: purple$1[50],
          dark: purple$1[400]
        };
      }
      return {
        main: purple$1[500],
        light: purple$1[300],
        dark: purple$1[700]
      };
    }
    function getDefaultError(mode = "light") {
      if (mode === "dark") {
        return {
          main: red$1[500],
          light: red$1[300],
          dark: red$1[700]
        };
      }
      return {
        main: red$1[700],
        light: red$1[400],
        dark: red$1[800]
      };
    }
    function getDefaultInfo(mode = "light") {
      if (mode === "dark") {
        return {
          main: lightBlue$1[400],
          light: lightBlue$1[300],
          dark: lightBlue$1[700]
        };
      }
      return {
        main: lightBlue$1[700],
        light: lightBlue$1[500],
        dark: lightBlue$1[900]
      };
    }
    function getDefaultSuccess(mode = "light") {
      if (mode === "dark") {
        return {
          main: green$1[400],
          light: green$1[300],
          dark: green$1[700]
        };
      }
      return {
        main: green$1[800],
        light: green$1[500],
        dark: green$1[900]
      };
    }
    function getDefaultWarning(mode = "light") {
      if (mode === "dark") {
        return {
          main: orange$1[400],
          light: orange$1[300],
          dark: orange$1[700]
        };
      }
      return {
        main: "#ed6c02",
        // closest to orange[800] that pass 3:1.
        light: orange$1[500],
        dark: orange$1[900]
      };
    }
    function createPalette(palette) {
      const {
        mode = "light",
        contrastThreshold = 3,
        tonalOffset = 0.2
      } = palette, other = _objectWithoutPropertiesLoose(palette, _excluded$u);
      const primary = palette.primary || getDefaultPrimary(mode);
      const secondary = palette.secondary || getDefaultSecondary(mode);
      const error = palette.error || getDefaultError(mode);
      const info = palette.info || getDefaultInfo(mode);
      const success = palette.success || getDefaultSuccess(mode);
      const warning2 = palette.warning || getDefaultWarning(mode);
      function getContrastText(background) {
        const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
        return contrastText;
      }
      const augmentColor = ({
        color: color2,
        name,
        mainShade = 500,
        lightShade = 300,
        darkShade = 700
      }) => {
        color2 = _extends$1({}, color2);
        if (!color2.main && color2[mainShade]) {
          color2.main = color2[mainShade];
        }
        if (!color2.hasOwnProperty("main")) {
          throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
        }
        if (typeof color2.main !== "string") {
          throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
        }
        addLightOrDark(color2, "light", lightShade, tonalOffset);
        addLightOrDark(color2, "dark", darkShade, tonalOffset);
        if (!color2.contrastText) {
          color2.contrastText = getContrastText(color2.main);
        }
        return color2;
      };
      const modes = {
        dark,
        light
      };
      const paletteOutput = deepmerge(_extends$1({
        // A collection of common colors.
        common: _extends$1({}, common$1),
        // prevent mutable object.
        // The palette mode, can be light or dark.
        mode,
        // The colors used to represent primary interface elements for a user.
        primary: augmentColor({
          color: primary,
          name: "primary"
        }),
        // The colors used to represent secondary interface elements for a user.
        secondary: augmentColor({
          color: secondary,
          name: "secondary",
          mainShade: "A400",
          lightShade: "A200",
          darkShade: "A700"
        }),
        // The colors used to represent interface elements that the user should be made aware of.
        error: augmentColor({
          color: error,
          name: "error"
        }),
        // The colors used to represent potentially dangerous actions or important messages.
        warning: augmentColor({
          color: warning2,
          name: "warning"
        }),
        // The colors used to present information to the user that is neutral and not necessarily important.
        info: augmentColor({
          color: info,
          name: "info"
        }),
        // The colors used to indicate the successful completion of an action that user triggered.
        success: augmentColor({
          color: success,
          name: "success"
        }),
        // The grey colors.
        grey: grey$1,
        // Used by `getContrastText()` to maximize the contrast between
        // the background and the text.
        contrastThreshold,
        // Takes a background color and returns the text color that maximizes the contrast.
        getContrastText,
        // Generate a rich color object.
        augmentColor,
        // Used by the functions below to shift a color's luminance by approximately
        // two indexes within its tonal palette.
        // E.g., shift from Red 500 to Red 300 or Red 700.
        tonalOffset
      }, modes[mode]), other);
      return paletteOutput;
    }
    const _excluded$t = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
    function round(value) {
      return Math.round(value * 1e5) / 1e5;
    }
    const caseAllCaps = {
      textTransform: "uppercase"
    };
    const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
    function createTypography(palette, typography2) {
      const _ref = typeof typography2 === "function" ? typography2(palette) : typography2, {
        fontFamily = defaultFontFamily,
        // The default font size of the Material Specification.
        fontSize = 14,
        // px
        fontWeightLight = 300,
        fontWeightRegular = 400,
        fontWeightMedium = 500,
        fontWeightBold = 700,
        // Tell MUI what's the font-size on the html element.
        // 16px is the default font-size used by browsers.
        htmlFontSize = 16,
        // Apply the CSS properties to all the variants.
        allVariants,
        pxToRem: pxToRem2
      } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$t);
      const coef = fontSize / 14;
      const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
      const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends$1({
        fontFamily,
        fontWeight,
        fontSize: pxToRem(size),
        // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
        lineHeight
      }, fontFamily === defaultFontFamily ? {
        letterSpacing: `${round(letterSpacing / size)}em`
      } : {}, casing, allVariants);
      const variants = {
        h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
        h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
        h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
        h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
        h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
        h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
        subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
        subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
        body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
        body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
        button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
        caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
        overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
        // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
        inherit: {
          fontFamily: "inherit",
          fontWeight: "inherit",
          fontSize: "inherit",
          lineHeight: "inherit",
          letterSpacing: "inherit"
        }
      };
      return deepmerge(_extends$1({
        htmlFontSize,
        pxToRem,
        fontFamily,
        fontSize,
        fontWeightLight,
        fontWeightRegular,
        fontWeightMedium,
        fontWeightBold
      }, variants), other, {
        clone: false
        // No need to clone deep
      });
    }
    const shadowKeyUmbraOpacity = 0.2;
    const shadowKeyPenumbraOpacity = 0.14;
    const shadowAmbientShadowOpacity = 0.12;
    function createShadow(...px) {
      return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
    }
    const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
    const shadows$1 = shadows;
    const _excluded$s = ["duration", "easing", "delay"];
    const easing = {
      // This is the most common easing curve.
      easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
      // Objects enter the screen at full velocity from off-screen and
      // slowly decelerate to a resting point.
      easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
      // Objects leave the screen at full velocity. They do not decelerate when off-screen.
      easeIn: "cubic-bezier(0.4, 0, 1, 1)",
      // The sharp curve is used by objects that may return to the screen at any time.
      sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
    };
    const duration = {
      shortest: 150,
      shorter: 200,
      short: 250,
      // most basic recommended timing
      standard: 300,
      // this is to be used in complex animations
      complex: 375,
      // recommended when something is entering screen
      enteringScreen: 225,
      // recommended when something is leaving screen
      leavingScreen: 195
    };
    function formatMs(milliseconds) {
      return `${Math.round(milliseconds)}ms`;
    }
    function getAutoHeightDuration(height2) {
      if (!height2) {
        return 0;
      }
      const constant = height2 / 36;
      return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
    }
    function createTransitions(inputTransitions) {
      const mergedEasing = _extends$1({}, easing, inputTransitions.easing);
      const mergedDuration = _extends$1({}, duration, inputTransitions.duration);
      const create = (props = ["all"], options = {}) => {
        const {
          duration: durationOption = mergedDuration.standard,
          easing: easingOption = mergedEasing.easeInOut,
          delay = 0
        } = options;
        _objectWithoutPropertiesLoose(options, _excluded$s);
        return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
      };
      return _extends$1({
        getAutoHeightDuration,
        create
      }, inputTransitions, {
        easing: mergedEasing,
        duration: mergedDuration
      });
    }
    const zIndex = {
      mobileStepper: 1e3,
      fab: 1050,
      speedDial: 1050,
      appBar: 1100,
      drawer: 1200,
      modal: 1300,
      snackbar: 1400,
      tooltip: 1500
    };
    const zIndex$1 = zIndex;
    const _excluded$r = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
    function createTheme(options = {}, ...args) {
      const {
        mixins: mixinsInput = {},
        palette: paletteInput = {},
        transitions: transitionsInput = {},
        typography: typographyInput = {}
      } = options, other = _objectWithoutPropertiesLoose(options, _excluded$r);
      if (options.vars) {
        throw new Error(formatMuiErrorMessage(18));
      }
      const palette = createPalette(paletteInput);
      const systemTheme = createTheme$1(options);
      let muiTheme = deepmerge(systemTheme, {
        mixins: createMixins(systemTheme.breakpoints, mixinsInput),
        palette,
        // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
        shadows: shadows$1.slice(),
        typography: createTypography(palette, typographyInput),
        transitions: createTransitions(transitionsInput),
        zIndex: _extends$1({}, zIndex$1)
      });
      muiTheme = deepmerge(muiTheme, other);
      muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
      muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
      muiTheme.unstable_sx = function sx(props) {
        return styleFunctionSx$1({
          sx: props,
          theme: this
        });
      };
      return muiTheme;
    }
    const defaultTheme = createTheme();
    const defaultTheme$1 = defaultTheme;
    function useTheme() {
      const theme = useTheme$1(defaultTheme$1);
      return theme[THEME_ID] || theme;
    }
    function useThemeProps({
      props,
      name
    }) {
      return useThemeProps$1({
        props,
        name,
        defaultTheme: defaultTheme$1,
        themeId: THEME_ID
      });
    }
    const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
    const slotShouldForwardProp = shouldForwardProp;
    const styled = createStyled({
      themeId: THEME_ID,
      defaultTheme: defaultTheme$1,
      rootShouldForwardProp
    });
    const styled$1 = styled;
    const getOverlayAlpha = (elevation) => {
      let alphaValue;
      if (elevation < 1) {
        alphaValue = 5.11916 * elevation ** 2;
      } else {
        alphaValue = 4.5 * Math.log(elevation + 1) + 2;
      }
      return (alphaValue / 100).toFixed(2);
    };
    const getOverlayAlpha$1 = getOverlayAlpha;
    function getSvgIconUtilityClass(slot) {
      return generateUtilityClass("MuiSvgIcon", slot);
    }
    generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
    const _excluded$q = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
    const useUtilityClasses$j = (ownerState) => {
      const {
        color: color2,
        fontSize,
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
      };
      return composeClasses(slots, getSvgIconUtilityClass, classes2);
    };
    const SvgIconRoot = styled$1("svg", {
      name: "MuiSvgIcon",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
      return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        // the <svg> will define the property that has `currentColor`
        // e.g. heroicons uses fill="none" and stroke="currentColor"
        fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
        flexShrink: 0,
        transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
          duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
        }),
        fontSize: {
          inherit: "inherit",
          small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
          medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
          large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
        }[ownerState.fontSize],
        // TODO v5 deprecate, v6 remove for sx
        color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
          action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
          disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
          inherit: void 0
        }[ownerState.color]
      };
    });
    const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiSvgIcon"
      });
      const {
        children,
        className,
        color: color2 = "inherit",
        component = "svg",
        fontSize = "medium",
        htmlColor,
        inheritViewBox = false,
        titleAccess,
        viewBox = "0 0 24 24"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$q);
      const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
      const ownerState = _extends$1({}, props, {
        color: color2,
        component,
        fontSize,
        instanceFontSize: inProps.fontSize,
        inheritViewBox,
        viewBox,
        hasSvgAsChild
      });
      const more = {};
      if (!inheritViewBox) {
        more.viewBox = viewBox;
      }
      const classes2 = useUtilityClasses$j(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$1({
        as: component,
        className: clsx(classes2.root, className),
        focusable: "false",
        color: htmlColor,
        "aria-hidden": titleAccess ? void 0 : true,
        role: titleAccess ? "img" : void 0,
        ref
      }, more, other, hasSvgAsChild && children.props, {
        ownerState,
        children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
          children: titleAccess
        }) : null]
      }));
    });
    SvgIcon.muiName = "SvgIcon";
    const SvgIcon$1 = SvgIcon;
    function createSvgIcon(path, displayName) {
      function Component(props, ref) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon$1, _extends$1({
          "data-testid": `${displayName}Icon`,
          ref
        }, props, {
          children: path
        }));
      }
      Component.muiName = SvgIcon$1.muiName;
      return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
    }
    function _setPrototypeOf(o2, p2) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
        o3.__proto__ = p3;
        return o3;
      };
      return _setPrototypeOf(o2, p2);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    const config = {
      disabled: false
    };
    const TransitionGroupContext = React.createContext(null);
    var forceReflow = function forceReflow2(node2) {
      return node2.scrollTop;
    };
    var UNMOUNTED = "unmounted";
    var EXITED = "exited";
    var ENTERING = "entering";
    var ENTERED = "entered";
    var EXITING = "exiting";
    var Transition = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(Transition2, _React$Component);
      function Transition2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var parentGroup = context;
        var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
        var initialStatus;
        _this.appearStatus = null;
        if (props.in) {
          if (appear) {
            initialStatus = EXITED;
            _this.appearStatus = ENTERING;
          } else {
            initialStatus = ENTERED;
          }
        } else {
          if (props.unmountOnExit || props.mountOnEnter) {
            initialStatus = UNMOUNTED;
          } else {
            initialStatus = EXITED;
          }
        }
        _this.state = {
          status: initialStatus
        };
        _this.nextCallback = null;
        return _this;
      }
      Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
        var nextIn = _ref.in;
        if (nextIn && prevState.status === UNMOUNTED) {
          return {
            status: EXITED
          };
        }
        return null;
      };
      var _proto = Transition2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.updateStatus(true, this.appearStatus);
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
        var nextStatus = null;
        if (prevProps !== this.props) {
          var status = this.state.status;
          if (this.props.in) {
            if (status !== ENTERING && status !== ENTERED) {
              nextStatus = ENTERING;
            }
          } else {
            if (status === ENTERING || status === ENTERED) {
              nextStatus = EXITING;
            }
          }
        }
        this.updateStatus(false, nextStatus);
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.cancelNextCallback();
      };
      _proto.getTimeouts = function getTimeouts() {
        var timeout = this.props.timeout;
        var exit, enter, appear;
        exit = enter = appear = timeout;
        if (timeout != null && typeof timeout !== "number") {
          exit = timeout.exit;
          enter = timeout.enter;
          appear = timeout.appear !== void 0 ? timeout.appear : enter;
        }
        return {
          exit,
          enter,
          appear
        };
      };
      _proto.updateStatus = function updateStatus(mounting, nextStatus) {
        if (mounting === void 0) {
          mounting = false;
        }
        if (nextStatus !== null) {
          this.cancelNextCallback();
          if (nextStatus === ENTERING) {
            if (this.props.unmountOnExit || this.props.mountOnEnter) {
              var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
              if (node2)
                forceReflow(node2);
            }
            this.performEnter(mounting);
          } else {
            this.performExit();
          }
        } else if (this.props.unmountOnExit && this.state.status === EXITED) {
          this.setState({
            status: UNMOUNTED
          });
        }
      };
      _proto.performEnter = function performEnter(mounting) {
        var _this2 = this;
        var enter = this.props.enter;
        var appearing = this.context ? this.context.isMounting : mounting;
        var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
        var timeouts = this.getTimeouts();
        var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
        if (!mounting && !enter || config.disabled) {
          this.safeSetState({
            status: ENTERED
          }, function() {
            _this2.props.onEntered(maybeNode);
          });
          return;
        }
        this.props.onEnter(maybeNode, maybeAppearing);
        this.safeSetState({
          status: ENTERING
        }, function() {
          _this2.props.onEntering(maybeNode, maybeAppearing);
          _this2.onTransitionEnd(enterTimeout, function() {
            _this2.safeSetState({
              status: ENTERED
            }, function() {
              _this2.props.onEntered(maybeNode, maybeAppearing);
            });
          });
        });
      };
      _proto.performExit = function performExit() {
        var _this3 = this;
        var exit = this.props.exit;
        var timeouts = this.getTimeouts();
        var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
        if (!exit || config.disabled) {
          this.safeSetState({
            status: EXITED
          }, function() {
            _this3.props.onExited(maybeNode);
          });
          return;
        }
        this.props.onExit(maybeNode);
        this.safeSetState({
          status: EXITING
        }, function() {
          _this3.props.onExiting(maybeNode);
          _this3.onTransitionEnd(timeouts.exit, function() {
            _this3.safeSetState({
              status: EXITED
            }, function() {
              _this3.props.onExited(maybeNode);
            });
          });
        });
      };
      _proto.cancelNextCallback = function cancelNextCallback() {
        if (this.nextCallback !== null) {
          this.nextCallback.cancel();
          this.nextCallback = null;
        }
      };
      _proto.safeSetState = function safeSetState(nextState, callback) {
        callback = this.setNextCallback(callback);
        this.setState(nextState, callback);
      };
      _proto.setNextCallback = function setNextCallback(callback) {
        var _this4 = this;
        var active = true;
        this.nextCallback = function(event) {
          if (active) {
            active = false;
            _this4.nextCallback = null;
            callback(event);
          }
        };
        this.nextCallback.cancel = function() {
          active = false;
        };
        return this.nextCallback;
      };
      _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
        this.setNextCallback(handler);
        var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
        var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
        if (!node2 || doesNotHaveTimeoutOrListener) {
          setTimeout(this.nextCallback, 0);
          return;
        }
        if (this.props.addEndListener) {
          var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
          this.props.addEndListener(maybeNode, maybeNextCallback);
        }
        if (timeout != null) {
          setTimeout(this.nextCallback, timeout);
        }
      };
      _proto.render = function render() {
        var status = this.state.status;
        if (status === UNMOUNTED) {
          return null;
        }
        var _this$props = this.props, children = _this$props.children;
        _this$props.in;
        _this$props.mountOnEnter;
        _this$props.unmountOnExit;
        _this$props.appear;
        _this$props.enter;
        _this$props.exit;
        _this$props.timeout;
        _this$props.addEndListener;
        _this$props.onEnter;
        _this$props.onEntering;
        _this$props.onEntered;
        _this$props.onExit;
        _this$props.onExiting;
        _this$props.onExited;
        _this$props.nodeRef;
        var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return (
          // allows for nested Transitions
          /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
            value: null
          }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
        );
      };
      return Transition2;
    }(React.Component);
    Transition.contextType = TransitionGroupContext;
    Transition.propTypes = {};
    function noop() {
    }
    Transition.defaultProps = {
      in: false,
      mountOnEnter: false,
      unmountOnExit: false,
      appear: false,
      enter: true,
      exit: true,
      onEnter: noop,
      onEntering: noop,
      onEntered: noop,
      onExit: noop,
      onExiting: noop,
      onExited: noop
    };
    Transition.UNMOUNTED = UNMOUNTED;
    Transition.EXITED = EXITED;
    Transition.ENTERING = ENTERING;
    Transition.ENTERED = ENTERED;
    Transition.EXITING = EXITING;
    const Transition$1 = Transition;
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function getChildMapping(children, mapFn) {
      var mapper = function mapper2(child) {
        return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
      };
      var result = /* @__PURE__ */ Object.create(null);
      if (children)
        reactExports.Children.map(children, function(c2) {
          return c2;
        }).forEach(function(child) {
          result[child.key] = mapper(child);
        });
      return result;
    }
    function mergeChildMappings(prev2, next2) {
      prev2 = prev2 || {};
      next2 = next2 || {};
      function getValueForKey(key) {
        return key in next2 ? next2[key] : prev2[key];
      }
      var nextKeysPending = /* @__PURE__ */ Object.create(null);
      var pendingKeys = [];
      for (var prevKey in prev2) {
        if (prevKey in next2) {
          if (pendingKeys.length) {
            nextKeysPending[prevKey] = pendingKeys;
            pendingKeys = [];
          }
        } else {
          pendingKeys.push(prevKey);
        }
      }
      var i2;
      var childMapping = {};
      for (var nextKey in next2) {
        if (nextKeysPending[nextKey]) {
          for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
            var pendingNextKey = nextKeysPending[nextKey][i2];
            childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
          }
        }
        childMapping[nextKey] = getValueForKey(nextKey);
      }
      for (i2 = 0; i2 < pendingKeys.length; i2++) {
        childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
      }
      return childMapping;
    }
    function getProp(child, prop, props) {
      return props[prop] != null ? props[prop] : child.props[prop];
    }
    function getInitialChildMapping(props, onExited) {
      return getChildMapping(props.children, function(child) {
        return reactExports.cloneElement(child, {
          onExited: onExited.bind(null, child),
          in: true,
          appear: getProp(child, "appear", props),
          enter: getProp(child, "enter", props),
          exit: getProp(child, "exit", props)
        });
      });
    }
    function getNextChildMapping(nextProps, prevChildMapping, onExited) {
      var nextChildMapping = getChildMapping(nextProps.children);
      var children = mergeChildMappings(prevChildMapping, nextChildMapping);
      Object.keys(children).forEach(function(key) {
        var child = children[key];
        if (!reactExports.isValidElement(child))
          return;
        var hasPrev = key in prevChildMapping;
        var hasNext = key in nextChildMapping;
        var prevChild = prevChildMapping[key];
        var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
        if (hasNext && (!hasPrev || isLeaving)) {
          children[key] = reactExports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: true,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        } else if (!hasNext && hasPrev && !isLeaving) {
          children[key] = reactExports.cloneElement(child, {
            in: false
          });
        } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
          children[key] = reactExports.cloneElement(child, {
            onExited: onExited.bind(null, child),
            in: prevChild.props.in,
            exit: getProp(child, "exit", nextProps),
            enter: getProp(child, "enter", nextProps)
          });
        }
      });
      return children;
    }
    var values = Object.values || function(obj) {
      return Object.keys(obj).map(function(k2) {
        return obj[k2];
      });
    };
    var defaultProps = {
      component: "div",
      childFactory: function childFactory(child) {
        return child;
      }
    };
    var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
      _inheritsLoose(TransitionGroup2, _React$Component);
      function TransitionGroup2(props, context) {
        var _this;
        _this = _React$Component.call(this, props, context) || this;
        var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
        _this.state = {
          contextValue: {
            isMounting: true
          },
          handleExited,
          firstRender: true
        };
        return _this;
      }
      var _proto = TransitionGroup2.prototype;
      _proto.componentDidMount = function componentDidMount() {
        this.mounted = true;
        this.setState({
          contextValue: {
            isMounting: false
          }
        });
      };
      _proto.componentWillUnmount = function componentWillUnmount() {
        this.mounted = false;
      };
      TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
        var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
        return {
          children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
          firstRender: false
        };
      };
      _proto.handleExited = function handleExited(child, node2) {
        var currentChildMapping = getChildMapping(this.props.children);
        if (child.key in currentChildMapping)
          return;
        if (child.props.onExited) {
          child.props.onExited(node2);
        }
        if (this.mounted) {
          this.setState(function(state) {
            var children = _extends$1({}, state.children);
            delete children[child.key];
            return {
              children
            };
          });
        }
      };
      _proto.render = function render() {
        var _this$props = this.props, Component = _this$props.component, childFactory = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
        var contextValue = this.state.contextValue;
        var children = values(this.state.children).map(childFactory);
        delete props.appear;
        delete props.enter;
        delete props.exit;
        if (Component === null) {
          return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
            value: contextValue
          }, children);
        }
        return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
          value: contextValue
        }, /* @__PURE__ */ React.createElement(Component, props, children));
      };
      return TransitionGroup2;
    }(React.Component);
    TransitionGroup.propTypes = {};
    TransitionGroup.defaultProps = defaultProps;
    const TransitionGroup$1 = TransitionGroup;
    const reflow = (node2) => node2.scrollTop;
    function getTransitionProps(props, options) {
      var _style$transitionDura, _style$transitionTimi;
      const {
        timeout,
        easing: easing2,
        style: style2 = {}
      } = props;
      return {
        duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
        easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
        delay: style2.transitionDelay
      };
    }
    function getCollapseUtilityClass(slot) {
      return generateUtilityClass("MuiCollapse", slot);
    }
    generateUtilityClasses("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
    const _excluded$p = ["addEndListener", "children", "className", "collapsedSize", "component", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "orientation", "style", "timeout", "TransitionComponent"];
    const useUtilityClasses$i = (ownerState) => {
      const {
        orientation,
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root", `${orientation}`],
        entered: ["entered"],
        hidden: ["hidden"],
        wrapper: ["wrapper", `${orientation}`],
        wrapperInner: ["wrapperInner", `${orientation}`]
      };
      return composeClasses(slots, getCollapseUtilityClass, classes2);
    };
    const CollapseRoot = styled$1("div", {
      name: "MuiCollapse",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.orientation], ownerState.state === "entered" && styles2.entered, ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && styles2.hidden];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      height: 0,
      overflow: "hidden",
      transition: theme.transitions.create("height")
    }, ownerState.orientation === "horizontal" && {
      height: "auto",
      width: 0,
      transition: theme.transitions.create("width")
    }, ownerState.state === "entered" && _extends$1({
      height: "auto",
      overflow: "visible"
    }, ownerState.orientation === "horizontal" && {
      width: "auto"
    }), ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && {
      visibility: "hidden"
    }));
    const CollapseWrapper = styled$1("div", {
      name: "MuiCollapse",
      slot: "Wrapper",
      overridesResolver: (props, styles2) => styles2.wrapper
    })(({
      ownerState
    }) => _extends$1({
      // Hack to get children with a negative margin to not falsify the height computation.
      display: "flex",
      width: "100%"
    }, ownerState.orientation === "horizontal" && {
      width: "auto",
      height: "100%"
    }));
    const CollapseWrapperInner = styled$1("div", {
      name: "MuiCollapse",
      slot: "WrapperInner",
      overridesResolver: (props, styles2) => styles2.wrapperInner
    })(({
      ownerState
    }) => _extends$1({
      width: "100%"
    }, ownerState.orientation === "horizontal" && {
      width: "auto",
      height: "100%"
    }));
    const Collapse = /* @__PURE__ */ reactExports.forwardRef(function Collapse2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiCollapse"
      });
      const {
        addEndListener,
        children,
        className,
        collapsedSize: collapsedSizeProp = "0px",
        component,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        orientation = "vertical",
        style: style2,
        timeout = duration.standard,
        // eslint-disable-next-line react/prop-types
        TransitionComponent = Transition$1
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$p);
      const ownerState = _extends$1({}, props, {
        orientation,
        collapsedSize: collapsedSizeProp
      });
      const classes2 = useUtilityClasses$i(ownerState);
      const theme = useTheme();
      const timer = reactExports.useRef();
      const wrapperRef = reactExports.useRef(null);
      const autoTransitionDuration = reactExports.useRef();
      const collapsedSize = typeof collapsedSizeProp === "number" ? `${collapsedSizeProp}px` : collapsedSizeProp;
      const isHorizontal = orientation === "horizontal";
      const size = isHorizontal ? "width" : "height";
      reactExports.useEffect(() => {
        return () => {
          clearTimeout(timer.current);
        };
      }, []);
      const nodeRef = reactExports.useRef(null);
      const handleRef = useForkRef(ref, nodeRef);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const getWrapperSize = () => wrapperRef.current ? wrapperRef.current[isHorizontal ? "clientWidth" : "clientHeight"] : 0;
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        if (wrapperRef.current && isHorizontal) {
          wrapperRef.current.style.position = "absolute";
        }
        node2.style[size] = collapsedSize;
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
        const wrapperSize = getWrapperSize();
        if (wrapperRef.current && isHorizontal) {
          wrapperRef.current.style.position = "";
        }
        const {
          duration: transitionDuration,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        if (timeout === "auto") {
          const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
          node2.style.transitionDuration = `${duration2}ms`;
          autoTransitionDuration.current = duration2;
        } else {
          node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
        }
        node2.style[size] = `${wrapperSize}px`;
        node2.style.transitionTimingFunction = transitionTimingFunction;
        if (onEntering) {
          onEntering(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback((node2, isAppearing) => {
        node2.style[size] = "auto";
        if (onEntered) {
          onEntered(node2, isAppearing);
        }
      });
      const handleExit = normalizedTransitionCallback((node2) => {
        node2.style[size] = `${getWrapperSize()}px`;
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleExiting = normalizedTransitionCallback((node2) => {
        const wrapperSize = getWrapperSize();
        const {
          duration: transitionDuration,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        if (timeout === "auto") {
          const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
          node2.style.transitionDuration = `${duration2}ms`;
          autoTransitionDuration.current = duration2;
        } else {
          node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
        }
        node2.style[size] = collapsedSize;
        node2.style.transitionTimingFunction = transitionTimingFunction;
        if (onExiting) {
          onExiting(node2);
        }
      });
      const handleAddEndListener = (next2) => {
        if (timeout === "auto") {
          timer.current = setTimeout(next2, autoTransitionDuration.current || 0);
        }
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        in: inProp,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        nodeRef,
        timeout: timeout === "auto" ? null : timeout
      }, other, {
        children: (state, childProps) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseRoot, _extends$1({
          as: component,
          className: clsx(classes2.root, className, {
            "entered": classes2.entered,
            "exited": !inProp && collapsedSize === "0px" && classes2.hidden
          }[state]),
          style: _extends$1({
            [isHorizontal ? "minWidth" : "minHeight"]: collapsedSize
          }, style2),
          ownerState: _extends$1({}, ownerState, {
            state
          }),
          ref: handleRef
        }, childProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapper, {
            ownerState: _extends$1({}, ownerState, {
              state
            }),
            className: classes2.wrapper,
            ref: wrapperRef,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapperInner, {
              ownerState: _extends$1({}, ownerState, {
                state
              }),
              className: classes2.wrapperInner,
              children
            })
          })
        }))
      }));
    });
    Collapse.muiSupportAuto = true;
    const Collapse$1 = Collapse;
    function getPaperUtilityClass(slot) {
      return generateUtilityClass("MuiPaper", slot);
    }
    generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
    const _excluded$o = ["className", "component", "elevation", "square", "variant"];
    const useUtilityClasses$h = (ownerState) => {
      const {
        square,
        elevation,
        variant,
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
      };
      return composeClasses(slots, getPaperUtilityClass, classes2);
    };
    const PaperRoot = styled$1("div", {
      name: "MuiPaper",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _theme$vars$overlays;
      return _extends$1({
        backgroundColor: (theme.vars || theme).palette.background.paper,
        color: (theme.vars || theme).palette.text.primary,
        transition: theme.transitions.create("box-shadow")
      }, !ownerState.square && {
        borderRadius: theme.shape.borderRadius
      }, ownerState.variant === "outlined" && {
        border: `1px solid ${(theme.vars || theme).palette.divider}`
      }, ownerState.variant === "elevation" && _extends$1({
        boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
      }, !theme.vars && theme.palette.mode === "dark" && {
        backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))})`
      }, theme.vars && {
        backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
      }));
    });
    const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiPaper"
      });
      const {
        className,
        component = "div",
        elevation = 1,
        square = false,
        variant = "elevation"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$o);
      const ownerState = _extends$1({}, props, {
        component,
        elevation,
        square,
        variant
      });
      const classes2 = useUtilityClasses$h(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$1({
        as: component,
        ownerState,
        className: clsx(classes2.root, className),
        ref
      }, other));
    });
    const Paper$1 = Paper;
    const AccordionContext = /* @__PURE__ */ reactExports.createContext({});
    const AccordionContext$1 = AccordionContext;
    function getAccordionUtilityClass(slot) {
      return generateUtilityClass("MuiAccordion", slot);
    }
    const accordionClasses = generateUtilityClasses("MuiAccordion", ["root", "rounded", "expanded", "disabled", "gutters", "region"]);
    const accordionClasses$1 = accordionClasses;
    const _excluded$n = ["children", "className", "defaultExpanded", "disabled", "disableGutters", "expanded", "onChange", "square", "TransitionComponent", "TransitionProps"];
    const useUtilityClasses$g = (ownerState) => {
      const {
        classes: classes2,
        square,
        expanded,
        disabled,
        disableGutters
      } = ownerState;
      const slots = {
        root: ["root", !square && "rounded", expanded && "expanded", disabled && "disabled", !disableGutters && "gutters"],
        region: ["region"]
      };
      return composeClasses(slots, getAccordionUtilityClass, classes2);
    };
    const AccordionRoot = styled$1(Paper$1, {
      name: "MuiAccordion",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [{
          [`& .${accordionClasses$1.region}`]: styles2.region
        }, styles2.root, !ownerState.square && styles2.rounded, !ownerState.disableGutters && styles2.gutters];
      }
    })(({
      theme
    }) => {
      const transition2 = {
        duration: theme.transitions.duration.shortest
      };
      return {
        position: "relative",
        transition: theme.transitions.create(["margin"], transition2),
        overflowAnchor: "none",
        // Keep the same scrolling position
        "&:before": {
          position: "absolute",
          left: 0,
          top: -1,
          right: 0,
          height: 1,
          content: '""',
          opacity: 1,
          backgroundColor: (theme.vars || theme).palette.divider,
          transition: theme.transitions.create(["opacity", "background-color"], transition2)
        },
        "&:first-of-type": {
          "&:before": {
            display: "none"
          }
        },
        [`&.${accordionClasses$1.expanded}`]: {
          "&:before": {
            opacity: 0
          },
          "&:first-of-type": {
            marginTop: 0
          },
          "&:last-of-type": {
            marginBottom: 0
          },
          "& + &": {
            "&:before": {
              display: "none"
            }
          }
        },
        [`&.${accordionClasses$1.disabled}`]: {
          backgroundColor: (theme.vars || theme).palette.action.disabledBackground
        }
      };
    }, ({
      theme,
      ownerState
    }) => _extends$1({}, !ownerState.square && {
      borderRadius: 0,
      "&:first-of-type": {
        borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
        borderTopRightRadius: (theme.vars || theme).shape.borderRadius
      },
      "&:last-of-type": {
        borderBottomLeftRadius: (theme.vars || theme).shape.borderRadius,
        borderBottomRightRadius: (theme.vars || theme).shape.borderRadius,
        // Fix a rendering issue on Edge
        "@supports (-ms-ime-align: auto)": {
          borderBottomLeftRadius: 0,
          borderBottomRightRadius: 0
        }
      }
    }, !ownerState.disableGutters && {
      [`&.${accordionClasses$1.expanded}`]: {
        margin: "16px 0"
      }
    }));
    const Accordion = /* @__PURE__ */ reactExports.forwardRef(function Accordion2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiAccordion"
      });
      const {
        children: childrenProp,
        className,
        defaultExpanded = false,
        disabled = false,
        disableGutters = false,
        expanded: expandedProp,
        onChange,
        square = false,
        TransitionComponent = Collapse$1,
        TransitionProps
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$n);
      const [expanded, setExpandedState] = useControlled({
        controlled: expandedProp,
        default: defaultExpanded,
        name: "Accordion",
        state: "expanded"
      });
      const handleChange = reactExports.useCallback((event) => {
        setExpandedState(!expanded);
        if (onChange) {
          onChange(event, !expanded);
        }
      }, [expanded, onChange, setExpandedState]);
      const [summary, ...children] = reactExports.Children.toArray(childrenProp);
      const contextValue = reactExports.useMemo(() => ({
        expanded,
        disabled,
        disableGutters,
        toggle: handleChange
      }), [expanded, disabled, disableGutters, handleChange]);
      const ownerState = _extends$1({}, props, {
        square,
        disabled,
        disableGutters,
        expanded
      });
      const classes2 = useUtilityClasses$g(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(AccordionRoot, _extends$1({
        className: clsx(classes2.root, className),
        ref,
        ownerState,
        square
      }, other, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AccordionContext$1.Provider, {
          value: contextValue,
          children: summary
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
          in: expanded,
          timeout: "auto"
        }, TransitionProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
            "aria-labelledby": summary.props.id,
            id: summary.props["aria-controls"],
            role: "region",
            className: classes2.region,
            children
          })
        }))]
      }));
    });
    const Accordion$1 = Accordion;
    function getAccordionDetailsUtilityClass(slot) {
      return generateUtilityClass("MuiAccordionDetails", slot);
    }
    generateUtilityClasses("MuiAccordionDetails", ["root"]);
    const _excluded$m = ["className"];
    const useUtilityClasses$f = (ownerState) => {
      const {
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root"]
      };
      return composeClasses(slots, getAccordionDetailsUtilityClass, classes2);
    };
    const AccordionDetailsRoot = styled$1("div", {
      name: "MuiAccordionDetails",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      theme
    }) => ({
      padding: theme.spacing(1, 2, 2)
    }));
    const AccordionDetails = /* @__PURE__ */ reactExports.forwardRef(function AccordionDetails2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiAccordionDetails"
      });
      const {
        className
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$m);
      const ownerState = props;
      const classes2 = useUtilityClasses$f(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionDetailsRoot, _extends$1({
        className: clsx(classes2.root, className),
        ref,
        ownerState
      }, other));
    });
    const AccordionDetails$1 = AccordionDetails;
    function Ripple(props) {
      const {
        className,
        classes: classes2,
        pulsate = false,
        rippleX,
        rippleY,
        rippleSize,
        in: inProp,
        onExited,
        timeout
      } = props;
      const [leaving, setLeaving] = reactExports.useState(false);
      const rippleClassName = clsx(className, classes2.ripple, classes2.rippleVisible, pulsate && classes2.ripplePulsate);
      const rippleStyles = {
        width: rippleSize,
        height: rippleSize,
        top: -(rippleSize / 2) + rippleY,
        left: -(rippleSize / 2) + rippleX
      };
      const childClassName = clsx(classes2.child, leaving && classes2.childLeaving, pulsate && classes2.childPulsate);
      if (!inProp && !leaving) {
        setLeaving(true);
      }
      reactExports.useEffect(() => {
        if (!inProp && onExited != null) {
          const timeoutId = setTimeout(onExited, timeout);
          return () => {
            clearTimeout(timeoutId);
          };
        }
        return void 0;
      }, [onExited, inProp, timeout]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        className: rippleClassName,
        style: rippleStyles,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: childClassName
        })
      });
    }
    const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
    const touchRippleClasses$1 = touchRippleClasses;
    const _excluded$l = ["center", "classes", "className"];
    let _$1 = (t2) => t2, _t$1, _t2, _t3, _t4;
    const DURATION = 550;
    const DELAY_RIPPLE = 80;
    const enterKeyframe = keyframes(_t$1 || (_t$1 = _$1`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
    const exitKeyframe = keyframes(_t2 || (_t2 = _$1`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
    const pulsateKeyframe = keyframes(_t3 || (_t3 = _$1`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
    const TouchRippleRoot = styled$1("span", {
      name: "MuiTouchRipple",
      slot: "Root"
    })({
      overflow: "hidden",
      pointerEvents: "none",
      position: "absolute",
      zIndex: 0,
      top: 0,
      right: 0,
      bottom: 0,
      left: 0,
      borderRadius: "inherit"
    });
    const TouchRippleRipple = styled$1(Ripple, {
      name: "MuiTouchRipple",
      slot: "Ripple"
    })(_t4 || (_t4 = _$1`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
      theme
    }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
      theme
    }) => theme.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
      theme
    }) => theme.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
      theme
    }) => theme.transitions.easing.easeInOut);
    const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiTouchRipple"
      });
      const {
        center: centerProp = false,
        classes: classes2 = {},
        className
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$l);
      const [ripples, setRipples] = reactExports.useState([]);
      const nextKey = reactExports.useRef(0);
      const rippleCallback = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (rippleCallback.current) {
          rippleCallback.current();
          rippleCallback.current = null;
        }
      }, [ripples]);
      const ignoringMouseDown = reactExports.useRef(false);
      const startTimer = reactExports.useRef(0);
      const startTimerCommit = reactExports.useRef(null);
      const container = reactExports.useRef(null);
      reactExports.useEffect(() => {
        return () => {
          if (startTimer.current) {
            clearTimeout(startTimer.current);
          }
        };
      }, []);
      const startCommit = reactExports.useCallback((params) => {
        const {
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize,
          cb: cb2
        } = params;
        setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
          classes: {
            ripple: clsx(classes2.ripple, touchRippleClasses$1.ripple),
            rippleVisible: clsx(classes2.rippleVisible, touchRippleClasses$1.rippleVisible),
            ripplePulsate: clsx(classes2.ripplePulsate, touchRippleClasses$1.ripplePulsate),
            child: clsx(classes2.child, touchRippleClasses$1.child),
            childLeaving: clsx(classes2.childLeaving, touchRippleClasses$1.childLeaving),
            childPulsate: clsx(classes2.childPulsate, touchRippleClasses$1.childPulsate)
          },
          timeout: DURATION,
          pulsate: pulsate2,
          rippleX,
          rippleY,
          rippleSize
        }, nextKey.current)]);
        nextKey.current += 1;
        rippleCallback.current = cb2;
      }, [classes2]);
      const start = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
      }) => {
        const {
          pulsate: pulsate2 = false,
          center = centerProp || options.pulsate,
          fakeElement = false
          // For test purposes
        } = options;
        if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
          ignoringMouseDown.current = false;
          return;
        }
        if ((event == null ? void 0 : event.type) === "touchstart") {
          ignoringMouseDown.current = true;
        }
        const element = fakeElement ? null : container.current;
        const rect = element ? element.getBoundingClientRect() : {
          width: 0,
          height: 0,
          left: 0,
          top: 0
        };
        let rippleX;
        let rippleY;
        let rippleSize;
        if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
          rippleX = Math.round(rect.width / 2);
          rippleY = Math.round(rect.height / 2);
        } else {
          const {
            clientX,
            clientY
          } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
          rippleX = Math.round(clientX - rect.left);
          rippleY = Math.round(clientY - rect.top);
        }
        if (center) {
          rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
          if (rippleSize % 2 === 0) {
            rippleSize += 1;
          }
        } else {
          const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
          const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
          rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
        }
        if (event != null && event.touches) {
          if (startTimerCommit.current === null) {
            startTimerCommit.current = () => {
              startCommit({
                pulsate: pulsate2,
                rippleX,
                rippleY,
                rippleSize,
                cb: cb2
              });
            };
            startTimer.current = setTimeout(() => {
              if (startTimerCommit.current) {
                startTimerCommit.current();
                startTimerCommit.current = null;
              }
            }, DELAY_RIPPLE);
          }
        } else {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        }
      }, [centerProp, startCommit]);
      const pulsate = reactExports.useCallback(() => {
        start({}, {
          pulsate: true
        });
      }, [start]);
      const stop = reactExports.useCallback((event, cb2) => {
        clearTimeout(startTimer.current);
        if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
          startTimerCommit.current();
          startTimerCommit.current = null;
          startTimer.current = setTimeout(() => {
            stop(event, cb2);
          });
          return;
        }
        startTimerCommit.current = null;
        setRipples((oldRipples) => {
          if (oldRipples.length > 0) {
            return oldRipples.slice(1);
          }
          return oldRipples;
        });
        rippleCallback.current = cb2;
      }, []);
      reactExports.useImperativeHandle(ref, () => ({
        pulsate,
        start,
        stop
      }), [pulsate, start, stop]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$1({
        className: clsx(touchRippleClasses$1.root, classes2.root, className),
        ref: container
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
          component: null,
          exit: true,
          children: ripples
        })
      }));
    });
    const TouchRipple$1 = TouchRipple;
    function getButtonBaseUtilityClass(slot) {
      return generateUtilityClass("MuiButtonBase", slot);
    }
    const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
    const buttonBaseClasses$1 = buttonBaseClasses;
    const _excluded$k = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
    const useUtilityClasses$e = (ownerState) => {
      const {
        disabled,
        focusVisible,
        focusVisibleClassName,
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
      };
      const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes2);
      if (focusVisible && focusVisibleClassName) {
        composedClasses.root += ` ${focusVisibleClassName}`;
      }
      return composedClasses;
    };
    const ButtonBaseRoot = styled$1("button", {
      name: "MuiButtonBase",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      position: "relative",
      boxSizing: "border-box",
      WebkitTapHighlightColor: "transparent",
      backgroundColor: "transparent",
      // Reset default value
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0,
      border: 0,
      margin: 0,
      // Remove the margin in Safari
      borderRadius: 0,
      padding: 0,
      // Remove the padding in Firefox
      cursor: "pointer",
      userSelect: "none",
      verticalAlign: "middle",
      MozAppearance: "none",
      // Reset
      WebkitAppearance: "none",
      // Reset
      textDecoration: "none",
      // So we take precedent over the style of a native <a /> element.
      color: "inherit",
      "&::-moz-focus-inner": {
        borderStyle: "none"
        // Remove Firefox dotted outline.
      },
      [`&.${buttonBaseClasses$1.disabled}`]: {
        pointerEvents: "none",
        // Disable link interactions
        cursor: "default"
      },
      "@media print": {
        colorAdjust: "exact"
      }
    });
    const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiButtonBase"
      });
      const {
        action,
        centerRipple = false,
        children,
        className,
        component = "button",
        disabled = false,
        disableRipple = false,
        disableTouchRipple = false,
        focusRipple = false,
        LinkComponent = "a",
        onBlur,
        onClick: onClick2,
        onContextMenu,
        onDragLeave,
        onFocus: onFocus2,
        onFocusVisible,
        onKeyDown,
        onKeyUp,
        onMouseDown,
        onMouseLeave,
        onMouseUp,
        onTouchEnd: onTouchEnd2,
        onTouchMove: onTouchMove2,
        onTouchStart: onTouchStart2,
        tabIndex = 0,
        TouchRippleProps,
        touchRippleRef,
        type
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$k);
      const buttonRef = reactExports.useRef(null);
      const rippleRef = reactExports.useRef(null);
      const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
      const {
        isFocusVisibleRef,
        onFocus: handleFocusVisible,
        onBlur: handleBlurVisible,
        ref: focusVisibleRef
      } = useIsFocusVisible();
      const [focusVisible, setFocusVisible] = reactExports.useState(false);
      if (disabled && focusVisible) {
        setFocusVisible(false);
      }
      reactExports.useImperativeHandle(action, () => ({
        focusVisible: () => {
          setFocusVisible(true);
          buttonRef.current.focus();
        }
      }), []);
      const [mountedState, setMountedState] = reactExports.useState(false);
      reactExports.useEffect(() => {
        setMountedState(true);
      }, []);
      const enableTouchRipple = mountedState && !disableRipple && !disabled;
      reactExports.useEffect(() => {
        if (focusVisible && focusRipple && !disableRipple && mountedState) {
          rippleRef.current.pulsate();
        }
      }, [disableRipple, focusRipple, focusVisible, mountedState]);
      function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
        return useEventCallback((event) => {
          if (eventCallback) {
            eventCallback(event);
          }
          const ignore = skipRippleAction;
          if (!ignore && rippleRef.current) {
            rippleRef.current[rippleAction](event);
          }
          return true;
        });
      }
      const handleMouseDown = useRippleHandler("start", onMouseDown);
      const handleContextMenu = useRippleHandler("stop", onContextMenu);
      const handleDragLeave = useRippleHandler("stop", onDragLeave);
      const handleMouseUp = useRippleHandler("stop", onMouseUp);
      const handleMouseLeave = useRippleHandler("stop", (event) => {
        if (focusVisible) {
          event.preventDefault();
        }
        if (onMouseLeave) {
          onMouseLeave(event);
        }
      });
      const handleTouchStart = useRippleHandler("start", onTouchStart2);
      const handleTouchEnd = useRippleHandler("stop", onTouchEnd2);
      const handleTouchMove = useRippleHandler("stop", onTouchMove2);
      const handleBlur = useRippleHandler("stop", (event) => {
        handleBlurVisible(event);
        if (isFocusVisibleRef.current === false) {
          setFocusVisible(false);
        }
        if (onBlur) {
          onBlur(event);
        }
      }, false);
      const handleFocus = useEventCallback((event) => {
        if (!buttonRef.current) {
          buttonRef.current = event.currentTarget;
        }
        handleFocusVisible(event);
        if (isFocusVisibleRef.current === true) {
          setFocusVisible(true);
          if (onFocusVisible) {
            onFocusVisible(event);
          }
        }
        if (onFocus2) {
          onFocus2(event);
        }
      });
      const isNonNativeButton = () => {
        const button = buttonRef.current;
        return component && component !== "button" && !(button.tagName === "A" && button.href);
      };
      const keydownRef = reactExports.useRef(false);
      const handleKeyDown2 = useEventCallback((event) => {
        if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
          keydownRef.current = true;
          rippleRef.current.stop(event, () => {
            rippleRef.current.start(event);
          });
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
          event.preventDefault();
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
        if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
          event.preventDefault();
          if (onClick2) {
            onClick2(event);
          }
        }
      });
      const handleKeyUp = useEventCallback((event) => {
        if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
          keydownRef.current = false;
          rippleRef.current.stop(event, () => {
            rippleRef.current.pulsate(event);
          });
        }
        if (onKeyUp) {
          onKeyUp(event);
        }
        if (onClick2 && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
          onClick2(event);
        }
      });
      let ComponentProp = component;
      if (ComponentProp === "button" && (other.href || other.to)) {
        ComponentProp = LinkComponent;
      }
      const buttonProps = {};
      if (ComponentProp === "button") {
        buttonProps.type = type === void 0 ? "button" : type;
        buttonProps.disabled = disabled;
      } else {
        if (!other.href && !other.to) {
          buttonProps.role = "button";
        }
        if (disabled) {
          buttonProps["aria-disabled"] = disabled;
        }
      }
      const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
      const ownerState = _extends$1({}, props, {
        centerRipple,
        component,
        disabled,
        disableRipple,
        disableTouchRipple,
        focusRipple,
        tabIndex,
        focusVisible
      });
      const classes2 = useUtilityClasses$e(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$1({
        as: ComponentProp,
        className: clsx(classes2.root, className),
        ownerState,
        onBlur: handleBlur,
        onClick: onClick2,
        onContextMenu: handleContextMenu,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown2,
        onKeyUp: handleKeyUp,
        onMouseDown: handleMouseDown,
        onMouseLeave: handleMouseLeave,
        onMouseUp: handleMouseUp,
        onDragLeave: handleDragLeave,
        onTouchEnd: handleTouchEnd,
        onTouchMove: handleTouchMove,
        onTouchStart: handleTouchStart,
        ref: handleRef,
        tabIndex: disabled ? -1 : tabIndex,
        type
      }, buttonProps, other, {
        children: [children, enableTouchRipple ? (
          /* TouchRipple is only needed client-side, x2 boost on the server. */
          /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends$1({
            ref: handleRippleRef,
            center: centerRipple
          }, TouchRippleProps))
        ) : null]
      }));
    });
    const ButtonBase$1 = ButtonBase;
    function getAccordionSummaryUtilityClass(slot) {
      return generateUtilityClass("MuiAccordionSummary", slot);
    }
    const accordionSummaryClasses = generateUtilityClasses("MuiAccordionSummary", ["root", "expanded", "focusVisible", "disabled", "gutters", "contentGutters", "content", "expandIconWrapper"]);
    const accordionSummaryClasses$1 = accordionSummaryClasses;
    const _excluded$j = ["children", "className", "expandIcon", "focusVisibleClassName", "onClick"];
    const useUtilityClasses$d = (ownerState) => {
      const {
        classes: classes2,
        expanded,
        disabled,
        disableGutters
      } = ownerState;
      const slots = {
        root: ["root", expanded && "expanded", disabled && "disabled", !disableGutters && "gutters"],
        focusVisible: ["focusVisible"],
        content: ["content", expanded && "expanded", !disableGutters && "contentGutters"],
        expandIconWrapper: ["expandIconWrapper", expanded && "expanded"]
      };
      return composeClasses(slots, getAccordionSummaryUtilityClass, classes2);
    };
    const AccordionSummaryRoot = styled$1(ButtonBase$1, {
      name: "MuiAccordionSummary",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })(({
      theme,
      ownerState
    }) => {
      const transition2 = {
        duration: theme.transitions.duration.shortest
      };
      return _extends$1({
        display: "flex",
        minHeight: 48,
        padding: theme.spacing(0, 2),
        transition: theme.transitions.create(["min-height", "background-color"], transition2),
        [`&.${accordionSummaryClasses$1.focusVisible}`]: {
          backgroundColor: (theme.vars || theme).palette.action.focus
        },
        [`&.${accordionSummaryClasses$1.disabled}`]: {
          opacity: (theme.vars || theme).palette.action.disabledOpacity
        },
        [`&:hover:not(.${accordionSummaryClasses$1.disabled})`]: {
          cursor: "pointer"
        }
      }, !ownerState.disableGutters && {
        [`&.${accordionSummaryClasses$1.expanded}`]: {
          minHeight: 64
        }
      });
    });
    const AccordionSummaryContent = styled$1("div", {
      name: "MuiAccordionSummary",
      slot: "Content",
      overridesResolver: (props, styles2) => styles2.content
    })(({
      theme,
      ownerState
    }) => _extends$1({
      display: "flex",
      flexGrow: 1,
      margin: "12px 0"
    }, !ownerState.disableGutters && {
      transition: theme.transitions.create(["margin"], {
        duration: theme.transitions.duration.shortest
      }),
      [`&.${accordionSummaryClasses$1.expanded}`]: {
        margin: "20px 0"
      }
    }));
    const AccordionSummaryExpandIconWrapper = styled$1("div", {
      name: "MuiAccordionSummary",
      slot: "ExpandIconWrapper",
      overridesResolver: (props, styles2) => styles2.expandIconWrapper
    })(({
      theme
    }) => ({
      display: "flex",
      color: (theme.vars || theme).palette.action.active,
      transform: "rotate(0deg)",
      transition: theme.transitions.create("transform", {
        duration: theme.transitions.duration.shortest
      }),
      [`&.${accordionSummaryClasses$1.expanded}`]: {
        transform: "rotate(180deg)"
      }
    }));
    const AccordionSummary = /* @__PURE__ */ reactExports.forwardRef(function AccordionSummary2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiAccordionSummary"
      });
      const {
        children,
        className,
        expandIcon,
        focusVisibleClassName,
        onClick: onClick2
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$j);
      const {
        disabled = false,
        disableGutters,
        expanded,
        toggle
      } = reactExports.useContext(AccordionContext$1);
      const handleChange = (event) => {
        if (toggle) {
          toggle(event);
        }
        if (onClick2) {
          onClick2(event);
        }
      };
      const ownerState = _extends$1({}, props, {
        expanded,
        disabled,
        disableGutters
      });
      const classes2 = useUtilityClasses$d(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(AccordionSummaryRoot, _extends$1({
        focusRipple: false,
        disableRipple: true,
        disabled,
        component: "div",
        "aria-expanded": expanded,
        className: clsx(classes2.root, className),
        focusVisibleClassName: clsx(classes2.focusVisible, focusVisibleClassName),
        onClick: handleChange,
        ref,
        ownerState
      }, other, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AccordionSummaryContent, {
          className: classes2.content,
          ownerState,
          children
        }), expandIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionSummaryExpandIconWrapper, {
          className: classes2.expandIconWrapper,
          ownerState,
          children: expandIcon
        })]
      }));
    });
    const AccordionSummary$1 = AccordionSummary;
    function isHostComponent(element) {
      return typeof element === "string";
    }
    function appendOwnerState(elementType, otherProps, ownerState) {
      if (elementType === void 0 || isHostComponent(elementType)) {
        return otherProps;
      }
      return _extends$1({}, otherProps, {
        ownerState: _extends$1({}, otherProps.ownerState, ownerState)
      });
    }
    function extractEventHandlers(object, excludeKeys = []) {
      if (object === void 0) {
        return {};
      }
      const result = {};
      Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
        result[prop] = object[prop];
      });
      return result;
    }
    function resolveComponentProps(componentProps, ownerState, slotState) {
      if (typeof componentProps === "function") {
        return componentProps(ownerState, slotState);
      }
      return componentProps;
    }
    function omitEventHandlers(object) {
      if (object === void 0) {
        return {};
      }
      const result = {};
      Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
        result[prop] = object[prop];
      });
      return result;
    }
    function mergeSlotProps(parameters) {
      const {
        getSlotProps,
        additionalProps,
        externalSlotProps,
        externalForwardedProps,
        className
      } = parameters;
      if (!getSlotProps) {
        const joinedClasses2 = clsx(additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
        const mergedStyle2 = _extends$1({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
        const props2 = _extends$1({}, additionalProps, externalForwardedProps, externalSlotProps);
        if (joinedClasses2.length > 0) {
          props2.className = joinedClasses2;
        }
        if (Object.keys(mergedStyle2).length > 0) {
          props2.style = mergedStyle2;
        }
        return {
          props: props2,
          internalRef: void 0
        };
      }
      const eventHandlers = extractEventHandlers(_extends$1({}, externalForwardedProps, externalSlotProps));
      const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
      const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
      const internalSlotProps = getSlotProps(eventHandlers);
      const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
      const mergedStyle = _extends$1({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
      const props = _extends$1({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
      if (joinedClasses.length > 0) {
        props.className = joinedClasses;
      }
      if (Object.keys(mergedStyle).length > 0) {
        props.style = mergedStyle;
      }
      return {
        props,
        internalRef: internalSlotProps.ref
      };
    }
    const _excluded$i = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
    function useSlotProps(parameters) {
      var _parameters$additiona;
      const {
        elementType,
        externalSlotProps,
        ownerState,
        skipResolvingSlotProps = false
      } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded$i);
      const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
      const {
        props: mergedProps,
        internalRef
      } = mergeSlotProps(_extends$1({}, rest, {
        externalSlotProps: resolvedComponentsProps
      }));
      const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
      const props = appendOwnerState(elementType, _extends$1({}, mergedProps, {
        ref
      }), ownerState);
      return props;
    }
    const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
    function getTabIndex(node2) {
      const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
      if (!Number.isNaN(tabindexAttr)) {
        return tabindexAttr;
      }
      if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
        return 0;
      }
      return node2.tabIndex;
    }
    function isNonTabbableRadio(node2) {
      if (node2.tagName !== "INPUT" || node2.type !== "radio") {
        return false;
      }
      if (!node2.name) {
        return false;
      }
      const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
      let roving = getRadio(`[name="${node2.name}"]:checked`);
      if (!roving) {
        roving = getRadio(`[name="${node2.name}"]`);
      }
      return roving !== node2;
    }
    function isNodeMatchingSelectorFocusable(node2) {
      if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
        return false;
      }
      return true;
    }
    function defaultGetTabbable(root) {
      const regularTabNodes = [];
      const orderedTabNodes = [];
      Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i2) => {
        const nodeTabIndex = getTabIndex(node2);
        if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
          return;
        }
        if (nodeTabIndex === 0) {
          regularTabNodes.push(node2);
        } else {
          orderedTabNodes.push({
            documentOrder: i2,
            tabIndex: nodeTabIndex,
            node: node2
          });
        }
      });
      return orderedTabNodes.sort((a2, b2) => a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
    }
    function defaultIsEnabled() {
      return true;
    }
    function FocusTrap(props) {
      const {
        children,
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableRestoreFocus = false,
        getTabbable = defaultGetTabbable,
        isEnabled = defaultIsEnabled,
        open
      } = props;
      const ignoreNextEnforceFocus = reactExports.useRef(false);
      const sentinelStart = reactExports.useRef(null);
      const sentinelEnd = reactExports.useRef(null);
      const nodeToRestore = reactExports.useRef(null);
      const reactFocusEventTarget = reactExports.useRef(null);
      const activated = reactExports.useRef(false);
      const rootRef = reactExports.useRef(null);
      const handleRef = useForkRef(children.ref, rootRef);
      const lastKeydown = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        activated.current = !disableAutoFocus;
      }, [disableAutoFocus, open]);
      reactExports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        const doc = ownerDocument(rootRef.current);
        if (!rootRef.current.contains(doc.activeElement)) {
          if (!rootRef.current.hasAttribute("tabIndex")) {
            rootRef.current.setAttribute("tabIndex", "-1");
          }
          if (activated.current) {
            rootRef.current.focus();
          }
        }
        return () => {
          if (!disableRestoreFocus) {
            if (nodeToRestore.current && nodeToRestore.current.focus) {
              ignoreNextEnforceFocus.current = true;
              nodeToRestore.current.focus();
            }
            nodeToRestore.current = null;
          }
        };
      }, [open]);
      reactExports.useEffect(() => {
        if (!open || !rootRef.current) {
          return;
        }
        const doc = ownerDocument(rootRef.current);
        const loopFocus = (nativeEvent) => {
          lastKeydown.current = nativeEvent;
          if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
            return;
          }
          if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
            ignoreNextEnforceFocus.current = true;
            if (sentinelEnd.current) {
              sentinelEnd.current.focus();
            }
          }
        };
        const contain = () => {
          const rootElement = rootRef.current;
          if (rootElement === null) {
            return;
          }
          if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
            ignoreNextEnforceFocus.current = false;
            return;
          }
          if (rootElement.contains(doc.activeElement)) {
            return;
          }
          if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
            return;
          }
          if (doc.activeElement !== reactFocusEventTarget.current) {
            reactFocusEventTarget.current = null;
          } else if (reactFocusEventTarget.current !== null) {
            return;
          }
          if (!activated.current) {
            return;
          }
          let tabbable = [];
          if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
            tabbable = getTabbable(rootRef.current);
          }
          if (tabbable.length > 0) {
            var _lastKeydown$current, _lastKeydown$current2;
            const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
            const focusNext = tabbable[0];
            const focusPrevious = tabbable[tabbable.length - 1];
            if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
              if (isShiftTab) {
                focusPrevious.focus();
              } else {
                focusNext.focus();
              }
            }
          } else {
            rootElement.focus();
          }
        };
        doc.addEventListener("focusin", contain);
        doc.addEventListener("keydown", loopFocus, true);
        const interval = setInterval(() => {
          if (doc.activeElement && doc.activeElement.tagName === "BODY") {
            contain();
          }
        }, 50);
        return () => {
          clearInterval(interval);
          doc.removeEventListener("focusin", contain);
          doc.removeEventListener("keydown", loopFocus, true);
        };
      }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
      const onFocus2 = (event) => {
        if (nodeToRestore.current === null) {
          nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
        reactFocusEventTarget.current = event.target;
        const childrenPropsHandler = children.props.onFocus;
        if (childrenPropsHandler) {
          childrenPropsHandler(event);
        }
      };
      const handleFocusSentinel = (event) => {
        if (nodeToRestore.current === null) {
          nodeToRestore.current = event.relatedTarget;
        }
        activated.current = true;
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          tabIndex: open ? 0 : -1,
          onFocus: handleFocusSentinel,
          ref: sentinelStart,
          "data-testid": "sentinelStart"
        }), /* @__PURE__ */ reactExports.cloneElement(children, {
          ref: handleRef,
          onFocus: onFocus2
        }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
          tabIndex: open ? 0 : -1,
          onFocus: handleFocusSentinel,
          ref: sentinelEnd,
          "data-testid": "sentinelEnd"
        })]
      });
    }
    function getContainer$1(container) {
      return typeof container === "function" ? container() : container;
    }
    const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
      const {
        children,
        container,
        disablePortal = false
      } = props;
      const [mountNode, setMountNode] = reactExports.useState(null);
      const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
      useEnhancedEffect$1(() => {
        if (!disablePortal) {
          setMountNode(getContainer$1(container) || document.body);
        }
      }, [container, disablePortal]);
      useEnhancedEffect$1(() => {
        if (mountNode && !disablePortal) {
          setRef(forwardedRef, mountNode);
          return () => {
            setRef(forwardedRef, null);
          };
        }
        return void 0;
      }, [forwardedRef, mountNode, disablePortal]);
      if (disablePortal) {
        if (/* @__PURE__ */ reactExports.isValidElement(children)) {
          const newProps = {
            ref: handleRef
          };
          return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
          children
        });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
      });
    });
    function isOverflowing(container) {
      const doc = ownerDocument(container);
      if (doc.body === container) {
        return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
      }
      return container.scrollHeight > container.clientHeight;
    }
    function ariaHidden(element, show) {
      if (show) {
        element.setAttribute("aria-hidden", "true");
      } else {
        element.removeAttribute("aria-hidden");
      }
    }
    function getPaddingRight(element) {
      return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
    }
    function isAriaHiddenForbiddenOnElement(element) {
      const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
      const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
      const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
      return isForbiddenTagName || isInputHidden;
    }
    function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
      const blacklist = [mountElement, currentElement, ...elementsToExclude];
      [].forEach.call(container.children, (element) => {
        const isNotExcludedElement = blacklist.indexOf(element) === -1;
        const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
        if (isNotExcludedElement && isNotForbiddenElement) {
          ariaHidden(element, show);
        }
      });
    }
    function findIndexOf(items, callback) {
      let idx = -1;
      items.some((item, index) => {
        if (callback(item)) {
          idx = index;
          return true;
        }
        return false;
      });
      return idx;
    }
    function handleContainer(containerInfo, props) {
      const restoreStyle = [];
      const container = containerInfo.container;
      if (!props.disableScrollLock) {
        if (isOverflowing(container)) {
          const scrollbarSize = getScrollbarSize(ownerDocument(container));
          restoreStyle.push({
            value: container.style.paddingRight,
            property: "padding-right",
            el: container
          });
          container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
          const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
          [].forEach.call(fixedElements2, (element) => {
            restoreStyle.push({
              value: element.style.paddingRight,
              property: "padding-right",
              el: element
            });
            element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
          });
        }
        let scrollContainer;
        if (container.parentNode instanceof DocumentFragment) {
          scrollContainer = ownerDocument(container).body;
        } else {
          const parent = container.parentElement;
          const containerWindow = ownerWindow(container);
          scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
        }
        restoreStyle.push({
          value: scrollContainer.style.overflow,
          property: "overflow",
          el: scrollContainer
        }, {
          value: scrollContainer.style.overflowX,
          property: "overflow-x",
          el: scrollContainer
        }, {
          value: scrollContainer.style.overflowY,
          property: "overflow-y",
          el: scrollContainer
        });
        scrollContainer.style.overflow = "hidden";
      }
      const restore = () => {
        restoreStyle.forEach(({
          value,
          el: el2,
          property
        }) => {
          if (value) {
            el2.style.setProperty(property, value);
          } else {
            el2.style.removeProperty(property);
          }
        });
      };
      return restore;
    }
    function getHiddenSiblings(container) {
      const hiddenSiblings = [];
      [].forEach.call(container.children, (element) => {
        if (element.getAttribute("aria-hidden") === "true") {
          hiddenSiblings.push(element);
        }
      });
      return hiddenSiblings;
    }
    class ModalManager {
      constructor() {
        this.containers = void 0;
        this.modals = void 0;
        this.modals = [];
        this.containers = [];
      }
      add(modal, container) {
        let modalIndex = this.modals.indexOf(modal);
        if (modalIndex !== -1) {
          return modalIndex;
        }
        modalIndex = this.modals.length;
        this.modals.push(modal);
        if (modal.modalRef) {
          ariaHidden(modal.modalRef, false);
        }
        const hiddenSiblings = getHiddenSiblings(container);
        ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
        const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
        if (containerIndex !== -1) {
          this.containers[containerIndex].modals.push(modal);
          return modalIndex;
        }
        this.containers.push({
          modals: [modal],
          container,
          restore: null,
          hiddenSiblings
        });
        return modalIndex;
      }
      mount(modal, props) {
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        if (!containerInfo.restore) {
          containerInfo.restore = handleContainer(containerInfo, props);
        }
      }
      remove(modal, ariaHiddenState = true) {
        const modalIndex = this.modals.indexOf(modal);
        if (modalIndex === -1) {
          return modalIndex;
        }
        const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
        const containerInfo = this.containers[containerIndex];
        containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
        this.modals.splice(modalIndex, 1);
        if (containerInfo.modals.length === 0) {
          if (containerInfo.restore) {
            containerInfo.restore();
          }
          if (modal.modalRef) {
            ariaHidden(modal.modalRef, ariaHiddenState);
          }
          ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
          this.containers.splice(containerIndex, 1);
        } else {
          const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
          if (nextTop.modalRef) {
            ariaHidden(nextTop.modalRef, false);
          }
        }
        return modalIndex;
      }
      isTopModal(modal) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
      }
    }
    function getContainer(container) {
      return typeof container === "function" ? container() : container;
    }
    function getHasTransition(children) {
      return children ? children.props.hasOwnProperty("in") : false;
    }
    const defaultManager = new ModalManager();
    function useModal(parameters) {
      const {
        container,
        disableEscapeKeyDown = false,
        disableScrollLock = false,
        // @ts-ignore internal logic - Base UI supports the manager as a prop too
        manager = defaultManager,
        closeAfterTransition = false,
        onTransitionEnter,
        onTransitionExited,
        children,
        onClose,
        open,
        rootRef
      } = parameters;
      const modal = reactExports.useRef({});
      const mountNodeRef = reactExports.useRef(null);
      const modalRef = reactExports.useRef(null);
      const handleRef = useForkRef(modalRef, rootRef);
      const [exited, setExited] = reactExports.useState(!open);
      const hasTransition = getHasTransition(children);
      let ariaHiddenProp = true;
      if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
        ariaHiddenProp = false;
      }
      const getDoc = () => ownerDocument(mountNodeRef.current);
      const getModal = () => {
        modal.current.modalRef = modalRef.current;
        modal.current.mount = mountNodeRef.current;
        return modal.current;
      };
      const handleMounted = () => {
        manager.mount(getModal(), {
          disableScrollLock
        });
        if (modalRef.current) {
          modalRef.current.scrollTop = 0;
        }
      };
      const handleOpen = useEventCallback(() => {
        const resolvedContainer = getContainer(container) || getDoc().body;
        manager.add(getModal(), resolvedContainer);
        if (modalRef.current) {
          handleMounted();
        }
      });
      const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
      const handlePortalRef = useEventCallback((node2) => {
        mountNodeRef.current = node2;
        if (!node2) {
          return;
        }
        if (open && isTopModal()) {
          handleMounted();
        } else if (modalRef.current) {
          ariaHidden(modalRef.current, ariaHiddenProp);
        }
      });
      const handleClose = reactExports.useCallback(() => {
        manager.remove(getModal(), ariaHiddenProp);
      }, [ariaHiddenProp, manager]);
      reactExports.useEffect(() => {
        return () => {
          handleClose();
        };
      }, [handleClose]);
      reactExports.useEffect(() => {
        if (open) {
          handleOpen();
        } else if (!hasTransition || !closeAfterTransition) {
          handleClose();
        }
      }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
      const createHandleKeyDown = (otherHandlers) => (event) => {
        var _otherHandlers$onKeyD;
        (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
        if (event.key !== "Escape" || event.which === 229 || // Wait until IME is settled.
        !isTopModal()) {
          return;
        }
        if (!disableEscapeKeyDown) {
          event.stopPropagation();
          if (onClose) {
            onClose(event, "escapeKeyDown");
          }
        }
      };
      const createHandleBackdropClick = (otherHandlers) => (event) => {
        var _otherHandlers$onClic;
        (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
        if (event.target !== event.currentTarget) {
          return;
        }
        if (onClose) {
          onClose(event, "backdropClick");
        }
      };
      const getRootProps = (otherHandlers = {}) => {
        const propsEventHandlers = extractEventHandlers(parameters);
        delete propsEventHandlers.onTransitionEnter;
        delete propsEventHandlers.onTransitionExited;
        const externalEventHandlers = _extends$1({}, propsEventHandlers, otherHandlers);
        return _extends$1({
          role: "presentation"
        }, externalEventHandlers, {
          onKeyDown: createHandleKeyDown(externalEventHandlers),
          ref: handleRef
        });
      };
      const getBackdropProps = (otherHandlers = {}) => {
        const externalEventHandlers = otherHandlers;
        return _extends$1({
          "aria-hidden": true
        }, externalEventHandlers, {
          onClick: createHandleBackdropClick(externalEventHandlers),
          open
        });
      };
      const getTransitionProps2 = () => {
        const handleEnter = () => {
          setExited(false);
          if (onTransitionEnter) {
            onTransitionEnter();
          }
        };
        const handleExited = () => {
          setExited(true);
          if (onTransitionExited) {
            onTransitionExited();
          }
          if (closeAfterTransition) {
            handleClose();
          }
        };
        return {
          onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
          onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
        };
      };
      return {
        getRootProps,
        getBackdropProps,
        getTransitionProps: getTransitionProps2,
        rootRef: handleRef,
        portalRef: handlePortalRef,
        isTopModal,
        exited,
        hasTransition
      };
    }
    const _excluded$h = ["onChange", "maxRows", "minRows", "style", "value"];
    function getStyleValue(value) {
      return parseInt(value, 10) || 0;
    }
    const styles$3 = {
      shadow: {
        // Visibility needed to hide the extra text area on iPads
        visibility: "hidden",
        // Remove from the content flow
        position: "absolute",
        // Ignore the scrollbar width
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        // Create a new layer, increase the isolation of the computed values
        transform: "translateZ(0)"
      }
    };
    function isEmpty$1(obj) {
      return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflow;
    }
    const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
      const {
        onChange,
        maxRows,
        minRows = 1,
        style: style2,
        value
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$h);
      const {
        current: isControlled
      } = reactExports.useRef(value != null);
      const inputRef = reactExports.useRef(null);
      const handleRef = useForkRef(forwardedRef, inputRef);
      const shadowRef = reactExports.useRef(null);
      const renders = reactExports.useRef(0);
      const [state, setState] = reactExports.useState({
        outerHeightStyle: 0
      });
      const getUpdatedState = reactExports.useCallback(() => {
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        const computedStyle = containerWindow.getComputedStyle(input);
        if (computedStyle.width === "0px") {
          return {
            outerHeightStyle: 0
          };
        }
        const inputShallow = shadowRef.current;
        inputShallow.style.width = computedStyle.width;
        inputShallow.value = input.value || props.placeholder || "x";
        if (inputShallow.value.slice(-1) === "\n") {
          inputShallow.value += " ";
        }
        const boxSizing2 = computedStyle.boxSizing;
        const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
        const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
        const innerHeight = inputShallow.scrollHeight;
        inputShallow.value = "x";
        const singleRowHeight = inputShallow.scrollHeight;
        let outerHeight = innerHeight;
        if (minRows) {
          outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
        }
        if (maxRows) {
          outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
        }
        outerHeight = Math.max(outerHeight, singleRowHeight);
        const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
        const overflow = Math.abs(outerHeight - innerHeight) <= 1;
        return {
          outerHeightStyle,
          overflow
        };
      }, [maxRows, minRows, props.placeholder]);
      const updateState = (prevState, newState) => {
        const {
          outerHeightStyle,
          overflow
        } = newState;
        if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
          renders.current += 1;
          return {
            overflow,
            outerHeightStyle
          };
        }
        return prevState;
      };
      const syncHeight = reactExports.useCallback(() => {
        const newState = getUpdatedState();
        if (isEmpty$1(newState)) {
          return;
        }
        setState((prevState) => updateState(prevState, newState));
      }, [getUpdatedState]);
      useEnhancedEffect$1(() => {
        const syncHeightWithFlushSync = () => {
          const newState = getUpdatedState();
          if (isEmpty$1(newState)) {
            return;
          }
          reactDomExports.flushSync(() => {
            setState((prevState) => updateState(prevState, newState));
          });
        };
        const handleResize = () => {
          renders.current = 0;
          syncHeightWithFlushSync();
        };
        let rAF;
        const debounceHandleResize = debounce(handleResize);
        const input = inputRef.current;
        const containerWindow = ownerWindow(input);
        containerWindow.addEventListener("resize", debounceHandleResize);
        let resizeObserver;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver = new ResizeObserver(handleResize);
          resizeObserver.observe(input);
        }
        return () => {
          debounceHandleResize.clear();
          cancelAnimationFrame(rAF);
          containerWindow.removeEventListener("resize", debounceHandleResize);
          if (resizeObserver) {
            resizeObserver.disconnect();
          }
        };
      }, [getUpdatedState]);
      useEnhancedEffect$1(() => {
        syncHeight();
      });
      reactExports.useEffect(() => {
        renders.current = 0;
      }, [value]);
      const handleChange = (event) => {
        renders.current = 0;
        if (!isControlled) {
          syncHeight();
        }
        if (onChange) {
          onChange(event);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends$1({
          value,
          onChange: handleChange,
          ref: handleRef,
          rows: minRows,
          style: _extends$1({
            height: state.outerHeightStyle,
            // Need a large enough difference to allow scrolling.
            // This prevents infinite rendering loop.
            overflow: state.overflow ? "hidden" : void 0
          }, style2)
        }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
          "aria-hidden": true,
          className: props.className,
          readOnly: true,
          ref: shadowRef,
          tabIndex: -1,
          style: _extends$1({}, styles$3.shadow, style2, {
            paddingTop: 0,
            paddingBottom: 0
          })
        })]
      });
    });
    function formControlState({
      props,
      states,
      muiFormControl
    }) {
      return states.reduce((acc, state) => {
        acc[state] = props[state];
        if (muiFormControl) {
          if (typeof props[state] === "undefined") {
            acc[state] = muiFormControl[state];
          }
        }
        return acc;
      }, {});
    }
    const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
    const FormControlContext$1 = FormControlContext;
    function useFormControl() {
      return reactExports.useContext(FormControlContext$1);
    }
    function GlobalStyles(props) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends$1({}, props, {
        defaultTheme: defaultTheme$1,
        themeId: THEME_ID
      }));
    }
    function hasValue(value) {
      return value != null && !(Array.isArray(value) && value.length === 0);
    }
    function isFilled(obj, SSR = false) {
      return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
    }
    function getInputBaseUtilityClass(slot) {
      return generateUtilityClass("MuiInputBase", slot);
    }
    const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
    const inputBaseClasses$1 = inputBaseClasses;
    const _excluded$g = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
    const rootOverridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
    };
    const inputOverridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
    };
    const useUtilityClasses$c = (ownerState) => {
      const {
        classes: classes2,
        color: color2,
        disabled,
        error,
        endAdornment,
        focused,
        formControl,
        fullWidth,
        hiddenLabel,
        multiline,
        readOnly,
        size,
        startAdornment,
        type
      } = ownerState;
      const slots = {
        root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size && size !== "medium" && `size${capitalize(size)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
        input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
      };
      return composeClasses(slots, getInputBaseUtilityClass, classes2);
    };
    const InputBaseRoot = styled$1("div", {
      name: "MuiInputBase",
      slot: "Root",
      overridesResolver: rootOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({}, theme.typography.body1, {
      color: (theme.vars || theme).palette.text.primary,
      lineHeight: "1.4375em",
      // 23px
      boxSizing: "border-box",
      // Prevent padding issue with fullWidth.
      position: "relative",
      cursor: "text",
      display: "inline-flex",
      alignItems: "center",
      [`&.${inputBaseClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.text.disabled,
        cursor: "default"
      }
    }, ownerState.multiline && _extends$1({
      padding: "4px 0 5px"
    }, ownerState.size === "small" && {
      paddingTop: 1
    }), ownerState.fullWidth && {
      width: "100%"
    }));
    const InputBaseComponent = styled$1("input", {
      name: "MuiInputBase",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => {
      const light2 = theme.palette.mode === "light";
      const placeholder = _extends$1({
        color: "currentColor"
      }, theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: light2 ? 0.42 : 0.5
      }, {
        transition: theme.transitions.create("opacity", {
          duration: theme.transitions.duration.shorter
        })
      });
      const placeholderHidden = {
        opacity: "0 !important"
      };
      const placeholderVisible = theme.vars ? {
        opacity: theme.vars.opacity.inputPlaceholder
      } : {
        opacity: light2 ? 0.42 : 0.5
      };
      return _extends$1({
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        // Reset 23pxthe native input line-height
        margin: 0,
        // Reset for Safari
        WebkitTapHighlightColor: "transparent",
        display: "block",
        // Make the flex item shrink with Firefox
        minWidth: 0,
        width: "100%",
        // Fix IE11 width issue
        animationName: "mui-auto-fill-cancel",
        animationDuration: "10ms",
        "&::-webkit-input-placeholder": placeholder,
        "&::-moz-placeholder": placeholder,
        // Firefox 19+
        "&:-ms-input-placeholder": placeholder,
        // IE11
        "&::-ms-input-placeholder": placeholder,
        // Edge
        "&:focus": {
          outline: 0
        },
        // Reset Firefox invalid required input style
        "&:invalid": {
          boxShadow: "none"
        },
        "&::-webkit-search-decoration": {
          // Remove the padding when type=search.
          WebkitAppearance: "none"
        },
        // Show and hide the placeholder logic
        [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
          "&::-webkit-input-placeholder": placeholderHidden,
          "&::-moz-placeholder": placeholderHidden,
          // Firefox 19+
          "&:-ms-input-placeholder": placeholderHidden,
          // IE11
          "&::-ms-input-placeholder": placeholderHidden,
          // Edge
          "&:focus::-webkit-input-placeholder": placeholderVisible,
          "&:focus::-moz-placeholder": placeholderVisible,
          // Firefox 19+
          "&:focus:-ms-input-placeholder": placeholderVisible,
          // IE11
          "&:focus::-ms-input-placeholder": placeholderVisible
          // Edge
        },
        [`&.${inputBaseClasses$1.disabled}`]: {
          opacity: 1,
          // Reset iOS opacity
          WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
          // Fix opacity Safari bug
        },
        "&:-webkit-autofill": {
          animationDuration: "5000s",
          animationName: "mui-auto-fill"
        }
      }, ownerState.size === "small" && {
        paddingTop: 1
      }, ownerState.multiline && {
        height: "auto",
        resize: "none",
        padding: 0,
        paddingTop: 0
      }, ownerState.type === "search" && {
        // Improve type search style.
        MozAppearance: "textfield"
      });
    });
    const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
      styles: {
        "@keyframes mui-auto-fill": {
          from: {
            display: "block"
          }
        },
        "@keyframes mui-auto-fill-cancel": {
          from: {
            display: "block"
          }
        }
      }
    });
    const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
      var _slotProps$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiInputBase"
      });
      const {
        "aria-describedby": ariaDescribedby,
        autoComplete,
        autoFocus,
        className,
        components = {},
        componentsProps = {},
        defaultValue,
        disabled,
        disableInjectingGlobalStyles,
        endAdornment,
        fullWidth = false,
        id: id2,
        inputComponent = "input",
        inputProps: inputPropsProp = {},
        inputRef: inputRefProp,
        maxRows,
        minRows,
        multiline = false,
        name,
        onBlur,
        onChange,
        onClick: onClick2,
        onFocus: onFocus2,
        onKeyDown,
        onKeyUp,
        placeholder,
        readOnly,
        renderSuffix,
        rows,
        slotProps = {},
        slots = {},
        startAdornment,
        type = "text",
        value: valueProp
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
      const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
      const {
        current: isControlled
      } = reactExports.useRef(value != null);
      const inputRef = reactExports.useRef();
      const handleInputRefWarning = reactExports.useCallback((instance) => {
      }, []);
      const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
      const [focused, setFocused] = reactExports.useState(false);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
      });
      fcs.focused = muiFormControl ? muiFormControl.focused : focused;
      reactExports.useEffect(() => {
        if (!muiFormControl && disabled && focused) {
          setFocused(false);
          if (onBlur) {
            onBlur();
          }
        }
      }, [muiFormControl, disabled, focused, onBlur]);
      const onFilled = muiFormControl && muiFormControl.onFilled;
      const onEmpty = muiFormControl && muiFormControl.onEmpty;
      const checkDirty = reactExports.useCallback((obj) => {
        if (isFilled(obj)) {
          if (onFilled) {
            onFilled();
          }
        } else if (onEmpty) {
          onEmpty();
        }
      }, [onFilled, onEmpty]);
      useEnhancedEffect$1(() => {
        if (isControlled) {
          checkDirty({
            value
          });
        }
      }, [value, checkDirty, isControlled]);
      const handleFocus = (event) => {
        if (fcs.disabled) {
          event.stopPropagation();
          return;
        }
        if (onFocus2) {
          onFocus2(event);
        }
        if (inputPropsProp.onFocus) {
          inputPropsProp.onFocus(event);
        }
        if (muiFormControl && muiFormControl.onFocus) {
          muiFormControl.onFocus(event);
        } else {
          setFocused(true);
        }
      };
      const handleBlur = (event) => {
        if (onBlur) {
          onBlur(event);
        }
        if (inputPropsProp.onBlur) {
          inputPropsProp.onBlur(event);
        }
        if (muiFormControl && muiFormControl.onBlur) {
          muiFormControl.onBlur(event);
        } else {
          setFocused(false);
        }
      };
      const handleChange = (event, ...args) => {
        if (!isControlled) {
          const element = event.target || inputRef.current;
          if (element == null) {
            throw new Error(formatMuiErrorMessage(1));
          }
          checkDirty({
            value: element.value
          });
        }
        if (inputPropsProp.onChange) {
          inputPropsProp.onChange(event, ...args);
        }
        if (onChange) {
          onChange(event, ...args);
        }
      };
      reactExports.useEffect(() => {
        checkDirty(inputRef.current);
      }, []);
      const handleClick = (event) => {
        if (inputRef.current && event.currentTarget === event.target) {
          inputRef.current.focus();
        }
        if (onClick2) {
          onClick2(event);
        }
      };
      let InputComponent = inputComponent;
      let inputProps = inputPropsProp;
      if (multiline && InputComponent === "input") {
        if (rows) {
          inputProps = _extends$1({
            type: void 0,
            minRows: rows,
            maxRows: rows
          }, inputProps);
        } else {
          inputProps = _extends$1({
            type: void 0,
            maxRows,
            minRows
          }, inputProps);
        }
        InputComponent = TextareaAutosize;
      }
      const handleAutoFill = (event) => {
        checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
          value: "x"
        });
      };
      reactExports.useEffect(() => {
        if (muiFormControl) {
          muiFormControl.setAdornedStart(Boolean(startAdornment));
        }
      }, [muiFormControl, startAdornment]);
      const ownerState = _extends$1({}, props, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        endAdornment,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        startAdornment,
        type
      });
      const classes2 = useUtilityClasses$c(ownerState);
      const Root = slots.root || components.Root || InputBaseRoot;
      const rootProps = slotProps.root || componentsProps.root || {};
      const Input2 = slots.input || components.Input || InputBaseComponent;
      inputProps = _extends$1({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$1({}, rootProps, !isHostComponent(Root) && {
          ownerState: _extends$1({}, ownerState, rootProps.ownerState)
        }, {
          ref,
          onClick: handleClick
        }, other, {
          className: clsx(classes2.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
          children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
            value: null,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input2, _extends$1({
              ownerState,
              "aria-invalid": fcs.error,
              "aria-describedby": ariaDescribedby,
              autoComplete,
              autoFocus,
              defaultValue,
              disabled: fcs.disabled,
              id: id2,
              onAnimationStart: handleAutoFill,
              name,
              placeholder,
              readOnly,
              required: fcs.required,
              rows,
              value,
              onKeyDown,
              onKeyUp,
              type
            }, inputProps, !isHostComponent(Input2) && {
              as: InputComponent,
              ownerState: _extends$1({}, ownerState, inputProps.ownerState)
            }, {
              ref: handleInputRef,
              className: clsx(classes2.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
              onBlur: handleBlur,
              onChange: handleChange,
              onFocus: handleFocus
            }))
          }), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, fcs, {
            startAdornment
          })) : null]
        }))]
      });
    });
    const InputBase$1 = InputBase;
    function getInputUtilityClass(slot) {
      return generateUtilityClass("MuiInput", slot);
    }
    const inputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
    const inputClasses$1 = inputClasses;
    function getOutlinedInputUtilityClass(slot) {
      return generateUtilityClass("MuiOutlinedInput", slot);
    }
    const outlinedInputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
    const outlinedInputClasses$1 = outlinedInputClasses;
    function getFilledInputUtilityClass(slot) {
      return generateUtilityClass("MuiFilledInput", slot);
    }
    const filledInputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
    const filledInputClasses$1 = filledInputClasses;
    const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
      d: "M7 10l5 5 5-5z"
    }), "ArrowDropDown");
    const _excluded$f = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    const styles$2 = {
      entering: {
        opacity: 1
      },
      entered: {
        opacity: 1
      }
    };
    const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
      const theme = useTheme();
      const defaultTimeout = {
        enter: theme.transitions.duration.enteringScreen,
        exit: theme.transitions.duration.leavingScreen
      };
      const {
        addEndListener,
        appear = true,
        children,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = defaultTimeout,
        // eslint-disable-next-line react/prop-types
        TransitionComponent = Transition$1
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$f);
      const nodeRef = reactExports.useRef(null);
      const handleRef = useForkRef(nodeRef, children.ref, ref);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const handleEntering = normalizedTransitionCallback(onEntering);
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const transitionProps = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const transitionProps = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
        node2.style.transition = theme.transitions.create("opacity", transitionProps);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleAddEndListener = (next2) => {
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        appear,
        in: inProp,
        nodeRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
            style: _extends$1({
              opacity: 0,
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, styles$2[state], style2, children.props.style),
            ref: handleRef
          }, childProps));
        }
      }));
    });
    const Fade$1 = Fade;
    function getBackdropUtilityClass(slot) {
      return generateUtilityClass("MuiBackdrop", slot);
    }
    generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
    const _excluded$e = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
    const useUtilityClasses$b = (ownerState) => {
      const {
        classes: classes2,
        invisible
      } = ownerState;
      const slots = {
        root: ["root", invisible && "invisible"]
      };
      return composeClasses(slots, getBackdropUtilityClass, classes2);
    };
    const BackdropRoot = styled$1("div", {
      name: "MuiBackdrop",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, ownerState.invisible && styles2.invisible];
      }
    })(({
      ownerState
    }) => _extends$1({
      position: "fixed",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      right: 0,
      bottom: 0,
      top: 0,
      left: 0,
      backgroundColor: "rgba(0, 0, 0, 0.5)",
      WebkitTapHighlightColor: "transparent"
    }, ownerState.invisible && {
      backgroundColor: "transparent"
    }));
    const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
      var _slotProps$root, _ref, _slots$root;
      const props = useThemeProps({
        props: inProps,
        name: "MuiBackdrop"
      });
      const {
        children,
        className,
        component = "div",
        components = {},
        componentsProps = {},
        invisible = false,
        open,
        slotProps = {},
        slots = {},
        TransitionComponent = Fade$1,
        transitionDuration
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
      const ownerState = _extends$1({}, props, {
        component,
        invisible
      });
      const classes2 = useUtilityClasses$b(ownerState);
      const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        in: open,
        timeout: transitionDuration
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$1({
          "aria-hidden": true
        }, rootSlotProps, {
          as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
          className: clsx(classes2.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
          ownerState: _extends$1({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
          classes: classes2,
          ref,
          children
        }))
      }));
    });
    const Backdrop$1 = Backdrop;
    function getModalUtilityClass(slot) {
      return generateUtilityClass("MuiModal", slot);
    }
    generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
    const _excluded$d = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
    const useUtilityClasses$a = (ownerState) => {
      const {
        open,
        exited,
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root", !open && exited && "hidden"],
        backdrop: ["backdrop"]
      };
      return composeClasses(slots, getModalUtilityClass, classes2);
    };
    const ModalRoot = styled$1("div", {
      name: "MuiModal",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
      }
    })(({
      theme,
      ownerState
    }) => _extends$1({
      position: "fixed",
      zIndex: (theme.vars || theme).zIndex.modal,
      right: 0,
      bottom: 0,
      top: 0,
      left: 0
    }, !ownerState.open && ownerState.exited && {
      visibility: "hidden"
    }));
    const ModalBackdrop = styled$1(Backdrop$1, {
      name: "MuiModal",
      slot: "Backdrop",
      overridesResolver: (props, styles2) => {
        return styles2.backdrop;
      }
    })({
      zIndex: -1
    });
    const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
      const props = useThemeProps({
        name: "MuiModal",
        props: inProps
      });
      const {
        BackdropComponent = ModalBackdrop,
        BackdropProps,
        className,
        closeAfterTransition = false,
        children,
        container,
        component,
        components = {},
        componentsProps = {},
        disableAutoFocus = false,
        disableEnforceFocus = false,
        disableEscapeKeyDown = false,
        disablePortal = false,
        disableRestoreFocus = false,
        disableScrollLock = false,
        hideBackdrop = false,
        keepMounted = false,
        onBackdropClick,
        open,
        slotProps,
        slots
        // eslint-disable-next-line react/prop-types
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
      const propsWithDefaults = _extends$1({}, props, {
        closeAfterTransition,
        disableAutoFocus,
        disableEnforceFocus,
        disableEscapeKeyDown,
        disablePortal,
        disableRestoreFocus,
        disableScrollLock,
        hideBackdrop,
        keepMounted
      });
      const {
        getRootProps,
        getBackdropProps,
        getTransitionProps: getTransitionProps2,
        portalRef,
        isTopModal,
        exited,
        hasTransition
      } = useModal(_extends$1({}, propsWithDefaults, {
        rootRef: ref
      }));
      const ownerState = _extends$1({}, propsWithDefaults, {
        exited
      });
      const classes2 = useUtilityClasses$a(ownerState);
      const childProps = {};
      if (children.props.tabIndex === void 0) {
        childProps.tabIndex = "-1";
      }
      if (hasTransition) {
        const {
          onEnter,
          onExited
        } = getTransitionProps2();
        childProps.onEnter = onEnter;
        childProps.onExited = onExited;
      }
      const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
      const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
      const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
      const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
      const rootProps = useSlotProps({
        elementType: RootSlot,
        externalSlotProps: rootSlotProps,
        externalForwardedProps: other,
        getSlotProps: getRootProps,
        additionalProps: {
          ref,
          as: component
        },
        ownerState,
        className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes2 == null ? void 0 : classes2.root, !ownerState.open && ownerState.exited && (classes2 == null ? void 0 : classes2.hidden))
      });
      const backdropProps = useSlotProps({
        elementType: BackdropSlot,
        externalSlotProps: backdropSlotProps,
        additionalProps: BackdropProps,
        getSlotProps: (otherHandlers) => {
          return getBackdropProps(_extends$1({}, otherHandlers, {
            onClick: (e2) => {
              if (onBackdropClick) {
                onBackdropClick(e2);
              }
              if (otherHandlers != null && otherHandlers.onClick) {
                otherHandlers.onClick(e2);
              }
            }
          }));
        },
        className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes2 == null ? void 0 : classes2.backdrop),
        ownerState
      });
      if (!keepMounted && !open && (!hasTransition || exited)) {
        return null;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
        ref: portalRef,
        container,
        disablePortal,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$1({}, rootProps, {
          children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends$1({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
            disableEnforceFocus,
            disableAutoFocus,
            disableRestoreFocus,
            isEnabled: isTopModal,
            open,
            children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
          })]
        }))
      });
    });
    const Modal$1 = Modal;
    const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
    const dividerClasses$1 = dividerClasses;
    const _excluded$c = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
    const useUtilityClasses$9 = (ownerState) => {
      const {
        classes: classes2,
        disableUnderline
      } = ownerState;
      const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes2);
      return _extends$1({}, classes2, composedClasses);
    };
    const FilledInputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiFilledInput",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
      }
    })(({
      theme,
      ownerState
    }) => {
      var _palette;
      const light2 = theme.palette.mode === "light";
      const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
      const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
      const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
      const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
      return _extends$1({
        position: "relative",
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
        borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
        borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
        transition: theme.transitions.create("background-color", {
          duration: theme.transitions.duration.shorter,
          easing: theme.transitions.easing.easeOut
        }),
        "&:hover": {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
          }
        },
        [`&.${filledInputClasses$1.focused}`]: {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
        },
        [`&.${filledInputClasses$1.disabled}`]: {
          backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
        }
      }, !ownerState.disableUnderline && {
        "&:after": {
          borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${filledInputClasses$1.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${filledInputClasses$1.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&:before": {
          borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
          borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
        },
        [`&.${filledInputClasses$1.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      }, ownerState.startAdornment && {
        paddingLeft: 12
      }, ownerState.endAdornment && {
        paddingRight: 12
      }, ownerState.multiline && _extends$1({
        padding: "25px 12px 8px"
      }, ownerState.size === "small" && {
        paddingTop: 21,
        paddingBottom: 4
      }, ownerState.hiddenLabel && {
        paddingTop: 16,
        paddingBottom: 17
      }, ownerState.hiddenLabel && ownerState.size === "small" && {
        paddingTop: 8,
        paddingBottom: 9
      }));
    });
    const FilledInputInput = styled$1(InputBaseComponent, {
      name: "MuiFilledInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({
      paddingTop: 25,
      paddingRight: 12,
      paddingBottom: 8,
      paddingLeft: 12
    }, !theme.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
        caretColor: theme.palette.mode === "light" ? null : "#fff",
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      }
    }, theme.vars && {
      "&:-webkit-autofill": {
        borderTopLeftRadius: "inherit",
        borderTopRightRadius: "inherit"
      },
      [theme.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    }, ownerState.size === "small" && {
      paddingTop: 21,
      paddingBottom: 4
    }, ownerState.hiddenLabel && {
      paddingTop: 16,
      paddingBottom: 17
    }, ownerState.startAdornment && {
      paddingLeft: 0
    }, ownerState.endAdornment && {
      paddingRight: 0
    }, ownerState.hiddenLabel && ownerState.size === "small" && {
      paddingTop: 8,
      paddingBottom: 9
    }, ownerState.multiline && {
      paddingTop: 0,
      paddingBottom: 0,
      paddingLeft: 0,
      paddingRight: 0
    }));
    const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiFilledInput"
      });
      const {
        components = {},
        componentsProps: componentsPropsProp,
        fullWidth = false,
        // declare here to prevent spreading to DOM
        inputComponent = "input",
        multiline = false,
        slotProps,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
      const ownerState = _extends$1({}, props, {
        fullWidth,
        inputComponent,
        multiline,
        type
      });
      const classes2 = useUtilityClasses$9(props);
      const filledInputComponentsProps = {
        root: {
          ownerState
        },
        input: {
          ownerState
        }
      };
      const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        componentsProps,
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes: classes2
      }));
    });
    FilledInput.muiName = "Input";
    const FilledInput$1 = FilledInput;
    const _excluded$b = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
    function getScale(value) {
      return `scale(${value}, ${value ** 2})`;
    }
    const styles$1 = {
      entering: {
        opacity: 1,
        transform: getScale(1)
      },
      entered: {
        opacity: 1,
        transform: "none"
      }
    };
    const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
    const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
      const {
        addEndListener,
        appear = true,
        children,
        easing: easing2,
        in: inProp,
        onEnter,
        onEntered,
        onEntering,
        onExit,
        onExited,
        onExiting,
        style: style2,
        timeout = "auto",
        // eslint-disable-next-line react/prop-types
        TransitionComponent = Transition$1
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
      const timer = reactExports.useRef();
      const autoTimeout = reactExports.useRef();
      const theme = useTheme();
      const nodeRef = reactExports.useRef(null);
      const handleRef = useForkRef(nodeRef, children.ref, ref);
      const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
        if (callback) {
          const node2 = nodeRef.current;
          if (maybeIsAppearing === void 0) {
            callback(node2);
          } else {
            callback(node2, maybeIsAppearing);
          }
        }
      };
      const handleEntering = normalizedTransitionCallback(onEntering);
      const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
        reflow(node2);
        const {
          duration: transitionDuration,
          delay,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "enter"
        });
        let duration2;
        if (timeout === "auto") {
          duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
          autoTimeout.current = duration2;
        } else {
          duration2 = transitionDuration;
        }
        node2.style.transition = [theme.transitions.create("opacity", {
          duration: duration2,
          delay
        }), theme.transitions.create("transform", {
          duration: isWebKit154 ? duration2 : duration2 * 0.666,
          delay,
          easing: transitionTimingFunction
        })].join(",");
        if (onEnter) {
          onEnter(node2, isAppearing);
        }
      });
      const handleEntered = normalizedTransitionCallback(onEntered);
      const handleExiting = normalizedTransitionCallback(onExiting);
      const handleExit = normalizedTransitionCallback((node2) => {
        const {
          duration: transitionDuration,
          delay,
          easing: transitionTimingFunction
        } = getTransitionProps({
          style: style2,
          timeout,
          easing: easing2
        }, {
          mode: "exit"
        });
        let duration2;
        if (timeout === "auto") {
          duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
          autoTimeout.current = duration2;
        } else {
          duration2 = transitionDuration;
        }
        node2.style.transition = [theme.transitions.create("opacity", {
          duration: duration2,
          delay
        }), theme.transitions.create("transform", {
          duration: isWebKit154 ? duration2 : duration2 * 0.666,
          delay: isWebKit154 ? delay : delay || duration2 * 0.333,
          easing: transitionTimingFunction
        })].join(",");
        node2.style.opacity = 0;
        node2.style.transform = getScale(0.75);
        if (onExit) {
          onExit(node2);
        }
      });
      const handleExited = normalizedTransitionCallback(onExited);
      const handleAddEndListener = (next2) => {
        if (timeout === "auto") {
          timer.current = setTimeout(next2, autoTimeout.current || 0);
        }
        if (addEndListener) {
          addEndListener(nodeRef.current, next2);
        }
      };
      reactExports.useEffect(() => {
        return () => {
          clearTimeout(timer.current);
        };
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
        appear,
        in: inProp,
        nodeRef,
        onEnter: handleEnter,
        onEntered: handleEntered,
        onEntering: handleEntering,
        onExit: handleExit,
        onExited: handleExited,
        onExiting: handleExiting,
        addEndListener: handleAddEndListener,
        timeout: timeout === "auto" ? null : timeout
      }, other, {
        children: (state, childProps) => {
          return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
            style: _extends$1({
              opacity: 0,
              transform: getScale(0.75),
              visibility: state === "exited" && !inProp ? "hidden" : void 0
            }, styles$1[state], style2, children.props.style),
            ref: handleRef
          }, childProps));
        }
      }));
    });
    Grow.muiSupportAuto = true;
    const Grow$1 = Grow;
    function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
      const [match2, setMatch] = reactExports.useState(() => {
        if (noSsr && matchMedia) {
          return matchMedia(query).matches;
        }
        if (ssrMatchMedia) {
          return ssrMatchMedia(query).matches;
        }
        return defaultMatches;
      });
      useEnhancedEffect$1(() => {
        let active = true;
        if (!matchMedia) {
          return void 0;
        }
        const queryList = matchMedia(query);
        const updateMatch = () => {
          if (active) {
            setMatch(queryList.matches);
          }
        };
        updateMatch();
        queryList.addListener(updateMatch);
        return () => {
          active = false;
          queryList.removeListener(updateMatch);
        };
      }, [query, matchMedia]);
      return match2;
    }
    const maybeReactUseSyncExternalStore = React$1["useSyncExternalStore"];
    function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
      const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
      const getServerSnapshot = reactExports.useMemo(() => {
        if (noSsr && matchMedia) {
          return () => matchMedia(query).matches;
        }
        if (ssrMatchMedia !== null) {
          const {
            matches: matches2
          } = ssrMatchMedia(query);
          return () => matches2;
        }
        return getDefaultSnapshot;
      }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
      const [getSnapshot, subscribe] = reactExports.useMemo(() => {
        if (matchMedia === null) {
          return [getDefaultSnapshot, () => () => {
          }];
        }
        const mediaQueryList = matchMedia(query);
        return [() => mediaQueryList.matches, (notify) => {
          mediaQueryList.addListener(notify);
          return () => {
            mediaQueryList.removeListener(notify);
          };
        }];
      }, [getDefaultSnapshot, matchMedia, query]);
      const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      return match2;
    }
    function useMediaQuery$1(queryInput, options = {}) {
      const theme = useTheme$2();
      const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
      const {
        defaultMatches = false,
        matchMedia = supportMatchMedia ? window.matchMedia : null,
        ssrMatchMedia = null,
        noSsr = false
      } = getThemeProps({
        name: "MuiUseMediaQuery",
        props: options,
        theme
      });
      let query = typeof queryInput === "function" ? queryInput(theme) : queryInput;
      query = query.replace(/^@media( ?)/m, "");
      const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
      const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
      return match2;
    }
    const _excluded$a = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
    const useUtilityClasses$8 = (ownerState) => {
      const {
        classes: classes2,
        disableUnderline
      } = ownerState;
      const slots = {
        root: ["root", !disableUnderline && "underline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getInputUtilityClass, classes2);
      return _extends$1({}, classes2, composedClasses);
    };
    const InputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiInput",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
      }
    })(({
      theme,
      ownerState
    }) => {
      const light2 = theme.palette.mode === "light";
      let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
      if (theme.vars) {
        bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
      }
      return _extends$1({
        position: "relative"
      }, ownerState.formControl && {
        "label + &": {
          marginTop: 16
        }
      }, !ownerState.disableUnderline && {
        "&:after": {
          borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '""',
          position: "absolute",
          right: 0,
          transform: "scaleX(0)",
          transition: theme.transitions.create("transform", {
            duration: theme.transitions.duration.shorter,
            easing: theme.transitions.easing.easeOut
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&.${inputClasses$1.focused}:after`]: {
          // translateX(0) is a workaround for Safari transform scale bug
          // See https://github.com/mui/material-ui/issues/31766
          transform: "scaleX(1) translateX(0)"
        },
        [`&.${inputClasses$1.error}`]: {
          "&:before, &:after": {
            borderBottomColor: (theme.vars || theme).palette.error.main
          }
        },
        "&:before": {
          borderBottom: `1px solid ${bottomLineColor}`,
          left: 0,
          bottom: 0,
          // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
          content: '"\\00a0"',
          position: "absolute",
          right: 0,
          transition: theme.transitions.create("border-bottom-color", {
            duration: theme.transitions.duration.shorter
          }),
          pointerEvents: "none"
          // Transparent to the hover style.
        },
        [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
          borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
          // Reset on touch devices, it doesn't add specificity
          "@media (hover: none)": {
            borderBottom: `1px solid ${bottomLineColor}`
          }
        },
        [`&.${inputClasses$1.disabled}:before`]: {
          borderBottomStyle: "dotted"
        }
      });
    });
    const InputInput = styled$1(InputBaseComponent, {
      name: "MuiInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })({});
    const Input$2 = /* @__PURE__ */ reactExports.forwardRef(function Input2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input;
      const props = useThemeProps({
        props: inProps,
        name: "MuiInput"
      });
      const {
        disableUnderline,
        components = {},
        componentsProps: componentsPropsProp,
        fullWidth = false,
        inputComponent = "input",
        multiline = false,
        slotProps,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
      const classes2 = useUtilityClasses$8(props);
      const ownerState = {
        disableUnderline
      };
      const inputComponentsProps = {
        root: {
          ownerState
        }
      };
      const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        slotProps: componentsProps,
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes: classes2
      }));
    });
    Input$2.muiName = "Input";
    const Input$3 = Input$2;
    const ListContext = /* @__PURE__ */ reactExports.createContext({});
    const ListContext$1 = ListContext;
    function getListUtilityClass(slot) {
      return generateUtilityClass("MuiList", slot);
    }
    generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
    const _excluded$9 = ["children", "className", "component", "dense", "disablePadding", "subheader"];
    const useUtilityClasses$7 = (ownerState) => {
      const {
        classes: classes2,
        disablePadding,
        dense,
        subheader
      } = ownerState;
      const slots = {
        root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
      };
      return composeClasses(slots, getListUtilityClass, classes2);
    };
    const ListRoot = styled$1("ul", {
      name: "MuiList",
      slot: "Root",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
      }
    })(({
      ownerState
    }) => _extends$1({
      listStyle: "none",
      margin: 0,
      padding: 0,
      position: "relative"
    }, !ownerState.disablePadding && {
      paddingTop: 8,
      paddingBottom: 8
    }, ownerState.subheader && {
      paddingTop: 0
    }));
    const List$1 = /* @__PURE__ */ reactExports.forwardRef(function List2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiList"
      });
      const {
        children,
        className,
        component = "ul",
        dense = false,
        disablePadding = false,
        subheader
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$9);
      const context = reactExports.useMemo(() => ({
        dense
      }), [dense]);
      const ownerState = _extends$1({}, props, {
        component,
        dense,
        disablePadding
      });
      const classes2 = useUtilityClasses$7(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: context,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$1({
          as: component,
          className: clsx(classes2.root, className),
          ref,
          ownerState
        }, other, {
          children: [subheader, children]
        }))
      });
    });
    const List$2 = List$1;
    const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
    const listItemIconClasses$1 = listItemIconClasses;
    const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
    const listItemTextClasses$1 = listItemTextClasses;
    const _excluded$8 = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
    function nextItem(list, item, disableListWrap) {
      if (list === item) {
        return list.firstChild;
      }
      if (item && item.nextElementSibling) {
        return item.nextElementSibling;
      }
      return disableListWrap ? null : list.firstChild;
    }
    function previousItem(list, item, disableListWrap) {
      if (list === item) {
        return disableListWrap ? list.firstChild : list.lastChild;
      }
      if (item && item.previousElementSibling) {
        return item.previousElementSibling;
      }
      return disableListWrap ? null : list.lastChild;
    }
    function textCriteriaMatches(nextFocus, textCriteria) {
      if (textCriteria === void 0) {
        return true;
      }
      let text = nextFocus.innerText;
      if (text === void 0) {
        text = nextFocus.textContent;
      }
      text = text.trim().toLowerCase();
      if (text.length === 0) {
        return false;
      }
      if (textCriteria.repeating) {
        return text[0] === textCriteria.keys[0];
      }
      return text.indexOf(textCriteria.keys.join("")) === 0;
    }
    function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
      let wrappedOnce = false;
      let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
      while (nextFocus) {
        if (nextFocus === list.firstChild) {
          if (wrappedOnce) {
            return false;
          }
          wrappedOnce = true;
        }
        const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
        if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
          nextFocus = traversalFunction(list, nextFocus, disableListWrap);
        } else {
          nextFocus.focus();
          return true;
        }
      }
      return false;
    }
    const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
      const {
        // private
        // eslint-disable-next-line react/prop-types
        actions: actions2,
        autoFocus = false,
        autoFocusItem = false,
        children,
        className,
        disabledItemsFocusable = false,
        disableListWrap = false,
        onKeyDown,
        variant = "selectedMenu"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
      const listRef = reactExports.useRef(null);
      const textCriteriaRef = reactExports.useRef({
        keys: [],
        repeating: true,
        previousKeyMatched: true,
        lastTime: null
      });
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          listRef.current.focus();
        }
      }, [autoFocus]);
      reactExports.useImperativeHandle(actions2, () => ({
        adjustStyleForScrollbar: (containerElement, theme) => {
          const noExplicitWidth = !listRef.current.style.width;
          if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
            const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
            listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
            listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
          }
          return listRef.current;
        }
      }), []);
      const handleKeyDown2 = (event) => {
        const list = listRef.current;
        const key = event.key;
        const currentFocus = ownerDocument(list).activeElement;
        if (key === "ArrowDown") {
          event.preventDefault();
          moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
        } else if (key === "ArrowUp") {
          event.preventDefault();
          moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (key === "Home") {
          event.preventDefault();
          moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
        } else if (key === "End") {
          event.preventDefault();
          moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
        } else if (key.length === 1) {
          const criteria = textCriteriaRef.current;
          const lowerKey = key.toLowerCase();
          const currTime = performance.now();
          if (criteria.keys.length > 0) {
            if (currTime - criteria.lastTime > 500) {
              criteria.keys = [];
              criteria.repeating = true;
              criteria.previousKeyMatched = true;
            } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
              criteria.repeating = false;
            }
          }
          criteria.lastTime = currTime;
          criteria.keys.push(lowerKey);
          const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
          if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
            event.preventDefault();
          } else {
            criteria.previousKeyMatched = false;
          }
        }
        if (onKeyDown) {
          onKeyDown(event);
        }
      };
      const handleRef = useForkRef(listRef, ref);
      let activeItemIndex = -1;
      reactExports.Children.forEach(children, (child, index) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          if (activeItemIndex === index) {
            activeItemIndex += 1;
            if (activeItemIndex >= children.length) {
              activeItemIndex = -1;
            }
          }
          return;
        }
        if (!child.props.disabled) {
          if (variant === "selectedMenu" && child.props.selected) {
            activeItemIndex = index;
          } else if (activeItemIndex === -1) {
            activeItemIndex = index;
          }
        }
        if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
          activeItemIndex += 1;
          if (activeItemIndex >= children.length) {
            activeItemIndex = -1;
          }
        }
      });
      const items = reactExports.Children.map(children, (child, index) => {
        if (index === activeItemIndex) {
          const newChildProps = {};
          if (autoFocusItem) {
            newChildProps.autoFocus = true;
          }
          if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
            newChildProps.tabIndex = 0;
          }
          return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
        }
        return child;
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(List$2, _extends$1({
        role: "menu",
        ref: handleRef,
        className,
        onKeyDown: handleKeyDown2,
        tabIndex: autoFocus ? 0 : -1
      }, other, {
        children: items
      }));
    });
    const MenuList$1 = MenuList;
    function getPopoverUtilityClass(slot) {
      return generateUtilityClass("MuiPopover", slot);
    }
    generateUtilityClasses("MuiPopover", ["root", "paper"]);
    const _excluded$7 = ["onEntering"], _excluded2$2 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3 = ["slotProps"];
    function getOffsetTop(rect, vertical) {
      let offset = 0;
      if (typeof vertical === "number") {
        offset = vertical;
      } else if (vertical === "center") {
        offset = rect.height / 2;
      } else if (vertical === "bottom") {
        offset = rect.height;
      }
      return offset;
    }
    function getOffsetLeft(rect, horizontal) {
      let offset = 0;
      if (typeof horizontal === "number") {
        offset = horizontal;
      } else if (horizontal === "center") {
        offset = rect.width / 2;
      } else if (horizontal === "right") {
        offset = rect.width;
      }
      return offset;
    }
    function getTransformOriginValue(transformOrigin) {
      return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
    }
    function resolveAnchorEl(anchorEl) {
      return typeof anchorEl === "function" ? anchorEl() : anchorEl;
    }
    const useUtilityClasses$6 = (ownerState) => {
      const {
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"]
      };
      return composeClasses(slots, getPopoverUtilityClass, classes2);
    };
    const PopoverRoot = styled$1(Modal$1, {
      name: "MuiPopover",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const PopoverPaper = styled$1(Paper$1, {
      name: "MuiPopover",
      slot: "Paper",
      overridesResolver: (props, styles2) => styles2.paper
    })({
      position: "absolute",
      overflowY: "auto",
      overflowX: "hidden",
      // So we see the popover when it's empty.
      // It's most likely on issue on userland.
      minWidth: 16,
      minHeight: 16,
      maxWidth: "calc(100% - 32px)",
      maxHeight: "calc(100% - 32px)",
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    });
    const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
      var _slotProps$paper, _slots$root, _slots$paper;
      const props = useThemeProps({
        props: inProps,
        name: "MuiPopover"
      });
      const {
        action,
        anchorEl,
        anchorOrigin = {
          vertical: "top",
          horizontal: "left"
        },
        anchorPosition,
        anchorReference = "anchorEl",
        children,
        className,
        container: containerProp,
        elevation = 8,
        marginThreshold = 16,
        open,
        PaperProps: PaperPropsProp = {},
        slots,
        slotProps,
        transformOrigin = {
          vertical: "top",
          horizontal: "left"
        },
        TransitionComponent = Grow$1,
        transitionDuration: transitionDurationProp = "auto",
        TransitionProps: {
          onEntering
        } = {},
        disableScrollLock = false
      } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$7), other = _objectWithoutPropertiesLoose(props, _excluded2$2);
      const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
      const paperRef = reactExports.useRef();
      const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
      const ownerState = _extends$1({}, props, {
        anchorOrigin,
        anchorReference,
        elevation,
        marginThreshold,
        externalPaperSlotProps,
        transformOrigin,
        TransitionComponent,
        transitionDuration: transitionDurationProp,
        TransitionProps
      });
      const classes2 = useUtilityClasses$6(ownerState);
      const getAnchorOffset = reactExports.useCallback(() => {
        if (anchorReference === "anchorPosition") {
          return anchorPosition;
        }
        const resolvedAnchorEl = resolveAnchorEl(anchorEl);
        const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
        const anchorRect = anchorElement.getBoundingClientRect();
        return {
          top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
          left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
        };
      }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
      const getTransformOrigin = reactExports.useCallback((elemRect) => {
        return {
          vertical: getOffsetTop(elemRect, transformOrigin.vertical),
          horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
        };
      }, [transformOrigin.horizontal, transformOrigin.vertical]);
      const getPositioningStyle = reactExports.useCallback((element) => {
        const elemRect = {
          width: element.offsetWidth,
          height: element.offsetHeight
        };
        const elemTransformOrigin = getTransformOrigin(elemRect);
        if (anchorReference === "none") {
          return {
            top: null,
            left: null,
            transformOrigin: getTransformOriginValue(elemTransformOrigin)
          };
        }
        const anchorOffset = getAnchorOffset();
        let top = anchorOffset.top - elemTransformOrigin.vertical;
        let left = anchorOffset.left - elemTransformOrigin.horizontal;
        const bottom = top + elemRect.height;
        const right = left + elemRect.width;
        const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
        const heightThreshold = containerWindow.innerHeight - marginThreshold;
        const widthThreshold = containerWindow.innerWidth - marginThreshold;
        if (marginThreshold !== null && top < marginThreshold) {
          const diff = top - marginThreshold;
          top -= diff;
          elemTransformOrigin.vertical += diff;
        } else if (marginThreshold !== null && bottom > heightThreshold) {
          const diff = bottom - heightThreshold;
          top -= diff;
          elemTransformOrigin.vertical += diff;
        }
        if (marginThreshold !== null && left < marginThreshold) {
          const diff = left - marginThreshold;
          left -= diff;
          elemTransformOrigin.horizontal += diff;
        } else if (right > widthThreshold) {
          const diff = right - widthThreshold;
          left -= diff;
          elemTransformOrigin.horizontal += diff;
        }
        return {
          top: `${Math.round(top)}px`,
          left: `${Math.round(left)}px`,
          transformOrigin: getTransformOriginValue(elemTransformOrigin)
        };
      }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
      const [isPositioned, setIsPositioned] = reactExports.useState(open);
      const setPositioningStyles = reactExports.useCallback(() => {
        const element = paperRef.current;
        if (!element) {
          return;
        }
        const positioning = getPositioningStyle(element);
        if (positioning.top !== null) {
          element.style.top = positioning.top;
        }
        if (positioning.left !== null) {
          element.style.left = positioning.left;
        }
        element.style.transformOrigin = positioning.transformOrigin;
        setIsPositioned(true);
      }, [getPositioningStyle]);
      reactExports.useEffect(() => {
        if (disableScrollLock) {
          window.addEventListener("scroll", setPositioningStyles);
        }
        return () => window.removeEventListener("scroll", setPositioningStyles);
      }, [anchorEl, disableScrollLock, setPositioningStyles]);
      const handleEntering = (element, isAppearing) => {
        if (onEntering) {
          onEntering(element, isAppearing);
        }
        setPositioningStyles();
      };
      const handleExited = () => {
        setIsPositioned(false);
      };
      reactExports.useEffect(() => {
        if (open) {
          setPositioningStyles();
        }
      });
      reactExports.useImperativeHandle(action, () => open ? {
        updatePosition: () => {
          setPositioningStyles();
        }
      } : null, [open, setPositioningStyles]);
      reactExports.useEffect(() => {
        if (!open) {
          return void 0;
        }
        const handleResize = debounce(() => {
          setPositioningStyles();
        });
        const containerWindow = ownerWindow(anchorEl);
        containerWindow.addEventListener("resize", handleResize);
        return () => {
          handleResize.clear();
          containerWindow.removeEventListener("resize", handleResize);
        };
      }, [anchorEl, open, setPositioningStyles]);
      let transitionDuration = transitionDurationProp;
      if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
        transitionDuration = void 0;
      }
      const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
      const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
      const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
      const paperProps = useSlotProps({
        elementType: PaperSlot,
        externalSlotProps: _extends$1({}, externalPaperSlotProps, {
          style: isPositioned ? externalPaperSlotProps.style : _extends$1({}, externalPaperSlotProps.style, {
            opacity: 0
          })
        }),
        additionalProps: {
          elevation,
          ref: handlePaperRef
        },
        ownerState,
        className: clsx(classes2.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
      });
      const _useSlotProps = useSlotProps({
        elementType: RootSlot,
        externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
        externalForwardedProps: other,
        additionalProps: {
          ref,
          slotProps: {
            backdrop: {
              invisible: true
            }
          },
          container,
          open
        },
        ownerState,
        className: clsx(classes2.root, className)
      }), {
        slotProps: rootSlotPropsProp
      } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded3);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$1({}, rootProps, !isHostComponent(RootSlot) && {
        slotProps: rootSlotPropsProp,
        disableScrollLock
      }, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
          appear: true,
          in: open,
          onEntering: handleEntering,
          onExited: handleExited,
          timeout: transitionDuration
        }, TransitionProps, {
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$1({}, paperProps, {
            children
          }))
        }))
      }));
    });
    const Popover$1 = Popover;
    function getMenuUtilityClass(slot) {
      return generateUtilityClass("MuiMenu", slot);
    }
    generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
    const _excluded$6 = ["onEntering"], _excluded2$1 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
    const RTL_ORIGIN = {
      vertical: "top",
      horizontal: "right"
    };
    const LTR_ORIGIN = {
      vertical: "top",
      horizontal: "left"
    };
    const useUtilityClasses$5 = (ownerState) => {
      const {
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root"],
        paper: ["paper"],
        list: ["list"]
      };
      return composeClasses(slots, getMenuUtilityClass, classes2);
    };
    const MenuRoot = styled$1(Popover$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiMenu",
      slot: "Root",
      overridesResolver: (props, styles2) => styles2.root
    })({});
    const MenuPaper = styled$1(PopoverPaper, {
      name: "MuiMenu",
      slot: "Paper",
      overridesResolver: (props, styles2) => styles2.paper
    })({
      // specZ: The maximum height of a simple menu should be one or more rows less than the view
      // height. This ensures a tappable area outside of the simple menu with which to dismiss
      // the menu.
      maxHeight: "calc(100% - 96px)",
      // Add iOS momentum scrolling for iOS < 13.0
      WebkitOverflowScrolling: "touch"
    });
    const MenuMenuList = styled$1(MenuList$1, {
      name: "MuiMenu",
      slot: "List",
      overridesResolver: (props, styles2) => styles2.list
    })({
      // We disable the focus ring for mouse, touch and keyboard users.
      outline: 0
    });
    const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
      var _slots$paper, _slotProps$paper;
      const props = useThemeProps({
        props: inProps,
        name: "MuiMenu"
      });
      const {
        autoFocus = true,
        children,
        className,
        disableAutoFocusItem = false,
        MenuListProps = {},
        onClose,
        open,
        PaperProps = {},
        PopoverClasses,
        transitionDuration = "auto",
        TransitionProps: {
          onEntering
        } = {},
        variant = "selectedMenu",
        slots = {},
        slotProps = {}
      } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$6), other = _objectWithoutPropertiesLoose(props, _excluded2$1);
      const theme = useTheme();
      const isRtl = theme.direction === "rtl";
      const ownerState = _extends$1({}, props, {
        autoFocus,
        disableAutoFocusItem,
        MenuListProps,
        onEntering,
        PaperProps,
        transitionDuration,
        TransitionProps,
        variant
      });
      const classes2 = useUtilityClasses$5(ownerState);
      const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
      const menuListActionsRef = reactExports.useRef(null);
      const handleEntering = (element, isAppearing) => {
        if (menuListActionsRef.current) {
          menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
        }
        if (onEntering) {
          onEntering(element, isAppearing);
        }
      };
      const handleListKeyDown = (event) => {
        if (event.key === "Tab") {
          event.preventDefault();
          if (onClose) {
            onClose(event, "tabKeyDown");
          }
        }
      };
      let activeItemIndex = -1;
      reactExports.Children.map(children, (child, index) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          return;
        }
        if (!child.props.disabled) {
          if (variant === "selectedMenu" && child.props.selected) {
            activeItemIndex = index;
          } else if (activeItemIndex === -1) {
            activeItemIndex = index;
          }
        }
      });
      const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
      const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
      const rootSlotProps = useSlotProps({
        elementType: slots.root,
        externalSlotProps: slotProps.root,
        ownerState,
        className: [classes2.root, className]
      });
      const paperSlotProps = useSlotProps({
        elementType: PaperSlot,
        externalSlotProps: paperExternalSlotProps,
        ownerState,
        className: classes2.paper
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$1({
        onClose,
        anchorOrigin: {
          vertical: "bottom",
          horizontal: isRtl ? "right" : "left"
        },
        transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
        slots: {
          paper: PaperSlot,
          root: slots.root
        },
        slotProps: {
          root: rootSlotProps,
          paper: paperSlotProps
        },
        open,
        ref,
        transitionDuration,
        TransitionProps: _extends$1({
          onEntering: handleEntering
        }, TransitionProps),
        ownerState
      }, other, {
        classes: PopoverClasses,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$1({
          onKeyDown: handleListKeyDown,
          actions: menuListActionsRef,
          autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
          autoFocusItem,
          variant
        }, MenuListProps, {
          className: clsx(classes2.list, MenuListProps.className),
          children
        }))
      }));
    });
    const Menu$1 = Menu;
    function getMenuItemUtilityClass(slot) {
      return generateUtilityClass("MuiMenuItem", slot);
    }
    const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
    const menuItemClasses$1 = menuItemClasses;
    const _excluded$5 = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
    const overridesResolver = (props, styles2) => {
      const {
        ownerState
      } = props;
      return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
    };
    const useUtilityClasses$4 = (ownerState) => {
      const {
        disabled,
        dense,
        divider,
        disableGutters,
        selected,
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
      };
      const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes2);
      return _extends$1({}, classes2, composedClasses);
    };
    const MenuItemRoot = styled$1(ButtonBase$1, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiMenuItem",
      slot: "Root",
      overridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({}, theme.typography.body1, {
      display: "flex",
      justifyContent: "flex-start",
      alignItems: "center",
      position: "relative",
      textDecoration: "none",
      minHeight: 48,
      paddingTop: 6,
      paddingBottom: 6,
      boxSizing: "border-box",
      whiteSpace: "nowrap"
    }, !ownerState.disableGutters && {
      paddingLeft: 16,
      paddingRight: 16
    }, ownerState.divider && {
      borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
      backgroundClip: "padding-box"
    }, {
      "&:hover": {
        textDecoration: "none",
        backgroundColor: (theme.vars || theme).palette.action.hover,
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: "transparent"
        }
      },
      [`&.${menuItemClasses$1.selected}`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
        [`&.${menuItemClasses$1.focusVisible}`]: {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
        }
      },
      [`&.${menuItemClasses$1.selected}:hover`]: {
        backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
        }
      },
      [`&.${menuItemClasses$1.focusVisible}`]: {
        backgroundColor: (theme.vars || theme).palette.action.focus
      },
      [`&.${menuItemClasses$1.disabled}`]: {
        opacity: (theme.vars || theme).palette.action.disabledOpacity
      },
      [`& + .${dividerClasses$1.root}`]: {
        marginTop: theme.spacing(1),
        marginBottom: theme.spacing(1)
      },
      [`& + .${dividerClasses$1.inset}`]: {
        marginLeft: 52
      },
      [`& .${listItemTextClasses$1.root}`]: {
        marginTop: 0,
        marginBottom: 0
      },
      [`& .${listItemTextClasses$1.inset}`]: {
        paddingLeft: 36
      },
      [`& .${listItemIconClasses$1.root}`]: {
        minWidth: 36
      }
    }, !ownerState.dense && {
      [theme.breakpoints.up("sm")]: {
        minHeight: "auto"
      }
    }, ownerState.dense && _extends$1({
      minHeight: 32,
      // https://m2.material.io/components/menus#specs > Dense
      paddingTop: 4,
      paddingBottom: 4
    }, theme.typography.body2, {
      [`& .${listItemIconClasses$1.root} svg`]: {
        fontSize: "1.25rem"
      }
    })));
    const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
      const props = useThemeProps({
        props: inProps,
        name: "MuiMenuItem"
      });
      const {
        autoFocus = false,
        component = "li",
        dense = false,
        divider = false,
        disableGutters = false,
        focusVisibleClassName,
        role = "menuitem",
        tabIndex: tabIndexProp,
        className
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$5);
      const context = reactExports.useContext(ListContext$1);
      const childContext = reactExports.useMemo(() => ({
        dense: dense || context.dense || false,
        disableGutters
      }), [context.dense, dense, disableGutters]);
      const menuItemRef = reactExports.useRef(null);
      useEnhancedEffect$1(() => {
        if (autoFocus) {
          if (menuItemRef.current) {
            menuItemRef.current.focus();
          }
        }
      }, [autoFocus]);
      const ownerState = _extends$1({}, props, {
        dense: childContext.dense,
        divider,
        disableGutters
      });
      const classes2 = useUtilityClasses$4(props);
      const handleRef = useForkRef(menuItemRef, ref);
      let tabIndex;
      if (!props.disabled) {
        tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
        value: childContext,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$1({
          ref: handleRef,
          role,
          tabIndex,
          component,
          focusVisibleClassName: clsx(classes2.focusVisible, focusVisibleClassName),
          className: clsx(classes2.root, className)
        }, other, {
          ownerState,
          classes: classes2
        }))
      });
    });
    const MenuItem$1 = MenuItem;
    function getNativeSelectUtilityClasses(slot) {
      return generateUtilityClass("MuiNativeSelect", slot);
    }
    const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
    const nativeSelectClasses$1 = nativeSelectClasses;
    const _excluded$4 = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
    const useUtilityClasses$3 = (ownerState) => {
      const {
        classes: classes2,
        variant,
        disabled,
        multiple,
        open,
        error
      } = ownerState;
      const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
        icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
      };
      return composeClasses(slots, getNativeSelectUtilityClasses, classes2);
    };
    const nativeSelectSelectStyles = ({
      ownerState,
      theme
    }) => _extends$1({
      MozAppearance: "none",
      // Reset
      WebkitAppearance: "none",
      // Reset
      // When interacting quickly, the text can end up selected.
      // Native select can't be selected either.
      userSelect: "none",
      borderRadius: 0,
      // Reset
      cursor: "pointer",
      "&:focus": _extends$1({}, theme.vars ? {
        backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`
      } : {
        backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
      }, {
        borderRadius: 0
        // Reset Chrome style
      }),
      // Remove IE11 arrow
      "&::-ms-expand": {
        display: "none"
      },
      [`&.${nativeSelectClasses$1.disabled}`]: {
        cursor: "default"
      },
      "&[multiple]": {
        height: "auto"
      },
      "&:not([multiple]) option, &:not([multiple]) optgroup": {
        backgroundColor: (theme.vars || theme).palette.background.paper
      },
      // Bump specificity to allow extending custom inputs
      "&&&": {
        paddingRight: 24,
        minWidth: 16
        // So it doesn't collapse.
      }
    }, ownerState.variant === "filled" && {
      "&&&": {
        paddingRight: 32
      }
    }, ownerState.variant === "outlined" && {
      borderRadius: (theme.vars || theme).shape.borderRadius,
      "&:focus": {
        borderRadius: (theme.vars || theme).shape.borderRadius
        // Reset the reset for Chrome style
      },
      "&&&": {
        paddingRight: 32
      }
    });
    const NativeSelectSelect = styled$1("select", {
      name: "MuiNativeSelect",
      slot: "Select",
      shouldForwardProp: rootShouldForwardProp,
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
          [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
        }];
      }
    })(nativeSelectSelectStyles);
    const nativeSelectIconStyles = ({
      ownerState,
      theme
    }) => _extends$1({
      // We use a position absolute over a flexbox in order to forward the pointer events
      // to the input and to support wrapping tags..
      position: "absolute",
      right: 0,
      top: "calc(50% - .5em)",
      // Center vertically, height is 1em
      pointerEvents: "none",
      // Don't block pointer events on the select under the icon.
      color: (theme.vars || theme).palette.action.active,
      [`&.${nativeSelectClasses$1.disabled}`]: {
        color: (theme.vars || theme).palette.action.disabled
      }
    }, ownerState.open && {
      transform: "rotate(180deg)"
    }, ownerState.variant === "filled" && {
      right: 7
    }, ownerState.variant === "outlined" && {
      right: 7
    });
    const NativeSelectIcon = styled$1("svg", {
      name: "MuiNativeSelect",
      slot: "Icon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
      }
    })(nativeSelectIconStyles);
    const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
      const {
        className,
        disabled,
        error,
        IconComponent,
        inputRef,
        variant = "standard"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$4);
      const ownerState = _extends$1({}, props, {
        disabled,
        variant,
        error
      });
      const classes2 = useUtilityClasses$3(ownerState);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends$1({
          ownerState,
          className: clsx(classes2.select, className),
          disabled,
          ref: inputRef || ref
        }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
          as: IconComponent,
          ownerState,
          className: classes2.icon
        })]
      });
    });
    const NativeSelectInput$1 = NativeSelectInput;
    var _span$1;
    const _excluded$3 = ["children", "classes", "className", "label", "notched"];
    const NotchedOutlineRoot$1 = styled$1("fieldset", {
      shouldForwardProp: rootShouldForwardProp
    })({
      textAlign: "left",
      position: "absolute",
      bottom: 0,
      right: 0,
      top: -5,
      left: 0,
      margin: 0,
      padding: "0 8px",
      pointerEvents: "none",
      borderRadius: "inherit",
      borderStyle: "solid",
      borderWidth: 1,
      overflow: "hidden",
      minWidth: "0%"
    });
    const NotchedOutlineLegend = styled$1("legend", {
      shouldForwardProp: rootShouldForwardProp
    })(({
      ownerState,
      theme
    }) => _extends$1({
      float: "unset",
      // Fix conflict with bootstrap
      width: "auto",
      // Fix conflict with bootstrap
      overflow: "hidden"
    }, !ownerState.withLabel && {
      padding: 0,
      lineHeight: "11px",
      // sync with `height` in `legend` styles
      transition: theme.transitions.create("width", {
        duration: 150,
        easing: theme.transitions.easing.easeOut
      })
    }, ownerState.withLabel && _extends$1({
      display: "block",
      // Fix conflict with normalize.css and sanitize.css
      padding: 0,
      height: 11,
      // sync with `lineHeight` in `legend` styles
      fontSize: "0.75em",
      visibility: "hidden",
      maxWidth: 0.01,
      transition: theme.transitions.create("max-width", {
        duration: 50,
        easing: theme.transitions.easing.easeOut
      }),
      whiteSpace: "nowrap",
      "& > span": {
        paddingLeft: 5,
        paddingRight: 5,
        display: "inline-block",
        opacity: 0,
        visibility: "visible"
      }
    }, ownerState.notched && {
      maxWidth: "100%",
      transition: theme.transitions.create("max-width", {
        duration: 100,
        easing: theme.transitions.easing.easeOut,
        delay: 50
      })
    })));
    function NotchedOutline(props) {
      const {
        className,
        label,
        notched
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$3);
      const withLabel = label != null && label !== "";
      const ownerState = _extends$1({}, props, {
        notched,
        withLabel
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$1({
        "aria-hidden": true,
        className,
        ownerState
      }, other, {
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
          ownerState,
          children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
            children: label
          }) : (
            // notranslate needed while Google Translate will not fix zero-width space issue
            _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "notranslate",
              children: ""
            }))
          )
        })
      }));
    }
    const _excluded$2 = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
    const useUtilityClasses$2 = (ownerState) => {
      const {
        classes: classes2
      } = ownerState;
      const slots = {
        root: ["root"],
        notchedOutline: ["notchedOutline"],
        input: ["input"]
      };
      const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes2);
      return _extends$1({}, classes2, composedClasses);
    };
    const OutlinedInputRoot = styled$1(InputBaseRoot, {
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
      name: "MuiOutlinedInput",
      slot: "Root",
      overridesResolver: rootOverridesResolver
    })(({
      theme,
      ownerState
    }) => {
      const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
      return _extends$1({
        position: "relative",
        borderRadius: (theme.vars || theme).shape.borderRadius,
        [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.text.primary
        },
        // Reset on touch devices, it doesn't add specificity
        "@media (hover: none)": {
          [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
            borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
          }
        },
        [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette[ownerState.color].main,
          borderWidth: 2
        },
        [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.error.main
        },
        [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
          borderColor: (theme.vars || theme).palette.action.disabled
        }
      }, ownerState.startAdornment && {
        paddingLeft: 14
      }, ownerState.endAdornment && {
        paddingRight: 14
      }, ownerState.multiline && _extends$1({
        padding: "16.5px 14px"
      }, ownerState.size === "small" && {
        padding: "8.5px 14px"
      }));
    });
    const NotchedOutlineRoot = styled$1(NotchedOutline, {
      name: "MuiOutlinedInput",
      slot: "NotchedOutline",
      overridesResolver: (props, styles2) => styles2.notchedOutline
    })(({
      theme
    }) => {
      const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
      return {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      };
    });
    const OutlinedInputInput = styled$1(InputBaseComponent, {
      name: "MuiOutlinedInput",
      slot: "Input",
      overridesResolver: inputOverridesResolver
    })(({
      theme,
      ownerState
    }) => _extends$1({
      padding: "16.5px 14px"
    }, !theme.vars && {
      "&:-webkit-autofill": {
        WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
        WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
        caretColor: theme.palette.mode === "light" ? null : "#fff",
        borderRadius: "inherit"
      }
    }, theme.vars && {
      "&:-webkit-autofill": {
        borderRadius: "inherit"
      },
      [theme.getColorSchemeSelector("dark")]: {
        "&:-webkit-autofill": {
          WebkitBoxShadow: "0 0 0 100px #266798 inset",
          WebkitTextFillColor: "#fff",
          caretColor: "#fff"
        }
      }
    }, ownerState.size === "small" && {
      padding: "8.5px 14px"
    }, ownerState.multiline && {
      padding: 0
    }, ownerState.startAdornment && {
      paddingLeft: 0
    }, ownerState.endAdornment && {
      paddingRight: 0
    }));
    const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
      var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
      const props = useThemeProps({
        props: inProps,
        name: "MuiOutlinedInput"
      });
      const {
        components = {},
        fullWidth = false,
        inputComponent = "input",
        label,
        multiline = false,
        notched,
        slots = {},
        type = "text"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$2);
      const classes2 = useUtilityClasses$2(props);
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
      });
      const ownerState = _extends$1({}, props, {
        color: fcs.color || "primary",
        disabled: fcs.disabled,
        error: fcs.error,
        focused: fcs.focused,
        formControl: muiFormControl,
        fullWidth,
        hiddenLabel: fcs.hiddenLabel,
        multiline,
        size: fcs.size,
        type
      });
      const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
      const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
      return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
        slots: {
          root: RootSlot,
          input: InputSlot
        },
        renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
          ownerState,
          className: classes2.notchedOutline,
          label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [label, "", "*"]
          })) : label,
          notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
        }),
        fullWidth,
        inputComponent,
        multiline,
        ref,
        type
      }, other, {
        classes: _extends$1({}, classes2, {
          notchedOutline: null
        })
      }));
    });
    OutlinedInput.muiName = "Input";
    const OutlinedInput$1 = OutlinedInput;
    function getSelectUtilityClasses(slot) {
      return generateUtilityClass("MuiSelect", slot);
    }
    const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
    const selectClasses$1 = selectClasses;
    var _span;
    const _excluded$1 = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
    const SelectSelect = styled$1("div", {
      name: "MuiSelect",
      slot: "Select",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [
          // Win specificity over the input base
          {
            [`&.${selectClasses$1.select}`]: styles2.select
          },
          {
            [`&.${selectClasses$1.select}`]: styles2[ownerState.variant]
          },
          {
            [`&.${selectClasses$1.error}`]: styles2.error
          },
          {
            [`&.${selectClasses$1.multiple}`]: styles2.multiple
          }
        ];
      }
    })(nativeSelectSelectStyles, {
      // Win specificity over the input base
      [`&.${selectClasses$1.select}`]: {
        height: "auto",
        // Resets for multiple select with chips
        minHeight: "1.4375em",
        // Required for select\text-field height consistency
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        overflow: "hidden"
      }
    });
    const SelectIcon$2 = styled$1("svg", {
      name: "MuiSelect",
      slot: "Icon",
      overridesResolver: (props, styles2) => {
        const {
          ownerState
        } = props;
        return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
      }
    })(nativeSelectIconStyles);
    const SelectNativeInput = styled$1("input", {
      shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
      name: "MuiSelect",
      slot: "NativeInput",
      overridesResolver: (props, styles2) => styles2.nativeInput
    })({
      bottom: 0,
      left: 0,
      position: "absolute",
      opacity: 0,
      pointerEvents: "none",
      width: "100%",
      boxSizing: "border-box"
    });
    function areEqualValues(a2, b2) {
      if (typeof b2 === "object" && b2 !== null) {
        return a2 === b2;
      }
      return String(a2) === String(b2);
    }
    function isEmpty(display) {
      return display == null || typeof display === "string" && !display.trim();
    }
    const useUtilityClasses$1 = (ownerState) => {
      const {
        classes: classes2,
        variant,
        disabled,
        multiple,
        open,
        error
      } = ownerState;
      const slots = {
        select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
        icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
        nativeInput: ["nativeInput"]
      };
      return composeClasses(slots, getSelectUtilityClasses, classes2);
    };
    const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
      var _MenuProps$slotProps;
      const {
        "aria-describedby": ariaDescribedby,
        "aria-label": ariaLabel,
        autoFocus,
        autoWidth,
        children,
        className,
        defaultOpen,
        defaultValue,
        disabled,
        displayEmpty,
        error = false,
        IconComponent,
        inputRef: inputRefProp,
        labelId,
        MenuProps = {},
        multiple,
        name,
        onBlur,
        onChange,
        onClose,
        onFocus: onFocus2,
        onOpen,
        open: openProp,
        readOnly,
        renderValue,
        SelectDisplayProps = {},
        tabIndex: tabIndexProp,
        value: valueProp,
        variant = "standard"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
      const [value, setValueState] = useControlled({
        controlled: valueProp,
        default: defaultValue,
        name: "Select"
      });
      const [openState, setOpenState] = useControlled({
        controlled: openProp,
        default: defaultOpen,
        name: "Select"
      });
      const inputRef = reactExports.useRef(null);
      const displayRef = reactExports.useRef(null);
      const [displayNode, setDisplayNode] = reactExports.useState(null);
      const {
        current: isOpenControlled
      } = reactExports.useRef(openProp != null);
      const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
      const handleRef = useForkRef(ref, inputRefProp);
      const handleDisplayRef = reactExports.useCallback((node2) => {
        displayRef.current = node2;
        if (node2) {
          setDisplayNode(node2);
        }
      }, []);
      const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
      reactExports.useImperativeHandle(handleRef, () => ({
        focus: () => {
          displayRef.current.focus();
        },
        node: inputRef.current,
        value
      }), [value]);
      reactExports.useEffect(() => {
        if (defaultOpen && openState && displayNode && !isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
          displayRef.current.focus();
        }
      }, [displayNode, autoWidth]);
      reactExports.useEffect(() => {
        if (autoFocus) {
          displayRef.current.focus();
        }
      }, [autoFocus]);
      reactExports.useEffect(() => {
        if (!labelId) {
          return void 0;
        }
        const label = ownerDocument(displayRef.current).getElementById(labelId);
        if (label) {
          const handler = () => {
            if (getSelection().isCollapsed) {
              displayRef.current.focus();
            }
          };
          label.addEventListener("click", handler);
          return () => {
            label.removeEventListener("click", handler);
          };
        }
        return void 0;
      }, [labelId]);
      const update2 = (open2, event) => {
        if (open2) {
          if (onOpen) {
            onOpen(event);
          }
        } else if (onClose) {
          onClose(event);
        }
        if (!isOpenControlled) {
          setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
          setOpenState(open2);
        }
      };
      const handleMouseDown = (event) => {
        if (event.button !== 0) {
          return;
        }
        event.preventDefault();
        displayRef.current.focus();
        update2(true, event);
      };
      const handleClose = (event) => {
        update2(false, event);
      };
      const childrenArray = reactExports.Children.toArray(children);
      const handleChange = (event) => {
        const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
        if (child === void 0) {
          return;
        }
        setValueState(child.props.value);
        if (onChange) {
          onChange(event, child);
        }
      };
      const handleItemClick = (child) => (event) => {
        let newValue;
        if (!event.currentTarget.hasAttribute("tabindex")) {
          return;
        }
        if (multiple) {
          newValue = Array.isArray(value) ? value.slice() : [];
          const itemIndex = value.indexOf(child.props.value);
          if (itemIndex === -1) {
            newValue.push(child.props.value);
          } else {
            newValue.splice(itemIndex, 1);
          }
        } else {
          newValue = child.props.value;
        }
        if (child.props.onClick) {
          child.props.onClick(event);
        }
        if (value !== newValue) {
          setValueState(newValue);
          if (onChange) {
            const nativeEvent = event.nativeEvent || event;
            const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
            Object.defineProperty(clonedEvent, "target", {
              writable: true,
              value: {
                value: newValue,
                name
              }
            });
            onChange(clonedEvent, child);
          }
        }
        if (!multiple) {
          update2(false, event);
        }
      };
      const handleKeyDown2 = (event) => {
        if (!readOnly) {
          const validKeys = [
            " ",
            "ArrowUp",
            "ArrowDown",
            // The native select doesn't respond to enter on macOS, but it's recommended by
            // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
            "Enter"
          ];
          if (validKeys.indexOf(event.key) !== -1) {
            event.preventDefault();
            update2(true, event);
          }
        }
      };
      const open = displayNode !== null && openState;
      const handleBlur = (event) => {
        if (!open && onBlur) {
          Object.defineProperty(event, "target", {
            writable: true,
            value: {
              value,
              name
            }
          });
          onBlur(event);
        }
      };
      delete other["aria-invalid"];
      let display;
      let displaySingle;
      const displayMultiple = [];
      let computeDisplay = false;
      if (isFilled({
        value
      }) || displayEmpty) {
        if (renderValue) {
          display = renderValue(value);
        } else {
          computeDisplay = true;
        }
      }
      const items = childrenArray.map((child) => {
        if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
          return null;
        }
        let selected;
        if (multiple) {
          if (!Array.isArray(value)) {
            throw new Error(formatMuiErrorMessage(2));
          }
          selected = value.some((v2) => areEqualValues(v2, child.props.value));
          if (selected && computeDisplay) {
            displayMultiple.push(child.props.children);
          }
        } else {
          selected = areEqualValues(value, child.props.value);
          if (selected && computeDisplay) {
            displaySingle = child.props.children;
          }
        }
        return /* @__PURE__ */ reactExports.cloneElement(child, {
          "aria-selected": selected ? "true" : "false",
          onClick: handleItemClick(child),
          onKeyUp: (event) => {
            if (event.key === " ") {
              event.preventDefault();
            }
            if (child.props.onKeyUp) {
              child.props.onKeyUp(event);
            }
          },
          role: "option",
          selected,
          value: void 0,
          // The value is most likely not a valid HTML attribute.
          "data-value": child.props.value
          // Instead, we provide it as a data attribute.
        });
      });
      if (computeDisplay) {
        if (multiple) {
          if (displayMultiple.length === 0) {
            display = null;
          } else {
            display = displayMultiple.reduce((output, child, index) => {
              output.push(child);
              if (index < displayMultiple.length - 1) {
                output.push(", ");
              }
              return output;
            }, []);
          }
        } else {
          display = displaySingle;
        }
      }
      let menuMinWidth = menuMinWidthState;
      if (!autoWidth && isOpenControlled && displayNode) {
        menuMinWidth = anchorElement.clientWidth;
      }
      let tabIndex;
      if (typeof tabIndexProp !== "undefined") {
        tabIndex = tabIndexProp;
      } else {
        tabIndex = disabled ? null : 0;
      }
      const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
      const ownerState = _extends$1({}, props, {
        variant,
        value,
        open,
        error
      });
      const classes2 = useUtilityClasses$1(ownerState);
      const paperProps = _extends$1({}, MenuProps.PaperProps, (_MenuProps$slotProps = MenuProps.slotProps) == null ? void 0 : _MenuProps$slotProps.paper);
      const listboxId = useId();
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends$1({
          ref: handleDisplayRef,
          tabIndex,
          role: "combobox",
          "aria-controls": listboxId,
          "aria-disabled": disabled ? "true" : void 0,
          "aria-expanded": open ? "true" : "false",
          "aria-haspopup": "listbox",
          "aria-label": ariaLabel,
          "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
          "aria-describedby": ariaDescribedby,
          onKeyDown: handleKeyDown2,
          onMouseDown: disabled || readOnly ? null : handleMouseDown,
          onBlur: handleBlur,
          onFocus: onFocus2
        }, SelectDisplayProps, {
          ownerState,
          className: clsx(SelectDisplayProps.className, classes2.select, className),
          id: buttonId,
          children: isEmpty(display) ? (
            // notranslate needed while Google Translate will not fix zero-width space issue
            _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
              className: "notranslate",
              children: ""
            }))
          ) : display
        })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends$1({
          "aria-invalid": error,
          value: Array.isArray(value) ? value.join(",") : value,
          name,
          ref: inputRef,
          "aria-hidden": true,
          onChange: handleChange,
          tabIndex: -1,
          disabled,
          className: classes2.nativeInput,
          autoFocus,
          ownerState
        }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon$2, {
          as: IconComponent,
          className: classes2.icon,
          ownerState
        }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, _extends$1({
          id: `menu-${name || ""}`,
          anchorEl: anchorElement,
          open,
          onClose: handleClose,
          anchorOrigin: {
            vertical: "bottom",
            horizontal: "center"
          },
          transformOrigin: {
            vertical: "top",
            horizontal: "center"
          }
        }, MenuProps, {
          MenuListProps: _extends$1({
            "aria-labelledby": labelId,
            role: "listbox",
            "aria-multiselectable": multiple ? "true" : void 0,
            disableListWrap: true,
            id: listboxId
          }, MenuProps.MenuListProps),
          slotProps: _extends$1({}, MenuProps.slotProps, {
            paper: _extends$1({}, paperProps, {
              style: _extends$1({
                minWidth: menuMinWidth
              }, paperProps != null ? paperProps.style : null)
            })
          }),
          children: items
        }))]
      });
    });
    const SelectInput$1 = SelectInput;
    const _excluded = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], _excluded2 = ["root"];
    const useUtilityClasses = (ownerState) => {
      const {
        classes: classes2
      } = ownerState;
      return classes2;
    };
    const styledRootConfig = {
      name: "MuiSelect",
      overridesResolver: (props, styles2) => styles2.root,
      shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
      slot: "Root"
    };
    const StyledInput = styled$1(Input$3, styledRootConfig)("");
    const StyledOutlinedInput = styled$1(OutlinedInput$1, styledRootConfig)("");
    const StyledFilledInput = styled$1(FilledInput$1, styledRootConfig)("");
    const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
      const props = useThemeProps({
        name: "MuiSelect",
        props: inProps
      });
      const {
        autoWidth = false,
        children,
        classes: classesProp = {},
        className,
        defaultOpen = false,
        displayEmpty = false,
        IconComponent = ArrowDropDownIcon,
        id: id2,
        input,
        inputProps,
        label,
        labelId,
        MenuProps,
        multiple = false,
        native = false,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps,
        variant: variantProp = "outlined"
      } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
      const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
      const muiFormControl = useFormControl();
      const fcs = formControlState({
        props,
        muiFormControl,
        states: ["variant", "error"]
      });
      const variant = fcs.variant || variantProp;
      const ownerState = _extends$1({}, props, {
        variant,
        classes: classesProp
      });
      const classes2 = useUtilityClasses(ownerState);
      const restOfClasses = _objectWithoutPropertiesLoose(classes2, _excluded2);
      const InputComponent = input || {
        standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
          ownerState
        }),
        outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
          label,
          ownerState
        }),
        filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
          ownerState
        })
      }[variant];
      const inputComponentRef = useForkRef(ref, InputComponent.ref);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
        children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$1({
          // Most of the logic is implemented in `SelectInput`.
          // The `Select` component is a simple API wrapper to expose something better to play with.
          inputComponent,
          inputProps: _extends$1({
            children,
            error: fcs.error,
            IconComponent,
            variant,
            type: void 0,
            // We render a select. We can ignore the type provided by the `Input`.
            multiple
          }, native ? {
            id: id2
          } : {
            autoWidth,
            defaultOpen,
            displayEmpty,
            labelId,
            MenuProps,
            onClose,
            onOpen,
            open,
            renderValue,
            SelectDisplayProps: _extends$1({
              id: id2
            }, SelectDisplayProps)
          }, inputProps, {
            classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses
          }, input ? input.props.inputProps : {})
        }, multiple && native && variant === "outlined" ? {
          notched: true
        } : {}, {
          ref: inputComponentRef,
          className: clsx(InputComponent.props.className, className, classes2.root)
        }, !input && {
          variant
        }, other))
      });
    });
    Select.muiName = "Select";
    const Select$1 = Select;
    function Header$2() {
      const [isBurgerMenuOpen, setBurgerMenuOpen] = reactExports.useState(false);
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      reactExports.useEffect(() => {
        if (isBurgerMenuOpen && isMobile) {
          document.body.style.overflow = "hidden";
        } else {
          document.body.style.overflow = "unset";
        }
      }, [isBurgerMenuOpen, isMobile]);
      const handleToggleBurgerMenu = () => {
        setBurgerMenuOpen(!isBurgerMenuOpen);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header$3, { children: [
        isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
          BurgerBtn,
          {
            isOpen: false,
            onClick: handleToggleBurgerMenu
          }
        ),
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { to: "/news", children: /* @__PURE__ */ jsxRuntimeExports.jsx(MainLogo, {}) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Nav$1, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileBlock, {}),
        isBurgerMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(BurgerMenu, { onClose: handleToggleBurgerMenu })
      ] });
    }
    const Container$E = st$1(FlexContainer)`
  align-items: center;
  margin-bottom: 20px;
`;
    st$1.div`
  padding: 3px 15px;
  margin-right: 20px;
  font-weight: 700;
  font-size: 24.923px;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realWhite};
  background-color: ${(props) => props.theme.colors.mainBlue};
  border-radius: 18px;
`;
    st$1(Text$6)`
  font-weight: 24.923px;
`;
    const ModalInitialState = {
      isModalOpen: false,
      modalType: ""
    };
    const modalSlice = createSlice({
      name: "modal",
      initialState: ModalInitialState,
      reducers: {
        setModalOpen: (state, { payload }) => {
          state.isModalOpen = payload;
          payload ? document.body.style.overflow = "hidden" : document.body.style.overflow = "unset";
        },
        setModalType: (state, { payload }) => {
          state.modalType = payload;
        }
      }
    });
    const { actions: actions$6, reducer: reducer$7 } = modalSlice;
    const AuthInitialState = {
      token: null
    };
    const authSlice = createSlice({
      name: "auth",
      initialState: AuthInitialState,
      reducers: {
        setAuthToken: (state, { payload }) => {
          state.token = payload;
        }
      }
    });
    const { actions: actions$5, reducer: reducer$6 } = authSlice;
    const courseInitialState = {
      data: {
        id: 0,
        title: "",
        description: "",
        is_open: 0,
        status: 0,
        user_id: 0,
        date: "",
        is_deleted: 0,
        chapters: [],
        image: null
      },
      activeChapterId: null,
      activeTheme: null,
      activeLesson: null,
      updatingChapterData: null,
      updatingThemeData: null
    };
    const courseSlice = createSlice({
      name: "course",
      initialState: courseInitialState,
      reducers: {
        setCourseData: (state, { payload }) => {
          return {
            ...state,
            ...{ data: payload || courseInitialState.data }
          };
        },
        changeCourseData: (state, { payload }) => {
          state.data = { ...state.data, ...payload };
        },
        setActiveChapterId: (state, { payload }) => {
          state.activeChapterId = payload;
        },
        addChapter: (state, { payload }) => {
          var _a;
          (_a = state.data.chapters) == null ? void 0 : _a.push(payload);
        },
        changeChapter: (state, { payload }) => {
          var _a, _b;
          if (!state.data || !state.data.chapters) {
            console.warn(`No chapters in course`);
            return;
          }
          const currentChapterIndex = (_b = (_a = state.data) == null ? void 0 : _a.chapters) == null ? void 0 : _b.findIndex(
            (chapter) => chapter.id === Number(payload.id)
          );
          if (currentChapterIndex === -1) {
            console.error(`No chapter with id: ${payload.id}`);
            return;
          }
          state.data.chapters[currentChapterIndex] = {
            ...state.data.chapters[currentChapterIndex],
            ...payload
          };
        },
        setActiveTheme: (state, { payload }) => {
          state.activeTheme = { ...payload };
        },
        setActiveLesson: (state, { payload }) => {
          state.activeLesson = { ...payload };
        },
        setUpdatingChapterData: (state, { payload }) => {
          state.updatingChapterData = { ...payload };
        },
        setUpdatingThemeData: (state, { payload }) => {
          state.updatingThemeData = { ...payload };
        }
      }
    });
    const { actions: actions$4, reducer: reducer$5 } = courseSlice;
    const loaderInitialState = {
      active: false
    };
    const loaderSlice = createSlice({
      name: "loader",
      initialState: loaderInitialState,
      reducers: {
        setLoaderActive(state, { payload }) {
          state.active = payload;
        }
      }
    });
    const { reducer: reducer$4, actions: actions$3 } = loaderSlice;
    class EmptyAnswer {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "answer");
        __publicField(this, "right_answer");
        __publicField(this, "text");
        this.id = nanoid();
        this.answer = "";
        this.right_answer = false;
        this.text = "";
      }
    }
    class EmptyTest {
      constructor() {
        __publicField(this, "id");
        __publicField(this, "question");
        __publicField(this, "answers");
        this.id = nanoid();
        this.question = "";
        this.answers = [
          {
            id: nanoid(),
            answer: "",
            right_answer: false,
            text: ""
          },
          {
            id: nanoid(),
            answer: "",
            right_answer: true,
            text: ""
          }
        ];
      }
    }
    const lessonInitialState = {
      tests: [],
      navPopup: false
    };
    const lessonSlice = createSlice({
      name: "lesson",
      initialState: lessonInitialState,
      reducers: {
        addEmptyTest: (state) => {
          let tests = state.tests;
          tests = [...tests, new EmptyTest()];
          return {
            ...state,
            tests
          };
        },
        deleteTest: (state, { payload }) => {
          const updatedTests = state.tests.filter((test) => test.id !== payload);
          return {
            ...state,
            tests: updatedTests
          };
        },
        addAnswer: (state, { payload }) => {
          const { tests } = state;
          const testIndex = tests.findIndex((test) => test.id === payload.id);
          if (testIndex === -1)
            return state;
          const newTests = [...tests];
          newTests[testIndex] = {
            ...newTests[testIndex],
            answers: [...newTests[testIndex].answers, new EmptyAnswer()]
          };
          return {
            ...state,
            tests: newTests
          };
        },
        deleteAnswer: (state, { payload }) => {
          const { testId, answerId } = payload;
          const testIndex = state.tests.findIndex((test) => test.id === testId);
          if (testIndex === -1) {
            return state;
          }
          const filteredAnswers = state.tests[testIndex].answers.filter(
            (answer) => answer.id !== answerId
          );
          const modifyTests = state.tests.map((test) => {
            if (test.id === testId) {
              test.answers = filteredAnswers;
            }
            return test;
          });
          state.tests = modifyTests;
        },
        setTestsData: (state, { payload }) => {
          state.tests = [...payload];
        },
        resetTestsData: (state) => {
          state.tests = [];
        },
        changeTestQuestion: (state, { payload }) => {
          const testIndex = state.tests.findIndex((test) => test.id === payload.id);
          if (testIndex === -1) {
            return state;
          }
          const modifyTests = state.tests.map((test) => {
            if (test.id === payload.id) {
              test.question = payload.question;
            }
            return test;
          });
          state.tests = modifyTests;
        },
        toggleAnswer: (state, { payload }) => {
          const testIndex = state.tests.findIndex(
            (test) => test.id === payload.testId
          );
          if (testIndex === -1)
            return;
          const changedAnswers = state.tests[testIndex].answers.map((answer) => {
            if (payload.isRight) {
              if (answer.id === payload.answerId && payload.isRight) {
                answer.right_answer = payload.isRight;
              } else {
                answer.right_answer = false;
              }
            } else {
              answer.right_answer = payload.isRight;
            }
            return answer;
          });
          const modifyTests = state.tests.map((test) => {
            if (test.id === payload.testId) {
              test.answers = changedAnswers;
            }
            return test;
          });
          state.tests = modifyTests;
        },
        changeAnswer: (state, { payload }) => {
          const testIndex = state.tests.findIndex(
            (test) => test.id === payload.testId
          );
          if (testIndex === -1)
            return;
          const changedAnswers = state.tests[testIndex].answers.map((answer) => {
            if (payload.answerId === answer.id) {
              answer.answer = payload.value;
            }
            return answer;
          });
          const modifyTests = state.tests.map((test) => {
            if (test.id === payload.testId) {
              test.answers = changedAnswers;
            }
            return test;
          });
          state.tests = modifyTests;
        },
        changeAnswerComment: (state, { payload }) => {
          const testIndex = state.tests.findIndex(
            (test) => test.id === payload.testId
          );
          if (testIndex === -1)
            return;
          const changedAnswers = state.tests[testIndex].answers.map((answer) => {
            if (payload.answerId === answer.id) {
              answer.text = payload.value;
            }
            return answer;
          });
          const modifyTests = state.tests.map((test) => {
            if (test.id === payload.testId) {
              test.answers = changedAnswers;
            }
            return test;
          });
          state.tests = modifyTests;
        },
        setNavPopup: (state, { payload }) => {
          state.navPopup = payload;
        }
      }
    });
    const { reducer: reducer$3, actions: actions$2 } = lessonSlice;
    const competitionInitialState = {
      updatingCompetitionData: null
    };
    const competitionSlice = createSlice({
      name: "competition",
      initialState: competitionInitialState,
      reducers: {
        setUpdatingCompetitionData: (state, { payload }) => {
          state.updatingCompetitionData = payload ? { ...payload } : null;
        }
      }
    });
    const { actions: actions$1, reducer: reducer$2 } = competitionSlice;
    const initialState = {
      newsCategories: []
    };
    const newsSlice = createSlice({
      name: "news",
      initialState,
      reducers: {
        setNewsCategories: (state, { payload }) => {
          state.newsCategories = payload;
        },
        addNewsCategory: (state, { payload }) => {
          state.newsCategories.push(payload);
        },
        deleteNewsCategory: (state, { payload }) => {
          const index = state.newsCategories.findIndex(
            (category) => category.id === payload.id || category.title === payload.title
          );
          if (index !== -1) {
            state.newsCategories.splice(index, 1);
          }
        }
      }
    });
    const { actions, reducer: reducer$1 } = newsSlice;
    const rootActions = {
      ...actions$5,
      ...actions$6,
      ...actions$4,
      ...actions$3,
      ...actions$2,
      ...actions$1,
      ...actions
    };
    const useActions = () => {
      const dispatch = useDispatch();
      return reactExports.useMemo(() => bindActionCreators(rootActions, dispatch), [dispatch]);
    };
    const editIcon$2 = "/assets/editIcon.svg";
    const addIcon$2 = "/assets/addIcon.svg";
    const AdminBtn$1 = st$1.button`
  position: relative;
  width: 24px;
  height: 24px;
  background-color: transparent;
  background-image: url(${(props) => props.$type === ADMIN_BTN_TYPES.edit ? editIcon$2 : addIcon$2});
  background-repeat: no-repeat;
  background-size: 100%;
  background-position: center;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
    width: 7.5vw;
    height: 7.5vw;
  }
`;
    const isHideIcon = "/assets/hideIcon.svg";
    const addIcon$1 = "/assets/addIconBlack.svg";
    const editIcon$1 = "/assets/editIconRed.svg";
    const deleteIcon$1 = "/assets/deleteIcon.svg";
    const visibleIcon = "/assets/visibleIcon.svg";
    const Overlay$3 = st$1(DarkOverlay)`
    z-index: ${(props) => props.theme.utils.zIndex.popup};
  @media ${(props) => props.theme.media.desktop} {
    background-color: transparent;
    position: absolute;
    top: 100%;
    right: 0;
    left: unset;
    width: 320px;
    filter: drop-shadow(0px 0px 9px rgba(0, 0, 0, 0.25));
  }
`;
    const Container$D = st$1(FlexContainer)`
  flex-direction: column;
  width: 100%;
  padding: 15px 10px 10px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.greyF1};
  @media ${(props) => props.theme.media.mobile} {
    padding: 3.125vw;
    border-radius: 0px 0px 15px 15px;
  }
`;
    const Title$f = st$1(Text$6)`
  margin-bottom: 15px;
  text-align: center;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 4.6875vw;
  }
`;
    const Btn = st$1.div`
  ${TextStyles}
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 60px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
  transition: ${(props) => props.theme.utils.transition};
  @media ${(props) => props.theme.media.mobile} {
    min-height: 18.75vw;
  }

  &:not(:last-child) {
    margin-bottom: 5px;
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 1.5625vw;
    }
  }

  &:hover {
    background-color: ${(props) => props.theme.colors.greyF1};
  }
`;
    const HideBtn = st$1(Btn)``;
    const VisibleBtn = st$1(Btn)``;
    const AddBtn = st$1(Btn)``;
    const EditBtn = st$1(Btn)``;
    const DeleteBtn$3 = st$1(Btn)`
  color: ${(props) => props.theme.colors.yRed};
`;
    const RestoreBtn = st$1(Btn)``;
    const BtnIcon = st$1(Icon$2)`
  margin-right: 15px;
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 3.125vw;
  }
`;
    const HideIcon = st$1(BtnIcon)`
  background-image: url(${isHideIcon});
`;
    const AddIcon$1 = st$1(BtnIcon)`
  background-image: url(${addIcon$1});
`;
    const EditIcon$1 = st$1(BtnIcon)`
  background-image: url(${editIcon$1});
`;
    const DeleteIcon$1 = st$1(BtnIcon)`
  background-image: url(${deleteIcon$1});
`;
    const VisibleIcon = st$1(BtnIcon)`
  background-image: url(${visibleIcon});
`;
    function ControlsPopup({
      innerRef,
      name,
      onHide,
      onAdd,
      onDelete,
      onEdit,
      onRestore,
      onVisible
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay$3, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$D, { ref: innerRef, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$f, { children: name }),
        onHide && /* @__PURE__ */ jsxRuntimeExports.jsxs(HideBtn, { onClick: onHide, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(HideIcon, {}),
          ""
        ] }),
        onVisible && /* @__PURE__ */ jsxRuntimeExports.jsxs(VisibleBtn, { onClick: onVisible, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(VisibleIcon, {}),
          ""
        ] }),
        onAdd && /* @__PURE__ */ jsxRuntimeExports.jsxs(AddBtn, { onClick: onAdd, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {}),
          ""
        ] }),
        onEdit && /* @__PURE__ */ jsxRuntimeExports.jsxs(EditBtn, { onClick: onEdit, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon$1, {}),
          ""
        ] }),
        onDelete && /* @__PURE__ */ jsxRuntimeExports.jsxs(DeleteBtn$3, { onClick: onDelete, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon$1, {}),
          ""
        ] }),
        onRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreBtn, { onClick: onRestore, children: "" })
      ] }) });
    }
    const body = document.body;
    function AdminBtn({ type, onClick: onClick2, popupName, popupHandlers, styles: styles2 = {} }) {
      const [isPopup, setPopup] = reactExports.useState();
      const user = useTypedSelector((state) => selectUser(state).data);
      const ref = reactExports.useRef(null);
      const popupInnerRef = reactExports.useRef(null);
      const [isAdmin, setAdmin] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if (user && user.user.role === USER_ROLES.admin) {
          setAdmin(true);
        }
      }, [user]);
      const handleOverlayClick = (event) => {
        if (!popupInnerRef.current)
          return;
        if (event.target !== popupInnerRef.current && event.target !== ref.current) {
          setPopup(false);
          body.removeEventListener("click", handleOverlayClick);
        }
      };
      const handleClick = (event) => {
        event.stopPropagation();
        if (onClick2) {
          onClick2(event);
        }
        if (type === ADMIN_BTN_TYPES.edit) {
          if (isPopup) {
            setPopup(false);
          } else {
            setPopup(true);
            body.addEventListener("click", handleOverlayClick);
          }
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isAdmin && /* @__PURE__ */ jsxRuntimeExports.jsx(
        AdminBtn$1,
        {
          style: styles2,
          ref,
          $type: type,
          onClick: handleClick,
          children: isPopup && /* @__PURE__ */ jsxRuntimeExports.jsx(
            ControlsPopup,
            {
              innerRef: popupInnerRef,
              name: popupName,
              ...popupHandlers
            }
          )
        }
      ) });
    }
    const courseApi = api.injectEndpoints({
      endpoints: (builder) => ({
        getCourses: builder.query({
          query: () => "course",
          providesTags: () => [
            {
              type: "Courses"
            }
          ]
        }),
        getCourseById: builder.query({
          query: (id2) => `course/${id2}`,
          providesTags: () => [
            {
              type: "CourseById"
            }
          ]
        }),
        createCourse: builder.mutation({
          query: (data) => ({
            url: "course/create",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [
            {
              type: "Courses"
            }
          ]
        }),
        updateCourse: builder.mutation({
          query: (data) => ({
            url: "course/update",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["Courses"]
        }),
        deleteCourse: builder.mutation({
          query: (data) => ({
            url: "course/delete",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["Courses"]
        }),
        restoreCourse: builder.mutation({
          query: (data) => ({
            url: "course/restore",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["Courses"]
        }),
        getCourseProgress: builder.query({
          query: (data) => ({
            url: "course/get-users-progress",
            method: "POST",
            body: data
          }),
          providesTags: () => [
            {
              type: "CourseProgress"
            }
          ]
        })
      }),
      overrideExisting: false
    });
    const {
      useCreateCourseMutation,
      useDeleteCourseMutation,
      useGetCoursesQuery,
      useGetCourseByIdQuery,
      useRestoreCourseMutation,
      useUpdateCourseMutation,
      useGetCourseProgressQuery
    } = courseApi;
    const selectCourses = courseApi.endpoints.getCourses.select();
    const SelectIcon$1 = st$1(Icon$2)`
  top: 25% !important;
  width: 33px;
  height: 33px;
  background-image: url(${selectIcon});
`;
    const ProgressContainer$1 = st$1.h4`
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 90px;
  height: 36px;
  border-radius: 18px;
  background-color: ${(props) => props.$isStart ? props.theme.colors.mainBlue : props.theme.colors.dark};
  margin-right: 20px;

  color: #fff;
  font-family: "Montserrat";
  font-size: 24.923px;
  font-weight: 700;
  line-height: 120%;
`;
    function ProgressCounter({ percentage = 0 }) {
      const isStart = percentage > 0;
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ProgressContainer$1, { $isStart: isStart, children: [
        percentage,
        "%"
      ] });
    }
    const CustomSelectOption$1 = st$1.label`
  display: flex;
  align-items: center;
  border: 0;
  padding-bottom: 5px;
  cursor: pointer;
  @media ${(props) => props.theme.media.mobile} {
    padding-bottom: 0;
  }
  &*:first-child {
    padding: 0;
  }
  &*:focus {
    background-color: transparent;
  }
`;
    const TextLabel = st$1.p`
  margin-right: 30px;
  color: #000;
  font-family: 'Montserrat';
  font-size: 24.923px;
  font-weight: ${(props) => props.$isSelected ? 700 : 500};
  line-height: 120%;
  &:first-child {
    font-weight: 700;
    @media ${(props) => props.theme.media.mobile} {
      font-weight: 500;
    }
  }
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 2%;
    font-size: 4.6875vw;
    font-weight: 500;
  }
`;
    const IsHiddenIcon$1 = st$1(Icon$2)`
  margin-left: auto;
  margin-right: 20px;
  background-image: url(${isHideIcon});
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 0;
  }
`;
    function CustomSelectOption({
      percentage,
      status,
      title,
      isSelected,
      isDeleted
    }) {
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(CustomSelectOption$1, { children: [
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressCounter, { percentage: percentage || 0 }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          TextLabel,
          {
            $isSelected: isSelected,
            $isDeleted: isDeleted,
            children: [
              ": ",
              title
            ]
          }
        ),
        status === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IsHiddenIcon$1, {})
      ] });
    }
    const styles = "";
    function CourseCustomSelect({ options, value, onChange }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Select$1,
        {
          value,
          onChange,
          IconComponent: SelectIcon$1,
          sx: {
            minWidth: "50%",
            marginRight: "auto",
            border: 0,
            "& fieldset": { border: "none" }
          },
          children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            MenuItem$1,
            {
              value: option.value,
              sx: {
                "&.Mui-selected": {
                  backgroundColor: "#f1f1f1 !important"
                },
                "&.Mui-selected:hover": {
                  backgroundColor: "#e0e0e0"
                },
                padding: "10px 25px"
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                CustomSelectOption,
                {
                  title: `${option.data.title}`,
                  percentage: option.data.percentage,
                  status: option.data.status,
                  isSelected: option.value === value,
                  isDeleted: option.data.isDeleted
                },
                option.value
              )
            },
            option.value
          ))
        }
      );
    }
    let init = true;
    function CourseSelect() {
      const coursesData = useTypedSelector((state) => {
        var _a;
        return (_a = selectCourses(state).data) == null ? void 0 : _a.data;
      });
      const { setModalOpen, setModalType, setCourseData, setLoaderActive } = useActions();
      const [updateCourse] = useUpdateCourseMutation();
      const [deleteCourse] = useDeleteCourseMutation();
      const [restoreCourse] = useRestoreCourseMutation();
      const courseData = useTypedSelector((state) => state.course.data);
      const [selectedValue, setSelectedValue] = reactExports.useState("");
      const navigate = useNavigate();
      const selectOptions = reactExports.useMemo(() => {
        if (!coursesData) {
          return [];
        }
        const options = coursesData.map((course) => {
          var _a;
          return {
            value: `${course.id}`,
            label: course.title,
            data: {
              status: Number(course.status),
              title: course.title,
              percentage: ((_a = course.percentage) == null ? void 0 : _a.percentage) || 0,
              isDeleted: !!course.is_deleted
            }
          };
        });
        return options;
      }, [coursesData]);
      reactExports.useEffect(() => {
        if (selectOptions.length > 0 && init) {
          init = false;
          setSelectedValue(selectOptions[0].value);
        } else if (selectOptions.length > 0) {
          const selectedCourseData = selectOptions.find(
            (option) => Number(option.value) === Number(courseData.id)
          );
          if (!selectedCourseData) {
            return;
          }
          setSelectedValue(selectedCourseData == null ? void 0 : selectedCourseData.value);
        }
      }, [courseData.id, selectOptions]);
      const handleAddCourse = () => {
        setModalType(MODAL_TYPES.createCourse);
        setModalOpen(true);
      };
      const handleEditCourse = () => {
        if (!courseData.id) {
          console.error(`No course with id: ${courseData.id}!`);
          return;
        }
        setModalType(MODAL_TYPES.editCourse);
        setModalOpen(true);
      };
      const handleToggleCourseStatus = () => {
        if (!courseData.id) {
          console.error(`No course with id: ${courseData.id}!`);
          return;
        }
        updateCourse({
          id: courseData.id,
          status: Number(courseData.status) === 0 ? 1 : 0,
          image: courseData.image
        }).then((res) => {
          if ("data" in res) {
            setCourseData(res.data.data);
          }
        });
        setLoaderActive(true);
      };
      const handleDeleteCourse = () => {
        deleteCourse({
          id: Number(courseData.id)
        }).then((res) => {
          if ("result" in res && !res.result) {
            alert("-   ...");
            console.error(`Course with id: ${courseData.id} not found!`);
          }
        });
        setLoaderActive(true);
      };
      const handleRestoreCourse = () => {
        restoreCourse({
          id: Number(courseData.id)
        }).then((res) => {
          if ("result" in res && !res.result) {
            alert("-   ...");
            console.error(`Course with id: ${courseData.id} not found!`);
          }
        });
        setLoaderActive(true);
      };
      const handleChange = (event) => {
        const selectedCourseId = event.target.value;
        setSelectedValue(`${selectedCourseId}`);
        navigate(`/courses/${selectedCourseId}`);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$E, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CourseCustomSelect,
          {
            options: selectOptions,
            value: selectedValue,
            onChange: handleChange
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdminBtn,
          {
            popupName: "",
            type: ADMIN_BTN_TYPES.edit,
            onClick: () => {
            },
            popupHandlers: {
              onAdd: handleAddCourse,
              onEdit: handleEditCourse,
              onHide: Number(courseData.status) === 1 ? handleToggleCourseStatus : void 0,
              onVisible: Number(courseData.status) === 0 ? handleToggleCourseStatus : void 0,
              onDelete: courseData.is_deleted ? void 0 : handleDeleteCourse,
              onRestore: courseData.is_deleted ? handleRestoreCourse : void 0
            }
          }
        )
      ] });
    }
    const Container$C = st$1(FlexContainer)`
  flex-direction: column;
  padding: 60px 0 150px 0;
  @media ${(props) => props.theme.media.mobile} {
    padding: 2% 0 15%;
  }
`;
    const Container$B = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  margin-bottom: 66px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 7.8125vw;
  }
`;
    const Wrapper$2 = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
  width: 49.7%;
  height: 400px;
  padding: 20px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    height: auto;
    padding: 0.94vw 4.69vw 4.69vw;
  }
`;
    const ImgWrapper = st$1(Wrapper$2)`
  padding: 0;
  overflow: hidden;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const Preview = st$1.img`
  width: 100%;
  height: 100%;
  object-fit: cover;
`;
    st$1.p`
  display: flex;
  align-items: center;
  height: fit-content;
  margin-bottom: 33px;
  font-size: 15px;
  font-weight: 500;
  line-height: 130%;
  color: ${(props) => props.theme.colors.realBlack};
`;
    st$1.img`
  display: inline-block;
  width: 24px;
  margin: 0 5px;
`;
    const LessonName = st$1(Text$6)`
  max-width: 95%;
  font-size: 25px;
  line-height: 130%;
  @media ${(props) => props.theme.media.mobile} {
    max-width: 100%;
    margin-bottom: 12.5vw;
    font-size: 4.6875vw;
  }
`;
    const OpenCourse = st$1(DefaultBtn)`
  width: fit-content;
  padding: 0 40px;
  margin-top: auto;
  border-radius: 22px;
  @media ${(props) => props.theme.media.mobile} {
    min-height: 12.5vw;
    padding: 0 7.5vw;
    font-size: 4.6875vw;
    border-radius: 7px;
  }
`;
    const CourseName = st$1(LessonName)`
  margin-bottom: 12px;
`;
    const CompleteStatus = st$1(Text$6)`
  font-size: 22.689px;
  color: ${(props) => props.theme.colors.mainBlue};
`;
    const ErrorName = st$1(LessonName)`
  margin: auto;
`;
    const defaultPreview = "/assets/course-stub-img.webp";
    const arrowRight = "/assets/arrowRight.svg";
    const Container$A = st$1(FlexContainer)`
  align-items: center;
  column-gap: 7px;
  flex-wrap: wrap;
  @media ${(props) => props.theme.media.mobile} {
    flex-direction: column;
    align-items: flex-start;
  }
`;
    const TextStyle = nt$1`
  font-size: 15px;
  font-weight: 500;
  line-height: 130%;
  color: ${(props) => props.theme.colors.realBlack};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 3.75vw;
  }

  &:not(:last-child) {
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 3.125vw;
    }
  }
`;
    const Chapter$1 = st$1.p`
  ${TextStyle}
`;
    const Theme$2 = st$1.p`
  ${TextStyle}
`;
    const Lesson = st$1.p`
  ${TextStyle}
`;
    const Arrow = st$1(Icon$2)`
  background-image: url(${arrowRight});
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    function CourseBreadcrumb({ chapter, theme, lesson, containerStyles }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$A, { style: containerStyles, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Chapter$1, { children: [
          " ",
          chapter.position,
          "/",
          chapter.allQuantity
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Theme$2, { children: [
          " ",
          theme.position,
          "/",
          theme.allQuantity,
          ": ",
          theme.name
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Lesson, { children: [
          " ",
          lesson.position,
          "/",
          lesson.allQuantity
        ] })
      ] });
    }
    const Container$z = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
`;
    const Text$5 = st$1(Text$6)`
  max-width: 268px;
  font-size: 37.778px;
  @media ${(props) => props.theme.media.mobile} {
    max-width: 50%;
    font-size: 6.13vw;
  }
`;
    const Percentage = st$1.h3`
  font-size: 105.387px;
  font-weight: 700;
  line-height: 100%;
  color: ${(props) => props.theme.colors.mainBlue};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 17.09vw;
    line-height: 113%;
  }
`;
    function ProgressInfo({ text, percentage, styles: styles2 = {} }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$z, { style: styles2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text$5, { children: text }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Percentage, { children: [
          percentage,
          "%"
        ] })
      ] });
    }
    const Overlay$2 = st$1.div`
  display: flex;
  align-items: flex-end;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: ${(props) => props.theme.utils.zIndex.darkOverlay};
`;
    const Container$y = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  padding-top: 4.0625vw;
  background-color: ${(props) => props.theme.colors.realWhite};
  border-radius: ${(props) => props.theme.utils.br} ${(props) => props.theme.utils.br} 0px 0px;
`;
    const CoursesList = st$1.ul`
  display: flex;
  flex-direction: column;
  padding: 0 4.6875vw;
  margin-bottom: 3.75vw;
`;
    const Course$1 = st$1.li`
  &:not(:last-child) {
    margin-bottom: 6.25vw;
  }
`;
    const AddCourseBtn = st$1.button`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 0 4.6875vw;
  margin: 0;
  margin-bottom: 2%;
  background-color: transparent;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const AddCourseBtnTitle = st$1(Text$6)`
  width: 90%;
  font-size: 4.6875vw;
  font-weight: 600;
  text-align: start;
`;
    const AddCourseBtnIcon = st$1(Icon$2)`
  background-image: url(${addIcon$2});
`;
    const CloseBtnWrapper = st$1.div`
  padding: 3.125vw 4.6875vw;
  border-top: 1px solid ${(props) => props.theme.colors.greyF1};
`;
    const CloseBtn$2 = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: 15.625vw;
  color: ${(props) => props.theme.colors.grey93};
  background-color: ${(props) => props.theme.colors.greyF1};
`;
    function Popup({ coursesData, onClose }) {
      const { setModalOpen, setModalType } = useActions();
      const selectedCourseid = useTypedSelector((state) => state.course.data.id);
      const modalRoot = document.querySelector("#modal-root");
      const navigate = useNavigate();
      if (!modalRoot) {
        return null;
      }
      const handleSelectCourse = (id2) => {
        onClose();
        navigate(`/courses/${id2}`);
      };
      const handleAddCourse = () => {
        onClose();
        setModalOpen(true);
        setModalType(MODAL_TYPES.createCourse);
      };
      return ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay$2, { onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$y, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CoursesList, { children: coursesData && coursesData.map((course) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            Course$1,
            {
              onClick: () => {
                handleSelectCourse(course.id);
              },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                CustomSelectOption,
                {
                  title: course.title,
                  status: course.status,
                  isDeleted: !!course.is_deleted,
                  isSelected: Number(course.id) === Number(selectedCourseid)
                },
                course.id
              )
            }
          )) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(AddCourseBtn, { onClick: handleAddCourse, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(AddCourseBtnTitle, { children: " " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AddCourseBtnIcon, {})
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CloseBtnWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseBtn$2, { onClick: onClose, children: "" }) })
        ] }) }),
        modalRoot
      );
    }
    const Container$x = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  margin-bottom: 4.6875vw;
`;
    const Wrapper$1 = st$1.div`
  display: flex;
  align-items: center;
  width: 100%;
  max-width: 75%;
`;
    const CourseTitle = st$1(Text$6)`
  /* width: 90%; */
  margin-right: 1.875vw;
  font-size: 4.6875vw;
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};
`;
    const SelectIcon = st$1(Icon$2)`
  background-image: url(${selectIcon});
  @media ${(props) => props.theme.media.mobile} {
    min-width: 7.5vw;
    min-height: 7.5vw;
  }
`;
    const IsHiddenIcon = st$1(Icon$2)`
  margin-left: auto;
  margin-right: 2%;
  background-image: url(${isHideIcon});
`;
    function OpenSelect({ courseData, onOpen }) {
      const { setModalOpen, setModalType, setLoaderActive, setCourseData } = useActions();
      const [updateCourse] = useUpdateCourseMutation();
      const [deleteCourse] = useDeleteCourseMutation();
      const [restoreCourse] = useRestoreCourseMutation();
      const handleAddCourse = () => {
        setModalType(MODAL_TYPES.createCourse);
        setModalOpen(true);
      };
      const handleEditCourse = () => {
        if (!courseData.id) {
          console.error(`No course with id: ${courseData.id}!`);
          return;
        }
        setModalType(MODAL_TYPES.editCourse);
        setModalOpen(true);
      };
      const handleToggleCourseStatus = () => {
        if (!courseData.id) {
          console.error(`No course with id: ${courseData.id}!`);
          return;
        }
        updateCourse({
          id: courseData.id,
          status: Number(courseData.status) === 0 ? 1 : 0
        }).then((res) => {
          if ("data" in res) {
            setCourseData(res.data.data);
          }
        });
        setLoaderActive(true);
      };
      const handleDeleteCourse = () => {
        deleteCourse({
          id: Number(courseData.id)
        }).then((res) => {
          if ("result" in res && !res.result) {
            alert("-   ...");
            console.error(`Course with id: ${courseData.id} not found!`);
          }
        });
        setLoaderActive(true);
      };
      const handleRestoreCourse = () => {
        restoreCourse({
          id: Number(courseData.id)
        }).then((res) => {
          if ("result" in res && !res.result) {
            alert("-   ...");
            console.error(`Course with id: ${courseData.id} not found!`);
          }
        });
        setLoaderActive(true);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$x, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Wrapper$1, { onClick: onOpen, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CourseTitle, { $isDeleted: !!courseData.is_deleted, children: courseData.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {})
        ] }),
        courseData.status === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IsHiddenIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdminBtn,
          {
            popupName: "",
            type: ADMIN_BTN_TYPES.edit,
            popupHandlers: {
              onAdd: handleAddCourse,
              onEdit: handleEditCourse,
              onHide: Number(courseData.status) === 1 ? handleToggleCourseStatus : void 0,
              onVisible: Number(courseData.status) === 0 ? handleToggleCourseStatus : void 0,
              onDelete: courseData.is_deleted ? void 0 : handleDeleteCourse,
              onRestore: courseData.is_deleted ? handleRestoreCourse : void 0
            }
          }
        )
      ] });
    }
    const loadingLogo = "/assets/loadingLogo.svg";
    const Overlay$1 = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 0;
  left: 0;
  z-index: ${(props) => props.theme.utils.zIndex.popup};
  width: 100%;
  height: 100%;
  border-radius: inherit;
  background-color: ${(props) => props.theme.colors.realWhite};
`;
    const Container$w = st$1.div`
  display: flex;
  align-items: center;
  width: fit-content;
`;
    const LoadingIcon = st$1(Icon$2)`
  margin-right: 15px;
  background-image: url(${loadingLogo});
`;
    const LoadingText = st$1(Text$6)`
  font-size: 22px;
`;
    function LoadingSmall() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$w, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingText, { children: "..." })
      ] }) });
    }
    function CourseMainInfo({ coursesData }) {
      var _a;
      const { courseId } = useParams();
      const navigate = useNavigate();
      const courseData = useTypedSelector((state) => state.course.data);
      const [previewSrc, setPreviewSrc] = reactExports.useState("");
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      const [isPopupOpen, setIsPopupOpen] = reactExports.useState(false);
      const { data, isError, isFetching } = useGetCourseProgressQuery(
        { course_id: Number(courseId) },
        {
          skip: !courseId
        }
      );
      reactExports.useEffect(() => {
        if (courseData.image) {
          const src = courseData.image.directory + "/" + courseData.image.name;
          setPreviewSrc(src);
          return;
        }
        setPreviewSrc(defaultPreview);
      }, [courseData.image]);
      const handleLoadError = () => {
        setPreviewSrc(defaultPreview);
      };
      const handleClosePopup = () => {
        setIsPopupOpen(false);
      };
      const handleOpenPopup = () => {
        setIsPopupOpen(true);
      };
      const handleGoToCurrentLesson = () => {
        if (data && "chapter" in data) {
          navigate(`/courses/${courseId}/${data.chapter.id}/${data.theme.id}/${data.lesson.id}`);
        }
      };
      const progressInfoStyles = {
        marginBottom: "3.13vw"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$B, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Wrapper$2, { children: [
          isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSmall, {}),
          isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              ProgressInfo,
              {
                percentage: `${(_a = courseData.percentage) == null ? void 0 : _a.percentage}`,
                text: "   ",
                styles: progressInfoStyles
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              OpenSelect,
              {
                courseData,
                onOpen: handleOpenPopup
              }
            )
          ] }),
          data && "chapter" in data && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CourseBreadcrumb,
              {
                containerStyles: { marginBottom: isMobile ? "5vw" : "30px" },
                chapter: { name: data.chapter.name, position: data.chapter.position, allQuantity: data.chapter.allQuantity },
                theme: { name: data.theme.name, position: data.theme.position, allQuantity: data.theme.allQuantity },
                lesson: { name: data.lesson.name, position: data.lesson.position, allQuantity: data.lesson.allQuantity }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(LessonName, { children: data.lesson.name }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(OpenCourse, { onClick: handleGoToCurrentLesson, children: "" })
          ] }),
          data && "courseComplete" in data && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CourseName, { children: courseData.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CompleteStatus, { children: "" })
          ] }),
          isError || data && "error" in data && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorName, { children: " " })
        ] }),
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(ImgWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Preview,
          {
            src: previewSrc,
            onError: handleLoadError
          }
        ) }),
        isPopupOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Popup,
          {
            coursesData,
            onClose: handleClosePopup
          }
        )
      ] });
    }
    const Container$v = st$1(FlexContainer)`
  flex-direction: column;
`;
    const Head$2 = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0 3.125vw;
    margin-bottom: 4.6875vw;
    font-size: 4.6875vw;
  }
`;
    const Title$e = st$1(Text$6)`
  @media ${(props) => props.theme.media.mobile} {
    margin: 0 auto;
    font-size: 4.6875vw;
  }
`;
    const CardList = st$1.ul`
  display: flex;
  flex-wrap: wrap;
  /* justify-content: space-between; */
  gap: 9px;
  @media ${(props) => props.theme.media.mobile} {
    justify-content: space-between;
    gap: unset;
    row-gap: 1.875vw;
  }
`;
    const Card = st$1(FlexContainer)`
  flex-direction: column;
  width: 310px;
  height: 400px;
  padding: 20px;
  padding-bottom: 15px;
  background-color: ${(props) => props.$isDeleted ? props.theme.colors.grey93 : props.theme.colors.realWhite};
  border-radius: ${(props) => props.theme.utils.br};
  @media ${(props) => props.theme.media.mobile} {
    width: 49%;
    height: auto;
    min-height: 63.125vw;
    padding: 3.125vw 3.125vw 2.1875vw;
    border-radius: 7.597px;
  }
`;
    const imgWrapper = st$1.div`
  width: 100%;
  aspect-ratio: 3/2;
  margin-bottom: 15px;
  overflow: hidden;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.greyEO};
  cursor: pointer;
  transition: transform 0.3s ease-in-out;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 2.5vw;
    border-radius: 7.597px;
  }

  &:hover {
    transform: scale(1.05);
  }
`;
    const Img = st$1.img`
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
`;
    const Title$d = st$1(Text$6)`
  word-break: break-word;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 3.75vw;
  }
`;
    const ProgressContainer = st$1(FlexContainer)`
  flex-direction: column;
  margin-top: auto;
`;
    const ProgressStatusWrapper = st$1(FlexContainer)`
  align-items: center;
  margin-bottom: 10px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 0;
  }
`;
    const ProgressStatus = st$1.p`
  margin-right: auto;
  font-size: 15px;
  font-weight: 500;
  color: ${(props) => props.theme.colors.realBlack};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 2.5vw;
  }
`;
    const defaultCardImg = "/assets/stub-course-program.webp";
    const chapterApi = api.injectEndpoints({
      endpoints: (builder) => ({
        getChapterById: builder.query({
          query: (id2) => `chapter/${id2}`,
          providesTags: () => [
            {
              type: "ChapterById"
            }
          ]
        }),
        createChapter: builder.mutation({
          query: (data) => ({
            url: "course/create-chapter",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [
            {
              type: "Courses"
            }
          ]
        }),
        updateChapter: builder.mutation({
          query: (data) => ({
            url: "course/update-chapter",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["Courses", "ChapterById"]
        }),
        deleteChapter: builder.mutation({
          query: (data) => ({
            url: "course/delete-chapter",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["CourseById", "ChapterById"]
        }),
        restoreChapter: builder.mutation({
          query: (data) => ({
            url: "course/restore-chapter",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["CourseById", "ChapterById"]
        })
      }),
      overrideExisting: false
    });
    const {
      useCreateChapterMutation,
      useDeleteChapterMutation,
      useGetChapterByIdQuery,
      useRestoreChapterMutation,
      useUpdateChapterMutation
    } = chapterApi;
    function CourseProgrammCard({ data }) {
      const navigation = useNavigate();
      const [deleteChapter] = useDeleteChapterMutation();
      const [restoreChapter] = useRestoreChapterMutation();
      const [isTextProgres, setTextProgres] = reactExports.useState("");
      const [isDeleted, setDeleted] = reactExports.useState(false);
      const {
        setLoaderActive,
        setModalOpen,
        setModalType,
        setUpdatingChapterData
      } = useActions();
      const [imgSrc, setImgSrc] = reactExports.useState(null);
      reactExports.useEffect(() => {
        if (data.image) {
          const src = data.image.directory + "/" + data.image.name;
          setImgSrc(src);
        }
      }, [data.image]);
      reactExports.useEffect(() => {
        Number(data.is_deleted) === 0 ? setDeleted(false) : setDeleted(true);
      }, [data.is_deleted]);
      const handleClick = () => {
        navigation(`/courses/${data.course_id}/${data.id}/`);
      };
      reactExports.useEffect(() => {
        changesStatusText();
      }, [data]);
      const handleDeleteChapter = () => {
        deleteChapter({ id: data.id }).then(() => {
          setLoaderActive(false);
          setDeleted(true);
        });
        setLoaderActive(true);
      };
      const handleRestoreChapter = () => {
        restoreChapter({ id: data.id }).then(() => {
          setLoaderActive(false);
          setDeleted(false);
        });
        setLoaderActive(true);
      };
      const handleEditChapter = () => {
        setModalType(MODAL_TYPES.editChapter);
        setUpdatingChapterData(data);
        setModalOpen(true);
      };
      const changesStatusText = () => {
        if (data.percentage.percentage == 100) {
          return setTextProgres("");
        } else if (data.percentage.percentage > 0 && data.percentage.percentage < 100) {
          return setTextProgres(" ");
        } else if (data.percentage.percentage == 0) {
          return setTextProgres("");
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { $isDeleted: isDeleted, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(imgWrapper, { onClick: handleClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Img, { src: imgSrc || defaultCardImg }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$d, { children: data.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ProgressContainer, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ProgressStatusWrapper, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressStatus, { children: isTextProgres }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              AdminBtn,
              {
                popupName: "",
                type: ADMIN_BTN_TYPES.edit,
                onClick: () => {
                },
                popupHandlers: {
                  onDelete: isDeleted ? void 0 : handleDeleteChapter,
                  onRestore: isDeleted ? handleRestoreChapter : void 0,
                  onEdit: handleEditChapter
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressBar$1, { $progress: (data == null ? void 0 : data.percentage.percentage) || 0 })
        ] })
      ] });
    }
    function CourseProgramm() {
      const { setModalOpen, setModalType } = useActions();
      const courseChapters = useTypedSelector((state) => {
        var _a;
        return (_a = state.course.data) == null ? void 0 : _a.chapters;
      });
      const role = useTypedSelector((state) => {
        var _a;
        return (_a = selectUser(state).data) == null ? void 0 : _a.user.role;
      });
      const [chaptersData, setChaptersData] = reactExports.useState();
      reactExports.useEffect(() => {
        if (courseChapters && courseChapters) {
          setChaptersData(courseChapters);
        } else {
          setChaptersData([]);
        }
      }, [courseChapters]);
      const openCreateChapterModal = () => {
        setModalType(MODAL_TYPES.createChapter);
        setModalOpen(true);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$v, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Head$2, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Title$e, { as: "h4", children: " " }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AdminBtn,
            {
              popupName: "",
              type: ADMIN_BTN_TYPES.add,
              onClick: openCreateChapterModal
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardList, { children: chaptersData && chaptersData.length > 0 && chaptersData.map((chapter) => {
          if (!chapter.is_deleted || role === USER_ROLES.admin) {
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              CourseProgrammCard,
              {
                data: chapter
              },
              chapter.id
            );
          }
        }) })
      ] });
    }
    const Container$u = st$1(FlexContainer)`
  align-items: center;
  justify-content: center;
  height: 188px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
`;
    const Text$4 = st$1(Text$6)`
  font-size: 22.714px;
`;
    function ErrorBlock() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$u, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$4, { children: "-   " }) });
    }
    const NoAvailableCourses = st$1(FlexContainer)`
  align-items: center;
  justify-content: center;
  min-height: 200px;
  background-color: ${(props) => props.theme.colors.realWhite};
  border-radius: ${(props) => props.theme.utils.br};
  @media ${(props) => props.theme.media.mobile} {
    min-height: unset;
    height: 43.75vw;
  }
`;
    const NoAvailableCoursesText = st$1(Text$6)`
  margin-right: 10px;
  font-size: 22px;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    margin: 0;
    text-align: center;

    font-size: 6.08vw;
  }
`;
    function NoAvailable({ text, onAdd = () => {
    }, style: style2 = {} }) {
      const user = useTypedSelector((state) => {
        var _a;
        return (_a = selectUser(state).data) == null ? void 0 : _a.user;
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(NoAvailableCourses, { style: style2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NoAvailableCoursesText, { children: text }),
        (user == null ? void 0 : user.role) === "admin" && /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdminBtn,
          {
            popupName: "",
            onClick: onAdd,
            type: "add"
          }
        )
      ] });
    }
    function CoursePreview() {
      const { data, isError, isFetching } = useGetCoursesQuery();
      const { setCourseData, setLoaderActive, setModalOpen, setModalType } = useActions();
      const params = useParams();
      const navigate = useNavigate();
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      reactExports.useEffect(() => {
        setLoaderActive(isFetching);
      }, [isFetching, setLoaderActive]);
      reactExports.useEffect(() => {
        if (data) {
          const currentCourseId = params.courseId || null;
          const currentCourse = data.data.find((course) => course.id === Number(currentCourseId));
          if (data.data.length > 0 && !currentCourseId || data.data.length > 0 && !currentCourse) {
            navigate(`/courses/${data.data[0].id}`);
            return;
          }
          if (data.data.length === 0) {
            navigate("/courses");
          }
          if (currentCourse) {
            setCourseData(currentCourse);
          }
        }
      }, [data, navigate, params.courseId, setCourseData]);
      const handleCreateCourse = () => {
        setModalOpen(true);
        setModalType("createCourse");
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$C, { children: [
        isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
        data && data.data.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(CourseSelect, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CourseMainInfo, { coursesData: data.data }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CourseProgramm, {})
        ] }),
        data && data.data.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(NoAvailable, { text: "  ", onAdd: handleCreateCourse })
      ] }) });
    }
    const Container$t = st$1.div`
  display: flex;
  align-items: center;
  width: 100%;
  margin-bottom: 30px;
  cursor: pointer;
  opacity: ${(props) => props.$isDeleted ? 0.5 : 1};
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};
  transition: opacity 0.2s ease-in-out;

  &:hover {
    opacity: 1;
  }
`;
    const lessonApi = api.injectEndpoints({
      endpoints: (builder) => ({
        getLessonById: builder.query({
          query: (id2) => `lesson/${id2}`,
          providesTags: () => [
            {
              type: "LessonById"
            }
          ]
        }),
        createLesson: builder.mutation({
          query: (data) => ({
            url: "course/create-lesson",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [
            {
              type: "ChapterById"
            }
          ]
        }),
        updateLesson: builder.mutation({
          query: (data) => ({
            url: "course/update-lesson",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["LessonById", "ChapterById"]
        }),
        deleteLesson: builder.mutation({
          query: (data) => ({
            url: "course/delete-lesson",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["LessonById", "ChapterById"]
        }),
        restoreLesson: builder.mutation({
          query: (data) => ({
            url: "course/restore-lesson",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["LessonById", "ChapterById"]
        }),
        checkLesson: builder.mutation({
          query: (data) => ({
            url: "course/check-lesson",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => ["ChapterById", "LessonById", "Courses"]
        })
      }),
      overrideExisting: false
    });
    const {
      useCheckLessonMutation,
      useCreateLessonMutation,
      useDeleteLessonMutation,
      useGetLessonByIdQuery,
      useRestoreLessonMutation,
      useUpdateLessonMutation
    } = lessonApi;
    const Title$c = st$1.p`
  font-size: 15px;
  font-weight: 500;
  line-height: 170%;
  color: ${(props) => props.$active ? props.theme.colors.dark : props.theme.colors.grey93};
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 3.75vw;
  }
`;
    function CourseNavItemTitle({
      text = "",
      children,
      onClick: onClick2 = () => {
      },
      styles: styles2 = {},
      isActive = true,
      isDeleted = false
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Title$c,
        {
          style: styles2,
          onClick: onClick2,
          $active: isActive,
          $isDeleted: isDeleted,
          children: [
            text,
            children
          ]
        }
      );
    }
    function CourseNavLesson({ data }) {
      const [isInit, setInit] = reactExports.useState(true);
      const { setActiveLesson, setLoaderActive } = useActions();
      const navigate = useNavigate();
      const { lessonId, chapterId, courseId } = useParams();
      const [deleteLesson] = useDeleteLessonMutation();
      const [restoreLesson] = useRestoreLessonMutation();
      const handleClick = () => {
        setActiveLesson(data);
        const lessonPath = generatePath(`/courses/:courseId/:chapterId/:themeId/:lessonId`, {
          courseId: String(courseId),
          chapterId: String(chapterId),
          themeId: String(data.theme_id),
          lessonId: String(data.id)
        });
        navigate(lessonPath);
      };
      reactExports.useEffect(() => {
        if (isInit && lessonId) {
          if (data.id === Number(lessonId)) {
            setActiveLesson(data);
          }
          setInit(false);
        }
      }, [data, isInit, lessonId, setActiveLesson]);
      const handleEditLesson = () => {
        navigate(
          generatePath(`/courses/:courseId/:chapterId/:themeId/:lessonId/edit-lesson`, {
            courseId: String(courseId),
            chapterId: String(chapterId),
            themeId: String(data.theme_id),
            lessonId: String(data.id)
          })
        );
      };
      const handleDeleteLesson = () => {
        deleteLesson({
          id: Number(data.id)
        });
        setLoaderActive(true);
      };
      const handleRestoreLesson = () => {
        restoreLesson({
          id: Number(data.id)
        });
        setLoaderActive(true);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$t, { $isDeleted: !!data.is_deleted, onClick: handleClick, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CourseNavItemTitle, { text: data.title, isActive: !data.isChecked }),
        data.isChecked && /* @__PURE__ */ jsxRuntimeExports.jsx(DoneIcon$2, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdminBtn,
          {
            popupName: "",
            styles: { marginLeft: "auto" },
            type: "edit",
            onClick: () => {
            },
            popupHandlers: {
              onEdit: handleEditLesson,
              onDelete: data.is_deleted ? void 0 : handleDeleteLesson,
              onRestore: data.is_deleted ? handleRestoreLesson : void 0
            }
          }
        )
      ] });
    }
    const dndIcon = "/assets/dnd-btn.svg";
    const DndBtn$1 = st$1.button`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  padding: 5px;
  background-color: transparent;
  cursor: grab;
  background-image: url(${dndIcon});
  background-repeat: no-repeat;
  background-size: 100%;
  background-position: center;
`;
    function DndBtn({ onClick: onClick2, styles: styles2 = {} }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DndBtn$1,
        {
          style: styles2,
          onClick: onClick2
        }
      );
    }
    const Container$s = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
  opacity: ${(props) => props.$isDeleted ? 0.5 : 1};
`;
    const Theme$1 = st$1(FlexContainer)`
  align-items: center;
  margin-bottom: 30px;
`;
    const AccSum = st$1(FlexContainer)`
  align-items: center;
`;
    st$1.button`
  display: flex;
  align-items: center;
  width: fit-content;
  padding: 0;
  margin-right: 5px;
  background-color: transparent;
`;
    st$1.div`
  width: 83%;
  height: 0px;
  overflow: hidden;
  margin-left: auto;
  transition: all 0.2s ease-in-out;
  animation: ${(props) => props.$active ? "openAccordion" : "closeAccrodion"} .2s ease-out forwards;

  @keyframes openAccordion {
    99% {
      height: ${(props) => props.$height};
      overflow: hidden;
    }
    100% {
      height: ${(props) => props.$height};
      overflow: visible;
    }
  }

  @keyframes closeAccrodion {
    0% {
      height: ${(props) => props.$height};
      overflow: hidden;
    }
    100% {
      height: 0px;
      overflow: hidden;
    }
  }
`;
    st$1(FlexContainer)`
  flex-direction: column;
  min-height: fit-content;
`;
    const themeApi = api.injectEndpoints({
      endpoints: (builder) => ({
        getThemeById: builder.query({
          query: (id2) => `theme/${id2}`,
          providesTags: () => [
            {
              type: "ThemeById"
            }
          ]
        }),
        createTheme: builder.mutation({
          query: (data) => ({
            url: "course/create-theme",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [
            {
              type: "ChapterById"
            }
          ]
        }),
        updateTheme: builder.mutation({
          query: (data) => ({
            url: "course/update-theme",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => ["ChapterById"]
        }),
        deleteTheme: builder.mutation({
          query: (data) => ({
            url: "course/delete-theme",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => ["ChapterById"]
        }),
        restoreTheme: builder.mutation({
          query: (data) => ({
            url: "course/restore-theme",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => ["ChapterById"]
        })
      }),
      overrideExisting: false
    });
    const {
      useCreateThemeMutation,
      useDeleteThemeMutation,
      useGetThemeByIdQuery,
      useRestoreThemeMutation,
      useUpdateThemeMutation
    } = themeApi;
    function CourseNavTheme({ data, courseId }) {
      const { setActiveTheme, setModalOpen, setModalType, setUpdatingThemeData, setLoaderActive } = useActions();
      const [deleteTheme] = useDeleteThemeMutation();
      const [restoreTheme] = useRestoreThemeMutation();
      const navigate = useNavigate();
      const { themeId } = useParams();
      const isThemeChecked = reactExports.useMemo(() => {
        if (data.lessons && data.lessons.length > 0) {
          const uncheckedLessons = data.lessons.filter((lesson) => lesson.isChecked !== true);
          return uncheckedLessons.length === 0;
        }
        return false;
      }, [data.lessons]);
      const handleChange = (panel) => (event, isExpanded) => {
        setActiveTheme(data);
        const themePath = generatePath(
          `/courses/:courseId/:chapterId/${isExpanded ? ":themeId" : ""}`,
          {
            courseId: String(courseId),
            chapterId: String(data.chapter_id),
            themeId: panel ? String(panel) : ""
          }
        );
        navigate(themePath);
      };
      const handleAddLesson = () => {
        const createLessonPath = generatePath(`/courses/:courseId/:chapterId/:themeId/create-lesson/`, {
          courseId: String(courseId),
          chapterId: String(data.chapter_id),
          themeId: String(data.id)
        });
        navigate(createLessonPath);
      };
      const handleEditTheme = () => {
        setUpdatingThemeData(data);
        setModalType("editTheme");
        setModalOpen(true);
      };
      const handleDeleteTheme = () => {
        deleteTheme({
          id: data.id
        });
        setLoaderActive(true);
      };
      const handleRestoreTheme = () => {
        restoreTheme({
          id: data.id
        });
        setLoaderActive(true);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$s, { $isDeleted: !!data.is_deleted, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Theme$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Accordion$1,
        {
          sx: { width: "100%", boxShadow: "unset" },
          expanded: Number(themeId) === data.id,
          onChange: handleChange(data.id),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              AccordionSummary$1,
              {
                sx: { padding: 0 },
                expandIcon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "none" } }),
                "aria-controls": `${data.id}_content`,
                id: `${data.id}_header`,
                children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AccSum, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    DndBtn,
                    {
                      onClick: () => {
                      },
                      styles: { marginRight: "20px" }
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionIcon, { $active: Number(themeId) === data.id }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    CourseNavItemTitle,
                    {
                      text: data.title,
                      isActive: !isThemeChecked,
                      isDeleted: !!data.is_deleted
                    }
                  ),
                  isThemeChecked && /* @__PURE__ */ jsxRuntimeExports.jsx(DoneIcon$2, {}),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    AdminBtn,
                    {
                      popupName: "",
                      styles: { marginLeft: "auto" },
                      type: "edit",
                      onClick: () => {
                      },
                      popupHandlers: {
                        onAdd: handleAddLesson,
                        onEdit: handleEditTheme,
                        onDelete: data.is_deleted ? void 0 : handleDeleteTheme,
                        onRestore: data.is_deleted ? handleRestoreTheme : void 0
                      }
                    }
                  )
                ] })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionDetails$1, { sx: { paddingLeft: "102px", paddingRight: 0 }, children: data.lessons && data.lessons.map((lesson) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              CourseNavLesson,
              {
                data: lesson
              },
              lesson.id
            )) })
          ]
        }
      ) }) });
    }
    const Container$r = st$1(FlexContainer)`
  flex-direction: column;
`;
    const Title$b = st$1.h4`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 25px;
  font-size: 18px;
  font-weight: 500;
  line-height: 100%;
  color: ${(props) => props.theme.colors.grey93};

  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 3.125vw;
    font-size: 3.75vw;
  }
`;
    function FadedTitle({ text, children, onClick: onClick2 = () => {
    }, styles: styles2 = {} }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Title$b,
        {
          onClick: onClick2,
          style: styles2,
          children: [
            text,
            children
          ]
        }
      );
    }
    function CourseNavBody({ data }) {
      const { setModalType, setModalOpen } = useActions();
      const userRole = useTypedSelector((state) => {
        var _a;
        return (_a = selectUser(state).data) == null ? void 0 : _a.user.role;
      });
      const openCreateThemeModal = () => {
        setModalType(MODAL_TYPES.createTheme);
        setModalOpen(true);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$r, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(FadedTitle, { text: " ", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdminBtn,
          {
            popupName: "",
            type: "add",
            onClick: openCreateThemeModal
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Container$r, { children: data.themes && data.themes.map((theme) => {
          if (Number(theme.is_deleted) === 1 && userRole !== "admin") {
            return;
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            CourseNavTheme,
            {
              data: theme,
              courseId: data.course_id
            },
            theme.id
          );
        }) })
      ] });
    }
    const Container$q = st$1(FlexContainer)`
  height: calc(100vh - 62.25px);
  background-color: ${(props) => props.theme.colors.realWhite};
`;
    const NavContainer = st$1(FlexContainer)`
  flex-direction: column;
  width: 33.25%; 
  padding: 15px 15px 80px;
  border-right: 1px solid ${(props) => props.theme.colors.greyF1};
`;
    const ContentContainer = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
  width: calc(100% - 33.25%);
  max-height: 100vh;
  overflow-y: scroll;
  padding: 20px 35px 80px;
  margin-left: auto;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    padding: 3.125vw 3% 10vw;
    margin: 0;
  }
`;
    const bodyOverflow$1 = at$1`
  body {
    overflow: hidden;
    background-color: ${(props) => props.theme.colors.realWhite};
  }
`;
    const Container$p = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 18px;
  margin-bottom: 40px;
`;
    const TitleWrapper = st$1(FlexContainer)`
  justify-content: space-between;
  align-items: center;
`;
    const Title$a = st$1(Text$6)`
  font-size: 25px;
`;
    const ProgressBar = st$1(ProgressBar$1)`
  height: 10px;
`;
    function CourseNavHead({ data }) {
      const [deleteChapter] = useDeleteChapterMutation();
      const [restoreChapter] = useRestoreChapterMutation();
      const { setLoaderActive, setModalType, setUpdatingChapterData, setModalOpen } = useActions();
      const chapterProgress = reactExports.useMemo(() => {
        var _a;
        if (data) {
          let lessons = 0;
          let checkedlessons = 0;
          (_a = data.themes) == null ? void 0 : _a.forEach((theme) => {
            var _a2;
            (_a2 = theme.lessons) == null ? void 0 : _a2.forEach((lesson) => {
              if (lesson.isChecked) {
                checkedlessons++;
              }
              lessons++;
            });
          });
          return checkedlessons / lessons * 100;
        }
      }, [data]);
      const handleDeleteChapter = () => {
        deleteChapter({ id: data.id }).then(() => {
          setLoaderActive(false);
        });
        setLoaderActive(true);
      };
      const handleRestoreChapter = () => {
        restoreChapter({ id: data.id }).then(() => {
          setLoaderActive(false);
        });
        setLoaderActive(true);
      };
      const handleEditChapter = () => {
        setUpdatingChapterData(data);
        setModalType(MODAL_TYPES.editChapter);
        setModalOpen(true);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$p, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TitleWrapper, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Title$a,
            {
              $isDeleted: !!data.is_deleted,
              as: "h3",
              children: data.title
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AdminBtn,
            {
              popupName: "",
              type: "edit",
              onClick: () => {
              },
              popupHandlers: {
                onDelete: !data.is_deleted ? handleDeleteChapter : void 0,
                onRestore: data.is_deleted ? handleRestoreChapter : void 0,
                onEdit: handleEditChapter
              }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressBar, { $progress: `${chapterProgress}` })
      ] });
    }
    const forwardIcon = "/assets/forwardIcon.svg";
    const forwardIconDisabled = "/assets/forwardIconDisabled.svg";
    const Title$9 = st$1(Text$6)`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 35px;
  font-size: 31px;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0 3.125vw;
    margin-bottom: 6.25vw;
    font-size:  5.625vw;
  }
`;
    const Container$o = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
`;
    st$1(FlexContainer)`
  flex-direction: column;
  padding-right: 20px;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0;
  }
`;
    st$1.div`
  position: absolute;
  top: 0;
  right: 0;
`;
    const NoOpenLesson = st$1(Text$6)`
  font-size: 31px;
`;
    const ForwardBtn = st$1(DefaultBtn)`
  width: 166px;
  padding: 0 20px 0 28px;
  text-align: start;
  background-image: url(${forwardIcon});
  background-repeat: no-repeat;
  background-position: 87% 50%;
  background-size: 33px;
  @media ${(props) => props.theme.media.mobile} {
    width: fit-content;
    min-height: 15.625vw;
    padding: 0px 15vw 0px 8vw;
    margin: 0;
    margin-left: auto;
    margin-right: 3.125vw;
    text-align: center;
    background-position: 88% 50%;
    background-size: 10.3125vw;
  }

  &:disabled {
    color: ${(props) => props.theme.colors.grey57};
    background-color: ${(props) => props.theme.colors.grey93};
    background-image: url(${forwardIconDisabled});
  }
`;
    const Container$n = st$1.div`
  font-style: normal;
  font-weight: 400;
  margin-bottom: 20px;
  .table {
    width: 100%;
  }

  /* p,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  ul,
  ol {
    margin-bottom: 20px;
  } */

  /* li {
    &:not(:last-child) {
      margin-bottom: 20px;
    }
  } */

  td {
    padding: 5px 0;
  }
  ol {
    list-style: inside;
    &:last-of-type {
      margin-bottom: 0px;
    }
  }
  ul {
    list-style: inside;
    &:last-of-type {
      margin-bottom: 0px;
    }
  }
`;
    function CkEditorOutput({ data }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: data && /* @__PURE__ */ jsxRuntimeExports.jsx(Container$n, { dangerouslySetInnerHTML: { __html: data }, className: "ck-content" }) });
    }
    const Container$m = st$1(FlexContainer)`
  display: flex;
  width: 100%;
  flex-direction: column;
  padding: 40px 45px;
  border: 1px solid
    ${(props) => props.$isPassed ? props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed : props.theme.colors.greyF1};
  border-radius: ${(props) => props.theme.utils.br};
  margin-bottom: 30px;
  @media ${(props) => props.theme.media.mobile} {
    padding: 6.25vw;
    border-radius: 17.089px;
  }

  &:last-child {
    margin-bottom: 115px;
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 3.125vw;
    }
  }
`;
    const Title$8 = st$1(Text$6)`
  margin-bottom: 40px;
  font-size: 25px;
  line-height: 150%;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 4.6875vw;
    font-size: 4.6875vw;
  }
`;
    const Answers = st$1(FlexContainer)`
  flex-direction: column;
  margin-bottom: 30px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 6.25vw;
  }
`;
    const CheckBtn = st$1(DefaultBtn)`
  align-self: flex-end;
  width: fit-content;
  padding: 19px 30px;
  @media ${(props) => props.theme.media.mobile} {
    align-self: center;
    padding: 0;
    width: 100%;
    min-height: 12.5vw;
    font-weight: 500;
    text-align: center;
    border-radius: 15px;
  }

  &:disabled {
    color: ${(props) => props.theme.colors.grey57};
    background-color: ${(props) => props.theme.colors.grey93};
  }
`;
    const radio = "/assets/radio.svg";
    const radioChecked = "/assets/radio-checked.svg";
    const Label$2 = st$1.label`
  display: flex;
  align-items: center;
  cursor: pointer;
  ${TextStyles}
  font-weight: 400;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.6875vw;
  }

  &:not(:last-child) {
    margin-bottom: 20px;
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 6.25vw;
    }
  }
`;
    const RadioBtn$1 = st$1.input`
  appearance: none;
  width: 36px;
  height: 36px;
  margin-right: 25px;
  background-image: url(${radio});
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;
  @media ${(props) => props.theme.media.mobile} {
    width: 7.5vw;
    height: 7.5vw;
    margin-right: 3.75vw;
  }

  &:checked {
    background-image: url(${radioChecked});
  }
`;
    function RadioBtn({ onChange, label, name, disabled = false }) {
      const handleChange = () => {
        if (onChange) {
          onChange();
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Label$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RadioBtn$1,
          {
            type: "radio",
            onChange: handleChange,
            name,
            disabled
          }
        ),
        label
      ] });
    }
    const lessonTestApi = api.injectEndpoints({
      endpoints: (builder) => ({
        addTest: builder.mutation({
          query: (data) => ({
            url: "test/add-test",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [{ type: "LessonById" }]
        }),
        updateTest: builder.mutation({
          query: (data) => ({
            url: "test/update-test",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [{ type: "LessonById" }]
        }),
        createQuestion: builder.mutation({
          query: (data) => ({
            url: "test/create-question",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [{ type: "LessonById" }]
        }),
        updateQuestion: builder.mutation({
          query: (data) => ({
            url: "test/update-question",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [{ type: "LessonById" }]
        }),
        deleteQuestion: builder.mutation({
          query: (data) => ({
            url: "test/delete-question",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => ["LessonById", "LessonById"]
        }),
        sendAnswer: builder.mutation({
          query: (data) => ({
            url: "test/send-answer",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => ["LessonById"]
        })
      }),
      overrideExisting: false
    });
    const {
      useAddTestMutation,
      useCreateQuestionMutation,
      useDeleteQuestionMutation,
      useSendAnswerMutation,
      useUpdateQuestionMutation,
      useUpdateTestMutation
    } = lessonTestApi;
    const wrongAnswer = "/assets/wrongAnswer.svg";
    const rightAnswer = "/assets/rightAnswer.svg";
    const Container$l = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 15px;
  @media ${(props) => props.theme.media.mobile} {
    row-gap: unset;
  }
  
  &:not(:last-child) {
    margin-bottom: 40px;
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 6.25vw;
    }
  }
`;
    const Answer = st$1(Text$6)`
  padding-left: 56px;
  font-weight: 400;
  color: ${(props) => props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed};
  background-image: url(${(props) => props.$isRight ? rightAnswer : wrongAnswer});
  background-repeat: no-repeat;
  background-position: left center;
  background-size: 36px;
  @media ${(props) => props.theme.media.mobile} {
    padding-left: 9.6875vw;
    background-size: 7.5vw;
  }
`;
    const Comment = st$1(Text$6)`
  font-weight: 600;
  color: ${(props) => props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed};
`;
    function CheckedAnswer({ data }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$l, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Answer, { $isRight: !!data.right_answer, children: data.answer }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Comment, { $isRight: !!data.right_answer, children: data.text })
      ] });
    }
    function LessonTest({ data }) {
      const { setLoaderActive } = useActions();
      const [checkedAnswer, setCheckedAnswer] = reactExports.useState(null);
      const [sendAnswer] = useSendAnswerMutation();
      const [isUserRightAnswer, setIsUserRightAnswer] = reactExports.useState(false);
      const [isTestPassed, setIsTestPassed] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if (data.userTestAnswer) {
          setIsTestPassed(true);
          setIsUserRightAnswer(!!data.userTestAnswer.is_right);
        }
      }, [data.userTestAnswer]);
      const handleChange = (answer) => {
        setCheckedAnswer(answer);
      };
      const handleSendAnswer = () => {
        if (checkedAnswer) {
          sendAnswer({ test_id: data.id, answer: checkedAnswer }).then(() => {
            setCheckedAnswer(null);
          });
          setLoaderActive(true);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Container$m,
        {
          $isRight: isUserRightAnswer,
          $isPassed: isTestPassed,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Title$8, { children: data.question }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Answers, { children: [
              !data.userTestAnswer && data.answers.map((answer) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                RadioBtn,
                {
                  name: data.id,
                  label: `${answer.answer}`,
                  onChange: () => {
                    handleChange(`${answer.id}`);
                  }
                },
                answer.id
              )),
              data.userTestAnswer && data.answers.map((answer) => {
                var _a, _b;
                if (Number(answer.id) === ((_a = data.userTestAnswer) == null ? void 0 : _a.answer)) {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckedAnswer, { data: answer });
                }
                if (!!answer.right_answer && Number(answer.id) !== ((_b = data.userTestAnswer) == null ? void 0 : _b.answer)) {
                  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckedAnswer, { data: answer });
                }
                return /* @__PURE__ */ jsxRuntimeExports.jsx(
                  RadioBtn,
                  {
                    name: data.id,
                    label: `${answer.answer}`,
                    onChange: () => {
                    },
                    disabled: true
                  },
                  answer.id
                );
              })
            ] }),
            !data.userTestAnswer && /* @__PURE__ */ jsxRuntimeExports.jsx(
              CheckBtn,
              {
                onClick: handleSendAnswer,
                disabled: !checkedAnswer,
                children: ""
              }
            )
          ]
        }
      );
    }
    const useMediaQuery = (query) => {
      if (!query) {
        console.error(`useMediaQuery: ${query}. Current query is not valid!`);
        return false;
      }
      return window.matchMedia(query).matches;
    };
    function CourseContent() {
      const { setLoaderActive } = useActions();
      const { courseId, lessonId, chapterId } = useParams();
      const chapterData = useGetChapterByIdQuery(Number(chapterId), {
        skip: !chapterId
      });
      const [deleteLesson] = useDeleteLessonMutation();
      const [restoreLesson] = useRestoreLessonMutation();
      const { data, isError, isFetching } = useGetLessonByIdQuery(String(lessonId), {
        skip: !lessonId
      });
      const [checkLesson] = useCheckLessonMutation();
      const [isForwardBtnDisabled, setIsForwardBtnDisabled] = reactExports.useState(true);
      const isMobile = useMediaQuery(MediaQueries.mobile);
      const navigate = useNavigate();
      const isTestsPassed = reactExports.useMemo(() => {
        if ((data == null ? void 0 : data.data.tests) && (data == null ? void 0 : data.data.tests.length) > 0) {
          return data == null ? void 0 : data.data.tests.every((test) => test.userTestAnswer);
        }
      }, [data == null ? void 0 : data.data.tests]);
      reactExports.useEffect(() => {
        setLoaderActive(isFetching);
        if (isFetching || (data == null ? void 0 : data.data.isChecked) || (data == null ? void 0 : data.data.tests) && (data == null ? void 0 : data.data.tests.length) > 0 && !isTestsPassed) {
          setIsForwardBtnDisabled(true);
        } else {
          setIsForwardBtnDisabled(false);
        }
      }, [data == null ? void 0 : data.data.isChecked, data == null ? void 0 : data.data.tests, isFetching, isTestsPassed]);
      const handleCheckLesson = () => {
        if (data && data.data.id) {
          checkLesson({ id: data.data.id }).then((res) => {
            var _a;
            if (!("data" in res) || "data" in res && !res.data.data) {
              return;
            }
            if (!chapterData.data || !chapterData.data.data || !chapterData.data.data.themes) {
              return;
            }
            const theme = (_a = chapterData.data) == null ? void 0 : _a.data.themes.find(
              (theme2) => theme2.id === res.data.data.theme_id
            );
            if (!theme || !(theme == null ? void 0 : theme.lessons)) {
              return;
            }
            const index = theme == null ? void 0 : theme.lessons.findIndex((lesson) => lesson.id === Number(lessonId));
            if (index && index !== -1 && (theme == null ? void 0 : theme.lessons.length) > index + 1) {
              navigate(
                `/courses/${courseId}/${chapterId}/${res.data.data.theme_id}/${theme.lessons[index + 1].id}`
              );
            }
            setLoaderActive(false);
          });
          setLoaderActive(true);
        }
      };
      const renderLessonTests = () => {
        return data == null ? void 0 : data.data.tests.map((test) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          LessonTest,
          {
            data: test
          },
          test.id
        ));
      };
      const renderForwardButton = () => {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          ForwardBtn,
          {
            onClick: handleCheckLesson,
            disabled: isForwardBtnDisabled,
            children: ""
          }
        );
      };
      const handleEditLesson = () => {
        if (data) {
          navigate(
            generatePath(`/courses/:courseId/:chapterId/:themeId/:lessonId/edit-lesson`, {
              courseId: String(courseId),
              chapterId: String(chapterId),
              themeId: String(data.data.theme_id),
              lessonId: String(data.data.id)
            })
          );
        }
      };
      const handleDeleteLesson = () => {
        if (!data)
          return;
        deleteLesson({
          id: Number(data.data.id)
        });
        setLoaderActive(true);
      };
      const handleRestoreLesson = () => {
        if (!data)
          return;
        restoreLesson({
          id: Number(data.data.id)
        });
        setLoaderActive(true);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        !lessonId && /* @__PURE__ */ jsxRuntimeExports.jsx(NoOpenLesson, { children: " " }),
        lessonId && isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
        lessonId && data && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$9, { as: "h2", children: [
            data.data.title,
            !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
              AdminBtn,
              {
                popupName: "",
                type: "edit",
                onClick: () => {
                },
                popupHandlers: {
                  onEdit: handleEditLesson,
                  onDelete: data.data.is_deleted ? void 0 : handleDeleteLesson,
                  onRestore: data.data.is_deleted ? handleRestoreLesson : void 0
                }
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$o, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditorOutput, { data: data.data.description }),
            data.data.tests.length > 0 && renderLessonTests(),
            data.data.description.length > 0 && !isFetching && !data.data.isChecked && renderForwardButton()
          ] })
        ] })
      ] });
    }
    const closeIcon = "/assets/close-icon.svg";
    const Button$1 = st$1.button`
  width: 24px;
  height: 24px;
  padding: 0;
  margin: 0;
  background-image: url(${closeIcon});
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;
  background-color: transparent;
  @media ${(props) => props.theme.media.mobile} {
    width: 7.5vw;
    height: 7.5vw;
  }
`;
    function CloseBtn$1({ onClick: onClick2 = () => {
    }, styles: styles2 = {} }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button$1,
        {
          onClick: onClick2,
          style: styles2
        }
      );
    }
    const arrowIcon = "/assets/grey-arrow-right.svg";
    const NavList$2 = st$1.ul`
  display: flex;
  align-items: center;
  width: fit-content;
`;
    const NavItem = st$1.li`
  padding-bottom: 3.125vw;
  border-bottom: 4px solid ${(props) => props.theme.colors.grey93};
  margin-right: 3.125vw;
  font-size: 4.6875vw;
  font-weight: 500;
  line-height: 130%;
  color: #000;
`;
    const Chapter = st$1(NavItem)`
  ${(props) => {
      if (!props.$isActive) {
        return nt$1`
        color: ${(props2) => props2.theme.colors.grey93};
        border-bottom: none;
      `;
      }
    }}
`;
    const ArrowIcon = st$1(Icon$2)`
  margin-right: 3.125vw;
  background-image: url(${arrowIcon});
`;
    const Theme = st$1(NavItem)`
  color: ${(props) => props.theme.colors.dark};
  border-color: ${(props) => props.theme.colors.dark};
`;
    function NavBar({ activeStep }) {
      const { courseId, chapterId } = useParams();
      const navigate = useNavigate();
      const handleClick = reactExports.useCallback(() => {
        if (activeStep === Steps.theme) {
          navigate(`/courses/${courseId}/${chapterId}`);
        }
      }, [activeStep, chapterId, courseId, navigate]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(NavList$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Chapter,
          {
            $isActive: activeStep === Steps.chapter,
            onClick: handleClick,
            children: ""
          }
        ),
        activeStep === Steps.theme && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowIcon, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, { children: "" })
        ] })
      ] });
    }
    const Container$k = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  border-bottom: 1px solid ${(props) => props.theme.colors.grey93};
  margin-bottom: 4.6875vw;
`;
    function Head$1({ activeStep, onClose = () => {
    } }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$k, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NavBar, { activeStep }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CloseBtn$1, { onClick: onClose })
      ] });
    }
    const Container$j = st$1.div`
  display: flex;
  flex-direction: column;
  position: fixed;
  top: 0;
  left: 0;
  z-index: ${(props) => props.theme.utils.zIndex.overDarkOverlay};
  width: 100vw;
  height: 100vh;
  overflow-y: auto;
  padding: 3.125vw; 
  background-color: ${(props) => props.theme.colors.realWhite};
`;
    const MainContent = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
`;
    const NavList$1 = st$1.ul`
  display: flex;
  flex-direction: column;
  width: 100%;
  row-gap: 3.125vw;
`;
    const NavListItem$1 = st$1.li`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  min-height: 7.5vw;
`;
    const DoneIcon$1 = st$1(Icon$2)`
  background-image: url(${doneIcon});
`;
    function DoneIcon() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DoneIcon$1, {});
    }
    function NavPopup({ chapterData }) {
      const { themeId, lessonId } = useParams();
      const [activeStep, setActiveStep] = reactExports.useState(Steps.chapter);
      const { setNavPopup } = useActions();
      const navigate = useNavigate();
      const [navListData, setNavListData] = reactExports.useState([]);
      reactExports.useEffect(() => {
        themeId ? setActiveStep(Steps.theme) : setActiveStep(Steps.chapter);
      }, [themeId]);
      const handleClose = reactExports.useCallback(() => {
        if (themeId && lessonId) {
          setNavPopup(false);
        } else {
          navigate(`/courses/${chapterData.course_id}`);
        }
      }, [chapterData.course_id, lessonId, navigate, setNavPopup, themeId]);
      reactExports.useEffect(() => {
        if (activeStep === Steps.chapter) {
          const data = chapterData.themes || [];
          setNavListData(data);
          return;
        }
        if (activeStep === Steps.theme && chapterData.themes) {
          const currentTheme = chapterData.themes.find((theme) => Number(theme.id) === Number(themeId));
          if (currentTheme) {
            const data = currentTheme.lessons || [];
            setNavListData(data);
            return;
          }
        }
      }, [activeStep, chapterData.themes, themeId]);
      const handleClick = (id2) => {
        let url = "";
        if (activeStep === Steps.theme) {
          url = `/courses/${chapterData.course_id}/${chapterData.id}/${themeId}/${id2}`;
        } else {
          url = `/courses/${chapterData.course_id}/${chapterData.id}/${id2}`;
        }
        navigate(url);
        if (activeStep === Steps.theme) {
          setNavPopup(false);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$j, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Head$1,
          {
            activeStep,
            onClose: handleClose
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(MainContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CourseNavHead, { data: chapterData }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            FadedTitle,
            {
              text: activeStep === Steps.chapter ? " " : "",
              styles: {
                marginBottom: "3.125vw",
                minHeight: "7.5vw"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(NavList$1, { children: navListData && navListData.length > 0 && navListData.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            NavListItem$1,
            {
              onClick: () => handleClick(item.id),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  CourseNavItemTitle,
                  {
                    text: item.title,
                    isDeleted: !!item.is_deleted
                  }
                ),
                "isChecked" in item && /* @__PURE__ */ jsxRuntimeExports.jsx(DoneIcon, {})
              ]
            },
            item.id
          )) })
        ] })
      ] });
    }
    function Course() {
      const { setActiveChapterId, setLoaderActive, setNavPopup } = useActions();
      const { chapterId, lessonId } = useParams();
      const { data, isError, isFetching } = useGetChapterByIdQuery(Number(chapterId));
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      const isNavPopup = useTypedSelector((state) => state.lesson.navPopup);
      reactExports.useEffect(() => {
        lessonId ? setNavPopup(false) : setNavPopup(true);
      }, [lessonId, setNavPopup]);
      reactExports.useEffect(() => {
        setLoaderActive(isFetching);
      }, [isFetching, setLoaderActive]);
      reactExports.useEffect(() => {
        if (chapterId) {
          setActiveChapterId(chapterId);
        }
      }, [chapterId, setActiveChapterId]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$q, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(bodyOverflow$1, {}),
          !isMobile && data && /* @__PURE__ */ jsxRuntimeExports.jsxs(NavContainer, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CourseNavHead, { data: data.data }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CourseNavBody, { data: data.data })
          ] }),
          isMobile && data && isNavPopup && /* @__PURE__ */ jsxRuntimeExports.jsx(NavPopup, { chapterData: data.data }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ContentContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CourseContent, {}) })
        ] })
      ] });
    }
    function Courses() {
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "/:courseId?",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(CoursePreview, {})
          }
        ),
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
          Route,
          {
            path: "/:courseId/:chapterId/:themeId?/:lessonId?",
            element: /* @__PURE__ */ jsxRuntimeExports.jsx(Course, {})
          }
        )
      ] }) });
    }
    const competitionApi = api.injectEndpoints({
      endpoints: (builder) => ({
        getAllCompetitions: builder.query({
          query: () => "competition",
          providesTags: () => [
            {
              type: "Competition"
            }
          ]
        }),
        getCompetitionById: builder.query({
          query: (id2) => `competition/${id2}`,
          providesTags: () => [
            {
              type: "CompetitionById"
            }
          ]
        }),
        createCompetition: builder.mutation({
          query: (data) => ({
            url: "competition/create",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["Competition"]
        }),
        updateCompetition: builder.mutation({
          query: (data) => ({
            url: "competition/update",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["Competition", "CompetitionById"]
        }),
        deleteCompetition: builder.mutation({
          query: (data) => ({
            url: "competition/delete",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["Competition", "CompetitionById"]
        }),
        restoreCompetition: builder.mutation({
          query: (data) => ({
            url: "competition/restore",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["Competition", "CompetitionById"]
        })
      }),
      overrideExisting: false
    });
    const {
      useCreateCompetitionMutation,
      useDeleteCompetitionMutation,
      useGetCompetitionByIdQuery,
      useGetAllCompetitionsQuery,
      useRestoreCompetitionMutation,
      useUpdateCompetitionMutation
    } = competitionApi;
    const arrowLeft = "/assets/swiperArrowLeft.svg";
    const Container$i = st$1.div`
  position: relative;
  width: 49.7%;
  height: 400px;
  background-color: ${(props) => props.theme.colors.realWhite};
  border-radius: ${(props) => props.theme.utils.br};
  overflow: hidden;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    min-height: 47.85vw;
    height: unset;
    background-color: transparent;
    overflow: unset;
  }

  .swiper-pagination {
    display: none;
    @media ${(props) => props.theme.media.mobile} {
      display: flex;
      align-items: center;
      justify-content: center;
      flex-wrap: wrap;
      padding: 0 3vw;
      row-gap: 2vw;
      bottom: -5vw;
      left: 0;
      z-index: 222;
    }
  }

  .swiper-pagination-bullet {
    width: 1.88vw;
    height: 1.88vw;
  }

  .swiper-pagination-bullet-active {
    background-color: #181818;
  }
`;
    const SwiperPrevBtn = st$1.div`
  position: absolute;
  bottom: 40px;
  left: 20px;
  z-index: 2;
  width: 33px;
  height: 33px;
  background-image: url(${arrowLeft});
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;
  cursor: pointer;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const SwiperNextBtn = st$1(SwiperPrevBtn)`
  right: 20px;
  left: unset;
  transform: rotate(-180deg);
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    st$1(DefaultBtn)`
  z-index: 2;
  position: absolute;
  top: 50%;
  left: 50%;
  color: white;
  border-radius: 15px;
  width: fit-content;
  padding: 20px 30px;
  background-color: rgb(0, 122, 255);
  cursor: pointer;
  transform: translate(-50%, -50%);
  @media ${(props) => props.theme.media.mobile} {
  }
`;
    st$1(Text$6)`
  position: absolute;
  left: 50%;
  top: 50%;
  font-size: 22px;
  transform: translate(-50%, -50%);
  z-index: 2;

  @media ${(props) => props.theme.media.mobile} {
  }
`;
    function isObject$2(obj) {
      return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
    }
    function extend$2(target, src) {
      if (target === void 0) {
        target = {};
      }
      if (src === void 0) {
        src = {};
      }
      Object.keys(src).forEach((key) => {
        if (typeof target[key] === "undefined")
          target[key] = src[key];
        else if (isObject$2(src[key]) && isObject$2(target[key]) && Object.keys(src[key]).length > 0) {
          extend$2(target[key], src[key]);
        }
      });
    }
    const ssrDocument = {
      body: {},
      addEventListener() {
      },
      removeEventListener() {
      },
      activeElement: {
        blur() {
        },
        nodeName: ""
      },
      querySelector() {
        return null;
      },
      querySelectorAll() {
        return [];
      },
      getElementById() {
        return null;
      },
      createEvent() {
        return {
          initEvent() {
          }
        };
      },
      createElement() {
        return {
          children: [],
          childNodes: [],
          style: {},
          setAttribute() {
          },
          getElementsByTagName() {
            return [];
          }
        };
      },
      createElementNS() {
        return {};
      },
      importNode() {
        return null;
      },
      location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
      }
    };
    function getDocument() {
      const doc = typeof document !== "undefined" ? document : {};
      extend$2(doc, ssrDocument);
      return doc;
    }
    const ssrWindow = {
      document: ssrDocument,
      navigator: {
        userAgent: ""
      },
      location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
      },
      history: {
        replaceState() {
        },
        pushState() {
        },
        go() {
        },
        back() {
        }
      },
      CustomEvent: function CustomEvent2() {
        return this;
      },
      addEventListener() {
      },
      removeEventListener() {
      },
      getComputedStyle() {
        return {
          getPropertyValue() {
            return "";
          }
        };
      },
      Image() {
      },
      Date() {
      },
      screen: {},
      setTimeout() {
      },
      clearTimeout() {
      },
      matchMedia() {
        return {};
      },
      requestAnimationFrame(callback) {
        if (typeof setTimeout === "undefined") {
          callback();
          return null;
        }
        return setTimeout(callback, 0);
      },
      cancelAnimationFrame(id2) {
        if (typeof setTimeout === "undefined") {
          return;
        }
        clearTimeout(id2);
      }
    };
    function getWindow() {
      const win = typeof window !== "undefined" ? window : {};
      extend$2(win, ssrWindow);
      return win;
    }
    function deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach((key) => {
        try {
          object[key] = null;
        } catch (e2) {
        }
        try {
          delete object[key];
        } catch (e2) {
        }
      });
    }
    function nextTick(callback, delay) {
      if (delay === void 0) {
        delay = 0;
      }
      return setTimeout(callback, delay);
    }
    function now() {
      return Date.now();
    }
    function getComputedStyle$1(el2) {
      const window2 = getWindow();
      let style2;
      if (window2.getComputedStyle) {
        style2 = window2.getComputedStyle(el2, null);
      }
      if (!style2 && el2.currentStyle) {
        style2 = el2.currentStyle;
      }
      if (!style2) {
        style2 = el2.style;
      }
      return style2;
    }
    function getTranslate(el2, axis) {
      if (axis === void 0) {
        axis = "x";
      }
      const window2 = getWindow();
      let matrix;
      let curTransform;
      let transformMatrix;
      const curStyle = getComputedStyle$1(el2);
      if (window2.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(",").length > 6) {
          curTransform = curTransform.split(", ").map((a2) => a2.replace(",", ".")).join(", ");
        }
        transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
        matrix = transformMatrix.toString().split(",");
      }
      if (axis === "x") {
        if (window2.WebKitCSSMatrix)
          curTransform = transformMatrix.m41;
        else if (matrix.length === 16)
          curTransform = parseFloat(matrix[12]);
        else
          curTransform = parseFloat(matrix[4]);
      }
      if (axis === "y") {
        if (window2.WebKitCSSMatrix)
          curTransform = transformMatrix.m42;
        else if (matrix.length === 16)
          curTransform = parseFloat(matrix[13]);
        else
          curTransform = parseFloat(matrix[5]);
      }
      return curTransform || 0;
    }
    function isObject$1(o2) {
      return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
    }
    function isNode(node2) {
      if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
        return node2 instanceof HTMLElement;
      }
      return node2 && (node2.nodeType === 1 || node2.nodeType === 11);
    }
    function extend$1() {
      const to2 = Object(arguments.length <= 0 ? void 0 : arguments[0]);
      const noExtend = ["__proto__", "constructor", "prototype"];
      for (let i2 = 1; i2 < arguments.length; i2 += 1) {
        const nextSource = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
        if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
          const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== void 0 && desc.enumerable) {
              if (isObject$1(to2[nextKey]) && isObject$1(nextSource[nextKey])) {
                if (nextSource[nextKey].__swiper__) {
                  to2[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to2[nextKey], nextSource[nextKey]);
                }
              } else if (!isObject$1(to2[nextKey]) && isObject$1(nextSource[nextKey])) {
                to2[nextKey] = {};
                if (nextSource[nextKey].__swiper__) {
                  to2[nextKey] = nextSource[nextKey];
                } else {
                  extend$1(to2[nextKey], nextSource[nextKey]);
                }
              } else {
                to2[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }
      return to2;
    }
    function setCSSProperty(el2, varName, varValue) {
      el2.style.setProperty(varName, varValue);
    }
    function animateCSSModeScroll(_ref) {
      let {
        swiper: swiper2,
        targetPosition,
        side
      } = _ref;
      const window2 = getWindow();
      const startPosition = -swiper2.translate;
      let startTime = null;
      let time;
      const duration2 = swiper2.params.speed;
      swiper2.wrapperEl.style.scrollSnapType = "none";
      window2.cancelAnimationFrame(swiper2.cssModeFrameID);
      const dir = targetPosition > startPosition ? "next" : "prev";
      const isOutOfBound = (current, target) => {
        return dir === "next" && current >= target || dir === "prev" && current <= target;
      };
      const animate = () => {
        time = (/* @__PURE__ */ new Date()).getTime();
        if (startTime === null) {
          startTime = time;
        }
        const progress = Math.max(Math.min((time - startTime) / duration2, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
        if (isOutOfBound(currentPosition, targetPosition)) {
          currentPosition = targetPosition;
        }
        swiper2.wrapperEl.scrollTo({
          [side]: currentPosition
        });
        if (isOutOfBound(currentPosition, targetPosition)) {
          swiper2.wrapperEl.style.overflow = "hidden";
          swiper2.wrapperEl.style.scrollSnapType = "";
          setTimeout(() => {
            swiper2.wrapperEl.style.overflow = "";
            swiper2.wrapperEl.scrollTo({
              [side]: currentPosition
            });
          });
          window2.cancelAnimationFrame(swiper2.cssModeFrameID);
          return;
        }
        swiper2.cssModeFrameID = window2.requestAnimationFrame(animate);
      };
      animate();
    }
    function elementChildren(element, selector) {
      if (selector === void 0) {
        selector = "";
      }
      return [...element.children].filter((el2) => el2.matches(selector));
    }
    function createElement(tag, classes2) {
      if (classes2 === void 0) {
        classes2 = [];
      }
      const el2 = document.createElement(tag);
      el2.classList.add(...Array.isArray(classes2) ? classes2 : [classes2]);
      return el2;
    }
    function elementPrevAll(el2, selector) {
      const prevEls = [];
      while (el2.previousElementSibling) {
        const prev2 = el2.previousElementSibling;
        if (selector) {
          if (prev2.matches(selector))
            prevEls.push(prev2);
        } else
          prevEls.push(prev2);
        el2 = prev2;
      }
      return prevEls;
    }
    function elementNextAll(el2, selector) {
      const nextEls = [];
      while (el2.nextElementSibling) {
        const next2 = el2.nextElementSibling;
        if (selector) {
          if (next2.matches(selector))
            nextEls.push(next2);
        } else
          nextEls.push(next2);
        el2 = next2;
      }
      return nextEls;
    }
    function elementStyle(el2, prop) {
      const window2 = getWindow();
      return window2.getComputedStyle(el2, null).getPropertyValue(prop);
    }
    function elementIndex(el2) {
      let child = el2;
      let i2;
      if (child) {
        i2 = 0;
        while ((child = child.previousSibling) !== null) {
          if (child.nodeType === 1)
            i2 += 1;
        }
        return i2;
      }
      return void 0;
    }
    function elementParents(el2, selector) {
      const parents = [];
      let parent = el2.parentElement;
      while (parent) {
        if (selector) {
          if (parent.matches(selector))
            parents.push(parent);
        } else {
          parents.push(parent);
        }
        parent = parent.parentElement;
      }
      return parents;
    }
    function elementOuterSize(el2, size, includeMargins) {
      const window2 = getWindow();
      if (includeMargins) {
        return el2[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el2, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el2, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
      }
      return el2.offsetWidth;
    }
    let support;
    function calcSupport() {
      const window2 = getWindow();
      const document2 = getDocument();
      return {
        smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
        touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
      };
    }
    function getSupport() {
      if (!support) {
        support = calcSupport();
      }
      return support;
    }
    let deviceCached;
    function calcDevice(_temp) {
      let {
        userAgent
      } = _temp === void 0 ? {} : _temp;
      const support2 = getSupport();
      const window2 = getWindow();
      const platform = window2.navigator.platform;
      const ua2 = userAgent || window2.navigator.userAgent;
      const device = {
        ios: false,
        android: false
      };
      const screenWidth = window2.screen.width;
      const screenHeight = window2.screen.height;
      const android = ua2.match(/(Android);?[\s\/]+([\d.]+)?/);
      let ipad = ua2.match(/(iPad).*OS\s([\d_]+)/);
      const ipod = ua2.match(/(iPod)(.*OS\s([\d_]+))?/);
      const iphone = !ipad && ua2.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
      const windows = platform === "Win32";
      let macos = platform === "MacIntel";
      const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
      if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua2.match(/(Version)\/([\d.]+)/);
        if (!ipad)
          ipad = [0, 1, "13_0_0"];
        macos = false;
      }
      if (android && !windows) {
        device.os = "android";
        device.android = true;
      }
      if (ipad || iphone || ipod) {
        device.os = "ios";
        device.ios = true;
      }
      return device;
    }
    function getDevice(overrides) {
      if (overrides === void 0) {
        overrides = {};
      }
      if (!deviceCached) {
        deviceCached = calcDevice(overrides);
      }
      return deviceCached;
    }
    let browser;
    function calcBrowser() {
      const window2 = getWindow();
      let needPerspectiveFix = false;
      function isSafari() {
        const ua2 = window2.navigator.userAgent.toLowerCase();
        return ua2.indexOf("safari") >= 0 && ua2.indexOf("chrome") < 0 && ua2.indexOf("android") < 0;
      }
      if (isSafari()) {
        const ua2 = String(window2.navigator.userAgent);
        if (ua2.includes("Version/")) {
          const [major, minor] = ua2.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
          needPerspectiveFix = major < 16 || major === 16 && minor < 2;
        }
      }
      return {
        isSafari: needPerspectiveFix || isSafari(),
        needPerspectiveFix,
        isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
      };
    }
    function getBrowser() {
      if (!browser) {
        browser = calcBrowser();
      }
      return browser;
    }
    function Resize(_ref) {
      let {
        swiper: swiper2,
        on: on2,
        emit
      } = _ref;
      const window2 = getWindow();
      let observer = null;
      let animationFrame = null;
      const resizeHandler = () => {
        if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
          return;
        emit("beforeResize");
        emit("resize");
      };
      const createObserver = () => {
        if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
          return;
        observer = new ResizeObserver((entries) => {
          animationFrame = window2.requestAnimationFrame(() => {
            const {
              width: width2,
              height: height2
            } = swiper2;
            let newWidth = width2;
            let newHeight = height2;
            entries.forEach((_ref2) => {
              let {
                contentBoxSize,
                contentRect,
                target
              } = _ref2;
              if (target && target !== swiper2.el)
                return;
              newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
              newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
            });
            if (newWidth !== width2 || newHeight !== height2) {
              resizeHandler();
            }
          });
        });
        observer.observe(swiper2.el);
      };
      const removeObserver = () => {
        if (animationFrame) {
          window2.cancelAnimationFrame(animationFrame);
        }
        if (observer && observer.unobserve && swiper2.el) {
          observer.unobserve(swiper2.el);
          observer = null;
        }
      };
      const orientationChangeHandler = () => {
        if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
          return;
        emit("orientationchange");
      };
      on2("init", () => {
        if (swiper2.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
          createObserver();
          return;
        }
        window2.addEventListener("resize", resizeHandler);
        window2.addEventListener("orientationchange", orientationChangeHandler);
      });
      on2("destroy", () => {
        removeObserver();
        window2.removeEventListener("resize", resizeHandler);
        window2.removeEventListener("orientationchange", orientationChangeHandler);
      });
    }
    function Observer(_ref) {
      let {
        swiper: swiper2,
        extendParams,
        on: on2,
        emit
      } = _ref;
      const observers = [];
      const window2 = getWindow();
      const attach = function(target, options) {
        if (options === void 0) {
          options = {};
        }
        const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
        const observer = new ObserverFunc((mutations) => {
          if (swiper2.__preventObserver__)
            return;
          if (mutations.length === 1) {
            emit("observerUpdate", mutations[0]);
            return;
          }
          const observerUpdate = function observerUpdate2() {
            emit("observerUpdate", mutations[0]);
          };
          if (window2.requestAnimationFrame) {
            window2.requestAnimationFrame(observerUpdate);
          } else {
            window2.setTimeout(observerUpdate, 0);
          }
        });
        observer.observe(target, {
          attributes: typeof options.attributes === "undefined" ? true : options.attributes,
          childList: typeof options.childList === "undefined" ? true : options.childList,
          characterData: typeof options.characterData === "undefined" ? true : options.characterData
        });
        observers.push(observer);
      };
      const init2 = () => {
        if (!swiper2.params.observer)
          return;
        if (swiper2.params.observeParents) {
          const containerParents = elementParents(swiper2.hostEl);
          for (let i2 = 0; i2 < containerParents.length; i2 += 1) {
            attach(containerParents[i2]);
          }
        }
        attach(swiper2.hostEl, {
          childList: swiper2.params.observeSlideChildren
        });
        attach(swiper2.wrapperEl, {
          attributes: false
        });
      };
      const destroy = () => {
        observers.forEach((observer) => {
          observer.disconnect();
        });
        observers.splice(0, observers.length);
      };
      extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
      });
      on2("init", init2);
      on2("destroy", destroy);
    }
    var eventsEmitter = {
      on(events2, handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed)
          return self2;
        if (typeof handler !== "function")
          return self2;
        const method = priority ? "unshift" : "push";
        events2.split(" ").forEach((event) => {
          if (!self2.eventsListeners[event])
            self2.eventsListeners[event] = [];
          self2.eventsListeners[event][method](handler);
        });
        return self2;
      },
      once(events2, handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed)
          return self2;
        if (typeof handler !== "function")
          return self2;
        function onceHandler() {
          self2.off(events2, onceHandler);
          if (onceHandler.__emitterProxy) {
            delete onceHandler.__emitterProxy;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          handler.apply(self2, args);
        }
        onceHandler.__emitterProxy = handler;
        return self2.on(events2, onceHandler, priority);
      },
      onAny(handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed)
          return self2;
        if (typeof handler !== "function")
          return self2;
        const method = priority ? "unshift" : "push";
        if (self2.eventsAnyListeners.indexOf(handler) < 0) {
          self2.eventsAnyListeners[method](handler);
        }
        return self2;
      },
      offAny(handler) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed)
          return self2;
        if (!self2.eventsAnyListeners)
          return self2;
        const index = self2.eventsAnyListeners.indexOf(handler);
        if (index >= 0) {
          self2.eventsAnyListeners.splice(index, 1);
        }
        return self2;
      },
      off(events2, handler) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed)
          return self2;
        if (!self2.eventsListeners)
          return self2;
        events2.split(" ").forEach((event) => {
          if (typeof handler === "undefined") {
            self2.eventsListeners[event] = [];
          } else if (self2.eventsListeners[event]) {
            self2.eventsListeners[event].forEach((eventHandler, index) => {
              if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                self2.eventsListeners[event].splice(index, 1);
              }
            });
          }
        });
        return self2;
      },
      emit() {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed)
          return self2;
        if (!self2.eventsListeners)
          return self2;
        let events2;
        let data;
        let context;
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
          events2 = args[0];
          data = args.slice(1, args.length);
          context = self2;
        } else {
          events2 = args[0].events;
          data = args[0].data;
          context = args[0].context || self2;
        }
        data.unshift(context);
        const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
        eventsArray.forEach((event) => {
          if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
            self2.eventsAnyListeners.forEach((eventHandler) => {
              eventHandler.apply(context, [event, ...data]);
            });
          }
          if (self2.eventsListeners && self2.eventsListeners[event]) {
            self2.eventsListeners[event].forEach((eventHandler) => {
              eventHandler.apply(context, data);
            });
          }
        });
        return self2;
      }
    };
    function updateSize() {
      const swiper2 = this;
      let width2;
      let height2;
      const el2 = swiper2.el;
      if (typeof swiper2.params.width !== "undefined" && swiper2.params.width !== null) {
        width2 = swiper2.params.width;
      } else {
        width2 = el2.clientWidth;
      }
      if (typeof swiper2.params.height !== "undefined" && swiper2.params.height !== null) {
        height2 = swiper2.params.height;
      } else {
        height2 = el2.clientHeight;
      }
      if (width2 === 0 && swiper2.isHorizontal() || height2 === 0 && swiper2.isVertical()) {
        return;
      }
      width2 = width2 - parseInt(elementStyle(el2, "padding-left") || 0, 10) - parseInt(elementStyle(el2, "padding-right") || 0, 10);
      height2 = height2 - parseInt(elementStyle(el2, "padding-top") || 0, 10) - parseInt(elementStyle(el2, "padding-bottom") || 0, 10);
      if (Number.isNaN(width2))
        width2 = 0;
      if (Number.isNaN(height2))
        height2 = 0;
      Object.assign(swiper2, {
        width: width2,
        height: height2,
        size: swiper2.isHorizontal() ? width2 : height2
      });
    }
    function updateSlides() {
      const swiper2 = this;
      function getDirectionLabel(property) {
        if (swiper2.isHorizontal()) {
          return property;
        }
        return {
          "width": "height",
          "margin-top": "margin-left",
          "margin-bottom ": "margin-right",
          "margin-left": "margin-top",
          "margin-right": "margin-bottom",
          "padding-left": "padding-top",
          "padding-right": "padding-bottom",
          "marginRight": "marginBottom"
        }[property];
      }
      function getDirectionPropertyValue(node2, label) {
        return parseFloat(node2.getPropertyValue(getDirectionLabel(label)) || 0);
      }
      const params = swiper2.params;
      const {
        wrapperEl,
        slidesEl,
        size: swiperSize,
        rtlTranslate: rtl,
        wrongRTL
      } = swiper2;
      const isVirtual = swiper2.virtual && params.virtual.enabled;
      const previousSlidesLength = isVirtual ? swiper2.virtual.slides.length : swiper2.slides.length;
      const slides = elementChildren(slidesEl, `.${swiper2.params.slideClass}, swiper-slide`);
      const slidesLength = isVirtual ? swiper2.virtual.slides.length : slides.length;
      let snapGrid = [];
      const slidesGrid = [];
      const slidesSizesGrid = [];
      let offsetBefore = params.slidesOffsetBefore;
      if (typeof offsetBefore === "function") {
        offsetBefore = params.slidesOffsetBefore.call(swiper2);
      }
      let offsetAfter = params.slidesOffsetAfter;
      if (typeof offsetAfter === "function") {
        offsetAfter = params.slidesOffsetAfter.call(swiper2);
      }
      const previousSnapGridLength = swiper2.snapGrid.length;
      const previousSlidesGridLength = swiper2.slidesGrid.length;
      let spaceBetween = params.spaceBetween;
      let slidePosition = -offsetBefore;
      let prevSlideSize = 0;
      let index = 0;
      if (typeof swiperSize === "undefined") {
        return;
      }
      if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
      } else if (typeof spaceBetween === "string") {
        spaceBetween = parseFloat(spaceBetween);
      }
      swiper2.virtualSize = -spaceBetween;
      slides.forEach((slideEl) => {
        if (rtl) {
          slideEl.style.marginLeft = "";
        } else {
          slideEl.style.marginRight = "";
        }
        slideEl.style.marginBottom = "";
        slideEl.style.marginTop = "";
      });
      if (params.centeredSlides && params.cssMode) {
        setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
        setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
      }
      const gridEnabled = params.grid && params.grid.rows > 1 && swiper2.grid;
      if (gridEnabled) {
        swiper2.grid.initSlides(slidesLength);
      }
      let slideSize;
      const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
        return typeof params.breakpoints[key].slidesPerView !== "undefined";
      }).length > 0;
      for (let i2 = 0; i2 < slidesLength; i2 += 1) {
        slideSize = 0;
        let slide2;
        if (slides[i2])
          slide2 = slides[i2];
        if (gridEnabled) {
          swiper2.grid.updateSlide(i2, slide2, slidesLength, getDirectionLabel);
        }
        if (slides[i2] && elementStyle(slide2, "display") === "none")
          continue;
        if (params.slidesPerView === "auto") {
          if (shouldResetSlideSize) {
            slides[i2].style[getDirectionLabel("width")] = ``;
          }
          const slideStyles = getComputedStyle(slide2);
          const currentTransform = slide2.style.transform;
          const currentWebKitTransform = slide2.style.webkitTransform;
          if (currentTransform) {
            slide2.style.transform = "none";
          }
          if (currentWebKitTransform) {
            slide2.style.webkitTransform = "none";
          }
          if (params.roundLengths) {
            slideSize = swiper2.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
          } else {
            const width2 = getDirectionPropertyValue(slideStyles, "width");
            const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
            const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
            const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
            const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
            const boxSizing2 = slideStyles.getPropertyValue("box-sizing");
            if (boxSizing2 && boxSizing2 === "border-box") {
              slideSize = width2 + marginLeft + marginRight;
            } else {
              const {
                clientWidth,
                offsetWidth
              } = slide2;
              slideSize = width2 + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
            }
          }
          if (currentTransform) {
            slide2.style.transform = currentTransform;
          }
          if (currentWebKitTransform) {
            slide2.style.webkitTransform = currentWebKitTransform;
          }
          if (params.roundLengths)
            slideSize = Math.floor(slideSize);
        } else {
          slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
          if (params.roundLengths)
            slideSize = Math.floor(slideSize);
          if (slides[i2]) {
            slides[i2].style[getDirectionLabel("width")] = `${slideSize}px`;
          }
        }
        if (slides[i2]) {
          slides[i2].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);
        if (params.centeredSlides) {
          slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
          if (prevSlideSize === 0 && i2 !== 0)
            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (i2 === 0)
            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
          if (Math.abs(slidePosition) < 1 / 1e3)
            slidePosition = 0;
          if (params.roundLengths)
            slidePosition = Math.floor(slidePosition);
          if (index % params.slidesPerGroup === 0)
            snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
        } else {
          if (params.roundLengths)
            slidePosition = Math.floor(slidePosition);
          if ((index - Math.min(swiper2.params.slidesPerGroupSkip, index)) % swiper2.params.slidesPerGroup === 0)
            snapGrid.push(slidePosition);
          slidesGrid.push(slidePosition);
          slidePosition = slidePosition + slideSize + spaceBetween;
        }
        swiper2.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
      }
      swiper2.virtualSize = Math.max(swiper2.virtualSize, swiperSize) + offsetAfter;
      if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
        wrapperEl.style.width = `${swiper2.virtualSize + spaceBetween}px`;
      }
      if (params.setWrapperSize) {
        wrapperEl.style[getDirectionLabel("width")] = `${swiper2.virtualSize + spaceBetween}px`;
      }
      if (gridEnabled) {
        swiper2.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
      }
      if (!params.centeredSlides) {
        const newSlidesGrid = [];
        for (let i2 = 0; i2 < snapGrid.length; i2 += 1) {
          let slidesGridItem = snapGrid[i2];
          if (params.roundLengths)
            slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[i2] <= swiper2.virtualSize - swiperSize) {
            newSlidesGrid.push(slidesGridItem);
          }
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper2.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
          snapGrid.push(swiper2.virtualSize - swiperSize);
        }
      }
      if (isVirtual && params.loop) {
        const size = slidesSizesGrid[0] + spaceBetween;
        if (params.slidesPerGroup > 1) {
          const groups = Math.ceil((swiper2.virtual.slidesBefore + swiper2.virtual.slidesAfter) / params.slidesPerGroup);
          const groupSize = size * params.slidesPerGroup;
          for (let i2 = 0; i2 < groups; i2 += 1) {
            snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
          }
        }
        for (let i2 = 0; i2 < swiper2.virtual.slidesBefore + swiper2.virtual.slidesAfter; i2 += 1) {
          if (params.slidesPerGroup === 1) {
            snapGrid.push(snapGrid[snapGrid.length - 1] + size);
          }
          slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
          swiper2.virtualSize += size;
        }
      }
      if (snapGrid.length === 0)
        snapGrid = [0];
      if (spaceBetween !== 0) {
        const key = swiper2.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
        slides.filter((_2, slideIndex) => {
          if (!params.cssMode || params.loop)
            return true;
          if (slideIndex === slides.length - 1) {
            return false;
          }
          return true;
        }).forEach((slideEl) => {
          slideEl.style[key] = `${spaceBetween}px`;
        });
      }
      if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue) => {
          allSlidesSize += slideSizeValue + (spaceBetween || 0);
        });
        allSlidesSize -= spaceBetween;
        const maxSnap = allSlidesSize - swiperSize;
        snapGrid = snapGrid.map((snap) => {
          if (snap <= 0)
            return -offsetBefore;
          if (snap > maxSnap)
            return maxSnap + offsetAfter;
          return snap;
        });
      }
      if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue) => {
          allSlidesSize += slideSizeValue + (spaceBetween || 0);
        });
        allSlidesSize -= spaceBetween;
        if (allSlidesSize < swiperSize) {
          const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
          snapGrid.forEach((snap, snapIndex) => {
            snapGrid[snapIndex] = snap - allSlidesOffset;
          });
          slidesGrid.forEach((snap, snapIndex) => {
            slidesGrid[snapIndex] = snap + allSlidesOffset;
          });
        }
      }
      Object.assign(swiper2, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
      });
      if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
        setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper2.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper2.snapGrid[0];
        const addToSlidesGrid = -swiper2.slidesGrid[0];
        swiper2.snapGrid = swiper2.snapGrid.map((v2) => v2 + addToSnapGrid);
        swiper2.slidesGrid = swiper2.slidesGrid.map((v2) => v2 + addToSlidesGrid);
      }
      if (slidesLength !== previousSlidesLength) {
        swiper2.emit("slidesLengthChange");
      }
      if (snapGrid.length !== previousSnapGridLength) {
        if (swiper2.params.watchOverflow)
          swiper2.checkOverflow();
        swiper2.emit("snapGridLengthChange");
      }
      if (slidesGrid.length !== previousSlidesGridLength) {
        swiper2.emit("slidesGridLengthChange");
      }
      if (params.watchSlidesProgress) {
        swiper2.updateSlidesOffset();
      }
      if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
        const hasClassBackfaceClassAdded = swiper2.el.classList.contains(backFaceHiddenClass);
        if (slidesLength <= params.maxBackfaceHiddenSlides) {
          if (!hasClassBackfaceClassAdded)
            swiper2.el.classList.add(backFaceHiddenClass);
        } else if (hasClassBackfaceClassAdded) {
          swiper2.el.classList.remove(backFaceHiddenClass);
        }
      }
    }
    function updateAutoHeight(speed) {
      const swiper2 = this;
      const activeSlides = [];
      const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
      let newHeight = 0;
      let i2;
      if (typeof speed === "number") {
        swiper2.setTransition(speed);
      } else if (speed === true) {
        swiper2.setTransition(swiper2.params.speed);
      }
      const getSlideByIndex = (index) => {
        if (isVirtual) {
          return swiper2.slides[swiper2.getSlideIndexByData(index)];
        }
        return swiper2.slides[index];
      };
      if (swiper2.params.slidesPerView !== "auto" && swiper2.params.slidesPerView > 1) {
        if (swiper2.params.centeredSlides) {
          (swiper2.visibleSlides || []).forEach((slide2) => {
            activeSlides.push(slide2);
          });
        } else {
          for (i2 = 0; i2 < Math.ceil(swiper2.params.slidesPerView); i2 += 1) {
            const index = swiper2.activeIndex + i2;
            if (index > swiper2.slides.length && !isVirtual)
              break;
            activeSlides.push(getSlideByIndex(index));
          }
        }
      } else {
        activeSlides.push(getSlideByIndex(swiper2.activeIndex));
      }
      for (i2 = 0; i2 < activeSlides.length; i2 += 1) {
        if (typeof activeSlides[i2] !== "undefined") {
          const height2 = activeSlides[i2].offsetHeight;
          newHeight = height2 > newHeight ? height2 : newHeight;
        }
      }
      if (newHeight || newHeight === 0)
        swiper2.wrapperEl.style.height = `${newHeight}px`;
    }
    function updateSlidesOffset() {
      const swiper2 = this;
      const slides = swiper2.slides;
      const minusOffset = swiper2.isElement ? swiper2.isHorizontal() ? swiper2.wrapperEl.offsetLeft : swiper2.wrapperEl.offsetTop : 0;
      for (let i2 = 0; i2 < slides.length; i2 += 1) {
        slides[i2].swiperSlideOffset = (swiper2.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop) - minusOffset - swiper2.cssOverflowAdjustment();
      }
    }
    function updateSlidesProgress(translate2) {
      if (translate2 === void 0) {
        translate2 = this && this.translate || 0;
      }
      const swiper2 = this;
      const params = swiper2.params;
      const {
        slides,
        rtlTranslate: rtl,
        snapGrid
      } = swiper2;
      if (slides.length === 0)
        return;
      if (typeof slides[0].swiperSlideOffset === "undefined")
        swiper2.updateSlidesOffset();
      let offsetCenter = -translate2;
      if (rtl)
        offsetCenter = translate2;
      slides.forEach((slideEl) => {
        slideEl.classList.remove(params.slideVisibleClass);
      });
      swiper2.visibleSlidesIndexes = [];
      swiper2.visibleSlides = [];
      let spaceBetween = params.spaceBetween;
      if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper2.size;
      } else if (typeof spaceBetween === "string") {
        spaceBetween = parseFloat(spaceBetween);
      }
      for (let i2 = 0; i2 < slides.length; i2 += 1) {
        const slide2 = slides[i2];
        let slideOffset = slide2.swiperSlideOffset;
        if (params.cssMode && params.centeredSlides) {
          slideOffset -= slides[0].swiperSlideOffset;
        }
        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper2.slidesSizesGrid[i2];
        const isVisible = slideBefore >= 0 && slideBefore < swiper2.size - 1 || slideAfter > 1 && slideAfter <= swiper2.size || slideBefore <= 0 && slideAfter >= swiper2.size;
        if (isVisible) {
          swiper2.visibleSlides.push(slide2);
          swiper2.visibleSlidesIndexes.push(i2);
          slides[i2].classList.add(params.slideVisibleClass);
        }
        slide2.progress = rtl ? -slideProgress : slideProgress;
        slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
      }
    }
    function updateProgress(translate2) {
      const swiper2 = this;
      if (typeof translate2 === "undefined") {
        const multiplier = swiper2.rtlTranslate ? -1 : 1;
        translate2 = swiper2 && swiper2.translate && swiper2.translate * multiplier || 0;
      }
      const params = swiper2.params;
      const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
      let {
        progress,
        isBeginning,
        isEnd,
        progressLoop
      } = swiper2;
      const wasBeginning = isBeginning;
      const wasEnd = isEnd;
      if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
      } else {
        progress = (translate2 - swiper2.minTranslate()) / translatesDiff;
        const isBeginningRounded = Math.abs(translate2 - swiper2.minTranslate()) < 1;
        const isEndRounded = Math.abs(translate2 - swiper2.maxTranslate()) < 1;
        isBeginning = isBeginningRounded || progress <= 0;
        isEnd = isEndRounded || progress >= 1;
        if (isBeginningRounded)
          progress = 0;
        if (isEndRounded)
          progress = 1;
      }
      if (params.loop) {
        const firstSlideIndex = swiper2.getSlideIndexByData(0);
        const lastSlideIndex = swiper2.getSlideIndexByData(swiper2.slides.length - 1);
        const firstSlideTranslate = swiper2.slidesGrid[firstSlideIndex];
        const lastSlideTranslate = swiper2.slidesGrid[lastSlideIndex];
        const translateMax = swiper2.slidesGrid[swiper2.slidesGrid.length - 1];
        const translateAbs = Math.abs(translate2);
        if (translateAbs >= firstSlideTranslate) {
          progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
        } else {
          progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
        }
        if (progressLoop > 1)
          progressLoop -= 1;
      }
      Object.assign(swiper2, {
        progress,
        progressLoop,
        isBeginning,
        isEnd
      });
      if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
        swiper2.updateSlidesProgress(translate2);
      if (isBeginning && !wasBeginning) {
        swiper2.emit("reachBeginning toEdge");
      }
      if (isEnd && !wasEnd) {
        swiper2.emit("reachEnd toEdge");
      }
      if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper2.emit("fromEdge");
      }
      swiper2.emit("progress", progress);
    }
    function updateSlidesClasses() {
      const swiper2 = this;
      const {
        slides,
        params,
        slidesEl,
        activeIndex
      } = swiper2;
      const isVirtual = swiper2.virtual && params.virtual.enabled;
      const getFilteredSlide = (selector) => {
        return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
      };
      slides.forEach((slideEl) => {
        slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
      });
      let activeSlide;
      if (isVirtual) {
        if (params.loop) {
          let slideIndex = activeIndex - swiper2.virtual.slidesBefore;
          if (slideIndex < 0)
            slideIndex = swiper2.virtual.slides.length + slideIndex;
          if (slideIndex >= swiper2.virtual.slides.length)
            slideIndex -= swiper2.virtual.slides.length;
          activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
        } else {
          activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
        }
      } else {
        activeSlide = slides[activeIndex];
      }
      if (activeSlide) {
        activeSlide.classList.add(params.slideActiveClass);
        let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !nextSlide) {
          nextSlide = slides[0];
        }
        if (nextSlide) {
          nextSlide.classList.add(params.slideNextClass);
        }
        let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
        if (params.loop && !prevSlide === 0) {
          prevSlide = slides[slides.length - 1];
        }
        if (prevSlide) {
          prevSlide.classList.add(params.slidePrevClass);
        }
      }
      swiper2.emitSlidesClasses();
    }
    const processLazyPreloader = (swiper2, imageEl) => {
      if (!swiper2 || swiper2.destroyed || !swiper2.params)
        return;
      const slideSelector = () => swiper2.isElement ? `swiper-slide` : `.${swiper2.params.slideClass}`;
      const slideEl = imageEl.closest(slideSelector());
      if (slideEl) {
        let lazyEl = slideEl.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
        if (!lazyEl && swiper2.isElement) {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
          } else {
            requestAnimationFrame(() => {
              if (slideEl.shadowRoot) {
                lazyEl = slideEl.shadowRoot.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
                if (lazyEl)
                  lazyEl.remove();
              }
            });
          }
        }
        if (lazyEl)
          lazyEl.remove();
      }
    };
    const unlazy = (swiper2, index) => {
      if (!swiper2.slides[index])
        return;
      const imageEl = swiper2.slides[index].querySelector('[loading="lazy"]');
      if (imageEl)
        imageEl.removeAttribute("loading");
    };
    const preload = (swiper2) => {
      if (!swiper2 || swiper2.destroyed || !swiper2.params)
        return;
      let amount = swiper2.params.lazyPreloadPrevNext;
      const len = swiper2.slides.length;
      if (!len || !amount || amount < 0)
        return;
      amount = Math.min(amount, len);
      const slidesPerView = swiper2.params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(swiper2.params.slidesPerView);
      const activeIndex = swiper2.activeIndex;
      if (swiper2.params.grid && swiper2.params.grid.rows > 1) {
        const activeColumn = activeIndex;
        const preloadColumns = [activeColumn - amount];
        preloadColumns.push(...Array.from({
          length: amount
        }).map((_2, i2) => {
          return activeColumn + slidesPerView + i2;
        }));
        swiper2.slides.forEach((slideEl, i2) => {
          if (preloadColumns.includes(slideEl.column))
            unlazy(swiper2, i2);
        });
        return;
      }
      const slideIndexLastInView = activeIndex + slidesPerView - 1;
      if (swiper2.params.rewind || swiper2.params.loop) {
        for (let i2 = activeIndex - amount; i2 <= slideIndexLastInView + amount; i2 += 1) {
          const realIndex = (i2 % len + len) % len;
          if (realIndex < activeIndex || realIndex > slideIndexLastInView)
            unlazy(swiper2, realIndex);
        }
      } else {
        for (let i2 = Math.max(activeIndex - amount, 0); i2 <= Math.min(slideIndexLastInView + amount, len - 1); i2 += 1) {
          if (i2 !== activeIndex && (i2 > slideIndexLastInView || i2 < activeIndex)) {
            unlazy(swiper2, i2);
          }
        }
      }
    };
    function getActiveIndexByTranslate(swiper2) {
      const {
        slidesGrid,
        params
      } = swiper2;
      const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
      let activeIndex;
      for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
        if (typeof slidesGrid[i2 + 1] !== "undefined") {
          if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) {
            activeIndex = i2;
          } else if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1]) {
            activeIndex = i2 + 1;
          }
        } else if (translate2 >= slidesGrid[i2]) {
          activeIndex = i2;
        }
      }
      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === "undefined")
          activeIndex = 0;
      }
      return activeIndex;
    }
    function updateActiveIndex(newActiveIndex) {
      const swiper2 = this;
      const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
      const {
        snapGrid,
        params,
        activeIndex: previousIndex,
        realIndex: previousRealIndex,
        snapIndex: previousSnapIndex
      } = swiper2;
      let activeIndex = newActiveIndex;
      let snapIndex;
      const getVirtualRealIndex = (aIndex) => {
        let realIndex2 = aIndex - swiper2.virtual.slidesBefore;
        if (realIndex2 < 0) {
          realIndex2 = swiper2.virtual.slides.length + realIndex2;
        }
        if (realIndex2 >= swiper2.virtual.slides.length) {
          realIndex2 -= swiper2.virtual.slides.length;
        }
        return realIndex2;
      };
      if (typeof activeIndex === "undefined") {
        activeIndex = getActiveIndexByTranslate(swiper2);
      }
      if (snapGrid.indexOf(translate2) >= 0) {
        snapIndex = snapGrid.indexOf(translate2);
      } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
      }
      if (snapIndex >= snapGrid.length)
        snapIndex = snapGrid.length - 1;
      if (activeIndex === previousIndex) {
        if (snapIndex !== previousSnapIndex) {
          swiper2.snapIndex = snapIndex;
          swiper2.emit("snapIndexChange");
        }
        if (swiper2.params.loop && swiper2.virtual && swiper2.params.virtual.enabled) {
          swiper2.realIndex = getVirtualRealIndex(activeIndex);
        }
        return;
      }
      let realIndex;
      if (swiper2.virtual && params.virtual.enabled && params.loop) {
        realIndex = getVirtualRealIndex(activeIndex);
      } else if (swiper2.slides[activeIndex]) {
        realIndex = parseInt(swiper2.slides[activeIndex].getAttribute("data-swiper-slide-index") || activeIndex, 10);
      } else {
        realIndex = activeIndex;
      }
      Object.assign(swiper2, {
        previousSnapIndex,
        snapIndex,
        previousRealIndex,
        realIndex,
        previousIndex,
        activeIndex
      });
      if (swiper2.initialized) {
        preload(swiper2);
      }
      swiper2.emit("activeIndexChange");
      swiper2.emit("snapIndexChange");
      if (swiper2.initialized || swiper2.params.runCallbacksOnInit) {
        if (previousRealIndex !== realIndex) {
          swiper2.emit("realIndexChange");
        }
        swiper2.emit("slideChange");
      }
    }
    function updateClickedSlide(el2, path) {
      const swiper2 = this;
      const params = swiper2.params;
      let slide2 = el2.closest(`.${params.slideClass}, swiper-slide`);
      if (!slide2 && swiper2.isElement && path && path.length > 1 && path.includes(el2)) {
        [...path.slice(path.indexOf(el2) + 1, path.length)].forEach((pathEl) => {
          if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
            slide2 = pathEl;
          }
        });
      }
      let slideFound = false;
      let slideIndex;
      if (slide2) {
        for (let i2 = 0; i2 < swiper2.slides.length; i2 += 1) {
          if (swiper2.slides[i2] === slide2) {
            slideFound = true;
            slideIndex = i2;
            break;
          }
        }
      }
      if (slide2 && slideFound) {
        swiper2.clickedSlide = slide2;
        if (swiper2.virtual && swiper2.params.virtual.enabled) {
          swiper2.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
        } else {
          swiper2.clickedIndex = slideIndex;
        }
      } else {
        swiper2.clickedSlide = void 0;
        swiper2.clickedIndex = void 0;
        return;
      }
      if (params.slideToClickedSlide && swiper2.clickedIndex !== void 0 && swiper2.clickedIndex !== swiper2.activeIndex) {
        swiper2.slideToClickedSlide();
      }
    }
    var update = {
      updateSize,
      updateSlides,
      updateAutoHeight,
      updateSlidesOffset,
      updateSlidesProgress,
      updateProgress,
      updateSlidesClasses,
      updateActiveIndex,
      updateClickedSlide
    };
    function getSwiperTranslate(axis) {
      if (axis === void 0) {
        axis = this.isHorizontal() ? "x" : "y";
      }
      const swiper2 = this;
      const {
        params,
        rtlTranslate: rtl,
        translate: translate2,
        wrapperEl
      } = swiper2;
      if (params.virtualTranslate) {
        return rtl ? -translate2 : translate2;
      }
      if (params.cssMode) {
        return translate2;
      }
      let currentTranslate = getTranslate(wrapperEl, axis);
      currentTranslate += swiper2.cssOverflowAdjustment();
      if (rtl)
        currentTranslate = -currentTranslate;
      return currentTranslate || 0;
    }
    function setTranslate(translate2, byController) {
      const swiper2 = this;
      const {
        rtlTranslate: rtl,
        params,
        wrapperEl,
        progress
      } = swiper2;
      let x2 = 0;
      let y2 = 0;
      const z2 = 0;
      if (swiper2.isHorizontal()) {
        x2 = rtl ? -translate2 : translate2;
      } else {
        y2 = translate2;
      }
      if (params.roundLengths) {
        x2 = Math.floor(x2);
        y2 = Math.floor(y2);
      }
      swiper2.previousTranslate = swiper2.translate;
      swiper2.translate = swiper2.isHorizontal() ? x2 : y2;
      if (params.cssMode) {
        wrapperEl[swiper2.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper2.isHorizontal() ? -x2 : -y2;
      } else if (!params.virtualTranslate) {
        if (swiper2.isHorizontal()) {
          x2 -= swiper2.cssOverflowAdjustment();
        } else {
          y2 -= swiper2.cssOverflowAdjustment();
        }
        wrapperEl.style.transform = `translate3d(${x2}px, ${y2}px, ${z2}px)`;
      }
      let newProgress;
      const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (translate2 - swiper2.minTranslate()) / translatesDiff;
      }
      if (newProgress !== progress) {
        swiper2.updateProgress(translate2);
      }
      swiper2.emit("setTranslate", swiper2.translate, byController);
    }
    function minTranslate() {
      return -this.snapGrid[0];
    }
    function maxTranslate() {
      return -this.snapGrid[this.snapGrid.length - 1];
    }
    function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
      if (translate2 === void 0) {
        translate2 = 0;
      }
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      if (translateBounds === void 0) {
        translateBounds = true;
      }
      const swiper2 = this;
      const {
        params,
        wrapperEl
      } = swiper2;
      if (swiper2.animating && params.preventInteractionOnTransition) {
        return false;
      }
      const minTranslate2 = swiper2.minTranslate();
      const maxTranslate2 = swiper2.maxTranslate();
      let newTranslate;
      if (translateBounds && translate2 > minTranslate2)
        newTranslate = minTranslate2;
      else if (translateBounds && translate2 < maxTranslate2)
        newTranslate = maxTranslate2;
      else
        newTranslate = translate2;
      swiper2.updateProgress(newTranslate);
      if (params.cssMode) {
        const isH = swiper2.isHorizontal();
        if (speed === 0) {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
        } else {
          if (!swiper2.support.smoothScroll) {
            animateCSSModeScroll({
              swiper: swiper2,
              targetPosition: -newTranslate,
              side: isH ? "left" : "top"
            });
            return true;
          }
          wrapperEl.scrollTo({
            [isH ? "left" : "top"]: -newTranslate,
            behavior: "smooth"
          });
        }
        return true;
      }
      if (speed === 0) {
        swiper2.setTransition(0);
        swiper2.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper2.emit("beforeTransitionStart", speed, internal);
          swiper2.emit("transitionEnd");
        }
      } else {
        swiper2.setTransition(speed);
        swiper2.setTranslate(newTranslate);
        if (runCallbacks) {
          swiper2.emit("beforeTransitionStart", speed, internal);
          swiper2.emit("transitionStart");
        }
        if (!swiper2.animating) {
          swiper2.animating = true;
          if (!swiper2.onTranslateToWrapperTransitionEnd) {
            swiper2.onTranslateToWrapperTransitionEnd = function transitionEnd2(e2) {
              if (!swiper2 || swiper2.destroyed)
                return;
              if (e2.target !== this)
                return;
              swiper2.wrapperEl.removeEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
              swiper2.onTranslateToWrapperTransitionEnd = null;
              delete swiper2.onTranslateToWrapperTransitionEnd;
              if (runCallbacks) {
                swiper2.emit("transitionEnd");
              }
            };
          }
          swiper2.wrapperEl.addEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
        }
      }
      return true;
    }
    var translate = {
      getTranslate: getSwiperTranslate,
      setTranslate,
      minTranslate,
      maxTranslate,
      translateTo
    };
    function setTransition(duration2, byController) {
      const swiper2 = this;
      if (!swiper2.params.cssMode) {
        swiper2.wrapperEl.style.transitionDuration = `${duration2}ms`;
        swiper2.wrapperEl.style.transitionDelay = duration2 === 0 ? `0ms` : "";
      }
      swiper2.emit("setTransition", duration2, byController);
    }
    function transitionEmit(_ref) {
      let {
        swiper: swiper2,
        runCallbacks,
        direction,
        step
      } = _ref;
      const {
        activeIndex,
        previousIndex
      } = swiper2;
      let dir = direction;
      if (!dir) {
        if (activeIndex > previousIndex)
          dir = "next";
        else if (activeIndex < previousIndex)
          dir = "prev";
        else
          dir = "reset";
      }
      swiper2.emit(`transition${step}`);
      if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === "reset") {
          swiper2.emit(`slideResetTransition${step}`);
          return;
        }
        swiper2.emit(`slideChangeTransition${step}`);
        if (dir === "next") {
          swiper2.emit(`slideNextTransition${step}`);
        } else {
          swiper2.emit(`slidePrevTransition${step}`);
        }
      }
    }
    function transitionStart(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper2 = this;
      const {
        params
      } = swiper2;
      if (params.cssMode)
        return;
      if (params.autoHeight) {
        swiper2.updateAutoHeight();
      }
      transitionEmit({
        swiper: swiper2,
        runCallbacks,
        direction,
        step: "Start"
      });
    }
    function transitionEnd(runCallbacks, direction) {
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper2 = this;
      const {
        params
      } = swiper2;
      swiper2.animating = false;
      if (params.cssMode)
        return;
      swiper2.setTransition(0);
      transitionEmit({
        swiper: swiper2,
        runCallbacks,
        direction,
        step: "End"
      });
    }
    var transition = {
      setTransition,
      transitionStart,
      transitionEnd
    };
    function slideTo(index, speed, runCallbacks, internal, initial) {
      if (index === void 0) {
        index = 0;
      }
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      if (typeof index === "string") {
        index = parseInt(index, 10);
      }
      const swiper2 = this;
      let slideIndex = index;
      if (slideIndex < 0)
        slideIndex = 0;
      const {
        params,
        snapGrid,
        slidesGrid,
        previousIndex,
        activeIndex,
        rtlTranslate: rtl,
        wrapperEl,
        enabled
      } = swiper2;
      if (swiper2.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
        return false;
      }
      const skip = Math.min(swiper2.params.slidesPerGroupSkip, slideIndex);
      let snapIndex = skip + Math.floor((slideIndex - skip) / swiper2.params.slidesPerGroup);
      if (snapIndex >= snapGrid.length)
        snapIndex = snapGrid.length - 1;
      const translate2 = -snapGrid[snapIndex];
      if (params.normalizeSlideIndex) {
        for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
          const normalizedTranslate = -Math.floor(translate2 * 100);
          const normalizedGrid = Math.floor(slidesGrid[i2] * 100);
          const normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
          if (typeof slidesGrid[i2 + 1] !== "undefined") {
            if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
              slideIndex = i2;
            } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
              slideIndex = i2 + 1;
            }
          } else if (normalizedTranslate >= normalizedGrid) {
            slideIndex = i2;
          }
        }
      }
      if (swiper2.initialized && slideIndex !== activeIndex) {
        if (!swiper2.allowSlideNext && (rtl ? translate2 > swiper2.translate && translate2 > swiper2.minTranslate() : translate2 < swiper2.translate && translate2 < swiper2.minTranslate())) {
          return false;
        }
        if (!swiper2.allowSlidePrev && translate2 > swiper2.translate && translate2 > swiper2.maxTranslate()) {
          if ((activeIndex || 0) !== slideIndex) {
            return false;
          }
        }
      }
      if (slideIndex !== (previousIndex || 0) && runCallbacks) {
        swiper2.emit("beforeSlideChangeStart");
      }
      swiper2.updateProgress(translate2);
      let direction;
      if (slideIndex > activeIndex)
        direction = "next";
      else if (slideIndex < activeIndex)
        direction = "prev";
      else
        direction = "reset";
      if (rtl && -translate2 === swiper2.translate || !rtl && translate2 === swiper2.translate) {
        swiper2.updateActiveIndex(slideIndex);
        if (params.autoHeight) {
          swiper2.updateAutoHeight();
        }
        swiper2.updateSlidesClasses();
        if (params.effect !== "slide") {
          swiper2.setTranslate(translate2);
        }
        if (direction !== "reset") {
          swiper2.transitionStart(runCallbacks, direction);
          swiper2.transitionEnd(runCallbacks, direction);
        }
        return false;
      }
      if (params.cssMode) {
        const isH = swiper2.isHorizontal();
        const t2 = rtl ? translate2 : -translate2;
        if (speed === 0) {
          const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
          if (isVirtual) {
            swiper2.wrapperEl.style.scrollSnapType = "none";
            swiper2._immediateVirtual = true;
          }
          if (isVirtual && !swiper2._cssModeVirtualInitialSet && swiper2.params.initialSlide > 0) {
            swiper2._cssModeVirtualInitialSet = true;
            requestAnimationFrame(() => {
              wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
            });
          } else {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
          }
          if (isVirtual) {
            requestAnimationFrame(() => {
              swiper2.wrapperEl.style.scrollSnapType = "";
              swiper2._immediateVirtual = false;
            });
          }
        } else {
          if (!swiper2.support.smoothScroll) {
            animateCSSModeScroll({
              swiper: swiper2,
              targetPosition: t2,
              side: isH ? "left" : "top"
            });
            return true;
          }
          wrapperEl.scrollTo({
            [isH ? "left" : "top"]: t2,
            behavior: "smooth"
          });
        }
        return true;
      }
      swiper2.setTransition(speed);
      swiper2.setTranslate(translate2);
      swiper2.updateActiveIndex(slideIndex);
      swiper2.updateSlidesClasses();
      swiper2.emit("beforeTransitionStart", speed, internal);
      swiper2.transitionStart(runCallbacks, direction);
      if (speed === 0) {
        swiper2.transitionEnd(runCallbacks, direction);
      } else if (!swiper2.animating) {
        swiper2.animating = true;
        if (!swiper2.onSlideToWrapperTransitionEnd) {
          swiper2.onSlideToWrapperTransitionEnd = function transitionEnd2(e2) {
            if (!swiper2 || swiper2.destroyed)
              return;
            if (e2.target !== this)
              return;
            swiper2.wrapperEl.removeEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
            swiper2.onSlideToWrapperTransitionEnd = null;
            delete swiper2.onSlideToWrapperTransitionEnd;
            swiper2.transitionEnd(runCallbacks, direction);
          };
        }
        swiper2.wrapperEl.addEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
      }
      return true;
    }
    function slideToLoop(index, speed, runCallbacks, internal) {
      if (index === void 0) {
        index = 0;
      }
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      if (typeof index === "string") {
        const indexAsNumber = parseInt(index, 10);
        index = indexAsNumber;
      }
      const swiper2 = this;
      let newIndex = index;
      if (swiper2.params.loop) {
        if (swiper2.virtual && swiper2.params.virtual.enabled) {
          newIndex = newIndex + swiper2.virtual.slidesBefore;
        } else {
          newIndex = swiper2.getSlideIndexByData(newIndex);
        }
      }
      return swiper2.slideTo(newIndex, speed, runCallbacks, internal);
    }
    function slideNext(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper2 = this;
      const {
        enabled,
        params,
        animating
      } = swiper2;
      if (!enabled)
        return swiper2;
      let perGroup = params.slidesPerGroup;
      if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper2.slidesPerViewDynamic("current", true), 1);
      }
      const increment = swiper2.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
      const isVirtual = swiper2.virtual && params.virtual.enabled;
      if (params.loop) {
        if (animating && !isVirtual && params.loopPreventsSliding)
          return false;
        swiper2.loopFix({
          direction: "next"
        });
        swiper2._clientLeft = swiper2.wrapperEl.clientLeft;
        if (swiper2.activeIndex === swiper2.slides.length - 1 && params.cssMode) {
          requestAnimationFrame(() => {
            swiper2.slideTo(swiper2.activeIndex + increment, speed, runCallbacks, internal);
          });
          return true;
        }
      }
      if (params.rewind && swiper2.isEnd) {
        return swiper2.slideTo(0, speed, runCallbacks, internal);
      }
      return swiper2.slideTo(swiper2.activeIndex + increment, speed, runCallbacks, internal);
    }
    function slidePrev(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper2 = this;
      const {
        params,
        snapGrid,
        slidesGrid,
        rtlTranslate,
        enabled,
        animating
      } = swiper2;
      if (!enabled)
        return swiper2;
      const isVirtual = swiper2.virtual && params.virtual.enabled;
      if (params.loop) {
        if (animating && !isVirtual && params.loopPreventsSliding)
          return false;
        swiper2.loopFix({
          direction: "prev"
        });
        swiper2._clientLeft = swiper2.wrapperEl.clientLeft;
      }
      const translate2 = rtlTranslate ? swiper2.translate : -swiper2.translate;
      function normalize2(val) {
        if (val < 0)
          return -Math.floor(Math.abs(val));
        return Math.floor(val);
      }
      const normalizedTranslate = normalize2(translate2);
      const normalizedSnapGrid = snapGrid.map((val) => normalize2(val));
      let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
      if (typeof prevSnap === "undefined" && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach((snap, snapIndex) => {
          if (normalizedTranslate >= snap) {
            prevSnapIndex = snapIndex;
          }
        });
        if (typeof prevSnapIndex !== "undefined") {
          prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
      }
      let prevIndex = 0;
      if (typeof prevSnap !== "undefined") {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0)
          prevIndex = swiper2.activeIndex - 1;
        if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
          prevIndex = prevIndex - swiper2.slidesPerViewDynamic("previous", true) + 1;
          prevIndex = Math.max(prevIndex, 0);
        }
      }
      if (params.rewind && swiper2.isBeginning) {
        const lastIndex = swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
        return swiper2.slideTo(lastIndex, speed, runCallbacks, internal);
      } else if (params.loop && swiper2.activeIndex === 0 && params.cssMode) {
        requestAnimationFrame(() => {
          swiper2.slideTo(prevIndex, speed, runCallbacks, internal);
        });
        return true;
      }
      return swiper2.slideTo(prevIndex, speed, runCallbacks, internal);
    }
    function slideReset(speed, runCallbacks, internal) {
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      const swiper2 = this;
      return swiper2.slideTo(swiper2.activeIndex, speed, runCallbacks, internal);
    }
    function slideToClosest(speed, runCallbacks, internal, threshold) {
      if (speed === void 0) {
        speed = this.params.speed;
      }
      if (runCallbacks === void 0) {
        runCallbacks = true;
      }
      if (threshold === void 0) {
        threshold = 0.5;
      }
      const swiper2 = this;
      let index = swiper2.activeIndex;
      const skip = Math.min(swiper2.params.slidesPerGroupSkip, index);
      const snapIndex = skip + Math.floor((index - skip) / swiper2.params.slidesPerGroup);
      const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
      if (translate2 >= swiper2.snapGrid[snapIndex]) {
        const currentSnap = swiper2.snapGrid[snapIndex];
        const nextSnap = swiper2.snapGrid[snapIndex + 1];
        if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
          index += swiper2.params.slidesPerGroup;
        }
      } else {
        const prevSnap = swiper2.snapGrid[snapIndex - 1];
        const currentSnap = swiper2.snapGrid[snapIndex];
        if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
          index -= swiper2.params.slidesPerGroup;
        }
      }
      index = Math.max(index, 0);
      index = Math.min(index, swiper2.slidesGrid.length - 1);
      return swiper2.slideTo(index, speed, runCallbacks, internal);
    }
    function slideToClickedSlide() {
      const swiper2 = this;
      const {
        params,
        slidesEl
      } = swiper2;
      const slidesPerView = params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : params.slidesPerView;
      let slideToIndex = swiper2.clickedIndex;
      let realIndex;
      const slideSelector = swiper2.isElement ? `swiper-slide` : `.${params.slideClass}`;
      if (params.loop) {
        if (swiper2.animating)
          return;
        realIndex = parseInt(swiper2.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
        if (params.centeredSlides) {
          if (slideToIndex < swiper2.loopedSlides - slidesPerView / 2 || slideToIndex > swiper2.slides.length - swiper2.loopedSlides + slidesPerView / 2) {
            swiper2.loopFix();
            slideToIndex = swiper2.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
            nextTick(() => {
              swiper2.slideTo(slideToIndex);
            });
          } else {
            swiper2.slideTo(slideToIndex);
          }
        } else if (slideToIndex > swiper2.slides.length - slidesPerView) {
          swiper2.loopFix();
          slideToIndex = swiper2.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
          nextTick(() => {
            swiper2.slideTo(slideToIndex);
          });
        } else {
          swiper2.slideTo(slideToIndex);
        }
      } else {
        swiper2.slideTo(slideToIndex);
      }
    }
    var slide = {
      slideTo,
      slideToLoop,
      slideNext,
      slidePrev,
      slideReset,
      slideToClosest,
      slideToClickedSlide
    };
    function loopCreate(slideRealIndex) {
      const swiper2 = this;
      const {
        params,
        slidesEl
      } = swiper2;
      if (!params.loop || swiper2.virtual && swiper2.params.virtual.enabled)
        return;
      const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      slides.forEach((el2, index) => {
        el2.setAttribute("data-swiper-slide-index", index);
      });
      swiper2.loopFix({
        slideRealIndex,
        direction: params.centeredSlides ? void 0 : "next"
      });
    }
    function loopFix(_temp) {
      let {
        slideRealIndex,
        slideTo: slideTo2 = true,
        direction,
        setTranslate: setTranslate2,
        activeSlideIndex,
        byController,
        byMousewheel
      } = _temp === void 0 ? {} : _temp;
      const swiper2 = this;
      if (!swiper2.params.loop)
        return;
      swiper2.emit("beforeLoopFix");
      const {
        slides,
        allowSlidePrev,
        allowSlideNext,
        slidesEl,
        params
      } = swiper2;
      swiper2.allowSlidePrev = true;
      swiper2.allowSlideNext = true;
      if (swiper2.virtual && params.virtual.enabled) {
        if (slideTo2) {
          if (!params.centeredSlides && swiper2.snapIndex === 0) {
            swiper2.slideTo(swiper2.virtual.slides.length, 0, false, true);
          } else if (params.centeredSlides && swiper2.snapIndex < params.slidesPerView) {
            swiper2.slideTo(swiper2.virtual.slides.length + swiper2.snapIndex, 0, false, true);
          } else if (swiper2.snapIndex === swiper2.snapGrid.length - 1) {
            swiper2.slideTo(swiper2.virtual.slidesBefore, 0, false, true);
          }
        }
        swiper2.allowSlidePrev = allowSlidePrev;
        swiper2.allowSlideNext = allowSlideNext;
        swiper2.emit("loopFix");
        return;
      }
      const slidesPerView = params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
      let loopedSlides = params.loopedSlides || slidesPerView;
      if (loopedSlides % params.slidesPerGroup !== 0) {
        loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
      }
      swiper2.loopedSlides = loopedSlides;
      const prependSlidesIndexes = [];
      const appendSlidesIndexes = [];
      let activeIndex = swiper2.activeIndex;
      if (typeof activeSlideIndex === "undefined") {
        activeSlideIndex = swiper2.getSlideIndex(swiper2.slides.filter((el2) => el2.classList.contains(params.slideActiveClass))[0]);
      } else {
        activeIndex = activeSlideIndex;
      }
      const isNext = direction === "next" || !direction;
      const isPrev = direction === "prev" || !direction;
      let slidesPrepended = 0;
      let slidesAppended = 0;
      if (activeSlideIndex < loopedSlides) {
        slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
        for (let i2 = 0; i2 < loopedSlides - activeSlideIndex; i2 += 1) {
          const index = i2 - Math.floor(i2 / slides.length) * slides.length;
          prependSlidesIndexes.push(slides.length - index - 1);
        }
      } else if (activeSlideIndex > swiper2.slides.length - loopedSlides * 2) {
        slidesAppended = Math.max(activeSlideIndex - (swiper2.slides.length - loopedSlides * 2), params.slidesPerGroup);
        for (let i2 = 0; i2 < slidesAppended; i2 += 1) {
          const index = i2 - Math.floor(i2 / slides.length) * slides.length;
          appendSlidesIndexes.push(index);
        }
      }
      if (isPrev) {
        prependSlidesIndexes.forEach((index) => {
          swiper2.slides[index].swiperLoopMoveDOM = true;
          slidesEl.prepend(swiper2.slides[index]);
          swiper2.slides[index].swiperLoopMoveDOM = false;
        });
      }
      if (isNext) {
        appendSlidesIndexes.forEach((index) => {
          swiper2.slides[index].swiperLoopMoveDOM = true;
          slidesEl.append(swiper2.slides[index]);
          swiper2.slides[index].swiperLoopMoveDOM = false;
        });
      }
      swiper2.recalcSlides();
      if (params.slidesPerView === "auto") {
        swiper2.updateSlides();
      }
      if (params.watchSlidesProgress) {
        swiper2.updateSlidesOffset();
      }
      if (slideTo2) {
        if (prependSlidesIndexes.length > 0 && isPrev) {
          if (typeof slideRealIndex === "undefined") {
            const currentSlideTranslate = swiper2.slidesGrid[activeIndex];
            const newSlideTranslate = swiper2.slidesGrid[activeIndex + slidesPrepended];
            const diff = newSlideTranslate - currentSlideTranslate;
            if (byMousewheel) {
              swiper2.setTranslate(swiper2.translate - diff);
            } else {
              swiper2.slideTo(activeIndex + slidesPrepended, 0, false, true);
              if (setTranslate2) {
                swiper2.touches[swiper2.isHorizontal() ? "startX" : "startY"] += diff;
                swiper2.touchEventsData.currentTranslate = swiper2.translate;
              }
            }
          } else {
            if (setTranslate2) {
              swiper2.slideToLoop(slideRealIndex, 0, false, true);
              swiper2.touchEventsData.currentTranslate = swiper2.translate;
            }
          }
        } else if (appendSlidesIndexes.length > 0 && isNext) {
          if (typeof slideRealIndex === "undefined") {
            const currentSlideTranslate = swiper2.slidesGrid[activeIndex];
            const newSlideTranslate = swiper2.slidesGrid[activeIndex - slidesAppended];
            const diff = newSlideTranslate - currentSlideTranslate;
            if (byMousewheel) {
              swiper2.setTranslate(swiper2.translate - diff);
            } else {
              swiper2.slideTo(activeIndex - slidesAppended, 0, false, true);
              if (setTranslate2) {
                swiper2.touches[swiper2.isHorizontal() ? "startX" : "startY"] += diff;
                swiper2.touchEventsData.currentTranslate = swiper2.translate;
              }
            }
          } else {
            swiper2.slideToLoop(slideRealIndex, 0, false, true);
          }
        }
      }
      swiper2.allowSlidePrev = allowSlidePrev;
      swiper2.allowSlideNext = allowSlideNext;
      if (swiper2.controller && swiper2.controller.control && !byController) {
        const loopParams = {
          slideRealIndex,
          direction,
          setTranslate: setTranslate2,
          activeSlideIndex,
          byController: true
        };
        if (Array.isArray(swiper2.controller.control)) {
          swiper2.controller.control.forEach((c2) => {
            if (!c2.destroyed && c2.params.loop)
              c2.loopFix({
                ...loopParams,
                slideTo: c2.params.slidesPerView === params.slidesPerView ? slideTo2 : false
              });
          });
        } else if (swiper2.controller.control instanceof swiper2.constructor && swiper2.controller.control.params.loop) {
          swiper2.controller.control.loopFix({
            ...loopParams,
            slideTo: swiper2.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
          });
        }
      }
      swiper2.emit("loopFix");
    }
    function loopDestroy() {
      const swiper2 = this;
      const {
        params,
        slidesEl
      } = swiper2;
      if (!params.loop || swiper2.virtual && swiper2.params.virtual.enabled)
        return;
      swiper2.recalcSlides();
      const newSlidesOrder = [];
      swiper2.slides.forEach((slideEl) => {
        const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
        newSlidesOrder[index] = slideEl;
      });
      swiper2.slides.forEach((slideEl) => {
        slideEl.removeAttribute("data-swiper-slide-index");
      });
      newSlidesOrder.forEach((slideEl) => {
        slidesEl.append(slideEl);
      });
      swiper2.recalcSlides();
      swiper2.slideTo(swiper2.realIndex, 0);
    }
    var loop = {
      loopCreate,
      loopFix,
      loopDestroy
    };
    function setGrabCursor(moving) {
      const swiper2 = this;
      if (!swiper2.params.simulateTouch || swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode)
        return;
      const el2 = swiper2.params.touchEventsTarget === "container" ? swiper2.el : swiper2.wrapperEl;
      if (swiper2.isElement) {
        swiper2.__preventObserver__ = true;
      }
      el2.style.cursor = "move";
      el2.style.cursor = moving ? "grabbing" : "grab";
      if (swiper2.isElement) {
        requestAnimationFrame(() => {
          swiper2.__preventObserver__ = false;
        });
      }
    }
    function unsetGrabCursor() {
      const swiper2 = this;
      if (swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode) {
        return;
      }
      if (swiper2.isElement) {
        swiper2.__preventObserver__ = true;
      }
      swiper2[swiper2.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
      if (swiper2.isElement) {
        requestAnimationFrame(() => {
          swiper2.__preventObserver__ = false;
        });
      }
    }
    var grabCursor = {
      setGrabCursor,
      unsetGrabCursor
    };
    function closestElement(selector, base) {
      if (base === void 0) {
        base = this;
      }
      function __closestFrom(el2) {
        if (!el2 || el2 === getDocument() || el2 === getWindow())
          return null;
        if (el2.assignedSlot)
          el2 = el2.assignedSlot;
        const found = el2.closest(selector);
        if (!found && !el2.getRootNode) {
          return null;
        }
        return found || __closestFrom(el2.getRootNode().host);
      }
      return __closestFrom(base);
    }
    function onTouchStart(event) {
      const swiper2 = this;
      const document2 = getDocument();
      const window2 = getWindow();
      const data = swiper2.touchEventsData;
      data.evCache.push(event);
      const {
        params,
        touches,
        enabled
      } = swiper2;
      if (!enabled)
        return;
      if (!params.simulateTouch && event.pointerType === "mouse")
        return;
      if (swiper2.animating && params.preventInteractionOnTransition) {
        return;
      }
      if (!swiper2.animating && params.cssMode && params.loop) {
        swiper2.loopFix();
      }
      let e2 = event;
      if (e2.originalEvent)
        e2 = e2.originalEvent;
      let targetEl = e2.target;
      if (params.touchEventsTarget === "wrapper") {
        if (!swiper2.wrapperEl.contains(targetEl))
          return;
      }
      if ("which" in e2 && e2.which === 3)
        return;
      if ("button" in e2 && e2.button > 0)
        return;
      if (data.isTouched && data.isMoved)
        return;
      const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
      const eventPath = event.composedPath ? event.composedPath() : event.path;
      if (swipingClassHasValue && e2.target && e2.target.shadowRoot && eventPath) {
        targetEl = eventPath[0];
      }
      const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
      const isTargetShadow = !!(e2.target && e2.target.shadowRoot);
      if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
        swiper2.allowClick = true;
        return;
      }
      if (params.swipeHandler) {
        if (!targetEl.closest(params.swipeHandler))
          return;
      }
      touches.currentX = e2.pageX;
      touches.currentY = e2.pageY;
      const startX = touches.currentX;
      const startY = touches.currentY;
      const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
      const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
      if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === "prevent") {
          event.preventDefault();
        } else {
          return;
        }
      }
      Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: void 0,
        startMoving: void 0
      });
      touches.startX = startX;
      touches.startY = startY;
      data.touchStartTime = now();
      swiper2.allowClick = true;
      swiper2.updateSize();
      swiper2.swipeDirection = void 0;
      if (params.threshold > 0)
        data.allowThresholdMove = false;
      let preventDefault = true;
      if (targetEl.matches(data.focusableElements)) {
        preventDefault = false;
        if (targetEl.nodeName === "SELECT") {
          data.isTouched = false;
        }
      }
      if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) {
        document2.activeElement.blur();
      }
      const shouldPreventDefault = preventDefault && swiper2.allowTouchMove && params.touchStartPreventDefault;
      if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
        e2.preventDefault();
      }
      if (params.freeMode && params.freeMode.enabled && swiper2.freeMode && swiper2.animating && !params.cssMode) {
        swiper2.freeMode.onTouchStart();
      }
      swiper2.emit("touchStart", e2);
    }
    function onTouchMove(event) {
      const document2 = getDocument();
      const swiper2 = this;
      const data = swiper2.touchEventsData;
      const {
        params,
        touches,
        rtlTranslate: rtl,
        enabled
      } = swiper2;
      if (!enabled)
        return;
      if (!params.simulateTouch && event.pointerType === "mouse")
        return;
      let e2 = event;
      if (e2.originalEvent)
        e2 = e2.originalEvent;
      if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
          swiper2.emit("touchMoveOpposite", e2);
        }
        return;
      }
      const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === e2.pointerId);
      if (pointerIndex >= 0)
        data.evCache[pointerIndex] = e2;
      const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e2;
      const pageX = targetTouch.pageX;
      const pageY = targetTouch.pageY;
      if (e2.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
      }
      if (!swiper2.allowTouchMove) {
        if (!e2.target.matches(data.focusableElements)) {
          swiper2.allowClick = false;
        }
        if (data.isTouched) {
          Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            prevX: swiper2.touches.currentX,
            prevY: swiper2.touches.currentY,
            currentX: pageX,
            currentY: pageY
          });
          data.touchStartTime = now();
        }
        return;
      }
      if (params.touchReleaseOnEdges && !params.loop) {
        if (swiper2.isVertical()) {
          if (pageY < touches.startY && swiper2.translate <= swiper2.maxTranslate() || pageY > touches.startY && swiper2.translate >= swiper2.minTranslate()) {
            data.isTouched = false;
            data.isMoved = false;
            return;
          }
        } else if (pageX < touches.startX && swiper2.translate <= swiper2.maxTranslate() || pageX > touches.startX && swiper2.translate >= swiper2.minTranslate()) {
          return;
        }
      }
      if (document2.activeElement) {
        if (e2.target === document2.activeElement && e2.target.matches(data.focusableElements)) {
          data.isMoved = true;
          swiper2.allowClick = false;
          return;
        }
      }
      if (data.allowTouchCallbacks) {
        swiper2.emit("touchMove", e2);
      }
      if (e2.targetTouches && e2.targetTouches.length > 1)
        return;
      touches.currentX = pageX;
      touches.currentY = pageY;
      const diffX = touches.currentX - touches.startX;
      const diffY = touches.currentY - touches.startY;
      if (swiper2.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper2.params.threshold)
        return;
      if (typeof data.isScrolling === "undefined") {
        let touchAngle;
        if (swiper2.isHorizontal() && touches.currentY === touches.startY || swiper2.isVertical() && touches.currentX === touches.startX) {
          data.isScrolling = false;
        } else {
          if (diffX * diffX + diffY * diffY >= 25) {
            touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
            data.isScrolling = swiper2.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
          }
        }
      }
      if (data.isScrolling) {
        swiper2.emit("touchMoveOpposite", e2);
      }
      if (typeof data.startMoving === "undefined") {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
          data.startMoving = true;
        }
      }
      if (data.isScrolling || swiper2.zoom && swiper2.params.zoom && swiper2.params.zoom.enabled && data.evCache.length > 1) {
        data.isTouched = false;
        return;
      }
      if (!data.startMoving) {
        return;
      }
      swiper2.allowClick = false;
      if (!params.cssMode && e2.cancelable) {
        e2.preventDefault();
      }
      if (params.touchMoveStopPropagation && !params.nested) {
        e2.stopPropagation();
      }
      let diff = swiper2.isHorizontal() ? diffX : diffY;
      let touchesDiff = swiper2.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
      if (params.oneWayMovement) {
        diff = Math.abs(diff) * (rtl ? 1 : -1);
        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
      }
      touches.diff = diff;
      diff *= params.touchRatio;
      if (rtl) {
        diff = -diff;
        touchesDiff = -touchesDiff;
      }
      const prevTouchesDirection = swiper2.touchesDirection;
      swiper2.swipeDirection = diff > 0 ? "prev" : "next";
      swiper2.touchesDirection = touchesDiff > 0 ? "prev" : "next";
      const isLoop = swiper2.params.loop && !params.cssMode;
      const allowLoopFix = swiper2.swipeDirection === "next" && swiper2.allowSlideNext || swiper2.swipeDirection === "prev" && swiper2.allowSlidePrev;
      if (!data.isMoved) {
        if (isLoop && allowLoopFix) {
          swiper2.loopFix({
            direction: swiper2.swipeDirection
          });
        }
        data.startTranslate = swiper2.getTranslate();
        swiper2.setTransition(0);
        if (swiper2.animating) {
          const evt = new window.CustomEvent("transitionend", {
            bubbles: true,
            cancelable: true
          });
          swiper2.wrapperEl.dispatchEvent(evt);
        }
        data.allowMomentumBounce = false;
        if (params.grabCursor && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
          swiper2.setGrabCursor(true);
        }
        swiper2.emit("sliderFirstMove", e2);
      }
      let loopFixed;
      if (data.isMoved && prevTouchesDirection !== swiper2.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
        swiper2.loopFix({
          direction: swiper2.swipeDirection,
          setTranslate: true
        });
        loopFixed = true;
      }
      swiper2.emit("sliderMove", e2);
      data.isMoved = true;
      data.currentTranslate = diff + data.startTranslate;
      let disableParentSwiper = true;
      let resistanceRatio = params.resistanceRatio;
      if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
      }
      if (diff > 0) {
        if (isLoop && allowLoopFix && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper2.minTranslate() - swiper2.size / 2 : swiper2.minTranslate())) {
          swiper2.loopFix({
            direction: "prev",
            setTranslate: true,
            activeSlideIndex: 0
          });
        }
        if (data.currentTranslate > swiper2.minTranslate()) {
          disableParentSwiper = false;
          if (params.resistance) {
            data.currentTranslate = swiper2.minTranslate() - 1 + (-swiper2.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
          }
        }
      } else if (diff < 0) {
        if (isLoop && allowLoopFix && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper2.maxTranslate() + swiper2.size / 2 : swiper2.maxTranslate())) {
          swiper2.loopFix({
            direction: "next",
            setTranslate: true,
            activeSlideIndex: swiper2.slides.length - (params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
          });
        }
        if (data.currentTranslate < swiper2.maxTranslate()) {
          disableParentSwiper = false;
          if (params.resistance) {
            data.currentTranslate = swiper2.maxTranslate() + 1 - (swiper2.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
          }
        }
      }
      if (disableParentSwiper) {
        e2.preventedByNestedSwiper = true;
      }
      if (!swiper2.allowSlideNext && swiper2.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }
      if (!swiper2.allowSlidePrev && swiper2.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
      }
      if (!swiper2.allowSlidePrev && !swiper2.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
      }
      if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
          if (!data.allowThresholdMove) {
            data.allowThresholdMove = true;
            touches.startX = touches.currentX;
            touches.startY = touches.currentY;
            data.currentTranslate = data.startTranslate;
            touches.diff = swiper2.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
            return;
          }
        } else {
          data.currentTranslate = data.startTranslate;
          return;
        }
      }
      if (!params.followFinger || params.cssMode)
        return;
      if (params.freeMode && params.freeMode.enabled && swiper2.freeMode || params.watchSlidesProgress) {
        swiper2.updateActiveIndex();
        swiper2.updateSlidesClasses();
      }
      if (params.freeMode && params.freeMode.enabled && swiper2.freeMode) {
        swiper2.freeMode.onTouchMove();
      }
      swiper2.updateProgress(data.currentTranslate);
      swiper2.setTranslate(data.currentTranslate);
    }
    function onTouchEnd(event) {
      const swiper2 = this;
      const data = swiper2.touchEventsData;
      const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === event.pointerId);
      if (pointerIndex >= 0) {
        data.evCache.splice(pointerIndex, 1);
      }
      if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(event.type)) {
        const proceed = ["pointercancel", "contextmenu"].includes(event.type) && (swiper2.browser.isSafari || swiper2.browser.isWebView);
        if (!proceed) {
          return;
        }
      }
      const {
        params,
        touches,
        rtlTranslate: rtl,
        slidesGrid,
        enabled
      } = swiper2;
      if (!enabled)
        return;
      if (!params.simulateTouch && event.pointerType === "mouse")
        return;
      let e2 = event;
      if (e2.originalEvent)
        e2 = e2.originalEvent;
      if (data.allowTouchCallbacks) {
        swiper2.emit("touchEnd", e2);
      }
      data.allowTouchCallbacks = false;
      if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
          swiper2.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      if (params.grabCursor && data.isMoved && data.isTouched && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
        swiper2.setGrabCursor(false);
      }
      const touchEndTime = now();
      const timeDiff = touchEndTime - data.touchStartTime;
      if (swiper2.allowClick) {
        const pathTree = e2.path || e2.composedPath && e2.composedPath();
        swiper2.updateClickedSlide(pathTree && pathTree[0] || e2.target, pathTree);
        swiper2.emit("tap click", e2);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
          swiper2.emit("doubleTap doubleClick", e2);
        }
      }
      data.lastClickTime = now();
      nextTick(() => {
        if (!swiper2.destroyed)
          swiper2.allowClick = true;
      });
      if (!data.isTouched || !data.isMoved || !swiper2.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
      }
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      let currentPos;
      if (params.followFinger) {
        currentPos = rtl ? swiper2.translate : -swiper2.translate;
      } else {
        currentPos = -data.currentTranslate;
      }
      if (params.cssMode) {
        return;
      }
      if (params.freeMode && params.freeMode.enabled) {
        swiper2.freeMode.onTouchEnd({
          currentPos
        });
        return;
      }
      let stopIndex = 0;
      let groupSize = swiper2.slidesSizesGrid[0];
      for (let i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
        const increment2 = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i2 + increment2] !== "undefined") {
          if (currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + increment2]) {
            stopIndex = i2;
            groupSize = slidesGrid[i2 + increment2] - slidesGrid[i2];
          }
        } else if (currentPos >= slidesGrid[i2]) {
          stopIndex = i2;
          groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
      }
      let rewindFirstIndex = null;
      let rewindLastIndex = null;
      if (params.rewind) {
        if (swiper2.isBeginning) {
          rewindLastIndex = params.virtual && params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
        } else if (swiper2.isEnd) {
          rewindFirstIndex = 0;
        }
      }
      const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
      const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
      if (timeDiff > params.longSwipesMs) {
        if (!params.longSwipes) {
          swiper2.slideTo(swiper2.activeIndex);
          return;
        }
        if (swiper2.swipeDirection === "next") {
          if (ratio >= params.longSwipesRatio)
            swiper2.slideTo(params.rewind && swiper2.isEnd ? rewindFirstIndex : stopIndex + increment);
          else
            swiper2.slideTo(stopIndex);
        }
        if (swiper2.swipeDirection === "prev") {
          if (ratio > 1 - params.longSwipesRatio) {
            swiper2.slideTo(stopIndex + increment);
          } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
            swiper2.slideTo(rewindLastIndex);
          } else {
            swiper2.slideTo(stopIndex);
          }
        }
      } else {
        if (!params.shortSwipes) {
          swiper2.slideTo(swiper2.activeIndex);
          return;
        }
        const isNavButtonTarget = swiper2.navigation && (e2.target === swiper2.navigation.nextEl || e2.target === swiper2.navigation.prevEl);
        if (!isNavButtonTarget) {
          if (swiper2.swipeDirection === "next") {
            swiper2.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
          }
          if (swiper2.swipeDirection === "prev") {
            swiper2.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
          }
        } else if (e2.target === swiper2.navigation.nextEl) {
          swiper2.slideTo(stopIndex + increment);
        } else {
          swiper2.slideTo(stopIndex);
        }
      }
    }
    function onResize() {
      const swiper2 = this;
      const {
        params,
        el: el2
      } = swiper2;
      if (el2 && el2.offsetWidth === 0)
        return;
      if (params.breakpoints) {
        swiper2.setBreakpoint();
      }
      const {
        allowSlideNext,
        allowSlidePrev,
        snapGrid
      } = swiper2;
      const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
      swiper2.allowSlideNext = true;
      swiper2.allowSlidePrev = true;
      swiper2.updateSize();
      swiper2.updateSlides();
      swiper2.updateSlidesClasses();
      const isVirtualLoop = isVirtual && params.loop;
      if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper2.isEnd && !swiper2.isBeginning && !swiper2.params.centeredSlides && !isVirtualLoop) {
        swiper2.slideTo(swiper2.slides.length - 1, 0, false, true);
      } else {
        if (swiper2.params.loop && !isVirtual) {
          swiper2.slideToLoop(swiper2.realIndex, 0, false, true);
        } else {
          swiper2.slideTo(swiper2.activeIndex, 0, false, true);
        }
      }
      if (swiper2.autoplay && swiper2.autoplay.running && swiper2.autoplay.paused) {
        clearTimeout(swiper2.autoplay.resizeTimeout);
        swiper2.autoplay.resizeTimeout = setTimeout(() => {
          if (swiper2.autoplay && swiper2.autoplay.running && swiper2.autoplay.paused) {
            swiper2.autoplay.resume();
          }
        }, 500);
      }
      swiper2.allowSlidePrev = allowSlidePrev;
      swiper2.allowSlideNext = allowSlideNext;
      if (swiper2.params.watchOverflow && snapGrid !== swiper2.snapGrid) {
        swiper2.checkOverflow();
      }
    }
    function onClick(e2) {
      const swiper2 = this;
      if (!swiper2.enabled)
        return;
      if (!swiper2.allowClick) {
        if (swiper2.params.preventClicks)
          e2.preventDefault();
        if (swiper2.params.preventClicksPropagation && swiper2.animating) {
          e2.stopPropagation();
          e2.stopImmediatePropagation();
        }
      }
    }
    function onScroll() {
      const swiper2 = this;
      const {
        wrapperEl,
        rtlTranslate,
        enabled
      } = swiper2;
      if (!enabled)
        return;
      swiper2.previousTranslate = swiper2.translate;
      if (swiper2.isHorizontal()) {
        swiper2.translate = -wrapperEl.scrollLeft;
      } else {
        swiper2.translate = -wrapperEl.scrollTop;
      }
      if (swiper2.translate === 0)
        swiper2.translate = 0;
      swiper2.updateActiveIndex();
      swiper2.updateSlidesClasses();
      let newProgress;
      const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
      if (translatesDiff === 0) {
        newProgress = 0;
      } else {
        newProgress = (swiper2.translate - swiper2.minTranslate()) / translatesDiff;
      }
      if (newProgress !== swiper2.progress) {
        swiper2.updateProgress(rtlTranslate ? -swiper2.translate : swiper2.translate);
      }
      swiper2.emit("setTranslate", swiper2.translate, false);
    }
    function onLoad(e2) {
      const swiper2 = this;
      processLazyPreloader(swiper2, e2.target);
      if (swiper2.params.cssMode || swiper2.params.slidesPerView !== "auto" && !swiper2.params.autoHeight) {
        return;
      }
      swiper2.update();
    }
    let dummyEventAttached = false;
    function dummyEventListener() {
    }
    const events = (swiper2, method) => {
      const document2 = getDocument();
      const {
        params,
        el: el2,
        wrapperEl,
        device
      } = swiper2;
      const capture = !!params.nested;
      const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
      const swiperMethod = method;
      el2[domMethod]("pointerdown", swiper2.onTouchStart, {
        passive: false
      });
      document2[domMethod]("pointermove", swiper2.onTouchMove, {
        passive: false,
        capture
      });
      document2[domMethod]("pointerup", swiper2.onTouchEnd, {
        passive: true
      });
      document2[domMethod]("pointercancel", swiper2.onTouchEnd, {
        passive: true
      });
      document2[domMethod]("pointerout", swiper2.onTouchEnd, {
        passive: true
      });
      document2[domMethod]("pointerleave", swiper2.onTouchEnd, {
        passive: true
      });
      document2[domMethod]("contextmenu", swiper2.onTouchEnd, {
        passive: true
      });
      if (params.preventClicks || params.preventClicksPropagation) {
        el2[domMethod]("click", swiper2.onClick, true);
      }
      if (params.cssMode) {
        wrapperEl[domMethod]("scroll", swiper2.onScroll);
      }
      if (params.updateOnWindowResize) {
        swiper2[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
      } else {
        swiper2[swiperMethod]("observerUpdate", onResize, true);
      }
      el2[domMethod]("load", swiper2.onLoad, {
        capture: true
      });
    };
    function attachEvents() {
      const swiper2 = this;
      const document2 = getDocument();
      const {
        params
      } = swiper2;
      swiper2.onTouchStart = onTouchStart.bind(swiper2);
      swiper2.onTouchMove = onTouchMove.bind(swiper2);
      swiper2.onTouchEnd = onTouchEnd.bind(swiper2);
      if (params.cssMode) {
        swiper2.onScroll = onScroll.bind(swiper2);
      }
      swiper2.onClick = onClick.bind(swiper2);
      swiper2.onLoad = onLoad.bind(swiper2);
      if (!dummyEventAttached) {
        document2.addEventListener("touchstart", dummyEventListener);
        dummyEventAttached = true;
      }
      events(swiper2, "on");
    }
    function detachEvents() {
      const swiper2 = this;
      events(swiper2, "off");
    }
    var events$1 = {
      attachEvents,
      detachEvents
    };
    const isGridEnabled = (swiper2, params) => {
      return swiper2.grid && params.grid && params.grid.rows > 1;
    };
    function setBreakpoint() {
      const swiper2 = this;
      const {
        realIndex,
        initialized,
        params,
        el: el2
      } = swiper2;
      const breakpoints2 = params.breakpoints;
      if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
        return;
      const breakpoint = swiper2.getBreakpoint(breakpoints2, swiper2.params.breakpointsBase, swiper2.el);
      if (!breakpoint || swiper2.currentBreakpoint === breakpoint)
        return;
      const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
      const breakpointParams = breakpointOnlyParams || swiper2.originalParams;
      const wasMultiRow = isGridEnabled(swiper2, params);
      const isMultiRow = isGridEnabled(swiper2, breakpointParams);
      const wasEnabled = params.enabled;
      if (wasMultiRow && !isMultiRow) {
        el2.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
        swiper2.emitContainerClasses();
      } else if (!wasMultiRow && isMultiRow) {
        el2.classList.add(`${params.containerModifierClass}grid`);
        if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
          el2.classList.add(`${params.containerModifierClass}grid-column`);
        }
        swiper2.emitContainerClasses();
      }
      ["navigation", "pagination", "scrollbar"].forEach((prop) => {
        if (typeof breakpointParams[prop] === "undefined")
          return;
        const wasModuleEnabled = params[prop] && params[prop].enabled;
        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
        if (wasModuleEnabled && !isModuleEnabled) {
          swiper2[prop].disable();
        }
        if (!wasModuleEnabled && isModuleEnabled) {
          swiper2[prop].enable();
        }
      });
      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
      const wasLoop = params.loop;
      if (directionChanged && initialized) {
        swiper2.changeDirection();
      }
      extend$1(swiper2.params, breakpointParams);
      const isEnabled = swiper2.params.enabled;
      const hasLoop = swiper2.params.loop;
      Object.assign(swiper2, {
        allowTouchMove: swiper2.params.allowTouchMove,
        allowSlideNext: swiper2.params.allowSlideNext,
        allowSlidePrev: swiper2.params.allowSlidePrev
      });
      if (wasEnabled && !isEnabled) {
        swiper2.disable();
      } else if (!wasEnabled && isEnabled) {
        swiper2.enable();
      }
      swiper2.currentBreakpoint = breakpoint;
      swiper2.emit("_beforeBreakpoint", breakpointParams);
      if (initialized) {
        if (needsReLoop) {
          swiper2.loopDestroy();
          swiper2.loopCreate(realIndex);
          swiper2.updateSlides();
        } else if (!wasLoop && hasLoop) {
          swiper2.loopCreate(realIndex);
          swiper2.updateSlides();
        } else if (wasLoop && !hasLoop) {
          swiper2.loopDestroy();
        }
      }
      swiper2.emit("breakpoint", breakpointParams);
    }
    function getBreakpoint(breakpoints2, base, containerEl) {
      if (base === void 0) {
        base = "window";
      }
      if (!breakpoints2 || base === "container" && !containerEl)
        return void 0;
      let breakpoint = false;
      const window2 = getWindow();
      const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
      const points = Object.keys(breakpoints2).map((point) => {
        if (typeof point === "string" && point.indexOf("@") === 0) {
          const minRatio = parseFloat(point.substr(1));
          const value = currentHeight * minRatio;
          return {
            value,
            point
          };
        }
        return {
          value: point,
          point
        };
      });
      points.sort((a2, b2) => parseInt(a2.value, 10) - parseInt(b2.value, 10));
      for (let i2 = 0; i2 < points.length; i2 += 1) {
        const {
          point,
          value
        } = points[i2];
        if (base === "window") {
          if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
            breakpoint = point;
          }
        } else if (value <= containerEl.clientWidth) {
          breakpoint = point;
        }
      }
      return breakpoint || "max";
    }
    var breakpoints = {
      setBreakpoint,
      getBreakpoint
    };
    function prepareClasses(entries, prefix2) {
      const resultClasses = [];
      entries.forEach((item) => {
        if (typeof item === "object") {
          Object.keys(item).forEach((classNames) => {
            if (item[classNames]) {
              resultClasses.push(prefix2 + classNames);
            }
          });
        } else if (typeof item === "string") {
          resultClasses.push(prefix2 + item);
        }
      });
      return resultClasses;
    }
    function addClasses() {
      const swiper2 = this;
      const {
        classNames,
        params,
        rtl,
        el: el2,
        device
      } = swiper2;
      const suffixes = prepareClasses(["initialized", params.direction, {
        "free-mode": swiper2.params.freeMode && params.freeMode.enabled
      }, {
        "autoheight": params.autoHeight
      }, {
        "rtl": rtl
      }, {
        "grid": params.grid && params.grid.rows > 1
      }, {
        "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
      }, {
        "android": device.android
      }, {
        "ios": device.ios
      }, {
        "css-mode": params.cssMode
      }, {
        "centered": params.cssMode && params.centeredSlides
      }, {
        "watch-progress": params.watchSlidesProgress
      }], params.containerModifierClass);
      classNames.push(...suffixes);
      el2.classList.add(...classNames);
      swiper2.emitContainerClasses();
    }
    function removeClasses() {
      const swiper2 = this;
      const {
        el: el2,
        classNames
      } = swiper2;
      el2.classList.remove(...classNames);
      swiper2.emitContainerClasses();
    }
    var classes = {
      addClasses,
      removeClasses
    };
    function checkOverflow() {
      const swiper2 = this;
      const {
        isLocked: wasLocked,
        params
      } = swiper2;
      const {
        slidesOffsetBefore
      } = params;
      if (slidesOffsetBefore) {
        const lastSlideIndex = swiper2.slides.length - 1;
        const lastSlideRightEdge = swiper2.slidesGrid[lastSlideIndex] + swiper2.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper2.isLocked = swiper2.size > lastSlideRightEdge;
      } else {
        swiper2.isLocked = swiper2.snapGrid.length === 1;
      }
      if (params.allowSlideNext === true) {
        swiper2.allowSlideNext = !swiper2.isLocked;
      }
      if (params.allowSlidePrev === true) {
        swiper2.allowSlidePrev = !swiper2.isLocked;
      }
      if (wasLocked && wasLocked !== swiper2.isLocked) {
        swiper2.isEnd = false;
      }
      if (wasLocked !== swiper2.isLocked) {
        swiper2.emit(swiper2.isLocked ? "lock" : "unlock");
      }
    }
    var checkOverflow$1 = {
      checkOverflow
    };
    var defaults = {
      init: true,
      direction: "horizontal",
      oneWayMovement: false,
      touchEventsTarget: "wrapper",
      initialSlide: 0,
      speed: 300,
      cssMode: false,
      updateOnWindowResize: true,
      resizeObserver: true,
      nested: false,
      createElements: false,
      enabled: true,
      focusableElements: "input, select, option, textarea, button, video, label",
      // Overrides
      width: null,
      height: null,
      //
      preventInteractionOnTransition: false,
      // ssr
      userAgent: null,
      url: null,
      // To support iOS's swipe-to-go-back gesture (when being used in-app).
      edgeSwipeDetection: false,
      edgeSwipeThreshold: 20,
      // Autoheight
      autoHeight: false,
      // Set wrapper width
      setWrapperSize: false,
      // Virtual Translate
      virtualTranslate: false,
      // Effects
      effect: "slide",
      // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
      // Breakpoints
      breakpoints: void 0,
      breakpointsBase: "window",
      // Slides grid
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: false,
      centeredSlides: false,
      centeredSlidesBounds: false,
      slidesOffsetBefore: 0,
      // in px
      slidesOffsetAfter: 0,
      // in px
      normalizeSlideIndex: true,
      centerInsufficientSlides: false,
      // Disable swiper and hide navigation when container not overflow
      watchOverflow: true,
      // Round length
      roundLengths: false,
      // Touches
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: true,
      shortSwipes: true,
      longSwipes: true,
      longSwipesRatio: 0.5,
      longSwipesMs: 300,
      followFinger: true,
      allowTouchMove: true,
      threshold: 5,
      touchMoveStopPropagation: false,
      touchStartPreventDefault: true,
      touchStartForcePreventDefault: false,
      touchReleaseOnEdges: false,
      // Unique Navigation Elements
      uniqueNavElements: true,
      // Resistance
      resistance: true,
      resistanceRatio: 0.85,
      // Progress
      watchSlidesProgress: false,
      // Cursor
      grabCursor: false,
      // Clicks
      preventClicks: true,
      preventClicksPropagation: true,
      slideToClickedSlide: false,
      // loop
      loop: false,
      loopedSlides: null,
      loopPreventsSliding: true,
      // rewind
      rewind: false,
      // Swiping/no swiping
      allowSlidePrev: true,
      allowSlideNext: true,
      swipeHandler: null,
      // '.swipe-handler',
      noSwiping: true,
      noSwipingClass: "swiper-no-swiping",
      noSwipingSelector: null,
      // Passive Listeners
      passiveListeners: true,
      maxBackfaceHiddenSlides: 10,
      // NS
      containerModifierClass: "swiper-",
      // NEW
      slideClass: "swiper-slide",
      slideActiveClass: "swiper-slide-active",
      slideVisibleClass: "swiper-slide-visible",
      slideNextClass: "swiper-slide-next",
      slidePrevClass: "swiper-slide-prev",
      wrapperClass: "swiper-wrapper",
      lazyPreloaderClass: "swiper-lazy-preloader",
      lazyPreloadPrevNext: 0,
      // Callbacks
      runCallbacksOnInit: true,
      // Internals
      _emitClasses: false
    };
    function moduleExtendParams(params, allModulesParams) {
      return function extendParams(obj) {
        if (obj === void 0) {
          obj = {};
        }
        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];
        if (typeof moduleParams !== "object" || moduleParams === null) {
          extend$1(allModulesParams, obj);
          return;
        }
        if (params[moduleParamName] === true) {
          params[moduleParamName] = {
            enabled: true
          };
        }
        if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
          params[moduleParamName].auto = true;
        }
        if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
          params[moduleParamName].auto = true;
        }
        if (!(moduleParamName in params && "enabled" in moduleParams)) {
          extend$1(allModulesParams, obj);
          return;
        }
        if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
          params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName])
          params[moduleParamName] = {
            enabled: false
          };
        extend$1(allModulesParams, obj);
      };
    }
    const prototypes = {
      eventsEmitter,
      update,
      translate,
      transition,
      slide,
      loop,
      grabCursor,
      events: events$1,
      breakpoints,
      checkOverflow: checkOverflow$1,
      classes
    };
    const extendedDefaults = {};
    let Swiper$1 = class Swiper2 {
      constructor() {
        let el2;
        let params;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
          params = args[0];
        } else {
          [el2, params] = args;
        }
        if (!params)
          params = {};
        params = extend$1({}, params);
        if (el2 && !params.el)
          params.el = el2;
        const document2 = getDocument();
        if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
          const swipers = [];
          document2.querySelectorAll(params.el).forEach((containerEl) => {
            const newParams = extend$1({}, params, {
              el: containerEl
            });
            swipers.push(new Swiper2(newParams));
          });
          return swipers;
        }
        const swiper2 = this;
        swiper2.__swiper__ = true;
        swiper2.support = getSupport();
        swiper2.device = getDevice({
          userAgent: params.userAgent
        });
        swiper2.browser = getBrowser();
        swiper2.eventsListeners = {};
        swiper2.eventsAnyListeners = [];
        swiper2.modules = [...swiper2.__modules__];
        if (params.modules && Array.isArray(params.modules)) {
          swiper2.modules.push(...params.modules);
        }
        const allModulesParams = {};
        swiper2.modules.forEach((mod) => {
          mod({
            params,
            swiper: swiper2,
            extendParams: moduleExtendParams(params, allModulesParams),
            on: swiper2.on.bind(swiper2),
            once: swiper2.once.bind(swiper2),
            off: swiper2.off.bind(swiper2),
            emit: swiper2.emit.bind(swiper2)
          });
        });
        const swiperParams = extend$1({}, defaults, allModulesParams);
        swiper2.params = extend$1({}, swiperParams, extendedDefaults, params);
        swiper2.originalParams = extend$1({}, swiper2.params);
        swiper2.passedParams = extend$1({}, params);
        if (swiper2.params && swiper2.params.on) {
          Object.keys(swiper2.params.on).forEach((eventName) => {
            swiper2.on(eventName, swiper2.params.on[eventName]);
          });
        }
        if (swiper2.params && swiper2.params.onAny) {
          swiper2.onAny(swiper2.params.onAny);
        }
        Object.assign(swiper2, {
          enabled: swiper2.params.enabled,
          el: el2,
          // Classes
          classNames: [],
          // Slides
          slides: [],
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          // isDirection
          isHorizontal() {
            return swiper2.params.direction === "horizontal";
          },
          isVertical() {
            return swiper2.params.direction === "vertical";
          },
          // Indexes
          activeIndex: 0,
          realIndex: 0,
          //
          isBeginning: true,
          isEnd: false,
          // Props
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: false,
          cssOverflowAdjustment() {
            return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
          },
          // Locks
          allowSlideNext: swiper2.params.allowSlideNext,
          allowSlidePrev: swiper2.params.allowSlidePrev,
          // Touch Events
          touchEventsData: {
            isTouched: void 0,
            isMoved: void 0,
            allowTouchCallbacks: void 0,
            touchStartTime: void 0,
            isScrolling: void 0,
            currentTranslate: void 0,
            startTranslate: void 0,
            allowThresholdMove: void 0,
            // Form elements to match
            focusableElements: swiper2.params.focusableElements,
            // Last click time
            lastClickTime: 0,
            clickTimeout: void 0,
            // Velocities
            velocities: [],
            allowMomentumBounce: void 0,
            startMoving: void 0,
            evCache: []
          },
          // Clicks
          allowClick: true,
          // Touches
          allowTouchMove: swiper2.params.allowTouchMove,
          touches: {
            startX: 0,
            startY: 0,
            currentX: 0,
            currentY: 0,
            diff: 0
          },
          // Images
          imagesToLoad: [],
          imagesLoaded: 0
        });
        swiper2.emit("_swiper");
        if (swiper2.params.init) {
          swiper2.init();
        }
        return swiper2;
      }
      getSlideIndex(slideEl) {
        const {
          slidesEl,
          params
        } = this;
        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
        const firstSlideIndex = elementIndex(slides[0]);
        return elementIndex(slideEl) - firstSlideIndex;
      }
      getSlideIndexByData(index) {
        return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index)[0]);
      }
      recalcSlides() {
        const swiper2 = this;
        const {
          slidesEl,
          params
        } = swiper2;
        swiper2.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
      }
      enable() {
        const swiper2 = this;
        if (swiper2.enabled)
          return;
        swiper2.enabled = true;
        if (swiper2.params.grabCursor) {
          swiper2.setGrabCursor();
        }
        swiper2.emit("enable");
      }
      disable() {
        const swiper2 = this;
        if (!swiper2.enabled)
          return;
        swiper2.enabled = false;
        if (swiper2.params.grabCursor) {
          swiper2.unsetGrabCursor();
        }
        swiper2.emit("disable");
      }
      setProgress(progress, speed) {
        const swiper2 = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper2.minTranslate();
        const max = swiper2.maxTranslate();
        const current = (max - min) * progress + min;
        swiper2.translateTo(current, typeof speed === "undefined" ? 0 : speed);
        swiper2.updateActiveIndex();
        swiper2.updateSlidesClasses();
      }
      emitContainerClasses() {
        const swiper2 = this;
        if (!swiper2.params._emitClasses || !swiper2.el)
          return;
        const cls = swiper2.el.className.split(" ").filter((className) => {
          return className.indexOf("swiper") === 0 || className.indexOf(swiper2.params.containerModifierClass) === 0;
        });
        swiper2.emit("_containerClasses", cls.join(" "));
      }
      getSlideClasses(slideEl) {
        const swiper2 = this;
        if (swiper2.destroyed)
          return "";
        return slideEl.className.split(" ").filter((className) => {
          return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper2.params.slideClass) === 0;
        }).join(" ");
      }
      emitSlidesClasses() {
        const swiper2 = this;
        if (!swiper2.params._emitClasses || !swiper2.el)
          return;
        const updates = [];
        swiper2.slides.forEach((slideEl) => {
          const classNames = swiper2.getSlideClasses(slideEl);
          updates.push({
            slideEl,
            classNames
          });
          swiper2.emit("_slideClass", slideEl, classNames);
        });
        swiper2.emit("_slideClasses", updates);
      }
      slidesPerViewDynamic(view, exact) {
        if (view === void 0) {
          view = "current";
        }
        if (exact === void 0) {
          exact = false;
        }
        const swiper2 = this;
        const {
          params,
          slides,
          slidesGrid,
          slidesSizesGrid,
          size: swiperSize,
          activeIndex
        } = swiper2;
        let spv = 1;
        if (typeof params.slidesPerView === "number")
          return params.slidesPerView;
        if (params.centeredSlides) {
          let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;
          let breakLoop;
          for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
            if (slides[i2] && !breakLoop) {
              slideSize += slides[i2].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize)
                breakLoop = true;
            }
          }
          for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
            if (slides[i2] && !breakLoop) {
              slideSize += slides[i2].swiperSlideSize;
              spv += 1;
              if (slideSize > swiperSize)
                breakLoop = true;
            }
          }
        } else {
          if (view === "current") {
            for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
              const slideInView = exact ? slidesGrid[i2] + slidesSizesGrid[i2] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i2] - slidesGrid[activeIndex] < swiperSize;
              if (slideInView) {
                spv += 1;
              }
            }
          } else {
            for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
              const slideInView = slidesGrid[activeIndex] - slidesGrid[i2] < swiperSize;
              if (slideInView) {
                spv += 1;
              }
            }
          }
        }
        return spv;
      }
      update() {
        const swiper2 = this;
        if (!swiper2 || swiper2.destroyed)
          return;
        const {
          snapGrid,
          params
        } = swiper2;
        if (params.breakpoints) {
          swiper2.setBreakpoint();
        }
        [...swiper2.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
          if (imageEl.complete) {
            processLazyPreloader(swiper2, imageEl);
          }
        });
        swiper2.updateSize();
        swiper2.updateSlides();
        swiper2.updateProgress();
        swiper2.updateSlidesClasses();
        function setTranslate2() {
          const translateValue = swiper2.rtlTranslate ? swiper2.translate * -1 : swiper2.translate;
          const newTranslate = Math.min(Math.max(translateValue, swiper2.maxTranslate()), swiper2.minTranslate());
          swiper2.setTranslate(newTranslate);
          swiper2.updateActiveIndex();
          swiper2.updateSlidesClasses();
        }
        let translated;
        if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
          setTranslate2();
          if (params.autoHeight) {
            swiper2.updateAutoHeight();
          }
        } else {
          if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper2.isEnd && !params.centeredSlides) {
            const slides = swiper2.virtual && params.virtual.enabled ? swiper2.virtual.slides : swiper2.slides;
            translated = swiper2.slideTo(slides.length - 1, 0, false, true);
          } else {
            translated = swiper2.slideTo(swiper2.activeIndex, 0, false, true);
          }
          if (!translated) {
            setTranslate2();
          }
        }
        if (params.watchOverflow && snapGrid !== swiper2.snapGrid) {
          swiper2.checkOverflow();
        }
        swiper2.emit("update");
      }
      changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
          needUpdate = true;
        }
        const swiper2 = this;
        const currentDirection = swiper2.params.direction;
        if (!newDirection) {
          newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
        }
        if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
          return swiper2;
        }
        swiper2.el.classList.remove(`${swiper2.params.containerModifierClass}${currentDirection}`);
        swiper2.el.classList.add(`${swiper2.params.containerModifierClass}${newDirection}`);
        swiper2.emitContainerClasses();
        swiper2.params.direction = newDirection;
        swiper2.slides.forEach((slideEl) => {
          if (newDirection === "vertical") {
            slideEl.style.width = "";
          } else {
            slideEl.style.height = "";
          }
        });
        swiper2.emit("changeDirection");
        if (needUpdate)
          swiper2.update();
        return swiper2;
      }
      changeLanguageDirection(direction) {
        const swiper2 = this;
        if (swiper2.rtl && direction === "rtl" || !swiper2.rtl && direction === "ltr")
          return;
        swiper2.rtl = direction === "rtl";
        swiper2.rtlTranslate = swiper2.params.direction === "horizontal" && swiper2.rtl;
        if (swiper2.rtl) {
          swiper2.el.classList.add(`${swiper2.params.containerModifierClass}rtl`);
          swiper2.el.dir = "rtl";
        } else {
          swiper2.el.classList.remove(`${swiper2.params.containerModifierClass}rtl`);
          swiper2.el.dir = "ltr";
        }
        swiper2.update();
      }
      mount(element) {
        const swiper2 = this;
        if (swiper2.mounted)
          return true;
        let el2 = element || swiper2.params.el;
        if (typeof el2 === "string") {
          el2 = document.querySelector(el2);
        }
        if (!el2) {
          return false;
        }
        el2.swiper = swiper2;
        if (el2.parentNode && el2.parentNode.host && el2.parentNode.host.nodeName === "SWIPER-CONTAINER") {
          swiper2.isElement = true;
        }
        const getWrapperSelector = () => {
          return `.${(swiper2.params.wrapperClass || "").trim().split(" ").join(".")}`;
        };
        const getWrapper = () => {
          if (el2 && el2.shadowRoot && el2.shadowRoot.querySelector) {
            const res = el2.shadowRoot.querySelector(getWrapperSelector());
            return res;
          }
          return elementChildren(el2, getWrapperSelector())[0];
        };
        let wrapperEl = getWrapper();
        if (!wrapperEl && swiper2.params.createElements) {
          wrapperEl = createElement("div", swiper2.params.wrapperClass);
          el2.append(wrapperEl);
          elementChildren(el2, `.${swiper2.params.slideClass}`).forEach((slideEl) => {
            wrapperEl.append(slideEl);
          });
        }
        Object.assign(swiper2, {
          el: el2,
          wrapperEl,
          slidesEl: swiper2.isElement && !el2.parentNode.host.slideSlots ? el2.parentNode.host : wrapperEl,
          hostEl: swiper2.isElement ? el2.parentNode.host : el2,
          mounted: true,
          // RTL
          rtl: el2.dir.toLowerCase() === "rtl" || elementStyle(el2, "direction") === "rtl",
          rtlTranslate: swiper2.params.direction === "horizontal" && (el2.dir.toLowerCase() === "rtl" || elementStyle(el2, "direction") === "rtl"),
          wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
        });
        return true;
      }
      init(el2) {
        const swiper2 = this;
        if (swiper2.initialized)
          return swiper2;
        const mounted = swiper2.mount(el2);
        if (mounted === false)
          return swiper2;
        swiper2.emit("beforeInit");
        if (swiper2.params.breakpoints) {
          swiper2.setBreakpoint();
        }
        swiper2.addClasses();
        swiper2.updateSize();
        swiper2.updateSlides();
        if (swiper2.params.watchOverflow) {
          swiper2.checkOverflow();
        }
        if (swiper2.params.grabCursor && swiper2.enabled) {
          swiper2.setGrabCursor();
        }
        if (swiper2.params.loop && swiper2.virtual && swiper2.params.virtual.enabled) {
          swiper2.slideTo(swiper2.params.initialSlide + swiper2.virtual.slidesBefore, 0, swiper2.params.runCallbacksOnInit, false, true);
        } else {
          swiper2.slideTo(swiper2.params.initialSlide, 0, swiper2.params.runCallbacksOnInit, false, true);
        }
        if (swiper2.params.loop) {
          swiper2.loopCreate();
        }
        swiper2.attachEvents();
        const lazyElements = [...swiper2.el.querySelectorAll('[loading="lazy"]')];
        if (swiper2.isElement) {
          lazyElements.push(...swiper2.hostEl.querySelectorAll('[loading="lazy"]'));
        }
        lazyElements.forEach((imageEl) => {
          if (imageEl.complete) {
            processLazyPreloader(swiper2, imageEl);
          } else {
            imageEl.addEventListener("load", (e2) => {
              processLazyPreloader(swiper2, e2.target);
            });
          }
        });
        preload(swiper2);
        swiper2.initialized = true;
        preload(swiper2);
        swiper2.emit("init");
        swiper2.emit("afterInit");
        return swiper2;
      }
      destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
          deleteInstance = true;
        }
        if (cleanStyles === void 0) {
          cleanStyles = true;
        }
        const swiper2 = this;
        const {
          params,
          el: el2,
          wrapperEl,
          slides
        } = swiper2;
        if (typeof swiper2.params === "undefined" || swiper2.destroyed) {
          return null;
        }
        swiper2.emit("beforeDestroy");
        swiper2.initialized = false;
        swiper2.detachEvents();
        if (params.loop) {
          swiper2.loopDestroy();
        }
        if (cleanStyles) {
          swiper2.removeClasses();
          el2.removeAttribute("style");
          wrapperEl.removeAttribute("style");
          if (slides && slides.length) {
            slides.forEach((slideEl) => {
              slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
              slideEl.removeAttribute("style");
              slideEl.removeAttribute("data-swiper-slide-index");
            });
          }
        }
        swiper2.emit("destroy");
        Object.keys(swiper2.eventsListeners).forEach((eventName) => {
          swiper2.off(eventName);
        });
        if (deleteInstance !== false) {
          swiper2.el.swiper = null;
          deleteProps(swiper2);
        }
        swiper2.destroyed = true;
        return null;
      }
      static extendDefaults(newDefaults) {
        extend$1(extendedDefaults, newDefaults);
      }
      static get extendedDefaults() {
        return extendedDefaults;
      }
      static get defaults() {
        return defaults;
      }
      static installModule(mod) {
        if (!Swiper2.prototype.__modules__)
          Swiper2.prototype.__modules__ = [];
        const modules = Swiper2.prototype.__modules__;
        if (typeof mod === "function" && modules.indexOf(mod) < 0) {
          modules.push(mod);
        }
      }
      static use(module2) {
        if (Array.isArray(module2)) {
          module2.forEach((m2) => Swiper2.installModule(m2));
          return Swiper2;
        }
        Swiper2.installModule(module2);
        return Swiper2;
      }
    };
    Object.keys(prototypes).forEach((prototypeGroup) => {
      Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
        Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
      });
    });
    Swiper$1.use([Resize, Observer]);
    const paramsList = [
      "eventsPrefix",
      "injectStyles",
      "injectStylesUrls",
      "modules",
      "init",
      "_direction",
      "oneWayMovement",
      "touchEventsTarget",
      "initialSlide",
      "_speed",
      "cssMode",
      "updateOnWindowResize",
      "resizeObserver",
      "nested",
      "focusableElements",
      "_enabled",
      "_width",
      "_height",
      "preventInteractionOnTransition",
      "userAgent",
      "url",
      "_edgeSwipeDetection",
      "_edgeSwipeThreshold",
      "_freeMode",
      "_autoHeight",
      "setWrapperSize",
      "virtualTranslate",
      "_effect",
      "breakpoints",
      "breakpointsBase",
      "_spaceBetween",
      "_slidesPerView",
      "maxBackfaceHiddenSlides",
      "_grid",
      "_slidesPerGroup",
      "_slidesPerGroupSkip",
      "_slidesPerGroupAuto",
      "_centeredSlides",
      "_centeredSlidesBounds",
      "_slidesOffsetBefore",
      "_slidesOffsetAfter",
      "normalizeSlideIndex",
      "_centerInsufficientSlides",
      "_watchOverflow",
      "roundLengths",
      "touchRatio",
      "touchAngle",
      "simulateTouch",
      "_shortSwipes",
      "_longSwipes",
      "longSwipesRatio",
      "longSwipesMs",
      "_followFinger",
      "allowTouchMove",
      "_threshold",
      "touchMoveStopPropagation",
      "touchStartPreventDefault",
      "touchStartForcePreventDefault",
      "touchReleaseOnEdges",
      "uniqueNavElements",
      "_resistance",
      "_resistanceRatio",
      "_watchSlidesProgress",
      "_grabCursor",
      "preventClicks",
      "preventClicksPropagation",
      "_slideToClickedSlide",
      "_loop",
      "loopedSlides",
      "loopPreventsSliding",
      "_rewind",
      "_allowSlidePrev",
      "_allowSlideNext",
      "_swipeHandler",
      "_noSwiping",
      "noSwipingClass",
      "noSwipingSelector",
      "passiveListeners",
      "containerModifierClass",
      "slideClass",
      "slideActiveClass",
      "slideVisibleClass",
      "slideNextClass",
      "slidePrevClass",
      "wrapperClass",
      "lazyPreloaderClass",
      "lazyPreloadPrevNext",
      "runCallbacksOnInit",
      "observer",
      "observeParents",
      "observeSlideChildren",
      // modules
      "a11y",
      "_autoplay",
      "_controller",
      "coverflowEffect",
      "cubeEffect",
      "fadeEffect",
      "flipEffect",
      "creativeEffect",
      "cardsEffect",
      "hashNavigation",
      "history",
      "keyboard",
      "mousewheel",
      "_navigation",
      "_pagination",
      "parallax",
      "_scrollbar",
      "_thumbs",
      "virtual",
      "zoom",
      "control"
    ];
    function isObject(o2) {
      return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object" && !o2.__swiper__;
    }
    function extend(target, src) {
      const noExtend = ["__proto__", "constructor", "prototype"];
      Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
        if (typeof target[key] === "undefined")
          target[key] = src[key];
        else if (isObject(src[key]) && isObject(target[key]) && Object.keys(src[key]).length > 0) {
          if (src[key].__swiper__)
            target[key] = src[key];
          else
            extend(target[key], src[key]);
        } else {
          target[key] = src[key];
        }
      });
    }
    function needsNavigation(params) {
      if (params === void 0) {
        params = {};
      }
      return params.navigation && typeof params.navigation.nextEl === "undefined" && typeof params.navigation.prevEl === "undefined";
    }
    function needsPagination(params) {
      if (params === void 0) {
        params = {};
      }
      return params.pagination && typeof params.pagination.el === "undefined";
    }
    function needsScrollbar(params) {
      if (params === void 0) {
        params = {};
      }
      return params.scrollbar && typeof params.scrollbar.el === "undefined";
    }
    function uniqueClasses(classNames) {
      if (classNames === void 0) {
        classNames = "";
      }
      const classes2 = classNames.split(" ").map((c2) => c2.trim()).filter((c2) => !!c2);
      const unique = [];
      classes2.forEach((c2) => {
        if (unique.indexOf(c2) < 0)
          unique.push(c2);
      });
      return unique.join(" ");
    }
    function wrapperClass(className) {
      if (className === void 0) {
        className = "";
      }
      if (!className)
        return "swiper-wrapper";
      if (!className.includes("swiper-wrapper"))
        return `swiper-wrapper ${className}`;
      return className;
    }
    function updateSwiper(_ref) {
      let {
        swiper: swiper2,
        slides,
        passedParams,
        changedParams,
        nextEl,
        prevEl,
        scrollbarEl,
        paginationEl
      } = _ref;
      const updateParams = changedParams.filter((key) => key !== "children" && key !== "direction" && key !== "wrapperClass");
      const {
        params: currentParams,
        pagination,
        navigation,
        scrollbar,
        virtual,
        thumbs
      } = swiper2;
      let needThumbsInit;
      let needControllerInit;
      let needPaginationInit;
      let needScrollbarInit;
      let needNavigationInit;
      let loopNeedDestroy;
      let loopNeedEnable;
      let loopNeedReloop;
      if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
        needThumbsInit = true;
      }
      if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
        needControllerInit = true;
      }
      if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
        needPaginationInit = true;
      }
      if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
        needScrollbarInit = true;
      }
      if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
        needNavigationInit = true;
      }
      const destroyModule = (mod) => {
        if (!swiper2[mod])
          return;
        swiper2[mod].destroy();
        if (mod === "navigation") {
          if (swiper2.isElement) {
            swiper2[mod].prevEl.remove();
            swiper2[mod].nextEl.remove();
          }
          currentParams[mod].prevEl = void 0;
          currentParams[mod].nextEl = void 0;
          swiper2[mod].prevEl = void 0;
          swiper2[mod].nextEl = void 0;
        } else {
          if (swiper2.isElement) {
            swiper2[mod].el.remove();
          }
          currentParams[mod].el = void 0;
          swiper2[mod].el = void 0;
        }
      };
      if (changedParams.includes("loop") && swiper2.isElement) {
        if (currentParams.loop && !passedParams.loop) {
          loopNeedDestroy = true;
        } else if (!currentParams.loop && passedParams.loop) {
          loopNeedEnable = true;
        } else {
          loopNeedReloop = true;
        }
      }
      updateParams.forEach((key) => {
        if (isObject(currentParams[key]) && isObject(passedParams[key])) {
          extend(currentParams[key], passedParams[key]);
          if ((key === "navigation" || key === "pagination" || key === "scrollbar") && "enabled" in passedParams[key] && !passedParams[key].enabled) {
            destroyModule(key);
          }
        } else {
          const newValue = passedParams[key];
          if ((newValue === true || newValue === false) && (key === "navigation" || key === "pagination" || key === "scrollbar")) {
            if (newValue === false) {
              destroyModule(key);
            }
          } else {
            currentParams[key] = passedParams[key];
          }
        }
      });
      if (updateParams.includes("controller") && !needControllerInit && swiper2.controller && swiper2.controller.control && currentParams.controller && currentParams.controller.control) {
        swiper2.controller.control = currentParams.controller.control;
      }
      if (changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled) {
        virtual.slides = slides;
        virtual.update(true);
      }
      if (changedParams.includes("children") && slides && currentParams.loop) {
        loopNeedReloop = true;
      }
      if (needThumbsInit) {
        const initialized = thumbs.init();
        if (initialized)
          thumbs.update(true);
      }
      if (needControllerInit) {
        swiper2.controller.control = currentParams.controller.control;
      }
      if (needPaginationInit) {
        if (swiper2.isElement && (!paginationEl || typeof paginationEl === "string")) {
          paginationEl = document.createElement("div");
          paginationEl.classList.add("swiper-pagination");
          paginationEl.part.add("pagination");
          swiper2.el.appendChild(paginationEl);
        }
        if (paginationEl)
          currentParams.pagination.el = paginationEl;
        pagination.init();
        pagination.render();
        pagination.update();
      }
      if (needScrollbarInit) {
        if (swiper2.isElement && (!scrollbarEl || typeof scrollbarEl === "string")) {
          scrollbarEl = document.createElement("div");
          scrollbarEl.classList.add("swiper-scrollbar");
          scrollbarEl.part.add("scrollbar");
          swiper2.el.appendChild(scrollbarEl);
        }
        if (scrollbarEl)
          currentParams.scrollbar.el = scrollbarEl;
        scrollbar.init();
        scrollbar.updateSize();
        scrollbar.setTranslate();
      }
      if (needNavigationInit) {
        if (swiper2.isElement) {
          if (!nextEl || typeof nextEl === "string") {
            nextEl = document.createElement("div");
            nextEl.classList.add("swiper-button-next");
            nextEl.innerHTML = swiper2.hostEl.constructor.nextButtonSvg;
            nextEl.part.add("button-next");
            swiper2.el.appendChild(nextEl);
          }
          if (!prevEl || typeof prevEl === "string") {
            prevEl = document.createElement("div");
            prevEl.classList.add("swiper-button-prev");
            prevEl.innerHTML = swiper2.hostEl.constructor.prevButtonSvg;
            prevEl.part.add("button-prev");
            swiper2.el.appendChild(prevEl);
          }
        }
        if (nextEl)
          currentParams.navigation.nextEl = nextEl;
        if (prevEl)
          currentParams.navigation.prevEl = prevEl;
        navigation.init();
        navigation.update();
      }
      if (changedParams.includes("allowSlideNext")) {
        swiper2.allowSlideNext = passedParams.allowSlideNext;
      }
      if (changedParams.includes("allowSlidePrev")) {
        swiper2.allowSlidePrev = passedParams.allowSlidePrev;
      }
      if (changedParams.includes("direction")) {
        swiper2.changeDirection(passedParams.direction, false);
      }
      if (loopNeedDestroy || loopNeedReloop) {
        swiper2.loopDestroy();
      }
      if (loopNeedEnable || loopNeedReloop) {
        swiper2.loopCreate();
      }
      swiper2.update();
    }
    function getParams(obj, splitEvents) {
      if (obj === void 0) {
        obj = {};
      }
      if (splitEvents === void 0) {
        splitEvents = true;
      }
      const params = {
        on: {}
      };
      const events2 = {};
      const passedParams = {};
      extend(params, defaults);
      params._emitClasses = true;
      params.init = false;
      const rest = {};
      const allowedParams = paramsList.map((key) => key.replace(/_/, ""));
      const plainObj = Object.assign({}, obj);
      Object.keys(plainObj).forEach((key) => {
        if (typeof obj[key] === "undefined")
          return;
        if (allowedParams.indexOf(key) >= 0) {
          if (isObject(obj[key])) {
            params[key] = {};
            passedParams[key] = {};
            extend(params[key], obj[key]);
            extend(passedParams[key], obj[key]);
          } else {
            params[key] = obj[key];
            passedParams[key] = obj[key];
          }
        } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === "function") {
          if (splitEvents) {
            events2[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
          } else {
            params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
          }
        } else {
          rest[key] = obj[key];
        }
      });
      ["navigation", "pagination", "scrollbar"].forEach((key) => {
        if (params[key] === true)
          params[key] = {};
        if (params[key] === false)
          delete params[key];
      });
      return {
        params,
        passedParams,
        rest,
        events: events2
      };
    }
    function mountSwiper(_ref, swiperParams) {
      let {
        el: el2,
        nextEl,
        prevEl,
        paginationEl,
        scrollbarEl,
        swiper: swiper2
      } = _ref;
      if (needsNavigation(swiperParams) && nextEl && prevEl) {
        swiper2.params.navigation.nextEl = nextEl;
        swiper2.originalParams.navigation.nextEl = nextEl;
        swiper2.params.navigation.prevEl = prevEl;
        swiper2.originalParams.navigation.prevEl = prevEl;
      }
      if (needsPagination(swiperParams) && paginationEl) {
        swiper2.params.pagination.el = paginationEl;
        swiper2.originalParams.pagination.el = paginationEl;
      }
      if (needsScrollbar(swiperParams) && scrollbarEl) {
        swiper2.params.scrollbar.el = scrollbarEl;
        swiper2.originalParams.scrollbar.el = scrollbarEl;
      }
      swiper2.init(el2);
    }
    function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
      const keys = [];
      if (!oldParams)
        return keys;
      const addKey = (key) => {
        if (keys.indexOf(key) < 0)
          keys.push(key);
      };
      if (children && oldChildren) {
        const oldChildrenKeys = oldChildren.map(getKey);
        const childrenKeys = children.map(getKey);
        if (oldChildrenKeys.join("") !== childrenKeys.join(""))
          addKey("children");
        if (oldChildren.length !== children.length)
          addKey("children");
      }
      const watchParams = paramsList.filter((key) => key[0] === "_").map((key) => key.replace(/_/, ""));
      watchParams.forEach((key) => {
        if (key in swiperParams && key in oldParams) {
          if (isObject(swiperParams[key]) && isObject(oldParams[key])) {
            const newKeys = Object.keys(swiperParams[key]);
            const oldKeys = Object.keys(oldParams[key]);
            if (newKeys.length !== oldKeys.length) {
              addKey(key);
            } else {
              newKeys.forEach((newKey) => {
                if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
                  addKey(key);
                }
              });
              oldKeys.forEach((oldKey) => {
                if (swiperParams[key][oldKey] !== oldParams[key][oldKey])
                  addKey(key);
              });
            }
          } else if (swiperParams[key] !== oldParams[key]) {
            addKey(key);
          }
        }
      });
      return keys;
    }
    const updateOnVirtualData = (swiper2) => {
      if (!swiper2 || swiper2.destroyed || !swiper2.params.virtual || swiper2.params.virtual && !swiper2.params.virtual.enabled)
        return;
      swiper2.updateSlides();
      swiper2.updateProgress();
      swiper2.updateSlidesClasses();
      if (swiper2.parallax && swiper2.params.parallax && swiper2.params.parallax.enabled) {
        swiper2.parallax.setTranslate();
      }
    };
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i2 = 1; i2 < arguments.length; i2++) {
          var source = arguments[i2];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function isChildSwiperSlide(child) {
      return child.type && child.type.displayName && child.type.displayName.includes("SwiperSlide");
    }
    function processChildren(c2) {
      const slides = [];
      React.Children.toArray(c2).forEach((child) => {
        if (isChildSwiperSlide(child)) {
          slides.push(child);
        } else if (child.props && child.props.children) {
          processChildren(child.props.children).forEach((slide2) => slides.push(slide2));
        }
      });
      return slides;
    }
    function getChildren(c2) {
      const slides = [];
      const slots = {
        "container-start": [],
        "container-end": [],
        "wrapper-start": [],
        "wrapper-end": []
      };
      React.Children.toArray(c2).forEach((child) => {
        if (isChildSwiperSlide(child)) {
          slides.push(child);
        } else if (child.props && child.props.slot && slots[child.props.slot]) {
          slots[child.props.slot].push(child);
        } else if (child.props && child.props.children) {
          const foundSlides = processChildren(child.props.children);
          if (foundSlides.length > 0) {
            foundSlides.forEach((slide2) => slides.push(slide2));
          } else {
            slots["container-end"].push(child);
          }
        } else {
          slots["container-end"].push(child);
        }
      });
      return {
        slides,
        slots
      };
    }
    function renderVirtual(swiper2, slides, virtualData) {
      if (!virtualData)
        return null;
      const getSlideIndex = (index) => {
        let slideIndex = index;
        if (index < 0) {
          slideIndex = slides.length + index;
        } else if (slideIndex >= slides.length) {
          slideIndex = slideIndex - slides.length;
        }
        return slideIndex;
      };
      const style2 = swiper2.isHorizontal() ? {
        [swiper2.rtlTranslate ? "right" : "left"]: `${virtualData.offset}px`
      } : {
        top: `${virtualData.offset}px`
      };
      const {
        from: from2,
        to: to2
      } = virtualData;
      const loopFrom = swiper2.params.loop ? -slides.length : 0;
      const loopTo = swiper2.params.loop ? slides.length * 2 : slides.length;
      const slidesToRender = [];
      for (let i2 = loopFrom; i2 < loopTo; i2 += 1) {
        if (i2 >= from2 && i2 <= to2) {
          slidesToRender.push(slides[getSlideIndex(i2)]);
        }
      }
      return slidesToRender.map((child, index) => {
        return /* @__PURE__ */ React.cloneElement(child, {
          swiper: swiper2,
          style: style2,
          key: `slide-${index}`
        });
      });
    }
    function useIsomorphicLayoutEffect(callback, deps) {
      if (typeof window === "undefined")
        return reactExports.useEffect(callback, deps);
      return reactExports.useLayoutEffect(callback, deps);
    }
    const SwiperSlideContext = /* @__PURE__ */ reactExports.createContext(null);
    const SwiperContext = /* @__PURE__ */ reactExports.createContext(null);
    const Swiper = /* @__PURE__ */ reactExports.forwardRef(function(_temp, externalElRef) {
      let {
        className,
        tag: Tag = "div",
        wrapperTag: WrapperTag = "div",
        children,
        onSwiper,
        ...rest
      } = _temp === void 0 ? {} : _temp;
      let eventsAssigned = false;
      const [containerClasses, setContainerClasses] = reactExports.useState("swiper");
      const [virtualData, setVirtualData] = reactExports.useState(null);
      const [breakpointChanged, setBreakpointChanged] = reactExports.useState(false);
      const initializedRef = reactExports.useRef(false);
      const swiperElRef = reactExports.useRef(null);
      const swiperRef = reactExports.useRef(null);
      const oldPassedParamsRef = reactExports.useRef(null);
      const oldSlides = reactExports.useRef(null);
      const nextElRef = reactExports.useRef(null);
      const prevElRef = reactExports.useRef(null);
      const paginationElRef = reactExports.useRef(null);
      const scrollbarElRef = reactExports.useRef(null);
      const {
        params: swiperParams,
        passedParams,
        rest: restProps,
        events: events2
      } = getParams(rest);
      const {
        slides,
        slots
      } = getChildren(children);
      const onBeforeBreakpoint = () => {
        setBreakpointChanged(!breakpointChanged);
      };
      Object.assign(swiperParams.on, {
        _containerClasses(swiper2, classes2) {
          setContainerClasses(classes2);
        }
      });
      const initSwiper = () => {
        Object.assign(swiperParams.on, events2);
        eventsAssigned = true;
        const passParams = {
          ...swiperParams
        };
        delete passParams.wrapperClass;
        swiperRef.current = new Swiper$1(passParams);
        if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
          swiperRef.current.virtual.slides = slides;
          const extendWith = {
            cache: false,
            slides,
            renderExternal: setVirtualData,
            renderExternalUpdate: false
          };
          extend(swiperRef.current.params.virtual, extendWith);
          extend(swiperRef.current.originalParams.virtual, extendWith);
        }
      };
      if (!swiperElRef.current) {
        initSwiper();
      }
      if (swiperRef.current) {
        swiperRef.current.on("_beforeBreakpoint", onBeforeBreakpoint);
      }
      const attachEvents2 = () => {
        if (eventsAssigned || !events2 || !swiperRef.current)
          return;
        Object.keys(events2).forEach((eventName) => {
          swiperRef.current.on(eventName, events2[eventName]);
        });
      };
      const detachEvents2 = () => {
        if (!events2 || !swiperRef.current)
          return;
        Object.keys(events2).forEach((eventName) => {
          swiperRef.current.off(eventName, events2[eventName]);
        });
      };
      reactExports.useEffect(() => {
        return () => {
          if (swiperRef.current)
            swiperRef.current.off("_beforeBreakpoint", onBeforeBreakpoint);
        };
      });
      reactExports.useEffect(() => {
        if (!initializedRef.current && swiperRef.current) {
          swiperRef.current.emitSlidesClasses();
          initializedRef.current = true;
        }
      });
      useIsomorphicLayoutEffect(() => {
        if (externalElRef) {
          externalElRef.current = swiperElRef.current;
        }
        if (!swiperElRef.current)
          return;
        if (swiperRef.current.destroyed) {
          initSwiper();
        }
        mountSwiper({
          el: swiperElRef.current,
          nextEl: nextElRef.current,
          prevEl: prevElRef.current,
          paginationEl: paginationElRef.current,
          scrollbarEl: scrollbarElRef.current,
          swiper: swiperRef.current
        }, swiperParams);
        if (onSwiper)
          onSwiper(swiperRef.current);
        return () => {
          if (swiperRef.current && !swiperRef.current.destroyed) {
            swiperRef.current.destroy(true, false);
          }
        };
      }, []);
      useIsomorphicLayoutEffect(() => {
        attachEvents2();
        const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c2) => c2.key);
        oldPassedParamsRef.current = passedParams;
        oldSlides.current = slides;
        if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
          updateSwiper({
            swiper: swiperRef.current,
            slides,
            passedParams,
            changedParams,
            nextEl: nextElRef.current,
            prevEl: prevElRef.current,
            scrollbarEl: scrollbarElRef.current,
            paginationEl: paginationElRef.current
          });
        }
        return () => {
          detachEvents2();
        };
      });
      useIsomorphicLayoutEffect(() => {
        updateOnVirtualData(swiperRef.current);
      }, [virtualData]);
      function renderSlides() {
        if (swiperParams.virtual) {
          return renderVirtual(swiperRef.current, slides, virtualData);
        }
        return slides.map((child, index) => {
          return /* @__PURE__ */ React.cloneElement(child, {
            swiper: swiperRef.current,
            swiperSlideIndex: index
          });
        });
      }
      return /* @__PURE__ */ React.createElement(Tag, _extends({
        ref: swiperElRef,
        className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ""}`)
      }, restProps), /* @__PURE__ */ React.createElement(SwiperContext.Provider, {
        value: swiperRef.current
      }, slots["container-start"], /* @__PURE__ */ React.createElement(WrapperTag, {
        className: wrapperClass(swiperParams.wrapperClass)
      }, slots["wrapper-start"], renderSlides(), slots["wrapper-end"]), needsNavigation(swiperParams) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
        ref: prevElRef,
        className: "swiper-button-prev"
      }), /* @__PURE__ */ React.createElement("div", {
        ref: nextElRef,
        className: "swiper-button-next"
      })), needsScrollbar(swiperParams) && /* @__PURE__ */ React.createElement("div", {
        ref: scrollbarElRef,
        className: "swiper-scrollbar"
      }), needsPagination(swiperParams) && /* @__PURE__ */ React.createElement("div", {
        ref: paginationElRef,
        className: "swiper-pagination"
      }), slots["container-end"]));
    });
    Swiper.displayName = "Swiper";
    const SwiperSlide = /* @__PURE__ */ reactExports.forwardRef(function(_temp, externalRef) {
      let {
        tag: Tag = "div",
        children,
        className = "",
        swiper: swiper2,
        zoom,
        lazy,
        virtualIndex,
        swiperSlideIndex,
        ...rest
      } = _temp === void 0 ? {} : _temp;
      const slideElRef = reactExports.useRef(null);
      const [slideClasses, setSlideClasses] = reactExports.useState("swiper-slide");
      const [lazyLoaded, setLazyLoaded] = reactExports.useState(false);
      function updateClasses(_s, el2, classNames) {
        if (el2 === slideElRef.current) {
          setSlideClasses(classNames);
        }
      }
      useIsomorphicLayoutEffect(() => {
        if (typeof swiperSlideIndex !== "undefined") {
          slideElRef.current.swiperSlideIndex = swiperSlideIndex;
        }
        if (externalRef) {
          externalRef.current = slideElRef.current;
        }
        if (!slideElRef.current || !swiper2) {
          return;
        }
        if (swiper2.destroyed) {
          if (slideClasses !== "swiper-slide") {
            setSlideClasses("swiper-slide");
          }
          return;
        }
        swiper2.on("_slideClass", updateClasses);
        return () => {
          if (!swiper2)
            return;
          swiper2.off("_slideClass", updateClasses);
        };
      });
      useIsomorphicLayoutEffect(() => {
        if (swiper2 && slideElRef.current && !swiper2.destroyed) {
          setSlideClasses(swiper2.getSlideClasses(slideElRef.current));
        }
      }, [swiper2]);
      const slideData = {
        isActive: slideClasses.indexOf("swiper-slide-active") >= 0,
        isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
        isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0,
        isNext: slideClasses.indexOf("swiper-slide-next") >= 0
      };
      const renderChildren = () => {
        return typeof children === "function" ? children(slideData) : children;
      };
      const onLoad2 = () => {
        setLazyLoaded(true);
      };
      return /* @__PURE__ */ React.createElement(Tag, _extends({
        ref: slideElRef,
        className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ""}`),
        "data-swiper-slide-index": virtualIndex,
        onLoad: onLoad2
      }, rest), zoom && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, {
        value: slideData
      }, /* @__PURE__ */ React.createElement("div", {
        className: "swiper-zoom-container",
        "data-swiper-zoom": typeof zoom === "number" ? zoom : void 0
      }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ React.createElement("div", {
        className: "swiper-lazy-preloader"
      }))), !zoom && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, {
        value: slideData
      }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ React.createElement("div", {
        className: "swiper-lazy-preloader"
      })));
    });
    SwiperSlide.displayName = "SwiperSlide";
    function createElementIfNotDefined(swiper2, originalParams, params, checkProps) {
      if (swiper2.params.createElements) {
        Object.keys(checkProps).forEach((key) => {
          if (!params[key] && params.auto === true) {
            let element = elementChildren(swiper2.el, `.${checkProps[key]}`)[0];
            if (!element) {
              element = createElement("div", checkProps[key]);
              element.className = checkProps[key];
              swiper2.el.append(element);
            }
            params[key] = element;
            originalParams[key] = element;
          }
        });
      }
      return params;
    }
    function classesToSelector(classes2) {
      if (classes2 === void 0) {
        classes2 = "";
      }
      return `.${classes2.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
    }
    function Pagination(_ref) {
      let {
        swiper: swiper2,
        extendParams,
        on: on2,
        emit
      } = _ref;
      const pfx = "swiper-pagination";
      extendParams({
        pagination: {
          el: null,
          bulletElement: "span",
          clickable: false,
          hideOnClick: false,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: false,
          type: "bullets",
          // 'bullets' or 'progressbar' or 'fraction' or 'custom'
          dynamicBullets: false,
          dynamicMainBullets: 1,
          formatFractionCurrent: (number) => number,
          formatFractionTotal: (number) => number,
          bulletClass: `${pfx}-bullet`,
          bulletActiveClass: `${pfx}-bullet-active`,
          modifierClass: `${pfx}-`,
          currentClass: `${pfx}-current`,
          totalClass: `${pfx}-total`,
          hiddenClass: `${pfx}-hidden`,
          progressbarFillClass: `${pfx}-progressbar-fill`,
          progressbarOppositeClass: `${pfx}-progressbar-opposite`,
          clickableClass: `${pfx}-clickable`,
          lockClass: `${pfx}-lock`,
          horizontalClass: `${pfx}-horizontal`,
          verticalClass: `${pfx}-vertical`,
          paginationDisabledClass: `${pfx}-disabled`
        }
      });
      swiper2.pagination = {
        el: null,
        bullets: []
      };
      let bulletSize;
      let dynamicBulletIndex = 0;
      const makeElementsArray = (el2) => (Array.isArray(el2) ? el2 : [el2]).filter((e2) => !!e2);
      function isPaginationDisabled() {
        return !swiper2.params.pagination.el || !swiper2.pagination.el || Array.isArray(swiper2.pagination.el) && swiper2.pagination.el.length === 0;
      }
      function setSideBullets(bulletEl, position2) {
        const {
          bulletActiveClass
        } = swiper2.params.pagination;
        if (!bulletEl)
          return;
        bulletEl = bulletEl[`${position2 === "prev" ? "previous" : "next"}ElementSibling`];
        if (bulletEl) {
          bulletEl.classList.add(`${bulletActiveClass}-${position2}`);
          bulletEl = bulletEl[`${position2 === "prev" ? "previous" : "next"}ElementSibling`];
          if (bulletEl) {
            bulletEl.classList.add(`${bulletActiveClass}-${position2}-${position2}`);
          }
        }
      }
      function onBulletClick(e2) {
        const bulletEl = e2.target.closest(classesToSelector(swiper2.params.pagination.bulletClass));
        if (!bulletEl) {
          return;
        }
        e2.preventDefault();
        const index = elementIndex(bulletEl) * swiper2.params.slidesPerGroup;
        if (swiper2.params.loop) {
          if (swiper2.realIndex === index)
            return;
          const realIndex = swiper2.realIndex;
          const newSlideIndex = swiper2.getSlideIndexByData(index);
          const currentSlideIndex = swiper2.getSlideIndexByData(swiper2.realIndex);
          const loopFix2 = (dir) => {
            const indexBeforeLoopFix = swiper2.activeIndex;
            swiper2.loopFix({
              direction: dir,
              activeSlideIndex: newSlideIndex,
              slideTo: false
            });
            const indexAfterFix = swiper2.activeIndex;
            if (indexBeforeLoopFix === indexAfterFix) {
              swiper2.slideToLoop(realIndex, 0, false, true);
            }
          };
          if (newSlideIndex > swiper2.slides.length - swiper2.loopedSlides) {
            loopFix2(newSlideIndex > currentSlideIndex ? "next" : "prev");
          } else if (swiper2.params.centeredSlides) {
            const slidesPerView = swiper2.params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(parseFloat(swiper2.params.slidesPerView, 10));
            if (newSlideIndex < Math.floor(slidesPerView / 2)) {
              loopFix2("prev");
            }
          }
          swiper2.slideToLoop(index);
        } else {
          swiper2.slideTo(index);
        }
      }
      function update2() {
        const rtl = swiper2.rtl;
        const params = swiper2.params.pagination;
        if (isPaginationDisabled())
          return;
        let el2 = swiper2.pagination.el;
        el2 = makeElementsArray(el2);
        let current;
        let previousIndex;
        const slidesLength = swiper2.virtual && swiper2.params.virtual.enabled ? swiper2.virtual.slides.length : swiper2.slides.length;
        const total = swiper2.params.loop ? Math.ceil(slidesLength / swiper2.params.slidesPerGroup) : swiper2.snapGrid.length;
        if (swiper2.params.loop) {
          previousIndex = swiper2.previousRealIndex || 0;
          current = swiper2.params.slidesPerGroup > 1 ? Math.floor(swiper2.realIndex / swiper2.params.slidesPerGroup) : swiper2.realIndex;
        } else if (typeof swiper2.snapIndex !== "undefined") {
          current = swiper2.snapIndex;
          previousIndex = swiper2.previousSnapIndex;
        } else {
          previousIndex = swiper2.previousIndex || 0;
          current = swiper2.activeIndex || 0;
        }
        if (params.type === "bullets" && swiper2.pagination.bullets && swiper2.pagination.bullets.length > 0) {
          const bullets = swiper2.pagination.bullets;
          let firstIndex;
          let lastIndex;
          let midIndex;
          if (params.dynamicBullets) {
            bulletSize = elementOuterSize(bullets[0], swiper2.isHorizontal() ? "width" : "height", true);
            el2.forEach((subEl) => {
              subEl.style[swiper2.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
            });
            if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
              dynamicBulletIndex += current - (previousIndex || 0);
              if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                dynamicBulletIndex = params.dynamicMainBullets - 1;
              } else if (dynamicBulletIndex < 0) {
                dynamicBulletIndex = 0;
              }
            }
            firstIndex = Math.max(current - dynamicBulletIndex, 0);
            lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
            midIndex = (lastIndex + firstIndex) / 2;
          }
          bullets.forEach((bulletEl) => {
            const classesToRemove = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((suffix) => `${params.bulletActiveClass}${suffix}`)].map((s2) => typeof s2 === "string" && s2.includes(" ") ? s2.split(" ") : s2).flat();
            bulletEl.classList.remove(...classesToRemove);
          });
          if (el2.length > 1) {
            bullets.forEach((bullet) => {
              const bulletIndex = elementIndex(bullet);
              if (bulletIndex === current) {
                bullet.classList.add(...params.bulletActiveClass.split(" "));
              } else if (swiper2.isElement) {
                bullet.setAttribute("part", "bullet");
              }
              if (params.dynamicBullets) {
                if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                  bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                }
                if (bulletIndex === firstIndex) {
                  setSideBullets(bullet, "prev");
                }
                if (bulletIndex === lastIndex) {
                  setSideBullets(bullet, "next");
                }
              }
            });
          } else {
            const bullet = bullets[current];
            if (bullet) {
              bullet.classList.add(...params.bulletActiveClass.split(" "));
            }
            if (swiper2.isElement) {
              bullets.forEach((bulletEl, bulletIndex) => {
                bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
              });
            }
            if (params.dynamicBullets) {
              const firstDisplayedBullet = bullets[firstIndex];
              const lastDisplayedBullet = bullets[lastIndex];
              for (let i2 = firstIndex; i2 <= lastIndex; i2 += 1) {
                if (bullets[i2]) {
                  bullets[i2].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                }
              }
              setSideBullets(firstDisplayedBullet, "prev");
              setSideBullets(lastDisplayedBullet, "next");
            }
          }
          if (params.dynamicBullets) {
            const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
            const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
            const offsetProp = rtl ? "right" : "left";
            bullets.forEach((bullet) => {
              bullet.style[swiper2.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
            });
          }
        }
        el2.forEach((subEl, subElIndex) => {
          if (params.type === "fraction") {
            subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl) => {
              fractionEl.textContent = params.formatFractionCurrent(current + 1);
            });
            subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl) => {
              totalEl.textContent = params.formatFractionTotal(total);
            });
          }
          if (params.type === "progressbar") {
            let progressbarDirection;
            if (params.progressbarOpposite) {
              progressbarDirection = swiper2.isHorizontal() ? "vertical" : "horizontal";
            } else {
              progressbarDirection = swiper2.isHorizontal() ? "horizontal" : "vertical";
            }
            const scale = (current + 1) / total;
            let scaleX = 1;
            let scaleY = 1;
            if (progressbarDirection === "horizontal") {
              scaleX = scale;
            } else {
              scaleY = scale;
            }
            subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl) => {
              progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
              progressEl.style.transitionDuration = `${swiper2.params.speed}ms`;
            });
          }
          if (params.type === "custom" && params.renderCustom) {
            subEl.innerHTML = params.renderCustom(swiper2, current + 1, total);
            if (subElIndex === 0)
              emit("paginationRender", subEl);
          } else {
            if (subElIndex === 0)
              emit("paginationRender", subEl);
            emit("paginationUpdate", subEl);
          }
          if (swiper2.params.watchOverflow && swiper2.enabled) {
            subEl.classList[swiper2.isLocked ? "add" : "remove"](params.lockClass);
          }
        });
      }
      function render() {
        const params = swiper2.params.pagination;
        if (isPaginationDisabled())
          return;
        const slidesLength = swiper2.virtual && swiper2.params.virtual.enabled ? swiper2.virtual.slides.length : swiper2.slides.length;
        let el2 = swiper2.pagination.el;
        el2 = makeElementsArray(el2);
        let paginationHTML = "";
        if (params.type === "bullets") {
          let numberOfBullets = swiper2.params.loop ? Math.ceil(slidesLength / swiper2.params.slidesPerGroup) : swiper2.snapGrid.length;
          if (swiper2.params.freeMode && swiper2.params.freeMode.enabled && numberOfBullets > slidesLength) {
            numberOfBullets = slidesLength;
          }
          for (let i2 = 0; i2 < numberOfBullets; i2 += 1) {
            if (params.renderBullet) {
              paginationHTML += params.renderBullet.call(swiper2, i2, params.bulletClass);
            } else {
              paginationHTML += `<${params.bulletElement} ${swiper2.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
            }
          }
        }
        if (params.type === "fraction") {
          if (params.renderFraction) {
            paginationHTML = params.renderFraction.call(swiper2, params.currentClass, params.totalClass);
          } else {
            paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
          }
        }
        if (params.type === "progressbar") {
          if (params.renderProgressbar) {
            paginationHTML = params.renderProgressbar.call(swiper2, params.progressbarFillClass);
          } else {
            paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
          }
        }
        swiper2.pagination.bullets = [];
        el2.forEach((subEl) => {
          if (params.type !== "custom") {
            subEl.innerHTML = paginationHTML || "";
          }
          if (params.type === "bullets") {
            swiper2.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
          }
        });
        if (params.type !== "custom") {
          emit("paginationRender", el2[0]);
        }
      }
      function init2() {
        swiper2.params.pagination = createElementIfNotDefined(swiper2, swiper2.originalParams.pagination, swiper2.params.pagination, {
          el: "swiper-pagination"
        });
        const params = swiper2.params.pagination;
        if (!params.el)
          return;
        let el2;
        if (typeof params.el === "string" && swiper2.isElement) {
          el2 = swiper2.el.querySelector(params.el);
        }
        if (!el2 && typeof params.el === "string") {
          el2 = [...document.querySelectorAll(params.el)];
        }
        if (!el2) {
          el2 = params.el;
        }
        if (!el2 || el2.length === 0)
          return;
        if (swiper2.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el2) && el2.length > 1) {
          el2 = [...swiper2.el.querySelectorAll(params.el)];
          if (el2.length > 1) {
            el2 = el2.filter((subEl) => {
              if (elementParents(subEl, ".swiper")[0] !== swiper2.el)
                return false;
              return true;
            })[0];
          }
        }
        if (Array.isArray(el2) && el2.length === 1)
          el2 = el2[0];
        Object.assign(swiper2.pagination, {
          el: el2
        });
        el2 = makeElementsArray(el2);
        el2.forEach((subEl) => {
          if (params.type === "bullets" && params.clickable) {
            subEl.classList.add(...(params.clickableClass || "").split(" "));
          }
          subEl.classList.add(params.modifierClass + params.type);
          subEl.classList.add(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
          if (params.type === "bullets" && params.dynamicBullets) {
            subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
            dynamicBulletIndex = 0;
            if (params.dynamicMainBullets < 1) {
              params.dynamicMainBullets = 1;
            }
          }
          if (params.type === "progressbar" && params.progressbarOpposite) {
            subEl.classList.add(params.progressbarOppositeClass);
          }
          if (params.clickable) {
            subEl.addEventListener("click", onBulletClick);
          }
          if (!swiper2.enabled) {
            subEl.classList.add(params.lockClass);
          }
        });
      }
      function destroy() {
        const params = swiper2.params.pagination;
        if (isPaginationDisabled())
          return;
        let el2 = swiper2.pagination.el;
        if (el2) {
          el2 = makeElementsArray(el2);
          el2.forEach((subEl) => {
            subEl.classList.remove(params.hiddenClass);
            subEl.classList.remove(params.modifierClass + params.type);
            subEl.classList.remove(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (params.clickable) {
              subEl.classList.remove(...(params.clickableClass || "").split(" "));
              subEl.removeEventListener("click", onBulletClick);
            }
          });
        }
        if (swiper2.pagination.bullets)
          swiper2.pagination.bullets.forEach((subEl) => subEl.classList.remove(...params.bulletActiveClass.split(" ")));
      }
      on2("changeDirection", () => {
        if (!swiper2.pagination || !swiper2.pagination.el)
          return;
        const params = swiper2.params.pagination;
        let {
          el: el2
        } = swiper2.pagination;
        el2 = makeElementsArray(el2);
        el2.forEach((subEl) => {
          subEl.classList.remove(params.horizontalClass, params.verticalClass);
          subEl.classList.add(swiper2.isHorizontal() ? params.horizontalClass : params.verticalClass);
        });
      });
      on2("init", () => {
        if (swiper2.params.pagination.enabled === false) {
          disable();
        } else {
          init2();
          render();
          update2();
        }
      });
      on2("activeIndexChange", () => {
        if (typeof swiper2.snapIndex === "undefined") {
          update2();
        }
      });
      on2("snapIndexChange", () => {
        update2();
      });
      on2("snapGridLengthChange", () => {
        render();
        update2();
      });
      on2("destroy", () => {
        destroy();
      });
      on2("enable disable", () => {
        let {
          el: el2
        } = swiper2.pagination;
        if (el2) {
          el2 = makeElementsArray(el2);
          el2.forEach((subEl) => subEl.classList[swiper2.enabled ? "remove" : "add"](swiper2.params.pagination.lockClass));
        }
      });
      on2("lock unlock", () => {
        update2();
      });
      on2("click", (_s, e2) => {
        const targetEl = e2.target;
        const el2 = makeElementsArray(swiper2.pagination.el);
        if (swiper2.params.pagination.el && swiper2.params.pagination.hideOnClick && el2 && el2.length > 0 && !targetEl.classList.contains(swiper2.params.pagination.bulletClass)) {
          if (swiper2.navigation && (swiper2.navigation.nextEl && targetEl === swiper2.navigation.nextEl || swiper2.navigation.prevEl && targetEl === swiper2.navigation.prevEl))
            return;
          const isHidden = el2[0].classList.contains(swiper2.params.pagination.hiddenClass);
          if (isHidden === true) {
            emit("paginationShow");
          } else {
            emit("paginationHide");
          }
          el2.forEach((subEl) => subEl.classList.toggle(swiper2.params.pagination.hiddenClass));
        }
      });
      const enable = () => {
        swiper2.el.classList.remove(swiper2.params.pagination.paginationDisabledClass);
        let {
          el: el2
        } = swiper2.pagination;
        if (el2) {
          el2 = makeElementsArray(el2);
          el2.forEach((subEl) => subEl.classList.remove(swiper2.params.pagination.paginationDisabledClass));
        }
        init2();
        render();
        update2();
      };
      const disable = () => {
        swiper2.el.classList.add(swiper2.params.pagination.paginationDisabledClass);
        let {
          el: el2
        } = swiper2.pagination;
        if (el2) {
          el2 = makeElementsArray(el2);
          el2.forEach((subEl) => subEl.classList.add(swiper2.params.pagination.paginationDisabledClass));
        }
        destroy();
      };
      Object.assign(swiper2.pagination, {
        enable,
        disable,
        render,
        update: update2,
        init: init2,
        destroy
      });
    }
    function Autoplay(_ref) {
      let {
        swiper: swiper2,
        extendParams,
        on: on2,
        emit,
        params
      } = _ref;
      swiper2.autoplay = {
        running: false,
        paused: false,
        timeLeft: 0
      };
      extendParams({
        autoplay: {
          enabled: false,
          delay: 3e3,
          waitForTransition: true,
          disableOnInteraction: true,
          stopOnLastSlide: false,
          reverseDirection: false,
          pauseOnMouseEnter: false
        }
      });
      let timeout;
      let raf;
      let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
      let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
      let autoplayTimeLeft;
      let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime;
      let wasPaused;
      let isTouched;
      let pausedByTouch;
      let touchStartTimeout;
      let slideChanged;
      let pausedByInteraction;
      function onTransitionEnd(e2) {
        if (!swiper2 || swiper2.destroyed || !swiper2.wrapperEl)
          return;
        if (e2.target !== swiper2.wrapperEl)
          return;
        swiper2.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
        resume();
      }
      const calcTimeLeft = () => {
        if (swiper2.destroyed || !swiper2.autoplay.running)
          return;
        if (swiper2.autoplay.paused) {
          wasPaused = true;
        } else if (wasPaused) {
          autoplayDelayCurrent = autoplayTimeLeft;
          wasPaused = false;
        }
        const timeLeft = swiper2.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();
        swiper2.autoplay.timeLeft = timeLeft;
        emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
        raf = requestAnimationFrame(() => {
          calcTimeLeft();
        });
      };
      const getSlideDelay = () => {
        let activeSlideEl;
        if (swiper2.virtual && swiper2.params.virtual.enabled) {
          activeSlideEl = swiper2.slides.filter((slideEl) => slideEl.classList.contains("swiper-slide-active"))[0];
        } else {
          activeSlideEl = swiper2.slides[swiper2.activeIndex];
        }
        if (!activeSlideEl)
          return void 0;
        const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
        return currentSlideDelay;
      };
      const run = (delayForce) => {
        if (swiper2.destroyed || !swiper2.autoplay.running)
          return;
        cancelAnimationFrame(raf);
        calcTimeLeft();
        let delay = typeof delayForce === "undefined" ? swiper2.params.autoplay.delay : delayForce;
        autoplayDelayTotal = swiper2.params.autoplay.delay;
        autoplayDelayCurrent = swiper2.params.autoplay.delay;
        const currentSlideDelay = getSlideDelay();
        if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
          delay = currentSlideDelay;
          autoplayDelayTotal = currentSlideDelay;
          autoplayDelayCurrent = currentSlideDelay;
        }
        autoplayTimeLeft = delay;
        const speed = swiper2.params.speed;
        const proceed = () => {
          if (!swiper2 || swiper2.destroyed)
            return;
          if (swiper2.params.autoplay.reverseDirection) {
            if (!swiper2.isBeginning || swiper2.params.loop || swiper2.params.rewind) {
              swiper2.slidePrev(speed, true, true);
              emit("autoplay");
            } else if (!swiper2.params.autoplay.stopOnLastSlide) {
              swiper2.slideTo(swiper2.slides.length - 1, speed, true, true);
              emit("autoplay");
            }
          } else {
            if (!swiper2.isEnd || swiper2.params.loop || swiper2.params.rewind) {
              swiper2.slideNext(speed, true, true);
              emit("autoplay");
            } else if (!swiper2.params.autoplay.stopOnLastSlide) {
              swiper2.slideTo(0, speed, true, true);
              emit("autoplay");
            }
          }
          if (swiper2.params.cssMode) {
            autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
            requestAnimationFrame(() => {
              run();
            });
          }
        };
        if (delay > 0) {
          clearTimeout(timeout);
          timeout = setTimeout(() => {
            proceed();
          }, delay);
        } else {
          requestAnimationFrame(() => {
            proceed();
          });
        }
        return delay;
      };
      const start = () => {
        swiper2.autoplay.running = true;
        run();
        emit("autoplayStart");
      };
      const stop = () => {
        swiper2.autoplay.running = false;
        clearTimeout(timeout);
        cancelAnimationFrame(raf);
        emit("autoplayStop");
      };
      const pause = (internal, reset) => {
        if (swiper2.destroyed || !swiper2.autoplay.running)
          return;
        clearTimeout(timeout);
        if (!internal) {
          pausedByInteraction = true;
        }
        const proceed = () => {
          emit("autoplayPause");
          if (swiper2.params.autoplay.waitForTransition) {
            swiper2.wrapperEl.addEventListener("transitionend", onTransitionEnd);
          } else {
            resume();
          }
        };
        swiper2.autoplay.paused = true;
        if (reset) {
          if (slideChanged) {
            autoplayTimeLeft = swiper2.params.autoplay.delay;
          }
          slideChanged = false;
          proceed();
          return;
        }
        const delay = autoplayTimeLeft || swiper2.params.autoplay.delay;
        autoplayTimeLeft = delay - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);
        if (swiper2.isEnd && autoplayTimeLeft < 0 && !swiper2.params.loop)
          return;
        if (autoplayTimeLeft < 0)
          autoplayTimeLeft = 0;
        proceed();
      };
      const resume = () => {
        if (swiper2.isEnd && autoplayTimeLeft < 0 && !swiper2.params.loop || swiper2.destroyed || !swiper2.autoplay.running)
          return;
        autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
        if (pausedByInteraction) {
          pausedByInteraction = false;
          run(autoplayTimeLeft);
        } else {
          run();
        }
        swiper2.autoplay.paused = false;
        emit("autoplayResume");
      };
      const onVisibilityChange = () => {
        if (swiper2.destroyed || !swiper2.autoplay.running)
          return;
        const document2 = getDocument();
        if (document2.visibilityState === "hidden") {
          pausedByInteraction = true;
          pause(true);
        }
        if (document2.visibilityState === "visible") {
          resume();
        }
      };
      const onPointerEnter = (e2) => {
        if (e2.pointerType !== "mouse")
          return;
        pausedByInteraction = true;
        if (swiper2.animating || swiper2.autoplay.paused)
          return;
        pause(true);
      };
      const onPointerLeave = (e2) => {
        if (e2.pointerType !== "mouse")
          return;
        if (swiper2.autoplay.paused) {
          resume();
        }
      };
      const attachMouseEvents = () => {
        if (swiper2.params.autoplay.pauseOnMouseEnter) {
          swiper2.el.addEventListener("pointerenter", onPointerEnter);
          swiper2.el.addEventListener("pointerleave", onPointerLeave);
        }
      };
      const detachMouseEvents = () => {
        swiper2.el.removeEventListener("pointerenter", onPointerEnter);
        swiper2.el.removeEventListener("pointerleave", onPointerLeave);
      };
      const attachDocumentEvents = () => {
        const document2 = getDocument();
        document2.addEventListener("visibilitychange", onVisibilityChange);
      };
      const detachDocumentEvents = () => {
        const document2 = getDocument();
        document2.removeEventListener("visibilitychange", onVisibilityChange);
      };
      on2("init", () => {
        if (swiper2.params.autoplay.enabled) {
          attachMouseEvents();
          attachDocumentEvents();
          autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
          start();
        }
      });
      on2("destroy", () => {
        detachMouseEvents();
        detachDocumentEvents();
        if (swiper2.autoplay.running) {
          stop();
        }
      });
      on2("beforeTransitionStart", (_s, speed, internal) => {
        if (swiper2.destroyed || !swiper2.autoplay.running)
          return;
        if (internal || !swiper2.params.autoplay.disableOnInteraction) {
          pause(true, true);
        } else {
          stop();
        }
      });
      on2("sliderFirstMove", () => {
        if (swiper2.destroyed || !swiper2.autoplay.running)
          return;
        if (swiper2.params.autoplay.disableOnInteraction) {
          stop();
          return;
        }
        isTouched = true;
        pausedByTouch = false;
        pausedByInteraction = false;
        touchStartTimeout = setTimeout(() => {
          pausedByInteraction = true;
          pausedByTouch = true;
          pause(true);
        }, 200);
      });
      on2("touchEnd", () => {
        if (swiper2.destroyed || !swiper2.autoplay.running || !isTouched)
          return;
        clearTimeout(touchStartTimeout);
        clearTimeout(timeout);
        if (swiper2.params.autoplay.disableOnInteraction) {
          pausedByTouch = false;
          isTouched = false;
          return;
        }
        if (pausedByTouch && swiper2.params.cssMode)
          resume();
        pausedByTouch = false;
        isTouched = false;
      });
      on2("slideChange", () => {
        if (swiper2.destroyed || !swiper2.autoplay.running)
          return;
        slideChanged = true;
      });
      Object.assign(swiper2.autoplay, {
        start,
        stop,
        pause,
        resume
      });
    }
    const swiper = "";
    const swiperBundle = "";
    const Container$h = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
  padding: 25px;
  opacity: ${(props) => props.$isVisible ? 1 : 0.5};
  background-color: ${(props) => props.$isDeleted ? "rgba(224, 54, 56, .1)" : props.theme.colors.realWhite};
  transition: opacity 0.2s ease-in-out;
  border-radius: ${(props) => props.theme.utils.br};
  &:hover {
    opacity: 1;
  }
  @media ${(props) => props.theme.media.mobile} {
    padding: 4.38vw 4.38vw 4.7vw;
    min-height: 42.81vw;
    background-color: #fff;
    opacity: 1;
    transition: unset;
  }
`;
    const Head = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;

  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 2.5vw;
  }
`;
    const CompetitionPagination = st$1.p`
  font-size: 15px;
  font-weight: 500;
  line-height: 130%;
  color: ${(props) => props.theme.colors.realBlack};

  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.7vw;
  }
`;
    const CompetitionTitle = st$1.h4`
  margin-bottom: 20px;
  font-size: 25px;
  font-weight: 700;
  line-height: 145.5%;
  color: ${(props) => props.theme.colors.realBlack};

  @media ${(props) => props.theme.media.mobile} {
    font-size: 3.75vw;
    line-height: 140%;
  }
`;
    const CompetitionDescr = st$1.p`
  font-size: 18px;
  font-weight: 400;
  line-height: 170%;
  color: ${(props) => props.theme.colors.realBlack};
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const MoreBtn$1 = st$1(DefaultBtn)`
  width: fit-content;
  margin: auto auto 0;
  padding: 0 40px;
  border-radius: 22.689px;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    function Competition$1({ data, totalCount, index }) {
      const navigate = useNavigate();
      const [deleteCompetition] = useDeleteCompetitionMutation();
      const [restoreCompetition] = useRestoreCompetitionMutation();
      const [updateCompetition] = useUpdateCompetitionMutation();
      const [competitionDescr, setCompetitionDescr] = reactExports.useState("");
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      reactExports.useEffect(() => {
        const ckEditorData = data.text || "";
        const regex = /(<([^>]+)>)/gi;
        const nbsp = /&nbsp;/gi;
        const stringWithoutTags = ckEditorData.replace(regex, "").replace(nbsp, " ");
        if (stringWithoutTags) {
          setCompetitionDescr(stringWithoutTags);
        }
      }, [data.text]);
      const { setLoaderActive, setUpdatingCompetitionData } = useActions();
      const [isDeleted, setDeleted] = reactExports.useState(!!(data == null ? void 0 : data.is_deleted));
      const handleAddCompetition = () => {
        setUpdatingCompetitionData(null);
        navigate("/news/competition/create-competition");
      };
      const handleDeleteCompetition = () => {
        deleteCompetition({ id: data.id }).then(() => {
          setDeleted(true);
        });
      };
      const handleRestoreCompetition = () => {
        restoreCompetition({ id: data.id }).then(() => {
          setDeleted(false);
        });
      };
      const handleEditCompetition = () => {
        navigate(`/news/competition/edit-competition/${data.id}`);
      };
      const handleClickMore = (id2) => {
        navigate(`/news/competitions/${id2}`);
      };
      const handleVisibleCompetition = () => {
        updateCompetition({
          id: data.id,
          status: Number(data.status) === 0 ? 1 : 0
        }).then((res) => {
          if ("data" in res && !res.data.result) {
            alert("    ");
          }
        }).catch((err) => {
          console.error(err);
          alert("    ");
        });
      };
      const mobileNavigate = () => {
        if (isMobile) {
          navigate(`/news/competitions/${data.id}`, { replace: true });
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Container$h,
        {
          onClick: mobileNavigate,
          $isDeleted: isDeleted,
          $isVisible: Number(data.status) === 1,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Head, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs(CompetitionPagination, { children: [
                " ",
                index + 1 + "/" + totalCount
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                AdminBtn,
                {
                  popupName: "",
                  type: ADMIN_BTN_TYPES.edit,
                  popupHandlers: {
                    onAdd: handleAddCompetition,
                    onDelete: isDeleted ? void 0 : handleDeleteCompetition,
                    onRestore: isDeleted ? handleRestoreCompetition : void 0,
                    onEdit: handleEditCompetition,
                    onHide: Number(data.status) === 1 ? handleVisibleCompetition : void 0,
                    onVisible: Number(data.status) === 0 ? handleVisibleCompetition : void 0
                  }
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionTitle, { children: data == null ? void 0 : data.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionDescr, { children: competitionDescr }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(MoreBtn$1, { onClick: () => handleClickMore(data == null ? void 0 : data.id), children: "" })
          ]
        }
      );
    }
    function CompetitionsSwiper({
      data,
      isError,
      isFetching
    }) {
      var _a, _b, _c;
      const swiperRef = reactExports.useRef(null);
      const navigate = useNavigate();
      const handleCreateCompetition = () => {
        navigate(`/news/competition/create-competition`);
      };
      const handlePrev = reactExports.useCallback(() => {
        if (!swiperRef.current)
          return;
        swiperRef.current.swiper.slidePrev();
      }, []);
      const handleNext = reactExports.useCallback(() => {
        if (!swiperRef.current)
          return;
        swiperRef.current.swiper.slideNext();
      }, []);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$i, { children: [
        isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSmall, {}),
        isError && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
        data && !isError && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          !data.data.length && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(
            NoAvailable,
            {
              text: "  ",
              onAdd: handleCreateCompetition,
              style: {
                position: "absolute",
                top: "0",
                left: "0",
                width: "100%",
                height: "100%",
                zIndex: "2"
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Swiper,
            {
              ref: swiperRef,
              style: { width: "100%", height: "100%", overflowY: "unset", position: "relative" },
              autoplay: {
                delay: 4e3,
                disableOnInteraction: false,
                pauseOnMouseEnter: true
              },
              breakpoints: {
                767: {
                  slidesPerView: 1
                },
                320: {
                  slidesPerView: 1.2,
                  centeredSlides: true,
                  spaceBetween: 15
                }
              },
              loop: true,
              modules: [Autoplay, Pagination],
              pagination: { clickable: true },
              children: ((_a = data == null ? void 0 : data.data) == null ? void 0 : _a.length) > 0 && ((_b = data == null ? void 0 : data.data) == null ? void 0 : _b.map(
                (competitionData, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Competition$1,
                  {
                    data: competitionData,
                    totalCount: data == null ? void 0 : data.count,
                    index
                  }
                ) }, competitionData == null ? void 0 : competitionData.id)
              ))
            }
          ),
          ((_c = data == null ? void 0 : data.data) == null ? void 0 : _c.length) > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperPrevBtn, { onClick: handlePrev }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperNextBtn, { onClick: handleNext })
          ] })
        ] })
      ] });
    }
    const star = "/assets/star.svg";
    const activeStar = "/assets/active-star.svg";
    const moreIcon = "/assets/moreIcon.svg";
    const Container$g = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
  width: 49.7%;
  height: 400px;
  padding: 25px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};

  @media ${(props) => props.theme.media.mobile} {
    width: 100%;

    display: none;
  }
`;
    const InfoBlock = st$1(FlexContainer)`
  flex-direction: column;
  gap: 23px;
  margin-bottom: 40px;
`;
    const InfoRaw = st$1(FlexContainer)`
  align-items: center;
`;
    const InfoRawTitle = st$1(Text$6)`
  min-width: fit-content;
  font-size: 20px;
`;
    const InfoRawDots = st$1.div`
  width: 100%;
  height: 13px;
  margin: 0 2%;
  border-bottom: 5px dotted ${(props) => props.theme.colors.greyF1};
`;
    const InfoRawValue = st$1(Text$6)`
  min-width: fit-content;
  font-size: 22px;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 5vw;
  }

`;
    const Footer$1 = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
`;
    const YamaguchiLvl = st$1(FlexContainer)`
  flex-direction: column;
  max-width: 40%;
  row-gap: 8px;
`;
    const YamaguchiLvlTitle = st$1(Text$6)`
  font-size: 15px;
`;
    const StarsContainer = st$1(FlexContainer)`
  align-items: center;
`;
    const Star = st$1(Icon$2)`
  width: 33px;
  height: 33px;
  background-image: url(${(props) => props.$active ? activeStar : star});
`;
    const MoreLink = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  padding: 0 30px;
  border-radius: 22.689px;
  text-decoration: none !important;
  @media ${(props) => props.theme.media.mobile} {
    padding:  0 10px;
  }
`;
    const MoreIcon = st$1(Icon$2)`
  margin-left: 13px;
  background-image: url(${moreIcon});
`;
    const Container$f = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: inherit;
  background-color: rgba(190, 190, 190, 0.5);
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const Text$3 = st$1.p`
  padding: 20px 25px;
  text-align: center;
  font-size: 29.051px;
  font-weight: 400;
  line-height: 100%;
  color: ${(props) => props.theme.colors.realWhite};
  background-color: ${(props) => props.theme.colors.mainBlue};
  transform: rotate(-9.76deg);
`;
    function InDeveloping() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$f, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: " " }) });
    }
    function ManagerInfo({
      percentage,
      salary,
      appSaleValue,
      zebrChair,
      yamaguchiLvl
    }) {
      const stars = [1, 2, 3, 4, 5, 6];
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      const progressInfoStyles = {
        marginBottom: isMobile ? "10px" : "30px"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$g, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InDeveloping, {}),
        percentage && /* @__PURE__ */ jsxRuntimeExports.jsx(
          ProgressInfo,
          {
            percentage,
            text: "   ",
            styles: progressInfoStyles
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoBlock, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoRaw, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawTitle, { children: "" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawDots, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoRawValue, { children: [
              salary,
              " "
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoRaw, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawTitle, { children: " App" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawDots, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawValue, { children: appSaleValue })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoRaw, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawTitle, { children: "  " }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawDots, {}),
            /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawValue, { children: zebrChair })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Footer$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(YamaguchiLvl, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(YamaguchiLvlTitle, { children: " !" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(StarsContainer, { children: stars.map((starNumber) => /* @__PURE__ */ jsxRuntimeExports.jsx(Star, { $active: starNumber > Number(yamaguchiLvl) ? false : true })) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            MoreLink,
            {
              as: "a",
              href: "#",
              children: [
                "",
                /* @__PURE__ */ jsxRuntimeExports.jsx(MoreIcon, {})
              ]
            }
          )
        ] })
      ] });
    }
    const newsApi = api.injectEndpoints({
      endpoints: (builder) => ({
        getAllNews: builder.query({
          query: () => "news",
          providesTags: () => [
            {
              type: "News"
            }
          ]
        }),
        getNewsByCategory: builder.query({
          query: (id2) => `news?category=${id2}`,
          providesTags: () => [
            {
              type: "NewsByCategory"
            }
          ]
        }),
        getNewsById: builder.query({
          query: (id2) => `news/${id2}`,
          providesTags: () => [
            {
              type: "NewsById"
            }
          ]
        }),
        createNews: builder.mutation({
          query: (news) => ({
            url: "news/create",
            method: "POST",
            body: news
          }),
          invalidatesTags: () => [
            {
              type: "News"
            }
          ]
        }),
        updateNews: builder.mutation({
          query: (updateNews) => ({
            url: "news/update",
            method: "POST",
            body: updateNews
          }),
          invalidatesTags: ["News", "NewsByCategory", "NewsById"]
        }),
        deleteNews: builder.mutation({
          query: (id2) => ({
            url: "news/delete",
            method: "POST",
            body: id2
          }),
          invalidatesTags: ["News", "NewsByCategory", "NewsById"]
        }),
        restoreNews: builder.mutation({
          query: (id2) => ({
            url: "news/restore",
            method: "POST",
            body: id2
          }),
          invalidatesTags: ["News", "NewsByCategory", "NewsById"]
        })
      }),
      overrideExisting: false
    });
    const { useGetAllNewsQuery, useCreateNewsMutation, useGetNewsByIdQuery, useDeleteNewsMutation, useRestoreNewsMutation, useUpdateNewsMutation, useGetNewsByCategoryQuery } = newsApi;
    const Container$e = st$1.div`
  display: flex;
  width: 100%;
  flex-direction: column;
  padding: 20px 15px;
  border-radius: ${(props) => props.theme.utils.br};
  opacity: ${(props) => props.$isVisible ? 1 : 0.5};
  background-color: ${(props) => props.$isDeleted ? "rgba(224, 54, 56, .1)" : props.theme.colors.realWhite};
  transition: opacity 0.2s ease-in-out;
  &:hover {
    opacity: 1;
  }

  @media ${(props) => props.theme.media.mobile} {
    padding: 2.5vw 3.125vw;
  }
`;
    const Title$7 = st$1.h3`
  margin-bottom: 25px;
  font-size: 22px;
  font-weight: 700;
  line-height: 149.5%;
  color: ${(props) => props.theme.colors.mainBlue};
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 4.38vw;

    font-size: 3.75vw;
  }
`;
    const Image$2 = st$1.img`
  display: block;
  margin-bottom: 20px;
  border-radius: ${(props) => props.theme.utils.br};
  width: 100%;
  object-fit: contain;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    height: auto;
    margin-bottom: 2.5vw;
  }
`;
    const Footer = st$1(FlexContainer)`
  align-items: center;
  margin-top: 18px;
  @media ${(props) => props.theme.media.mobile} { 
    margin-right: auto;
  }
`;
    const MoreBtn = st$1(DefaultBtn)`
  min-height: 44px;
  width: 158px;
  margin-right: auto;

  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const ImageContainer = st$1.div`
  aspect-ratio: 16/9;
  overflow: hidden;
  border-radius: ${(props) => props.theme.utils.br};
`;
    const Container$d = st$1.div`
  display: flex;
  align-items: center;
  margin-left: auto;
  @media ${(props) => props.theme.media.mobile} {
    justify-content: flex-start;
    margin: 0 auto 0 0 ;
    
  }
`;
    const Date$1 = st$1.p`
  margin-right: 20px;
  font-size: 18px;
  font-weight: 400;
  line-height: 149.5%;
  color: ${(props) => props.theme.colors.grey93};
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 6.25vw;
    font-size: 3.75vw;
  }
`;
    const Author = st$1(Date$1)``;
    function NewsRequisites({
      date,
      author,
      adminHandlers = {},
      onClick: onClick2 = () => {
      }
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$d, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Date$1, { children: date }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Author, { children: author }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdminBtn,
          {
            popupName: "",
            type: "edit",
            onClick: onClick2,
            popupHandlers: adminHandlers
          }
        )
      ] });
    }
    function NewsEl({ data }) {
      const { setLoaderActive } = useActions();
      const [authorName, setAuthorName] = reactExports.useState("");
      const [imgUrl, setImgUrl] = reactExports.useState("");
      const navigate = useNavigate();
      const [deleteNews] = useDeleteNewsMutation();
      const [restoreNews] = useRestoreNewsMutation();
      const [update2] = useUpdateNewsMutation();
      const [isMobile, setIsMobile] = reactExports.useState(window.innerWidth <= 600);
      reactExports.useEffect(() => {
        const handleResize = () => {
          setIsMobile(window.innerWidth <= 600);
        };
        window.addEventListener("resize", handleResize);
      }, []);
      const mobileNavigate = () => {
        if (isMobile) {
          navigate(`/news/${data.id}`, { replace: true });
        }
      };
      const DesNavigateNews = () => {
        if (!isMobile) {
          navigate(`/news/${data.id}`, { replace: true });
        }
      };
      reactExports.useEffect(() => {
        const name = data.user ? data.user.name : data.user_id;
        setAuthorName(name);
        const ckEditorData = data.text || "";
        const regex = /<img.*?src=\"([^\"]*)\".*?>/g;
        const match2 = regex.exec(ckEditorData);
        const srcValue = match2 ? match2[1] : null;
        setImgUrl(srcValue);
      }, [data.text, data.user, data.user_id]);
      const handleEditNews = () => {
        navigate(`/news/edit-news/${data.id}`);
      };
      const handleDeleteNews = () => {
        deleteNews({
          id: data.id
        }).then((res) => {
          if ("data" in res && !res.data.result) {
            alert("    ");
          }
        });
        setLoaderActive(true);
      };
      const handleRestoreNews = () => {
        restoreNews({
          id: data.id
        }).then((res) => {
          if ("data" in res && !res.data.result) {
            alert("    ");
          }
        });
        setLoaderActive(true);
      };
      const handleVisibileNews = () => {
        update2({
          id: data.id,
          status: Number(data.status) === 0 ? 1 : 0
        });
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Container$e,
        {
          onClick: mobileNavigate,
          $isDeleted: !!data.is_deleted,
          $isVisible: Number(data.status) !== 0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Title$7, { children: data.title }),
            imgUrl && /* @__PURE__ */ jsxRuntimeExports.jsx(ImageContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Image$2, { src: imgUrl }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Footer, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(MoreBtn, { onClick: DesNavigateNews, children: "" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                NewsRequisites,
                {
                  author: authorName,
                  date: data.date,
                  adminHandlers: {
                    onEdit: handleEditNews,
                    onDelete: data.is_deleted ? void 0 : handleDeleteNews,
                    onRestore: data.is_deleted ? handleRestoreNews : void 0,
                    onVisible: Number(data.status) === 0 ? handleVisibileNews : void 0,
                    onHide: Number(data.status) === 1 ? handleVisibileNews : void 0
                  }
                }
              )
            ] })
          ]
        }
      );
    }
    const Container$c = st$1(FlexContainer)`
  flex-direction: column;
`;
    const Title$6 = st$1(Text$6)`
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 75%;
  align-self: flex-end;
  margin-bottom: 10px;
  font-size: 15px;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const ContentWrapper = st$1(FlexContainer)``;
    const News$1 = st$1(FlexContainer)`
  position: relative;
  width: 75%;
  min-height: 150px;
  flex-direction: column;
  row-gap: 10px;
  @media ${(props) => props.theme.media.desktop} {
    border-radius: ${(props) => props.theme.utils.br};
  }

  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
  }
`;
    const Wrapper = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 22px;
  width: 25%;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const Item = st$1(Text$6)`
  font-size: 22px;
  cursor: pointer;

  &:hover {
    text-decoration: underline;
  }
`;
    function NavListItem({ title, onClick: onClick2 = () => {
    } }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Item, { onClick: onClick2, children: title });
    }
    const newsCategoryApi = api.injectEndpoints({
      endpoints: (builder) => ({
        getNewsCategory: builder.query({
          query: () => "news-category",
          providesTags: () => [
            {
              type: "NewsCategory"
            }
          ]
        }),
        createNewsCategory: builder.mutation({
          query: (data) => ({
            url: "news-category/create",
            method: "POST",
            body: data
          }),
          invalidatesTags: () => [
            {
              type: "NewsCategory"
            }
          ]
        }),
        updateNewsCategory: builder.mutation({
          query: (data) => ({
            url: "news-category/update",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["NewsCategory"]
        }),
        deleteNewsCategory: builder.mutation({
          query: (data) => ({
            url: "news-category/delete",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["NewsCategory"]
        }),
        restoreNewsCategory: builder.mutation({
          query: (data) => ({
            url: "news-category/restore",
            method: "POST",
            body: data
          }),
          invalidatesTags: ["NewsCategory"]
        })
      }),
      overrideExisting: false
    });
    const {
      useCreateNewsCategoryMutation,
      useDeleteNewsCategoryMutation,
      useGetNewsCategoryQuery,
      useRestoreNewsCategoryMutation,
      useUpdateNewsCategoryMutation
    } = newsCategoryApi;
    function NewsCategoryWrapper({ children }) {
      const { data, isError, isLoading } = useGetNewsCategoryQuery();
      const navigate = useNavigate();
      const handleGoToCategory = (id2) => {
        navigate(`/news?category=${id2}`);
      };
      const handleGoToAllNews = () => {
        navigate("/news");
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Wrapper, { children: [
        children,
        data && data.data.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          NavListItem,
          {
            title: " ",
            onClick: handleGoToAllNews
          }
        ),
        isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "..." }),
        isError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "!" }),
        !isError && !isLoading && data && data.data.map((newsCategory) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          NavListItem,
          {
            onClick: () => handleGoToCategory(newsCategory.id),
            title: newsCategory.title
          },
          newsCategory.id
        ))
      ] });
    }
    const dropMenuIcon = "/assets/caret-up-mob-news.svg";
    const dropMenu = st$1.div`
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  margin-bottom: 4.38vw;
`;
    const dropMenuImg = st$1(Icon$2)`
  background-image: url(${dropMenuIcon});
`;
    const filterPopup = st$1.div`
  position: absolute;
  flex-direction: column;
  align-items: center;
  row-gap: 2vw;
  width: 90%;
  left: 50%;
  top: 100%;
  padding: 4.38vw 3.13vw;
  transform: translateX(-50%);
  background-color: #fff;
  border-radius: ${(props) => props.theme.utils.br};
  z-index: 222;
`;
    const titleFilter = st$1.p`
  color: ${(props) => props.theme.colors.mainBlue};
  font-family: "Montserrat";
  font-size: 4.7vw;
  font-weight: 700;
  line-height: 149.5%;
`;
    function NewsCategoryDropPopup({ NewsCategory }) {
      const navigate = useNavigate();
      const [isOpen, setOpen] = reactExports.useState();
      const { data, isError, isLoading } = NewsCategory;
      const handleToglePopupCategories = () => {
        setOpen((prevState) => !prevState);
      };
      const [isTextNewsCategory, setTextNewsCategory] = reactExports.useState(" ");
      const updateText = (text) => {
        setTextNewsCategory(text);
      };
      const popupRef = reactExports.useRef(null);
      const currentURL = window.location.href;
      const handleOutsideClick = (event) => {
        if (popupRef.current && !popupRef.current.contains(event.target)) {
          setOpen(false);
        }
      };
      reactExports.useEffect(() => {
        const handleTouchStart = (event) => handleOutsideClick(event);
        document.addEventListener("touchstart", handleTouchStart);
        return () => {
          document.removeEventListener("touchstart", handleTouchStart);
        };
      }, []);
      const handleGoToCategory = (id2, text) => {
        navigate(`/news?category=${id2}`);
        updateText(text);
        setOpen(false);
      };
      const handleGoToAllNews = () => {
        navigate("/news", { replace: true });
        updateText(" ");
        setOpen(false);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(dropMenu, { ref: popupRef, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(titleFilter, { onClick: handleToglePopupCategories, children: isTextNewsCategory }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          dropMenuImg,
          {
            style: {
              transition: "transform .2s ease",
              transform: `rotate(${isOpen ? "180deg" : "0"})`
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(filterPopup, { style: { display: isOpen ? "flex" : "none" }, children: [
          currentURL !== `http://kaizen-mini.borboza.com/news` ? /* @__PURE__ */ jsxRuntimeExports.jsx(titleFilter, { onClick: handleGoToAllNews, children: " " }) : null,
          !isError && !isLoading && data && data.data.map((newsCategory) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            titleFilter,
            {
              onClick: () => handleGoToCategory(newsCategory.id, newsCategory.title),
              children: newsCategory.title
            },
            newsCategory.id
          ))
        ] })
      ] }) });
    }
    function NewsContainer() {
      var _a;
      const navigate = useNavigate();
      const { setLoaderActive } = useActions();
      const [searchParams] = useSearchParams();
      const [categorySearchParam, setCategorySearchParam] = reactExports.useState(
        null
      );
      const { data, isError, isFetching } = useGetAllNewsQuery(void 0, {
        skip: !!categorySearchParam
      });
      const isMobile = useMediaQuery(MediaQueries.mobile);
      const newsByIdData = useGetNewsCategoryQuery();
      const newsByCategory = useGetNewsByCategoryQuery(
        Number(categorySearchParam),
        {
          skip: !categorySearchParam
        }
      );
      reactExports.useEffect(() => {
        setCategorySearchParam(searchParams.get("category"));
      }, [searchParams]);
      reactExports.useEffect(() => {
        setLoaderActive(isFetching);
      }, [isFetching, setLoaderActive]);
      const handleCreateNews = () => {
        navigate("/news/create-news");
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$c, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$6, { children: [
          "",
          /* @__PURE__ */ jsxRuntimeExports.jsx(AdminBtn, { popupName: "", type: "add", onClick: handleCreateNews })
        ] }),
        isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(NewsCategoryDropPopup, { NewsCategory: newsByIdData }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ContentWrapper, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(NewsCategoryWrapper, {}),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(News$1, { children: [
            isFetching || newsByCategory.isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSmall, {}),
            isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
            categorySearchParam && newsByCategory.data && newsByCategory.data.data.length > 0 && newsByCategory.data.data.map((newsData) => /* @__PURE__ */ jsxRuntimeExports.jsx(NewsEl, { data: newsData })),
            !categorySearchParam && data && data.data.length > 0 && data.data.slice().reverse().map((newsData) => /* @__PURE__ */ jsxRuntimeExports.jsx(NewsEl, { data: newsData })),
            !((_a = newsByCategory.data) == null ? void 0 : _a.data.length) && !(data == null ? void 0 : data.data.length) && !isFetching && !newsByCategory.isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(
              NoAvailable,
              {
                text: "  ",
                onAdd: handleCreateNews
              }
            )
          ] })
        ] })
      ] });
    }
    const Container$b = st$1(FlexContainer)`
  flex-direction: column;
  padding: 60px 0 90px 0;
  @media ${(props) => props.theme.media.mobile} {
    padding: 5vw 0 0 ;

  }
`;
    const MainInfoWrapper = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  margin-bottom: 35px;

  @media ${(props) => props.theme.media.mobile} {
    flex-direction: column;
    align-items: unset;
    justify-content: unset;
    row-gap: 11.3vw;
  }
`;
    function NewsMain() {
      const { data, isError, isFetching } = useGetAllCompetitionsQuery();
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$b, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(MainInfoWrapper, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionsSwiper, { data, isError, isFetching }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            ManagerInfo,
            {
              percentage: "100",
              salary: "999999",
              appSaleValue: "999",
              yamaguchiLvl: "3",
              zebrChair: "2(x)  33"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NewsContainer, {})
      ] }) });
    }
    const Container$a = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  padding-top: 25px;
`;
    const backIcon = "/assets/arrow-left-blue.svg";
    const backIconMob = "/assets/angle-right-mob.svg";
    const Button = st$1.button`
  display: flex;
  align-items: center;
  width: fit-content;
  background-color: transparent;
  padding: 0;
  margin: 0;
  margin-bottom: 18px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 5vw;
  }
`;
    const Icon = st$1(Icon$2)`
  margin-right: 8px;
  background-image: url(${backIcon});
  @media ${(props) => props.theme.media.mobile} {
    background-image: url(${backIconMob});
    margin-right: 2.81vw;
  }
`;
    const Text$2 = st$1.span`
  font-size: 22px;
  font-weight: 500;
  line-height: 149.5%;
  color: ${(props) => props.theme.colors.mainBlue};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 3.75vw;
    font-weight: 700;
  }
`;
    function BackBtn({ onClick: onClick2 = () => {
    }, text }) {
      const [textBtn, setTextBtn] = reactExports.useState("");
      reactExports.useEffect(() => {
        if (text !== void 0) {
          setTextBtn(text);
        } else {
          setTextBtn("");
        }
      }, [text]);
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: onClick2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Text$2, { children: textBtn })
      ] });
    }
    const Container$9 = st$1.div`
  display: flex;
  width: 100%;
`;
    st$1.div`
  display: flex;
  flex-direction: column;
  width: 75%;
  padding: 15px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
`;
    st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  margin-bottom: 50px;
`;
    st$1.div`
  width: 100%;
  margin-bottom: 50px;

  font-family: "Montserrat";
  font-size: 18px;
  font-weight: 400;
  line-height: 170%;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 3.13vw;

    font-size: 4.7vw;
  }
`;
    const Bottom = st$1.div`
  display: flex;
  align-items: center;
`;
    const Content$1 = st$1.div`
  display: flex;
  flex-direction: column;
  position: relative;
  width: 75%;
  min-height: 200px;
  padding: 15px;
  border-radius: ${(props) => props.theme.utils.br};
  opacity: ${(props) => props.$isVisible ? 1 : 0.5};
  background-color: ${(props) => props.$isDeleted ? "rgba(224, 54, 56, .1)" : props.theme.colors.realWhite};
  transition: opacity 0.2s ease-in-out;
  &:hover {
    opacity: 1;
  }
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    padding: 4.6875vw;
  }
`;
    function Content({ children, isDeleted, isVisible }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Content$1, { $isDeleted: isDeleted, $isVisible: isVisible, children });
    }
    const Title$5 = st$1(Text$6)`
  margin-bottom: 23px;
  font-size: 22px;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    function ContentTitle({ title }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Title$5, { children: title });
    }
    function NewsContent() {
      var _a;
      const { setLoaderActive } = useActions();
      const { newsId } = useParams();
      const { data, isFetching, isError } = useGetNewsByIdQuery(Number(newsId), {
        skip: !newsId
      });
      const navigate = useNavigate();
      const [deleteNews] = useDeleteNewsMutation();
      const [restoreNews] = useRestoreNewsMutation();
      const [update2] = useUpdateNewsMutation();
      reactExports.useEffect(() => {
        setLoaderActive(isFetching);
      }, [isFetching, setLoaderActive]);
      const handleEditNews = () => {
        if (!data) {
          console.error("no data:" + data);
          return;
        }
        navigate(`/news/edit-news/${data.data.id}`);
      };
      const handleDeleteNews = () => {
        if (!data) {
          console.error("no data:" + data);
          return;
        }
        deleteNews({
          id: data.data.id
        }).then((res) => {
          if ("data" in res && !res.data.result) {
            alert("    ");
          }
        });
        setLoaderActive(true);
      };
      const handleRestoreNews = () => {
        if (!data) {
          console.error("no data:" + data);
          return;
        }
        restoreNews({
          id: data.data.id
        }).then((res) => {
          if ("data" in res && !res.data.result) {
            alert("    ");
          }
        });
        setLoaderActive(true);
      };
      const handleVisibileNews = () => {
        if (!data) {
          console.error("no data:" + data);
          return;
        }
        update2({
          id: data.data.id,
          status: Number(data.data.status) === 0 ? 1 : 0
        });
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { isDeleted: !!(data == null ? void 0 : data.data.is_deleted), isVisible: Number(data == null ? void 0 : data.data.status) === 1, children: [
        isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
        data && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(ContentTitle, { title: data.data.title }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditorOutput, { data: data.data.text }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Bottom, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            NewsRequisites,
            {
              author: ((_a = data.data.user) == null ? void 0 : _a.name) || data.data.user_id,
              date: data.data.date,
              adminHandlers: {
                onEdit: handleEditNews,
                onDelete: data.data.is_deleted ? void 0 : handleDeleteNews,
                onRestore: data.data.is_deleted ? handleRestoreNews : void 0,
                onVisible: Number(data.data.status) === 0 ? handleVisibileNews : void 0,
                onHide: Number(data.data.status) === 1 ? handleVisibileNews : void 0
              }
            }
          ) })
        ] })
      ] });
    }
    function NewsByIdContent() {
      const navigate = useNavigate();
      const handleGoBack = () => {
        navigate("/news");
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$9, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(NewsCategoryWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackBtn, { onClick: handleGoBack }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NewsContent, {})
      ] });
    }
    function NewsById() {
      const navigate = useNavigate();
      const handleCreateNews = () => {
        navigate("/news/create-news");
      };
      const { newsId } = useParams();
      const { data, isFetching, isError } = useGetNewsByIdQuery(Number(newsId), {
        skip: !newsId
      });
      const isMobile = useMediaQuery(MediaQueries.mobile);
      function handleGoBack() {
        navigate("/news", { replace: true });
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$a, { children: [
        isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackBtn, { onClick: handleGoBack, text: data == null ? void 0 : data.data.title }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdminBtn,
          {
            popupName: "",
            type: "add",
            styles: { marginLeft: "auto" },
            onClick: handleCreateNews
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(NewsByIdContent, {})
      ] }) });
    }
    const List = st$1.ul`
  display: flex;
  flex-direction: column;
  row-gap: 22px;
`;
    function NavList({ children }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(List, { children });
    }
    function CompetitionAside() {
      var _a;
      const navigate = useNavigate();
      const { competitionId } = useParams();
      const { data, isError, isFetching } = useGetAllCompetitionsQuery();
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      const competitionData = useGetCompetitionByIdQuery(Number(competitionId), {
        skip: !isMobile
      });
      const handleGoBack = () => {
        navigate("/news");
      };
      const handleGoToCompetition = (id2) => {
        navigate(`/news/competitions/${id2}`);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(BackBtn, { onClick: handleGoBack, text: isMobile ? (_a = competitionData.data) == null ? void 0 : _a.data.title : void 0 }),
        !isMobile && data && !isError && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(NavList, { children: data.data.map(
          (competition) => {
            if (Number(competitionId) === competition.id) {
              return null;
            }
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              NavListItem,
              {
                title: competition.title,
                onClick: () => {
                  handleGoToCompetition(competition.id);
                }
              },
              competition.id
            );
          }
        ) })
      ] });
    }
    const Container$8 = st$1(FlexContainer)`
  padding-top: 50px;
  @media ${(props) => props.theme.media.mobile} {
    flex-direction: column;
    padding-top: 4.6875vw;
  }
`;
    const Container$7 = st$1(FlexContainer)`
  flex-direction: column;
  width: 25%;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
  }
`;
    function AsideBar({ children }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$7, { children });
    }
    const externalLinkIcon = "/assets/moreIcon.svg";
    const BottomContainer$2 = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  @media ${(props) => props.theme.media.mobile} {
    flex-direction: column-reverse;
    align-items: flex-start;
    row-gap: 9.375vw;
  }
`;
    const AllCompetitionsLenght = st$1.p`
  margin-bottom: 11px;

  font-size: 15px;
  font-weight: 500;
  line-height: 130%;
  @media ${(props) => props.theme.media.mobile} {
    margin-left: 10.94vw;
    margin-bottom: 9.69vw;

    font-size: 3.75vw;
  }
`;
    st$1(FlexContainer)`
  flex-direction: column;
  margin-bottom: 50px;
`;
    const Link = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  justify-content: center;
  width: fit-content;
  min-height: 44px;
  padding: 0 20px 0 23px;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    min-height: 12.5vw;
  }
`;
    const LinkIcon = st$1(Icon$2)`
  margin-left: 10px;
  background-image: url(${externalLinkIcon});
`;
    const ContainerBtn = st$1.div`
  width: 100%;
  display: flex;
  position: absolute;
  top: 107%;
  right: 0;
  justify-content: space-between;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
    const BtnLeft = st$1.button`
  width: 24px;
  height: 24px;
  background-image: url(${arrowLeft});
  background-size: contain;
`;
    const BtnRight = st$1(BtnLeft)`
  transform: rotate(-180deg);
`;
    function CompetitionContent() {
      var _a, _b;
      const { setLoaderActive } = useActions();
      const { competitionId } = useParams();
      const navigate = useNavigate();
      const [deleteCompetition] = useDeleteCompetitionMutation();
      const [restoreCompetition] = useRestoreCompetitionMutation();
      const [updateCompetition] = useUpdateCompetitionMutation();
      const { data, isFetching, isError } = useGetCompetitionByIdQuery(
        Number(competitionId),
        {
          skip: !competitionId
        }
      );
      const [isAllCompetitionsLenght, setAllCompetitionsLenght] = reactExports.useState("");
      const allCompetitions = useGetAllCompetitionsQuery();
      const handleEditTextCompetitionLenght = () => {
        var _a2, _b2;
        return [
          setAllCompetitionsLenght(
            ` ${(data == null ? void 0 : data.data.id) === void 0 ? "1" : data == null ? void 0 : data.data.id}/${((_a2 = allCompetitions.data) == null ? void 0 : _a2.data.length) === void 0 ? "1" : (_b2 = allCompetitions.data) == null ? void 0 : _b2.data.length}`
          )
        ];
      };
      reactExports.useEffect(() => {
        handleEditTextCompetitionLenght();
      }, [data, (_a = allCompetitions.data) == null ? void 0 : _a.data.length]);
      const isMobile = useMediaQuery(MediaQueries.mobile);
      const handleEditCompetition = () => {
        if (!data) {
          console.error("No data:", data);
          return;
        }
        navigate(`/news/competition/edit-competition/${data == null ? void 0 : data.data.id}`);
      };
      const handleDeleteCompetition = () => {
        if (!data) {
          console.error("No data:", data);
          return;
        }
        deleteCompetition({ id: data.data.id }).then(() => {
          setLoaderActive(false);
        });
        setLoaderActive(true);
      };
      const handleRestoreCompetition = () => {
        if (!data) {
          console.error("No data:", data);
          return;
        }
        restoreCompetition({ id: data.data.id }).then(() => {
          setLoaderActive(false);
        });
        setLoaderActive(true);
      };
      const handleVisibleCompetition = () => {
        if (!data) {
          console.error("No data:", data);
          return;
        }
        updateCompetition({
          id: data.data.id,
          status: Number(data.data.status) === 0 ? 1 : 0
        }).then((res) => {
          if ("data" in res && !res.data.result) {
            alert("    ");
          }
          setLoaderActive(false);
        }).catch((err) => {
          console.error(err);
          alert("    ");
          setLoaderActive(false);
        });
        setLoaderActive(true);
      };
      const handleNextCompetition = () => {
        var _a2, _b2;
        if ((data == null ? void 0 : data.data.id) < ((_a2 = allCompetitions.data) == null ? void 0 : _a2.data.length)) {
          navigate(`/news/competitions/${(data == null ? void 0 : data.data.id) + 1}`);
        } else if ((data == null ? void 0 : data.data.id) == ((_b2 = allCompetitions.data) == null ? void 0 : _b2.data.length)) {
          navigate(`/news/competitions/${1}`);
        }
      };
      const handleBackCompetition = () => {
        var _a2;
        if ((data == null ? void 0 : data.data.id) !== 1) {
          navigate(`/news/competitions/${(data == null ? void 0 : data.data.id) - 1}`);
        } else if ((data == null ? void 0 : data.data.id) == 1) {
          navigate(`/news/competitions/${(_a2 = allCompetitions.data) == null ? void 0 : _a2.data.length}`);
        }
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(AllCompetitionsLenght, { children: isAllCompetitionsLenght }) : null,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content,
          {
            isDeleted: !!(data == null ? void 0 : data.data.is_deleted),
            isVisible: Number(data == null ? void 0 : data.data.status) === 1,
            children: [
              !isMobile ? /* @__PURE__ */ jsxRuntimeExports.jsx(AllCompetitionsLenght, { children: isAllCompetitionsLenght }) : null,
              data && !isError && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ContentTitle, { title: data == null ? void 0 : data.data.title }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditorOutput, { data: data.data.text }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(BottomContainer$2, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    Link$1,
                    {
                      to: data.data.link,
                      target: "_blank",
                      style: {
                        textDecoration: "none",
                        width: isMobile ? "100%" : "auto"
                      },
                      children: data.data.link && /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { children: [
                        " ",
                        /* @__PURE__ */ jsxRuntimeExports.jsx(LinkIcon, {})
                      ] })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    NewsRequisites,
                    {
                      date: data.data.date,
                      author: ((_b = data.data.user) == null ? void 0 : _b.name) || data.data.user_id,
                      adminHandlers: {
                        onDelete: data.data.is_deleted ? void 0 : handleDeleteCompetition,
                        onRestore: data.data.is_deleted ? handleRestoreCompetition : void 0,
                        onEdit: handleEditCompetition,
                        onHide: Number(data.data.status) === 1 ? handleVisibleCompetition : void 0,
                        onVisible: Number(data.data.status) === 0 ? handleVisibleCompetition : void 0
                      }
                    }
                  )
                ] })
              ] }),
              isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSmall, {}),
              isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(ContainerBtn, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(BtnLeft, { onClick: handleBackCompetition }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(BtnRight, { onClick: handleNextCompetition })
              ] })
            ]
          }
        )
      ] });
    }
    function Competition() {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$8, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AsideBar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionAside, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionContent, {})
      ] }) });
    }
    function News() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(NewsMain, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/:newsId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(NewsById, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/competitions/:competitionId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Competition, {}) })
      ] });
    }
    function Main() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header$2, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Route,
            {
              path: "/news/*",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(News, {})
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Route,
            {
              path: "/courses/*",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(Courses, {})
            }
          )
        ] })
      ] });
    }
    const ModalLayout$1 = st$1.div`
  display: flex;
  justify-content: flex-end;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: transparent;
  animation: overlayEntrance 0.3s ease-out forwards;
  z-index: ${(props) => props.theme.utils.zIndex.darkOverlay};
  @media ${(props) => props.theme.media.mobile} {
    animation: unset;
  }

  @keyframes overlayEntrance {
    100% {
      background-color: rgba(0, 0, 0, 0.7);
    }
  }
`;
    const Window = st$1.div`
  display: flex;
  flex-direction: column;
  position: relative;
  width: fit-content;
  height: 100%;
  overflow-y: auto;
  background-color: ${(props) => props.theme.colors.realWhite};
  animation: windowEntrance 0.3s ease-out forwards;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    padding: 3.125vw 0 0;
    animation-name: windowEntrance;
  }

  @keyframes windowEntrance {
    0% {
      transform: translateX(100%);
    }
    100% {
      transform: translate(0%);
    }
  }
`;
    const ModalName = st$1.h3`
  position: absolute;
  top: 35px;
  left: -155px;
  font-size: 92.5px;
  font-weight: 700;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realWhite};
  transform: rotate(-180deg);
  writing-mode: vertical-lr;
  pointer-events: none;
  @media ${(props) => props.theme.media.mobile} {
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: static;
    padding: 0 3.125vw;
    margin-bottom: 4.6875vw;
    font-size: 3.75vw;
    color: ${(props) => props.theme.colors.mainBlue};
    transform: none;
    writing-mode: unset;
    pointer-events: unset;
  }
`;
    const CloseBtn = st$1.button`
  display: none;
  @media ${(props) => props.theme.media.mobile} {
    display: block;
    width: 7.5vw;
    height: 7.5vw;
    padding: 0;
    margin: 0;
    background-color: transparent;
    background-image: url(${closeIcon});
    background-repeat: no-repeat;
    background-position: center;
    background-size: 100%;
  }
`;
    function ModalLayout({ children, modalType: type }) {
      const { setModalOpen } = useActions();
      const [modalName, setModalName] = reactExports.useState();
      reactExports.useEffect(() => {
        let name = "";
        switch (type) {
          case MODAL_TYPES.createCourse:
            name = " ";
            break;
          case MODAL_TYPES.editCourse:
            name = " ";
            break;
          case MODAL_TYPES.createChapter:
            name = " ";
            break;
          case MODAL_TYPES.editChapter:
            name = " ";
            break;
          case MODAL_TYPES.createTheme:
            name = " ";
            break;
          case MODAL_TYPES.editTheme:
            name = " ";
            break;
          case MODAL_TYPES.newsCategory:
            name = "";
            break;
          default:
            console.error(`Unknown modal type: ${type}`);
        }
        setModalName(name);
      }, [type]);
      const modalRoot = document.getElementById("modal-root");
      if (!modalRoot)
        return;
      const handleOverlayClick = (event) => {
        if (event.target === event.currentTarget) {
          setModalOpen(false);
        }
      };
      const handleCloseModal = () => {
        setModalOpen(false);
      };
      return ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(ModalLayout$1, { onClick: handleOverlayClick, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Window, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalName, { children: [
            modalName,
            /* @__PURE__ */ jsxRuntimeExports.jsx(CloseBtn, { onClick: handleCloseModal })
          ] }),
          children
        ] }) }),
        modalRoot
      );
    }
    const imagesIcon = "/assets/imagesIcon.svg";
    const NameInput = st$1(InputWithState)`
  margin-bottom: 20px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 2.5vw;
  }
`;
    const Textarea = st$1(InputWithState)`
  min-height: 557px;
  margin-bottom: 15px;
  resize: none;
  outline: none;
  @media ${(props) => props.theme.media.mobile} {
    min-height: 93.125vw;
    margin-bottom: 2.5vw;
  }
`;
    st$1(DefaultBtn)`
  width: fit-content;
  min-height: 41px;
  padding: 0 24px 0 52px;
  margin-bottom: 20px;
  font-size: 15.397px;
  background-image: url(${imagesIcon});
  background-repeat: no-repeat;
  background-position: 17px 9px;
  background-size: 24px;
  @media ${(props) => props.theme.media.mobile} {
    min-height: 12.5vw;
    padding: 0  7.5vw 0 16.25vw;
    margin-bottom: 4.6875vw;
    font-size: 4.6875vw;
    background-size: 7.5vw;
    background-position: 5.3125vw center;
  }
`;
    const BottomContainer$1 = st$1(FlexContainer)`
  justify-content: space-between;
`;
    const Container$6 = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  row-gap: 10px;
  width: 100%;
  padding: 25px;
  margin-top: auto;
  border-top: 1px solid ${(props) => props.theme.colors.greyF1};
  @media ${(props) => props.theme.media.mobile} {
    flex-wrap: nowrap;
    padding: 3.125vw;
    gap: unset;
  }
`;
    const ConfirmBtn = st$1(DefaultBtn)`
  width: 49%;
  min-width: 449px;
  @media ${(props) => props.theme.media.mobile} {
    min-width: unset;
    width: 48%;
    min-height: 15.625vw;
    font-size: 4.6875vw;
  }
`;
    const CancelBtn = st$1(ConfirmBtn)`
  color: ${(props) => props.theme.colors.grey93};
  background-color: ${(props) => props.theme.colors.greyF1};

  &:hover {
    background-color: ${(props) => props.theme.colors.greyEO};
  }
`;
    function FormControls({ handlers, names, containerStyles }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$6, { style: containerStyles, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CancelBtn, { onClick: handlers.cancel, children: names.cancel }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmBtn, { onClick: handlers.confirm, children: names.confirm })
      ] });
    }
    const Container$5 = st$1(FlexContainer)`
  flex-direction: column;
  width: ${(props) => props.$width};
  height: 100%;
  padding-top: 25px;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    padding-top: 0;
  }
`;
    const Form = st$1.form`
  padding: 0 25px 5vh;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0 3.125vw 15%;
  }
`;
    function ModalForm({
      children,
      handlers,
      names,
      width: width2,
      onSubmit = () => {
      },
      styles: styles2
    }) {
      const handleSubmit = (event) => {
        event.preventDefault();
        onSubmit();
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Container$5,
        {
          $width: width2,
          style: styles2,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { onSubmit: handleSubmit, children }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              FormControls,
              {
                handlers,
                names
              }
            )
          ]
        }
      );
    }
    const editorjs = "";
    const InputWrapper = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  width: fit-content;
`;
    const FileInput = st$1.input`
  position: absolute;
  left: 50%;
  top: 50%;
  width: 100%;
  height: 100%;
  opacity: 0;
  transform: translate(-50%, -50%);
  cursor: pointer;
`;
    function CustomFileInput({ onSet, children }) {
      const handleFileChange = (event) => {
        const file = event.target.files && event.target.files[0];
        if (file && file.type.startsWith("image/")) {
          const fileExtension = file.name.split(".").pop() || null;
          if (fileExtension) {
            convertToBase64(file, fileExtension);
          }
        }
      };
      const convertToBase64 = (file, extension) => {
        const reader = new FileReader();
        reader.onload = () => {
          const base64 = reader.result;
          onSet(base64, extension);
        };
        reader.readAsDataURL(file);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(InputWrapper, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FileInput,
          {
            type: "file",
            accept: "image/*",
            onChange: handleFileChange
          }
        ),
        children
      ] });
    }
    const ImageWrapper = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-width: 342px;
  margin-bottom: 13px;
  aspect-ratio: 3/2;
  border-radius: 19px;
  background-color: ${(props) => props.theme.colors.greyF1};
  overflow: hidden;
  @media ${(props) => props.theme.media.mobile} {
    min-width: unset;
    max-width: unset;
    margin-bottom: 3.125vw;
    border-radius: 16.5px;
  }
`;
    const Image$1 = st$1.img`
  width: 100%;
  height: 100%;
  object-fit: cover;
`;
    function Image({ image, description, styles: styles2 = {} }) {
      const [src, setSrc] = reactExports.useState("");
      reactExports.useEffect(() => {
        if ("id" in image) {
          const src2 = image.directory + "/" + image.name;
          setSrc(src2);
          return;
        }
        if (image.data)
          [
            setSrc(image.data)
          ];
      }, [image]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageWrapper, { style: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Image$1,
        {
          src,
          alt: description
        }
      ) });
    }
    const editIcon = "/assets/editIcon-with-pen.svg";
    const deleteIcon = "/assets/deleteIcon-white.svg";
    const Container$4 = st$1.div``;
    st$1.div`
  position: relative;
  margin-bottom: 15px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 3.125vw;
  }
`;
    const ControlsGroup = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
`;
    const AddFileBtn = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  width: fit-content;
  min-height: 41px;
  padding: 0 23px 0 17px;
  font-size: 15.397px;
  @media ${(props) => props.theme.media.mobile} {
    min-height: 12.8125vw;
    padding: 0 7.1875vw 0 5.3125vw;
    font-size: 4.8115625vw;
  }
`;
    const EditFileBtn = st$1(AddFileBtn)`
  min-height: 60px;
  padding: 0 30px;
  font-size: 15px;
  @media ${(props) => props.theme.media.mobile} {
    justify-content: center;
    min-height: 15.625vw;
    padding: 0;
    width: 45vw;
    font-size: 3.75vw;
    border-radius: 13.026px;
  }
`;
    const DeleteFileBtn = st$1(EditFileBtn)`
  padding: 0 33px 0 23px;
  background-color: ${(props) => props.theme.colors.yRed};

  &:hover {
    background-color: ${(props) => props.theme.colors.darkRed};
  }
`;
    const AddFileIcon = st$1(Icon$2)`
  margin-right: 11px;
  background-image: url(${imagesIcon});
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 3.125vw;
  }
`;
    const EditIcon = st$1(Icon$2)`
  margin-right: 8px;
  background-image: url(${editIcon});
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 1.5625vw;
  }
`;
    const DeleteIcon = st$1(Icon$2)`
  margin-right: 8px;
  background-image: url(${deleteIcon});
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 1.5625vw;
  }
`;
    function AddImage({ name, onSet, imageData, onDelete, previewImageStyles = {} }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$4, { children: [
        imageData && /* @__PURE__ */ jsxRuntimeExports.jsx(Image, { image: imageData, styles: previewImageStyles }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(ControlsGroup, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CustomFileInput, { onSet, children: [
            !imageData && /* @__PURE__ */ jsxRuntimeExports.jsxs(AddFileBtn, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(AddFileIcon, {}),
              name
            ] }),
            imageData && /* @__PURE__ */ jsxRuntimeExports.jsxs(EditFileBtn, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon, {}),
              ""
            ] })
          ] }),
          imageData && /* @__PURE__ */ jsxRuntimeExports.jsxs(DeleteFileBtn, { onClick: onDelete, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, {}),
            ""
          ] })
        ] })
      ] });
    }
    function CreateCourseForm() {
      const { setModalOpen, setLoaderActive } = useActions();
      const modalType = useTypedSelector((state) => state.modal.modalType);
      const courseData = useTypedSelector((state) => state.course.data);
      const [courseName, setCourseName] = reactExports.useState("");
      const [isValidName, setValidName] = reactExports.useState(false);
      const [isChangedName, setChangedName] = reactExports.useState(false);
      const [isEditForm, setEditForm] = reactExports.useState(false);
      const [courseImage, setCourseImage] = reactExports.useState(null);
      const [courseDescription, setCourseDescription] = reactExports.useState("");
      const [createCourse] = useCreateCourseMutation();
      const [updateCourse] = useUpdateCourseMutation();
      const navigate = useNavigate();
      reactExports.useEffect(() => {
        const isEdit = modalType === MODAL_TYPES.editCourse;
        setEditForm(isEdit);
        if (isEdit && courseData) {
          setCourseName((prevState) => (courseData == null ? void 0 : courseData.title) || prevState);
          setChangedName(true);
          setValidName(true);
          setCourseDescription((prevState) => (courseData == null ? void 0 : courseData.description) || prevState);
          setCourseImage((courseData == null ? void 0 : courseData.image) || null);
        }
      }, [courseData, modalType]);
      const handleChange = (event) => {
        setValidName(event.target.value.length > 1);
        setCourseName(event.target.value);
        if (!isChangedName) {
          setChangedName(true);
        }
      };
      const handleTeaxtAreaChange = (event) => {
        setCourseDescription(event.target.value);
      };
      const handleConfirm = () => {
        if (!isValidName) {
          setChangedName(true);
          return;
        }
        if (!isEditForm) {
          createCourse({
            title: courseName,
            description: courseDescription,
            is_open: 1,
            image: courseImage
          }).then((res) => {
            if ("data" in res) {
              setModalOpen(false);
              navigate(`/courses/${res.data.data.id}`);
            }
          });
          setLoaderActive(true);
        }
        if (isEditForm && courseData && courseData.id) {
          updateCourse({
            id: courseData.id,
            title: courseName,
            description: courseDescription,
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore
            image: courseImage ? courseImage.id ? { id: courseImage.id } : courseImage : null
          }).then(() => setModalOpen(false));
          setLoaderActive(true);
        }
      };
      const handleCancel = () => {
        setModalOpen(false);
      };
      const handleSetCourseImage = (base64, extension) => {
        setCourseImage({ data: base64, extension });
      };
      const handleDeleteCourseImage = () => {
        setCourseImage(null);
      };
      const handlers = {
        cancel: handleCancel,
        confirm: handleConfirm
      };
      const names = {
        cancel: "",
        confirm: `${modalType === MODAL_TYPES.editCourse ? "" : ""} `
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        ModalForm,
        {
          width: "1240px",
          handlers,
          names,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              NameInput,
              {
                type: "text",
                $isValid: isValidName,
                $isChanged: isChangedName,
                value: courseName,
                onChange: handleChange,
                placeholder: "   ()"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Textarea,
              {
                as: "textarea",
                onChange: handleTeaxtAreaChange,
                value: courseDescription
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(BottomContainer$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              AddImage,
              {
                onSet: handleSetCourseImage,
                name: " ",
                imageData: courseImage,
                onDelete: handleDeleteCourseImage,
                previewImageStyles: {
                  maxWidth: "342px"
                }
              }
            ) })
          ]
        }
      );
    }
    const InputName$1 = st$1(InputWithState)`
  margin-bottom: 20px;
`;
    st$1(DefaultBtn)`
  width: fit-content;
  min-height: 41px;
  padding: 0 24px 0 52px;
  margin-bottom: 20px;
  font-size: 15.397px;
  background-image: url(${imagesIcon});
  background-repeat: no-repeat;
  background-position: 17px 9px;
  background-size: 24px;
`;
    const BottomContainer = st$1(FlexContainer)`
  justify-content: space-between;
`;
    function CreateChapterForm() {
      const { data, updatingChapterData } = useTypedSelector((state) => state.course);
      const formType = useTypedSelector((state) => state.modal.modalType);
      const { setModalOpen, addChapter, setLoaderActive, changeChapter } = useActions();
      const [createChapter] = useCreateChapterMutation();
      const [updateChapter] = useUpdateChapterMutation();
      const [chapterName, setChapterName] = reactExports.useState("");
      const [isValidName, setValidName] = reactExports.useState(false);
      const [isChangedName, setChangedName] = reactExports.useState(false);
      const [isEditForm, setEditForm] = reactExports.useState(false);
      const [chapterImage, setChapterImage] = reactExports.useState(null);
      reactExports.useEffect(() => {
        if (formType === MODAL_TYPES.editChapter && updatingChapterData) {
          setEditForm(true);
          setChapterName(updatingChapterData.title);
          setValidName(true);
          setChangedName(true);
          setChapterImage(updatingChapterData.image);
        }
      }, [data.image, formType, updatingChapterData]);
      const handleChange = (event) => {
        setValidName(event.target.value.length > 1);
        setChapterName(event.target.value);
        if (!isChangedName) {
          setChangedName(true);
        }
      };
      const handleConfirm = () => {
        if (!isValidName) {
          setChangedName(true);
          return;
        }
        if ((data == null ? void 0 : data.id) && !isEditForm) {
          createChapter({
            title: chapterName,
            course_id: data.id,
            image: chapterImage
          }).then((res) => {
            setModalOpen(false);
          }).catch((err) => {
            console.error(err);
          });
          setLoaderActive(true);
        }
        console.log(updatingChapterData);
        if (isEditForm && updatingChapterData && updatingChapterData.course_id) {
          updateChapter({
            course_id: updatingChapterData.course_id,
            id: Number(updatingChapterData.id),
            title: chapterName,
            image: chapterImage
          }).then((res) => {
            if ("data" in res) {
              changeChapter(res.data.data);
            }
            setLoaderActive(false);
            setModalOpen(false);
          }).catch((err) => console.error(err));
          setLoaderActive(true);
        }
      };
      const handleCancel = () => {
        setModalOpen(false);
      };
      const handlers = {
        cancel: handleCancel,
        confirm: handleConfirm
      };
      const handleSetChapterImage = (base64, extension) => {
        setChapterImage({ data: base64, extension });
      };
      const handleDeleteChapterImage = () => {
        setChapterImage(null);
      };
      const names = {
        cancel: "",
        confirm: `${isEditForm ? "" : ""} `
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(
        ModalForm,
        {
          handlers,
          names,
          width: "509px",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              InputName$1,
              {
                type: "text",
                $isValid: isValidName,
                $isChanged: isChangedName,
                value: chapterName,
                onChange: handleChange,
                placeholder: "   ()"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(BottomContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              AddImage,
              {
                onSet: handleSetChapterImage,
                name: " ",
                imageData: chapterImage,
                onDelete: handleDeleteChapterImage
              }
            ) })
          ]
        }
      );
    }
    const InputName = st$1(InputWithState)`
  margin-bottom: 20px;
`;
    function CreateThemeForm() {
      const { setModalOpen, setLoaderActive } = useActions();
      const chapterId = useTypedSelector((state) => state.course.activeChapterId);
      const themeData = useTypedSelector((state) => state.course.updatingThemeData);
      const modalType = useTypedSelector((state) => state.modal.modalType);
      const [createTheme2] = useCreateThemeMutation();
      const [updateTheme] = useUpdateThemeMutation();
      const [themeName, setThemeName] = reactExports.useState("");
      const [isValidName, setValidName] = reactExports.useState(false);
      const [isChangedName, setChangedName] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if (modalType === MODAL_TYPES.editTheme && themeData) {
          setThemeName(themeData.title);
          setValidName(true);
          setChangedName(false);
        } else if (modalType === MODAL_TYPES.editTheme) {
          alert("-   ...");
          setModalOpen(false);
        }
      }, [modalType, setModalOpen, themeData]);
      const handleChange = (event) => {
        setValidName(event.target.value.length > 1);
        setThemeName(event.target.value);
        if (!isChangedName) {
          setChangedName(true);
        }
      };
      const handleConfirm = () => {
        if (!isValidName) {
          setChangedName(true);
          return;
        }
        if (modalType === MODAL_TYPES.editTheme && themeData) {
          updateTheme({
            id: themeData.id,
            title: themeName,
            chapter_id: themeData == null ? void 0 : themeData.chapter_id
          }).then((res) => {
            if ("data" in res) {
              setModalOpen(false);
            }
          });
          setLoaderActive(true);
          return;
        }
        createTheme2({
          title: themeName,
          chapter_id: chapterId ? chapterId : 0
        }).then(() => {
          setModalOpen(false);
        }).catch((error) => {
          console.log(error);
          alert("-   ");
        });
        setLoaderActive(true);
      };
      const handleCancel = () => {
        setModalOpen(false);
      };
      const handlers = {
        cancel: handleCancel,
        confirm: handleConfirm
      };
      const names = {
        cancel: "",
        confirm: `${modalType === MODAL_TYPES.editTheme ? "" : ""} `
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        ModalForm,
        {
          handlers,
          names,
          width: "509px",
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            InputName,
            {
              type: "text",
              $isValid: isValidName,
              $isChanged: isChangedName,
              value: themeName,
              onChange: handleChange,
              placeholder: "   ()"
            }
          )
        }
      );
    }
    const checklistIcon = "/assets/checklist.svg";
    const Title$4 = st$1(Text$6)`
  margin-bottom: 20px;
  font-size: 92.5px;
`;
    const LessonNameInput = st$1(InputWithState)`
  margin-bottom: 15px;
`;
    st$1.div`
  width: 100%;
  min-height: 472px;
  padding: 25px;
  padding-left: 75px;
  margin-bottom: 15px;
  border: 1px solid ${(props) => props.theme.colors.greyEO};
  border-radius: ${(props) => props.theme.utils.br};
`;
    const TestWrapper = st$1.div`
margin-bottom: 60px;
`;
    const AddTest = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  width: fit-content;
`;
    const AddTestIcon = st$1(Icon$2)`
  margin-right: 10px;
  background-image: url(${checklistIcon});
`;
    const Divider$2 = st$1.div`
  position: relative;
  width: 100%;
  height: 1px;
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 100vw;
    height: 100%;
    background-color: ${(props) => props.theme.colors.greyF1};
    transform: translateX(-50%);
  }
`;
    var Ot = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
    function xe(s2) {
      return s2 && s2.__esModule && Object.prototype.hasOwnProperty.call(s2, "default") ? s2.default : s2;
    }
    function Be() {
    }
    Object.assign(Be, {
      default: Be,
      register: Be,
      revert: function() {
      },
      __esModule: true
    });
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s2) {
      const e2 = (this.document || this.ownerDocument).querySelectorAll(s2);
      let t2 = e2.length;
      for (; --t2 >= 0 && e2.item(t2) !== this; )
        ;
      return t2 > -1;
    });
    Element.prototype.closest || (Element.prototype.closest = function(s2) {
      let e2 = this;
      if (!document.documentElement.contains(e2))
        return null;
      do {
        if (e2.matches(s2))
          return e2;
        e2 = e2.parentElement || e2.parentNode;
      } while (e2 !== null);
      return null;
    });
    Element.prototype.prepend || (Element.prototype.prepend = function(e2) {
      const t2 = document.createDocumentFragment();
      Array.isArray(e2) || (e2 = [e2]), e2.forEach((o2) => {
        const i2 = o2 instanceof Node;
        t2.appendChild(i2 ? o2 : document.createTextNode(o2));
      }), this.insertBefore(t2, this.firstChild);
    });
    Element.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(s2) {
      s2 = arguments.length === 0 ? true : !!s2;
      const e2 = this.parentNode, t2 = window.getComputedStyle(e2, null), o2 = parseInt(t2.getPropertyValue("border-top-width")), i2 = parseInt(t2.getPropertyValue("border-left-width")), n2 = this.offsetTop - e2.offsetTop < e2.scrollTop, r2 = this.offsetTop - e2.offsetTop + this.clientHeight - o2 > e2.scrollTop + e2.clientHeight, a2 = this.offsetLeft - e2.offsetLeft < e2.scrollLeft, l2 = this.offsetLeft - e2.offsetLeft + this.clientWidth - i2 > e2.scrollLeft + e2.clientWidth, c2 = n2 && !r2;
      (n2 || r2) && s2 && (e2.scrollTop = this.offsetTop - e2.offsetTop - e2.clientHeight / 2 - o2 + this.clientHeight / 2), (a2 || l2) && s2 && (e2.scrollLeft = this.offsetLeft - e2.offsetLeft - e2.clientWidth / 2 - i2 + this.clientWidth / 2), (n2 || r2 || a2 || l2) && !s2 && this.scrollIntoView(c2);
    });
    window.requestIdleCallback = window.requestIdleCallback || function(s2) {
      const e2 = Date.now();
      return setTimeout(function() {
        s2({
          didTimeout: false,
          timeRemaining: function() {
            return Math.max(0, 50 - (Date.now() - e2));
          }
        });
      }, 1);
    };
    window.cancelIdleCallback = window.cancelIdleCallback || function(s2) {
      clearTimeout(s2);
    };
    let At = (s2 = 21) => crypto.getRandomValues(new Uint8Array(s2)).reduce((e2, t2) => (t2 &= 63, t2 < 36 ? e2 += t2.toString(36) : t2 < 62 ? e2 += (t2 - 26).toString(36).toUpperCase() : t2 > 62 ? e2 += "-" : e2 += "_", e2), "");
    var it = /* @__PURE__ */ ((s2) => (s2.VERBOSE = "VERBOSE", s2.INFO = "INFO", s2.WARN = "WARN", s2.ERROR = "ERROR", s2))(it || {});
    const B$1 = {
      BACKSPACE: 8,
      TAB: 9,
      ENTER: 13,
      SHIFT: 16,
      CTRL: 17,
      ALT: 18,
      ESC: 27,
      SPACE: 32,
      LEFT: 37,
      UP: 38,
      DOWN: 40,
      RIGHT: 39,
      DELETE: 46,
      META: 91
    }, _t = {
      LEFT: 0,
      WHEEL: 1,
      RIGHT: 2,
      BACKWARD: 3,
      FORWARD: 4
    };
    function be(s2, e2, t2 = "log", o2, i2 = "color: inherit") {
      if (!("console" in window) || !window.console[t2])
        return;
      const n2 = ["info", "log", "warn", "error"].includes(t2), r2 = [];
      switch (be.logLevel) {
        case "ERROR":
          if (t2 !== "error")
            return;
          break;
        case "WARN":
          if (!["error", "warn"].includes(t2))
            return;
          break;
        case "INFO":
          if (!n2 || s2)
            return;
          break;
      }
      o2 && r2.push(o2);
      const a2 = "Editor.js 2.28.2", l2 = `line-height: 1em;
            color: #006FEA;
            display: inline-block;
            font-size: 11px;
            line-height: 1em;
            background-color: #fff;
            padding: 4px 9px;
            border-radius: 30px;
            border: 1px solid rgba(56, 138, 229, 0.16);
            margin: 4px 5px 4px 0;`;
      s2 && (n2 ? (r2.unshift(l2, i2), e2 = `%c${a2}%c ${e2}`) : e2 = `( ${a2} )${e2}`);
      try {
        n2 ? o2 ? console[t2](`${e2} %o`, ...r2) : console[t2](e2, ...r2) : console[t2](e2);
      } catch {
      }
    }
    be.logLevel = "VERBOSE";
    function Nt(s2) {
      be.logLevel = s2;
    }
    const L$1 = be.bind(window, false), K = be.bind(window, true);
    function oe(s2) {
      return Object.prototype.toString.call(s2).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
    }
    function D$1(s2) {
      return oe(s2) === "function" || oe(s2) === "asyncfunction";
    }
    function z(s2) {
      return oe(s2) === "object";
    }
    function J(s2) {
      return oe(s2) === "string";
    }
    function Rt(s2) {
      return oe(s2) === "boolean";
    }
    function qe(s2) {
      return oe(s2) === "number";
    }
    function Ze(s2) {
      return oe(s2) === "undefined";
    }
    function V(s2) {
      return s2 ? Object.keys(s2).length === 0 && s2.constructor === Object : true;
    }
    function nt(s2) {
      return s2 > 47 && s2 < 58 || // number keys
      s2 === 32 || s2 === 13 || // Space bar & return key(s)
      s2 === 229 || // processing key input for certain languages  Chinese, Japanese, etc.
      s2 > 64 && s2 < 91 || // letter keys
      s2 > 95 && s2 < 112 || // Numpad keys
      s2 > 185 && s2 < 193 || // ;=,-./` (in order)
      s2 > 218 && s2 < 223;
    }
    async function Dt(s2, e2 = () => {
    }, t2 = () => {
    }) {
      async function o2(i2, n2, r2) {
        try {
          await i2.function(i2.data), await n2(Ze(i2.data) ? {} : i2.data);
        } catch {
          r2(Ze(i2.data) ? {} : i2.data);
        }
      }
      return s2.reduce(async (i2, n2) => (await i2, o2(n2, e2, t2)), Promise.resolve());
    }
    function st(s2) {
      return Array.prototype.slice.call(s2);
    }
    function re(s2, e2) {
      return function() {
        const t2 = this, o2 = arguments;
        window.setTimeout(() => s2.apply(t2, o2), e2);
      };
    }
    function Pt(s2) {
      return s2.name.split(".").pop();
    }
    function Ft(s2) {
      return /^[-\w]+\/([-+\w]+|\*)$/.test(s2);
    }
    function Ht(s2, e2, t2) {
      let o2;
      return (...i2) => {
        const n2 = this, r2 = () => {
          o2 = null, t2 || s2.apply(n2, i2);
        }, a2 = t2 && !o2;
        window.clearTimeout(o2), o2 = window.setTimeout(r2, e2), a2 && s2.apply(n2, i2);
      };
    }
    function Ce(s2, e2, t2 = void 0) {
      let o2, i2, n2, r2 = null, a2 = 0;
      t2 || (t2 = {});
      const l2 = function() {
        a2 = t2.leading === false ? 0 : Date.now(), r2 = null, n2 = s2.apply(o2, i2), r2 || (o2 = i2 = null);
      };
      return function() {
        const c2 = Date.now();
        !a2 && t2.leading === false && (a2 = c2);
        const u2 = e2 - (c2 - a2);
        return o2 = this, i2 = arguments, u2 <= 0 || u2 > e2 ? (r2 && (clearTimeout(r2), r2 = null), a2 = c2, n2 = s2.apply(o2, i2), r2 || (o2 = i2 = null)) : !r2 && t2.trailing !== false && (r2 = setTimeout(l2, u2)), n2;
      };
    }
    function jt() {
      const s2 = {
        win: false,
        mac: false,
        x11: false,
        linux: false
      }, e2 = Object.keys(s2).find((t2) => window.navigator.appVersion.toLowerCase().indexOf(t2) !== -1);
      return e2 && (s2[e2] = true), s2;
    }
    function ae(s2) {
      return s2[0].toUpperCase() + s2.slice(1);
    }
    function Se(s2, ...e2) {
      if (!e2.length)
        return s2;
      const t2 = e2.shift();
      if (z(s2) && z(t2))
        for (const o2 in t2)
          z(t2[o2]) ? (s2[o2] || Object.assign(s2, { [o2]: {} }), Se(s2[o2], t2[o2])) : Object.assign(s2, { [o2]: t2[o2] });
      return Se(s2, ...e2);
    }
    function Re(s2) {
      const e2 = jt();
      return s2 = s2.replace(/shift/gi, "").replace(/backspace/gi, "").replace(/enter/gi, "").replace(/up/gi, "").replace(/left/gi, "").replace(/down/gi, "").replace(/right/gi, "").replace(/escape/gi, "").replace(/insert/gi, "Ins").replace(/delete/gi, "").replace(/\+/gi, " + "), e2.mac ? s2 = s2.replace(/ctrl|cmd/gi, "").replace(/alt/gi, "") : s2 = s2.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), s2;
    }
    function zt(s2) {
      try {
        return new URL(s2).href;
      } catch {
      }
      return s2.substring(0, 2) === "//" ? window.location.protocol + s2 : window.location.origin + s2;
    }
    function Ut() {
      return At(10);
    }
    function $t(s2) {
      window.open(s2, "_blank");
    }
    function Wt(s2 = "") {
      return `${s2}${Math.floor(Math.random() * 1e8).toString(16)}`;
    }
    function Ie(s2, e2, t2) {
      const o2 = `${e2} is deprecated and will be removed in the next major release. Please use the ${t2} instead.`;
      s2 && K(o2, "warn");
    }
    function ce(s2, e2, t2) {
      const o2 = t2.value ? "value" : "get", i2 = t2[o2], n2 = `#${e2}Cache`;
      if (t2[o2] = function(...r2) {
        return this[n2] === void 0 && (this[n2] = i2.apply(this, ...r2)), this[n2];
      }, o2 === "get" && t2.set) {
        const r2 = t2.set;
        t2.set = function(a2) {
          delete s2[n2], r2.apply(this, a2);
        };
      }
      return t2;
    }
    const rt = 650;
    function te() {
      return window.matchMedia(`(max-width: ${rt}px)`).matches;
    }
    const Ge = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
    function Yt(s2, e2) {
      const t2 = Array.isArray(s2) || z(s2), o2 = Array.isArray(e2) || z(e2);
      return t2 || o2 ? JSON.stringify(s2) === JSON.stringify(e2) : s2 === e2;
    }
    let d$1 = class d2 {
      /**
       * Check if passed tag has no closed tag
       *
       * @param {HTMLElement} tag - element to check
       * @returns {boolean}
       */
      static isSingleTag(e2) {
        return e2.tagName && [
          "AREA",
          "BASE",
          "BR",
          "COL",
          "COMMAND",
          "EMBED",
          "HR",
          "IMG",
          "INPUT",
          "KEYGEN",
          "LINK",
          "META",
          "PARAM",
          "SOURCE",
          "TRACK",
          "WBR"
        ].includes(e2.tagName);
      }
      /**
       * Check if element is BR or WBR
       *
       * @param {HTMLElement} element - element to check
       * @returns {boolean}
       */
      static isLineBreakTag(e2) {
        return e2 && e2.tagName && [
          "BR",
          "WBR"
        ].includes(e2.tagName);
      }
      /**
       * Helper for making Elements with class name and attributes
       *
       * @param  {string} tagName - new Element tag name
       * @param  {string[]|string} [classNames] - list or name of CSS class name(s)
       * @param  {object} [attributes] - any attributes
       * @returns {HTMLElement}
       */
      static make(e2, t2 = null, o2 = {}) {
        const i2 = document.createElement(e2);
        Array.isArray(t2) ? i2.classList.add(...t2) : t2 && i2.classList.add(t2);
        for (const n2 in o2)
          Object.prototype.hasOwnProperty.call(o2, n2) && (i2[n2] = o2[n2]);
        return i2;
      }
      /**
       * Creates Text Node with the passed content
       *
       * @param {string} content - text content
       * @returns {Text}
       */
      static text(e2) {
        return document.createTextNode(e2);
      }
      /**
       * Append one or several elements to the parent
       *
       * @param  {Element|DocumentFragment} parent - where to append
       * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list
       */
      static append(e2, t2) {
        Array.isArray(t2) ? t2.forEach((o2) => e2.appendChild(o2)) : e2.appendChild(t2);
      }
      /**
       * Append element or a couple to the beginning of the parent elements
       *
       * @param {Element} parent - where to append
       * @param {Element|Element[]} elements - element or elements list
       */
      static prepend(e2, t2) {
        Array.isArray(t2) ? (t2 = t2.reverse(), t2.forEach((o2) => e2.prepend(o2))) : e2.prepend(t2);
      }
      /**
       * Swap two elements in parent
       *
       * @param {HTMLElement} el1 - from
       * @param {HTMLElement} el2 - to
       * @deprecated
       */
      static swap(e2, t2) {
        const o2 = document.createElement("div"), i2 = e2.parentNode;
        i2.insertBefore(o2, e2), i2.insertBefore(e2, t2), i2.insertBefore(t2, o2), i2.removeChild(o2);
      }
      /**
       * Selector Decorator
       *
       * Returns first match
       *
       * @param {Element} el - element we searching inside. Default - DOM Document
       * @param {string} selector - searching string
       * @returns {Element}
       */
      static find(e2 = document, t2) {
        return e2.querySelector(t2);
      }
      /**
       * Get Element by Id
       *
       * @param {string} id - id to find
       * @returns {HTMLElement | null}
       */
      static get(e2) {
        return document.getElementById(e2);
      }
      /**
       * Selector Decorator.
       *
       * Returns all matches
       *
       * @param {Element|Document} el - element we searching inside. Default - DOM Document
       * @param {string} selector - searching string
       * @returns {NodeList}
       */
      static findAll(e2 = document, t2) {
        return e2.querySelectorAll(t2);
      }
      /**
       * Returns CSS selector for all text inputs
       */
      static get allInputsSelector() {
        return "[contenteditable=true], textarea, input:not([type]), " + ["text", "password", "email", "number", "search", "tel", "url"].map((t2) => `input[type="${t2}"]`).join(", ");
      }
      /**
       * Find all contenteditable, textarea and editable input elements passed holder contains
       *
       * @param holder - element where to find inputs
       */
      static findAllInputs(e2) {
        return st(e2.querySelectorAll(d2.allInputsSelector)).reduce((t2, o2) => d2.isNativeInput(o2) || d2.containsOnlyInlineElements(o2) ? [...t2, o2] : [...t2, ...d2.getDeepestBlockElements(o2)], []);
      }
      /**
       * Search for deepest node which is Leaf.
       * Leaf is the vertex that doesn't have any child nodes
       *
       * @description Method recursively goes throw the all Node until it finds the Leaf
       * @param {Node} node - root Node. From this vertex we start Deep-first search
       *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}
       * @param {boolean} [atLast] - find last text node
       * @returns {Node} - it can be text Node or Element Node, so that caret will able to work with it
       */
      static getDeepestNode(e2, t2 = false) {
        const o2 = t2 ? "lastChild" : "firstChild", i2 = t2 ? "previousSibling" : "nextSibling";
        if (e2 && e2.nodeType === Node.ELEMENT_NODE && e2[o2]) {
          let n2 = e2[o2];
          if (d2.isSingleTag(n2) && !d2.isNativeInput(n2) && !d2.isLineBreakTag(n2))
            if (n2[i2])
              n2 = n2[i2];
            else if (n2.parentNode[i2])
              n2 = n2.parentNode[i2];
            else
              return n2.parentNode;
          return this.getDeepestNode(n2, t2);
        }
        return e2;
      }
      /**
       * Check if object is DOM node
       *
       * @param {*} node - object to check
       * @returns {boolean}
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static isElement(e2) {
        return qe(e2) ? false : e2 && e2.nodeType && e2.nodeType === Node.ELEMENT_NODE;
      }
      /**
       * Check if object is DocumentFragment node
       *
       * @param {object} node - object to check
       * @returns {boolean}
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static isFragment(e2) {
        return qe(e2) ? false : e2 && e2.nodeType && e2.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
      }
      /**
       * Check if passed element is contenteditable
       *
       * @param {HTMLElement} element - html element to check
       * @returns {boolean}
       */
      static isContentEditable(e2) {
        return e2.contentEditable === "true";
      }
      /**
       * Checks target if it is native input
       *
       * @param {*} target - HTML element or string
       * @returns {boolean}
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static isNativeInput(e2) {
        const t2 = [
          "INPUT",
          "TEXTAREA"
        ];
        return e2 && e2.tagName ? t2.includes(e2.tagName) : false;
      }
      /**
       * Checks if we can set caret
       *
       * @param {HTMLElement} target - target to check
       * @returns {boolean}
       */
      static canSetCaret(e2) {
        let t2 = true;
        if (d2.isNativeInput(e2))
          switch (e2.type) {
            case "file":
            case "checkbox":
            case "radio":
            case "hidden":
            case "submit":
            case "button":
            case "image":
            case "reset":
              t2 = false;
              break;
          }
        else
          t2 = d2.isContentEditable(e2);
        return t2;
      }
      /**
       * Checks node if it is empty
       *
       * @description Method checks simple Node without any childs for emptiness
       * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method
       * @param {Node} node - node to check
       * @returns {boolean} true if it is empty
       */
      static isNodeEmpty(e2) {
        let t2;
        return this.isSingleTag(e2) && !this.isLineBreakTag(e2) ? false : (this.isElement(e2) && this.isNativeInput(e2) ? t2 = e2.value : t2 = e2.textContent.replace("", ""), t2.trim().length === 0);
      }
      /**
       * checks node if it is doesn't have any child nodes
       *
       * @param {Node} node - node to check
       * @returns {boolean}
       */
      static isLeaf(e2) {
        return e2 ? e2.childNodes.length === 0 : false;
      }
      /**
       * breadth-first search (BFS)
       * {@link https://en.wikipedia.org/wiki/Breadth-first_search}
       *
       * @description Pushes to stack all DOM leafs and checks for emptiness
       * @param {Node} node - node to check
       * @returns {boolean}
       */
      static isEmpty(e2) {
        e2.normalize();
        const t2 = [e2];
        for (; t2.length > 0; )
          if (e2 = t2.shift(), !!e2) {
            if (this.isLeaf(e2) && !this.isNodeEmpty(e2))
              return false;
            e2.childNodes && t2.push(...Array.from(e2.childNodes));
          }
        return true;
      }
      /**
       * Check if string contains html elements
       *
       * @param {string} str - string to check
       * @returns {boolean}
       */
      static isHTMLString(e2) {
        const t2 = d2.make("div");
        return t2.innerHTML = e2, t2.childElementCount > 0;
      }
      /**
       * Return length of node`s text content
       *
       * @param {Node} node - node with content
       * @returns {number}
       */
      static getContentLength(e2) {
        return d2.isNativeInput(e2) ? e2.value.length : e2.nodeType === Node.TEXT_NODE ? e2.length : e2.textContent.length;
      }
      /**
       * Return array of names of block html elements
       *
       * @returns {string[]}
       */
      static get blockElements() {
        return [
          "address",
          "article",
          "aside",
          "blockquote",
          "canvas",
          "div",
          "dl",
          "dt",
          "fieldset",
          "figcaption",
          "figure",
          "footer",
          "form",
          "h1",
          "h2",
          "h3",
          "h4",
          "h5",
          "h6",
          "header",
          "hgroup",
          "hr",
          "li",
          "main",
          "nav",
          "noscript",
          "ol",
          "output",
          "p",
          "pre",
          "ruby",
          "section",
          "table",
          "tbody",
          "thead",
          "tr",
          "tfoot",
          "ul",
          "video"
        ];
      }
      /**
       * Check if passed content includes only inline elements
       *
       * @param {string|HTMLElement} data - element or html string
       * @returns {boolean}
       */
      static containsOnlyInlineElements(e2) {
        let t2;
        J(e2) ? (t2 = document.createElement("div"), t2.innerHTML = e2) : t2 = e2;
        const o2 = (i2) => !d2.blockElements.includes(i2.tagName.toLowerCase()) && Array.from(i2.children).every(o2);
        return Array.from(t2.children).every(o2);
      }
      /**
       * Find and return all block elements in the passed parent (including subtree)
       *
       * @param {HTMLElement} parent - root element
       * @returns {HTMLElement[]}
       */
      static getDeepestBlockElements(e2) {
        return d2.containsOnlyInlineElements(e2) ? [e2] : Array.from(e2.children).reduce((t2, o2) => [...t2, ...d2.getDeepestBlockElements(o2)], []);
      }
      /**
       * Helper for get holder from {string} or return HTMLElement
       *
       * @param {string | HTMLElement} element - holder's id or holder's HTML Element
       * @returns {HTMLElement}
       */
      static getHolder(e2) {
        return J(e2) ? document.getElementById(e2) : e2;
      }
      /**
       * Returns true if element is anchor (is A tag)
       *
       * @param {Element} element - element to check
       * @returns {boolean}
       */
      static isAnchor(e2) {
        return e2.tagName.toLowerCase() === "a";
      }
      /**
       * Return element's offset related to the document
       *
       * @todo handle case when editor initialized in scrollable popup
       * @param el - element to compute offset
       */
      static offset(e2) {
        const t2 = e2.getBoundingClientRect(), o2 = window.pageXOffset || document.documentElement.scrollLeft, i2 = window.pageYOffset || document.documentElement.scrollTop, n2 = t2.top + i2, r2 = t2.left + o2;
        return {
          top: n2,
          left: r2,
          bottom: n2 + t2.height,
          right: r2 + t2.width
        };
      }
    };
    const Kt = {
      blockTunes: {
        toggler: {
          "Click to tune": "",
          "or drag to move": ""
        }
      },
      inlineToolbar: {
        converter: {
          "Convert to": ""
        }
      },
      toolbar: {
        toolbox: {
          Add: ""
        }
      },
      popover: {
        Filter: "",
        "Nothing found": ""
      }
    }, Xt = {
      Text: "",
      Link: "",
      Bold: "",
      Italic: ""
    }, Vt = {
      link: {
        "Add a link": ""
      },
      stub: {
        "The block can not be displayed correctly.": ""
      }
    }, qt = {
      delete: {
        Delete: "",
        "Click to delete": ""
      },
      moveUp: {
        "Move up": ""
      },
      moveDown: {
        "Move down": ""
      }
    }, at = {
      ui: Kt,
      toolNames: Xt,
      tools: Vt,
      blockTunes: qt
    }, ie = class {
      /**
       * Type-safe translation for internal UI texts:
       * Perform translation of the string by namespace and a key
       *
       * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')
       * @param internalNamespace - path to translated string in dictionary
       * @param dictKey - dictionary key. Better to use default locale original text
       */
      static ui(s2, e2) {
        return ie._t(s2, e2);
      }
      /**
       * Translate for external strings that is not presented in default dictionary.
       * For example, for user-specified tool names
       *
       * @param namespace - path to translated string in dictionary
       * @param dictKey - dictionary key. Better to use default locale original text
       */
      static t(s2, e2) {
        return ie._t(s2, e2);
      }
      /**
       * Adjust module for using external dictionary
       *
       * @param dictionary - new messages list to override default
       */
      static setDictionary(s2) {
        ie.currentDictionary = s2;
      }
      /**
       * Perform translation both for internal and external namespaces
       * If there is no translation found, returns passed key as a translated message
       *
       * @param namespace - path to translated string in dictionary
       * @param dictKey - dictionary key. Better to use default locale original text
       */
      static _t(s2, e2) {
        const t2 = ie.getNamespace(s2);
        return !t2 || !t2[e2] ? e2 : t2[e2];
      }
      /**
       * Find messages section by namespace path
       *
       * @param namespace - path to section
       */
      static getNamespace(s2) {
        return s2.split(".").reduce((t2, o2) => !t2 || !Object.keys(t2).length ? {} : t2[o2], ie.currentDictionary);
      }
    };
    let $ = ie;
    $.currentDictionary = at;
    class lt extends Error {
    }
    class we {
      constructor() {
        this.subscribers = {};
      }
      /**
       * Subscribe any event on callback
       *
       * @param eventName - event name
       * @param callback - subscriber
       */
      on(e2, t2) {
        e2 in this.subscribers || (this.subscribers[e2] = []), this.subscribers[e2].push(t2);
      }
      /**
       * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.
       *
       * @param eventName - event name
       * @param callback - subscriber
       */
      once(e2, t2) {
        e2 in this.subscribers || (this.subscribers[e2] = []);
        const o2 = (i2) => {
          const n2 = t2(i2), r2 = this.subscribers[e2].indexOf(o2);
          return r2 !== -1 && this.subscribers[e2].splice(r2, 1), n2;
        };
        this.subscribers[e2].push(o2);
      }
      /**
       * Emit callbacks with passed data
       *
       * @param eventName - event name
       * @param data - subscribers get this data when they were fired
       */
      emit(e2, t2) {
        V(this.subscribers) || !this.subscribers[e2] || this.subscribers[e2].reduce((o2, i2) => {
          const n2 = i2(o2);
          return n2 !== void 0 ? n2 : o2;
        }, t2);
      }
      /**
       * Unsubscribe callback from event
       *
       * @param eventName - event name
       * @param callback - event handler
       */
      off(e2, t2) {
        if (this.subscribers[e2] === void 0) {
          console.warn(`EventDispatcher .off(): there is no subscribers for event "${e2.toString()}". Probably, .off() called before .on()`);
          return;
        }
        for (let o2 = 0; o2 < this.subscribers[e2].length; o2++)
          if (this.subscribers[e2][o2] === t2) {
            delete this.subscribers[e2][o2];
            break;
          }
      }
      /**
       * Destroyer
       * clears subscribers list
       */
      destroy() {
        this.subscribers = {};
      }
    }
    function ee(s2) {
      Object.setPrototypeOf(this, {
        /**
         * Block id
         *
         * @returns {string}
         */
        get id() {
          return s2.id;
        },
        /**
         * Tool name
         *
         * @returns {string}
         */
        get name() {
          return s2.name;
        },
        /**
         * Tool config passed on Editor's initialization
         *
         * @returns {ToolConfig}
         */
        get config() {
          return s2.config;
        },
        /**
         * .ce-block element, that wraps plugin contents
         *
         * @returns {HTMLElement}
         */
        get holder() {
          return s2.holder;
        },
        /**
         * True if Block content is empty
         *
         * @returns {boolean}
         */
        get isEmpty() {
          return s2.isEmpty;
        },
        /**
         * True if Block is selected with Cross-Block selection
         *
         * @returns {boolean}
         */
        get selected() {
          return s2.selected;
        },
        /**
         * Set Block's stretch state
         *
         * @param {boolean} state  state to set
         */
        set stretched(t2) {
          s2.stretched = t2;
        },
        /**
         * True if Block is stretched
         *
         * @returns {boolean}
         */
        get stretched() {
          return s2.stretched;
        },
        /**
         * Call Tool method with errors handler under-the-hood
         *
         * @param {string} methodName - method to call
         * @param {object} param - object with parameters
         * @returns {unknown}
         */
        call(t2, o2) {
          return s2.call(t2, o2);
        },
        /**
         * Save Block content
         *
         * @returns {Promise<void|SavedData>}
         */
        save() {
          return s2.save();
        },
        /**
         * Validate Block data
         *
         * @param {BlockToolData} data - data to validate
         * @returns {Promise<boolean>}
         */
        validate(t2) {
          return s2.validate(t2);
        },
        /**
         * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback
         * Can be useful for block changes invisible for editor core.
         */
        dispatchChange() {
          s2.dispatchChange();
        }
      });
    }
    class De {
      constructor() {
        this.allListeners = [];
      }
      /**
       * Assigns event listener on element and returns unique identifier
       *
       * @param {EventTarget} element - DOM element that needs to be listened
       * @param {string} eventType - event type
       * @param {Function} handler - method that will be fired on event
       * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}
       */
      on(e2, t2, o2, i2 = false) {
        const n2 = Wt("l"), r2 = {
          id: n2,
          element: e2,
          eventType: t2,
          handler: o2,
          options: i2
        };
        if (!this.findOne(e2, t2, o2))
          return this.allListeners.push(r2), e2.addEventListener(t2, o2, i2), n2;
      }
      /**
       * Removes event listener from element
       *
       * @param {EventTarget} element - DOM element that we removing listener
       * @param {string} eventType - event type
       * @param {Function} handler - remove handler, if element listens several handlers on the same event type
       * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}
       */
      off(e2, t2, o2, i2) {
        const n2 = this.findAll(e2, t2, o2);
        n2.forEach((r2, a2) => {
          const l2 = this.allListeners.indexOf(n2[a2]);
          l2 > -1 && (this.allListeners.splice(l2, 1), r2.element.removeEventListener(r2.eventType, r2.handler, r2.options));
        });
      }
      /**
       * Removes listener by id
       *
       * @param {string} id - listener identifier
       */
      offById(e2) {
        const t2 = this.findById(e2);
        t2 && t2.element.removeEventListener(t2.eventType, t2.handler, t2.options);
      }
      /**
       * Finds and returns first listener by passed params
       *
       * @param {EventTarget} element - event target
       * @param {string} [eventType] - event type
       * @param {Function} [handler] - event handler
       * @returns {ListenerData|null}
       */
      findOne(e2, t2, o2) {
        const i2 = this.findAll(e2, t2, o2);
        return i2.length > 0 ? i2[0] : null;
      }
      /**
       * Return all stored listeners by passed params
       *
       * @param {EventTarget} element - event target
       * @param {string} eventType - event type
       * @param {Function} handler - event handler
       * @returns {ListenerData[]}
       */
      findAll(e2, t2, o2) {
        let i2;
        const n2 = e2 ? this.findByEventTarget(e2) : [];
        return e2 && t2 && o2 ? i2 = n2.filter((r2) => r2.eventType === t2 && r2.handler === o2) : e2 && t2 ? i2 = n2.filter((r2) => r2.eventType === t2) : i2 = n2, i2;
      }
      /**
       * Removes all listeners
       */
      removeAll() {
        this.allListeners.map((e2) => {
          e2.element.removeEventListener(e2.eventType, e2.handler, e2.options);
        }), this.allListeners = [];
      }
      /**
       * Module cleanup on destruction
       */
      destroy() {
        this.removeAll();
      }
      /**
       * Search method: looks for listener by passed element
       *
       * @param {EventTarget} element - searching element
       * @returns {Array} listeners that found on element
       */
      findByEventTarget(e2) {
        return this.allListeners.filter((t2) => {
          if (t2.element === e2)
            return t2;
        });
      }
      /**
       * Search method: looks for listener by passed event type
       *
       * @param {string} eventType - event type
       * @returns {ListenerData[]} listeners that found on element
       */
      findByType(e2) {
        return this.allListeners.filter((t2) => {
          if (t2.eventType === e2)
            return t2;
        });
      }
      /**
       * Search method: looks for listener by passed handler
       *
       * @param {Function} handler - event handler
       * @returns {ListenerData[]} listeners that found on element
       */
      findByHandler(e2) {
        return this.allListeners.filter((t2) => {
          if (t2.handler === e2)
            return t2;
        });
      }
      /**
       * Returns listener data found by id
       *
       * @param {string} id - listener identifier
       * @returns {ListenerData}
       */
      findById(e2) {
        return this.allListeners.find((t2) => t2.id === e2);
      }
    }
    class C {
      /**
       * @class
       * @param options - Module options
       * @param options.config - Module config
       * @param options.eventsDispatcher - Common event bus
       */
      constructor({ config: e2, eventsDispatcher: t2 }) {
        if (this.nodes = {}, this.listeners = new De(), this.readOnlyMutableListeners = {
          /**
           * Assigns event listener on DOM element and pushes into special array that might be removed
           *
           * @param {EventTarget} element - DOM Element
           * @param {string} eventType - Event name
           * @param {Function} handler - Event handler
           * @param {boolean|AddEventListenerOptions} options - Listening options
           */
          on: (o2, i2, n2, r2 = false) => {
            this.mutableListenerIds.push(
              this.listeners.on(o2, i2, n2, r2)
            );
          },
          /**
           * Clears all mutable listeners
           */
          clearAll: () => {
            for (const o2 of this.mutableListenerIds)
              this.listeners.offById(o2);
            this.mutableListenerIds = [];
          }
        }, this.mutableListenerIds = [], new.target === C)
          throw new TypeError("Constructors for abstract class Module are not allowed.");
        this.config = e2, this.eventsDispatcher = t2;
      }
      /**
       * Editor modules setter
       *
       * @param {EditorModules} Editor - Editor's Modules
       */
      set state(e2) {
        this.Editor = e2;
      }
      /**
       * Remove memorized nodes
       */
      removeAllNodes() {
        for (const e2 in this.nodes) {
          const t2 = this.nodes[e2];
          t2 instanceof HTMLElement && t2.remove();
        }
      }
      /**
       * Returns true if current direction is RTL (Right-To-Left)
       */
      get isRtl() {
        return this.config.i18n.direction === "rtl";
      }
    }
    let m$1 = class m2 {
      constructor() {
        this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = false, this.commandBackground = "backColor", this.commandRemoveFormat = "removeFormat";
      }
      /**
       * Editor styles
       *
       * @returns {{editorWrapper: string, editorZone: string}}
       */
      static get CSS() {
        return {
          editorWrapper: "codex-editor",
          editorZone: "codex-editor__redactor"
        };
      }
      /**
       * Returns selected anchor
       * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}
       *
       * @returns {Node|null}
       */
      static get anchorNode() {
        const e2 = window.getSelection();
        return e2 ? e2.anchorNode : null;
      }
      /**
       * Returns selected anchor element
       *
       * @returns {Element|null}
       */
      static get anchorElement() {
        const e2 = window.getSelection();
        if (!e2)
          return null;
        const t2 = e2.anchorNode;
        return t2 ? d$1.isElement(t2) ? t2 : t2.parentElement : null;
      }
      /**
       * Returns selection offset according to the anchor node
       * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}
       *
       * @returns {number|null}
       */
      static get anchorOffset() {
        const e2 = window.getSelection();
        return e2 ? e2.anchorOffset : null;
      }
      /**
       * Is current selection range collapsed
       *
       * @returns {boolean|null}
       */
      static get isCollapsed() {
        const e2 = window.getSelection();
        return e2 ? e2.isCollapsed : null;
      }
      /**
       * Check current selection if it is at Editor's zone
       *
       * @returns {boolean}
       */
      static get isAtEditor() {
        return this.isSelectionAtEditor(m2.get());
      }
      /**
       * Check if passed selection is at Editor's zone
       *
       * @param selection - Selection object to check
       */
      static isSelectionAtEditor(e2) {
        if (!e2)
          return false;
        let t2 = e2.anchorNode || e2.focusNode;
        t2 && t2.nodeType === Node.TEXT_NODE && (t2 = t2.parentNode);
        let o2 = null;
        return t2 && t2 instanceof Element && (o2 = t2.closest(`.${m2.CSS.editorZone}`)), o2 ? o2.nodeType === Node.ELEMENT_NODE : false;
      }
      /**
       * Check if passed range at Editor zone
       *
       * @param range - range to check
       */
      static isRangeAtEditor(e2) {
        if (!e2)
          return;
        let t2 = e2.startContainer;
        t2 && t2.nodeType === Node.TEXT_NODE && (t2 = t2.parentNode);
        let o2 = null;
        return t2 && t2 instanceof Element && (o2 = t2.closest(`.${m2.CSS.editorZone}`)), o2 ? o2.nodeType === Node.ELEMENT_NODE : false;
      }
      /**
       * Methods return boolean that true if selection exists on the page
       */
      static get isSelectionExists() {
        return !!m2.get().anchorNode;
      }
      /**
       * Return first range
       *
       * @returns {Range|null}
       */
      static get range() {
        return this.getRangeFromSelection(this.get());
      }
      /**
       * Returns range from passed Selection object
       *
       * @param selection - Selection object to get Range from
       */
      static getRangeFromSelection(e2) {
        return e2 && e2.rangeCount ? e2.getRangeAt(0) : null;
      }
      /**
       * Calculates position and size of selected text
       *
       * @returns {DOMRect | ClientRect}
       */
      static get rect() {
        let e2 = document.selection, t2, o2 = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
        if (e2 && e2.type !== "Control")
          return e2 = e2, t2 = e2.createRange(), o2.x = t2.boundingLeft, o2.y = t2.boundingTop, o2.width = t2.boundingWidth, o2.height = t2.boundingHeight, o2;
        if (!window.getSelection)
          return L$1("Method window.getSelection is not supported", "warn"), o2;
        if (e2 = window.getSelection(), e2.rangeCount === null || isNaN(e2.rangeCount))
          return L$1("Method SelectionUtils.rangeCount is not supported", "warn"), o2;
        if (e2.rangeCount === 0)
          return o2;
        if (t2 = e2.getRangeAt(0).cloneRange(), t2.getBoundingClientRect && (o2 = t2.getBoundingClientRect()), o2.x === 0 && o2.y === 0) {
          const i2 = document.createElement("span");
          if (i2.getBoundingClientRect) {
            i2.appendChild(document.createTextNode("")), t2.insertNode(i2), o2 = i2.getBoundingClientRect();
            const n2 = i2.parentNode;
            n2.removeChild(i2), n2.normalize();
          }
        }
        return o2;
      }
      /**
       * Returns selected text as String
       *
       * @returns {string}
       */
      static get text() {
        return window.getSelection ? window.getSelection().toString() : "";
      }
      /**
       * Returns window SelectionUtils
       * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}
       *
       * @returns {Selection}
       */
      static get() {
        return window.getSelection();
      }
      /**
       * Set focus to contenteditable or native input element
       *
       * @param element - element where to set focus
       * @param offset - offset of cursor
       */
      static setCursor(e2, t2 = 0) {
        const o2 = document.createRange(), i2 = window.getSelection();
        return d$1.isNativeInput(e2) ? d$1.canSetCaret(e2) ? (e2.focus(), e2.selectionStart = e2.selectionEnd = t2, e2.getBoundingClientRect()) : void 0 : (o2.setStart(e2, t2), o2.setEnd(e2, t2), i2.removeAllRanges(), i2.addRange(o2), o2.getBoundingClientRect());
      }
      /**
       * Check if current range exists and belongs to container
       *
       * @param container - where range should be
       */
      static isRangeInsideContainer(e2) {
        const t2 = m2.range;
        return t2 === null ? false : e2.contains(t2.startContainer);
      }
      /**
       * Adds fake cursor to the current range
       */
      static addFakeCursor() {
        const e2 = m2.range;
        if (e2 === null)
          return;
        const t2 = d$1.make("span", "codex-editor__fake-cursor");
        t2.dataset.mutationFree = "true", e2.collapse(), e2.insertNode(t2);
      }
      /**
       * Check if passed element contains a fake cursor
       *
       * @param el - where to check
       */
      static isFakeCursorInsideContainer(e2) {
        return d$1.find(e2, ".codex-editor__fake-cursor") !== null;
      }
      /**
       * Removes fake cursor from a container
       *
       * @param container - container to look for
       */
      static removeFakeCursor(e2 = document.body) {
        const t2 = d$1.find(e2, ".codex-editor__fake-cursor");
        t2 && t2.remove();
      }
      /**
       * Removes fake background
       */
      removeFakeBackground() {
        this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = false, document.execCommand(this.commandRemoveFormat));
      }
      /**
       * Sets fake background
       */
      setFakeBackground() {
        document.execCommand(this.commandBackground, false, "#a8d6ff"), this.isFakeBackgroundEnabled = true;
      }
      /**
       * Save SelectionUtils's range
       */
      save() {
        this.savedSelectionRange = m2.range;
      }
      /**
       * Restore saved SelectionUtils's range
       */
      restore() {
        if (!this.savedSelectionRange)
          return;
        const e2 = window.getSelection();
        e2.removeAllRanges(), e2.addRange(this.savedSelectionRange);
      }
      /**
       * Clears saved selection
       */
      clearSaved() {
        this.savedSelectionRange = null;
      }
      /**
       * Collapse current selection
       */
      collapseToEnd() {
        const e2 = window.getSelection(), t2 = document.createRange();
        t2.selectNodeContents(e2.focusNode), t2.collapse(false), e2.removeAllRanges(), e2.addRange(t2);
      }
      /**
       * Looks ahead to find passed tag from current selection
       *
       * @param  {string} tagName       - tag to found
       * @param  {string} [className]   - tag's class name
       * @param  {number} [searchDepth] - count of tags that can be included. For better performance.
       * @returns {HTMLElement|null}
       */
      findParentTag(e2, t2, o2 = 10) {
        const i2 = window.getSelection();
        let n2 = null;
        return !i2 || !i2.anchorNode || !i2.focusNode ? null : ([
          /** the Node in which the selection begins */
          i2.anchorNode,
          /** the Node in which the selection ends */
          i2.focusNode
        ].forEach((a2) => {
          let l2 = o2;
          for (; l2 > 0 && a2.parentNode && !(a2.tagName === e2 && (n2 = a2, t2 && a2.classList && !a2.classList.contains(t2) && (n2 = null), n2)); )
            a2 = a2.parentNode, l2--;
        }), n2);
      }
      /**
       * Expands selection range to the passed parent node
       *
       * @param {HTMLElement} element - element which contents should be selected
       */
      expandToTag(e2) {
        const t2 = window.getSelection();
        t2.removeAllRanges();
        const o2 = document.createRange();
        o2.selectNodeContents(e2), t2.addRange(o2);
      }
    };
    function Zt(s2, e2) {
      const { type: t2, target: o2, addedNodes: i2, removedNodes: n2 } = s2;
      if (o2 === e2)
        return true;
      if (["characterData", "attributes"].includes(t2)) {
        const l2 = o2.nodeType === Node.TEXT_NODE ? o2.parentNode : o2;
        return e2.contains(l2);
      }
      const r2 = Array.from(i2).some((l2) => e2.contains(l2)), a2 = Array.from(n2).some((l2) => e2.contains(l2));
      return r2 || a2;
    }
    const Me = "redactor dom changed", ct = "block changed", dt = "fake cursor is about to be toggled", ht = "fake cursor have been set";
    function Je(s2, e2) {
      return s2.mergeable && s2.name === e2.name;
    }
    function Gt(s2, e2) {
      const t2 = e2 == null ? void 0 : e2.export;
      return D$1(t2) ? t2(s2) : J(t2) ? s2[t2] : (t2 !== void 0 && L$1("Conversion export property must be a string or function. String means key of saved data object to export. Function should export processed string to export."), "");
    }
    function Jt(s2, e2) {
      const t2 = e2 == null ? void 0 : e2.import;
      return D$1(t2) ? t2(s2) : J(t2) ? {
        [t2]: s2
      } : (t2 !== void 0 && L$1("Conversion import property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data."), {});
    }
    var q = /* @__PURE__ */ ((s2) => (s2.APPEND_CALLBACK = "appendCallback", s2.RENDERED = "rendered", s2.MOVED = "moved", s2.UPDATED = "updated", s2.REMOVED = "removed", s2.ON_PASTE = "onPaste", s2))(q || {});
    let F$1 = class F2 extends we {
      /**
       * @param options - block constructor options
       * @param [options.id] - block's id. Will be generated if omitted.
       * @param options.data - Tool's initial data
       * @param options.tool  block's tool
       * @param options.api - Editor API module for pass it to the Block Tunes
       * @param options.readOnly - Read-Only flag
       * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when "virtual" Block is created. See BlocksAPI@composeBlockData.
       */
      constructor({
        id: e2 = Ut(),
        data: t2,
        tool: o2,
        api: i2,
        readOnly: n2,
        tunesData: r2
      }, a2) {
        super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {
          this.dropInputsCache(), this.updateCurrentInput();
        }, this.didMutated = (l2 = void 0) => {
          const c2 = l2 === void 0, u2 = l2 instanceof InputEvent;
          !c2 && !u2 && this.detectToolRootChange(l2);
          let h2;
          c2 || u2 ? h2 = true : h2 = !(l2.length > 0 && l2.every((k2) => {
            const { addedNodes: p2, removedNodes: v2, target: A2 } = k2;
            return [
              ...Array.from(p2),
              ...Array.from(v2),
              A2
            ].some((_2) => d$1.isElement(_2) ? _2.dataset.mutationFree === "true" : false);
          })), h2 && (this.dropInputsCache(), this.updateCurrentInput(), this.call(
            "updated"
            /* UPDATED */
          ), this.emit("didMutated", this));
        }, this.name = o2.name, this.id = e2, this.settings = o2.settings, this.config = o2.settings.config || {}, this.api = i2, this.editorEventBus = a2 || null, this.blockAPI = new ee(this), this.tool = o2, this.toolInstance = o2.create(t2, this.blockAPI, n2), this.tunes = o2.tunes, this.composeTunes(r2), this.holder = this.compose(), window.requestIdleCallback(() => {
          this.watchBlockMutations(), this.addInputEvents();
        });
      }
      /**
       * CSS classes for the Block
       *
       * @returns {{wrapper: string, content: string}}
       */
      static get CSS() {
        return {
          wrapper: "ce-block",
          wrapperStretched: "ce-block--stretched",
          content: "ce-block__content",
          focused: "ce-block--focused",
          selected: "ce-block--selected",
          dropTarget: "ce-block--drop-target"
        };
      }
      /**
       * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML
       *
       * @returns {HTMLElement[]}
       */
      get inputs() {
        if (this.cachedInputs.length !== 0)
          return this.cachedInputs;
        const e2 = d$1.findAllInputs(this.holder);
        return this.inputIndex > e2.length - 1 && (this.inputIndex = e2.length - 1), this.cachedInputs = e2, e2;
      }
      /**
       * Return current Tool`s input
       *
       * @returns {HTMLElement}
       */
      get currentInput() {
        return this.inputs[this.inputIndex];
      }
      /**
       * Set input index to the passed element
       *
       * @param {HTMLElement | Node} element - HTML Element to set as current input
       */
      set currentInput(e2) {
        const t2 = this.inputs.findIndex((o2) => o2 === e2 || o2.contains(e2));
        t2 !== -1 && (this.inputIndex = t2);
      }
      /**
       * Return first Tool`s input
       *
       * @returns {HTMLElement}
       */
      get firstInput() {
        return this.inputs[0];
      }
      /**
       * Return first Tool`s input
       *
       * @returns {HTMLElement}
       */
      get lastInput() {
        const e2 = this.inputs;
        return e2[e2.length - 1];
      }
      /**
       * Return next Tool`s input or undefined if it doesn't exist
       *
       * @returns {HTMLElement}
       */
      get nextInput() {
        return this.inputs[this.inputIndex + 1];
      }
      /**
       * Return previous Tool`s input or undefined if it doesn't exist
       *
       * @returns {HTMLElement}
       */
      get previousInput() {
        return this.inputs[this.inputIndex - 1];
      }
      /**
       * Get Block's JSON data
       *
       * @returns {object}
       */
      get data() {
        return this.save().then((e2) => e2 && !V(e2.data) ? e2.data : {});
      }
      /**
       * Returns tool's sanitizer config
       *
       * @returns {object}
       */
      get sanitize() {
        return this.tool.sanitizeConfig;
      }
      /**
       * is block mergeable
       * We plugin have merge function then we call it mergeable
       *
       * @returns {boolean}
       */
      get mergeable() {
        return D$1(this.toolInstance.merge);
      }
      /**
       * Check block for emptiness
       *
       * @returns {boolean}
       */
      get isEmpty() {
        const e2 = d$1.isEmpty(this.pluginsContent), t2 = !this.hasMedia;
        return e2 && t2;
      }
      /**
       * Check if block has a media content such as images, iframe and other
       *
       * @returns {boolean}
       */
      get hasMedia() {
        const e2 = [
          "img",
          "iframe",
          "video",
          "audio",
          "source",
          "input",
          "textarea",
          "twitterwidget"
        ];
        return !!this.holder.querySelector(e2.join(","));
      }
      /**
       * Set focused state
       *
       * @param {boolean} state - 'true' to select, 'false' to remove selection
       */
      set focused(e2) {
        this.holder.classList.toggle(F2.CSS.focused, e2);
      }
      /**
       * Get Block's focused state
       */
      get focused() {
        return this.holder.classList.contains(F2.CSS.focused);
      }
      /**
       * Set selected state
       * We don't need to mark Block as Selected when it is empty
       *
       * @param {boolean} state - 'true' to select, 'false' to remove selection
       */
      set selected(e2) {
        var i2, n2;
        this.holder.classList.toggle(F2.CSS.selected, e2);
        const t2 = e2 === true && m$1.isRangeInsideContainer(this.holder), o2 = e2 === false && m$1.isFakeCursorInsideContainer(this.holder);
        (t2 || o2) && ((i2 = this.editorEventBus) == null || i2.emit(dt, { state: e2 }), t2 ? m$1.addFakeCursor() : m$1.removeFakeCursor(this.holder), (n2 = this.editorEventBus) == null || n2.emit(ht, { state: e2 }));
      }
      /**
       * Returns True if it is Selected
       *
       * @returns {boolean}
       */
      get selected() {
        return this.holder.classList.contains(F2.CSS.selected);
      }
      /**
       * Set stretched state
       *
       * @param {boolean} state - 'true' to enable, 'false' to disable stretched state
       */
      set stretched(e2) {
        this.holder.classList.toggle(F2.CSS.wrapperStretched, e2);
      }
      /**
       * Return Block's stretched state
       *
       * @returns {boolean}
       */
      get stretched() {
        return this.holder.classList.contains(F2.CSS.wrapperStretched);
      }
      /**
       * Toggle drop target state
       *
       * @param {boolean} state - 'true' if block is drop target, false otherwise
       */
      set dropTarget(e2) {
        this.holder.classList.toggle(F2.CSS.dropTarget, e2);
      }
      /**
       * Returns Plugins content
       *
       * @returns {HTMLElement}
       */
      get pluginsContent() {
        return this.toolRenderedElement;
      }
      /**
       * Calls Tool's method
       *
       * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function
       *
       * @param {string} methodName - method to call
       * @param {object} params - method argument
       */
      call(e2, t2) {
        if (D$1(this.toolInstance[e2])) {
          e2 === "appendCallback" && L$1(
            "`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead",
            "warn"
          );
          try {
            this.toolInstance[e2].call(this.toolInstance, t2);
          } catch (o2) {
            L$1(`Error during '${e2}' call: ${o2.message}`, "error");
          }
        }
      }
      /**
       * Call plugins merge method
       *
       * @param {BlockToolData} data - data to merge
       */
      async mergeWith(e2) {
        await this.toolInstance.merge(e2);
      }
      /**
       * Extracts data from Block
       * Groups Tool's save processing time
       *
       * @returns {object}
       */
      async save() {
        const e2 = await this.toolInstance.save(this.pluginsContent), t2 = this.unavailableTunesData;
        [
          ...this.tunesInstances.entries(),
          ...this.defaultTunesInstances.entries()
        ].forEach(([n2, r2]) => {
          if (D$1(r2.save))
            try {
              t2[n2] = r2.save();
            } catch (a2) {
              L$1(`Tune ${r2.constructor.name} save method throws an Error %o`, "warn", a2);
            }
        });
        const o2 = window.performance.now();
        let i2;
        return Promise.resolve(e2).then((n2) => (i2 = window.performance.now(), {
          id: this.id,
          tool: this.name,
          data: n2,
          tunes: t2,
          time: i2 - o2
        })).catch((n2) => {
          L$1(`Saving process for ${this.name} tool failed due to the ${n2}`, "log", "red");
        });
      }
      /**
       * Uses Tool's validation method to check the correctness of output data
       * Tool's validation method is optional
       *
       * @description Method returns true|false whether data passed the validation or not
       * @param {BlockToolData} data - data to validate
       * @returns {Promise<boolean>} valid
       */
      async validate(e2) {
        let t2 = true;
        return this.toolInstance.validate instanceof Function && (t2 = await this.toolInstance.validate(e2)), t2;
      }
      /**
       * Returns data to render in tunes menu.
       * Splits block tunes settings into 2 groups: popover items and custom html.
       */
      getTunes() {
        const e2 = document.createElement("div"), t2 = [], o2 = typeof this.toolInstance.renderSettings == "function" ? this.toolInstance.renderSettings() : [], i2 = [
          ...this.tunesInstances.values(),
          ...this.defaultTunesInstances.values()
        ].map((n2) => n2.render());
        return [o2, i2].flat().forEach((n2) => {
          d$1.isElement(n2) ? e2.appendChild(n2) : Array.isArray(n2) ? t2.push(...n2) : t2.push(n2);
        }), [t2, e2];
      }
      /**
       * Update current input index with selection anchor node
       */
      updateCurrentInput() {
        this.currentInput = d$1.isNativeInput(document.activeElement) || !m$1.anchorNode ? document.activeElement : m$1.anchorNode;
      }
      /**
       * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback
       * Can be useful for block changes invisible for editor core.
       */
      dispatchChange() {
        this.didMutated();
      }
      /**
       * Call Tool instance destroy method
       */
      destroy() {
        this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), D$1(this.toolInstance.destroy) && this.toolInstance.destroy();
      }
      /**
       * Tool could specify several entries to be displayed at the Toolbox (for example, "Heading 1", "Heading 2", "Heading 3")
       * This method returns the entry that is related to the Block (depended on the Block data)
       */
      async getActiveToolboxEntry() {
        const e2 = this.tool.toolbox;
        if (e2.length === 1)
          return Promise.resolve(this.tool.toolbox[0]);
        const t2 = await this.data;
        return e2.find((i2) => Object.entries(i2.data).some(([n2, r2]) => t2[n2] && Yt(t2[n2], r2)));
      }
      /**
       * Exports Block data as string using conversion config
       */
      async exportDataAsString() {
        const e2 = await this.data;
        return Gt(e2, this.tool.conversionConfig);
      }
      /**
       * Make default Block wrappers and put Tool`s content there
       *
       * @returns {HTMLDivElement}
       */
      compose() {
        const e2 = d$1.make("div", F2.CSS.wrapper), t2 = d$1.make("div", F2.CSS.content), o2 = this.toolInstance.render();
        e2.dataset.id = this.id, this.toolRenderedElement = o2, t2.appendChild(this.toolRenderedElement);
        let i2 = t2;
        return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((n2) => {
          if (D$1(n2.wrap))
            try {
              i2 = n2.wrap(i2);
            } catch (r2) {
              L$1(`Tune ${n2.constructor.name} wrap method throws an Error %o`, "warn", r2);
            }
        }), e2.appendChild(i2), e2;
      }
      /**
       * Instantiate Block Tunes
       *
       * @param tunesData - current Block tunes data
       * @private
       */
      composeTunes(e2) {
        Array.from(this.tunes.values()).forEach((t2) => {
          (t2.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t2.name, t2.create(e2[t2.name], this.blockAPI));
        }), Object.entries(e2).forEach(([t2, o2]) => {
          this.tunesInstances.has(t2) || (this.unavailableTunesData[t2] = o2);
        });
      }
      /**
       * Adds focus event listeners to all inputs and contenteditable
       */
      addInputEvents() {
        this.inputs.forEach((e2) => {
          e2.addEventListener("focus", this.handleFocus), d$1.isNativeInput(e2) && e2.addEventListener("input", this.didMutated);
        });
      }
      /**
       * removes focus event listeners from all inputs and contenteditable
       */
      removeInputEvents() {
        this.inputs.forEach((e2) => {
          e2.removeEventListener("focus", this.handleFocus), d$1.isNativeInput(e2) && e2.removeEventListener("input", this.didMutated);
        });
      }
      /**
       * Listen common editor Dom Changed event and detect mutations related to the  Block
       */
      watchBlockMutations() {
        var e2;
        this.redactorDomChangedCallback = (t2) => {
          const { mutations: o2 } = t2;
          o2.some((n2) => Zt(n2, this.toolRenderedElement)) && this.didMutated(o2);
        }, (e2 = this.editorEventBus) == null || e2.on(Me, this.redactorDomChangedCallback);
      }
      /**
       * Remove redactor dom change event listener
       */
      unwatchBlockMutations() {
        var e2;
        (e2 = this.editorEventBus) == null || e2.off(Me, this.redactorDomChangedCallback);
      }
      /**
       * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL
       * We need to detect such changes and update a link to tools main element with the new one
       *
       * @param mutations - records of block content mutations
       */
      detectToolRootChange(e2) {
        e2.forEach((t2) => {
          if (Array.from(t2.removedNodes).includes(this.toolRenderedElement)) {
            const i2 = t2.addedNodes[t2.addedNodes.length - 1];
            this.toolRenderedElement = i2;
          }
        });
      }
      /**
       * Clears inputs cached value
       */
      dropInputsCache() {
        this.cachedInputs = [];
      }
    };
    class Qt extends C {
      constructor() {
        super(...arguments), this.insert = (e2 = this.config.defaultBlock, t2 = {}, o2 = {}, i2, n2, r2, a2) => {
          const l2 = this.Editor.BlockManager.insert({
            id: a2,
            tool: e2,
            data: t2,
            index: i2,
            needToFocus: n2,
            replace: r2
          });
          return new ee(l2);
        }, this.composeBlockData = async (e2) => {
          const t2 = this.Editor.Tools.blockTools.get(e2);
          return new F$1({
            tool: t2,
            api: this.Editor.API,
            readOnly: true,
            data: {},
            tunesData: {}
          }).data;
        }, this.update = async (e2, t2) => {
          const { BlockManager: o2 } = this.Editor, i2 = o2.getBlockById(e2);
          if (i2 === void 0)
            throw new Error(`Block with id "${e2}" not found`);
          const n2 = await o2.update(i2, t2);
          return new ee(n2);
        }, this.convert = (e2, t2, o2) => {
          var h2, f2;
          const { BlockManager: i2, Tools: n2 } = this.Editor, r2 = i2.getBlockById(e2);
          if (!r2)
            throw new Error(`Block with id "${e2}" not found`);
          const a2 = n2.blockTools.get(r2.name), l2 = n2.blockTools.get(t2);
          if (!l2)
            throw new Error(`Block Tool with type "${t2}" not found`);
          const c2 = ((h2 = a2 == null ? void 0 : a2.conversionConfig) == null ? void 0 : h2.export) !== void 0, u2 = ((f2 = l2.conversionConfig) == null ? void 0 : f2.import) !== void 0;
          if (c2 && u2)
            i2.convert(r2, t2, o2);
          else {
            const k2 = [
              c2 ? false : ae(r2.name),
              u2 ? false : ae(t2)
            ].filter(Boolean).join(" and ");
            throw new Error(`Conversion from "${r2.name}" to "${t2}" is not possible. ${k2} tool(s) should provide a "conversionConfig"`);
          }
        }, this.insertMany = (e2, t2 = this.Editor.BlockManager.blocks.length - 1) => {
          this.validateIndex(t2);
          const o2 = e2.map(({ id: i2, type: n2, data: r2 }) => this.Editor.BlockManager.composeBlock({
            id: i2,
            tool: n2 || this.config.defaultBlock,
            data: r2
          }));
          return this.Editor.BlockManager.insertMany(o2, t2), o2.map((i2) => new ee(i2));
        };
      }
      /**
       * Available methods
       *
       * @returns {Blocks}
       */
      get methods() {
        return {
          clear: () => this.clear(),
          render: (e2) => this.render(e2),
          renderFromHTML: (e2) => this.renderFromHTML(e2),
          delete: (e2) => this.delete(e2),
          swap: (e2, t2) => this.swap(e2, t2),
          move: (e2, t2) => this.move(e2, t2),
          getBlockByIndex: (e2) => this.getBlockByIndex(e2),
          getById: (e2) => this.getById(e2),
          getCurrentBlockIndex: () => this.getCurrentBlockIndex(),
          getBlockIndex: (e2) => this.getBlockIndex(e2),
          getBlocksCount: () => this.getBlocksCount(),
          stretchBlock: (e2, t2 = true) => this.stretchBlock(e2, t2),
          insertNewBlock: () => this.insertNewBlock(),
          insert: this.insert,
          insertMany: this.insertMany,
          update: this.update,
          composeBlockData: this.composeBlockData,
          convert: this.convert
        };
      }
      /**
       * Returns Blocks count
       *
       * @returns {number}
       */
      getBlocksCount() {
        return this.Editor.BlockManager.blocks.length;
      }
      /**
       * Returns current block index
       *
       * @returns {number}
       */
      getCurrentBlockIndex() {
        return this.Editor.BlockManager.currentBlockIndex;
      }
      /**
       * Returns the index of Block by id;
       *
       * @param id - block id
       */
      getBlockIndex(e2) {
        const t2 = this.Editor.BlockManager.getBlockById(e2);
        if (!t2) {
          K("There is no block with id `" + e2 + "`", "warn");
          return;
        }
        return this.Editor.BlockManager.getBlockIndex(t2);
      }
      /**
       * Returns BlockAPI object by Block index
       *
       * @param {number} index - index to get
       */
      getBlockByIndex(e2) {
        const t2 = this.Editor.BlockManager.getBlockByIndex(e2);
        if (t2 === void 0) {
          K("There is no block at index `" + e2 + "`", "warn");
          return;
        }
        return new ee(t2);
      }
      /**
       * Returns BlockAPI object by Block id
       *
       * @param id - id of block to get
       */
      getById(e2) {
        const t2 = this.Editor.BlockManager.getBlockById(e2);
        return t2 === void 0 ? (K("There is no block with id `" + e2 + "`", "warn"), null) : new ee(t2);
      }
      /**
       * Call Block Manager method that swap Blocks
       *
       * @param {number} fromIndex - position of first Block
       * @param {number} toIndex - position of second Block
       * @deprecated  use 'move' instead
       */
      swap(e2, t2) {
        L$1(
          "`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead",
          "info"
        ), this.Editor.BlockManager.swap(e2, t2);
      }
      /**
       * Move block from one index to another
       *
       * @param {number} toIndex - index to move to
       * @param {number} fromIndex - index to move from
       */
      move(e2, t2) {
        this.Editor.BlockManager.move(e2, t2);
      }
      /**
       * Deletes Block
       *
       * @param {number} blockIndex - index of Block to delete
       */
      delete(e2 = this.Editor.BlockManager.currentBlockIndex) {
        try {
          const t2 = this.Editor.BlockManager.getBlockByIndex(e2);
          this.Editor.BlockManager.removeBlock(t2);
        } catch (t2) {
          K(t2, "warn");
          return;
        }
        this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();
      }
      /**
       * Clear Editor's area
       */
      async clear() {
        await this.Editor.BlockManager.clear(true), this.Editor.InlineToolbar.close();
      }
      /**
       * Fills Editor with Blocks data
       *
       * @param {OutputData} data  Saved Editor data
       */
      async render(e2) {
        if (e2 === void 0 || e2.blocks === void 0)
          throw new Error("Incorrect data passed to the render() method");
        this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e2.blocks), this.Editor.ModificationsObserver.enable();
      }
      /**
       * Render passed HTML string
       *
       * @param {string} data - HTML string to render
       * @returns {Promise<void>}
       */
      renderFromHTML(e2) {
        return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e2, true);
      }
      /**
       * Stretch Block's content
       *
       * @param {number} index - index of Block to stretch
       * @param {boolean} status - true to enable, false to disable
       * @deprecated Use BlockAPI interface to stretch Blocks
       */
      stretchBlock(e2, t2 = true) {
        Ie(
          true,
          "blocks.stretchBlock()",
          "BlockAPI"
        );
        const o2 = this.Editor.BlockManager.getBlockByIndex(e2);
        o2 && (o2.stretched = t2);
      }
      /**
       * Insert new Block
       * After set caret to this Block
       *
       * @todo remove in 3.0.0
       * @deprecated with insert() method
       */
      insertNewBlock() {
        L$1("Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.", "warn"), this.insert();
      }
      /**
       * Validated block index and throws an error if it's invalid
       *
       * @param index - index to validate
       */
      validateIndex(e2) {
        if (typeof e2 != "number")
          throw new Error("Index should be a number");
        if (e2 < 0)
          throw new Error("Index should be greater than or equal to 0");
        if (e2 === null)
          throw new Error("Index should be greater than or equal to 0");
      }
    }
    class eo extends C {
      constructor() {
        super(...arguments), this.setToFirstBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e2, t2), true) : false, this.setToLastBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e2, t2), true) : false, this.setToPreviousBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e2, t2), true) : false, this.setToNextBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e2, t2), true) : false, this.setToBlock = (e2, t2 = this.Editor.Caret.positions.DEFAULT, o2 = 0) => this.Editor.BlockManager.blocks[e2] ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.blocks[e2], t2, o2), true) : false, this.focus = (e2 = false) => e2 ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);
      }
      /**
       * Available methods
       *
       * @returns {Caret}
       */
      get methods() {
        return {
          setToFirstBlock: this.setToFirstBlock,
          setToLastBlock: this.setToLastBlock,
          setToPreviousBlock: this.setToPreviousBlock,
          setToNextBlock: this.setToNextBlock,
          setToBlock: this.setToBlock,
          focus: this.focus
        };
      }
    }
    class to extends C {
      /**
       * Available methods
       *
       * @returns {Events}
       */
      get methods() {
        return {
          emit: (e2, t2) => this.emit(e2, t2),
          off: (e2, t2) => this.off(e2, t2),
          on: (e2, t2) => this.on(e2, t2)
        };
      }
      /**
       * Subscribe on Events
       *
       * @param {string} eventName - event name to subscribe
       * @param {Function} callback - event handler
       */
      on(e2, t2) {
        this.eventsDispatcher.on(e2, t2);
      }
      /**
       * Emit event with data
       *
       * @param {string} eventName - event to emit
       * @param {object} data - event's data
       */
      emit(e2, t2) {
        this.eventsDispatcher.emit(e2, t2);
      }
      /**
       * Unsubscribe from Event
       *
       * @param {string} eventName - event to unsubscribe
       * @param {Function} callback - event handler
       */
      off(e2, t2) {
        this.eventsDispatcher.off(e2, t2);
      }
    }
    class Pe extends C {
      /**
       * Return namespace section for tool or block tune
       *
       * @param tool - tool object
       */
      static getNamespace(e2) {
        return e2.isTune() ? `blockTunes.${e2.name}` : `tools.${e2.name}`;
      }
      /**
       * Return I18n API methods with global dictionary access
       */
      get methods() {
        return {
          t: () => {
            K("I18n.t() method can be accessed only from Tools", "warn");
          }
        };
      }
      /**
       * Return I18n API methods with tool namespaced dictionary
       *
       * @param tool - Tool object
       */
      getMethodsForTool(e2) {
        return Object.assign(
          this.methods,
          {
            t: (t2) => $.t(Pe.getNamespace(e2), t2)
          }
        );
      }
    }
    class oo extends C {
      /**
       * Editor.js Core API modules
       */
      get methods() {
        return {
          blocks: this.Editor.BlocksAPI.methods,
          caret: this.Editor.CaretAPI.methods,
          events: this.Editor.EventsAPI.methods,
          listeners: this.Editor.ListenersAPI.methods,
          notifier: this.Editor.NotifierAPI.methods,
          sanitizer: this.Editor.SanitizerAPI.methods,
          saver: this.Editor.SaverAPI.methods,
          selection: this.Editor.SelectionAPI.methods,
          styles: this.Editor.StylesAPI.classes,
          toolbar: this.Editor.ToolbarAPI.methods,
          inlineToolbar: this.Editor.InlineToolbarAPI.methods,
          tooltip: this.Editor.TooltipAPI.methods,
          i18n: this.Editor.I18nAPI.methods,
          readOnly: this.Editor.ReadOnlyAPI.methods,
          ui: this.Editor.UiAPI.methods
        };
      }
      /**
       * Returns Editor.js Core API methods for passed tool
       *
       * @param tool - tool object
       */
      getMethodsForTool(e2) {
        return Object.assign(
          this.methods,
          {
            i18n: this.Editor.I18nAPI.getMethodsForTool(e2)
          }
        );
      }
    }
    class io extends C {
      /**
       * Available methods
       *
       * @returns {InlineToolbar}
       */
      get methods() {
        return {
          close: () => this.close(),
          open: () => this.open()
        };
      }
      /**
       * Open Inline Toolbar
       */
      open() {
        this.Editor.InlineToolbar.tryToShow();
      }
      /**
       * Close Inline Toolbar
       */
      close() {
        this.Editor.InlineToolbar.close();
      }
    }
    class no extends C {
      /**
       * Available methods
       *
       * @returns {Listeners}
       */
      get methods() {
        return {
          on: (e2, t2, o2, i2) => this.on(e2, t2, o2, i2),
          off: (e2, t2, o2, i2) => this.off(e2, t2, o2, i2),
          offById: (e2) => this.offById(e2)
        };
      }
      /**
       * Ads a DOM event listener. Return it's id.
       *
       * @param {HTMLElement} element - Element to set handler to
       * @param {string} eventType - event type
       * @param {() => void} handler - event handler
       * @param {boolean} useCapture - capture event or not
       */
      on(e2, t2, o2, i2) {
        return this.listeners.on(e2, t2, o2, i2);
      }
      /**
       * Removes DOM listener from element
       *
       * @param {Element} element - Element to remove handler from
       * @param eventType - event type
       * @param handler - event handler
       * @param {boolean} useCapture - capture event or not
       */
      off(e2, t2, o2, i2) {
        this.listeners.off(e2, t2, o2, i2);
      }
      /**
       * Removes DOM listener by the listener id
       *
       * @param id - id of the listener to remove
       */
      offById(e2) {
        this.listeners.offById(e2);
      }
    }
    var Le = {}, so = {
      get exports() {
        return Le;
      },
      set exports(s2) {
        Le = s2;
      }
    };
    (function(s2, e2) {
      (function(t2, o2) {
        s2.exports = o2();
      })(window, function() {
        return function(t2) {
          var o2 = {};
          function i2(n2) {
            if (o2[n2])
              return o2[n2].exports;
            var r2 = o2[n2] = { i: n2, l: false, exports: {} };
            return t2[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
          }
          return i2.m = t2, i2.c = o2, i2.d = function(n2, r2, a2) {
            i2.o(n2, r2) || Object.defineProperty(n2, r2, { enumerable: true, get: a2 });
          }, i2.r = function(n2) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
          }, i2.t = function(n2, r2) {
            if (1 & r2 && (n2 = i2(n2)), 8 & r2 || 4 & r2 && typeof n2 == "object" && n2 && n2.__esModule)
              return n2;
            var a2 = /* @__PURE__ */ Object.create(null);
            if (i2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: n2 }), 2 & r2 && typeof n2 != "string")
              for (var l2 in n2)
                i2.d(a2, l2, (function(c2) {
                  return n2[c2];
                }).bind(null, l2));
            return a2;
          }, i2.n = function(n2) {
            var r2 = n2 && n2.__esModule ? function() {
              return n2.default;
            } : function() {
              return n2;
            };
            return i2.d(r2, "a", r2), r2;
          }, i2.o = function(n2, r2) {
            return Object.prototype.hasOwnProperty.call(n2, r2);
          }, i2.p = "/", i2(i2.s = 0);
        }([function(t2, o2, i2) {
          i2(1), /*!
          * Codex JavaScript Notification module
          * https://github.com/codex-team/js-notifier
          */
          t2.exports = function() {
            var n2 = i2(6), r2 = "cdx-notify--bounce-in", a2 = null;
            return { show: function(l2) {
              if (l2.message) {
                (function() {
                  if (a2)
                    return true;
                  a2 = n2.getWrapper(), document.body.appendChild(a2);
                })();
                var c2 = null, u2 = l2.time || 8e3;
                switch (l2.type) {
                  case "confirm":
                    c2 = n2.confirm(l2);
                    break;
                  case "prompt":
                    c2 = n2.prompt(l2);
                    break;
                  default:
                    c2 = n2.alert(l2), window.setTimeout(function() {
                      c2.remove();
                    }, u2);
                }
                a2.appendChild(c2), c2.classList.add(r2);
              }
            } };
          }();
        }, function(t2, o2, i2) {
          var n2 = i2(2);
          typeof n2 == "string" && (n2 = [[t2.i, n2, ""]]);
          var r2 = { hmr: true, transform: void 0, insertInto: void 0 };
          i2(4)(n2, r2), n2.locals && (t2.exports = n2.locals);
        }, function(t2, o2, i2) {
          (t2.exports = i2(3)(false)).push([t2.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, ""]);
        }, function(t2, o2) {
          t2.exports = function(i2) {
            var n2 = [];
            return n2.toString = function() {
              return this.map(function(r2) {
                var a2 = function(l2, c2) {
                  var u2 = l2[1] || "", h2 = l2[3];
                  if (!h2)
                    return u2;
                  if (c2 && typeof btoa == "function") {
                    var f2 = (p2 = h2, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(p2)))) + " */"), k2 = h2.sources.map(function(v2) {
                      return "/*# sourceURL=" + h2.sourceRoot + v2 + " */";
                    });
                    return [u2].concat(k2).concat([f2]).join(`
`);
                  }
                  var p2;
                  return [u2].join(`
`);
                }(r2, i2);
                return r2[2] ? "@media " + r2[2] + "{" + a2 + "}" : a2;
              }).join("");
            }, n2.i = function(r2, a2) {
              typeof r2 == "string" && (r2 = [[null, r2, ""]]);
              for (var l2 = {}, c2 = 0; c2 < this.length; c2++) {
                var u2 = this[c2][0];
                typeof u2 == "number" && (l2[u2] = true);
              }
              for (c2 = 0; c2 < r2.length; c2++) {
                var h2 = r2[c2];
                typeof h2[0] == "number" && l2[h2[0]] || (a2 && !h2[2] ? h2[2] = a2 : a2 && (h2[2] = "(" + h2[2] + ") and (" + a2 + ")"), n2.push(h2));
              }
            }, n2;
          };
        }, function(t2, o2, i2) {
          var n2, r2, a2 = {}, l2 = (n2 = function() {
            return window && document && document.all && !window.atob;
          }, function() {
            return r2 === void 0 && (r2 = n2.apply(this, arguments)), r2;
          }), c2 = function(b2) {
            var g2 = {};
            return function(E2) {
              if (typeof E2 == "function")
                return E2();
              if (g2[E2] === void 0) {
                var T2 = (function(O2) {
                  return document.querySelector(O2);
                }).call(this, E2);
                if (window.HTMLIFrameElement && T2 instanceof window.HTMLIFrameElement)
                  try {
                    T2 = T2.contentDocument.head;
                  } catch {
                    T2 = null;
                  }
                g2[E2] = T2;
              }
              return g2[E2];
            };
          }(), u2 = null, h2 = 0, f2 = [], k2 = i2(5);
          function p2(b2, g2) {
            for (var E2 = 0; E2 < b2.length; E2++) {
              var T2 = b2[E2], O2 = a2[T2.id];
              if (O2) {
                O2.refs++;
                for (var S2 = 0; S2 < O2.parts.length; S2++)
                  O2.parts[S2](T2.parts[S2]);
                for (; S2 < T2.parts.length; S2++)
                  O2.parts.push(x2(T2.parts[S2], g2));
              } else {
                var H2 = [];
                for (S2 = 0; S2 < T2.parts.length; S2++)
                  H2.push(x2(T2.parts[S2], g2));
                a2[T2.id] = { id: T2.id, refs: 1, parts: H2 };
              }
            }
          }
          function v2(b2, g2) {
            for (var E2 = [], T2 = {}, O2 = 0; O2 < b2.length; O2++) {
              var S2 = b2[O2], H2 = g2.base ? S2[0] + g2.base : S2[0], M2 = { css: S2[1], media: S2[2], sourceMap: S2[3] };
              T2[H2] ? T2[H2].parts.push(M2) : E2.push(T2[H2] = { id: H2, parts: [M2] });
            }
            return E2;
          }
          function A2(b2, g2) {
            var E2 = c2(b2.insertInto);
            if (!E2)
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
            var T2 = f2[f2.length - 1];
            if (b2.insertAt === "top")
              T2 ? T2.nextSibling ? E2.insertBefore(g2, T2.nextSibling) : E2.appendChild(g2) : E2.insertBefore(g2, E2.firstChild), f2.push(g2);
            else if (b2.insertAt === "bottom")
              E2.appendChild(g2);
            else {
              if (typeof b2.insertAt != "object" || !b2.insertAt.before)
                throw new Error(`[Style Loader]

 Invalid value for parameter 'insertAt' ('options.insertAt') found.
 Must be 'top', 'bottom', or Object.
 (https://github.com/webpack-contrib/style-loader#insertat)
`);
              var O2 = c2(b2.insertInto + " " + b2.insertAt.before);
              E2.insertBefore(g2, O2);
            }
          }
          function N2(b2) {
            if (b2.parentNode === null)
              return false;
            b2.parentNode.removeChild(b2);
            var g2 = f2.indexOf(b2);
            g2 >= 0 && f2.splice(g2, 1);
          }
          function _2(b2) {
            var g2 = document.createElement("style");
            return b2.attrs.type === void 0 && (b2.attrs.type = "text/css"), y2(g2, b2.attrs), A2(b2, g2), g2;
          }
          function y2(b2, g2) {
            Object.keys(g2).forEach(function(E2) {
              b2.setAttribute(E2, g2[E2]);
            });
          }
          function x2(b2, g2) {
            var E2, T2, O2, S2;
            if (g2.transform && b2.css) {
              if (!(S2 = g2.transform(b2.css)))
                return function() {
                };
              b2.css = S2;
            }
            if (g2.singleton) {
              var H2 = h2++;
              E2 = u2 || (u2 = _2(g2)), T2 = R2.bind(null, E2, H2, false), O2 = R2.bind(null, E2, H2, true);
            } else
              b2.sourceMap && typeof URL == "function" && typeof URL.createObjectURL == "function" && typeof URL.revokeObjectURL == "function" && typeof Blob == "function" && typeof btoa == "function" ? (E2 = function(M2) {
                var W2 = document.createElement("link");
                return M2.attrs.type === void 0 && (M2.attrs.type = "text/css"), M2.attrs.rel = "stylesheet", y2(W2, M2.attrs), A2(M2, W2), W2;
              }(g2), T2 = (function(M2, W2, de2) {
                var Q2 = de2.css, Ee2 = de2.sourceMap, Mt = W2.convertToAbsoluteUrls === void 0 && Ee2;
                (W2.convertToAbsoluteUrls || Mt) && (Q2 = k2(Q2)), Ee2 && (Q2 += `
/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(Ee2)))) + " */");
                var Lt = new Blob([Q2], { type: "text/css" }), Ve2 = M2.href;
                M2.href = URL.createObjectURL(Lt), Ve2 && URL.revokeObjectURL(Ve2);
              }).bind(null, E2, g2), O2 = function() {
                N2(E2), E2.href && URL.revokeObjectURL(E2.href);
              }) : (E2 = _2(g2), T2 = (function(M2, W2) {
                var de2 = W2.css, Q2 = W2.media;
                if (Q2 && M2.setAttribute("media", Q2), M2.styleSheet)
                  M2.styleSheet.cssText = de2;
                else {
                  for (; M2.firstChild; )
                    M2.removeChild(M2.firstChild);
                  M2.appendChild(document.createTextNode(de2));
                }
              }).bind(null, E2), O2 = function() {
                N2(E2);
              });
            return T2(b2), function(M2) {
              if (M2) {
                if (M2.css === b2.css && M2.media === b2.media && M2.sourceMap === b2.sourceMap)
                  return;
                T2(b2 = M2);
              } else
                O2();
            };
          }
          t2.exports = function(b2, g2) {
            if (typeof DEBUG < "u" && DEBUG && typeof document != "object")
              throw new Error("The style-loader cannot be used in a non-browser environment");
            (g2 = g2 || {}).attrs = typeof g2.attrs == "object" ? g2.attrs : {}, g2.singleton || typeof g2.singleton == "boolean" || (g2.singleton = l2()), g2.insertInto || (g2.insertInto = "head"), g2.insertAt || (g2.insertAt = "bottom");
            var E2 = v2(b2, g2);
            return p2(E2, g2), function(T2) {
              for (var O2 = [], S2 = 0; S2 < E2.length; S2++) {
                var H2 = E2[S2];
                (M2 = a2[H2.id]).refs--, O2.push(M2);
              }
              for (T2 && p2(v2(T2, g2), g2), S2 = 0; S2 < O2.length; S2++) {
                var M2;
                if ((M2 = O2[S2]).refs === 0) {
                  for (var W2 = 0; W2 < M2.parts.length; W2++)
                    M2.parts[W2]();
                  delete a2[M2.id];
                }
              }
            };
          };
          var w2, I2 = (w2 = [], function(b2, g2) {
            return w2[b2] = g2, w2.filter(Boolean).join(`
`);
          });
          function R2(b2, g2, E2, T2) {
            var O2 = E2 ? "" : T2.css;
            if (b2.styleSheet)
              b2.styleSheet.cssText = I2(g2, O2);
            else {
              var S2 = document.createTextNode(O2), H2 = b2.childNodes;
              H2[g2] && b2.removeChild(H2[g2]), H2.length ? b2.insertBefore(S2, H2[g2]) : b2.appendChild(S2);
            }
          }
        }, function(t2, o2) {
          t2.exports = function(i2) {
            var n2 = typeof window < "u" && window.location;
            if (!n2)
              throw new Error("fixUrls requires window.location");
            if (!i2 || typeof i2 != "string")
              return i2;
            var r2 = n2.protocol + "//" + n2.host, a2 = r2 + n2.pathname.replace(/\/[^\/]*$/, "/");
            return i2.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(l2, c2) {
              var u2, h2 = c2.trim().replace(/^"(.*)"$/, function(f2, k2) {
                return k2;
              }).replace(/^'(.*)'$/, function(f2, k2) {
                return k2;
              });
              return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(h2) ? l2 : (u2 = h2.indexOf("//") === 0 ? h2 : h2.indexOf("/") === 0 ? r2 + h2 : a2 + h2.replace(/^\.\//, ""), "url(" + JSON.stringify(u2) + ")");
            });
          };
        }, function(t2, o2, i2) {
          var n2, r2, a2, l2, c2, u2, h2, f2, k2;
          t2.exports = (n2 = "cdx-notifies", r2 = "cdx-notify", a2 = "cdx-notify__cross", l2 = "cdx-notify__button--confirm", c2 = "cdx-notify__button--cancel", u2 = "cdx-notify__input", h2 = "cdx-notify__button", f2 = "cdx-notify__btns-wrapper", { alert: k2 = function(p2) {
            var v2 = document.createElement("DIV"), A2 = document.createElement("DIV"), N2 = p2.message, _2 = p2.style;
            return v2.classList.add(r2), _2 && v2.classList.add(r2 + "--" + _2), v2.innerHTML = N2, A2.classList.add(a2), A2.addEventListener("click", v2.remove.bind(v2)), v2.appendChild(A2), v2;
          }, confirm: function(p2) {
            var v2 = k2(p2), A2 = document.createElement("div"), N2 = document.createElement("button"), _2 = document.createElement("button"), y2 = v2.querySelector("." + a2), x2 = p2.cancelHandler, w2 = p2.okHandler;
            return A2.classList.add(f2), N2.innerHTML = p2.okText || "Confirm", _2.innerHTML = p2.cancelText || "Cancel", N2.classList.add(h2), _2.classList.add(h2), N2.classList.add(l2), _2.classList.add(c2), x2 && typeof x2 == "function" && (_2.addEventListener("click", x2), y2.addEventListener("click", x2)), w2 && typeof w2 == "function" && N2.addEventListener("click", w2), N2.addEventListener("click", v2.remove.bind(v2)), _2.addEventListener("click", v2.remove.bind(v2)), A2.appendChild(N2), A2.appendChild(_2), v2.appendChild(A2), v2;
          }, prompt: function(p2) {
            var v2 = k2(p2), A2 = document.createElement("div"), N2 = document.createElement("button"), _2 = document.createElement("input"), y2 = v2.querySelector("." + a2), x2 = p2.cancelHandler, w2 = p2.okHandler;
            return A2.classList.add(f2), N2.innerHTML = p2.okText || "Ok", N2.classList.add(h2), N2.classList.add(l2), _2.classList.add(u2), p2.placeholder && _2.setAttribute("placeholder", p2.placeholder), p2.default && (_2.value = p2.default), p2.inputType && (_2.type = p2.inputType), x2 && typeof x2 == "function" && y2.addEventListener("click", x2), w2 && typeof w2 == "function" && N2.addEventListener("click", function() {
              w2(_2.value);
            }), N2.addEventListener("click", v2.remove.bind(v2)), A2.appendChild(_2), A2.appendChild(N2), v2.appendChild(A2), v2;
          }, getWrapper: function() {
            var p2 = document.createElement("DIV");
            return p2.classList.add(n2), p2;
          } });
        }]);
      });
    })(so);
    const ro = /* @__PURE__ */ xe(Le);
    class ao {
      /**
       * Show web notification
       *
       * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options
       */
      show(e2) {
        ro.show(e2);
      }
    }
    class lo extends C {
      /**
       * @param moduleConfiguration - Module Configuration
       * @param moduleConfiguration.config - Editor's config
       * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
       */
      constructor({ config: e2, eventsDispatcher: t2 }) {
        super({
          config: e2,
          eventsDispatcher: t2
        }), this.notifier = new ao();
      }
      /**
       * Available methods
       */
      get methods() {
        return {
          show: (e2) => this.show(e2)
        };
      }
      /**
       * Show notification
       *
       * @param {NotifierOptions} options - message option
       */
      show(e2) {
        return this.notifier.show(e2);
      }
    }
    class co extends C {
      /**
       * Available methods
       */
      get methods() {
        const e2 = () => this.isEnabled;
        return {
          toggle: (t2) => this.toggle(t2),
          get isEnabled() {
            return e2();
          }
        };
      }
      /**
       * Set or toggle read-only state
       *
       * @param {boolean|undefined} state - set or toggle state
       * @returns {boolean} current value
       */
      toggle(e2) {
        return this.Editor.ReadOnly.toggle(e2);
      }
      /**
       * Returns current read-only state
       */
      get isEnabled() {
        return this.Editor.ReadOnly.isEnabled;
      }
    }
    var Oe = {}, ho = {
      get exports() {
        return Oe;
      },
      set exports(s2) {
        Oe = s2;
      }
    };
    (function(s2, e2) {
      (function(t2, o2) {
        s2.exports = o2();
      })(Ot, function() {
        function t2(h2) {
          var f2 = h2.tags, k2 = Object.keys(f2), p2 = k2.map(function(v2) {
            return typeof f2[v2];
          }).every(function(v2) {
            return v2 === "object" || v2 === "boolean" || v2 === "function";
          });
          if (!p2)
            throw new Error("The configuration was invalid");
          this.config = h2;
        }
        var o2 = ["P", "LI", "TD", "TH", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "PRE"];
        function i2(h2) {
          return o2.indexOf(h2.nodeName) !== -1;
        }
        var n2 = ["A", "B", "STRONG", "I", "EM", "SUB", "SUP", "U", "STRIKE"];
        function r2(h2) {
          return n2.indexOf(h2.nodeName) !== -1;
        }
        t2.prototype.clean = function(h2) {
          const f2 = document.implementation.createHTMLDocument(), k2 = f2.createElement("div");
          return k2.innerHTML = h2, this._sanitize(f2, k2), k2.innerHTML;
        }, t2.prototype._sanitize = function(h2, f2) {
          var k2 = a2(h2, f2), p2 = k2.firstChild();
          if (p2)
            do {
              if (p2.nodeType === Node.TEXT_NODE)
                if (p2.data.trim() === "" && (p2.previousElementSibling && i2(p2.previousElementSibling) || p2.nextElementSibling && i2(p2.nextElementSibling))) {
                  f2.removeChild(p2), this._sanitize(h2, f2);
                  break;
                } else
                  continue;
              if (p2.nodeType === Node.COMMENT_NODE) {
                f2.removeChild(p2), this._sanitize(h2, f2);
                break;
              }
              var v2 = r2(p2), A2;
              v2 && (A2 = Array.prototype.some.call(p2.childNodes, i2));
              var N2 = !!f2.parentNode, _2 = i2(f2) && i2(p2) && N2, y2 = p2.nodeName.toLowerCase(), x2 = l2(this.config, y2, p2), w2 = v2 && A2;
              if (w2 || c2(p2, x2) || !this.config.keepNestedBlockElements && _2) {
                if (!(p2.nodeName === "SCRIPT" || p2.nodeName === "STYLE"))
                  for (; p2.childNodes.length > 0; )
                    f2.insertBefore(p2.childNodes[0], p2);
                f2.removeChild(p2), this._sanitize(h2, f2);
                break;
              }
              for (var I2 = 0; I2 < p2.attributes.length; I2 += 1) {
                var R2 = p2.attributes[I2];
                u2(R2, x2, p2) && (p2.removeAttribute(R2.name), I2 = I2 - 1);
              }
              this._sanitize(h2, p2);
            } while (p2 = k2.nextSibling());
        };
        function a2(h2, f2) {
          return h2.createTreeWalker(
            f2,
            NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,
            null,
            false
          );
        }
        function l2(h2, f2, k2) {
          return typeof h2.tags[f2] == "function" ? h2.tags[f2](k2) : h2.tags[f2];
        }
        function c2(h2, f2) {
          return typeof f2 > "u" ? true : typeof f2 == "boolean" ? !f2 : false;
        }
        function u2(h2, f2, k2) {
          var p2 = h2.name.toLowerCase();
          return f2 === true ? false : typeof f2[p2] == "function" ? !f2[p2](h2.value, k2) : typeof f2[p2] > "u" || f2[p2] === false ? true : typeof f2[p2] == "string" ? f2[p2] !== h2.value : false;
        }
        return t2;
      });
    })(ho);
    const uo = Oe;
    function ut(s2, e2) {
      return s2.map((t2) => {
        const o2 = D$1(e2) ? e2(t2.tool) : e2;
        return V(o2) || (t2.data = Fe(t2.data, o2)), t2;
      });
    }
    function Z(s2, e2 = {}) {
      const t2 = {
        tags: e2
      };
      return new uo(t2).clean(s2);
    }
    function Fe(s2, e2) {
      return Array.isArray(s2) ? po(s2, e2) : z(s2) ? fo(s2, e2) : J(s2) ? go(s2, e2) : s2;
    }
    function po(s2, e2) {
      return s2.map((t2) => Fe(t2, e2));
    }
    function fo(s2, e2) {
      const t2 = {};
      for (const o2 in s2) {
        if (!Object.prototype.hasOwnProperty.call(s2, o2))
          continue;
        const i2 = s2[o2], n2 = bo(e2[o2]) ? e2[o2] : e2;
        t2[o2] = Fe(i2, n2);
      }
      return t2;
    }
    function go(s2, e2) {
      return z(e2) ? Z(s2, e2) : e2 === false ? Z(s2, {}) : s2;
    }
    function bo(s2) {
      return z(s2) || Rt(s2) || D$1(s2);
    }
    class mo extends C {
      /**
       * Available methods
       *
       * @returns {SanitizerConfig}
       */
      get methods() {
        return {
          clean: (e2, t2) => this.clean(e2, t2)
        };
      }
      /**
       * Perform sanitizing of a string
       *
       * @param {string} taintString - what to sanitize
       * @param {SanitizerConfig} config - sanitizer config
       * @returns {string}
       */
      clean(e2, t2) {
        return Z(e2, t2);
      }
    }
    class ko extends C {
      /**
       * Available methods
       *
       * @returns {Saver}
       */
      get methods() {
        return {
          save: () => this.save()
        };
      }
      /**
       * Return Editor's data
       *
       * @returns {OutputData}
       */
      save() {
        const e2 = "Editor's content can not be saved in read-only mode";
        return this.Editor.ReadOnly.isEnabled ? (K(e2, "warn"), Promise.reject(new Error(e2))) : this.Editor.Saver.save();
      }
    }
    class vo extends C {
      /**
       * Available methods
       *
       * @returns {SelectionAPIInterface}
       */
      get methods() {
        return {
          findParentTag: (e2, t2) => this.findParentTag(e2, t2),
          expandToTag: (e2) => this.expandToTag(e2)
        };
      }
      /**
       * Looks ahead from selection and find passed tag with class name
       *
       * @param {string} tagName - tag to find
       * @param {string} className - tag's class name
       * @returns {HTMLElement|null}
       */
      findParentTag(e2, t2) {
        return new m$1().findParentTag(e2, t2);
      }
      /**
       * Expand selection to passed tag
       *
       * @param {HTMLElement} node - tag that should contain selection
       */
      expandToTag(e2) {
        new m$1().expandToTag(e2);
      }
    }
    class xo extends C {
      /**
       * Exported classes
       */
      get classes() {
        return {
          /**
           * Base Block styles
           */
          block: "cdx-block",
          /**
           * Inline Tools styles
           */
          inlineToolButton: "ce-inline-tool",
          inlineToolButtonActive: "ce-inline-tool--active",
          /**
           * UI elements
           */
          input: "cdx-input",
          loader: "cdx-loader",
          button: "cdx-button",
          /**
           * Settings styles
           */
          settingsButton: "cdx-settings-button",
          settingsButtonActive: "cdx-settings-button--active"
        };
      }
    }
    class wo extends C {
      /**
       * Available methods
       *
       * @returns {Toolbar}
       */
      get methods() {
        return {
          close: () => this.close(),
          open: () => this.open(),
          toggleBlockSettings: (e2) => this.toggleBlockSettings(e2),
          toggleToolbox: (e2) => this.toggleToolbox(e2)
        };
      }
      /**
       * Open toolbar
       */
      open() {
        this.Editor.Toolbar.moveAndOpen();
      }
      /**
       * Close toolbar and all included elements
       */
      close() {
        this.Editor.Toolbar.close();
      }
      /**
       * Toggles Block Setting of the current block
       *
       * @param {boolean} openingState   opening state of Block Setting
       */
      toggleBlockSettings(e2) {
        if (this.Editor.BlockManager.currentBlockIndex === -1) {
          K("Could't toggle the Toolbar because there is no block selected ", "warn");
          return;
        }
        e2 ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();
      }
      /**
       * Open toolbox
       *
       * @param {boolean} openingState - Opening state of toolbox
       */
      toggleToolbox(e2) {
        if (this.Editor.BlockManager.currentBlockIndex === -1) {
          K("Could't toggle the Toolbox because there is no block selected ", "warn");
          return;
        }
        e2 ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();
      }
    }
    var Ae = {}, yo = {
      get exports() {
        return Ae;
      },
      set exports(s2) {
        Ae = s2;
      }
    };
    /*!
     * CodeX.Tooltips
     * 
     * @version 1.0.5
     * 
     * @licence MIT
     * @author CodeX <https://codex.so>
     * 
     * 
     */
    (function(s2, e2) {
      (function(t2, o2) {
        s2.exports = o2();
      })(window, function() {
        return function(t2) {
          var o2 = {};
          function i2(n2) {
            if (o2[n2])
              return o2[n2].exports;
            var r2 = o2[n2] = { i: n2, l: false, exports: {} };
            return t2[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
          }
          return i2.m = t2, i2.c = o2, i2.d = function(n2, r2, a2) {
            i2.o(n2, r2) || Object.defineProperty(n2, r2, { enumerable: true, get: a2 });
          }, i2.r = function(n2) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
          }, i2.t = function(n2, r2) {
            if (1 & r2 && (n2 = i2(n2)), 8 & r2 || 4 & r2 && typeof n2 == "object" && n2 && n2.__esModule)
              return n2;
            var a2 = /* @__PURE__ */ Object.create(null);
            if (i2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: n2 }), 2 & r2 && typeof n2 != "string")
              for (var l2 in n2)
                i2.d(a2, l2, (function(c2) {
                  return n2[c2];
                }).bind(null, l2));
            return a2;
          }, i2.n = function(n2) {
            var r2 = n2 && n2.__esModule ? function() {
              return n2.default;
            } : function() {
              return n2;
            };
            return i2.d(r2, "a", r2), r2;
          }, i2.o = function(n2, r2) {
            return Object.prototype.hasOwnProperty.call(n2, r2);
          }, i2.p = "", i2(i2.s = 0);
        }([function(t2, o2, i2) {
          t2.exports = i2(1);
        }, function(t2, o2, i2) {
          i2.r(o2), i2.d(o2, "default", function() {
            return n2;
          });
          class n2 {
            constructor() {
              this.nodes = { wrapper: null, content: null }, this.showed = false, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {
                this.showed && this.hide(true);
              }, this.loadStyles(), this.prepare(), window.addEventListener("scroll", this.handleWindowScroll, { passive: true });
            }
            get CSS() {
              return { tooltip: "ct", tooltipContent: "ct__content", tooltipShown: "ct--shown", placement: { left: "ct--left", bottom: "ct--bottom", right: "ct--right", top: "ct--top" } };
            }
            show(a2, l2, c2) {
              this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);
              const u2 = Object.assign({ placement: "bottom", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, c2);
              if (u2.hidingDelay && (this.hidingDelay = u2.hidingDelay), this.nodes.content.innerHTML = "", typeof l2 == "string")
                this.nodes.content.appendChild(document.createTextNode(l2));
              else {
                if (!(l2 instanceof Node))
                  throw Error("[CodeX Tooltip] Wrong type of content passed. It should be an instance of Node or String. But " + typeof l2 + " given.");
                this.nodes.content.appendChild(l2);
              }
              switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u2.placement) {
                case "top":
                  this.placeTop(a2, u2);
                  break;
                case "left":
                  this.placeLeft(a2, u2);
                  break;
                case "right":
                  this.placeRight(a2, u2);
                  break;
                case "bottom":
                default:
                  this.placeBottom(a2, u2);
              }
              u2 && u2.delay ? this.showingTimeout = setTimeout(() => {
                this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true;
              }, u2.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true);
            }
            hide(a2 = false) {
              if (this.hidingDelay && !a2)
                return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {
                  this.hide(true);
                }, this.hidingDelay));
              this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = false, this.showingTimeout && clearTimeout(this.showingTimeout);
            }
            onHover(a2, l2, c2) {
              a2.addEventListener("mouseenter", () => {
                this.show(a2, l2, c2);
              }), a2.addEventListener("mouseleave", () => {
                this.hide();
              });
            }
            destroy() {
              this.nodes.wrapper.remove(), window.removeEventListener("scroll", this.handleWindowScroll);
            }
            prepare() {
              this.nodes.wrapper = this.make("div", this.CSS.tooltip), this.nodes.content = this.make("div", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);
            }
            loadStyles() {
              const a2 = "codex-tooltips-style";
              if (document.getElementById(a2))
                return;
              const l2 = i2(2), c2 = this.make("style", null, { textContent: l2.toString(), id: a2 });
              this.prepend(document.head, c2);
            }
            placeBottom(a2, l2) {
              const c2 = a2.getBoundingClientRect(), u2 = c2.left + a2.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h2 = c2.bottom + window.pageYOffset + this.offsetTop + l2.marginTop;
              this.applyPlacement("bottom", u2, h2);
            }
            placeTop(a2, l2) {
              const c2 = a2.getBoundingClientRect(), u2 = c2.left + a2.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h2 = c2.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;
              this.applyPlacement("top", u2, h2);
            }
            placeLeft(a2, l2) {
              const c2 = a2.getBoundingClientRect(), u2 = c2.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l2.marginLeft, h2 = c2.top + window.pageYOffset + a2.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
              this.applyPlacement("left", u2, h2);
            }
            placeRight(a2, l2) {
              const c2 = a2.getBoundingClientRect(), u2 = c2.right + this.offsetRight + l2.marginRight, h2 = c2.top + window.pageYOffset + a2.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
              this.applyPlacement("right", u2, h2);
            }
            applyPlacement(a2, l2, c2) {
              this.nodes.wrapper.classList.add(this.CSS.placement[a2]), this.nodes.wrapper.style.left = l2 + "px", this.nodes.wrapper.style.top = c2 + "px";
            }
            make(a2, l2 = null, c2 = {}) {
              const u2 = document.createElement(a2);
              Array.isArray(l2) ? u2.classList.add(...l2) : l2 && u2.classList.add(l2);
              for (const h2 in c2)
                c2.hasOwnProperty(h2) && (u2[h2] = c2[h2]);
              return u2;
            }
            append(a2, l2) {
              Array.isArray(l2) ? l2.forEach((c2) => a2.appendChild(c2)) : a2.appendChild(l2);
            }
            prepend(a2, l2) {
              Array.isArray(l2) ? (l2 = l2.reverse()).forEach((c2) => a2.prepend(c2)) : a2.prepend(l2);
            }
          }
        }, function(t2, o2) {
          t2.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:"";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url("")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:"";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;
        }]).default;
      });
    })(yo);
    const Eo = /* @__PURE__ */ xe(Ae);
    class He {
      constructor() {
        this.lib = new Eo();
      }
      /**
       * Release the library
       */
      destroy() {
        this.lib.destroy();
      }
      /**
       * Shows tooltip on element with passed HTML content
       *
       * @param {HTMLElement} element - any HTML element in DOM
       * @param content - tooltip's content
       * @param options - showing settings
       */
      show(e2, t2, o2) {
        this.lib.show(e2, t2, o2);
      }
      /**
       * Hides tooltip
       *
       * @param skipHidingDelay  pass true to immediately hide the tooltip
       */
      hide(e2 = false) {
        this.lib.hide(e2);
      }
      /**
       * Binds 'mouseenter' and 'mouseleave' events that shows/hides the Tooltip
       *
       * @param {HTMLElement} element - any HTML element in DOM
       * @param content - tooltip's content
       * @param options - showing settings
       */
      onHover(e2, t2, o2) {
        this.lib.onHover(e2, t2, o2);
      }
    }
    class Bo extends C {
      /**
       * @class
       * @param moduleConfiguration - Module Configuration
       * @param moduleConfiguration.config - Editor's config
       * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
       */
      constructor({ config: e2, eventsDispatcher: t2 }) {
        super({
          config: e2,
          eventsDispatcher: t2
        }), this.tooltip = new He();
      }
      /**
       * Destroy Module
       */
      destroy() {
        this.tooltip.destroy();
      }
      /**
       * Available methods
       */
      get methods() {
        return {
          show: (e2, t2, o2) => this.show(e2, t2, o2),
          hide: () => this.hide(),
          onHover: (e2, t2, o2) => this.onHover(e2, t2, o2)
        };
      }
      /**
       * Method show tooltip on element with passed HTML content
       *
       * @param {HTMLElement} element - element on which tooltip should be shown
       * @param {TooltipContent} content - tooltip content
       * @param {TooltipOptions} options - tooltip options
       */
      show(e2, t2, o2) {
        this.tooltip.show(e2, t2, o2);
      }
      /**
       * Method hides tooltip on HTML page
       */
      hide() {
        this.tooltip.hide();
      }
      /**
       * Decorator for showing Tooltip by mouseenter/mouseleave
       *
       * @param {HTMLElement} element - element on which tooltip should be shown
       * @param {TooltipContent} content - tooltip content
       * @param {TooltipOptions} options - tooltip options
       */
      onHover(e2, t2, o2) {
        this.tooltip.onHover(e2, t2, o2);
      }
    }
    class To extends C {
      /**
       * Available methods / getters
       */
      get methods() {
        return {
          nodes: this.editorNodes
          /**
           * There can be added some UI methods, like toggleThinMode() etc
           */
        };
      }
      /**
       * Exported classes
       */
      get editorNodes() {
        return {
          /**
           * Top-level editor instance wrapper
           */
          wrapper: this.Editor.UI.nodes.wrapper,
          /**
           * Element that holds all the Blocks
           */
          redactor: this.Editor.UI.nodes.redactor
        };
      }
    }
    function pt(s2, e2) {
      const t2 = {};
      return Object.entries(s2).forEach(([o2, i2]) => {
        if (z(i2)) {
          const n2 = e2 ? `${e2}.${o2}` : o2;
          Object.values(i2).every((a2) => J(a2)) ? t2[o2] = n2 : t2[o2] = pt(i2, n2);
          return;
        }
        t2[o2] = i2;
      }), t2;
    }
    const X = pt(at);
    function Co(s2, e2) {
      const t2 = {};
      return Object.keys(s2).forEach((o2) => {
        const i2 = e2[o2];
        i2 !== void 0 ? t2[i2] = s2[o2] : t2[o2] = s2[o2];
      }), t2;
    }
    const So = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11"/></svg>', ft = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10"/></svg>', Io = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15"/></svg>', Mo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16"/></svg>', Lo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="2"/></svg>', Oo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M13.34 10C12.4223 12.7337 11 17 11 17"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.21 7H14.2"/></svg>', Qe = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72"/></svg>', Ao = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 7.29999H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 7.29999H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.30999 12H9.3"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 12H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 16.7H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 16.7H14.59"/></svg>', _o = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 7V12M12 17V12M17 12H12M12 12H7"/></svg>', No = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="10.5" cy="10.5" r="5.5" stroke="currentColor" stroke-width="2"/><line x1="15.4142" x2="19" y1="15" y2="18.5858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>', Ro = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397"/><line x1="12.1142" x2="11.7" y1="12.2" y2="11.7858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>', Do = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><line x1="12" x2="12" y1="9" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 15.02V15.01"/></svg>';
    let P$1 = class P2 {
      /**
       * Constructs popover item instance
       *
       * @param params - popover item construction params
       */
      constructor(e2) {
        this.nodes = {
          root: null,
          icon: null
        }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {
          this.nodes.root.classList.remove(P2.CSS.noFocus);
        }, this.removeSpecialHoverBehavior = () => {
          this.nodes.root.classList.remove(P2.CSS.noHover);
        }, this.onErrorAnimationEnd = () => {
          this.nodes.icon.classList.remove(P2.CSS.wobbleAnimation), this.nodes.icon.removeEventListener("animationend", this.onErrorAnimationEnd);
        }, this.params = e2, this.nodes.root = this.make(e2);
      }
      /**
       * True if item is disabled and hence not clickable
       */
      get isDisabled() {
        return this.params.isDisabled;
      }
      /**
       * Exposes popover item toggle parameter
       */
      get toggle() {
        return this.params.toggle;
      }
      /**
       * Item title
       */
      get title() {
        return this.params.title;
      }
      /**
       * True if popover should close once item is activated
       */
      get closeOnActivate() {
        return this.params.closeOnActivate;
      }
      /**
       * True if confirmation state is enabled for popover item
       */
      get isConfirmationStateEnabled() {
        return this.confirmationState !== null;
      }
      /**
       * True if item is focused in keyboard navigation process
       */
      get isFocused() {
        return this.nodes.root.classList.contains(P2.CSS.focused);
      }
      /**
       * Popover item CSS classes
       */
      static get CSS() {
        return {
          container: "ce-popover-item",
          title: "ce-popover-item__title",
          secondaryTitle: "ce-popover-item__secondary-title",
          icon: "ce-popover-item__icon",
          active: "ce-popover-item--active",
          disabled: "ce-popover-item--disabled",
          focused: "ce-popover-item--focused",
          hidden: "ce-popover-item--hidden",
          confirmationState: "ce-popover-item--confirmation",
          noHover: "ce-popover-item--no-hover",
          noFocus: "ce-popover-item--no-focus",
          wobbleAnimation: "wobble"
        };
      }
      /**
       * Returns popover item root element
       */
      getElement() {
        return this.nodes.root;
      }
      /**
       * Called on popover item click
       */
      handleClick() {
        if (this.isConfirmationStateEnabled) {
          this.activateOrEnableConfirmationMode(this.confirmationState);
          return;
        }
        this.activateOrEnableConfirmationMode(this.params);
      }
      /**
       * Toggles item active state
       *
       * @param isActive - true if item should strictly should become active
       */
      toggleActive(e2) {
        this.nodes.root.classList.toggle(P2.CSS.active, e2);
      }
      /**
       * Toggles item hidden state
       *
       * @param isHidden - true if item should be hidden
       */
      toggleHidden(e2) {
        this.nodes.root.classList.toggle(P2.CSS.hidden, e2);
      }
      /**
       * Resets popover item to its original state
       */
      reset() {
        this.isConfirmationStateEnabled && this.disableConfirmationMode();
      }
      /**
       * Method called once item becomes focused during keyboard navigation
       */
      onFocus() {
        this.disableSpecialHoverAndFocusBehavior();
      }
      /**
       * Constructs HTML element corresponding to popover item params
       *
       * @param params - item construction params
       */
      make(e2) {
        const t2 = d$1.make("div", P2.CSS.container);
        return e2.name && (t2.dataset.itemName = e2.name), this.nodes.icon = d$1.make("div", P2.CSS.icon, {
          innerHTML: e2.icon || Lo
        }), t2.appendChild(this.nodes.icon), t2.appendChild(d$1.make("div", P2.CSS.title, {
          innerHTML: e2.title || ""
        })), e2.secondaryLabel && t2.appendChild(d$1.make("div", P2.CSS.secondaryTitle, {
          textContent: e2.secondaryLabel
        })), e2.isActive && t2.classList.add(P2.CSS.active), e2.isDisabled && t2.classList.add(P2.CSS.disabled), t2;
      }
      /**
       * Activates confirmation mode for the item.
       *
       * @param newState - new popover item params that should be applied
       */
      enableConfirmationMode(e2) {
        const t2 = {
          ...this.params,
          ...e2,
          confirmation: e2.confirmation
        }, o2 = this.make(t2);
        this.nodes.root.innerHTML = o2.innerHTML, this.nodes.root.classList.add(P2.CSS.confirmationState), this.confirmationState = e2, this.enableSpecialHoverAndFocusBehavior();
      }
      /**
       * Returns item to its original state
       */
      disableConfirmationMode() {
        const e2 = this.make(this.params);
        this.nodes.root.innerHTML = e2.innerHTML, this.nodes.root.classList.remove(P2.CSS.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();
      }
      /**
       * Enables special focus and hover behavior for item in confirmation state.
       * This is needed to prevent item from being highlighted as hovered/focused just after click.
       */
      enableSpecialHoverAndFocusBehavior() {
        this.nodes.root.classList.add(P2.CSS.noHover), this.nodes.root.classList.add(P2.CSS.noFocus), this.nodes.root.addEventListener("mouseleave", this.removeSpecialHoverBehavior, { once: true });
      }
      /**
       * Disables special focus and hover behavior
       */
      disableSpecialHoverAndFocusBehavior() {
        this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), this.nodes.root.removeEventListener("mouseleave", this.removeSpecialHoverBehavior);
      }
      /**
       * Executes item's onActivate callback if the item has no confirmation configured
       *
       * @param item - item to activate or bring to confirmation mode
       */
      activateOrEnableConfirmationMode(e2) {
        if (e2.confirmation === void 0)
          try {
            e2.onActivate(e2), this.disableConfirmationMode();
          } catch {
            this.animateError();
          }
        else
          this.enableConfirmationMode(e2.confirmation);
      }
      /**
       * Animates item which symbolizes that error occured while executing 'onActivate()' callback
       */
      animateError() {
        this.nodes.icon.classList.contains(P2.CSS.wobbleAnimation) || (this.nodes.icon.classList.add(P2.CSS.wobbleAnimation), this.nodes.icon.addEventListener("animationend", this.onErrorAnimationEnd));
      }
    };
    const he = class {
      /**
       * @param {HTMLElement[]} nodeList  the list of iterable HTML-items
       * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process
       */
      constructor(s2, e2) {
        this.cursor = -1, this.items = [], this.items = s2 || [], this.focusedCssClass = e2;
      }
      /**
       * Returns Focused button Node
       *
       * @returns {HTMLElement}
       */
      get currentItem() {
        return this.cursor === -1 ? null : this.items[this.cursor];
      }
      /**
       * Sets cursor to specified position
       *
       * @param cursorPosition - new cursor position
       */
      setCursor(s2) {
        s2 < this.items.length && s2 >= -1 && (this.dropCursor(), this.cursor = s2, this.items[this.cursor].classList.add(this.focusedCssClass));
      }
      /**
       * Sets items. Can be used when iterable items changed dynamically
       *
       * @param {HTMLElement[]} nodeList - nodes to iterate
       */
      setItems(s2) {
        this.items = s2;
      }
      /**
       * Sets cursor next to the current
       */
      next() {
        this.cursor = this.leafNodesAndReturnIndex(he.directions.RIGHT);
      }
      /**
       * Sets cursor before current
       */
      previous() {
        this.cursor = this.leafNodesAndReturnIndex(he.directions.LEFT);
      }
      /**
       * Sets cursor to the default position and removes CSS-class from previously focused item
       */
      dropCursor() {
        this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);
      }
      /**
       * Leafs nodes inside the target list from active element
       *
       * @param {string} direction - leaf direction. Can be 'left' or 'right'
       * @returns {number} index of focused node
       */
      leafNodesAndReturnIndex(s2) {
        if (this.items.length === 0)
          return this.cursor;
        let e2 = this.cursor;
        return e2 === -1 ? e2 = s2 === he.directions.RIGHT ? -1 : 0 : this.items[e2].classList.remove(this.focusedCssClass), s2 === he.directions.RIGHT ? e2 = (e2 + 1) % this.items.length : e2 = (this.items.length + e2 - 1) % this.items.length, d$1.canSetCaret(this.items[e2]) && re(() => m$1.setCursor(this.items[e2]), 50)(), this.items[e2].classList.add(this.focusedCssClass), e2;
      }
    };
    let ne = he;
    ne.directions = {
      RIGHT: "right",
      LEFT: "left"
    };
    class G {
      /**
       * @param {FlipperOptions} options - different constructing settings
       */
      constructor(e2) {
        this.iterator = null, this.activated = false, this.flipCallbacks = [], this.onKeyDown = (t2) => {
          if (this.isEventReadyForHandling(t2))
            switch (G.usedKeys.includes(t2.keyCode) && t2.preventDefault(), t2.keyCode) {
              case B$1.TAB:
                this.handleTabPress(t2);
                break;
              case B$1.LEFT:
              case B$1.UP:
                this.flipLeft();
                break;
              case B$1.RIGHT:
              case B$1.DOWN:
                this.flipRight();
                break;
              case B$1.ENTER:
                this.handleEnterPress(t2);
                break;
            }
        }, this.iterator = new ne(e2.items, e2.focusedItemClass), this.activateCallback = e2.activateCallback, this.allowedKeys = e2.allowedKeys || G.usedKeys;
      }
      /**
       * True if flipper is currently activated
       */
      get isActivated() {
        return this.activated;
      }
      /**
       * Array of keys (codes) that is handled by Flipper
       * Used to:
       *  - preventDefault only for this keys, not all keydowns (@see constructor)
       *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)
       */
      static get usedKeys() {
        return [
          B$1.TAB,
          B$1.LEFT,
          B$1.RIGHT,
          B$1.ENTER,
          B$1.UP,
          B$1.DOWN
        ];
      }
      /**
       * Active tab/arrows handling by flipper
       *
       * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically
       * @param cursorPosition - index of the item that should be focused once flipper is activated
       */
      activate(e2, t2) {
        this.activated = true, e2 && this.iterator.setItems(e2), t2 !== void 0 && this.iterator.setCursor(t2), document.addEventListener("keydown", this.onKeyDown, true);
      }
      /**
       * Disable tab/arrows handling by flipper
       */
      deactivate() {
        this.activated = false, this.dropCursor(), document.removeEventListener("keydown", this.onKeyDown);
      }
      /**
       * Focus first item
       */
      focusFirst() {
        this.dropCursor(), this.flipRight();
      }
      /**
       * Focuses previous flipper iterator item
       */
      flipLeft() {
        this.iterator.previous(), this.flipCallback();
      }
      /**
       * Focuses next flipper iterator item
       */
      flipRight() {
        this.iterator.next(), this.flipCallback();
      }
      /**
       * Return true if some button is focused
       */
      hasFocus() {
        return !!this.iterator.currentItem;
      }
      /**
       * Registeres function that should be executed on each navigation action
       *
       * @param cb - function to execute
       */
      onFlip(e2) {
        this.flipCallbacks.push(e2);
      }
      /**
       * Unregisteres function that is executed on each navigation action
       *
       * @param cb - function to stop executing
       */
      removeOnFlip(e2) {
        this.flipCallbacks = this.flipCallbacks.filter((t2) => t2 !== e2);
      }
      /**
       * Drops flipper's iterator cursor
       *
       * @see DomIterator#dropCursor
       */
      dropCursor() {
        this.iterator.dropCursor();
      }
      /**
       * This function is fired before handling flipper keycodes
       * The result of this function defines if it is need to be handled or not
       *
       * @param {KeyboardEvent} event - keydown keyboard event
       * @returns {boolean}
       */
      isEventReadyForHandling(e2) {
        return this.activated && this.allowedKeys.includes(e2.keyCode);
      }
      /**
       * When flipper is activated tab press will leaf the items
       *
       * @param {KeyboardEvent} event - tab keydown event
       */
      handleTabPress(e2) {
        switch (e2.shiftKey ? ne.directions.LEFT : ne.directions.RIGHT) {
          case ne.directions.RIGHT:
            this.flipRight();
            break;
          case ne.directions.LEFT:
            this.flipLeft();
            break;
        }
      }
      /**
       * Enter press will click current item if flipper is activated
       *
       * @param {KeyboardEvent} event - enter keydown event
       */
      handleEnterPress(e2) {
        this.activated && (this.iterator.currentItem && (e2.stopPropagation(), e2.preventDefault(), this.iterator.currentItem.click()), D$1(this.activateCallback) && this.activateCallback(this.iterator.currentItem));
      }
      /**
       * Fired after flipping in any direction
       */
      flipCallback() {
        this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e2) => e2());
      }
    }
    class pe {
      /**
       * Styles
       */
      static get CSS() {
        return {
          wrapper: "cdx-search-field",
          icon: "cdx-search-field__icon",
          input: "cdx-search-field__input"
        };
      }
      /**
       * @param options - available config
       * @param options.items - searchable items list
       * @param options.onSearch - search callback
       * @param options.placeholder - input placeholder
       */
      constructor({ items: e2, onSearch: t2, placeholder: o2 }) {
        this.listeners = new De(), this.items = e2, this.onSearch = t2, this.render(o2);
      }
      /**
       * Returns search field element
       */
      getElement() {
        return this.wrapper;
      }
      /**
       * Sets focus to the input
       */
      focus() {
        this.input.focus();
      }
      /**
       * Clears search query and results
       */
      clear() {
        this.input.value = "", this.searchQuery = "", this.onSearch("", this.foundItems);
      }
      /**
       * Clears memory
       */
      destroy() {
        this.listeners.removeAll();
      }
      /**
       * Creates the search field
       *
       * @param placeholder - input placeholder
       */
      render(e2) {
        this.wrapper = d$1.make("div", pe.CSS.wrapper);
        const t2 = d$1.make("div", pe.CSS.icon, {
          innerHTML: No
        });
        this.input = d$1.make("input", pe.CSS.input, {
          placeholder: e2
        }), this.wrapper.appendChild(t2), this.wrapper.appendChild(this.input), this.listeners.on(this.input, "input", () => {
          this.searchQuery = this.input.value, this.onSearch(this.searchQuery, this.foundItems);
        });
      }
      /**
       * Returns list of found items for the current search query
       */
      get foundItems() {
        return this.items.filter((e2) => this.checkItem(e2));
      }
      /**
       * Contains logic for checking whether passed item conforms the search query
       *
       * @param item - item to be checked
       */
      checkItem(e2) {
        var i2;
        const t2 = ((i2 = e2.title) == null ? void 0 : i2.toLowerCase()) || "", o2 = this.searchQuery.toLowerCase();
        return t2.includes(o2);
      }
    }
    const ue = class {
      /**
       * Locks body element scroll
       */
      lock() {
        Ge ? this.lockHard() : document.body.classList.add(ue.CSS.scrollLocked);
      }
      /**
       * Unlocks body element scroll
       */
      unlock() {
        Ge ? this.unlockHard() : document.body.classList.remove(ue.CSS.scrollLocked);
      }
      /**
       * Locks scroll in a hard way (via setting fixed position to body element)
       */
      lockHard() {
        this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty(
          "--window-scroll-offset",
          `${this.scrollPosition}px`
        ), document.body.classList.add(ue.CSS.scrollLockedHard);
      }
      /**
       * Unlocks hard scroll lock
       */
      unlockHard() {
        document.body.classList.remove(ue.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;
      }
    };
    let gt = ue;
    gt.CSS = {
      scrollLocked: "ce-scroll-locked",
      scrollLockedHard: "ce-scroll-locked--hard"
    };
    var Po = Object.defineProperty, Fo = Object.getOwnPropertyDescriptor, Ho = (s2, e2, t2, o2) => {
      for (var i2 = o2 > 1 ? void 0 : o2 ? Fo(e2, t2) : e2, n2 = s2.length - 1, r2; n2 >= 0; n2--)
        (r2 = s2[n2]) && (i2 = (o2 ? r2(e2, t2, i2) : r2(i2)) || i2);
      return o2 && i2 && Po(e2, t2, i2), i2;
    }, ge = /* @__PURE__ */ ((s2) => (s2.Close = "close", s2))(ge || {});
    const j$1 = class j extends we {
      /**
       * Constructs the instance
       *
       * @param params - popover construction params
       */
      constructor(s2) {
        super(), this.scopeElement = document.body, this.listeners = new De(), this.scrollLocker = new gt(), this.nodes = {
          wrapper: null,
          popover: null,
          nothingFoundMessage: null,
          customContent: null,
          items: null,
          overlay: null
        }, this.messages = {
          nothingFound: "Nothing found",
          search: "Search"
        }, this.onFlip = () => {
          this.items.find((t2) => t2.isFocused).onFocus();
        }, this.items = s2.items.map((e2) => new P$1(e2)), s2.scopeElement !== void 0 && (this.scopeElement = s2.scopeElement), s2.messages && (this.messages = {
          ...this.messages,
          ...s2.messages
        }), s2.customContentFlippableItems && (this.customContentFlippableItems = s2.customContentFlippableItems), this.make(), s2.customContent && this.addCustomContent(s2.customContent), s2.searchable && this.addSearch(), this.initializeFlipper();
      }
      /**
       * Popover CSS classes
       */
      static get CSS() {
        return {
          popover: "ce-popover",
          popoverOpenTop: "ce-popover--open-top",
          popoverOpened: "ce-popover--opened",
          search: "ce-popover__search",
          nothingFoundMessage: "ce-popover__nothing-found-message",
          nothingFoundMessageDisplayed: "ce-popover__nothing-found-message--displayed",
          customContent: "ce-popover__custom-content",
          customContentHidden: "ce-popover__custom-content--hidden",
          items: "ce-popover__items",
          overlay: "ce-popover__overlay",
          overlayHidden: "ce-popover__overlay--hidden"
        };
      }
      /**
       * Returns HTML element corresponding to the popover
       */
      getElement() {
        return this.nodes.wrapper;
      }
      /**
       * Returns true if some item inside popover is focused
       */
      hasFocus() {
        return this.flipper.hasFocus();
      }
      /**
       * Open popover
       */
      show() {
        this.shouldOpenBottom || (this.nodes.popover.style.setProperty("--popover-height", this.height + "px"), this.nodes.popover.classList.add(j$1.CSS.popoverOpenTop)), this.nodes.overlay.classList.remove(j$1.CSS.overlayHidden), this.nodes.popover.classList.add(j$1.CSS.popoverOpened), this.flipper.activate(this.flippableElements), this.search !== void 0 && setTimeout(() => {
          this.search.focus();
        }, 100), te() && this.scrollLocker.lock();
      }
      /**
       * Closes popover
       */
      hide() {
        this.nodes.popover.classList.remove(j$1.CSS.popoverOpened), this.nodes.popover.classList.remove(j$1.CSS.popoverOpenTop), this.nodes.overlay.classList.add(j$1.CSS.overlayHidden), this.flipper.deactivate(), this.items.forEach((s2) => s2.reset()), this.search !== void 0 && this.search.clear(), te() && this.scrollLocker.unlock(), this.emit(
          "close"
          /* Close */
        );
      }
      /**
       * Clears memory
       */
      destroy() {
        this.flipper.deactivate(), this.listeners.removeAll(), te() && this.scrollLocker.unlock();
      }
      /**
       * Constructs HTML element corresponding to popover
       */
      make() {
        this.nodes.popover = d$1.make("div", [j$1.CSS.popover]), this.nodes.nothingFoundMessage = d$1.make("div", [j$1.CSS.nothingFoundMessage], {
          textContent: this.messages.nothingFound
        }), this.nodes.popover.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = d$1.make("div", [j$1.CSS.items]), this.items.forEach((s2) => {
          this.nodes.items.appendChild(s2.getElement());
        }), this.nodes.popover.appendChild(this.nodes.items), this.listeners.on(this.nodes.popover, "click", (s2) => {
          const e2 = this.getTargetItem(s2);
          e2 !== void 0 && this.handleItemClick(e2);
        }), this.nodes.wrapper = d$1.make("div"), this.nodes.overlay = d$1.make("div", [j$1.CSS.overlay, j$1.CSS.overlayHidden]), this.listeners.on(this.nodes.overlay, "click", () => {
          this.hide();
        }), this.nodes.wrapper.appendChild(this.nodes.overlay), this.nodes.wrapper.appendChild(this.nodes.popover);
      }
      /**
       * Adds search to the popover
       */
      addSearch() {
        this.search = new pe({
          items: this.items,
          placeholder: this.messages.search,
          onSearch: (e2, t2) => {
            this.items.forEach((i2) => {
              const n2 = !t2.includes(i2);
              i2.toggleHidden(n2);
            }), this.toggleNothingFoundMessage(t2.length === 0), this.toggleCustomContent(e2 !== "");
            const o2 = e2 === "" ? this.flippableElements : t2.map((i2) => i2.getElement());
            this.flipper.isActivated && (this.flipper.deactivate(), this.flipper.activate(o2));
          }
        });
        const s2 = this.search.getElement();
        s2.classList.add(j$1.CSS.search), this.nodes.popover.insertBefore(s2, this.nodes.popover.firstChild);
      }
      /**
       * Adds custom html content to the popover
       *
       * @param content - html content to append
       */
      addCustomContent(s2) {
        this.nodes.customContent = s2, this.nodes.customContent.classList.add(j$1.CSS.customContent), this.nodes.popover.insertBefore(s2, this.nodes.popover.firstChild);
      }
      /**
       * Retrieves popover item that is the target of the specified event
       *
       * @param event - event to retrieve popover item from
       */
      getTargetItem(s2) {
        return this.items.find((e2) => s2.composedPath().includes(e2.getElement()));
      }
      /**
       * Handles item clicks
       *
       * @param item - item to handle click of
       */
      handleItemClick(s2) {
        s2.isDisabled || (this.items.filter((e2) => e2 !== s2).forEach((e2) => e2.reset()), s2.handleClick(), this.toggleItemActivenessIfNeeded(s2), s2.closeOnActivate && this.hide());
      }
      /**
       * Creates Flipper instance which allows to navigate between popover items via keyboard
       */
      initializeFlipper() {
        this.flipper = new G({
          items: this.flippableElements,
          focusedItemClass: P$1.CSS.focused,
          allowedKeys: [
            B$1.TAB,
            B$1.UP,
            B$1.DOWN,
            B$1.ENTER
          ]
        }), this.flipper.onFlip(this.onFlip);
      }
      /**
       * Returns list of elements available for keyboard navigation.
       * Contains both usual popover items elements and custom html content.
       */
      get flippableElements() {
        const s2 = this.items.map((t2) => t2.getElement());
        return (this.customContentFlippableItems || []).concat(s2);
      }
      get height() {
        let s2 = 0;
        if (this.nodes.popover === null)
          return s2;
        const e2 = this.nodes.popover.cloneNode(true);
        return e2.style.visibility = "hidden", e2.style.position = "absolute", e2.style.top = "-1000px", e2.classList.add(j$1.CSS.popoverOpened), document.body.appendChild(e2), s2 = e2.offsetHeight, e2.remove(), s2;
      }
      /**
       * Checks if popover should be opened bottom.
       * It should happen when there is enough space below or not enough space above
       */
      get shouldOpenBottom() {
        const s2 = this.nodes.popover.getBoundingClientRect(), e2 = this.scopeElement.getBoundingClientRect(), t2 = this.height, o2 = s2.top + t2, i2 = s2.top - t2, n2 = Math.min(window.innerHeight, e2.bottom);
        return i2 < e2.top || o2 <= n2;
      }
      /**
       * Toggles nothing found message visibility
       *
       * @param isDisplayed - true if the message should be displayed
       */
      toggleNothingFoundMessage(s2) {
        this.nodes.nothingFoundMessage.classList.toggle(j$1.CSS.nothingFoundMessageDisplayed, s2);
      }
      /**
       * Toggles custom content visibility
       *
       * @param isDisplayed - true if custom content should be displayed
       */
      toggleCustomContent(s2) {
        var e2;
        (e2 = this.nodes.customContent) == null || e2.classList.toggle(j$1.CSS.customContentHidden, s2);
      }
      /**
       * - Toggles item active state, if clicked popover item has property 'toggle' set to true.
       *
       * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.
       * (All the other items with the same key get inactive, and the item gets active)
       *
       * @param clickedItem - popover item that was clicked
       */
      toggleItemActivenessIfNeeded(s2) {
        if (s2.toggle === true && s2.toggleActive(), typeof s2.toggle == "string") {
          const e2 = this.items.filter((t2) => t2.toggle === s2.toggle);
          if (e2.length === 1) {
            s2.toggleActive();
            return;
          }
          e2.forEach((t2) => {
            t2.toggleActive(t2 === s2);
          });
        }
      }
    };
    let je = j$1;
    Ho([
      ce
    ], je.prototype, "height", 1);
    class jo extends C {
      constructor() {
        super(...arguments), this.opened = false, this.selection = new m$1(), this.onPopoverClose = () => {
          this.close();
        };
      }
      /**
       * Module Events
       *
       * @returns {{opened: string, closed: string}}
       */
      get events() {
        return {
          opened: "block-settings-opened",
          closed: "block-settings-closed"
        };
      }
      /**
       * Block Settings CSS
       */
      get CSS() {
        return {
          settings: "ce-settings"
        };
      }
      /**
       * Getter for inner popover's flipper instance
       *
       * @todo remove once BlockSettings becomes standalone non-module class
       */
      get flipper() {
        var e2;
        return (e2 = this.popover) == null ? void 0 : e2.flipper;
      }
      /**
       * Panel with block settings with 2 sections:
       *  - Tool's Settings
       *  - Default Settings [Move, Remove, etc]
       */
      make() {
        this.nodes.wrapper = d$1.make("div", [this.CSS.settings]);
      }
      /**
       * Destroys module
       */
      destroy() {
        this.removeAllNodes();
      }
      /**
       * Open Block Settings pane
       *
       * @param targetBlock - near which Block we should open BlockSettings
       */
      open(e2 = this.Editor.BlockManager.currentBlock) {
        this.opened = true, this.selection.save(), e2.selected = true, this.Editor.BlockSelection.clearCache();
        const [t2, o2] = e2.getTunes();
        this.eventsDispatcher.emit(this.events.opened), this.popover = new je({
          searchable: true,
          items: t2.map((i2) => this.resolveTuneAliases(i2)),
          customContent: o2,
          customContentFlippableItems: this.getControls(o2),
          scopeElement: this.Editor.API.methods.ui.nodes.redactor,
          messages: {
            nothingFound: $.ui(X.ui.popover, "Nothing found"),
            search: $.ui(X.ui.popover, "Filter")
          }
        }), this.popover.on(ge.Close, this.onPopoverClose), this.nodes.wrapper.append(this.popover.getElement()), this.popover.show();
      }
      /**
       * Returns root block settings element
       */
      getElement() {
        return this.nodes.wrapper;
      }
      /**
       * Close Block Settings pane
       */
      close() {
        this.opened = false, m$1.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && (this.Editor.BlockManager.currentBlock.selected = false), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(ge.Close, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null);
      }
      /**
       * Returns list of buttons and inputs inside specified container
       *
       * @param container - container to query controls inside of
       */
      getControls(e2) {
        const { StylesAPI: t2 } = this.Editor, o2 = e2.querySelectorAll(
          `.${t2.classes.settingsButton}, ${d$1.allInputsSelector}`
        );
        return Array.from(o2);
      }
      /**
       * Resolves aliases in tunes menu items
       *
       * @param item - item with resolved aliases
       */
      resolveTuneAliases(e2) {
        const t2 = Co(e2, { label: "title" });
        return e2.confirmation && (t2.confirmation = this.resolveTuneAliases(e2.confirmation)), t2;
      }
    }
    class Y extends C {
      constructor() {
        super(...arguments), this.opened = false, this.tools = [], this.flipper = null, this.togglingCallback = null;
      }
      /**
       * CSS getter
       */
      static get CSS() {
        return {
          conversionToolbarWrapper: "ce-conversion-toolbar",
          conversionToolbarShowed: "ce-conversion-toolbar--showed",
          conversionToolbarTools: "ce-conversion-toolbar__tools",
          conversionToolbarLabel: "ce-conversion-toolbar__label",
          conversionTool: "ce-conversion-tool",
          conversionToolHidden: "ce-conversion-tool--hidden",
          conversionToolIcon: "ce-conversion-tool__icon",
          conversionToolSecondaryLabel: "ce-conversion-tool__secondary-label",
          conversionToolFocused: "ce-conversion-tool--focused",
          conversionToolActive: "ce-conversion-tool--active"
        };
      }
      /**
       * Create UI of Conversion Toolbar
       */
      make() {
        this.nodes.wrapper = d$1.make("div", [
          Y.CSS.conversionToolbarWrapper,
          ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []
        ]), this.nodes.tools = d$1.make("div", Y.CSS.conversionToolbarTools);
        const e2 = d$1.make("div", Y.CSS.conversionToolbarLabel, {
          textContent: $.ui(X.ui.inlineToolbar.converter, "Convert to")
        });
        return this.addTools(), this.enableFlipper(), d$1.append(this.nodes.wrapper, e2), d$1.append(this.nodes.wrapper, this.nodes.tools), this.nodes.wrapper;
      }
      /**
       * Deactivates flipper and removes all nodes
       */
      destroy() {
        this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();
      }
      /**
       * Toggle conversion dropdown visibility
       *
       * @param {Function} [togglingCallback]  callback that will accept opening state
       */
      toggle(e2) {
        this.opened ? this.close() : this.open(), D$1(e2) && (this.togglingCallback = e2);
      }
      /**
       * Shows Conversion Toolbar
       */
      open() {
        this.filterTools(), this.opened = true, this.nodes.wrapper.classList.add(Y.CSS.conversionToolbarShowed), window.requestAnimationFrame(() => {
          this.flipper.activate(this.tools.map((e2) => e2.button).filter((e2) => !e2.classList.contains(Y.CSS.conversionToolHidden))), this.flipper.focusFirst(), D$1(this.togglingCallback) && this.togglingCallback(true);
        });
      }
      /**
       * Closes Conversion Toolbar
       */
      close() {
        this.opened = false, this.flipper.deactivate(), this.nodes.wrapper.classList.remove(Y.CSS.conversionToolbarShowed), D$1(this.togglingCallback) && this.togglingCallback(false);
      }
      /**
       * Returns true if it has more than one tool available for convert in
       */
      hasTools() {
        return this.tools.length === 1 ? this.tools[0].name !== this.config.defaultBlock : true;
      }
      /**
       * Replaces one Block with another
       * For that Tools must provide import/export methods
       *
       * @param {string} replacingToolName - name of Tool which replaces current
       * @param blockDataOverrides - If this conversion fired by the one of multiple Toolbox items, extend converted data with this item's "data" overrides
       */
      async replaceWithBlock(e2, t2) {
        const { BlockManager: o2, BlockSelection: i2, InlineToolbar: n2, Caret: r2 } = this.Editor;
        o2.convert(this.Editor.BlockManager.currentBlock, e2, t2), i2.clearSelection(), this.close(), n2.close(), window.requestAnimationFrame(() => {
          r2.setToBlock(this.Editor.BlockManager.currentBlock, r2.positions.END);
        });
      }
      /**
       * Iterates existing Tools and inserts to the ConversionToolbar
       * if tools have ability to import
       */
      addTools() {
        const e2 = this.Editor.Tools.blockTools;
        Array.from(e2.entries()).forEach(([t2, o2]) => {
          var n2;
          const i2 = o2.conversionConfig;
          !i2 || !i2.import || (n2 = o2.toolbox) == null || n2.forEach(
            (r2) => this.addToolIfValid(t2, r2)
          );
        });
      }
      /**
       * Inserts a tool to the ConversionToolbar if the tool's toolbox config is valid
       *
       * @param name - tool's name
       * @param toolboxSettings - tool's single toolbox setting
       */
      addToolIfValid(e2, t2) {
        V(t2) || !t2.icon || this.addTool(e2, t2);
      }
      /**
       * Add tool to the Conversion Toolbar
       *
       * @param toolName - name of Tool to add
       * @param toolboxItem - tool's toolbox item data
       */
      addTool(e2, t2) {
        var r2;
        const o2 = d$1.make("div", [Y.CSS.conversionTool]), i2 = d$1.make("div", [Y.CSS.conversionToolIcon]);
        o2.dataset.tool = e2, i2.innerHTML = t2.icon, d$1.append(o2, i2), d$1.append(o2, d$1.text($.t(X.toolNames, t2.title || ae(e2))));
        const n2 = (r2 = this.Editor.Tools.blockTools.get(e2)) == null ? void 0 : r2.shortcut;
        if (n2) {
          const a2 = d$1.make("span", Y.CSS.conversionToolSecondaryLabel, {
            innerText: Re(n2)
          });
          d$1.append(o2, a2);
        }
        d$1.append(this.nodes.tools, o2), this.tools.push({
          name: e2,
          button: o2,
          toolboxItem: t2
        }), this.listeners.on(o2, "click", async () => {
          await this.replaceWithBlock(e2, t2.data);
        });
      }
      /**
       * Hide current Tool and show others
       */
      async filterTools() {
        const { currentBlock: e2 } = this.Editor.BlockManager, t2 = await e2.getActiveToolboxEntry();
        function o2(i2, n2) {
          return i2.icon === n2.icon && i2.title === n2.title;
        }
        this.tools.forEach((i2) => {
          let n2 = false;
          if (t2) {
            const r2 = o2(t2, i2.toolboxItem);
            n2 = i2.button.dataset.tool === e2.name && r2;
          }
          i2.button.hidden = n2, i2.button.classList.toggle(Y.CSS.conversionToolHidden, n2);
        });
      }
      /**
       * Prepare Flipper to be able to leaf tools by arrows/tab
       */
      enableFlipper() {
        this.flipper = new G({
          focusedItemClass: Y.CSS.conversionToolFocused
        });
      }
    }
    var _e = {}, zo = {
      get exports() {
        return _e;
      },
      set exports(s2) {
        _e = s2;
      }
    };
    /*!
     * Library for handling keyboard shortcuts
     * @copyright CodeX (https://codex.so)
     * @license MIT
     * @author CodeX (https://codex.so)
     * @version 1.2.0
     */
    (function(s2, e2) {
      (function(t2, o2) {
        s2.exports = o2();
      })(window, function() {
        return function(t2) {
          var o2 = {};
          function i2(n2) {
            if (o2[n2])
              return o2[n2].exports;
            var r2 = o2[n2] = { i: n2, l: false, exports: {} };
            return t2[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
          }
          return i2.m = t2, i2.c = o2, i2.d = function(n2, r2, a2) {
            i2.o(n2, r2) || Object.defineProperty(n2, r2, { enumerable: true, get: a2 });
          }, i2.r = function(n2) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
          }, i2.t = function(n2, r2) {
            if (1 & r2 && (n2 = i2(n2)), 8 & r2 || 4 & r2 && typeof n2 == "object" && n2 && n2.__esModule)
              return n2;
            var a2 = /* @__PURE__ */ Object.create(null);
            if (i2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: n2 }), 2 & r2 && typeof n2 != "string")
              for (var l2 in n2)
                i2.d(a2, l2, (function(c2) {
                  return n2[c2];
                }).bind(null, l2));
            return a2;
          }, i2.n = function(n2) {
            var r2 = n2 && n2.__esModule ? function() {
              return n2.default;
            } : function() {
              return n2;
            };
            return i2.d(r2, "a", r2), r2;
          }, i2.o = function(n2, r2) {
            return Object.prototype.hasOwnProperty.call(n2, r2);
          }, i2.p = "", i2(i2.s = 0);
        }([function(t2, o2, i2) {
          function n2(l2, c2) {
            for (var u2 = 0; u2 < c2.length; u2++) {
              var h2 = c2[u2];
              h2.enumerable = h2.enumerable || false, h2.configurable = true, "value" in h2 && (h2.writable = true), Object.defineProperty(l2, h2.key, h2);
            }
          }
          function r2(l2, c2, u2) {
            return c2 && n2(l2.prototype, c2), u2 && n2(l2, u2), l2;
          }
          i2.r(o2);
          var a2 = function() {
            function l2(c2) {
              var u2 = this;
              (function(h2, f2) {
                if (!(h2 instanceof f2))
                  throw new TypeError("Cannot call a class as a function");
              })(this, l2), this.commands = {}, this.keys = {}, this.name = c2.name, this.parseShortcutName(c2.name), this.element = c2.on, this.callback = c2.callback, this.executeShortcut = function(h2) {
                u2.execute(h2);
              }, this.element.addEventListener("keydown", this.executeShortcut, false);
            }
            return r2(l2, null, [{ key: "supportedCommands", get: function() {
              return { SHIFT: ["SHIFT"], CMD: ["CMD", "CONTROL", "COMMAND", "WINDOWS", "CTRL"], ALT: ["ALT", "OPTION"] };
            } }, { key: "keyCodes", get: function() {
              return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, ".": 190 };
            } }]), r2(l2, [{ key: "parseShortcutName", value: function(c2) {
              c2 = c2.split("+");
              for (var u2 = 0; u2 < c2.length; u2++) {
                c2[u2] = c2[u2].toUpperCase();
                var h2 = false;
                for (var f2 in l2.supportedCommands)
                  if (l2.supportedCommands[f2].includes(c2[u2])) {
                    h2 = this.commands[f2] = true;
                    break;
                  }
                h2 || (this.keys[c2[u2]] = true);
              }
              for (var k2 in l2.supportedCommands)
                this.commands[k2] || (this.commands[k2] = false);
            } }, { key: "execute", value: function(c2) {
              var u2, h2 = { CMD: c2.ctrlKey || c2.metaKey, SHIFT: c2.shiftKey, ALT: c2.altKey }, f2 = true;
              for (u2 in this.commands)
                this.commands[u2] !== h2[u2] && (f2 = false);
              var k2, p2 = true;
              for (k2 in this.keys)
                p2 = p2 && c2.keyCode === l2.keyCodes[k2];
              f2 && p2 && this.callback(c2);
            } }, { key: "remove", value: function() {
              this.element.removeEventListener("keydown", this.executeShortcut);
            } }]), l2;
          }();
          o2.default = a2;
        }]).default;
      });
    })(zo);
    const Uo = /* @__PURE__ */ xe(_e);
    class $o {
      constructor() {
        this.registeredShortcuts = /* @__PURE__ */ new Map();
      }
      /**
       * Register shortcut
       *
       * @param shortcut - shortcut options
       */
      add(e2) {
        if (this.findShortcut(e2.on, e2.name))
          throw Error(
            `Shortcut ${e2.name} is already registered for ${e2.on}. Please remove it before add a new handler.`
          );
        const o2 = new Uo({
          name: e2.name,
          on: e2.on,
          callback: e2.handler
        }), i2 = this.registeredShortcuts.get(e2.on) || [];
        this.registeredShortcuts.set(e2.on, [...i2, o2]);
      }
      /**
       * Remove shortcut
       *
       * @param element - Element shortcut is set for
       * @param name - shortcut name
       */
      remove(e2, t2) {
        const o2 = this.findShortcut(e2, t2);
        if (!o2)
          return;
        o2.remove();
        const i2 = this.registeredShortcuts.get(e2);
        this.registeredShortcuts.set(e2, i2.filter((n2) => n2 !== o2));
      }
      /**
       * Get Shortcut instance if exist
       *
       * @param element - Element shorcut is set for
       * @param shortcut - shortcut name
       * @returns {number} index - shortcut index if exist
       */
      findShortcut(e2, t2) {
        return (this.registeredShortcuts.get(e2) || []).find(({ name: i2 }) => i2 === t2);
      }
    }
    const le = new $o();
    var Wo = Object.defineProperty, Yo = Object.getOwnPropertyDescriptor, bt = (s2, e2, t2, o2) => {
      for (var i2 = o2 > 1 ? void 0 : o2 ? Yo(e2, t2) : e2, n2 = s2.length - 1, r2; n2 >= 0; n2--)
        (r2 = s2[n2]) && (i2 = (o2 ? r2(e2, t2, i2) : r2(i2)) || i2);
      return o2 && i2 && Wo(e2, t2, i2), i2;
    }, me = /* @__PURE__ */ ((s2) => (s2.Opened = "toolbox-opened", s2.Closed = "toolbox-closed", s2.BlockAdded = "toolbox-block-added", s2))(me || {});
    const mt = class extends we {
      /**
       * Toolbox constructor
       *
       * @param options - available parameters
       * @param options.api - Editor API methods
       * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not
       */
      constructor({ api: s2, tools: e2, i18nLabels: t2 }) {
        super(), this.opened = false, this.nodes = {
          toolbox: null
        }, this.onPopoverClose = () => {
          this.opened = false, this.emit(
            "toolbox-closed"
            /* Closed */
          );
        }, this.api = s2, this.tools = e2, this.i18nLabels = t2;
      }
      /**
       * Returns True if Toolbox is Empty and nothing to show
       *
       * @returns {boolean}
       */
      get isEmpty() {
        return this.toolsToBeDisplayed.length === 0;
      }
      /**
       * CSS styles
       *
       * @returns {Object<string, string>}
       */
      static get CSS() {
        return {
          toolbox: "ce-toolbox"
        };
      }
      /**
       * Makes the Toolbox
       */
      make() {
        return this.popover = new je({
          scopeElement: this.api.ui.nodes.redactor,
          searchable: true,
          messages: {
            nothingFound: this.i18nLabels.nothingFound,
            search: this.i18nLabels.filter
          },
          items: this.toolboxItemsToBeDisplayed
        }), this.popover.on(ge.Close, this.onPopoverClose), this.enableShortcuts(), this.nodes.toolbox = this.popover.getElement(), this.nodes.toolbox.classList.add(mt.CSS.toolbox), this.nodes.toolbox;
      }
      /**
       * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button
       */
      hasFocus() {
        var s2;
        return (s2 = this.popover) == null ? void 0 : s2.hasFocus();
      }
      /**
       * Destroy Module
       */
      destroy() {
        var s2;
        super.destroy(), this.nodes && this.nodes.toolbox && (this.nodes.toolbox.remove(), this.nodes.toolbox = null), this.removeAllShortcuts(), (s2 = this.popover) == null || s2.off(ge.Close, this.onPopoverClose);
      }
      /**
       * Toolbox Tool's button click handler
       *
       * @param toolName - tool type to be activated
       * @param blockDataOverrides - Block data predefined by the activated Toolbox item
       */
      toolButtonActivated(s2, e2) {
        this.insertNewBlock(s2, e2);
      }
      /**
       * Open Toolbox with Tools
       */
      open() {
        var s2;
        this.isEmpty || ((s2 = this.popover) == null || s2.show(), this.opened = true, this.emit(
          "toolbox-opened"
          /* Opened */
        ));
      }
      /**
       * Close Toolbox
       */
      close() {
        var s2;
        (s2 = this.popover) == null || s2.hide(), this.opened = false, this.emit(
          "toolbox-closed"
          /* Closed */
        );
      }
      /**
       * Close Toolbox
       */
      toggle() {
        this.opened ? this.close() : this.open();
      }
      get toolsToBeDisplayed() {
        const s2 = [];
        return this.tools.forEach((e2) => {
          e2.toolbox && s2.push(e2);
        }), s2;
      }
      get toolboxItemsToBeDisplayed() {
        const s2 = (e2, t2) => ({
          icon: e2.icon,
          title: $.t(X.toolNames, e2.title || ae(t2.name)),
          name: t2.name,
          onActivate: () => {
            this.toolButtonActivated(t2.name, e2.data);
          },
          secondaryLabel: t2.shortcut ? Re(t2.shortcut) : ""
        });
        return this.toolsToBeDisplayed.reduce((e2, t2) => (Array.isArray(t2.toolbox) ? t2.toolbox.forEach((o2) => {
          e2.push(s2(o2, t2));
        }) : t2.toolbox !== void 0 && e2.push(s2(t2.toolbox, t2)), e2), []);
      }
      /**
       * Iterate all tools and enable theirs shortcuts if specified
       */
      enableShortcuts() {
        this.toolsToBeDisplayed.forEach((s2) => {
          const e2 = s2.shortcut;
          e2 && this.enableShortcutForTool(s2.name, e2);
        });
      }
      /**
       * Enable shortcut Block Tool implemented shortcut
       *
       * @param {string} toolName - Tool name
       * @param {string} shortcut - shortcut according to the ShortcutData Module format
       */
      enableShortcutForTool(s2, e2) {
        le.add({
          name: e2,
          on: this.api.ui.nodes.redactor,
          handler: (t2) => {
            t2.preventDefault();
            const o2 = this.api.blocks.getCurrentBlockIndex(), i2 = this.api.blocks.getBlockByIndex(o2);
            if (i2)
              try {
                this.api.blocks.convert(i2.id, s2), window.requestAnimationFrame(() => {
                  this.api.caret.setToBlock(o2, "end");
                });
                return;
              } catch {
              }
            this.insertNewBlock(s2);
          }
        });
      }
      /**
       * Removes all added shortcuts
       * Fired when the Read-Only mode is activated
       */
      removeAllShortcuts() {
        this.toolsToBeDisplayed.forEach((s2) => {
          const e2 = s2.shortcut;
          e2 && le.remove(this.api.ui.nodes.redactor, e2);
        });
      }
      /**
       * Inserts new block
       * Can be called when button clicked on Toolbox or by ShortcutData
       *
       * @param {string} toolName - Tool name
       * @param blockDataOverrides - predefined Block data
       */
      async insertNewBlock(s2, e2) {
        const t2 = this.api.blocks.getCurrentBlockIndex(), o2 = this.api.blocks.getBlockByIndex(t2);
        if (!o2)
          return;
        const i2 = o2.isEmpty ? t2 : t2 + 1;
        let n2;
        if (e2) {
          const a2 = await this.api.blocks.composeBlockData(s2);
          n2 = Object.assign(a2, e2);
        }
        const r2 = this.api.blocks.insert(
          s2,
          n2,
          void 0,
          i2,
          void 0,
          o2.isEmpty
        );
        r2.call(q.APPEND_CALLBACK), this.api.caret.setToBlock(i2), this.emit("toolbox-block-added", {
          block: r2
        }), this.api.toolbar.close();
      }
    };
    let ze = mt;
    bt([
      ce
    ], ze.prototype, "toolsToBeDisplayed", 1);
    bt([
      ce
    ], ze.prototype, "toolboxItemsToBeDisplayed", 1);
    const kt = "block hovered";
    class Ko extends C {
      /**
       * @class
       * @param moduleConfiguration - Module Configuration
       * @param moduleConfiguration.config - Editor's config
       * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
       */
      constructor({ config: e2, eventsDispatcher: t2 }) {
        super({
          config: e2,
          eventsDispatcher: t2
        }), this.toolboxInstance = null, this.tooltip = new He();
      }
      /**
       * CSS styles
       *
       * @returns {object}
       */
      get CSS() {
        return {
          toolbar: "ce-toolbar",
          content: "ce-toolbar__content",
          actions: "ce-toolbar__actions",
          actionsOpened: "ce-toolbar__actions--opened",
          toolbarOpened: "ce-toolbar--opened",
          openedToolboxHolderModifier: "codex-editor--toolbox-opened",
          plusButton: "ce-toolbar__plus",
          plusButtonShortcut: "ce-toolbar__plus-shortcut",
          settingsToggler: "ce-toolbar__settings-btn",
          settingsTogglerHidden: "ce-toolbar__settings-btn--hidden"
        };
      }
      /**
       * Returns the Toolbar opening state
       *
       * @returns {boolean}
       */
      get opened() {
        return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);
      }
      /**
       * Public interface for accessing the Toolbox
       */
      get toolbox() {
        var e2;
        return {
          opened: (e2 = this.toolboxInstance) == null ? void 0 : e2.opened,
          close: () => {
            var t2;
            (t2 = this.toolboxInstance) == null || t2.close();
          },
          open: () => {
            if (this.toolboxInstance === null) {
              L$1("toolbox.open() called before initialization is finished", "warn");
              return;
            }
            this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();
          },
          toggle: () => {
            if (this.toolboxInstance === null) {
              L$1("toolbox.toggle() called before initialization is finished", "warn");
              return;
            }
            this.toolboxInstance.toggle();
          },
          hasFocus: () => {
            var t2;
            return (t2 = this.toolboxInstance) == null ? void 0 : t2.hasFocus();
          }
        };
      }
      /**
       * Block actions appearance manipulations
       */
      get blockActions() {
        return {
          hide: () => {
            this.nodes.actions.classList.remove(this.CSS.actionsOpened);
          },
          show: () => {
            this.nodes.actions.classList.add(this.CSS.actionsOpened);
          }
        };
      }
      /**
       * Methods for working with Block Tunes toggler
       */
      get blockTunesToggler() {
        return {
          hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),
          show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)
        };
      }
      /**
       * Toggles read-only mode
       *
       * @param {boolean} readOnlyEnabled - read-only mode
       */
      toggleReadOnly(e2) {
        e2 ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(() => {
          this.drawUI(), this.enableModuleBindings();
        }, { timeout: 2e3 });
      }
      /**
       * Move Toolbar to the passed (or current) Block
       *
       * @param block - block to move Toolbar near it
       */
      moveAndOpen(e2 = this.Editor.BlockManager.currentBlock) {
        if (this.toolboxInstance === null) {
          L$1("Can't open Toolbar since Editor initialization is not finished yet", "warn");
          return;
        }
        if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e2)
          return;
        this.hoveredBlock = e2;
        const t2 = e2.holder, { isMobile: o2 } = this.Editor.UI, i2 = e2.pluginsContent, n2 = window.getComputedStyle(i2), r2 = parseInt(n2.paddingTop, 10), a2 = t2.offsetHeight;
        let l2;
        o2 ? l2 = t2.offsetTop + a2 : l2 = t2.offsetTop + r2, this.nodes.wrapper.style.top = `${Math.floor(l2)}px`, this.Editor.BlockManager.blocks.length === 1 && e2.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();
      }
      /**
       * Close the Toolbar
       */
      close() {
        var e2;
        this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (e2 = this.toolboxInstance) == null || e2.close(), this.Editor.BlockSettings.close());
      }
      /**
       * Open Toolbar with Plus Button and Actions
       *
       * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.
       *                                     This flag allows to open Toolbar without Actions.
       */
      open(e2 = true) {
        re(() => {
          this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e2 ? this.blockActions.show() : this.blockActions.hide();
        }, 50)();
      }
      /**
       * Draws Toolbar elements
       */
      make() {
        this.nodes.wrapper = d$1.make("div", this.CSS.toolbar), ["content", "actions"].forEach((t2) => {
          this.nodes[t2] = d$1.make("div", this.CSS[t2]);
        }), d$1.append(this.nodes.wrapper, this.nodes.content), d$1.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = d$1.make("div", this.CSS.plusButton, {
          innerHTML: _o
        }), d$1.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, "click", () => {
          this.tooltip.hide(true), this.plusButtonClicked();
        }, false);
        const e2 = d$1.make("div");
        e2.appendChild(document.createTextNode($.ui(X.ui.toolbar.toolbox, "Add"))), e2.appendChild(d$1.make("div", this.CSS.plusButtonShortcut, {
          textContent: " Tab"
        })), this.tooltip.onHover(this.nodes.plusButton, e2, {
          hidingDelay: 400
        }), this.nodes.settingsToggler = d$1.make("span", this.CSS.settingsToggler, {
          innerHTML: Ao
        }), d$1.append(this.nodes.actions, this.nodes.settingsToggler), this.tooltip.onHover(
          this.nodes.settingsToggler,
          $.ui(X.ui.blockTunes.toggler, "Click to tune"),
          {
            hidingDelay: 400
          }
        ), d$1.append(this.nodes.actions, this.makeToolbox()), d$1.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), d$1.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);
      }
      /**
       * Creates the Toolbox instance and return it's rendered element
       */
      makeToolbox() {
        return this.toolboxInstance = new ze({
          api: this.Editor.API.methods,
          tools: this.Editor.Tools.blockTools,
          i18nLabels: {
            filter: $.ui(X.ui.popover, "Filter"),
            nothingFound: $.ui(X.ui.popover, "Nothing found")
          }
        }), this.toolboxInstance.on(me.Opened, () => {
          this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);
        }), this.toolboxInstance.on(me.Closed, () => {
          this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);
        }), this.toolboxInstance.on(me.BlockAdded, ({ block: e2 }) => {
          const { BlockManager: t2, Caret: o2 } = this.Editor, i2 = t2.getBlockById(e2.id);
          i2.inputs.length === 0 && (i2 === t2.lastBlock ? (t2.insertAtEnd(), o2.setToBlock(t2.lastBlock)) : o2.setToBlock(t2.nextBlock));
        }), this.toolboxInstance.make();
      }
      /**
       * Handler for Plus Button
       */
      plusButtonClicked() {
        var e2;
        this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e2 = this.toolboxInstance) == null || e2.toggle();
      }
      /**
       * Enable bindings
       */
      enableModuleBindings() {
        this.readOnlyMutableListeners.on(this.nodes.settingsToggler, "mousedown", (e2) => {
          var t2;
          e2.stopPropagation(), this.settingsTogglerClicked(), (t2 = this.toolboxInstance) != null && t2.opened && this.toolboxInstance.close(), this.tooltip.hide(true);
        }, true), te() || this.eventsDispatcher.on(kt, (e2) => {
          var t2;
          this.Editor.BlockSettings.opened || (t2 = this.toolboxInstance) != null && t2.opened || this.moveAndOpen(e2.block);
        });
      }
      /**
       * Disable bindings
       */
      disableModuleBindings() {
        this.readOnlyMutableListeners.clearAll();
      }
      /**
       * Clicks on the Block Settings toggler
       */
      settingsTogglerClicked() {
        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);
      }
      /**
       * Draws Toolbar UI
       *
       * Toolbar contains BlockSettings and Toolbox.
       * That's why at first we draw its components and then Toolbar itself
       *
       * Steps:
       *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on
       *  - Make itself and append dependent nodes to itself
       *
       */
      drawUI() {
        this.Editor.BlockSettings.make(), this.make();
      }
      /**
       * Removes all created and saved HTMLElements
       * It is used in Read-Only mode
       */
      destroy() {
        this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy(), this.tooltip.destroy();
      }
    }
    var ye = /* @__PURE__ */ ((s2) => (s2[s2.Block = 0] = "Block", s2[s2.Inline = 1] = "Inline", s2[s2.Tune = 2] = "Tune", s2))(ye || {}), ke = /* @__PURE__ */ ((s2) => (s2.Shortcut = "shortcut", s2.Toolbox = "toolbox", s2.EnabledInlineTools = "inlineToolbar", s2.EnabledBlockTunes = "tunes", s2.Config = "config", s2))(ke || {}), vt = /* @__PURE__ */ ((s2) => (s2.Shortcut = "shortcut", s2.SanitizeConfig = "sanitize", s2))(vt || {}), se = /* @__PURE__ */ ((s2) => (s2.IsEnabledLineBreaks = "enableLineBreaks", s2.Toolbox = "toolbox", s2.ConversionConfig = "conversionConfig", s2.IsReadOnlySupported = "isReadOnlySupported", s2.PasteConfig = "pasteConfig", s2))(se || {}), Ue = /* @__PURE__ */ ((s2) => (s2.IsInline = "isInline", s2.Title = "title", s2))(Ue || {}), xt = /* @__PURE__ */ ((s2) => (s2.IsTune = "isTune", s2))(xt || {});
    class $e {
      /**
       * @class
       * @param {ConstructorOptions} options - Constructor options
       */
      constructor({
        name: e2,
        constructable: t2,
        config: o2,
        api: i2,
        isDefault: n2,
        isInternal: r2 = false,
        defaultPlaceholder: a2
      }) {
        this.api = i2, this.name = e2, this.constructable = t2, this.config = o2, this.isDefault = n2, this.isInternal = r2, this.defaultPlaceholder = a2;
      }
      /**
       * Returns Tool user configuration
       */
      get settings() {
        const e2 = this.config.config || {};
        return this.isDefault && !("placeholder" in e2) && this.defaultPlaceholder && (e2.placeholder = this.defaultPlaceholder), e2;
      }
      /**
       * Calls Tool's reset method
       */
      reset() {
        if (D$1(this.constructable.reset))
          return this.constructable.reset();
      }
      /**
       * Calls Tool's prepare method
       */
      prepare() {
        if (D$1(this.constructable.prepare))
          return this.constructable.prepare({
            toolName: this.name,
            config: this.settings
          });
      }
      /**
       * Returns shortcut for Tool (internal or specified by user)
       */
      get shortcut() {
        const e2 = this.constructable.shortcut;
        return this.config.shortcut || e2;
      }
      /**
       * Returns Tool's sanitizer configuration
       */
      get sanitizeConfig() {
        return this.constructable.sanitize || {};
      }
      /**
       * Returns true if Tools is inline
       */
      isInline() {
        return this.type === 1;
      }
      /**
       * Returns true if Tools is block
       */
      isBlock() {
        return this.type === 0;
      }
      /**
       * Returns true if Tools is tune
       */
      isTune() {
        return this.type === 2;
      }
    }
    class Xo extends C {
      /**
       * @class
       * @param moduleConfiguration - Module Configuration
       * @param moduleConfiguration.config - Editor's config
       * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
       */
      constructor({ config: e2, eventsDispatcher: t2 }) {
        super({
          config: e2,
          eventsDispatcher: t2
        }), this.CSS = {
          inlineToolbar: "ce-inline-toolbar",
          inlineToolbarShowed: "ce-inline-toolbar--showed",
          inlineToolbarLeftOriented: "ce-inline-toolbar--left-oriented",
          inlineToolbarRightOriented: "ce-inline-toolbar--right-oriented",
          inlineToolbarShortcut: "ce-inline-toolbar__shortcut",
          buttonsWrapper: "ce-inline-toolbar__buttons",
          actionsWrapper: "ce-inline-toolbar__actions",
          inlineToolButton: "ce-inline-tool",
          inputField: "cdx-input",
          focusedButton: "ce-inline-tool--focused",
          conversionToggler: "ce-inline-toolbar__dropdown",
          conversionTogglerArrow: "ce-inline-toolbar__dropdown-arrow",
          conversionTogglerHidden: "ce-inline-toolbar__dropdown--hidden",
          conversionTogglerContent: "ce-inline-toolbar__dropdown-content",
          togglerAndButtonsWrapper: "ce-inline-toolbar__toggler-and-button-wrapper"
        }, this.opened = false, this.toolbarVerticalMargin = te() ? 20 : 6, this.buttonsList = null, this.width = 0, this.flipper = null, this.tooltip = new He();
      }
      /**
       * Toggles read-only mode
       *
       * @param {boolean} readOnlyEnabled - read-only mode
       */
      toggleReadOnly(e2) {
        e2 ? (this.destroy(), this.Editor.ConversionToolbar.destroy()) : window.requestIdleCallback(() => {
          this.make();
        }, { timeout: 2e3 });
      }
      /**
       *  Moving / appearance
       *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       */
      /**
       * Shows Inline Toolbar if something is selected
       *
       * @param [needToClose] - pass true to close toolbar if it is not allowed.
       *                                  Avoid to use it just for closing IT, better call .close() clearly.
       * @param [needToShowConversionToolbar] - pass false to not to show Conversion Toolbar
       */
      tryToShow(e2 = false, t2 = true) {
        if (!this.allowedToShow()) {
          e2 && this.close();
          return;
        }
        this.move(), this.open(t2), this.Editor.Toolbar.close();
      }
      /**
       * Move Toolbar to the selected text
       */
      move() {
        const e2 = m$1.rect, t2 = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), o2 = {
          x: e2.x - t2.left,
          y: e2.y + e2.height - // + window.scrollY
          t2.top + this.toolbarVerticalMargin
        };
        e2.width && (o2.x += Math.floor(e2.width / 2));
        const i2 = o2.x - this.width / 2, n2 = o2.x + this.width / 2;
        this.nodes.wrapper.classList.toggle(
          this.CSS.inlineToolbarLeftOriented,
          i2 < this.Editor.UI.contentRect.left
        ), this.nodes.wrapper.classList.toggle(
          this.CSS.inlineToolbarRightOriented,
          n2 > this.Editor.UI.contentRect.right
        ), this.nodes.wrapper.style.left = Math.floor(o2.x) + "px", this.nodes.wrapper.style.top = Math.floor(o2.y) + "px";
      }
      /**
       * Hides Inline Toolbar
       */
      close() {
        this.opened && (this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.inlineToolbarShowed), Array.from(this.toolsInstances.entries()).forEach(([e2, t2]) => {
          const o2 = this.getToolShortcut(e2);
          o2 && le.remove(this.Editor.UI.nodes.redactor, o2), D$1(t2.clear) && t2.clear();
        }), this.opened = false, this.flipper.deactivate(), this.Editor.ConversionToolbar.close()));
      }
      /**
       * Shows Inline Toolbar
       *
       * @param [needToShowConversionToolbar] - pass false to not to show Conversion Toolbar
       */
      open(e2 = true) {
        if (this.opened)
          return;
        this.addToolsFiltered(), this.nodes.wrapper.classList.add(this.CSS.inlineToolbarShowed), this.buttonsList = this.nodes.buttons.querySelectorAll(`.${this.CSS.inlineToolButton}`), this.opened = true, e2 && this.Editor.ConversionToolbar.hasTools() ? this.setConversionTogglerContent() : this.nodes.conversionToggler.hidden = true;
        let t2 = Array.from(this.buttonsList);
        t2.unshift(this.nodes.conversionToggler), t2 = t2.filter((o2) => !o2.hidden), this.flipper.activate(t2);
      }
      /**
       * Check if node is contained by Inline Toolbar
       *
       * @param {Node} node  node to check
       */
      containsNode(e2) {
        return this.nodes.wrapper.contains(e2);
      }
      /**
       * Removes UI and its components
       */
      destroy() {
        this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes(), this.tooltip.destroy();
      }
      /**
       * Making DOM
       */
      make() {
        this.nodes.wrapper = d$1.make("div", [
          this.CSS.inlineToolbar,
          ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []
        ]), this.nodes.togglerAndButtonsWrapper = d$1.make("div", this.CSS.togglerAndButtonsWrapper), this.nodes.buttons = d$1.make("div", this.CSS.buttonsWrapper), this.nodes.actions = d$1.make("div", this.CSS.actionsWrapper), this.listeners.on(this.nodes.wrapper, "mousedown", (e2) => {
          e2.target.closest(`.${this.CSS.actionsWrapper}`) || e2.preventDefault();
        }), d$1.append(this.nodes.wrapper, [this.nodes.togglerAndButtonsWrapper, this.nodes.actions]), d$1.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper), this.addConversionToggler(), d$1.append(this.nodes.togglerAndButtonsWrapper, this.nodes.buttons), this.prepareConversionToolbar(), window.requestAnimationFrame(() => {
          this.recalculateWidth();
        }), this.enableFlipper();
      }
      /**
       * Need to show Inline Toolbar or not
       */
      allowedToShow() {
        const e2 = ["IMG", "INPUT"], t2 = m$1.get(), o2 = m$1.text;
        if (!t2 || !t2.anchorNode || t2.isCollapsed || o2.length < 1)
          return false;
        const i2 = d$1.isElement(t2.anchorNode) ? t2.anchorNode : t2.anchorNode.parentElement;
        if (t2 && e2.includes(i2.tagName) || i2.closest('[contenteditable="true"]') === null)
          return false;
        const r2 = this.Editor.BlockManager.getBlock(t2.anchorNode);
        return r2 ? r2.tool.inlineTools.size !== 0 : false;
      }
      /**
       * Recalculate inline toolbar width
       */
      recalculateWidth() {
        this.width = this.nodes.wrapper.offsetWidth;
      }
      /**
       * Create a toggler for Conversion Dropdown
       * and prepend it to the buttons list
       */
      addConversionToggler() {
        this.nodes.conversionToggler = d$1.make("div", this.CSS.conversionToggler), this.nodes.conversionTogglerContent = d$1.make("div", this.CSS.conversionTogglerContent);
        const e2 = d$1.make("div", this.CSS.conversionTogglerArrow, {
          innerHTML: ft
        });
        this.nodes.conversionToggler.appendChild(this.nodes.conversionTogglerContent), this.nodes.conversionToggler.appendChild(e2), this.nodes.togglerAndButtonsWrapper.appendChild(this.nodes.conversionToggler), this.listeners.on(this.nodes.conversionToggler, "click", () => {
          this.Editor.ConversionToolbar.toggle((t2) => {
            !t2 && this.opened ? this.flipper.activate() : this.opened && this.flipper.deactivate();
          });
        }), te() === false && this.tooltip.onHover(this.nodes.conversionToggler, $.ui(X.ui.inlineToolbar.converter, "Convert to"), {
          placement: "top",
          hidingDelay: 100
        });
      }
      /**
       * Changes Conversion Dropdown content for current block's Tool
       */
      async setConversionTogglerContent() {
        const { BlockManager: e2 } = this.Editor, { currentBlock: t2 } = e2, o2 = t2.name, i2 = t2.tool.conversionConfig, n2 = i2 && i2.export;
        this.nodes.conversionToggler.hidden = !n2, this.nodes.conversionToggler.classList.toggle(this.CSS.conversionTogglerHidden, !n2);
        const r2 = await t2.getActiveToolboxEntry() || {};
        this.nodes.conversionTogglerContent.innerHTML = r2.icon || r2.title || ae(o2);
      }
      /**
       * Makes the Conversion Dropdown
       */
      prepareConversionToolbar() {
        const e2 = this.Editor.ConversionToolbar.make();
        d$1.append(this.nodes.wrapper, e2);
      }
      /**
       *  Working with Tools
       *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       */
      /**
       * Append only allowed Tools
       */
      addToolsFiltered() {
        const e2 = m$1.get(), t2 = this.Editor.BlockManager.getBlock(e2.anchorNode);
        this.nodes.buttons.innerHTML = "", this.nodes.actions.innerHTML = "", this.toolsInstances = /* @__PURE__ */ new Map(), Array.from(t2.tool.inlineTools.values()).forEach((o2) => {
          this.addTool(o2);
        }), this.recalculateWidth();
      }
      /**
       * Add tool button and activate clicks
       *
       * @param {InlineTool} tool - InlineTool object
       */
      addTool(e2) {
        const t2 = e2.create(), o2 = t2.render();
        if (!o2) {
          L$1("Render method must return an instance of Node", "warn", e2.name);
          return;
        }
        if (o2.dataset.tool = e2.name, this.nodes.buttons.appendChild(o2), this.toolsInstances.set(e2.name, t2), D$1(t2.renderActions)) {
          const a2 = t2.renderActions();
          this.nodes.actions.appendChild(a2);
        }
        this.listeners.on(o2, "click", (a2) => {
          this.toolClicked(t2), a2.preventDefault();
        });
        const i2 = this.getToolShortcut(e2.name);
        if (i2)
          try {
            this.enableShortcuts(t2, i2);
          } catch {
          }
        const n2 = d$1.make("div"), r2 = $.t(
          X.toolNames,
          e2.title || ae(e2.name)
        );
        n2.appendChild(d$1.text(r2)), i2 && n2.appendChild(d$1.make("div", this.CSS.inlineToolbarShortcut, {
          textContent: Re(i2)
        })), te() === false && this.tooltip.onHover(o2, n2, {
          placement: "top",
          hidingDelay: 100
        }), t2.checkState(m$1.get());
      }
      /**
       * Get shortcut name for tool
       *
       * @param toolName  Tool name
       */
      getToolShortcut(e2) {
        const { Tools: t2 } = this.Editor, o2 = t2.inlineTools.get(e2), i2 = t2.internal.inlineTools;
        return Array.from(i2.keys()).includes(e2) ? this.inlineTools[e2][vt.Shortcut] : o2.shortcut;
      }
      /**
       * Enable Tool shortcut with Editor Shortcuts Module
       *
       * @param {InlineTool} tool - Tool instance
       * @param {string} shortcut - shortcut according to the ShortcutData Module format
       */
      enableShortcuts(e2, t2) {
        le.add({
          name: t2,
          handler: (o2) => {
            const { currentBlock: i2 } = this.Editor.BlockManager;
            i2 && i2.tool.enabledInlineTools && (o2.preventDefault(), this.toolClicked(e2));
          },
          on: this.Editor.UI.nodes.redactor
        });
      }
      /**
       * Inline Tool button clicks
       *
       * @param {InlineTool} tool - Tool's instance
       */
      toolClicked(e2) {
        const t2 = m$1.range;
        e2.surround(t2), this.checkToolsState(), e2.renderActions !== void 0 && this.flipper.deactivate();
      }
      /**
       * Check Tools` state by selection
       */
      checkToolsState() {
        this.toolsInstances.forEach((e2) => {
          e2.checkState(m$1.get());
        });
      }
      /**
       * Get inline tools tools
       * Tools that has isInline is true
       */
      get inlineTools() {
        const e2 = {};
        return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t2, o2]) => {
          e2[t2] = o2.create();
        }), e2;
      }
      /**
       * Allow to leaf buttons by arrows / tab
       * Buttons will be filled on opening
       */
      enableFlipper() {
        this.flipper = new G({
          focusedItemClass: this.CSS.focusedButton,
          allowedKeys: [
            B$1.ENTER,
            B$1.TAB
          ]
        });
      }
    }
    class Vo extends C {
      /**
       * All keydowns on Block
       *
       * @param {KeyboardEvent} event - keydown
       */
      keydown(e2) {
        switch (this.beforeKeydownProcessing(e2), e2.keyCode) {
          case B$1.BACKSPACE:
            this.backspace(e2);
            break;
          case B$1.DELETE:
            this.delete(e2);
            break;
          case B$1.ENTER:
            this.enter(e2);
            break;
          case B$1.DOWN:
          case B$1.RIGHT:
            this.arrowRightAndDown(e2);
            break;
          case B$1.UP:
          case B$1.LEFT:
            this.arrowLeftAndUp(e2);
            break;
          case B$1.TAB:
            this.tabPressed(e2);
            break;
        }
      }
      /**
       * Fires on keydown before event processing
       *
       * @param {KeyboardEvent} event - keydown
       */
      beforeKeydownProcessing(e2) {
        this.needToolbarClosing(e2) && nt(e2.keyCode) && (this.Editor.Toolbar.close(), this.Editor.ConversionToolbar.close(), e2.ctrlKey || e2.metaKey || e2.altKey || e2.shiftKey || (this.Editor.BlockManager.clearFocused(), this.Editor.BlockSelection.clearSelection(e2)));
      }
      /**
       * Key up on Block:
       * - shows Inline Toolbar if something selected
       * - shows conversion toolbar with 85% of block selection
       *
       * @param {KeyboardEvent} event - keyup event
       */
      keyup(e2) {
        e2.shiftKey || this.Editor.UI.checkEmptiness();
      }
      /**
       * Open Toolbox to leaf Tools
       *
       * @param {KeyboardEvent} event - tab keydown event
       */
      tabPressed(e2) {
        this.Editor.BlockSelection.clearSelection(e2);
        const { BlockManager: t2, InlineToolbar: o2, ConversionToolbar: i2 } = this.Editor, n2 = t2.currentBlock;
        if (!n2)
          return;
        const r2 = n2.isEmpty, a2 = n2.tool.isDefault && r2, l2 = !r2 && i2.opened, c2 = !r2 && !m$1.isCollapsed && o2.opened;
        a2 ? this.activateToolbox() : !l2 && !c2 && this.activateBlockSettings();
      }
      /**
       * Add drop target styles
       *
       * @param {DragEvent} event - drag over event
       */
      dragOver(e2) {
        const t2 = this.Editor.BlockManager.getBlockByChildNode(e2.target);
        t2.dropTarget = true;
      }
      /**
       * Remove drop target style
       *
       * @param {DragEvent} event - drag leave event
       */
      dragLeave(e2) {
        const t2 = this.Editor.BlockManager.getBlockByChildNode(e2.target);
        t2.dropTarget = false;
      }
      /**
       * Copying selected blocks
       * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard
       *
       * @param {ClipboardEvent} event - clipboard event
       */
      handleCommandC(e2) {
        const { BlockSelection: t2 } = this.Editor;
        t2.anyBlockSelected && t2.copySelectedBlocks(e2);
      }
      /**
       * Copy and Delete selected Blocks
       *
       * @param {ClipboardEvent} event - clipboard event
       */
      handleCommandX(e2) {
        const { BlockSelection: t2, BlockManager: o2, Caret: i2 } = this.Editor;
        t2.anyBlockSelected && t2.copySelectedBlocks(e2).then(() => {
          const n2 = o2.removeSelectedBlocks(), r2 = o2.insertDefaultBlockAtIndex(n2, true);
          i2.setToBlock(r2, i2.positions.START), t2.clearSelection(e2);
        });
      }
      /**
       * ENTER pressed on block
       *
       * @param {KeyboardEvent} event - keydown
       */
      enter(e2) {
        const { BlockManager: t2, UI: o2 } = this.Editor;
        if (t2.currentBlock.tool.isLineBreaksEnabled || o2.someToolbarOpened && o2.someFlipperButtonFocused || e2.shiftKey)
          return;
        let n2 = this.Editor.BlockManager.currentBlock;
        this.Editor.Caret.isAtStart && !this.Editor.BlockManager.currentBlock.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : this.Editor.Caret.isAtEnd ? n2 = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : n2 = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(n2), this.Editor.Toolbar.moveAndOpen(n2), e2.preventDefault();
      }
      /**
       * Handle backspace keydown on Block
       *
       * @param {KeyboardEvent} event - keydown
       */
      backspace(e2) {
        const { BlockManager: t2, Caret: o2 } = this.Editor, { currentBlock: i2, previousBlock: n2 } = t2;
        if (!m$1.isCollapsed || !o2.isAtStart)
          return;
        if (e2.preventDefault(), this.Editor.Toolbar.close(), !(i2.currentInput === i2.firstInput)) {
          o2.navigatePrevious();
          return;
        }
        if (n2 === null)
          return;
        if (n2.isEmpty) {
          t2.removeBlock(n2);
          return;
        }
        if (i2.isEmpty) {
          t2.removeBlock(i2);
          const l2 = t2.currentBlock;
          o2.setToBlock(l2, o2.positions.END);
          return;
        }
        Je(i2, n2) ? this.mergeBlocks(n2, i2) : o2.setToBlock(n2, o2.positions.END);
      }
      /**
       * Handles delete keydown on Block
       * Removes char after the caret.
       * If caret is at the end of the block, merge next block with current
       *
       * @param {KeyboardEvent} event - keydown
       */
      delete(e2) {
        const { BlockManager: t2, Caret: o2 } = this.Editor, { currentBlock: i2, nextBlock: n2 } = t2;
        if (!m$1.isCollapsed || !o2.isAtEnd)
          return;
        if (e2.preventDefault(), this.Editor.Toolbar.close(), !(i2.currentInput === i2.lastInput)) {
          o2.navigateNext();
          return;
        }
        if (n2 === null)
          return;
        if (n2.isEmpty) {
          t2.removeBlock(n2);
          return;
        }
        if (i2.isEmpty) {
          t2.removeBlock(i2), o2.setToBlock(n2, o2.positions.START);
          return;
        }
        Je(i2, n2) ? this.mergeBlocks(i2, n2) : o2.setToBlock(n2, o2.positions.START);
      }
      /**
       * Merge passed Blocks
       *
       * @param targetBlock - to which Block we want to merge
       * @param blockToMerge - what Block we want to merge
       */
      mergeBlocks(e2, t2) {
        const { BlockManager: o2, Caret: i2, Toolbar: n2 } = this.Editor;
        i2.createShadow(e2.pluginsContent), o2.mergeBlocks(e2, t2).then(() => {
          window.requestAnimationFrame(() => {
            i2.restoreCaret(e2.pluginsContent), e2.pluginsContent.normalize(), n2.close();
          });
        });
      }
      /**
       * Handle right and down keyboard keys
       *
       * @param {KeyboardEvent} event - keyboard event
       */
      arrowRightAndDown(e2) {
        const t2 = G.usedKeys.includes(e2.keyCode) && (!e2.shiftKey || e2.keyCode === B$1.TAB);
        if (this.Editor.UI.someToolbarOpened && t2)
          return;
        this.Editor.BlockManager.clearFocused(), this.Editor.Toolbar.close();
        const o2 = this.Editor.Caret.isAtEnd || this.Editor.BlockSelection.anyBlockSelected;
        if (e2.shiftKey && e2.keyCode === B$1.DOWN && o2) {
          this.Editor.CrossBlockSelection.toggleBlockSelectedState();
          return;
        }
        (e2.keyCode === B$1.DOWN || e2.keyCode === B$1.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) ? e2.preventDefault() : re(() => {
          this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
        }, 20)(), this.Editor.BlockSelection.clearSelection(e2);
      }
      /**
       * Handle left and up keyboard keys
       *
       * @param {KeyboardEvent} event - keyboard event
       */
      arrowLeftAndUp(e2) {
        if (this.Editor.UI.someToolbarOpened) {
          if (G.usedKeys.includes(e2.keyCode) && (!e2.shiftKey || e2.keyCode === B$1.TAB))
            return;
          this.Editor.UI.closeAllToolbars();
        }
        this.Editor.BlockManager.clearFocused(), this.Editor.Toolbar.close();
        const t2 = this.Editor.Caret.isAtStart || this.Editor.BlockSelection.anyBlockSelected;
        if (e2.shiftKey && e2.keyCode === B$1.UP && t2) {
          this.Editor.CrossBlockSelection.toggleBlockSelectedState(false);
          return;
        }
        (e2.keyCode === B$1.UP || e2.keyCode === B$1.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) ? e2.preventDefault() : re(() => {
          this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
        }, 20)(), this.Editor.BlockSelection.clearSelection(e2);
      }
      /**
       * Cases when we need to close Toolbar
       *
       * @param {KeyboardEvent} event - keyboard event
       */
      needToolbarClosing(e2) {
        const t2 = e2.keyCode === B$1.ENTER && this.Editor.Toolbar.toolbox.opened, o2 = e2.keyCode === B$1.ENTER && this.Editor.BlockSettings.opened, i2 = e2.keyCode === B$1.ENTER && this.Editor.InlineToolbar.opened, n2 = e2.keyCode === B$1.ENTER && this.Editor.ConversionToolbar.opened, r2 = e2.keyCode === B$1.TAB;
        return !(e2.shiftKey || r2 || t2 || o2 || i2 || n2);
      }
      /**
       * If Toolbox is not open, then just open it and show plus button
       */
      activateToolbox() {
        this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();
      }
      /**
       * Open Toolbar and show BlockSettings before flipping Tools
       */
      activateBlockSettings() {
        this.Editor.Toolbar.opened || (this.Editor.BlockManager.currentBlock.focused = true, this.Editor.Toolbar.moveAndOpen()), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();
      }
    }
    class Te {
      /**
       * @class
       * @param {HTMLElement} workingArea  editor`s working node
       */
      constructor(e2) {
        this.blocks = [], this.workingArea = e2;
      }
      /**
       * Get length of Block instances array
       *
       * @returns {number}
       */
      get length() {
        return this.blocks.length;
      }
      /**
       * Get Block instances array
       *
       * @returns {Block[]}
       */
      get array() {
        return this.blocks;
      }
      /**
       * Get blocks html elements array
       *
       * @returns {HTMLElement[]}
       */
      get nodes() {
        return st(this.workingArea.children);
      }
      /**
       * Proxy trap to implement array-like setter
       *
       * @example
       * blocks[0] = new Block(...)
       * @param {Blocks} instance  Blocks instance
       * @param {PropertyKey} property  block index or any Blocks class property key to set
       * @param {Block} value  value to set
       * @returns {boolean}
       */
      static set(e2, t2, o2) {
        return isNaN(Number(t2)) ? (Reflect.set(e2, t2, o2), true) : (e2.insert(+t2, o2), true);
      }
      /**
       * Proxy trap to implement array-like getter
       *
       * @param {Blocks} instance  Blocks instance
       * @param {PropertyKey} property  Blocks class property key
       * @returns {Block|*}
       */
      static get(e2, t2) {
        return isNaN(Number(t2)) ? Reflect.get(e2, t2) : e2.get(+t2);
      }
      /**
       * Push new Block to the blocks array and append it to working area
       *
       * @param {Block} block - Block to add
       */
      push(e2) {
        this.blocks.push(e2), this.insertToDOM(e2);
      }
      /**
       * Swaps blocks with indexes first and second
       *
       * @param {number} first - first block index
       * @param {number} second - second block index
       * @deprecated  use 'move' instead
       */
      swap(e2, t2) {
        const o2 = this.blocks[t2];
        d$1.swap(this.blocks[e2].holder, o2.holder), this.blocks[t2] = this.blocks[e2], this.blocks[e2] = o2;
      }
      /**
       * Move a block from one to another index
       *
       * @param {number} toIndex - new index of the block
       * @param {number} fromIndex - block to move
       */
      move(e2, t2) {
        const o2 = this.blocks.splice(t2, 1)[0], i2 = e2 - 1, n2 = Math.max(0, i2), r2 = this.blocks[n2];
        e2 > 0 ? this.insertToDOM(o2, "afterend", r2) : this.insertToDOM(o2, "beforebegin", r2), this.blocks.splice(e2, 0, o2);
        const a2 = this.composeBlockEvent("move", {
          fromIndex: t2,
          toIndex: e2
        });
        o2.call(q.MOVED, a2);
      }
      /**
       * Insert new Block at passed index
       *
       * @param {number} index  index to insert Block
       * @param {Block} block  Block to insert
       * @param {boolean} replace  it true, replace block on given index
       */
      insert(e2, t2, o2 = false) {
        if (!this.length) {
          this.push(t2);
          return;
        }
        e2 > this.length && (e2 = this.length), o2 && (this.blocks[e2].holder.remove(), this.blocks[e2].call(q.REMOVED));
        const i2 = o2 ? 1 : 0;
        if (this.blocks.splice(e2, i2, t2), e2 > 0) {
          const n2 = this.blocks[e2 - 1];
          this.insertToDOM(t2, "afterend", n2);
        } else {
          const n2 = this.blocks[e2 + 1];
          n2 ? this.insertToDOM(t2, "beforebegin", n2) : this.insertToDOM(t2);
        }
      }
      /**
       * Replaces block under passed index with passed block
       *
       * @param index - index of existed block
       * @param block - new block
       */
      replace(e2, t2) {
        if (this.blocks[e2] === void 0)
          throw Error("Incorrect index");
        this.blocks[e2].holder.replaceWith(t2.holder), this.blocks[e2] = t2;
      }
      /**
       * Inserts several blocks at once
       *
       * @param blocks - blocks to insert
       * @param index - index to insert blocks at
       */
      insertMany(e2, t2) {
        const o2 = new DocumentFragment();
        for (const i2 of e2)
          o2.appendChild(i2.holder);
        if (this.length > 0) {
          if (t2 > 0) {
            const i2 = Math.min(t2 - 1, this.length - 1);
            this.blocks[i2].holder.after(o2);
          } else
            t2 === 0 && this.workingArea.prepend(o2);
          this.blocks.splice(t2, 0, ...e2);
        } else
          this.blocks.push(...e2), this.workingArea.appendChild(o2);
        e2.forEach((i2) => i2.call(q.RENDERED));
      }
      /**
       * Remove block
       *
       * @param {number} index - index of Block to remove
       */
      remove(e2) {
        isNaN(e2) && (e2 = this.length - 1), this.blocks[e2].holder.remove(), this.blocks[e2].call(q.REMOVED), this.blocks.splice(e2, 1);
      }
      /**
       * Remove all blocks
       */
      removeAll() {
        this.workingArea.innerHTML = "", this.blocks.forEach((e2) => e2.call(q.REMOVED)), this.blocks.length = 0;
      }
      /**
       * Insert Block after passed target
       *
       * @todo decide if this method is necessary
       * @param {Block} targetBlock  target after which Block should be inserted
       * @param {Block} newBlock  Block to insert
       */
      insertAfter(e2, t2) {
        const o2 = this.blocks.indexOf(e2);
        this.insert(o2 + 1, t2);
      }
      /**
       * Get Block by index
       *
       * @param {number} index  Block index
       * @returns {Block}
       */
      get(e2) {
        return this.blocks[e2];
      }
      /**
       * Return index of passed Block
       *
       * @param {Block} block - Block to find
       * @returns {number}
       */
      indexOf(e2) {
        return this.blocks.indexOf(e2);
      }
      /**
       * Insert new Block into DOM
       *
       * @param {Block} block - Block to insert
       * @param {InsertPosition} position  insert position (if set, will use insertAdjacentElement)
       * @param {Block} target  Block related to position
       */
      insertToDOM(e2, t2, o2) {
        t2 ? o2.holder.insertAdjacentElement(t2, e2.holder) : this.workingArea.appendChild(e2.holder), e2.call(q.RENDERED);
      }
      /**
       * Composes Block event with passed type and details
       *
       * @param {string} type - event type
       * @param {object} detail - event detail
       */
      composeBlockEvent(e2, t2) {
        return new CustomEvent(e2, {
          detail: t2
        });
      }
    }
    const et = "block-removed", tt = "block-added", qo = "block-moved", ot = "block-changed";
    class Zo {
      constructor() {
        this.completed = Promise.resolve();
      }
      /**
       * Add new promise to queue
       *
       * @param operation - promise should be added to queue
       */
      add(e2) {
        return new Promise((t2, o2) => {
          this.completed = this.completed.then(e2).then(t2).catch(o2);
        });
      }
    }
    class Go extends C {
      constructor() {
        super(...arguments), this._currentBlockIndex = -1, this._blocks = null;
      }
      /**
       * Returns current Block index
       *
       * @returns {number}
       */
      get currentBlockIndex() {
        return this._currentBlockIndex;
      }
      /**
       * Set current Block index and fire Block lifecycle callbacks
       *
       * @param {number} newIndex - index of Block to set as current
       */
      set currentBlockIndex(e2) {
        this._currentBlockIndex = e2;
      }
      /**
       * returns first Block
       *
       * @returns {Block}
       */
      get firstBlock() {
        return this._blocks[0];
      }
      /**
       * returns last Block
       *
       * @returns {Block}
       */
      get lastBlock() {
        return this._blocks[this._blocks.length - 1];
      }
      /**
       * Get current Block instance
       *
       * @returns {Block}
       */
      get currentBlock() {
        return this._blocks[this.currentBlockIndex];
      }
      /**
       * Set passed Block as a current
       *
       * @param block - block to set as a current
       */
      set currentBlock(e2) {
        this.currentBlockIndex = this.getBlockIndex(e2);
      }
      /**
       * Returns next Block instance
       *
       * @returns {Block|null}
       */
      get nextBlock() {
        return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];
      }
      /**
       * Return first Block with inputs after current Block
       *
       * @returns {Block | undefined}
       */
      get nextContentfulBlock() {
        return this.blocks.slice(this.currentBlockIndex + 1).find((t2) => !!t2.inputs.length);
      }
      /**
       * Return first Block with inputs before current Block
       *
       * @returns {Block | undefined}
       */
      get previousContentfulBlock() {
        return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t2) => !!t2.inputs.length);
      }
      /**
       * Returns previous Block instance
       *
       * @returns {Block|null}
       */
      get previousBlock() {
        return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];
      }
      /**
       * Get array of Block instances
       *
       * @returns {Block[]} {@link Blocks#array}
       */
      get blocks() {
        return this._blocks.array;
      }
      /**
       * Check if each Block is empty
       *
       * @returns {boolean}
       */
      get isEditorEmpty() {
        return this.blocks.every((e2) => e2.isEmpty);
      }
      /**
       * Should be called after Editor.UI preparation
       * Define this._blocks property
       */
      prepare() {
        const e2 = new Te(this.Editor.UI.nodes.redactor);
        this._blocks = new Proxy(e2, {
          set: Te.set,
          get: Te.get
        }), this.listeners.on(
          document,
          "copy",
          (t2) => this.Editor.BlockEvents.handleCommandC(t2)
        );
      }
      /**
       * Toggle read-only state
       *
       * If readOnly is true:
       *  - Unbind event handlers from created Blocks
       *
       * if readOnly is false:
       *  - Bind event handlers to all existing Blocks
       *
       * @param {boolean} readOnlyEnabled - "read only" state
       */
      toggleReadOnly(e2) {
        e2 ? this.disableModuleBindings() : this.enableModuleBindings();
      }
      /**
       * Creates Block instance by tool name
       *
       * @param {object} options - block creation options
       * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}
       * @param {string} [options.id] - unique id for this block
       * @param {BlockToolData} [options.data] - constructor params
       * @returns {Block}
       */
      composeBlock({
        tool: e2,
        data: t2 = {},
        id: o2 = void 0,
        tunes: i2 = {}
      }) {
        const n2 = this.Editor.ReadOnly.isEnabled, r2 = this.Editor.Tools.blockTools.get(e2), a2 = new F$1({
          id: o2,
          data: t2,
          tool: r2,
          api: this.Editor.API,
          readOnly: n2,
          tunesData: i2
        }, this.eventsDispatcher);
        return n2 || window.requestIdleCallback(() => {
          this.bindBlockEvents(a2);
        }, { timeout: 2e3 }), a2;
      }
      /**
       * Insert new block into _blocks
       *
       * @param {object} options - insert options
       * @param {string} [options.id] - block's unique id
       * @param {string} [options.tool] - plugin name, by default method inserts the default block type
       * @param {object} [options.data] - plugin data
       * @param {number} [options.index] - index where to insert new Block
       * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index
       * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one
       * @returns {Block}
       */
      insert({
        id: e2 = void 0,
        tool: t2 = this.config.defaultBlock,
        data: o2 = {},
        index: i2,
        needToFocus: n2 = true,
        replace: r2 = false,
        tunes: a2 = {}
      } = {}) {
        let l2 = i2;
        l2 === void 0 && (l2 = this.currentBlockIndex + (r2 ? 0 : 1));
        const c2 = this.composeBlock({
          id: e2,
          tool: t2,
          data: o2,
          tunes: a2
        });
        return r2 && this.blockDidMutated(et, this.getBlockByIndex(l2), {
          index: l2
        }), this._blocks.insert(l2, c2, r2), this.blockDidMutated(tt, c2, {
          index: l2
        }), n2 ? this.currentBlockIndex = l2 : l2 <= this.currentBlockIndex && this.currentBlockIndex++, c2;
      }
      /**
       * Inserts several blocks at once
       *
       * @param blocks - blocks to insert
       * @param index - index where to insert
       */
      insertMany(e2, t2 = 0) {
        this._blocks.insertMany(e2, t2);
      }
      /**
       * Update Block data.
       *
       * Currently we don't have an 'update' method in the Tools API, so we just create a new block with the same id and type
       * Should not trigger 'block-removed' or 'block-added' events
       *
       * @param block - block to update
       * @param data - new data
       */
      async update(e2, t2) {
        const o2 = await e2.data, i2 = this.composeBlock({
          id: e2.id,
          tool: e2.name,
          data: Object.assign({}, o2, t2),
          tunes: e2.tunes
        }), n2 = this.getBlockIndex(e2);
        return this._blocks.replace(n2, i2), this.blockDidMutated(ot, i2, {
          index: n2
        }), i2;
      }
      /**
       * Replace passed Block with the new one with specified Tool and data
       *
       * @param block - block to replace
       * @param newTool - new Tool name
       * @param data - new Tool data
       */
      replace(e2, t2, o2) {
        const i2 = this.getBlockIndex(e2);
        this.insert({
          tool: t2,
          data: o2,
          index: i2,
          replace: true
        });
      }
      /**
       * Insert pasted content. Call onPaste callback after insert.
       *
       * @param {string} toolName - name of Tool to insert
       * @param {PasteEvent} pasteEvent - pasted data
       * @param {boolean} replace - should replace current block
       */
      paste(e2, t2, o2 = false) {
        const i2 = this.insert({
          tool: e2,
          replace: o2
        });
        try {
          window.requestIdleCallback(() => {
            i2.call(q.ON_PASTE, t2);
          });
        } catch (n2) {
          L$1(`${e2}: onPaste callback call is failed`, "error", n2);
        }
        return i2;
      }
      /**
       * Insert new default block at passed index
       *
       * @param {number} index - index where Block should be inserted
       * @param {boolean} needToFocus - if true, updates current Block index
       *
       * TODO: Remove method and use insert() with index instead (?)
       * @returns {Block} inserted Block
       */
      insertDefaultBlockAtIndex(e2, t2 = false) {
        const o2 = this.composeBlock({ tool: this.config.defaultBlock });
        return this._blocks[e2] = o2, this.blockDidMutated(tt, o2, {
          index: e2
        }), t2 ? this.currentBlockIndex = e2 : e2 <= this.currentBlockIndex && this.currentBlockIndex++, o2;
      }
      /**
       * Always inserts at the end
       *
       * @returns {Block}
       */
      insertAtEnd() {
        return this.currentBlockIndex = this.blocks.length - 1, this.insert();
      }
      /**
       * Merge two blocks
       *
       * @param {Block} targetBlock - previous block will be append to this block
       * @param {Block} blockToMerge - block that will be merged with target block
       * @returns {Promise} - the sequence that can be continued
       */
      async mergeBlocks(e2, t2) {
        const o2 = await t2.data;
        V(o2) || await e2.mergeWith(o2), this.removeBlock(t2), this.currentBlockIndex = this._blocks.indexOf(e2);
      }
      /**
       * Remove passed Block
       *
       * @param block - Block to remove
       * @param addLastBlock - if true, adds new default block at the end. @todo remove this logic and use event-bus instead
       */
      removeBlock(e2, t2 = true) {
        return new Promise((o2) => {
          const i2 = this._blocks.indexOf(e2);
          if (!this.validateIndex(i2))
            throw new Error("Can't find a Block to remove");
          e2.destroy(), this._blocks.remove(i2), this.blockDidMutated(et, e2, {
            index: i2
          }), this.currentBlockIndex >= i2 && this.currentBlockIndex--, this.blocks.length ? i2 === 0 && (this.currentBlockIndex = 0) : (this.currentBlockIndex = -1, t2 && this.insert()), o2();
        });
      }
      /**
       * Remove only selected Blocks
       * and returns first Block index where started removing...
       *
       * @returns {number|undefined}
       */
      removeSelectedBlocks() {
        let e2;
        for (let t2 = this.blocks.length - 1; t2 >= 0; t2--)
          this.blocks[t2].selected && (this.removeBlock(this.blocks[t2]), e2 = t2);
        return e2;
      }
      /**
       * Attention!
       * After removing insert the new default typed Block and focus on it
       * Removes all blocks
       */
      removeAllBlocks() {
        for (let e2 = this.blocks.length - 1; e2 >= 0; e2--)
          this._blocks.remove(e2);
        this.currentBlockIndex = -1, this.insert(), this.currentBlock.firstInput.focus();
      }
      /**
       * Split current Block
       * 1. Extract content from Caret position to the Block`s end
       * 2. Insert a new Block below current one with extracted content
       *
       * @returns {Block}
       */
      split() {
        const e2 = this.Editor.Caret.extractFragmentFromCaretPosition(), t2 = d$1.make("div");
        t2.appendChild(e2);
        const o2 = {
          text: d$1.isEmpty(t2) ? "" : t2.innerHTML
        };
        return this.insert({ data: o2 });
      }
      /**
       * Returns Block by passed index
       *
       * @param {number} index - index to get. -1 to get last
       * @returns {Block}
       */
      getBlockByIndex(e2) {
        return e2 === -1 && (e2 = this._blocks.length - 1), this._blocks[e2];
      }
      /**
       * Returns an index for passed Block
       *
       * @param block - block to find index
       */
      getBlockIndex(e2) {
        return this._blocks.indexOf(e2);
      }
      /**
       * Returns the Block by passed id
       *
       * @param id - id of block to get
       * @returns {Block}
       */
      getBlockById(e2) {
        return this._blocks.array.find((t2) => t2.id === e2);
      }
      /**
       * Get Block instance by html element
       *
       * @param {Node} element - html element to get Block by
       */
      getBlock(e2) {
        d$1.isElement(e2) || (e2 = e2.parentNode);
        const t2 = this._blocks.nodes, o2 = e2.closest(`.${F$1.CSS.wrapper}`), i2 = t2.indexOf(o2);
        if (i2 >= 0)
          return this._blocks[i2];
      }
      /**
       * Remove selection from all Blocks then highlight only Current Block
       */
      highlightCurrentNode() {
        this.clearFocused(), this.currentBlock.focused = true;
      }
      /**
       * Remove selection from all Blocks
       */
      clearFocused() {
        this.blocks.forEach((e2) => {
          e2.focused = false;
        });
      }
      /**
       * 1) Find first-level Block from passed child Node
       * 2) Mark it as current
       *
       * @param {Node} childNode - look ahead from this node.
       * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance
       */
      setCurrentBlockByChildNode(e2) {
        d$1.isElement(e2) || (e2 = e2.parentNode);
        const t2 = e2.closest(`.${F$1.CSS.wrapper}`);
        if (!t2)
          return;
        const o2 = t2.closest(`.${this.Editor.UI.CSS.editorWrapper}`);
        if (o2 != null && o2.isEqualNode(this.Editor.UI.nodes.wrapper))
          return this.currentBlockIndex = this._blocks.nodes.indexOf(t2), this.currentBlock.updateCurrentInput(), this.currentBlock;
      }
      /**
       * Return block which contents passed node
       *
       * @param {Node} childNode - node to get Block by
       * @returns {Block}
       */
      getBlockByChildNode(e2) {
        d$1.isElement(e2) || (e2 = e2.parentNode);
        const t2 = e2.closest(`.${F$1.CSS.wrapper}`);
        return this.blocks.find((o2) => o2.holder === t2);
      }
      /**
       * Swap Blocks Position
       *
       * @param {number} fromIndex - index of first block
       * @param {number} toIndex - index of second block
       * @deprecated  use 'move' instead
       */
      swap(e2, t2) {
        this._blocks.swap(e2, t2), this.currentBlockIndex = t2;
      }
      /**
       * Move a block to a new index
       *
       * @param {number} toIndex - index where to move Block
       * @param {number} fromIndex - index of Block to move
       */
      move(e2, t2 = this.currentBlockIndex) {
        if (isNaN(e2) || isNaN(t2)) {
          L$1("Warning during 'move' call: incorrect indices provided.", "warn");
          return;
        }
        if (!this.validateIndex(e2) || !this.validateIndex(t2)) {
          L$1("Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.", "warn");
          return;
        }
        this._blocks.move(e2, t2), this.currentBlockIndex = e2, this.blockDidMutated(qo, this.currentBlock, {
          fromIndex: t2,
          toIndex: e2
        });
      }
      /**
       * Converts passed Block to the new Tool
       * Uses Conversion Config
       *
       * @param blockToConvert - Block that should be converted
       * @param targetToolName - name of the Tool to convert to
       * @param blockDataOverrides - optional new Block data overrides
       */
      async convert(e2, t2, o2) {
        if (!await e2.save())
          throw new Error("Could not convert Block. Failed to extract original Block data.");
        const n2 = this.Editor.Tools.blockTools.get(t2);
        if (!n2)
          throw new Error(`Could not convert Block. Tool ${t2} not found.`);
        const r2 = await e2.exportDataAsString(), a2 = Z(
          r2,
          n2.sanitizeConfig
        );
        let l2 = Jt(a2, n2.conversionConfig);
        o2 && (l2 = Object.assign(l2, o2)), this.replace(e2, n2.name, l2);
      }
      /**
       * Sets current Block Index -1 which means unknown
       * and clear highlights
       */
      dropPointer() {
        this.currentBlockIndex = -1, this.clearFocused();
      }
      /**
       * Clears Editor
       *
       * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)
       *                                             we don't need to add an empty default block
       *                                        2) in api.blocks.clear we should add empty block
       */
      async clear(e2 = false) {
        const t2 = new Zo();
        this.blocks.forEach((o2) => {
          t2.add(async () => {
            await this.removeBlock(o2, false);
          });
        }), await t2.completed, this.dropPointer(), e2 && this.insert(), this.Editor.UI.checkEmptiness();
      }
      /**
       * Cleans up all the block tools' resources
       * This is called when editor is destroyed
       */
      async destroy() {
        await Promise.all(this.blocks.map((e2) => e2.destroy()));
      }
      /**
       * Bind Block events
       *
       * @param {Block} block - Block to which event should be bound
       */
      bindBlockEvents(e2) {
        const { BlockEvents: t2 } = this.Editor;
        this.readOnlyMutableListeners.on(e2.holder, "keydown", (o2) => {
          t2.keydown(o2);
        }), this.readOnlyMutableListeners.on(e2.holder, "keyup", (o2) => {
          t2.keyup(o2);
        }), this.readOnlyMutableListeners.on(e2.holder, "dragover", (o2) => {
          t2.dragOver(o2);
        }), this.readOnlyMutableListeners.on(e2.holder, "dragleave", (o2) => {
          t2.dragLeave(o2);
        }), e2.on("didMutated", (o2) => this.blockDidMutated(ot, o2, {
          index: this.getBlockIndex(o2)
        }));
      }
      /**
       * Disable mutable handlers and bindings
       */
      disableModuleBindings() {
        this.readOnlyMutableListeners.clearAll();
      }
      /**
       * Enables all module handlers and bindings for all Blocks
       */
      enableModuleBindings() {
        this.readOnlyMutableListeners.on(
          document,
          "cut",
          (e2) => this.Editor.BlockEvents.handleCommandX(e2)
        ), this.blocks.forEach((e2) => {
          this.bindBlockEvents(e2);
        });
      }
      /**
       * Validates that the given index is not lower than 0 or higher than the amount of blocks
       *
       * @param {number} index - index of blocks array to validate
       * @returns {boolean}
       */
      validateIndex(e2) {
        return !(e2 < 0 || e2 >= this._blocks.length);
      }
      /**
       * Block mutation callback
       *
       * @param mutationType - what happened with block
       * @param block - mutated block
       * @param detailData - additional data to pass with change event
       */
      blockDidMutated(e2, t2, o2) {
        const i2 = new CustomEvent(e2, {
          detail: {
            target: new ee(t2),
            ...o2
          }
        });
        return this.eventsDispatcher.emit(ct, {
          event: i2
        }), t2;
      }
    }
    class Jo extends C {
      constructor() {
        super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
      }
      /**
       * Sanitizer Config
       *
       * @returns {SanitizerConfig}
       */
      get sanitizerConfig() {
        return {
          p: {},
          h1: {},
          h2: {},
          h3: {},
          h4: {},
          h5: {},
          h6: {},
          ol: {},
          ul: {},
          li: {},
          br: true,
          img: {
            src: true,
            width: true,
            height: true
          },
          a: {
            href: true
          },
          b: {},
          i: {},
          u: {}
        };
      }
      /**
       * Flag that identifies all Blocks selection
       *
       * @returns {boolean}
       */
      get allBlocksSelected() {
        const { BlockManager: e2 } = this.Editor;
        return e2.blocks.every((t2) => t2.selected === true);
      }
      /**
       * Set selected all blocks
       *
       * @param {boolean} state - state to set
       */
      set allBlocksSelected(e2) {
        const { BlockManager: t2 } = this.Editor;
        t2.blocks.forEach((o2) => {
          o2.selected = e2;
        }), this.clearCache();
      }
      /**
       * Flag that identifies any Block selection
       *
       * @returns {boolean}
       */
      get anyBlockSelected() {
        const { BlockManager: e2 } = this.Editor;
        return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e2.blocks.some((t2) => t2.selected === true)), this.anyBlockSelectedCache;
      }
      /**
       * Return selected Blocks array
       *
       * @returns {Block[]}
       */
      get selectedBlocks() {
        return this.Editor.BlockManager.blocks.filter((e2) => e2.selected);
      }
      /**
       * Module Preparation
       * Registers Shortcuts CMD+A and CMD+C
       * to select all and copy them
       */
      prepare() {
        this.selection = new m$1(), le.add({
          name: "CMD+A",
          handler: (e2) => {
            const { BlockManager: t2, ReadOnly: o2 } = this.Editor;
            if (o2.isEnabled) {
              e2.preventDefault(), this.selectAllBlocks();
              return;
            }
            t2.currentBlock && this.handleCommandA(e2);
          },
          on: this.Editor.UI.nodes.redactor
        });
      }
      /**
       * Toggle read-only state
       *
       *  - Remove all ranges
       *  - Unselect all Blocks
       */
      toggleReadOnly() {
        m$1.get().removeAllRanges(), this.allBlocksSelected = false;
      }
      /**
       * Remove selection of Block
       *
       * @param {number?} index - Block index according to the BlockManager's indexes
       */
      unSelectBlockByIndex(e2) {
        const { BlockManager: t2 } = this.Editor;
        let o2;
        isNaN(e2) ? o2 = t2.currentBlock : o2 = t2.getBlockByIndex(e2), o2.selected = false, this.clearCache();
      }
      /**
       * Clear selection from Blocks
       *
       * @param {Event} reason - event caused clear of selection
       * @param {boolean} restoreSelection - if true, restore saved selection
       */
      clearSelection(e2, t2 = false) {
        const { BlockManager: o2, Caret: i2, RectangleSelection: n2 } = this.Editor;
        this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
        const r2 = e2 && e2 instanceof KeyboardEvent, a2 = r2 && nt(e2.keyCode);
        if (this.anyBlockSelected && r2 && a2 && !m$1.isSelectionExists) {
          const l2 = o2.removeSelectedBlocks();
          o2.insertDefaultBlockAtIndex(l2, true), i2.setToBlock(o2.currentBlock), re(() => {
            const c2 = e2.key;
            i2.insertContentAtCaretPosition(c2.length > 1 ? "" : c2);
          }, 20)();
        }
        if (this.Editor.CrossBlockSelection.clear(e2), !this.anyBlockSelected || n2.isRectActivated()) {
          this.Editor.RectangleSelection.clearSelection();
          return;
        }
        t2 && this.selection.restore(), this.allBlocksSelected = false;
      }
      /**
       * Reduce each Block and copy its content
       *
       * @param {ClipboardEvent} e - copy/cut event
       * @returns {Promise<void>}
       */
      copySelectedBlocks(e2) {
        e2.preventDefault();
        const t2 = d$1.make("div");
        this.selectedBlocks.forEach((n2) => {
          const r2 = Z(n2.holder.innerHTML, this.sanitizerConfig), a2 = d$1.make("p");
          a2.innerHTML = r2, t2.appendChild(a2);
        });
        const o2 = Array.from(t2.childNodes).map((n2) => n2.textContent).join(`

`), i2 = t2.innerHTML;
        return e2.clipboardData.setData("text/plain", o2), e2.clipboardData.setData("text/html", i2), Promise.all(this.selectedBlocks.map((n2) => n2.save())).then((n2) => {
          try {
            e2.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(n2));
          } catch {
          }
        });
      }
      /**
       * select Block
       *
       * @param {number?} index - Block index according to the BlockManager's indexes
       */
      selectBlockByIndex(e2) {
        const { BlockManager: t2 } = this.Editor;
        t2.clearFocused();
        let o2;
        isNaN(e2) ? o2 = t2.currentBlock : o2 = t2.getBlockByIndex(e2), this.selection.save(), m$1.get().removeAllRanges(), o2.selected = true, this.clearCache(), this.Editor.InlineToolbar.close();
      }
      /**
       * Clear anyBlockSelected cache
       */
      clearCache() {
        this.anyBlockSelectedCache = null;
      }
      /**
       * Module destruction
       * De-registers Shortcut CMD+A
       */
      destroy() {
        le.remove(this.Editor.UI.nodes.redactor, "CMD+A");
      }
      /**
       * First CMD+A selects all input content by native behaviour,
       * next CMD+A keypress selects all blocks
       *
       * @param {KeyboardEvent} event - keyboard event
       */
      handleCommandA(e2) {
        if (this.Editor.RectangleSelection.clearSelection(), d$1.isNativeInput(e2.target) && !this.readyToBlockSelection) {
          this.readyToBlockSelection = true;
          return;
        }
        const o2 = this.Editor.BlockManager.getBlock(e2.target).inputs;
        if (o2.length > 1 && !this.readyToBlockSelection) {
          this.readyToBlockSelection = true;
          return;
        }
        if (o2.length === 1 && !this.needToSelectAll) {
          this.needToSelectAll = true;
          return;
        }
        this.needToSelectAll ? (e2.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = false, this.readyToBlockSelection = false, this.Editor.ConversionToolbar.close()) : this.readyToBlockSelection && (e2.preventDefault(), this.selectBlockByIndex(), this.needToSelectAll = true);
      }
      /**
       * Select All Blocks
       * Each Block has selected setter that makes Block copyable
       */
      selectAllBlocks() {
        this.selection.save(), m$1.get().removeAllRanges(), this.allBlocksSelected = true, this.Editor.InlineToolbar.close();
      }
    }
    class ve extends C {
      /**
       * Allowed caret positions in input
       *
       * @static
       * @returns {{START: string, END: string, DEFAULT: string}}
       */
      get positions() {
        return {
          START: "start",
          END: "end",
          DEFAULT: "default"
        };
      }
      /**
       * Elements styles that can be useful for Caret Module
       */
      static get CSS() {
        return {
          shadowCaret: "cdx-shadow-caret"
        };
      }
      /**
       * Get's deepest first node and checks if offset is zero
       *
       * @returns {boolean}
       */
      get isAtStart() {
        const e2 = m$1.get(), t2 = d$1.getDeepestNode(this.Editor.BlockManager.currentBlock.currentInput);
        let o2 = e2.focusNode;
        if (d$1.isNativeInput(t2))
          return t2.selectionEnd === 0;
        if (!e2.anchorNode)
          return false;
        let i2 = o2.textContent.search(/\S/);
        i2 === -1 && (i2 = 0);
        let n2 = e2.focusOffset;
        return o2.nodeType !== Node.TEXT_NODE && o2.childNodes.length && (o2.childNodes[n2] ? (o2 = o2.childNodes[n2], n2 = 0) : (o2 = o2.childNodes[n2 - 1], n2 = o2.textContent.length)), (d$1.isLineBreakTag(t2) || d$1.isEmpty(t2)) && this.getHigherLevelSiblings(o2, "left").every((l2) => {
          const c2 = d$1.isLineBreakTag(l2), u2 = l2.children.length === 1 && d$1.isLineBreakTag(l2.children[0]), h2 = c2 || u2;
          return d$1.isEmpty(l2) && !h2;
        }) && n2 === i2 ? true : t2 === null || o2 === t2 && n2 <= i2;
      }
      /**
       * Get's deepest last node and checks if offset is last node text length
       *
       * @returns {boolean}
       */
      get isAtEnd() {
        const e2 = m$1.get();
        let t2 = e2.focusNode;
        const o2 = d$1.getDeepestNode(this.Editor.BlockManager.currentBlock.currentInput, true);
        if (d$1.isNativeInput(o2))
          return o2.selectionEnd === o2.value.length;
        if (!e2.focusNode)
          return false;
        let i2 = e2.focusOffset;
        if (t2.nodeType !== Node.TEXT_NODE && t2.childNodes.length && (t2.childNodes[i2 - 1] ? (t2 = t2.childNodes[i2 - 1], i2 = t2.textContent.length) : (t2 = t2.childNodes[0], i2 = 0)), d$1.isLineBreakTag(o2) || d$1.isEmpty(o2)) {
          const r2 = this.getHigherLevelSiblings(t2, "right");
          if (r2.every((l2, c2) => c2 === r2.length - 1 && d$1.isLineBreakTag(l2) || d$1.isEmpty(l2) && !d$1.isLineBreakTag(l2)) && i2 === t2.textContent.length)
            return true;
        }
        const n2 = o2.textContent.replace(/\s+$/, "");
        return t2 === o2 && i2 >= n2.length;
      }
      /**
       * Method gets Block instance and puts caret to the text node with offset
       * There two ways that method applies caret position:
       *   - first found text node: sets at the beginning, but you can pass an offset
       *   - last found text node: sets at the end of the node. Also, you can customize the behaviour
       *
       * @param {Block} block - Block class
       * @param {string} position - position where to set caret.
       *                            If default - leave default behaviour and apply offset if it's passed
       * @param {number} offset - caret offset regarding to the text node
       */
      setToBlock(e2, t2 = this.positions.DEFAULT, o2 = 0) {
        const { BlockManager: i2 } = this.Editor;
        let n2;
        switch (t2) {
          case this.positions.START:
            n2 = e2.firstInput;
            break;
          case this.positions.END:
            n2 = e2.lastInput;
            break;
          default:
            n2 = e2.currentInput;
        }
        if (!n2)
          return;
        const r2 = d$1.getDeepestNode(n2, t2 === this.positions.END), a2 = d$1.getContentLength(r2);
        switch (true) {
          case t2 === this.positions.START:
            o2 = 0;
            break;
          case t2 === this.positions.END:
          case o2 > a2:
            o2 = a2;
            break;
        }
        re(() => {
          this.set(r2, o2);
        }, 20)(), i2.setCurrentBlockByChildNode(e2.holder), i2.currentBlock.currentInput = n2;
      }
      /**
       * Set caret to the current input of current Block.
       *
       * @param {HTMLElement} input - input where caret should be set
       * @param {string} position - position of the caret.
       *                            If default - leave default behaviour and apply offset if it's passed
       * @param {number} offset - caret offset regarding to the text node
       */
      setToInput(e2, t2 = this.positions.DEFAULT, o2 = 0) {
        const { currentBlock: i2 } = this.Editor.BlockManager, n2 = d$1.getDeepestNode(e2);
        switch (t2) {
          case this.positions.START:
            this.set(n2, 0);
            break;
          case this.positions.END:
            this.set(n2, d$1.getContentLength(n2));
            break;
          default:
            o2 && this.set(n2, o2);
        }
        i2.currentInput = e2;
      }
      /**
       * Creates Document Range and sets caret to the element with offset
       *
       * @param {HTMLElement} element - target node.
       * @param {number} offset - offset
       */
      set(e2, t2 = 0) {
        const { top: o2, bottom: i2 } = m$1.setCursor(e2, t2), { innerHeight: n2 } = window;
        o2 < 0 && window.scrollBy(0, o2), i2 > n2 && window.scrollBy(0, i2 - n2);
      }
      /**
       * Set Caret to the last Block
       * If last block is not empty, append another empty block
       */
      setToTheLastBlock() {
        const e2 = this.Editor.BlockManager.lastBlock;
        if (e2)
          if (e2.tool.isDefault && e2.isEmpty)
            this.setToBlock(e2);
          else {
            const t2 = this.Editor.BlockManager.insertAtEnd();
            this.setToBlock(t2);
          }
      }
      /**
       * Extract content fragment of current Block from Caret position to the end of the Block
       */
      extractFragmentFromCaretPosition() {
        const e2 = m$1.get();
        if (e2.rangeCount) {
          const t2 = e2.getRangeAt(0), o2 = this.Editor.BlockManager.currentBlock.currentInput;
          if (t2.deleteContents(), o2)
            if (d$1.isNativeInput(o2)) {
              const i2 = o2, n2 = document.createDocumentFragment(), r2 = i2.value.substring(0, i2.selectionStart), a2 = i2.value.substring(i2.selectionStart);
              return n2.textContent = a2, i2.value = r2, n2;
            } else {
              const i2 = t2.cloneRange();
              return i2.selectNodeContents(o2), i2.setStart(t2.endContainer, t2.endOffset), i2.extractContents();
            }
        }
      }
      /**
       * Set's caret to the next Block or Tool`s input
       * Before moving caret, we should check if caret position is at the end of Plugins node
       * Using {@link Dom#getDeepestNode} to get a last node and match with current selection
       *
       * @returns {boolean}
       */
      navigateNext() {
        const { BlockManager: e2 } = this.Editor, { currentBlock: t2, nextContentfulBlock: o2 } = e2, { nextInput: i2 } = t2, n2 = this.isAtEnd;
        let r2 = o2;
        if (!r2 && !i2) {
          if (t2.tool.isDefault || !n2)
            return false;
          r2 = e2.insertAtEnd();
        }
        return n2 ? (i2 ? this.setToInput(i2, this.positions.START) : this.setToBlock(r2, this.positions.START), true) : false;
      }
      /**
       * Set's caret to the previous Tool`s input or Block
       * Before moving caret, we should check if caret position is start of the Plugins node
       * Using {@link Dom#getDeepestNode} to get a last node and match with current selection
       *
       * @returns {boolean}
       */
      navigatePrevious() {
        const { currentBlock: e2, previousContentfulBlock: t2 } = this.Editor.BlockManager;
        if (!e2)
          return false;
        const { previousInput: o2 } = e2;
        return !t2 && !o2 ? false : this.isAtStart ? (o2 ? this.setToInput(o2, this.positions.END) : this.setToBlock(t2, this.positions.END), true) : false;
      }
      /**
       * Inserts shadow element after passed element where caret can be placed
       *
       * @param {Element} element - element after which shadow caret should be inserted
       */
      createShadow(e2) {
        const t2 = document.createElement("span");
        t2.classList.add(ve.CSS.shadowCaret), e2.insertAdjacentElement("beforeend", t2);
      }
      /**
       * Restores caret position
       *
       * @param {HTMLElement} element - element where caret should be restored
       */
      restoreCaret(e2) {
        const t2 = e2.querySelector(`.${ve.CSS.shadowCaret}`);
        if (!t2)
          return;
        new m$1().expandToTag(t2);
        const i2 = document.createRange();
        i2.selectNode(t2), i2.extractContents();
      }
      /**
       * Inserts passed content at caret position
       *
       * @param {string} content - content to insert
       */
      insertContentAtCaretPosition(e2) {
        const t2 = document.createDocumentFragment(), o2 = document.createElement("div"), i2 = m$1.get(), n2 = m$1.range;
        o2.innerHTML = e2, Array.from(o2.childNodes).forEach((c2) => t2.appendChild(c2)), t2.childNodes.length === 0 && t2.appendChild(new Text());
        const r2 = t2.lastChild;
        n2.deleteContents(), n2.insertNode(t2);
        const a2 = document.createRange(), l2 = r2.nodeType === Node.TEXT_NODE ? r2 : r2.firstChild;
        l2 !== null && l2.textContent !== null && a2.setStart(l2, l2.textContent.length), i2.removeAllRanges(), i2.addRange(a2);
      }
      /**
       * Get all first-level (first child of [contenteditable]) siblings from passed node
       * Then you can check it for emptiness
       *
       * @example
       * <div contenteditable>
       * <p></p>                            |
       * <p></p>                            | left first-level siblings
       * <p></p>                            |
       * <blockquote><a><b>adaddad</b><a><blockquote>       <-- passed node for example <b>
       * <p></p>                            |
       * <p></p>                            | right first-level siblings
       * <p></p>                            |
       * </div>
       * @param {HTMLElement} from - element from which siblings should be searched
       * @param {'left' | 'right'} direction - direction of search
       * @returns {HTMLElement[]}
       */
      getHigherLevelSiblings(e2, t2) {
        let o2 = e2;
        const i2 = [];
        for (; o2.parentNode && o2.parentNode.contentEditable !== "true"; )
          o2 = o2.parentNode;
        const n2 = t2 === "left" ? "previousSibling" : "nextSibling";
        for (; o2[n2]; )
          o2 = o2[n2], i2.push(o2);
        return i2;
      }
    }
    class Qo extends C {
      constructor() {
        super(...arguments), this.onMouseUp = () => {
          this.listeners.off(document, "mouseover", this.onMouseOver), this.listeners.off(document, "mouseup", this.onMouseUp);
        }, this.onMouseOver = (e2) => {
          const { BlockManager: t2, BlockSelection: o2 } = this.Editor, i2 = t2.getBlockByChildNode(e2.relatedTarget) || this.lastSelectedBlock, n2 = t2.getBlockByChildNode(e2.target);
          if (!(!i2 || !n2) && n2 !== i2) {
            if (i2 === this.firstSelectedBlock) {
              m$1.get().removeAllRanges(), i2.selected = true, n2.selected = true, o2.clearCache();
              return;
            }
            if (n2 === this.firstSelectedBlock) {
              i2.selected = false, n2.selected = false, o2.clearCache();
              return;
            }
            this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i2, n2), this.lastSelectedBlock = n2;
          }
        };
      }
      /**
       * Module preparation
       *
       * @returns {Promise}
       */
      async prepare() {
        this.listeners.on(document, "mousedown", (e2) => {
          this.enableCrossBlockSelection(e2);
        });
      }
      /**
       * Sets up listeners
       *
       * @param {MouseEvent} event - mouse down event
       */
      watchSelection(e2) {
        if (e2.button !== _t.LEFT)
          return;
        const { BlockManager: t2 } = this.Editor;
        this.firstSelectedBlock = t2.getBlock(e2.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, "mouseover", this.onMouseOver), this.listeners.on(document, "mouseup", this.onMouseUp);
      }
      /**
       * return boolean is cross block selection started
       */
      get isCrossBlockSelectionStarted() {
        return !!this.firstSelectedBlock && !!this.lastSelectedBlock;
      }
      /**
       * Change selection state of the next Block
       * Used for CBS via Shift + arrow keys
       *
       * @param {boolean} next - if true, toggle next block. Previous otherwise
       */
      toggleBlockSelectedState(e2 = true) {
        const { BlockManager: t2, BlockSelection: o2 } = this.Editor;
        this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t2.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = true, o2.clearCache(), m$1.get().removeAllRanges());
        const i2 = t2.blocks.indexOf(this.lastSelectedBlock) + (e2 ? 1 : -1), n2 = t2.blocks[i2];
        n2 && (this.lastSelectedBlock.selected !== n2.selected ? (n2.selected = true, o2.clearCache()) : (this.lastSelectedBlock.selected = false, o2.clearCache()), this.lastSelectedBlock = n2, this.Editor.InlineToolbar.close(), n2.holder.scrollIntoView({
          block: "nearest"
        }));
      }
      /**
       * Clear saved state
       *
       * @param {Event} reason - event caused clear of selection
       */
      clear(e2) {
        const { BlockManager: t2, BlockSelection: o2, Caret: i2 } = this.Editor, n2 = t2.blocks.indexOf(this.firstSelectedBlock), r2 = t2.blocks.indexOf(this.lastSelectedBlock);
        if (o2.anyBlockSelected && n2 > -1 && r2 > -1)
          if (e2 && e2 instanceof KeyboardEvent)
            switch (e2.keyCode) {
              case B$1.DOWN:
              case B$1.RIGHT:
                i2.setToBlock(t2.blocks[Math.max(n2, r2)], i2.positions.END);
                break;
              case B$1.UP:
              case B$1.LEFT:
                i2.setToBlock(t2.blocks[Math.min(n2, r2)], i2.positions.START);
                break;
              default:
                i2.setToBlock(t2.blocks[Math.max(n2, r2)], i2.positions.END);
            }
          else
            i2.setToBlock(t2.blocks[Math.max(n2, r2)], i2.positions.END);
        this.firstSelectedBlock = this.lastSelectedBlock = null;
      }
      /**
       * Enables Cross Block Selection
       *
       * @param {MouseEvent} event - mouse down event
       */
      enableCrossBlockSelection(e2) {
        const { UI: t2 } = this.Editor;
        m$1.isCollapsed || this.Editor.BlockSelection.clearSelection(e2), t2.nodes.redactor.contains(e2.target) ? this.watchSelection(e2) : this.Editor.BlockSelection.clearSelection(e2);
      }
      /**
       * Change blocks selection state between passed two blocks.
       *
       * @param {Block} firstBlock - first block in range
       * @param {Block} lastBlock - last block in range
       */
      toggleBlocksSelectedState(e2, t2) {
        const { BlockManager: o2, BlockSelection: i2 } = this.Editor, n2 = o2.blocks.indexOf(e2), r2 = o2.blocks.indexOf(t2), a2 = e2.selected !== t2.selected;
        for (let l2 = Math.min(n2, r2); l2 <= Math.max(n2, r2); l2++) {
          const c2 = o2.blocks[l2];
          c2 !== this.firstSelectedBlock && c2 !== (a2 ? e2 : t2) && (o2.blocks[l2].selected = !o2.blocks[l2].selected, i2.clearCache());
        }
      }
    }
    class ei extends C {
      constructor() {
        super(...arguments), this.isStartedAtEditor = false;
      }
      /**
       * Toggle read-only state
       *
       * if state is true:
       *  - disable all drag-n-drop event handlers
       *
       * if state is false:
       *  - restore drag-n-drop event handlers
       *
       * @param {boolean} readOnlyEnabled - "read only" state
       */
      toggleReadOnly(e2) {
        e2 ? this.disableModuleBindings() : this.enableModuleBindings();
      }
      /**
       * Add drag events listeners to editor zone
       */
      enableModuleBindings() {
        const { UI: e2 } = this.Editor;
        this.readOnlyMutableListeners.on(e2.nodes.holder, "drop", async (t2) => {
          await this.processDrop(t2);
        }, true), this.readOnlyMutableListeners.on(e2.nodes.holder, "dragstart", () => {
          this.processDragStart();
        }), this.readOnlyMutableListeners.on(e2.nodes.holder, "dragover", (t2) => {
          this.processDragOver(t2);
        }, true);
      }
      /**
       * Unbind drag-n-drop event handlers
       */
      disableModuleBindings() {
        this.readOnlyMutableListeners.clearAll();
      }
      /**
       * Handle drop event
       *
       * @param {DragEvent} dropEvent - drop event
       */
      async processDrop(e2) {
        const {
          BlockManager: t2,
          Caret: o2,
          Paste: i2
        } = this.Editor;
        e2.preventDefault(), t2.blocks.forEach((r2) => {
          r2.dropTarget = false;
        }), m$1.isAtEditor && !m$1.isCollapsed && this.isStartedAtEditor && document.execCommand("delete"), this.isStartedAtEditor = false;
        const n2 = t2.setCurrentBlockByChildNode(e2.target);
        if (n2)
          this.Editor.Caret.setToBlock(n2, o2.positions.END);
        else {
          const r2 = t2.setCurrentBlockByChildNode(t2.lastBlock.holder);
          this.Editor.Caret.setToBlock(r2, o2.positions.END);
        }
        await i2.processDataTransfer(e2.dataTransfer, true);
      }
      /**
       * Handle drag start event
       */
      processDragStart() {
        m$1.isAtEditor && !m$1.isCollapsed && (this.isStartedAtEditor = true), this.Editor.InlineToolbar.close();
      }
      /**
       * @param {DragEvent} dragEvent - drag event
       */
      processDragOver(e2) {
        e2.preventDefault();
      }
    }
    class ti extends C {
      /**
       * Prepare the module
       *
       * @param options - options used by the modification observer module
       * @param options.config - Editor configuration object
       * @param options.eventsDispatcher - common Editor event bus
       */
      constructor({ config: e2, eventsDispatcher: t2 }) {
        super({
          config: e2,
          eventsDispatcher: t2
        }), this.disabled = false, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = 400, this.mutationObserver = new MutationObserver((o2) => {
          this.redactorChanged(o2);
        }), this.eventsDispatcher.on(ct, (o2) => {
          this.particularBlockChanged(o2.event);
        }), this.eventsDispatcher.on(dt, () => {
          this.disable();
        }), this.eventsDispatcher.on(ht, () => {
          this.enable();
        });
      }
      /**
       * Enables onChange event
       */
      enable() {
        this.mutationObserver.observe(
          this.Editor.UI.nodes.redactor,
          {
            childList: true,
            subtree: true,
            characterData: true,
            attributes: true
          }
        ), this.disabled = false;
      }
      /**
       * Disables onChange event
       */
      disable() {
        this.mutationObserver.disconnect(), this.disabled = true;
      }
      /**
       * Call onChange event passed to Editor.js configuration
       *
       * @param event - some of our custom change events
       */
      particularBlockChanged(e2) {
        this.disabled || !D$1(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e2.detail.target.id}:event:${e2.type}`, e2), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {
          let t2;
          this.batchingOnChangeQueue.size === 1 ? t2 = this.batchingOnChangeQueue.values().next().value : t2 = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t2), this.batchingOnChangeQueue.clear();
        }, this.batchTime));
      }
      /**
       * Fired on every blocks wrapper dom change
       *
       * @param mutations - mutations happened
       */
      redactorChanged(e2) {
        this.eventsDispatcher.emit(Me, {
          mutations: e2
        });
      }
    }
    const wt = class extends C {
      constructor() {
        super(...arguments), this.MIME_TYPE = "application/x-editor-js", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (s2) => {
          try {
            const e2 = s2.create({}, {}, false);
            if (s2.pasteConfig === false) {
              this.exceptionList.push(s2.name);
              return;
            }
            if (!D$1(e2.onPaste))
              return;
            this.getTagsConfig(s2), this.getFilesConfig(s2), this.getPatternsConfig(s2);
          } catch (e2) {
            L$1(
              `Paste handling for ${s2.name} Tool hasn't been set up because of the error`,
              "warn",
              e2
            );
          }
        }, this.handlePasteEvent = async (s2) => {
          const { BlockManager: e2, Toolbar: t2 } = this.Editor, o2 = e2.setCurrentBlockByChildNode(s2.target);
          !o2 || this.isNativeBehaviour(s2.target) && !s2.clipboardData.types.includes("Files") || o2 && this.exceptionList.includes(o2.name) || (s2.preventDefault(), this.processDataTransfer(s2.clipboardData), e2.clearFocused(), t2.close());
        };
      }
      /**
       * Set onPaste callback and collect tools` paste configurations
       */
      async prepare() {
        this.processTools();
      }
      /**
       * Set read-only state
       *
       * @param {boolean} readOnlyEnabled - read only flag value
       */
      toggleReadOnly(s2) {
        s2 ? this.unsetCallback() : this.setCallback();
      }
      /**
       * Handle pasted or dropped data transfer object
       *
       * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object
       * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events
       */
      async processDataTransfer(s2, e2 = false) {
        const { Tools: t2 } = this.Editor, o2 = s2.types;
        if ((o2.includes ? o2.includes("Files") : o2.contains("Files")) && !V(this.toolsFiles)) {
          await this.processFiles(s2.files);
          return;
        }
        const n2 = s2.getData(this.MIME_TYPE), r2 = s2.getData("text/plain");
        let a2 = s2.getData("text/html");
        if (n2)
          try {
            this.insertEditorJSData(JSON.parse(n2));
            return;
          } catch {
          }
        e2 && r2.trim() && a2.trim() && (a2 = "<p>" + (a2.trim() ? a2 : r2) + "</p>");
        const l2 = Object.keys(this.toolsTags).reduce((h2, f2) => (h2[f2.toLowerCase()] = this.toolsTags[f2].sanitizationConfig ?? {}, h2), {}), c2 = Object.assign({}, l2, t2.getAllInlineToolsSanitizeConfig(), { br: {} }), u2 = Z(a2, c2);
        !u2.trim() || u2.trim() === r2 || !d$1.isHTMLString(u2) ? await this.processText(r2) : await this.processText(u2, true);
      }
      /**
       * Process pasted text and divide them into Blocks
       *
       * @param {string} data - text to process. Can be HTML or plain.
       * @param {boolean} isHTML - if passed string is HTML, this parameter should be true
       */
      async processText(s2, e2 = false) {
        const { Caret: t2, BlockManager: o2 } = this.Editor, i2 = e2 ? this.processHTML(s2) : this.processPlain(s2);
        if (!i2.length)
          return;
        if (i2.length === 1) {
          i2[0].isBlock ? this.processSingleBlock(i2.pop()) : this.processInlinePaste(i2.pop());
          return;
        }
        const r2 = o2.currentBlock && o2.currentBlock.tool.isDefault && o2.currentBlock.isEmpty;
        i2.map(
          async (a2, l2) => this.insertBlock(a2, l2 === 0 && r2)
        ), o2.currentBlock && t2.setToBlock(o2.currentBlock, t2.positions.END);
      }
      /**
       * Set onPaste callback handler
       */
      setCallback() {
        this.listeners.on(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
      }
      /**
       * Unset onPaste callback handler
       */
      unsetCallback() {
        this.listeners.off(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
      }
      /**
       * Get and process tool`s paste configs
       */
      processTools() {
        const s2 = this.Editor.Tools.blockTools;
        Array.from(s2.values()).forEach(this.processTool);
      }
      /**
       * Get tags name list from either tag name or sanitization config.
       *
       * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.
       * @returns {string[]} array of tags.
       */
      collectTagNames(s2) {
        return J(s2) ? [s2] : z(s2) ? Object.keys(s2) : [];
      }
      /**
       * Get tags to substitute by Tool
       *
       * @param tool - BlockTool object
       */
      getTagsConfig(s2) {
        if (s2.pasteConfig === false)
          return;
        const e2 = s2.pasteConfig.tags || [], t2 = [];
        e2.forEach((o2) => {
          const i2 = this.collectTagNames(o2);
          t2.push(...i2), i2.forEach((n2) => {
            if (Object.prototype.hasOwnProperty.call(this.toolsTags, n2)) {
              L$1(
                `Paste handler for ${s2.name} Tool on ${n2} tag is skipped because it is already used by ${this.toolsTags[n2].tool.name} Tool.`,
                "warn"
              );
              return;
            }
            const r2 = z(o2) ? o2[n2] : null;
            this.toolsTags[n2.toUpperCase()] = {
              tool: s2,
              sanitizationConfig: r2
            };
          });
        }), this.tagsByTool[s2.name] = t2.map((o2) => o2.toUpperCase());
      }
      /**
       * Get files` types and extensions to substitute by Tool
       *
       * @param tool - BlockTool object
       */
      getFilesConfig(s2) {
        if (s2.pasteConfig === false)
          return;
        const { files: e2 = {} } = s2.pasteConfig;
        let { extensions: t2, mimeTypes: o2 } = e2;
        !t2 && !o2 || (t2 && !Array.isArray(t2) && (L$1(`extensions property of the onDrop config for ${s2.name} Tool should be an array`), t2 = []), o2 && !Array.isArray(o2) && (L$1(`mimeTypes property of the onDrop config for ${s2.name} Tool should be an array`), o2 = []), o2 && (o2 = o2.filter((i2) => Ft(i2) ? true : (L$1(`MIME type value ${i2} for the ${s2.name} Tool is not a valid MIME type`, "warn"), false))), this.toolsFiles[s2.name] = {
          extensions: t2 || [],
          mimeTypes: o2 || []
        });
      }
      /**
       * Get RegExp patterns to substitute by Tool
       *
       * @param tool - BlockTool object
       */
      getPatternsConfig(s2) {
        s2.pasteConfig === false || !s2.pasteConfig.patterns || V(s2.pasteConfig.patterns) || Object.entries(s2.pasteConfig.patterns).forEach(([e2, t2]) => {
          t2 instanceof RegExp || L$1(
            `Pattern ${t2} for ${s2.name} Tool is skipped because it should be a Regexp instance.`,
            "warn"
          ), this.toolsPatterns.push({
            key: e2,
            pattern: t2,
            tool: s2
          });
        });
      }
      /**
       * Check if browser behavior suits better
       *
       * @param {EventTarget} element - element where content has been pasted
       * @returns {boolean}
       */
      isNativeBehaviour(s2) {
        return d$1.isNativeInput(s2);
      }
      /**
       * Get files from data transfer object and insert related Tools
       *
       * @param {FileList} items - pasted or dropped items
       */
      async processFiles(s2) {
        const { BlockManager: e2 } = this.Editor;
        let t2;
        t2 = await Promise.all(
          Array.from(s2).map((n2) => this.processFile(n2))
        ), t2 = t2.filter((n2) => !!n2);
        const i2 = e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty;
        t2.forEach(
          (n2, r2) => {
            e2.paste(n2.type, n2.event, r2 === 0 && i2);
          }
        );
      }
      /**
       * Get information about file and find Tool to handle it
       *
       * @param {File} file - file to process
       */
      async processFile(s2) {
        const e2 = Pt(s2), t2 = Object.entries(this.toolsFiles).find(([n2, { mimeTypes: r2, extensions: a2 }]) => {
          const [l2, c2] = s2.type.split("/"), u2 = a2.find((f2) => f2.toLowerCase() === e2.toLowerCase()), h2 = r2.find((f2) => {
            const [k2, p2] = f2.split("/");
            return k2 === l2 && (p2 === c2 || p2 === "*");
          });
          return !!u2 || !!h2;
        });
        if (!t2)
          return;
        const [o2] = t2;
        return {
          event: this.composePasteEvent("file", {
            file: s2
          }),
          type: o2
        };
      }
      /**
       * Split HTML string to blocks and return it as array of Block data
       *
       * @param {string} innerHTML - html string to process
       * @returns {PasteData[]}
       */
      processHTML(s2) {
        const { Tools: e2 } = this.Editor, t2 = d$1.make("DIV");
        return t2.innerHTML = s2, this.getNodes(t2).map((i2) => {
          let n2, r2 = e2.defaultTool, a2 = false;
          switch (i2.nodeType) {
            case Node.DOCUMENT_FRAGMENT_NODE:
              n2 = d$1.make("div"), n2.appendChild(i2);
              break;
            case Node.ELEMENT_NODE:
              n2 = i2, a2 = true, this.toolsTags[n2.tagName] && (r2 = this.toolsTags[n2.tagName].tool);
              break;
          }
          const { tags: l2 } = r2.pasteConfig || { tags: [] }, c2 = l2.reduce((f2, k2) => (this.collectTagNames(k2).forEach((v2) => {
            const A2 = z(k2) ? k2[v2] : null;
            f2[v2.toLowerCase()] = A2 || {};
          }), f2), {}), u2 = Object.assign({}, c2, r2.baseSanitizeConfig);
          if (n2.tagName.toLowerCase() === "table") {
            const f2 = Z(n2.outerHTML, u2);
            n2 = d$1.make("div", void 0, {
              innerHTML: f2
            }).firstChild;
          } else
            n2.innerHTML = Z(n2.innerHTML, u2);
          const h2 = this.composePasteEvent("tag", {
            data: n2
          });
          return {
            content: n2,
            isBlock: a2,
            tool: r2.name,
            event: h2
          };
        }).filter((i2) => {
          const n2 = d$1.isEmpty(i2.content), r2 = d$1.isSingleTag(i2.content);
          return !n2 || r2;
        });
      }
      /**
       * Split plain text by new line symbols and return it as array of Block data
       *
       * @param {string} plain - string to process
       * @returns {PasteData[]}
       */
      processPlain(s2) {
        const { defaultBlock: e2 } = this.config;
        if (!s2)
          return [];
        const t2 = e2;
        return s2.split(/\r?\n/).filter((o2) => o2.trim()).map((o2) => {
          const i2 = d$1.make("div");
          i2.textContent = o2;
          const n2 = this.composePasteEvent("tag", {
            data: i2
          });
          return {
            content: i2,
            tool: t2,
            isBlock: false,
            event: n2
          };
        });
      }
      /**
       * Process paste of single Block tool content
       *
       * @param {PasteData} dataToInsert - data of Block to insert
       */
      async processSingleBlock(s2) {
        const { Caret: e2, BlockManager: t2 } = this.Editor, { currentBlock: o2 } = t2;
        if (!o2 || s2.tool !== o2.name || !d$1.containsOnlyInlineElements(s2.content.innerHTML)) {
          this.insertBlock(s2, (o2 == null ? void 0 : o2.tool.isDefault) && o2.isEmpty);
          return;
        }
        e2.insertContentAtCaretPosition(s2.content.innerHTML);
      }
      /**
       * Process paste to single Block:
       * 1. Find patterns` matches
       * 2. Insert new block if it is not the same type as current one
       * 3. Just insert text if there is no substitutions
       *
       * @param {PasteData} dataToInsert - data of Block to insert
       */
      async processInlinePaste(s2) {
        const { BlockManager: e2, Caret: t2 } = this.Editor, { content: o2 } = s2;
        if (e2.currentBlock && e2.currentBlock.tool.isDefault && o2.textContent.length < wt.PATTERN_PROCESSING_MAX_LENGTH) {
          const n2 = await this.processPattern(o2.textContent);
          if (n2) {
            const r2 = e2.currentBlock && e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty, a2 = e2.paste(n2.tool, n2.event, r2);
            t2.setToBlock(a2, t2.positions.END);
            return;
          }
        }
        if (e2.currentBlock && e2.currentBlock.currentInput) {
          const n2 = e2.currentBlock.tool.baseSanitizeConfig;
          document.execCommand(
            "insertHTML",
            false,
            Z(o2.innerHTML, n2)
          );
        } else
          this.insertBlock(s2);
      }
      /**
       * Get patterns` matches
       *
       * @param {string} text - text to process
       * @returns {Promise<{event: PasteEvent, tool: string}>}
       */
      async processPattern(s2) {
        const e2 = this.toolsPatterns.find((o2) => {
          const i2 = o2.pattern.exec(s2);
          return i2 ? s2 === i2.shift() : false;
        });
        return e2 ? {
          event: this.composePasteEvent("pattern", {
            key: e2.key,
            data: s2
          }),
          tool: e2.tool.name
        } : void 0;
      }
      /**
       * Insert pasted Block content to Editor
       *
       * @param {PasteData} data - data to insert
       * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block
       * @returns {void}
       */
      insertBlock(s2, e2 = false) {
        const { BlockManager: t2, Caret: o2 } = this.Editor, { currentBlock: i2 } = t2;
        let n2;
        if (e2 && i2 && i2.isEmpty) {
          n2 = t2.paste(s2.tool, s2.event, true), o2.setToBlock(n2, o2.positions.END);
          return;
        }
        n2 = t2.paste(s2.tool, s2.event), o2.setToBlock(n2, o2.positions.END);
      }
      /**
       * Insert data passed as application/x-editor-js JSON
       *
       * @param {Array} blocks  Blocks' data to insert
       * @returns {void}
       */
      insertEditorJSData(s2) {
        const { BlockManager: e2, Caret: t2, Tools: o2 } = this.Editor;
        ut(
          s2,
          (n2) => o2.blockTools.get(n2).sanitizeConfig
        ).forEach(({ tool: n2, data: r2 }, a2) => {
          let l2 = false;
          a2 === 0 && (l2 = e2.currentBlock && e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty);
          const c2 = e2.insert({
            tool: n2,
            data: r2,
            replace: l2
          });
          t2.setToBlock(c2, t2.positions.END);
        });
      }
      /**
       * Fetch nodes from Element node
       *
       * @param {Node} node - current node
       * @param {Node[]} nodes - processed nodes
       * @param {Node} destNode - destination node
       */
      processElementNode(s2, e2, t2) {
        const o2 = Object.keys(this.toolsTags), i2 = s2, { tool: n2 } = this.toolsTags[i2.tagName] || {}, r2 = this.tagsByTool[n2 == null ? void 0 : n2.name] || [], a2 = o2.includes(i2.tagName), l2 = d$1.blockElements.includes(i2.tagName.toLowerCase()), c2 = Array.from(i2.children).some(
          ({ tagName: h2 }) => o2.includes(h2) && !r2.includes(h2)
        ), u2 = Array.from(i2.children).some(
          ({ tagName: h2 }) => d$1.blockElements.includes(h2.toLowerCase())
        );
        if (!l2 && !a2 && !c2)
          return t2.appendChild(i2), [...e2, t2];
        if (a2 && !c2 || l2 && !u2 && !c2)
          return [...e2, t2, i2];
      }
      /**
       * Recursively divide HTML string to two types of nodes:
       * 1. Block element
       * 2. Document Fragments contained text and markup tags like a, b, i etc.
       *
       * @param {Node} wrapper - wrapper of paster HTML content
       * @returns {Node[]}
       */
      getNodes(s2) {
        const e2 = Array.from(s2.childNodes);
        let t2;
        const o2 = (i2, n2) => {
          if (d$1.isEmpty(n2) && !d$1.isSingleTag(n2))
            return i2;
          const r2 = i2[i2.length - 1];
          let a2 = new DocumentFragment();
          switch (r2 && d$1.isFragment(r2) && (a2 = i2.pop()), n2.nodeType) {
            case Node.ELEMENT_NODE:
              if (t2 = this.processElementNode(n2, i2, a2), t2)
                return t2;
              break;
            case Node.TEXT_NODE:
              return a2.appendChild(n2), [...i2, a2];
            default:
              return [...i2, a2];
          }
          return [...i2, ...Array.from(n2.childNodes).reduce(o2, [])];
        };
        return e2.reduce(o2, []);
      }
      /**
       * Compose paste event with passed type and detail
       *
       * @param {string} type - event type
       * @param {PasteEventDetail} detail - event detail
       */
      composePasteEvent(s2, e2) {
        return new CustomEvent(s2, {
          detail: e2
        });
      }
    };
    let yt = wt;
    yt.PATTERN_PROCESSING_MAX_LENGTH = 450;
    class oi extends C {
      constructor() {
        super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = false;
      }
      /**
       * Returns state of read only mode
       */
      get isEnabled() {
        return this.readOnlyEnabled;
      }
      /**
       * Set initial state
       */
      async prepare() {
        const { Tools: e2 } = this.Editor, { blockTools: t2 } = e2, o2 = [];
        Array.from(t2.entries()).forEach(([i2, n2]) => {
          n2.isReadOnlySupported || o2.push(i2);
        }), this.toolsDontSupportReadOnly = o2, this.config.readOnly && o2.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly);
      }
      /**
       * Set read-only mode or toggle current state
       * Call all Modules `toggleReadOnly` method and re-render Editor
       *
       * @param {boolean} state - (optional) read-only state or toggle
       */
      async toggle(e2 = !this.readOnlyEnabled) {
        e2 && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();
        const t2 = this.readOnlyEnabled;
        this.readOnlyEnabled = e2;
        for (const i2 in this.Editor)
          this.Editor[i2].toggleReadOnly && this.Editor[i2].toggleReadOnly(e2);
        if (t2 === e2)
          return this.readOnlyEnabled;
        const o2 = await this.Editor.Saver.save();
        return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(o2.blocks), this.readOnlyEnabled;
      }
      /**
       * Throws an error about tools which don't support read-only mode
       */
      throwCriticalError() {
        throw new lt(
          `To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(", ")} don't support read-only mode.`
        );
      }
    }
    class fe extends C {
      constructor() {
        super(...arguments), this.isRectSelectionActivated = false, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = false, this.isScrolling = false, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];
      }
      /**
       * CSS classes for the Block
       *
       * @returns {{wrapper: string, content: string}}
       */
      static get CSS() {
        return {
          overlay: "codex-editor-overlay",
          overlayContainer: "codex-editor-overlay__container",
          rect: "codex-editor-overlay__rectangle",
          topScrollZone: "codex-editor-overlay__scroll-zone--top",
          bottomScrollZone: "codex-editor-overlay__scroll-zone--bottom"
        };
      }
      /**
       * Module Preparation
       * Creating rect and hang handlers
       */
      prepare() {
        this.enableModuleBindings();
      }
      /**
       * Init rect params
       *
       * @param {number} pageX - X coord of mouse
       * @param {number} pageY - Y coord of mouse
       */
      startSelection(e2, t2) {
        const o2 = document.elementFromPoint(e2 - window.pageXOffset, t2 - window.pageYOffset);
        o2.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = false, this.clearSelection(), this.stackOfSelected = []);
        const n2 = [
          `.${F$1.CSS.content}`,
          `.${this.Editor.Toolbar.CSS.toolbar}`,
          `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`
        ], r2 = o2.closest("." + this.Editor.UI.CSS.editorWrapper), a2 = n2.some((l2) => !!o2.closest(l2));
        !r2 || a2 || (this.mousedown = true, this.startX = e2, this.startY = t2);
      }
      /**
       * Clear all params to end selection
       */
      endSelection() {
        this.mousedown = false, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = "none";
      }
      /**
       * is RectSelection Activated
       */
      isRectActivated() {
        return this.isRectSelectionActivated;
      }
      /**
       * Mark that selection is end
       */
      clearSelection() {
        this.isRectSelectionActivated = false;
      }
      /**
       * Sets Module necessary event handlers
       */
      enableModuleBindings() {
        const { container: e2 } = this.genHTML();
        this.listeners.on(e2, "mousedown", (t2) => {
          this.processMouseDown(t2);
        }, false), this.listeners.on(document.body, "mousemove", Ce((t2) => {
          this.processMouseMove(t2);
        }, 10), {
          passive: true
        }), this.listeners.on(document.body, "mouseleave", () => {
          this.processMouseLeave();
        }), this.listeners.on(window, "scroll", Ce((t2) => {
          this.processScroll(t2);
        }, 10), {
          passive: true
        }), this.listeners.on(document.body, "mouseup", () => {
          this.processMouseUp();
        }, false);
      }
      /**
       * Handle mouse down events
       *
       * @param {MouseEvent} mouseEvent - mouse event payload
       */
      processMouseDown(e2) {
        if (e2.button !== this.MAIN_MOUSE_BUTTON)
          return;
        e2.target.closest(d$1.allInputsSelector) !== null || this.startSelection(e2.pageX, e2.pageY);
      }
      /**
       * Handle mouse move events
       *
       * @param {MouseEvent} mouseEvent - mouse event payload
       */
      processMouseMove(e2) {
        this.changingRectangle(e2), this.scrollByZones(e2.clientY);
      }
      /**
       * Handle mouse leave
       */
      processMouseLeave() {
        this.clearSelection(), this.endSelection();
      }
      /**
       * @param {MouseEvent} mouseEvent - mouse event payload
       */
      processScroll(e2) {
        this.changingRectangle(e2);
      }
      /**
       * Handle mouse up
       */
      processMouseUp() {
        this.clearSelection(), this.endSelection();
      }
      /**
       * Scroll If mouse in scroll zone
       *
       * @param {number} clientY - Y coord of mouse
       */
      scrollByZones(e2) {
        if (this.inScrollZone = null, e2 <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e2 <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {
          this.isScrolling = false;
          return;
        }
        this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = true);
      }
      /**
       * Generates required HTML elements
       *
       * @returns {Object<string, Element>}
       */
      genHTML() {
        const { UI: e2 } = this.Editor, t2 = e2.nodes.holder.querySelector("." + e2.CSS.editorWrapper), o2 = d$1.make("div", fe.CSS.overlay, {}), i2 = d$1.make("div", fe.CSS.overlayContainer, {}), n2 = d$1.make("div", fe.CSS.rect, {});
        return i2.appendChild(n2), o2.appendChild(i2), t2.appendChild(o2), this.overlayRectangle = n2, {
          container: t2,
          overlay: o2
        };
      }
      /**
       * Activates scrolling if blockSelection is active and mouse is in scroll zone
       *
       * @param {number} speed - speed of scrolling
       */
      scrollVertical(e2) {
        if (!(this.inScrollZone && this.mousedown))
          return;
        const t2 = window.pageYOffset;
        window.scrollBy(0, e2), this.mouseY += window.pageYOffset - t2, setTimeout(() => {
          this.scrollVertical(e2);
        }, 0);
      }
      /**
       * Handles the change in the rectangle and its effect
       *
       * @param {MouseEvent} event - mouse event
       */
      changingRectangle(e2) {
        if (!this.mousedown)
          return;
        e2.pageY !== void 0 && (this.mouseX = e2.pageX, this.mouseY = e2.pageY);
        const { rightPos: t2, leftPos: o2, index: i2 } = this.genInfoForMouseSelection(), n2 = this.startX > t2 && this.mouseX > t2, r2 = this.startX < o2 && this.mouseX < o2;
        this.rectCrossesBlocks = !(n2 || r2), this.isRectSelectionActivated || (this.rectCrossesBlocks = false, this.isRectSelectionActivated = true, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = "block"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i2 !== void 0 && (this.trySelectNextBlock(i2), this.inverseSelection(), m$1.get().removeAllRanges());
      }
      /**
       * Shrink rect to singular point
       */
      shrinkRectangleToPoint() {
        this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;
      }
      /**
       * Select or unselect all of blocks in array if rect is out or in selectable area
       */
      inverseSelection() {
        const t2 = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;
        if (this.rectCrossesBlocks && !t2)
          for (const o2 of this.stackOfSelected)
            this.Editor.BlockSelection.selectBlockByIndex(o2);
        if (!this.rectCrossesBlocks && t2)
          for (const o2 of this.stackOfSelected)
            this.Editor.BlockSelection.unSelectBlockByIndex(o2);
      }
      /**
       * Updates size of rectangle
       */
      updateRectangleSize() {
        this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);
      }
      /**
       * Collects information needed to determine the behavior of the rectangle
       *
       * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border
       */
      genInfoForMouseSelection() {
        const t2 = document.body.offsetWidth / 2, o2 = this.mouseY - window.pageYOffset, i2 = document.elementFromPoint(t2, o2), n2 = this.Editor.BlockManager.getBlockByChildNode(i2);
        let r2;
        n2 !== void 0 && (r2 = this.Editor.BlockManager.blocks.findIndex((h2) => h2.holder === n2.holder));
        const a2 = this.Editor.BlockManager.lastBlock.holder.querySelector("." + F$1.CSS.content), l2 = Number.parseInt(window.getComputedStyle(a2).width, 10) / 2, c2 = t2 - l2, u2 = t2 + l2;
        return {
          index: r2,
          leftPos: c2,
          rightPos: u2
        };
      }
      /**
       * Select block with index index
       *
       * @param index - index of block in redactor
       */
      addBlockInSelection(e2) {
        this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e2), this.stackOfSelected.push(e2);
      }
      /**
       * Adds a block to the selection and determines which blocks should be selected
       *
       * @param {object} index - index of new block in the reactor
       */
      trySelectNextBlock(e2) {
        const t2 = this.stackOfSelected[this.stackOfSelected.length - 1] === e2, o2 = this.stackOfSelected.length, i2 = 1, n2 = -1, r2 = 0;
        if (t2)
          return;
        const a2 = this.stackOfSelected[o2 - 1] - this.stackOfSelected[o2 - 2] > 0;
        let l2 = r2;
        o2 > 1 && (l2 = a2 ? i2 : n2);
        const c2 = e2 > this.stackOfSelected[o2 - 1] && l2 === i2, u2 = e2 < this.stackOfSelected[o2 - 1] && l2 === n2, f2 = !(c2 || u2 || l2 === r2);
        if (!f2 && (e2 > this.stackOfSelected[o2 - 1] || this.stackOfSelected[o2 - 1] === void 0)) {
          let v2 = this.stackOfSelected[o2 - 1] + 1 || e2;
          for (v2; v2 <= e2; v2++)
            this.addBlockInSelection(v2);
          return;
        }
        if (!f2 && e2 < this.stackOfSelected[o2 - 1]) {
          for (let v2 = this.stackOfSelected[o2 - 1] - 1; v2 >= e2; v2--)
            this.addBlockInSelection(v2);
          return;
        }
        if (!f2)
          return;
        let k2 = o2 - 1, p2;
        for (e2 > this.stackOfSelected[o2 - 1] ? p2 = () => e2 > this.stackOfSelected[k2] : p2 = () => e2 < this.stackOfSelected[k2]; p2(); )
          this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[k2]), this.stackOfSelected.pop(), k2--;
      }
    }
    class ii extends C {
      /**
       * Renders passed blocks as one batch
       *
       * @param blocksData - blocks to render
       */
      async render(e2) {
        return new Promise((t2) => {
          const { Tools: o2, BlockManager: i2 } = this.Editor, n2 = e2.map(({ type: r2, data: a2, tunes: l2, id: c2 }) => {
            o2.available.has(r2) === false && (K(`Tool ${r2} is not found. Check 'tools' property at the Editor.js config.`, "warn"), a2 = this.composeStubDataForTool(r2, a2, c2), r2 = o2.stubTool);
            let u2;
            try {
              u2 = i2.composeBlock({
                id: c2,
                tool: r2,
                data: a2,
                tunes: l2
              });
            } catch (h2) {
              L$1(`Block ${r2} skipped because of plugins error`, "error", {
                data: a2,
                error: h2
              }), a2 = this.composeStubDataForTool(r2, a2, c2), r2 = o2.stubTool, u2 = i2.composeBlock({
                id: c2,
                tool: r2,
                data: a2,
                tunes: l2
              });
            }
            return u2;
          });
          i2.insertMany(n2), window.requestIdleCallback(() => {
            t2();
          }, { timeout: 2e3 });
        });
      }
      /**
       * Create data for the Stub Tool that will be used instead of unavailable tool
       *
       * @param tool - unavailable tool name to stub
       * @param data - data of unavailable block
       * @param [id] - id of unavailable block
       */
      composeStubDataForTool(e2, t2, o2) {
        const { Tools: i2 } = this.Editor;
        let n2 = e2;
        if (i2.unavailable.has(e2)) {
          const r2 = i2.unavailable.get(e2).toolbox;
          r2 !== void 0 && r2[0].title !== void 0 && (n2 = r2[0].title);
        }
        return {
          savedData: {
            id: o2,
            type: e2,
            data: t2
          },
          title: n2
        };
      }
    }
    class ni extends C {
      /**
       * Composes new chain of Promises to fire them alternatelly
       *
       * @returns {OutputData}
       */
      async save() {
        const { BlockManager: e2, Tools: t2 } = this.Editor, o2 = e2.blocks, i2 = [];
        try {
          o2.forEach((a2) => {
            i2.push(this.getSavedData(a2));
          });
          const n2 = await Promise.all(i2), r2 = await ut(n2, (a2) => t2.blockTools.get(a2).sanitizeConfig);
          return this.makeOutput(r2);
        } catch (n2) {
          K("Saving failed due to the Error %o", "error", n2);
        }
      }
      /**
       * Saves and validates
       *
       * @param {Block} block - Editor's Tool
       * @returns {ValidatedData} - Tool's validated data
       */
      async getSavedData(e2) {
        const t2 = await e2.save(), o2 = t2 && await e2.validate(t2.data);
        return {
          ...t2,
          isValid: o2
        };
      }
      /**
       * Creates output object with saved data, time and version of editor
       *
       * @param {ValidatedData} allExtractedData - data extracted from Blocks
       * @returns {OutputData}
       */
      makeOutput(e2) {
        const t2 = [];
        return e2.forEach(({ id: o2, tool: i2, data: n2, tunes: r2, isValid: a2 }) => {
          if (!a2) {
            L$1(`Block ${i2} skipped because saved data is invalid`);
            return;
          }
          if (i2 === this.Editor.Tools.stubTool) {
            t2.push(n2);
            return;
          }
          const l2 = {
            id: o2,
            type: i2,
            data: n2,
            ...!V(r2) && {
              tunes: r2
            }
          };
          t2.push(l2);
        }), {
          time: +/* @__PURE__ */ new Date(),
          blocks: t2,
          version: "2.28.2"
        };
      }
    }
    var Ne = {}, si = {
      get exports() {
        return Ne;
      },
      set exports(s2) {
        Ne = s2;
      }
    };
    (function(s2, e2) {
      (function(t2, o2) {
        s2.exports = o2();
      })(window, function() {
        return function(t2) {
          var o2 = {};
          function i2(n2) {
            if (o2[n2])
              return o2[n2].exports;
            var r2 = o2[n2] = { i: n2, l: false, exports: {} };
            return t2[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
          }
          return i2.m = t2, i2.c = o2, i2.d = function(n2, r2, a2) {
            i2.o(n2, r2) || Object.defineProperty(n2, r2, { enumerable: true, get: a2 });
          }, i2.r = function(n2) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
          }, i2.t = function(n2, r2) {
            if (1 & r2 && (n2 = i2(n2)), 8 & r2 || 4 & r2 && typeof n2 == "object" && n2 && n2.__esModule)
              return n2;
            var a2 = /* @__PURE__ */ Object.create(null);
            if (i2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: n2 }), 2 & r2 && typeof n2 != "string")
              for (var l2 in n2)
                i2.d(a2, l2, (function(c2) {
                  return n2[c2];
                }).bind(null, l2));
            return a2;
          }, i2.n = function(n2) {
            var r2 = n2 && n2.__esModule ? function() {
              return n2.default;
            } : function() {
              return n2;
            };
            return i2.d(r2, "a", r2), r2;
          }, i2.o = function(n2, r2) {
            return Object.prototype.hasOwnProperty.call(n2, r2);
          }, i2.p = "/", i2(i2.s = 4);
        }([function(t2, o2, i2) {
          var n2 = i2(1), r2 = i2(2);
          typeof (r2 = r2.__esModule ? r2.default : r2) == "string" && (r2 = [[t2.i, r2, ""]]);
          var a2 = { insert: "head", singleton: false };
          n2(r2, a2), t2.exports = r2.locals || {};
        }, function(t2, o2, i2) {
          var n2, r2 = function() {
            return n2 === void 0 && (n2 = !!(window && document && document.all && !window.atob)), n2;
          }, a2 = function() {
            var y2 = {};
            return function(x2) {
              if (y2[x2] === void 0) {
                var w2 = document.querySelector(x2);
                if (window.HTMLIFrameElement && w2 instanceof window.HTMLIFrameElement)
                  try {
                    w2 = w2.contentDocument.head;
                  } catch {
                    w2 = null;
                  }
                y2[x2] = w2;
              }
              return y2[x2];
            };
          }(), l2 = [];
          function c2(y2) {
            for (var x2 = -1, w2 = 0; w2 < l2.length; w2++)
              if (l2[w2].identifier === y2) {
                x2 = w2;
                break;
              }
            return x2;
          }
          function u2(y2, x2) {
            for (var w2 = {}, I2 = [], R2 = 0; R2 < y2.length; R2++) {
              var b2 = y2[R2], g2 = x2.base ? b2[0] + x2.base : b2[0], E2 = w2[g2] || 0, T2 = "".concat(g2, " ").concat(E2);
              w2[g2] = E2 + 1;
              var O2 = c2(T2), S2 = { css: b2[1], media: b2[2], sourceMap: b2[3] };
              O2 !== -1 ? (l2[O2].references++, l2[O2].updater(S2)) : l2.push({ identifier: T2, updater: _2(S2, x2), references: 1 }), I2.push(T2);
            }
            return I2;
          }
          function h2(y2) {
            var x2 = document.createElement("style"), w2 = y2.attributes || {};
            if (w2.nonce === void 0) {
              var I2 = i2.nc;
              I2 && (w2.nonce = I2);
            }
            if (Object.keys(w2).forEach(function(b2) {
              x2.setAttribute(b2, w2[b2]);
            }), typeof y2.insert == "function")
              y2.insert(x2);
            else {
              var R2 = a2(y2.insert || "head");
              if (!R2)
                throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
              R2.appendChild(x2);
            }
            return x2;
          }
          var f2, k2 = (f2 = [], function(y2, x2) {
            return f2[y2] = x2, f2.filter(Boolean).join(`
`);
          });
          function p2(y2, x2, w2, I2) {
            var R2 = w2 ? "" : I2.media ? "@media ".concat(I2.media, " {").concat(I2.css, "}") : I2.css;
            if (y2.styleSheet)
              y2.styleSheet.cssText = k2(x2, R2);
            else {
              var b2 = document.createTextNode(R2), g2 = y2.childNodes;
              g2[x2] && y2.removeChild(g2[x2]), g2.length ? y2.insertBefore(b2, g2[x2]) : y2.appendChild(b2);
            }
          }
          function v2(y2, x2, w2) {
            var I2 = w2.css, R2 = w2.media, b2 = w2.sourceMap;
            if (R2 ? y2.setAttribute("media", R2) : y2.removeAttribute("media"), b2 && btoa && (I2 += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(b2)))), " */")), y2.styleSheet)
              y2.styleSheet.cssText = I2;
            else {
              for (; y2.firstChild; )
                y2.removeChild(y2.firstChild);
              y2.appendChild(document.createTextNode(I2));
            }
          }
          var A2 = null, N2 = 0;
          function _2(y2, x2) {
            var w2, I2, R2;
            if (x2.singleton) {
              var b2 = N2++;
              w2 = A2 || (A2 = h2(x2)), I2 = p2.bind(null, w2, b2, false), R2 = p2.bind(null, w2, b2, true);
            } else
              w2 = h2(x2), I2 = v2.bind(null, w2, x2), R2 = function() {
                (function(g2) {
                  if (g2.parentNode === null)
                    return false;
                  g2.parentNode.removeChild(g2);
                })(w2);
              };
            return I2(y2), function(g2) {
              if (g2) {
                if (g2.css === y2.css && g2.media === y2.media && g2.sourceMap === y2.sourceMap)
                  return;
                I2(y2 = g2);
              } else
                R2();
            };
          }
          t2.exports = function(y2, x2) {
            (x2 = x2 || {}).singleton || typeof x2.singleton == "boolean" || (x2.singleton = r2());
            var w2 = u2(y2 = y2 || [], x2);
            return function(I2) {
              if (I2 = I2 || [], Object.prototype.toString.call(I2) === "[object Array]") {
                for (var R2 = 0; R2 < w2.length; R2++) {
                  var b2 = c2(w2[R2]);
                  l2[b2].references--;
                }
                for (var g2 = u2(I2, x2), E2 = 0; E2 < w2.length; E2++) {
                  var T2 = c2(w2[E2]);
                  l2[T2].references === 0 && (l2[T2].updater(), l2.splice(T2, 1));
                }
                w2 = g2;
              }
            };
          };
        }, function(t2, o2, i2) {
          (o2 = i2(3)(false)).push([t2.i, `.ce-paragraph {
    line-height: 1.6em;
    outline: none;
}

.ce-paragraph[data-placeholder]:empty::before{
  content: attr(data-placeholder);
  color: #707684;
  font-weight: normal;
  opacity: 0;
}

/** Show placeholder at the first paragraph if Editor is empty */
.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before {
  opacity: 1;
}

.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before,
.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus::before {
  opacity: 0;
}

.ce-paragraph p:first-of-type{
    margin-top: 0;
}

.ce-paragraph p:last-of-type{
    margin-bottom: 0;
}
`, ""]), t2.exports = o2;
        }, function(t2, o2, i2) {
          t2.exports = function(n2) {
            var r2 = [];
            return r2.toString = function() {
              return this.map(function(a2) {
                var l2 = function(c2, u2) {
                  var h2 = c2[1] || "", f2 = c2[3];
                  if (!f2)
                    return h2;
                  if (u2 && typeof btoa == "function") {
                    var k2 = (v2 = f2, A2 = btoa(unescape(encodeURIComponent(JSON.stringify(v2)))), N2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(A2), "/*# ".concat(N2, " */")), p2 = f2.sources.map(function(_2) {
                      return "/*# sourceURL=".concat(f2.sourceRoot || "").concat(_2, " */");
                    });
                    return [h2].concat(p2).concat([k2]).join(`
`);
                  }
                  var v2, A2, N2;
                  return [h2].join(`
`);
                }(a2, n2);
                return a2[2] ? "@media ".concat(a2[2], " {").concat(l2, "}") : l2;
              }).join("");
            }, r2.i = function(a2, l2, c2) {
              typeof a2 == "string" && (a2 = [[null, a2, ""]]);
              var u2 = {};
              if (c2)
                for (var h2 = 0; h2 < this.length; h2++) {
                  var f2 = this[h2][0];
                  f2 != null && (u2[f2] = true);
                }
              for (var k2 = 0; k2 < a2.length; k2++) {
                var p2 = [].concat(a2[k2]);
                c2 && u2[p2[0]] || (l2 && (p2[2] ? p2[2] = "".concat(l2, " and ").concat(p2[2]) : p2[2] = l2), r2.push(p2));
              }
            }, r2;
          };
        }, function(t2, o2, i2) {
          i2.r(o2), i2.d(o2, "default", function() {
            return a2;
          }), i2(0);
          function n2(l2, c2) {
            for (var u2 = 0; u2 < c2.length; u2++) {
              var h2 = c2[u2];
              h2.enumerable = h2.enumerable || false, h2.configurable = true, "value" in h2 && (h2.writable = true), Object.defineProperty(l2, h2.key, h2);
            }
          }
          function r2(l2, c2, u2) {
            return c2 && n2(l2.prototype, c2), u2 && n2(l2, u2), l2;
          }
          /**
           * Base Paragraph Block for the Editor.js.
           * Represents a regular text block
           *
           * @author CodeX (team@codex.so)
           * @copyright CodeX 2018
           * @license The MIT License (MIT)
           */
          var a2 = function() {
            function l2(c2) {
              var u2 = c2.data, h2 = c2.config, f2 = c2.api, k2 = c2.readOnly;
              (function(p2, v2) {
                if (!(p2 instanceof v2))
                  throw new TypeError("Cannot call a class as a function");
              })(this, l2), this.api = f2, this.readOnly = k2, this._CSS = { block: this.api.styles.block, wrapper: "ce-paragraph" }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = h2.placeholder ? h2.placeholder : l2.DEFAULT_PLACEHOLDER, this._data = {}, this._element = null, this._preserveBlank = h2.preserveBlank !== void 0 && h2.preserveBlank, this.data = u2;
            }
            return r2(l2, null, [{ key: "DEFAULT_PLACEHOLDER", get: function() {
              return "";
            } }]), r2(l2, [{ key: "onKeyUp", value: function(c2) {
              c2.code !== "Backspace" && c2.code !== "Delete" || this._element.textContent === "" && (this._element.innerHTML = "");
            } }, { key: "drawView", value: function() {
              var c2 = document.createElement("DIV");
              return c2.classList.add(this._CSS.wrapper, this._CSS.block), c2.contentEditable = false, c2.dataset.placeholder = this.api.i18n.t(this._placeholder), this.readOnly || (c2.contentEditable = true, c2.addEventListener("keyup", this.onKeyUp)), c2;
            } }, { key: "render", value: function() {
              return this._element === null && (this._element = this.drawView()), this.hydrate(), this._element;
            } }, { key: "merge", value: function(c2) {
              var u2 = { text: this.data.text + c2.text };
              this.data = u2;
            } }, { key: "validate", value: function(c2) {
              return !(c2.text.trim() === "" && !this._preserveBlank);
            } }, { key: "save", value: function(c2) {
              return { text: c2.innerHTML };
            } }, { key: "onPaste", value: function(c2) {
              var u2 = { text: c2.detail.data.innerHTML };
              this.data = u2;
            } }, { key: "hydrate", value: function() {
              var c2 = this;
              window.requestAnimationFrame(function() {
                c2._element.innerHTML = c2._data.text || "";
              });
            } }, { key: "data", get: function() {
              if (this._element !== null) {
                var c2 = this._element.innerHTML;
                this._data.text = c2;
              }
              return this._data;
            }, set: function(c2) {
              this._data = c2 || {}, this._element !== null && this.hydrate();
            } }], [{ key: "conversionConfig", get: function() {
              return { export: "text", import: "text" };
            } }, { key: "sanitize", get: function() {
              return { text: { br: true } };
            } }, { key: "isReadOnlySupported", get: function() {
              return true;
            } }, { key: "pasteConfig", get: function() {
              return { tags: ["P"] };
            } }, { key: "toolbox", get: function() {
              return { icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14"/></svg>', title: "Text" };
            } }]), l2;
          }();
        }]).default;
      });
    })(si);
    const ri = /* @__PURE__ */ xe(Ne);
    class We {
      constructor() {
        this.commandName = "bold", this.CSS = {
          button: "ce-inline-tool",
          buttonActive: "ce-inline-tool--active",
          buttonModifier: "ce-inline-tool--bold"
        }, this.nodes = {
          button: void 0
        };
      }
      /**
       * Sanitizer Rule
       * Leave <b> tags
       *
       * @returns {object}
       */
      static get sanitize() {
        return {
          b: {}
        };
      }
      /**
       * Create button for Inline Toolbar
       */
      render() {
        return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = So, this.nodes.button;
      }
      /**
       * Wrap range with <b> tag
       */
      surround() {
        document.execCommand(this.commandName);
      }
      /**
       * Check selection and set activated state to button if there are <b> tag
       *
       * @returns {boolean}
       */
      checkState() {
        const e2 = document.queryCommandState(this.commandName);
        return this.nodes.button.classList.toggle(this.CSS.buttonActive, e2), e2;
      }
      /**
       * Set a shortcut
       *
       * @returns {boolean}
       */
      get shortcut() {
        return "CMD+B";
      }
    }
    We.isInline = true;
    We.title = "Bold";
    class Ye {
      constructor() {
        this.commandName = "italic", this.CSS = {
          button: "ce-inline-tool",
          buttonActive: "ce-inline-tool--active",
          buttonModifier: "ce-inline-tool--italic"
        }, this.nodes = {
          button: null
        };
      }
      /**
       * Sanitizer Rule
       * Leave <i> tags
       *
       * @returns {object}
       */
      static get sanitize() {
        return {
          i: {}
        };
      }
      /**
       * Create button for Inline Toolbar
       */
      render() {
        return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Oo, this.nodes.button;
      }
      /**
       * Wrap range with <i> tag
       */
      surround() {
        document.execCommand(this.commandName);
      }
      /**
       * Check selection and set activated state to button if there are <i> tag
       */
      checkState() {
        const e2 = document.queryCommandState(this.commandName);
        return this.nodes.button.classList.toggle(this.CSS.buttonActive, e2), e2;
      }
      /**
       * Set a shortcut
       */
      get shortcut() {
        return "CMD+I";
      }
    }
    Ye.isInline = true;
    Ye.title = "Italic";
    class Ke {
      /**
       * @param api - Editor.js API
       */
      constructor({ api: e2 }) {
        this.commandLink = "createLink", this.commandUnlink = "unlink", this.ENTER_KEY = 13, this.CSS = {
          button: "ce-inline-tool",
          buttonActive: "ce-inline-tool--active",
          buttonModifier: "ce-inline-tool--link",
          buttonUnlink: "ce-inline-tool--unlink",
          input: "ce-inline-tool-input",
          inputShowed: "ce-inline-tool-input--showed"
        }, this.nodes = {
          button: null,
          input: null
        }, this.inputOpened = false, this.toolbar = e2.toolbar, this.inlineToolbar = e2.inlineToolbar, this.notifier = e2.notifier, this.i18n = e2.i18n, this.selection = new m$1();
      }
      /**
       * Sanitizer Rule
       * Leave <a> tags
       *
       * @returns {object}
       */
      static get sanitize() {
        return {
          a: {
            href: true,
            target: "_blank",
            rel: "nofollow"
          }
        };
      }
      /**
       * Create button for Inline Toolbar
       */
      render() {
        return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Qe, this.nodes.button;
      }
      /**
       * Input for the link
       */
      renderActions() {
        return this.nodes.input = document.createElement("input"), this.nodes.input.placeholder = this.i18n.t("Add a link"), this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener("keydown", (e2) => {
          e2.keyCode === this.ENTER_KEY && this.enterPressed(e2);
        }), this.nodes.input;
      }
      /**
       * Handle clicks on the Inline Toolbar icon
       *
       * @param {Range} range - range to wrap with link
       */
      surround(e2) {
        if (e2) {
          this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());
          const t2 = this.selection.findParentTag("A");
          if (t2) {
            this.selection.expandToTag(t2), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();
            return;
          }
        }
        this.toggleActions();
      }
      /**
       * Check selection and set activated state to button if there are <a> tag
       */
      checkState() {
        const e2 = this.selection.findParentTag("A");
        if (e2) {
          this.nodes.button.innerHTML = Ro, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();
          const t2 = e2.getAttribute("href");
          this.nodes.input.value = t2 !== "null" ? t2 : "", this.selection.save();
        } else
          this.nodes.button.innerHTML = Qe, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);
        return !!e2;
      }
      /**
       * Function called with Inline Toolbar closing
       */
      clear() {
        this.closeActions();
      }
      /**
       * Set a shortcut
       */
      get shortcut() {
        return "CMD+K";
      }
      /**
       * Show/close link input
       */
      toggleActions() {
        this.inputOpened ? this.closeActions(false) : this.openActions(true);
      }
      /**
       * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.
       */
      openActions(e2 = false) {
        this.nodes.input.classList.add(this.CSS.inputShowed), e2 && this.nodes.input.focus(), this.inputOpened = true;
      }
      /**
       * Close input
       *
       * @param {boolean} clearSavedSelection  we don't need to clear saved selection
       *                                        on toggle-clicks on the icon of opened Toolbar
       */
      closeActions(e2 = true) {
        if (this.selection.isFakeBackgroundEnabled) {
          const t2 = new m$1();
          t2.save(), this.selection.restore(), this.selection.removeFakeBackground(), t2.restore();
        }
        this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = "", e2 && this.selection.clearSaved(), this.inputOpened = false;
      }
      /**
       * Enter pressed on input
       *
       * @param {KeyboardEvent} event - enter keydown event
       */
      enterPressed(e2) {
        let t2 = this.nodes.input.value || "";
        if (!t2.trim()) {
          this.selection.restore(), this.unlink(), e2.preventDefault(), this.closeActions();
          return;
        }
        if (!this.validateURL(t2)) {
          this.notifier.show({
            message: "Pasted link is not valid.",
            style: "error"
          }), L$1("Incorrect Link pasted", "warn", t2);
          return;
        }
        t2 = this.prepareLink(t2), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t2), e2.preventDefault(), e2.stopPropagation(), e2.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();
      }
      /**
       * Detects if passed string is URL
       *
       * @param {string} str - string to validate
       * @returns {boolean}
       */
      validateURL(e2) {
        return !/\s/.test(e2);
      }
      /**
       * Process link before injection
       * - sanitize
       * - add protocol for links like 'google.com'
       *
       * @param {string} link - raw user input
       */
      prepareLink(e2) {
        return e2 = e2.trim(), e2 = this.addProtocol(e2), e2;
      }
      /**
       * Add 'http' protocol to the links like 'vc.ru', 'google.com'
       *
       * @param {string} link - string to process
       */
      addProtocol(e2) {
        if (/^(\w+):(\/\/)?/.test(e2))
          return e2;
        const t2 = /^\/[^/\s]/.test(e2), o2 = e2.substring(0, 1) === "#", i2 = /^\/\/[^/\s]/.test(e2);
        return !t2 && !o2 && !i2 && (e2 = "http://" + e2), e2;
      }
      /**
       * Inserts <a> tag with "href"
       *
       * @param {string} link - "href" value
       */
      insertLink(e2) {
        const t2 = this.selection.findParentTag("A");
        t2 && this.selection.expandToTag(t2), document.execCommand(this.commandLink, false, e2);
      }
      /**
       * Removes <a> tag
       */
      unlink() {
        document.execCommand(this.commandUnlink);
      }
    }
    Ke.isInline = true;
    Ke.title = "Link";
    class Et {
      /**
       * @param options - constructor options
       * @param options.data - stub tool data
       * @param options.api - Editor.js API
       */
      constructor({ data: e2, api: t2 }) {
        this.CSS = {
          wrapper: "ce-stub",
          info: "ce-stub__info",
          title: "ce-stub__title",
          subtitle: "ce-stub__subtitle"
        }, this.api = t2, this.title = e2.title || this.api.i18n.t("Error"), this.subtitle = this.api.i18n.t("The block can not be displayed correctly."), this.savedData = e2.savedData, this.wrapper = this.make();
      }
      /**
       * Returns stub holder
       *
       * @returns {HTMLElement}
       */
      render() {
        return this.wrapper;
      }
      /**
       * Return original Tool data
       *
       * @returns {BlockToolData}
       */
      save() {
        return this.savedData;
      }
      /**
       * Create Tool html markup
       *
       * @returns {HTMLElement}
       */
      make() {
        const e2 = d$1.make("div", this.CSS.wrapper), t2 = Do, o2 = d$1.make("div", this.CSS.info), i2 = d$1.make("div", this.CSS.title, {
          textContent: this.title
        }), n2 = d$1.make("div", this.CSS.subtitle, {
          textContent: this.subtitle
        });
        return e2.innerHTML = t2, o2.appendChild(i2), o2.appendChild(n2), e2.appendChild(o2), e2;
      }
    }
    Et.isReadOnlySupported = true;
    class ai extends $e {
      constructor() {
        super(...arguments), this.type = ye.Inline;
      }
      /**
       * Returns title for Inline Tool if specified by user
       */
      get title() {
        return this.constructable[Ue.Title];
      }
      /**
       * Constructs new InlineTool instance from constructable
       */
      create() {
        return new this.constructable({
          api: this.api.getMethodsForTool(this),
          config: this.settings
        });
      }
    }
    class li extends $e {
      constructor() {
        super(...arguments), this.type = ye.Tune;
      }
      /**
       * Constructs new BlockTune instance from constructable
       *
       * @param data - Tune data
       * @param block - Block API object
       */
      create(e2, t2) {
        return new this.constructable({
          api: this.api.getMethodsForTool(this),
          config: this.settings,
          block: t2,
          data: e2
        });
      }
    }
    let U$1 = class U2 extends Map {
      /**
       * Returns Block Tools collection
       */
      get blockTools() {
        const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isBlock());
        return new U2(e2);
      }
      /**
       * Returns Inline Tools collection
       */
      get inlineTools() {
        const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isInline());
        return new U2(e2);
      }
      /**
       * Returns Block Tunes collection
       */
      get blockTunes() {
        const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isTune());
        return new U2(e2);
      }
      /**
       * Returns internal Tools collection
       */
      get internalTools() {
        const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isInternal);
        return new U2(e2);
      }
      /**
       * Returns Tools collection provided by user
       */
      get externalTools() {
        const e2 = Array.from(this.entries()).filter(([, t2]) => !t2.isInternal);
        return new U2(e2);
      }
    };
    var ci = Object.defineProperty, di = Object.getOwnPropertyDescriptor, Bt = (s2, e2, t2, o2) => {
      for (var i2 = o2 > 1 ? void 0 : o2 ? di(e2, t2) : e2, n2 = s2.length - 1, r2; n2 >= 0; n2--)
        (r2 = s2[n2]) && (i2 = (o2 ? r2(e2, t2, i2) : r2(i2)) || i2);
      return o2 && i2 && ci(e2, t2, i2), i2;
    };
    class Xe extends $e {
      constructor() {
        super(...arguments), this.type = ye.Block, this.inlineTools = new U$1(), this.tunes = new U$1();
      }
      /**
       * Creates new Tool instance
       *
       * @param data - Tool data
       * @param block - BlockAPI for current Block
       * @param readOnly - True if Editor is in read-only mode
       */
      create(e2, t2, o2) {
        return new this.constructable({
          data: e2,
          block: t2,
          readOnly: o2,
          api: this.api.getMethodsForTool(this),
          config: this.settings
        });
      }
      /**
       * Returns true if read-only mode is supported by Tool
       */
      get isReadOnlySupported() {
        return this.constructable[se.IsReadOnlySupported] === true;
      }
      /**
       * Returns true if Tool supports linebreaks
       */
      get isLineBreaksEnabled() {
        return this.constructable[se.IsEnabledLineBreaks];
      }
      /**
       * Returns Tool toolbox configuration (internal or user-specified).
       *
       * Merges internal and user-defined toolbox configs based on the following rules:
       *
       * - If both internal and user-defined toolbox configs are arrays their items are merged.
       * Length of the second one is kept.
       *
       * - If both are objects their properties are merged.
       *
       * - If one is an object and another is an array than internal config is replaced with user-defined
       * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)
       */
      get toolbox() {
        const e2 = this.constructable[se.Toolbox], t2 = this.config[ke.Toolbox];
        if (!V(e2) && t2 !== false)
          return t2 ? Array.isArray(e2) ? Array.isArray(t2) ? t2.map((o2, i2) => {
            const n2 = e2[i2];
            return n2 ? {
              ...n2,
              ...o2
            } : o2;
          }) : [t2] : Array.isArray(t2) ? t2 : [
            {
              ...e2,
              ...t2
            }
          ] : Array.isArray(e2) ? e2 : [e2];
      }
      /**
       * Returns Tool conversion configuration
       */
      get conversionConfig() {
        return this.constructable[se.ConversionConfig];
      }
      /**
       * Returns enabled inline tools for Tool
       */
      get enabledInlineTools() {
        return this.config[ke.EnabledInlineTools] || false;
      }
      /**
       * Returns enabled tunes for Tool
       */
      get enabledBlockTunes() {
        return this.config[ke.EnabledBlockTunes];
      }
      /**
       * Returns Tool paste configuration
       */
      get pasteConfig() {
        return this.constructable[se.PasteConfig] ?? {};
      }
      get sanitizeConfig() {
        const e2 = super.sanitizeConfig, t2 = this.baseSanitizeConfig;
        if (V(e2))
          return t2;
        const o2 = {};
        for (const i2 in e2)
          if (Object.prototype.hasOwnProperty.call(e2, i2)) {
            const n2 = e2[i2];
            z(n2) ? o2[i2] = Object.assign({}, t2, n2) : o2[i2] = n2;
          }
        return o2;
      }
      get baseSanitizeConfig() {
        const e2 = {};
        return Array.from(this.inlineTools.values()).forEach((t2) => Object.assign(e2, t2.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t2) => Object.assign(e2, t2.sanitizeConfig)), e2;
      }
    }
    Bt([
      ce
    ], Xe.prototype, "sanitizeConfig", 1);
    Bt([
      ce
    ], Xe.prototype, "baseSanitizeConfig", 1);
    class hi {
      /**
       * @class
       * @param config - tools config
       * @param editorConfig - EditorJS config
       * @param api - EditorJS API module
       */
      constructor(e2, t2, o2) {
        this.api = o2, this.config = e2, this.editorConfig = t2;
      }
      /**
       * Returns Tool object based on it's type
       *
       * @param name - tool name
       */
      get(e2) {
        const { class: t2, isInternal: o2 = false, ...i2 } = this.config[e2], n2 = this.getConstructor(t2);
        return new n2({
          name: e2,
          constructable: t2,
          config: i2,
          api: this.api,
          isDefault: e2 === this.editorConfig.defaultBlock,
          defaultPlaceholder: this.editorConfig.placeholder,
          isInternal: o2
        });
      }
      /**
       * Find appropriate Tool object constructor for Tool constructable
       *
       * @param constructable - Tools constructable
       */
      getConstructor(e2) {
        switch (true) {
          case e2[Ue.IsInline]:
            return ai;
          case e2[xt.IsTune]:
            return li;
          default:
            return Xe;
        }
      }
    }
    class Tt {
      /**
       * MoveDownTune constructor
       *
       * @param {API} api  Editor's API
       */
      constructor({ api: e2 }) {
        this.CSS = {
          animation: "wobble"
        }, this.api = e2;
      }
      /**
       * Tune's appearance in block settings menu
       */
      render() {
        return {
          icon: ft,
          title: this.api.i18n.t("Move down"),
          onActivate: () => this.handleClick(),
          name: "move-down"
        };
      }
      /**
       * Handle clicks on 'move down' button
       */
      handleClick() {
        const e2 = this.api.blocks.getCurrentBlockIndex(), t2 = this.api.blocks.getBlockByIndex(e2 + 1);
        if (!t2)
          throw new Error("Unable to move Block down since it is already the last");
        const o2 = t2.holder, i2 = o2.getBoundingClientRect();
        let n2 = Math.abs(window.innerHeight - o2.offsetHeight);
        i2.top < window.innerHeight && (n2 = window.scrollY + o2.offsetHeight), window.scrollTo(0, n2), this.api.blocks.move(e2 + 1), this.api.toolbar.toggleBlockSettings(true);
      }
    }
    Tt.isTune = true;
    class Ct {
      /**
       * DeleteTune constructor
       *
       * @param {API} api - Editor's API
       */
      constructor({ api: e2 }) {
        this.api = e2;
      }
      /**
       * Tune's appearance in block settings menu
       */
      render() {
        return {
          icon: Mo,
          title: this.api.i18n.t("Delete"),
          name: "delete",
          confirmation: {
            title: this.api.i18n.t("Click to delete"),
            onActivate: () => this.handleClick()
          }
        };
      }
      /**
       * Delete block conditions passed
       */
      handleClick() {
        this.api.blocks.delete();
      }
    }
    Ct.isTune = true;
    class St {
      /**
       * MoveUpTune constructor
       *
       * @param {API} api - Editor's API
       */
      constructor({ api: e2 }) {
        this.CSS = {
          animation: "wobble"
        }, this.api = e2;
      }
      /**
       * Tune's appearance in block settings menu
       */
      render() {
        return {
          icon: Io,
          title: this.api.i18n.t("Move up"),
          onActivate: () => this.handleClick(),
          name: "move-up"
        };
      }
      /**
       * Move current block up
       */
      handleClick() {
        const e2 = this.api.blocks.getCurrentBlockIndex(), t2 = this.api.blocks.getBlockByIndex(e2), o2 = this.api.blocks.getBlockByIndex(e2 - 1);
        if (e2 === 0 || !t2 || !o2)
          throw new Error("Unable to move Block up since it is already the first");
        const i2 = t2.holder, n2 = o2.holder, r2 = i2.getBoundingClientRect(), a2 = n2.getBoundingClientRect();
        let l2;
        a2.top > 0 ? l2 = Math.abs(r2.top) - Math.abs(a2.top) : l2 = Math.abs(r2.top) + a2.height, window.scrollBy(0, -1 * l2), this.api.blocks.move(e2 - 1), this.api.toolbar.toggleBlockSettings(true);
      }
    }
    St.isTune = true;
    var ui = Object.defineProperty, pi = Object.getOwnPropertyDescriptor, fi = (s2, e2, t2, o2) => {
      for (var i2 = o2 > 1 ? void 0 : o2 ? pi(e2, t2) : e2, n2 = s2.length - 1, r2; n2 >= 0; n2--)
        (r2 = s2[n2]) && (i2 = (o2 ? r2(e2, t2, i2) : r2(i2)) || i2);
      return o2 && i2 && ui(e2, t2, i2), i2;
    };
    class It extends C {
      constructor() {
        super(...arguments), this.stubTool = "stub", this.toolsAvailable = new U$1(), this.toolsUnavailable = new U$1();
      }
      /**
       * Returns available Tools
       */
      get available() {
        return this.toolsAvailable;
      }
      /**
       * Returns unavailable Tools
       */
      get unavailable() {
        return this.toolsUnavailable;
      }
      /**
       * Return Tools for the Inline Toolbar
       */
      get inlineTools() {
        return this.available.inlineTools;
      }
      /**
       * Return editor block tools
       */
      get blockTools() {
        return this.available.blockTools;
      }
      /**
       * Return available Block Tunes
       *
       * @returns {object} - object of Inline Tool's classes
       */
      get blockTunes() {
        return this.available.blockTunes;
      }
      /**
       * Returns default Tool object
       */
      get defaultTool() {
        return this.blockTools.get(this.config.defaultBlock);
      }
      /**
       * Returns internal tools
       */
      get internal() {
        return this.available.internalTools;
      }
      /**
       * Creates instances via passed or default configuration
       *
       * @returns {Promise<void>}
       */
      async prepare() {
        if (this.validateTools(), this.config.tools = Se({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, "tools") || Object.keys(this.config.tools).length === 0)
          throw Error("Can't start without tools");
        const e2 = this.prepareConfig();
        this.factory = new hi(e2, this.config, this.Editor.API);
        const t2 = this.getListOfPrepareFunctions(e2);
        if (t2.length === 0)
          return Promise.resolve();
        await Dt(t2, (o2) => {
          this.toolPrepareMethodSuccess(o2);
        }, (o2) => {
          this.toolPrepareMethodFallback(o2);
        }), this.prepareBlockTools();
      }
      getAllInlineToolsSanitizeConfig() {
        const e2 = {};
        return Array.from(this.inlineTools.values()).forEach((t2) => {
          Object.assign(e2, t2.sanitizeConfig);
        }), e2;
      }
      /**
       * Calls each Tool reset method to clean up anything set by Tool
       */
      destroy() {
        Object.values(this.available).forEach(async (e2) => {
          D$1(e2.reset) && await e2.reset();
        });
      }
      /**
       * Returns internal tools
       * Includes Bold, Italic, Link and Paragraph
       */
      get internalTools() {
        return {
          bold: {
            class: We,
            isInternal: true
          },
          italic: {
            class: Ye,
            isInternal: true
          },
          link: {
            class: Ke,
            isInternal: true
          },
          paragraph: {
            class: ri,
            inlineToolbar: true,
            isInternal: true
          },
          stub: {
            class: Et,
            isInternal: true
          },
          moveUp: {
            class: St,
            isInternal: true
          },
          delete: {
            class: Ct,
            isInternal: true
          },
          moveDown: {
            class: Tt,
            isInternal: true
          }
        };
      }
      /**
       * Tool prepare method success callback
       *
       * @param {object} data - append tool to available list
       */
      toolPrepareMethodSuccess(e2) {
        const t2 = this.factory.get(e2.toolName);
        if (t2.isInline()) {
          const i2 = ["render", "surround", "checkState"].filter((n2) => !t2.create()[n2]);
          if (i2.length) {
            L$1(
              `Incorrect Inline Tool: ${t2.name}. Some of required methods is not implemented %o`,
              "warn",
              i2
            ), this.toolsUnavailable.set(t2.name, t2);
            return;
          }
        }
        this.toolsAvailable.set(t2.name, t2);
      }
      /**
       * Tool prepare method fail callback
       *
       * @param {object} data - append tool to unavailable list
       */
      toolPrepareMethodFallback(e2) {
        this.toolsUnavailable.set(e2.toolName, this.factory.get(e2.toolName));
      }
      /**
       * Binds prepare function of plugins with user or default config
       *
       * @returns {Array} list of functions that needs to be fired sequentially
       * @param config - tools config
       */
      getListOfPrepareFunctions(e2) {
        const t2 = [];
        return Object.entries(e2).forEach(([o2, i2]) => {
          t2.push({
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            function: D$1(i2.class.prepare) ? i2.class.prepare : () => {
            },
            data: {
              toolName: o2,
              config: i2.config
            }
          });
        }), t2;
      }
      /**
       * Assign enabled Inline Tools and Block Tunes for Block Tool
       */
      prepareBlockTools() {
        Array.from(this.blockTools.values()).forEach((e2) => {
          this.assignInlineToolsToBlockTool(e2), this.assignBlockTunesToBlockTool(e2);
        });
      }
      /**
       * Assign enabled Inline Tools for Block Tool
       *
       * @param tool - Block Tool
       */
      assignInlineToolsToBlockTool(e2) {
        if (this.config.inlineToolbar !== false) {
          if (e2.enabledInlineTools === true) {
            e2.inlineTools = new U$1(
              Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t2) => [t2, this.inlineTools.get(t2)]) : Array.from(this.inlineTools.entries())
            );
            return;
          }
          Array.isArray(e2.enabledInlineTools) && (e2.inlineTools = new U$1(
            e2.enabledInlineTools.map((t2) => [t2, this.inlineTools.get(t2)])
          ));
        }
      }
      /**
       * Assign enabled Block Tunes for Block Tool
       *
       * @param tool  Block Tool
       */
      assignBlockTunesToBlockTool(e2) {
        if (e2.enabledBlockTunes !== false) {
          if (Array.isArray(e2.enabledBlockTunes)) {
            const t2 = new U$1(
              e2.enabledBlockTunes.map((o2) => [o2, this.blockTunes.get(o2)])
            );
            e2.tunes = new U$1([...t2, ...this.blockTunes.internalTools]);
            return;
          }
          if (Array.isArray(this.config.tunes)) {
            const t2 = new U$1(
              this.config.tunes.map((o2) => [o2, this.blockTunes.get(o2)])
            );
            e2.tunes = new U$1([...t2, ...this.blockTunes.internalTools]);
            return;
          }
          e2.tunes = this.blockTunes.internalTools;
        }
      }
      /**
       * Validate Tools configuration objects and throw Error for user if it is invalid
       */
      validateTools() {
        for (const e2 in this.config.tools)
          if (Object.prototype.hasOwnProperty.call(this.config.tools, e2)) {
            if (e2 in this.internalTools)
              return;
            const t2 = this.config.tools[e2];
            if (!D$1(t2) && !D$1(t2.class))
              throw Error(
                `Tool ${e2} must be a constructor function or an object with function in the class property`
              );
          }
      }
      /**
       * Unify tools config
       */
      prepareConfig() {
        const e2 = {};
        for (const t2 in this.config.tools)
          z(this.config.tools[t2]) ? e2[t2] = this.config.tools[t2] : e2[t2] = { class: this.config.tools[t2] };
        return e2;
      }
    }
    fi([
      ce
    ], It.prototype, "getAllInlineToolsSanitizeConfig", 1);
    const gi = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:"\\feff"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0px;left:0px;right:0px;bottom:0px;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;-webkit-transform:translateX(-50%) translateY(8px) scale(.94);transform:translate(-50%) translateY(8px) scale(.94);opacity:0;visibility:hidden;-webkit-transition:opacity .25s ease,-webkit-transform .15s ease;transition:opacity .25s ease,-webkit-transform .15s ease;transition:transform .15s ease,opacity .25s ease;transition:transform .15s ease,opacity .25s ease,-webkit-transform .15s ease;will-change:transform,opacity;top:0;left:0;z-index:3}.ce-inline-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-inline-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-inline-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:translateX(-50%);transform:translate(-50%)}.ce-inline-toolbar--left-oriented{-webkit-transform:translateX(-23px) translateY(8px) scale(.94);transform:translate(-23px) translateY(8px) scale(.94)}.ce-inline-toolbar--left-oriented.ce-inline-toolbar--showed{-webkit-transform:translateX(-23px);transform:translate(-23px)}.ce-inline-toolbar--right-oriented{-webkit-transform:translateX(-100%) translateY(8px) scale(.94);transform:translate(-100%) translateY(8px) scale(.94);margin-left:23px}.ce-inline-toolbar--right-oriented.ce-inline-toolbar--showed{-webkit-transform:translateX(-100%);transform:translate(-100%)}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;border-radius:0;line-height:normal}.ce-inline-tool svg{width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#eff2f5}}.ce-inline-tool--active{color:#388ae5}.ce-inline-tool--focused{background:rgba(34,186,255,.08)!important}.ce-inline-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-inline-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{outline:none;border:0;border-radius:0 0 4px 4px;margin:0;font-size:13px;padding:10px;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;border-top:1px solid rgba(201,201,204,.48);-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-conversion-toolbar{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;opacity:0;visibility:hidden;will-change:transform,opacity;-webkit-transition:opacity .1s ease,-webkit-transform .1s ease;transition:opacity .1s ease,-webkit-transform .1s ease;transition:transform .1s ease,opacity .1s ease;transition:transform .1s ease,opacity .1s ease,-webkit-transform .1s ease;-webkit-transform:translateY(-8px);transform:translateY(-8px);left:-1px;width:190px;margin-top:5px;-webkit-box-sizing:content-box;box-sizing:content-box}.ce-conversion-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-conversion-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-conversion-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:none;transform:none}.ce-conversion-toolbar [hidden]{display:none!important}.ce-conversion-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-conversion-toolbar__label{color:#707684;font-size:11px;font-weight:500;letter-spacing:.33px;padding:10px 10px 5px;text-transform:uppercase}.ce-conversion-tool{display:-webkit-box;display:-ms-flexbox;display:flex;padding:5px 10px;font-size:14px;line-height:20px;font-weight:500;cursor:pointer;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-conversion-tool--hidden{display:none}.ce-conversion-tool--focused{background:rgba(34,186,255,.08)!important}.ce-conversion-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-conversion-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-conversion-tool:hover{background:#eff2f5}.ce-conversion-tool__icon{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px rgba(201,201,204,.48);box-shadow:0 0 0 1px #c9c9cc7a;border-radius:5px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;background:#fff;-webkit-box-sizing:content-box;box-sizing:content-box;-ms-flex-negative:0;flex-shrink:0;margin-right:10px}.ce-conversion-tool__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-conversion-tool__icon{width:36px;height:36px;border-radius:8px}.ce-conversion-tool__icon svg{width:28px;height:28px}}.ce-conversion-tool--last{margin-right:0!important}.ce-conversion-tool--active{color:#388ae5!important}.ce-conversion-tool--active{-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-conversion-tool__secondary-label{color:#707684;font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-conversion-tool__secondary-label{display:none}}.ce-settings__button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;line-height:32px}.ce-settings__button svg{width:20px;height:20px}@media (max-width: 650px){.ce-settings__button svg{width:28px;height:28px}}@media (hover: hover){.ce-settings__button:hover{background-color:#eff2f5}}.ce-settings__button--active{color:#388ae5}.ce-settings__button--focused{background:rgba(34,186,255,.08)!important}.ce-settings__button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-settings__button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-settings__button:not(:nth-child(3n+3)){margin-right:3px}.ce-settings__button:nth-child(n+4){margin-top:3px}.ce-settings__button--disabled{cursor:not-allowed!important}.ce-settings__button--disabled{opacity:.3}.ce-settings__button--selected{color:#388ae5}@media (min-width: 651px){.codex-editor--narrow .ce-settings .ce-popover{right:0;left:auto;left:initial}}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:"";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:"";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@media (min-width: 651px){.codex-editor--narrow .ce-block--focused{margin-right:-50px;padding-right:50px}}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button svg{width:20px;height:20px}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:"";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0px;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:rgba(232,232,235,.49);border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #e8e8eb;--color-shadow: rgba(13,20,33,.13);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #eff2f5;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:0;top:calc(100% + var(--offset-from-target));background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}.ce-popover--open-top{top:calc(-1 * (var(--offset-from-target) + var(--popover-height)))}@media (max-width: 650px){.ce-popover{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}.ce-popover .ce-popover__search{display:none}}.ce-popover__search,.ce-popover__custom-content:not(:empty){margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover__custom-content:not(:empty){padding:4px}@media (min-width: 651px){.ce-popover__custom-content:not(:empty){padding:0}}.ce-popover__custom-content--hidden{display:none}.ce-popover-item{--border-radius: 6px;--icon-size: 20px;--icon-size-mobile: 28px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:3px;color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{border-radius:5px;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px var(--color-border-icon);box-shadow:0 0 0 1px var(--color-border-icon);background:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:10px}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:var(--icon-size-mobile);height:var(--icon-size-mobile)}}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--active .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--disabled .ce-popover-item__icon{-webkit-box-shadow:0 0 0 1px var(--color-border-icon-disabled);box-shadow:0 0 0 1px var(--color-border-icon-disabled)}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--focused:not(.ce-popover-item--no-focus){-webkit-box-shadow:inset 0 0 0px 1px var(--color-shadow-item-focus);box-shadow:inset 0 0 0 1px var(--color-shadow-item-focus)}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}.ce-popover-item:hover .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__icon{color:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}.ce-popover-item--confirmation .ce-popover-item__icon,.ce-popover-item--active .ce-popover-item__icon,.ce-popover-item--focused .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}
`;
    class bi extends C {
      constructor() {
        super(...arguments), this.isMobile = false, this.contentRectCache = void 0, this.resizeDebouncer = Ht(() => {
          this.windowResize();
        }, 200);
      }
      /**
       * Editor.js UI CSS class names
       *
       * @returns {{editorWrapper: string, editorZone: string}}
       */
      get CSS() {
        return {
          editorWrapper: "codex-editor",
          editorWrapperNarrow: "codex-editor--narrow",
          editorZone: "codex-editor__redactor",
          editorZoneHidden: "codex-editor__redactor--hidden",
          editorEmpty: "codex-editor--empty",
          editorRtlFix: "codex-editor--rtl"
        };
      }
      /**
       * Return Width of center column of Editor
       *
       * @returns {DOMRect}
       */
      get contentRect() {
        if (this.contentRectCache)
          return this.contentRectCache;
        const e2 = this.nodes.wrapper.querySelector(`.${F$1.CSS.content}`);
        return e2 ? (this.contentRectCache = e2.getBoundingClientRect(), this.contentRectCache) : {
          width: 650,
          left: 0,
          right: 0
        };
      }
      /**
       * Making main interface
       */
      async prepare() {
        this.checkIsMobile(), this.make(), this.loadStyles();
      }
      /**
       * Toggle read-only state
       *
       * If readOnly is true:
       *  - removes all listeners from main UI module elements
       *
       * if readOnly is false:
       *  - enables all listeners to UI module elements
       *
       * @param {boolean} readOnlyEnabled - "read only" state
       */
      toggleReadOnly(e2) {
        e2 ? this.disableModuleBindings() : this.enableModuleBindings();
      }
      /**
       * Check if Editor is empty and set CSS class to wrapper
       */
      checkEmptiness() {
        const { BlockManager: e2 } = this.Editor;
        this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e2.isEditorEmpty);
      }
      /**
       * Check if one of Toolbar is opened
       * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar
       *
       * @returns {boolean}
       */
      get someToolbarOpened() {
        const { Toolbar: e2, BlockSettings: t2, InlineToolbar: o2, ConversionToolbar: i2 } = this.Editor;
        return t2.opened || o2.opened || i2.opened || e2.toolbox.opened;
      }
      /**
       * Check for some Flipper-buttons is under focus
       */
      get someFlipperButtonFocused() {
        return this.Editor.Toolbar.toolbox.hasFocus() ? true : Object.entries(this.Editor).filter(([e2, t2]) => t2.flipper instanceof G).some(([e2, t2]) => t2.flipper.hasFocus());
      }
      /**
       * Clean editor`s UI
       */
      destroy() {
        this.nodes.holder.innerHTML = "";
      }
      /**
       * Close all Editor's toolbars
       */
      closeAllToolbars() {
        const { Toolbar: e2, BlockSettings: t2, InlineToolbar: o2, ConversionToolbar: i2 } = this.Editor;
        t2.close(), o2.close(), i2.close(), e2.toolbox.close();
      }
      /**
       * Check for mobile mode and cache a result
       */
      checkIsMobile() {
        this.isMobile = window.innerWidth < rt;
      }
      /**
       * Makes Editor.js interface
       */
      make() {
        this.nodes.holder = d$1.getHolder(this.config.holder), this.nodes.wrapper = d$1.make("div", [
          this.CSS.editorWrapper,
          ...this.isRtl ? [this.CSS.editorRtlFix] : []
        ]), this.nodes.redactor = d$1.make("div", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + "px", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper);
      }
      /**
       * Appends CSS
       */
      loadStyles() {
        const e2 = "editor-js-styles";
        if (d$1.get(e2))
          return;
        const t2 = d$1.make("style", null, {
          id: e2,
          textContent: gi.toString()
        });
        d$1.prepend(document.head, t2);
      }
      /**
       * Bind events on the Editor.js interface
       */
      enableModuleBindings() {
        this.readOnlyMutableListeners.on(this.nodes.redactor, "click", (e2) => {
          this.redactorClicked(e2);
        }, false), this.readOnlyMutableListeners.on(this.nodes.redactor, "mousedown", (e2) => {
          this.documentTouched(e2);
        }, true), this.readOnlyMutableListeners.on(this.nodes.redactor, "touchstart", (e2) => {
          this.documentTouched(e2);
        }, true), this.readOnlyMutableListeners.on(document, "keydown", (e2) => {
          this.documentKeydown(e2);
        }, true), this.readOnlyMutableListeners.on(document, "mousedown", (e2) => {
          this.documentClicked(e2);
        }, true), this.readOnlyMutableListeners.on(document, "selectionchange", () => {
          this.selectionChanged();
        }, true), this.readOnlyMutableListeners.on(window, "resize", () => {
          this.resizeDebouncer();
        }, {
          passive: true
        }), this.watchBlockHoveredEvents();
      }
      /**
       * Listen redactor mousemove to emit 'block-hovered' event
       */
      watchBlockHoveredEvents() {
        let e2;
        this.readOnlyMutableListeners.on(this.nodes.redactor, "mousemove", Ce((t2) => {
          const o2 = t2.target.closest(".ce-block");
          this.Editor.BlockSelection.anyBlockSelected || o2 && e2 !== o2 && (e2 = o2, this.eventsDispatcher.emit(kt, {
            block: this.Editor.BlockManager.getBlockByChildNode(o2)
          }));
        }, 20), {
          passive: true
        });
      }
      /**
       * Unbind events on the Editor.js interface
       */
      disableModuleBindings() {
        this.readOnlyMutableListeners.clearAll();
      }
      /**
       * Resize window handler
       */
      windowResize() {
        this.contentRectCache = null, this.checkIsMobile();
      }
      /**
       * All keydowns on document
       *
       * @param {KeyboardEvent} event - keyboard event
       */
      documentKeydown(e2) {
        switch (e2.keyCode) {
          case B$1.ENTER:
            this.enterPressed(e2);
            break;
          case B$1.BACKSPACE:
          case B$1.DELETE:
            this.backspacePressed(e2);
            break;
          case B$1.ESC:
            this.escapePressed(e2);
            break;
          default:
            this.defaultBehaviour(e2);
            break;
        }
      }
      /**
       * Ignore all other document's keydown events
       *
       * @param {KeyboardEvent} event - keyboard event
       */
      defaultBehaviour(e2) {
        const { currentBlock: t2 } = this.Editor.BlockManager, o2 = e2.target.closest(`.${this.CSS.editorWrapper}`), i2 = e2.altKey || e2.ctrlKey || e2.metaKey || e2.shiftKey;
        if (t2 !== void 0 && o2 === null) {
          this.Editor.BlockEvents.keydown(e2);
          return;
        }
        o2 || t2 && i2 || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());
      }
      /**
       * @param {KeyboardEvent} event - keyboard event
       */
      backspacePressed(e2) {
        const { BlockManager: t2, BlockSelection: o2, Caret: i2 } = this.Editor;
        if (o2.anyBlockSelected && !m$1.isSelectionExists) {
          const n2 = t2.removeSelectedBlocks();
          i2.setToBlock(t2.insertDefaultBlockAtIndex(n2, true), i2.positions.START), o2.clearSelection(e2), e2.preventDefault(), e2.stopPropagation(), e2.stopImmediatePropagation();
        }
      }
      /**
       * Escape pressed
       * If some of Toolbar components are opened, then close it otherwise close Toolbar
       *
       * @param {Event} event - escape keydown event
       */
      escapePressed(e2) {
        this.Editor.BlockSelection.clearSelection(e2), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.ConversionToolbar.opened ? this.Editor.ConversionToolbar.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();
      }
      /**
       * Enter pressed on document
       *
       * @param {KeyboardEvent} event - keyboard event
       */
      enterPressed(e2) {
        const { BlockManager: t2, BlockSelection: o2 } = this.Editor, i2 = t2.currentBlockIndex >= 0;
        if (o2.anyBlockSelected && !m$1.isSelectionExists) {
          o2.clearSelection(e2), e2.preventDefault(), e2.stopImmediatePropagation(), e2.stopPropagation();
          return;
        }
        if (!this.someToolbarOpened && i2 && e2.target.tagName === "BODY") {
          const n2 = this.Editor.BlockManager.insert();
          this.Editor.Caret.setToBlock(n2), this.Editor.BlockManager.highlightCurrentNode(), this.Editor.Toolbar.moveAndOpen(n2);
        }
        this.Editor.BlockSelection.clearSelection(e2);
      }
      /**
       * All clicks on document
       *
       * @param {MouseEvent} event - Click event
       */
      documentClicked(e2) {
        if (!e2.isTrusted)
          return;
        const t2 = e2.target;
        this.nodes.holder.contains(t2) || m$1.isAtEditor || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());
        const i2 = this.Editor.BlockSettings.nodes.wrapper.contains(t2), n2 = this.Editor.Toolbar.nodes.settingsToggler.contains(t2), r2 = i2 || n2;
        if (this.Editor.BlockSettings.opened && !r2) {
          this.Editor.BlockSettings.close();
          const a2 = this.Editor.BlockManager.getBlockByChildNode(t2);
          this.Editor.Toolbar.moveAndOpen(a2);
        }
        this.Editor.BlockSelection.clearSelection(e2);
      }
      /**
       * First touch on editor
       * Fired before click
       *
       * Used to change current block  we need to do it before 'selectionChange' event.
       * Also:
       * - Move and show the Toolbar
       * - Set a Caret
       *
       * @param {MouseEvent | TouchEvent} event - touch or mouse event
       */
      documentTouched(e2) {
        let t2 = e2.target;
        if (t2 === this.nodes.redactor) {
          const o2 = e2 instanceof MouseEvent ? e2.clientX : e2.touches[0].clientX, i2 = e2 instanceof MouseEvent ? e2.clientY : e2.touches[0].clientY;
          t2 = document.elementFromPoint(o2, i2);
        }
        try {
          this.Editor.BlockManager.setCurrentBlockByChildNode(t2), this.Editor.BlockManager.highlightCurrentNode();
        } catch {
          this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();
        }
        this.Editor.Toolbar.moveAndOpen();
      }
      /**
       * All clicks on the redactor zone
       *
       * @param {MouseEvent} event - click event
       * @description
       * - By clicks on the Editor's bottom zone:
       *      - if last Block is empty, set a Caret to this
       *      - otherwise, add a new empty Block and set a Caret to that
       */
      redactorClicked(e2) {
        const { BlockSelection: t2 } = this.Editor;
        if (!m$1.isCollapsed)
          return;
        const o2 = () => {
          e2.stopImmediatePropagation(), e2.stopPropagation();
        }, i2 = e2.target, n2 = e2.metaKey || e2.ctrlKey;
        if (d$1.isAnchor(i2) && n2) {
          o2();
          const u2 = i2.getAttribute("href"), h2 = zt(u2);
          $t(h2);
          return;
        }
        const r2 = this.Editor.BlockManager.getBlockByIndex(-1), a2 = d$1.offset(r2.holder).bottom, l2 = e2.pageY;
        if (e2.target instanceof Element && e2.target.isEqualNode(this.nodes.redactor) && /**
        * If there is cross block selection started, target will be equal to redactor so we need additional check
        */
        !t2.anyBlockSelected && /**
        * Prevent caret jumping (to last block) when clicking between blocks
        */
        a2 < l2) {
          o2();
          const { BlockManager: u2, Caret: h2, Toolbar: f2 } = this.Editor;
          (!u2.lastBlock.tool.isDefault || !u2.lastBlock.isEmpty) && u2.insertAtEnd(), h2.setToTheLastBlock(), f2.moveAndOpen(u2.lastBlock);
        }
      }
      /**
       * Handle selection changes on mobile devices
       * Uses for showing the Inline Toolbar
       */
      selectionChanged() {
        const { CrossBlockSelection: e2, BlockSelection: t2 } = this.Editor, o2 = m$1.anchorElement;
        if (e2.isCrossBlockSelectionStarted && t2.anyBlockSelected && m$1.get().removeAllRanges(), !o2) {
          m$1.range || this.Editor.InlineToolbar.close();
          return;
        }
        const i2 = o2.closest(`.${F$1.CSS.content}`) === null;
        if (i2 && (this.Editor.InlineToolbar.containsNode(o2) || this.Editor.InlineToolbar.close(), !(o2.dataset.inlineToolbar === "true")))
          return;
        this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o2);
        const n2 = i2 !== true;
        this.Editor.InlineToolbar.tryToShow(true, n2);
      }
    }
    const mi = {
      // API Modules
      BlocksAPI: Qt,
      CaretAPI: eo,
      EventsAPI: to,
      I18nAPI: Pe,
      API: oo,
      InlineToolbarAPI: io,
      ListenersAPI: no,
      NotifierAPI: lo,
      ReadOnlyAPI: co,
      SanitizerAPI: mo,
      SaverAPI: ko,
      SelectionAPI: vo,
      StylesAPI: xo,
      ToolbarAPI: wo,
      TooltipAPI: Bo,
      UiAPI: To,
      // Toolbar Modules
      BlockSettings: jo,
      ConversionToolbar: Y,
      Toolbar: Ko,
      InlineToolbar: Xo,
      // Modules
      BlockEvents: Vo,
      BlockManager: Go,
      BlockSelection: Jo,
      Caret: ve,
      CrossBlockSelection: Qo,
      DragNDrop: ei,
      ModificationsObserver: ti,
      Paste: yt,
      ReadOnly: oi,
      RectangleSelection: fe,
      Renderer: ii,
      Saver: ni,
      Tools: It,
      UI: bi
    };
    class ki {
      /**
       * @param {EditorConfig} config - user configuration
       */
      constructor(e2) {
        this.moduleInstances = {}, this.eventsDispatcher = new we();
        let t2, o2;
        this.isReady = new Promise((i2, n2) => {
          t2 = i2, o2 = n2;
        }), Promise.resolve().then(async () => {
          this.configuration = e2, this.validate(), this.init(), await this.start(), await this.render();
          const { BlockManager: i2, Caret: n2, UI: r2, ModificationsObserver: a2 } = this.moduleInstances;
          r2.checkEmptiness(), a2.enable(), this.configuration.autofocus && (n2.setToBlock(i2.blocks[0], n2.positions.START), i2.highlightCurrentNode()), t2();
        }).catch((i2) => {
          L$1(`Editor.js is not ready because of ${i2}`, "error"), o2(i2);
        });
      }
      /**
       * Setting for configuration
       *
       * @param {EditorConfig|string} config - Editor's config to set
       */
      set configuration(e2) {
        var o2, i2;
        z(e2) ? this.config = {
          ...e2
        } : this.config = {
          holder: e2
        }, Ie(!!this.config.holderId, "config.holderId", "config.holder"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = "editorjs"), this.config.logLevel || (this.config.logLevel = it.VERBOSE), Nt(this.config.logLevel), Ie(!!this.config.initialBlock, "config.initialBlock", "config.defaultBlock"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || "paragraph", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;
        const t2 = {
          type: this.config.defaultBlock,
          data: {}
        };
        this.config.placeholder = this.config.placeholder || false, this.config.sanitizer = this.config.sanitizer || {
          p: true,
          b: true,
          a: true
        }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : false, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {
        }), this.config.onChange = this.config.onChange || (() => {
        }), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : true, (V(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t2] }), this.config.readOnly = this.config.readOnly || false, (o2 = this.config.i18n) != null && o2.messages && $.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i2 = this.config.i18n) == null ? void 0 : i2.direction) || "ltr";
      }
      /**
       * Returns private property
       *
       * @returns {EditorConfig}
       */
      get configuration() {
        return this.config;
      }
      /**
       * Checks for required fields in Editor's config
       */
      validate() {
        const { holderId: e2, holder: t2 } = this.config;
        if (e2 && t2)
          throw Error("holderId and holder param can't assign at the same time.");
        if (J(t2) && !d$1.get(t2))
          throw Error(`element with ID ${t2} is missing. Pass correct holder's ID.`);
        if (t2 && z(t2) && !d$1.isElement(t2))
          throw Error("holder value must be an Element node");
      }
      /**
       * Initializes modules:
       *  - make and save instances
       *  - configure
       */
      init() {
        this.constructModules(), this.configureModules();
      }
      /**
       * Start Editor!
       *
       * Get list of modules that needs to be prepared and return a sequence (Promise)
       *
       * @returns {Promise<void>}
       */
      async start() {
        await [
          "Tools",
          "UI",
          "BlockManager",
          "Paste",
          "BlockSelection",
          "RectangleSelection",
          "CrossBlockSelection",
          "ReadOnly"
        ].reduce(
          (t2, o2) => t2.then(async () => {
            try {
              await this.moduleInstances[o2].prepare();
            } catch (i2) {
              if (i2 instanceof lt)
                throw new Error(i2.message);
              L$1(`Module ${o2} was skipped because of %o`, "warn", i2);
            }
          }),
          Promise.resolve()
        );
      }
      /**
       * Render initial data
       */
      render() {
        return this.moduleInstances.Renderer.render(this.config.data.blocks);
      }
      /**
       * Make modules instances and save it to the @property this.moduleInstances
       */
      constructModules() {
        Object.entries(mi).forEach(([e2, t2]) => {
          try {
            this.moduleInstances[e2] = new t2({
              config: this.configuration,
              eventsDispatcher: this.eventsDispatcher
            });
          } catch (o2) {
            L$1("[constructModules]", `Module ${e2} skipped because`, "error", o2);
          }
        });
      }
      /**
       * Modules instances configuration:
       *  - pass other modules to the 'state' property
       *  - ...
       */
      configureModules() {
        for (const e2 in this.moduleInstances)
          Object.prototype.hasOwnProperty.call(this.moduleInstances, e2) && (this.moduleInstances[e2].state = this.getModulesDiff(e2));
      }
      /**
       * Return modules without passed name
       *
       * @param {string} name - module for witch modules difference should be calculated
       */
      getModulesDiff(e2) {
        const t2 = {};
        for (const o2 in this.moduleInstances)
          o2 !== e2 && (t2[o2] = this.moduleInstances[o2]);
        return t2;
      }
    }
    /**
     * Editor.js
     *
     * @license Apache-2.0
     * @see Editor.js <https://editorjs.io>
     * @author CodeX Team <https://codex.so>
     */
    class vi {
      /** Editor version */
      static get version() {
        return "2.28.2";
      }
      /**
       * @param {EditorConfig|string|undefined} [configuration] - user configuration
       */
      constructor(e2) {
        let t2 = () => {
        };
        z(e2) && D$1(e2.onReady) && (t2 = e2.onReady);
        const o2 = new ki(e2);
        this.isReady = o2.isReady.then(() => {
          this.exportAPI(o2), t2();
        });
      }
      /**
       * Export external API methods
       *
       * @param {Core} editor  Editor's instance
       */
      exportAPI(e2) {
        const t2 = ["configuration"], o2 = () => {
          Object.values(e2.moduleInstances).forEach((n2) => {
            D$1(n2.destroy) && n2.destroy(), n2.listeners.removeAll();
          }), e2 = null;
          for (const n2 in this)
            Object.prototype.hasOwnProperty.call(this, n2) && delete this[n2];
          Object.setPrototypeOf(this, null);
        };
        t2.forEach((n2) => {
          this[n2] = e2[n2];
        }), this.destroy = o2, Object.setPrototypeOf(this, e2.moduleInstances.API.methods), delete this.exportAPI, Object.entries({
          blocks: {
            clear: "clear",
            render: "render"
          },
          caret: {
            focus: "focus"
          },
          events: {
            on: "on",
            off: "off",
            emit: "emit"
          },
          saver: {
            save: "save"
          }
        }).forEach(([n2, r2]) => {
          Object.entries(r2).forEach(([a2, l2]) => {
            this[l2] = e2.moduleInstances.API.methods[n2][a2];
          });
        });
      }
    }
    (function() {
      try {
        if (typeof document < "u") {
          var e2 = document.createElement("style");
          e2.appendChild(document.createTextNode('.embed-tool--loading .embed-tool__caption{display:none}.embed-tool--loading .embed-tool__preloader{display:block}.embed-tool--loading .embed-tool__content{display:none}.embed-tool__preloader{display:none;position:relative;height:200px;box-sizing:border-box;border-radius:5px;border:1px solid #e6e9eb}.embed-tool__preloader:before{content:"";position:absolute;z-index:3;left:50%;top:50%;width:30px;height:30px;margin-top:-25px;margin-left:-15px;border-radius:50%;border:2px solid #cdd1e0;border-top-color:#388ae5;box-sizing:border-box;animation:embed-preloader-spin 2s infinite linear}.embed-tool__url{position:absolute;bottom:20px;left:50%;transform:translate(-50%);max-width:250px;color:#7b7e89;font-size:11px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.embed-tool__content{width:100%}.embed-tool__caption{margin-top:7px}.embed-tool__caption[contentEditable=true][data-placeholder]:before{position:absolute;content:attr(data-placeholder);color:#707684;font-weight:400;opacity:0}.embed-tool__caption[contentEditable=true][data-placeholder]:empty:before{opacity:1}.embed-tool__caption[contentEditable=true][data-placeholder]:empty:focus:before{opacity:0}@keyframes embed-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')), document.head.appendChild(e2);
        }
      } catch (o2) {
        console.error("vite-plugin-css-injected-by-js", o2);
      }
    })();
    const g = {
      vimeo: {
        regex: /(?:http[s]?:\/\/)?(?:www.)?(?:player.)?vimeo\.co(?:.+\/([^\/]\d+)(?:#t=[\d]+)?s?$)/,
        embedUrl: "https://player.vimeo.com/video/<%= remote_id %>?title=0&byline=0",
        html: '<iframe style="width:100%;" height="320" frameborder="0"></iframe>',
        height: 320,
        width: 580
      },
      youtube: {
        regex: /(?:https?:\/\/)?(?:www\.)?(?:(?:youtu\.be\/)|(?:youtube\.com)\/(?:v\/|u\/\w\/|embed\/|watch))(?:(?:\?v=)?([^#&?=]*))?((?:[?&]\w*=\w*)*)/,
        embedUrl: "https://www.youtube.com/embed/<%= remote_id %>",
        html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>',
        height: 320,
        width: 580,
        id: ([o2, t2]) => {
          if (!t2 && o2)
            return o2;
          const i2 = {
            start: "start",
            end: "end",
            t: "start",
            // eslint-disable-next-line camelcase
            time_continue: "start",
            list: "list"
          };
          return t2 = t2.slice(1).split("&").map((e2) => {
            const [s2, n2] = e2.split("=");
            return !o2 && s2 === "v" ? (o2 = n2, null) : !i2[s2] || n2 === "LL" || n2.startsWith("RDMM") || n2.startsWith("FL") ? null : `${i2[s2]}=${n2}`;
          }).filter((e2) => !!e2), o2 + "?" + t2.join("&");
        }
      },
      coub: {
        regex: /https?:\/\/coub\.com\/view\/([^\/\?\&]+)/,
        embedUrl: "https://coub.com/embed/<%= remote_id %>",
        html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>',
        height: 320,
        width: 580
      },
      vine: {
        regex: /https?:\/\/vine\.co\/v\/([^\/\?\&]+)/,
        embedUrl: "https://vine.co/v/<%= remote_id %>/embed/simple/",
        html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>',
        height: 320,
        width: 580
      },
      imgur: {
        regex: /https?:\/\/(?:i\.)?imgur\.com.*\/([a-zA-Z0-9]+)(?:\.gifv)?/,
        embedUrl: "http://imgur.com/<%= remote_id %>/embed",
        html: '<iframe allowfullscreen="true" scrolling="no" id="imgur-embed-iframe-pub-<%= remote_id %>" class="imgur-embed-iframe-pub" style="height: 500px; width: 100%; border: 1px solid #000"></iframe>',
        height: 500,
        width: 540
      },
      gfycat: {
        regex: /https?:\/\/gfycat\.com(?:\/detail)?\/([a-zA-Z]+)/,
        embedUrl: "https://gfycat.com/ifr/<%= remote_id %>",
        html: `<iframe frameborder='0' scrolling='no' style="width:100%;" height='436' allowfullscreen ></iframe>`,
        height: 436,
        width: 580
      },
      "twitch-channel": {
        regex: /https?:\/\/www\.twitch\.tv\/([^\/\?\&]*)\/?$/,
        embedUrl: "https://player.twitch.tv/?channel=<%= remote_id %>",
        html: '<iframe frameborder="0" allowfullscreen="true" scrolling="no" height="366" style="width:100%;"></iframe>',
        height: 366,
        width: 600
      },
      "twitch-video": {
        regex: /https?:\/\/www\.twitch\.tv\/(?:[^\/\?\&]*\/v|videos)\/([0-9]*)/,
        embedUrl: "https://player.twitch.tv/?video=v<%= remote_id %>",
        html: '<iframe frameborder="0" allowfullscreen="true" scrolling="no" height="366" style="width:100%;"></iframe>',
        height: 366,
        width: 600
      },
      "yandex-music-album": {
        regex: /https?:\/\/music\.yandex\.ru\/album\/([0-9]*)\/?$/,
        embedUrl: "https://music.yandex.ru/iframe/#album/<%= remote_id %>/",
        html: '<iframe frameborder="0" style="border:none;width:540px;height:400px;" style="width:100%;" height="400"></iframe>',
        height: 400,
        width: 540
      },
      "yandex-music-track": {
        regex: /https?:\/\/music\.yandex\.ru\/album\/([0-9]*)\/track\/([0-9]*)/,
        embedUrl: "https://music.yandex.ru/iframe/#track/<%= remote_id %>/",
        html: '<iframe frameborder="0" style="border:none;width:540px;height:100px;" style="width:100%;" height="100"></iframe>',
        height: 100,
        width: 540,
        id: (o2) => o2.join("/")
      },
      "yandex-music-playlist": {
        regex: /https?:\/\/music\.yandex\.ru\/users\/([^\/\?\&]*)\/playlists\/([0-9]*)/,
        embedUrl: "https://music.yandex.ru/iframe/#playlist/<%= remote_id %>/show/cover/description/",
        html: '<iframe frameborder="0" style="border:none;width:540px;height:400px;" width="540" height="400"></iframe>',
        height: 400,
        width: 540,
        id: (o2) => o2.join("/")
      },
      codepen: {
        regex: /https?:\/\/codepen\.io\/([^\/\?\&]*)\/pen\/([^\/\?\&]*)/,
        embedUrl: "https://codepen.io/<%= remote_id %>?height=300&theme-id=0&default-tab=css,result&embed-version=2",
        html: "<iframe height='300' scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'></iframe>",
        height: 300,
        width: 600,
        id: (o2) => o2.join("/embed/")
      },
      instagram: {
        regex: /https?:\/\/www\.instagram\.com\/p\/([^\/\?\&]+)\/?.*/,
        embedUrl: "https://www.instagram.com/p/<%= remote_id %>/embed",
        html: '<iframe width="400" height="505" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>',
        height: 505,
        width: 400
      },
      twitter: {
        regex: /^https?:\/\/twitter\.com\/(?:#!\/)?(\w+)\/status(?:es)?\/(\d+?.*)?$/,
        embedUrl: "https://twitframe.com/show?url=https://twitter.com/<%= remote_id %>",
        html: '<iframe width="600" height="600" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>',
        height: 300,
        width: 600,
        id: (o2) => o2.join("/status/")
      },
      pinterest: {
        regex: /https?:\/\/([^\/\?\&]*).pinterest.com\/pin\/([^\/\?\&]*)\/?$/,
        embedUrl: "https://assets.pinterest.com/ext/embed.html?id=<%= remote_id %>",
        html: "<iframe scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%; min-height: 400px; max-height: 1000px;'></iframe>",
        id: (o2) => o2[1]
      },
      facebook: {
        regex: /https?:\/\/www.facebook.com\/([^\/\?\&]*)\/(.*)/,
        embedUrl: "https://www.facebook.com/plugins/post.php?href=https://www.facebook.com/<%= remote_id %>&width=500",
        html: "<iframe scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%; min-height: 500px; max-height: 1000px;'></iframe>",
        id: (o2) => o2.join("/")
      },
      aparat: {
        regex: /(?:http[s]?:\/\/)?(?:www.)?aparat\.com\/v\/([^\/\?\&]+)\/?/,
        embedUrl: "https://www.aparat.com/video/video/embed/videohash/<%= remote_id %>/vt/frame",
        html: '<iframe width="600" height="300" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>',
        height: 300,
        width: 600
      },
      miro: {
        regex: /https:\/\/miro.com\/\S+(\S{12})\/(\S+)?/,
        embedUrl: "https://miro.com/app/live-embed/<%= remote_id %>",
        html: '<iframe width="700" height="500" style="margin: 0 auto;" allowFullScreen frameBorder="0" scrolling="no"></iframe>'
      },
      github: {
        regex: /https?:\/\/gist.github.com\/([^\/\?\&]*)\/([^\/\?\&]*)/,
        embedUrl: 'data:text/html;charset=utf-8,<head><base target="_blank" /></head><body><script src="https://gist.github.com/<%= remote_id %>" ><\/script></body>',
        html: '<iframe width="100%" height="350" frameborder="0" style="margin: 0 auto;"></iframe>',
        height: 300,
        width: 600,
        id: (o2) => `${o2.join("/")}.js`
      }
    };
    function u(o2, t2, i2) {
      var e2, s2, n2, r2, a2;
      t2 == null && (t2 = 100);
      function l2() {
        var h2 = Date.now() - r2;
        h2 < t2 && h2 >= 0 ? e2 = setTimeout(l2, t2 - h2) : (e2 = null, i2 || (a2 = o2.apply(n2, s2), n2 = s2 = null));
      }
      var d2 = function() {
        n2 = this, s2 = arguments, r2 = Date.now();
        var h2 = i2 && !e2;
        return e2 || (e2 = setTimeout(l2, t2)), h2 && (a2 = o2.apply(n2, s2), n2 = s2 = null), a2;
      };
      return d2.clear = function() {
        e2 && (clearTimeout(e2), e2 = null);
      }, d2.flush = function() {
        e2 && (a2 = o2.apply(n2, s2), n2 = s2 = null, clearTimeout(e2), e2 = null);
      }, d2;
    }
    u.debounce = u;
    var w = u;
    class m {
      /**
       * @param {{data: EmbedData, config: EmbedConfig, api: object}}
       *   data  previously saved data
       *   config - user config for Tool
       *   api - Editor.js API
       *   readOnly - read-only mode flag
       */
      constructor({ data: t2, api: i2, readOnly: e2 }) {
        this.api = i2, this._data = {}, this.element = null, this.readOnly = e2, this.data = t2;
      }
      /**
       * @param {EmbedData} data - embed data
       * @param {RegExp} [data.regex] - pattern of source URLs
       * @param {string} [data.embedUrl] - URL scheme to embedded page. Use '<%= remote_id %>' to define a place to insert resource id
       * @param {string} [data.html] - iframe which contains embedded content
       * @param {number} [data.height] - iframe height
       * @param {number} [data.width] - iframe width
       * @param {string} [data.caption] - caption
       */
      set data(t2) {
        if (!(t2 instanceof Object))
          throw Error("Embed Tool data should be object");
        const { service: i2, source: e2, embed: s2, width: n2, height: r2, caption: a2 = "" } = t2;
        this._data = {
          service: i2 || this.data.service,
          source: e2 || this.data.source,
          embed: s2 || this.data.embed,
          width: n2 || this.data.width,
          height: r2 || this.data.height,
          caption: a2 || this.data.caption || ""
        };
        const l2 = this.element;
        l2 && l2.parentNode.replaceChild(this.render(), l2);
      }
      /**
       * @returns {EmbedData}
       */
      get data() {
        if (this.element) {
          const t2 = this.element.querySelector(`.${this.api.styles.input}`);
          this._data.caption = t2 ? t2.innerHTML : "";
        }
        return this._data;
      }
      /**
       * Get plugin styles
       *
       * @returns {object}
       */
      get CSS() {
        return {
          baseClass: this.api.styles.block,
          input: this.api.styles.input,
          container: "embed-tool",
          containerLoading: "embed-tool--loading",
          preloader: "embed-tool__preloader",
          caption: "embed-tool__caption",
          url: "embed-tool__url",
          content: "embed-tool__content"
        };
      }
      /**
       * Render Embed tool content
       *
       * @returns {HTMLElement}
       */
      render() {
        if (!this.data.service) {
          const a2 = document.createElement("div");
          return this.element = a2, a2;
        }
        const { html: t2 } = m.services[this.data.service], i2 = document.createElement("div"), e2 = document.createElement("div"), s2 = document.createElement("template"), n2 = this.createPreloader();
        i2.classList.add(this.CSS.baseClass, this.CSS.container, this.CSS.containerLoading), e2.classList.add(this.CSS.input, this.CSS.caption), i2.appendChild(n2), e2.contentEditable = !this.readOnly, e2.dataset.placeholder = this.api.i18n.t("Enter a caption"), e2.innerHTML = this.data.caption || "", s2.innerHTML = t2, s2.content.firstChild.setAttribute("src", this.data.embed), s2.content.firstChild.classList.add(this.CSS.content);
        const r2 = this.embedIsReady(i2);
        return i2.appendChild(s2.content.firstChild), i2.appendChild(e2), r2.then(() => {
          i2.classList.remove(this.CSS.containerLoading);
        }), this.element = i2, i2;
      }
      /**
       * Creates preloader to append to container while data is loading
       *
       * @returns {HTMLElement}
       */
      createPreloader() {
        const t2 = document.createElement("preloader"), i2 = document.createElement("div");
        return i2.textContent = this.data.source, t2.classList.add(this.CSS.preloader), i2.classList.add(this.CSS.url), t2.appendChild(i2), t2;
      }
      /**
       * Save current content and return EmbedData object
       *
       * @returns {EmbedData}
       */
      save() {
        return this.data;
      }
      /**
       * Handle pasted url and return Service object
       *
       * @param {PasteEvent} event - event with pasted data
       */
      onPaste(t2) {
        const { key: i2, data: e2 } = t2.detail, { regex: s2, embedUrl: n2, width: r2, height: a2, id: l2 = (c2) => c2.shift() } = m.services[i2], d2 = s2.exec(e2).slice(1), h2 = n2.replace(/<%= remote_id %>/g, l2(d2));
        this.data = {
          service: i2,
          source: e2,
          embed: h2,
          width: r2,
          height: a2
        };
      }
      /**
       * Analyze provided config and make object with services to use
       *
       * @param {EmbedConfig} config - configuration of embed block element
       */
      static prepare({ config: t2 = {} }) {
        const { services: i2 = {} } = t2;
        let e2 = Object.entries(g);
        const s2 = Object.entries(i2).filter(([r2, a2]) => typeof a2 == "boolean" && a2 === true).map(([r2]) => r2), n2 = Object.entries(i2).filter(([r2, a2]) => typeof a2 == "object").filter(([r2, a2]) => m.checkServiceConfig(a2)).map(([r2, a2]) => {
          const { regex: l2, embedUrl: d2, html: h2, height: c2, width: p2, id: f2 } = a2;
          return [r2, {
            regex: l2,
            embedUrl: d2,
            html: h2,
            height: c2,
            width: p2,
            id: f2
          }];
        });
        s2.length && (e2 = e2.filter(([r2]) => s2.includes(r2))), e2 = e2.concat(n2), m.services = e2.reduce((r2, [a2, l2]) => a2 in r2 ? (r2[a2] = Object.assign({}, r2[a2], l2), r2) : (r2[a2] = l2, r2), {}), m.patterns = e2.reduce((r2, [a2, l2]) => (r2[a2] = l2.regex, r2), {});
      }
      /**
       * Check if Service config is valid
       *
       * @param {Service} config - configuration of embed block element
       * @returns {boolean}
       */
      static checkServiceConfig(t2) {
        const { regex: i2, embedUrl: e2, html: s2, height: n2, width: r2, id: a2 } = t2;
        let l2 = i2 && i2 instanceof RegExp && e2 && typeof e2 == "string" && s2 && typeof s2 == "string";
        return l2 = l2 && (a2 !== void 0 ? a2 instanceof Function : true), l2 = l2 && (n2 !== void 0 ? Number.isFinite(n2) : true), l2 = l2 && (r2 !== void 0 ? Number.isFinite(r2) : true), l2;
      }
      /**
       * Paste configuration to enable pasted URLs processing by Editor
       *
       * @returns {object} - object of patterns which contain regx for pasteConfig
       */
      static get pasteConfig() {
        return {
          patterns: m.patterns
        };
      }
      /**
       * Notify core that read-only mode is supported
       *
       * @returns {boolean}
       */
      static get isReadOnlySupported() {
        return true;
      }
      /**
       * Checks that mutations in DOM have finished after appending iframe content
       *
       * @param {HTMLElement} targetNode - HTML-element mutations of which to listen
       * @returns {Promise<any>} - result that all mutations have finished
       */
      embedIsReady(t2) {
        let e2 = null;
        return new Promise((s2, n2) => {
          e2 = new MutationObserver(w.debounce(s2, 450)), e2.observe(t2, {
            childList: true,
            subtree: true
          });
        }).then(() => {
          e2.disconnect();
        });
      }
    }
    (function() {
      try {
        if (typeof document < "u") {
          var e2 = document.createElement("style");
          e2.appendChild(document.createTextNode(".cdx-list{margin:0;padding-left:40px;outline:none}.cdx-list__item{padding:5.5px 0 5.5px 3px;line-height:1.6em}.cdx-list--unordered{list-style:disc}.cdx-list--ordered{list-style:decimal}.cdx-list-settings{display:flex}.cdx-list-settings .cdx-settings-button{width:50%}")), document.head.appendChild(e2);
        }
      } catch (t2) {
        console.error("vite-plugin-css-injected-by-js", t2);
      }
    })();
    const a = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="9" x2="19" y1="7" y2="7" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="9" x2="19" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="9" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 17H4.99002"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 12H4.99002"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 7H4.99002"/></svg>', o$1 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="12" x2="19" y1="7" y2="7" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="12" x2="19" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="12" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5"/></svg>';
    class d {
      /**
       * Notify core that read-only mode is supported
       *
       * @returns {boolean}
       */
      static get isReadOnlySupported() {
        return true;
      }
      /**
       * Allow to use native Enter behaviour
       *
       * @returns {boolean}
       * @public
       */
      static get enableLineBreaks() {
        return true;
      }
      /**
       * Get Tool toolbox settings
       * icon - Tool icon's SVG
       * title - title to show in toolbox
       *
       * @returns {{icon: string, title: string}}
       */
      static get toolbox() {
        return {
          icon: a,
          title: "List"
        };
      }
      /**
       * Render plugin`s main Element and fill it with saved data
       *
       * @param {object} params - tool constructor options
       * @param {ListData} params.data - previously saved data
       * @param {object} params.config - user config for Tool
       * @param {object} params.api - Editor.js API
       * @param {boolean} params.readOnly - read-only mode flag
       */
      constructor({ data: e2, config: t2, api: r2, readOnly: s2 }) {
        this._elements = {
          wrapper: null
        }, this.api = r2, this.readOnly = s2, this.settings = [
          {
            name: "unordered",
            label: this.api.i18n.t("Unordered"),
            icon: a,
            default: t2.defaultStyle === "unordered" || false
          },
          {
            name: "ordered",
            label: this.api.i18n.t("Ordered"),
            icon: o$1,
            default: t2.defaultStyle === "ordered" || true
          }
        ], this._data = {
          style: this.settings.find((i2) => i2.default === true).name,
          items: []
        }, this.data = e2;
      }
      /**
       * Returns list tag with items
       *
       * @returns {Element}
       * @public
       */
      render() {
        return this._elements.wrapper = this.makeMainTag(this._data.style), this._data.items.length ? this._data.items.forEach((e2) => {
          this._elements.wrapper.appendChild(this._make("li", this.CSS.item, {
            innerHTML: e2
          }));
        }) : this._elements.wrapper.appendChild(this._make("li", this.CSS.item)), this.readOnly || this._elements.wrapper.addEventListener("keydown", (e2) => {
          const [t2, r2] = [13, 8];
          switch (e2.keyCode) {
            case t2:
              this.getOutofList(e2);
              break;
            case r2:
              this.backspace(e2);
              break;
          }
        }, false), this._elements.wrapper;
      }
      /**
       * @returns {ListData}
       * @public
       */
      save() {
        return this.data;
      }
      /**
       * Allow List Tool to be converted to/from other block
       *
       * @returns {{export: Function, import: Function}}
       */
      static get conversionConfig() {
        return {
          /**
           * To create exported string from list, concatenate items by dot-symbol.
           *
           * @param {ListData} data - list data to create a string from thats
           * @returns {string}
           */
          export: (e2) => e2.items.join(". "),
          /**
           * To create a list from other block's string, just put it at the first item
           *
           * @param {string} string - string to create list tool data from that
           * @returns {ListData}
           */
          import: (e2) => ({
            items: [e2],
            style: "unordered"
          })
        };
      }
      /**
       * Sanitizer rules
       *
       * @returns {object}
       */
      static get sanitize() {
        return {
          style: {},
          items: {
            br: true
          }
        };
      }
      /**
       * Settings
       *
       * @public
       * @returns {Array}
       */
      renderSettings() {
        return this.settings.map((e2) => ({
          ...e2,
          isActive: this._data.style === e2.name,
          closeOnActivate: true,
          onActivate: () => this.toggleTune(e2.name)
        }));
      }
      /**
       * On paste callback that is fired from Editor
       *
       * @param {PasteEvent} event - event with pasted data
       */
      onPaste(e2) {
        const t2 = e2.detail.data;
        this.data = this.pasteHandler(t2);
      }
      /**
       * List Tool on paste configuration
       *
       * @public
       */
      static get pasteConfig() {
        return {
          tags: ["OL", "UL", "LI"]
        };
      }
      /**
       * Creates main <ul> or <ol> tag depended on style
       *
       * @param {string} style - 'ordered' or 'unordered'
       * @returns {HTMLOListElement|HTMLUListElement}
       */
      makeMainTag(e2) {
        const t2 = e2 === "ordered" ? this.CSS.wrapperOrdered : this.CSS.wrapperUnordered, r2 = e2 === "ordered" ? "ol" : "ul";
        return this._make(r2, [this.CSS.baseBlock, this.CSS.wrapper, t2], {
          contentEditable: !this.readOnly
        });
      }
      /**
       * Toggles List style
       *
       * @param {string} style - 'ordered'|'unordered'
       */
      toggleTune(e2) {
        const t2 = this.makeMainTag(e2);
        for (; this._elements.wrapper.hasChildNodes(); )
          t2.appendChild(this._elements.wrapper.firstChild);
        this._elements.wrapper.replaceWith(t2), this._elements.wrapper = t2, this._data.style = e2;
      }
      /**
       * Styles
       *
       * @private
       */
      get CSS() {
        return {
          baseBlock: this.api.styles.block,
          wrapper: "cdx-list",
          wrapperOrdered: "cdx-list--ordered",
          wrapperUnordered: "cdx-list--unordered",
          item: "cdx-list__item"
        };
      }
      /**
       * List data setter
       *
       * @param {ListData} listData
       */
      set data(e2) {
        e2 || (e2 = {}), this._data.style = e2.style || this.settings.find((r2) => r2.default === true).name, this._data.items = e2.items || [];
        const t2 = this._elements.wrapper;
        t2 && t2.parentNode.replaceChild(this.render(), t2);
      }
      /**
       * Return List data
       *
       * @returns {ListData}
       */
      get data() {
        this._data.items = [];
        const e2 = this._elements.wrapper.querySelectorAll(`.${this.CSS.item}`);
        for (let t2 = 0; t2 < e2.length; t2++)
          e2[t2].innerHTML.replace("<br>", " ").trim() && this._data.items.push(e2[t2].innerHTML);
        return this._data;
      }
      /**
       * Helper for making Elements with attributes
       *
       * @param  {string} tagName           - new Element tag name
       * @param  {Array|string} classNames  - list or name of CSS classname(s)
       * @param  {object} attributes        - any attributes
       * @returns {Element}
       */
      _make(e2, t2 = null, r2 = {}) {
        const s2 = document.createElement(e2);
        Array.isArray(t2) ? s2.classList.add(...t2) : t2 && s2.classList.add(t2);
        for (const i2 in r2)
          s2[i2] = r2[i2];
        return s2;
      }
      /**
       * Returns current List item by the caret position
       *
       * @returns {Element}
       */
      get currentItem() {
        let e2 = window.getSelection().anchorNode;
        return e2.nodeType !== Node.ELEMENT_NODE && (e2 = e2.parentNode), e2.closest(`.${this.CSS.item}`);
      }
      /**
       * Get out from List Tool
       * by Enter on the empty last item
       *
       * @param {KeyboardEvent} event
       */
      getOutofList(e2) {
        const t2 = this._elements.wrapper.querySelectorAll("." + this.CSS.item);
        if (t2.length < 2)
          return;
        const r2 = t2[t2.length - 1], s2 = this.currentItem;
        s2 === r2 && !r2.textContent.trim().length && (s2.parentElement.removeChild(s2), this.api.blocks.insert(), this.api.caret.setToBlock(this.api.blocks.getCurrentBlockIndex()), e2.preventDefault(), e2.stopPropagation());
      }
      /**
       * Handle backspace
       *
       * @param {KeyboardEvent} event
       */
      backspace(e2) {
        const t2 = this._elements.wrapper.querySelectorAll("." + this.CSS.item), r2 = t2[0];
        r2 && t2.length < 2 && !r2.innerHTML.replace("<br>", " ").trim() && e2.preventDefault();
      }
      /**
       * Select LI content by CMD+A
       *
       * @param {KeyboardEvent} event
       */
      selectItem(e2) {
        e2.preventDefault();
        const t2 = window.getSelection(), r2 = t2.anchorNode.parentNode, s2 = r2.closest("." + this.CSS.item), i2 = new Range();
        i2.selectNodeContents(s2), t2.removeAllRanges(), t2.addRange(i2);
      }
      /**
       * Handle UL, OL and LI tags paste and returns List data
       *
       * @param {HTMLUListElement|HTMLOListElement|HTMLLIElement} element
       * @returns {ListData}
       */
      pasteHandler(e2) {
        const { tagName: t2 } = e2;
        let r2;
        switch (t2) {
          case "OL":
            r2 = "ordered";
            break;
          case "UL":
          case "LI":
            r2 = "unordered";
        }
        const s2 = {
          style: r2,
          items: []
        };
        if (t2 === "LI")
          s2.items = [e2.innerHTML];
        else {
          const i2 = Array.from(e2.querySelectorAll("LI"));
          s2.items = i2.map((n2) => n2.innerHTML).filter((n2) => !!n2.trim());
        }
        return s2;
      }
    }
    (function() {
      try {
        if (typeof document < "u") {
          var o2 = document.createElement("style");
          o2.appendChild(document.createTextNode('.image-tool{--bg-color: #cdd1e0;--front-color: #388ae5;--border-color: #e8e8eb}.image-tool__image{border-radius:3px;overflow:hidden;margin-bottom:10px}.image-tool__image-picture{max-width:100%;vertical-align:bottom;display:block}.image-tool__image-preloader{width:50px;height:50px;border-radius:50%;background-size:cover;margin:auto;position:relative;background-color:var(--bg-color);background-position:center center}.image-tool__image-preloader:after{content:"";position:absolute;z-index:3;width:60px;height:60px;border-radius:50%;border:2px solid var(--bg-color);border-top-color:var(--front-color);left:50%;top:50%;margin-top:-30px;margin-left:-30px;animation:image-preloader-spin 2s infinite linear;box-sizing:border-box}.image-tool__caption[contentEditable=true][data-placeholder]:before{position:absolute!important;content:attr(data-placeholder);color:#707684;font-weight:400;display:none}.image-tool__caption[contentEditable=true][data-placeholder]:empty:before{display:block}.image-tool__caption[contentEditable=true][data-placeholder]:empty:focus:before{display:none}.image-tool--empty .image-tool__image,.image-tool--empty .image-tool__caption,.image-tool--loading .image-tool__caption{display:none}.image-tool .cdx-button{display:flex;align-items:center;justify-content:center}.image-tool .cdx-button svg{height:auto;margin:0 6px 0 0}.image-tool--filled .cdx-button,.image-tool--filled .image-tool__image-preloader{display:none}.image-tool--loading .image-tool__image{min-height:200px;display:flex;border:1px solid var(--border-color);background-color:#fff}.image-tool--loading .image-tool__image-picture,.image-tool--loading .cdx-button{display:none}.image-tool--withBorder .image-tool__image{border:1px solid var(--border-color)}.image-tool--withBackground .image-tool__image{padding:15px;background:var(--bg-color)}.image-tool--withBackground .image-tool__image-picture{max-width:60%;margin:0 auto}.image-tool--stretched .image-tool__image-picture{width:100%}@keyframes image-preloader-spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}')), document.head.appendChild(o2);
        }
      } catch (e2) {
        console.error("vite-plugin-css-injected-by-js", e2);
      }
    })();
    const R = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19V19C9.13623 19 8.20435 19 7.46927 18.6955C6.48915 18.2895 5.71046 17.5108 5.30448 16.5307C5 15.7956 5 14.8638 5 13V12C5 9.19108 5 7.78661 5.67412 6.77772C5.96596 6.34096 6.34096 5.96596 6.77772 5.67412C7.78661 5 9.19108 5 12 5H13.5C14.8956 5 15.5933 5 16.1611 5.17224C17.4395 5.56004 18.44 6.56046 18.8278 7.83886C19 8.40666 19 9.10444 19 10.5V10.5"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 13V16M16 19V16M19 16H16M16 16H13"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6.5 17.5L17.5 6.5"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.9919 10.5H19.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.9919 19H11.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13L13 5"/></svg>', H = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.9919 9.5H19.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.5 5H14.5096"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.625 5H15C17.2091 5 19 6.79086 19 9V9.375"/><path stroke="currentColor" stroke-width="2" d="M9.375 5L9 5C6.79086 5 5 6.79086 5 9V9.375"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.3725 5H9.38207"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 9.5H5.00957"/><path stroke="currentColor" stroke-width="2" d="M9.375 19H9C6.79086 19 5 17.2091 5 15V14.625"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.3725 19H9.38207"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 14.55H5.00957"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 13V16M16 19V16M19 16H16M16 16H13"/></svg>', L = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.13968 15.32L8.69058 11.5661C9.02934 11.2036 9.48873 11 9.96774 11C10.4467 11 10.9061 11.2036 11.2449 11.5661L15.3871 16M13.5806 14.0664L15.0132 12.533C15.3519 12.1705 15.8113 11.9668 16.2903 11.9668C16.7693 11.9668 17.2287 12.1705 17.5675 12.533L18.841 13.9634"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.7778 9.33331H13.7867"/></svg>', D = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9L20 12L17 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 12H20"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9L4 12L7 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12H10"/></svg>';
    function M(E2, a2 = null, i2 = {}) {
      const c2 = document.createElement(E2);
      Array.isArray(a2) ? c2.classList.add(...a2) : a2 && c2.classList.add(a2);
      for (const r2 in i2)
        c2[r2] = i2[r2];
      return c2;
    }
    class j {
      /**
       * @param {object} ui - image tool Ui module
       * @param {object} ui.api - Editor.js API
       * @param {ImageConfig} ui.config - user config
       * @param {Function} ui.onSelectFile - callback for clicks on Select file button
       * @param {boolean} ui.readOnly - read-only mode flag
       */
      constructor({ api: a2, config: i2, onSelectFile: c2, readOnly: r2 }) {
        this.api = a2, this.config = i2, this.onSelectFile = c2, this.readOnly = r2, this.nodes = {
          wrapper: M("div", [this.CSS.baseClass, this.CSS.wrapper]),
          imageContainer: M("div", [this.CSS.imageContainer]),
          fileButton: this.createFileButton(),
          imageEl: void 0,
          imagePreloader: M("div", this.CSS.imagePreloader),
          caption: M("div", [this.CSS.input, this.CSS.caption], {
            contentEditable: !this.readOnly
          })
        }, this.nodes.caption.dataset.placeholder = this.config.captionPlaceholder, this.nodes.imageContainer.appendChild(this.nodes.imagePreloader), this.nodes.wrapper.appendChild(this.nodes.imageContainer), this.nodes.wrapper.appendChild(this.nodes.caption), this.nodes.wrapper.appendChild(this.nodes.fileButton);
      }
      /**
       * CSS classes
       *
       * @returns {object}
       */
      get CSS() {
        return {
          baseClass: this.api.styles.block,
          loading: this.api.styles.loader,
          input: this.api.styles.input,
          button: this.api.styles.button,
          /**
           * Tool's classes
           */
          wrapper: "image-tool",
          imageContainer: "image-tool__image",
          imagePreloader: "image-tool__image-preloader",
          imageEl: "image-tool__image-picture",
          caption: "image-tool__caption"
        };
      }
      /**
       * Ui statuses:
       * - empty
       * - uploading
       * - filled
       *
       * @returns {{EMPTY: string, UPLOADING: string, FILLED: string}}
       */
      static get status() {
        return {
          EMPTY: "empty",
          UPLOADING: "loading",
          FILLED: "filled"
        };
      }
      /**
       * Renders tool UI
       *
       * @param {ImageToolData} toolData - saved tool data
       * @returns {Element}
       */
      render(a2) {
        return !a2.file || Object.keys(a2.file).length === 0 ? this.toggleStatus(j.status.EMPTY) : this.toggleStatus(j.status.UPLOADING), this.nodes.wrapper;
      }
      /**
       * Creates upload-file button
       *
       * @returns {Element}
       */
      createFileButton() {
        const a2 = M("div", [this.CSS.button]);
        return a2.innerHTML = this.config.buttonContent || `${L} ${this.api.i18n.t("Select an Image")}`, a2.addEventListener("click", () => {
          this.onSelectFile();
        }), a2;
      }
      /**
       * Shows uploading preloader
       *
       * @param {string} src - preview source
       * @returns {void}
       */
      showPreloader(a2) {
        this.nodes.imagePreloader.style.backgroundImage = `url(${a2})`, this.toggleStatus(j.status.UPLOADING);
      }
      /**
       * Hide uploading preloader
       *
       * @returns {void}
       */
      hidePreloader() {
        this.nodes.imagePreloader.style.backgroundImage = "", this.toggleStatus(j.status.EMPTY);
      }
      /**
       * Shows an image
       *
       * @param {string} url - image source
       * @returns {void}
       */
      fillImage(a2) {
        const i2 = /\.mp4$/.test(a2) ? "VIDEO" : "IMG", c2 = {
          src: a2
        };
        let r2 = "load";
        i2 === "VIDEO" && (c2.autoplay = true, c2.loop = true, c2.muted = true, c2.playsinline = true, r2 = "loadeddata"), this.nodes.imageEl = M(i2, this.CSS.imageEl, c2), this.nodes.imageEl.addEventListener(r2, () => {
          this.toggleStatus(j.status.FILLED), this.nodes.imagePreloader && (this.nodes.imagePreloader.style.backgroundImage = "");
        }), this.nodes.imageContainer.appendChild(this.nodes.imageEl);
      }
      /**
       * Shows caption input
       *
       * @param {string} text - caption text
       * @returns {void}
       */
      fillCaption(a2) {
        this.nodes.caption && (this.nodes.caption.innerHTML = a2);
      }
      /**
       * Changes UI status
       *
       * @param {string} status - see {@link Ui.status} constants
       * @returns {void}
       */
      toggleStatus(a2) {
        for (const i2 in j.status)
          Object.prototype.hasOwnProperty.call(j.status, i2) && this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${j.status[i2]}`, a2 === j.status[i2]);
      }
      /**
       * Apply visual representation of activated tune
       *
       * @param {string} tuneName - one of available tunes {@link Tunes.tunes}
       * @param {boolean} status - true for enable, false for disable
       * @returns {void}
       */
      applyTune(a2, i2) {
        this.nodes.wrapper.classList.toggle(`${this.CSS.wrapper}--${a2}`, i2);
      }
    }
    function x(E2) {
      return E2 && E2.__esModule && Object.prototype.hasOwnProperty.call(E2, "default") ? E2.default : E2;
    }
    var I = { exports: {} };
    (function(E2, a2) {
      (function(i2, c2) {
        E2.exports = c2();
      })(window, function() {
        return function(i2) {
          var c2 = {};
          function r2(n2) {
            if (c2[n2])
              return c2[n2].exports;
            var o2 = c2[n2] = { i: n2, l: false, exports: {} };
            return i2[n2].call(o2.exports, o2, o2.exports, r2), o2.l = true, o2.exports;
          }
          return r2.m = i2, r2.c = c2, r2.d = function(n2, o2, d2) {
            r2.o(n2, o2) || Object.defineProperty(n2, o2, { enumerable: true, get: d2 });
          }, r2.r = function(n2) {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
          }, r2.t = function(n2, o2) {
            if (1 & o2 && (n2 = r2(n2)), 8 & o2 || 4 & o2 && typeof n2 == "object" && n2 && n2.__esModule)
              return n2;
            var d2 = /* @__PURE__ */ Object.create(null);
            if (r2.r(d2), Object.defineProperty(d2, "default", { enumerable: true, value: n2 }), 2 & o2 && typeof n2 != "string")
              for (var b2 in n2)
                r2.d(d2, b2, (function(u2) {
                  return n2[u2];
                }).bind(null, b2));
            return d2;
          }, r2.n = function(n2) {
            var o2 = n2 && n2.__esModule ? function() {
              return n2.default;
            } : function() {
              return n2;
            };
            return r2.d(o2, "a", o2), o2;
          }, r2.o = function(n2, o2) {
            return Object.prototype.hasOwnProperty.call(n2, o2);
          }, r2.p = "", r2(r2.s = 3);
        }([function(i2, c2) {
          var r2;
          r2 = function() {
            return this;
          }();
          try {
            r2 = r2 || new Function("return this")();
          } catch {
            typeof window == "object" && (r2 = window);
          }
          i2.exports = r2;
        }, function(i2, c2, r2) {
          (function(n2) {
            var o2 = r2(2), d2 = setTimeout;
            function b2() {
            }
            function u2(e2) {
              if (!(this instanceof u2))
                throw new TypeError("Promises must be constructed via new");
              if (typeof e2 != "function")
                throw new TypeError("not a function");
              this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], t2(e2, this);
            }
            function f2(e2, l2) {
              for (; e2._state === 3; )
                e2 = e2._value;
              e2._state !== 0 ? (e2._handled = true, u2._immediateFn(function() {
                var s2 = e2._state === 1 ? l2.onFulfilled : l2.onRejected;
                if (s2 !== null) {
                  var g2;
                  try {
                    g2 = s2(e2._value);
                  } catch (m2) {
                    return void y2(l2.promise, m2);
                  }
                  p2(l2.promise, g2);
                } else
                  (e2._state === 1 ? p2 : y2)(l2.promise, e2._value);
              })) : e2._deferreds.push(l2);
            }
            function p2(e2, l2) {
              try {
                if (l2 === e2)
                  throw new TypeError("A promise cannot be resolved with itself.");
                if (l2 && (typeof l2 == "object" || typeof l2 == "function")) {
                  var s2 = l2.then;
                  if (l2 instanceof u2)
                    return e2._state = 3, e2._value = l2, void w2(e2);
                  if (typeof s2 == "function")
                    return void t2((g2 = s2, m2 = l2, function() {
                      g2.apply(m2, arguments);
                    }), e2);
                }
                e2._state = 1, e2._value = l2, w2(e2);
              } catch (h2) {
                y2(e2, h2);
              }
              var g2, m2;
            }
            function y2(e2, l2) {
              e2._state = 2, e2._value = l2, w2(e2);
            }
            function w2(e2) {
              e2._state === 2 && e2._deferreds.length === 0 && u2._immediateFn(function() {
                e2._handled || u2._unhandledRejectionFn(e2._value);
              });
              for (var l2 = 0, s2 = e2._deferreds.length; l2 < s2; l2++)
                f2(e2, e2._deferreds[l2]);
              e2._deferreds = null;
            }
            function v2(e2, l2, s2) {
              this.onFulfilled = typeof e2 == "function" ? e2 : null, this.onRejected = typeof l2 == "function" ? l2 : null, this.promise = s2;
            }
            function t2(e2, l2) {
              var s2 = false;
              try {
                e2(function(g2) {
                  s2 || (s2 = true, p2(l2, g2));
                }, function(g2) {
                  s2 || (s2 = true, y2(l2, g2));
                });
              } catch (g2) {
                if (s2)
                  return;
                s2 = true, y2(l2, g2);
              }
            }
            u2.prototype.catch = function(e2) {
              return this.then(null, e2);
            }, u2.prototype.then = function(e2, l2) {
              var s2 = new this.constructor(b2);
              return f2(this, new v2(e2, l2, s2)), s2;
            }, u2.prototype.finally = o2.a, u2.all = function(e2) {
              return new u2(function(l2, s2) {
                if (!e2 || e2.length === void 0)
                  throw new TypeError("Promise.all accepts an array");
                var g2 = Array.prototype.slice.call(e2);
                if (g2.length === 0)
                  return l2([]);
                var m2 = g2.length;
                function h2(T2, C2) {
                  try {
                    if (C2 && (typeof C2 == "object" || typeof C2 == "function")) {
                      var S2 = C2.then;
                      if (typeof S2 == "function")
                        return void S2.call(C2, function(O2) {
                          h2(T2, O2);
                        }, s2);
                    }
                    g2[T2] = C2, --m2 == 0 && l2(g2);
                  } catch (O2) {
                    s2(O2);
                  }
                }
                for (var k2 = 0; k2 < g2.length; k2++)
                  h2(k2, g2[k2]);
              });
            }, u2.resolve = function(e2) {
              return e2 && typeof e2 == "object" && e2.constructor === u2 ? e2 : new u2(function(l2) {
                l2(e2);
              });
            }, u2.reject = function(e2) {
              return new u2(function(l2, s2) {
                s2(e2);
              });
            }, u2.race = function(e2) {
              return new u2(function(l2, s2) {
                for (var g2 = 0, m2 = e2.length; g2 < m2; g2++)
                  e2[g2].then(l2, s2);
              });
            }, u2._immediateFn = typeof n2 == "function" && function(e2) {
              n2(e2);
            } || function(e2) {
              d2(e2, 0);
            }, u2._unhandledRejectionFn = function(e2) {
              typeof console < "u" && console && console.warn("Possible Unhandled Promise Rejection:", e2);
            }, c2.a = u2;
          }).call(this, r2(5).setImmediate);
        }, function(i2, c2, r2) {
          c2.a = function(n2) {
            var o2 = this.constructor;
            return this.then(function(d2) {
              return o2.resolve(n2()).then(function() {
                return d2;
              });
            }, function(d2) {
              return o2.resolve(n2()).then(function() {
                return o2.reject(d2);
              });
            });
          };
        }, function(i2, c2, r2) {
          function n2(t2) {
            return (n2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e2) {
              return typeof e2;
            } : function(e2) {
              return e2 && typeof Symbol == "function" && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
            })(t2);
          }
          r2(4);
          var o2, d2, b2, u2, f2, p2, y2, w2 = r2(8), v2 = (d2 = function(t2) {
            return new Promise(function(e2, l2) {
              t2 = u2(t2), (t2 = f2(t2)).beforeSend && t2.beforeSend();
              var s2 = window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject("Microsoft.XMLHTTP");
              s2.open(t2.method, t2.url), s2.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(t2.headers).forEach(function(m2) {
                var h2 = t2.headers[m2];
                s2.setRequestHeader(m2, h2);
              });
              var g2 = t2.ratio;
              s2.upload.addEventListener("progress", function(m2) {
                var h2 = Math.round(m2.loaded / m2.total * 100), k2 = Math.ceil(h2 * g2 / 100);
                t2.progress(Math.min(k2, 100));
              }, false), s2.addEventListener("progress", function(m2) {
                var h2 = Math.round(m2.loaded / m2.total * 100), k2 = Math.ceil(h2 * (100 - g2) / 100) + g2;
                t2.progress(Math.min(k2, 100));
              }, false), s2.onreadystatechange = function() {
                if (s2.readyState === 4) {
                  var m2 = s2.response;
                  try {
                    m2 = JSON.parse(m2);
                  } catch {
                  }
                  var h2 = w2.parseHeaders(s2.getAllResponseHeaders()), k2 = { body: m2, code: s2.status, headers: h2 };
                  y2(s2.status) ? e2(k2) : l2(k2);
                }
              }, s2.send(t2.data);
            });
          }, b2 = function(t2) {
            return t2.method = "POST", d2(t2);
          }, u2 = function() {
            var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            if (t2.url && typeof t2.url != "string")
              throw new Error("Url must be a string");
            if (t2.url = t2.url || "", t2.method && typeof t2.method != "string")
              throw new Error("`method` must be a string or null");
            if (t2.method = t2.method ? t2.method.toUpperCase() : "GET", t2.headers && n2(t2.headers) !== "object")
              throw new Error("`headers` must be an object or null");
            if (t2.headers = t2.headers || {}, t2.type && (typeof t2.type != "string" || !Object.values(o2).includes(t2.type)))
              throw new Error("`type` must be taken from module's contentType library");
            if (t2.progress && typeof t2.progress != "function")
              throw new Error("`progress` must be a function or null");
            if (t2.progress = t2.progress || function(e2) {
            }, t2.beforeSend = t2.beforeSend || function(e2) {
            }, t2.ratio && typeof t2.ratio != "number")
              throw new Error("`ratio` must be a number");
            if (t2.ratio < 0 || t2.ratio > 100)
              throw new Error("`ratio` must be in a 0-100 interval");
            if (t2.ratio = t2.ratio || 90, t2.accept && typeof t2.accept != "string")
              throw new Error("`accept` must be a string with a list of allowed mime-types");
            if (t2.accept = t2.accept || "*/*", t2.multiple && typeof t2.multiple != "boolean")
              throw new Error("`multiple` must be a true or false");
            if (t2.multiple = t2.multiple || false, t2.fieldName && typeof t2.fieldName != "string")
              throw new Error("`fieldName` must be a string");
            return t2.fieldName = t2.fieldName || "files", t2;
          }, f2 = function(t2) {
            switch (t2.method) {
              case "GET":
                var e2 = p2(t2.data, o2.URLENCODED);
                delete t2.data, t2.url = /\?/.test(t2.url) ? t2.url + "&" + e2 : t2.url + "?" + e2;
                break;
              case "POST":
              case "PUT":
              case "DELETE":
              case "UPDATE":
                var l2 = function() {
                  return (arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}).type || o2.JSON;
                }(t2);
                (w2.isFormData(t2.data) || w2.isFormElement(t2.data)) && (l2 = o2.FORM), t2.data = p2(t2.data, l2), l2 !== v2.contentType.FORM && (t2.headers["content-type"] = l2);
            }
            return t2;
          }, p2 = function() {
            var t2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            switch (arguments.length > 1 ? arguments[1] : void 0) {
              case o2.URLENCODED:
                return w2.urlEncode(t2);
              case o2.JSON:
                return w2.jsonEncode(t2);
              case o2.FORM:
                return w2.formEncode(t2);
              default:
                return t2;
            }
          }, y2 = function(t2) {
            return t2 >= 200 && t2 < 300;
          }, { contentType: o2 = { URLENCODED: "application/x-www-form-urlencoded; charset=utf-8", FORM: "multipart/form-data", JSON: "application/json; charset=utf-8" }, request: d2, get: function(t2) {
            return t2.method = "GET", d2(t2);
          }, post: b2, transport: function(t2) {
            return t2 = u2(t2), w2.selectFiles(t2).then(function(e2) {
              for (var l2 = new FormData(), s2 = 0; s2 < e2.length; s2++)
                l2.append(t2.fieldName, e2[s2], e2[s2].name);
              w2.isObject(t2.data) && Object.keys(t2.data).forEach(function(m2) {
                var h2 = t2.data[m2];
                l2.append(m2, h2);
              });
              var g2 = t2.beforeSend;
              return t2.beforeSend = function() {
                return g2(e2);
              }, t2.data = l2, b2(t2);
            });
          }, selectFiles: function(t2) {
            return delete (t2 = u2(t2)).beforeSend, w2.selectFiles(t2);
          } });
          i2.exports = v2;
        }, function(i2, c2, r2) {
          r2.r(c2);
          var n2 = r2(1);
          window.Promise = window.Promise || n2.a;
        }, function(i2, c2, r2) {
          (function(n2) {
            var o2 = n2 !== void 0 && n2 || typeof self < "u" && self || window, d2 = Function.prototype.apply;
            function b2(u2, f2) {
              this._id = u2, this._clearFn = f2;
            }
            c2.setTimeout = function() {
              return new b2(d2.call(setTimeout, o2, arguments), clearTimeout);
            }, c2.setInterval = function() {
              return new b2(d2.call(setInterval, o2, arguments), clearInterval);
            }, c2.clearTimeout = c2.clearInterval = function(u2) {
              u2 && u2.close();
            }, b2.prototype.unref = b2.prototype.ref = function() {
            }, b2.prototype.close = function() {
              this._clearFn.call(o2, this._id);
            }, c2.enroll = function(u2, f2) {
              clearTimeout(u2._idleTimeoutId), u2._idleTimeout = f2;
            }, c2.unenroll = function(u2) {
              clearTimeout(u2._idleTimeoutId), u2._idleTimeout = -1;
            }, c2._unrefActive = c2.active = function(u2) {
              clearTimeout(u2._idleTimeoutId);
              var f2 = u2._idleTimeout;
              f2 >= 0 && (u2._idleTimeoutId = setTimeout(function() {
                u2._onTimeout && u2._onTimeout();
              }, f2));
            }, r2(6), c2.setImmediate = typeof self < "u" && self.setImmediate || n2 !== void 0 && n2.setImmediate || this && this.setImmediate, c2.clearImmediate = typeof self < "u" && self.clearImmediate || n2 !== void 0 && n2.clearImmediate || this && this.clearImmediate;
          }).call(this, r2(0));
        }, function(i2, c2, r2) {
          (function(n2, o2) {
            (function(d2, b2) {
              if (!d2.setImmediate) {
                var u2, f2, p2, y2, w2, v2 = 1, t2 = {}, e2 = false, l2 = d2.document, s2 = Object.getPrototypeOf && Object.getPrototypeOf(d2);
                s2 = s2 && s2.setTimeout ? s2 : d2, {}.toString.call(d2.process) === "[object process]" ? u2 = function(h2) {
                  o2.nextTick(function() {
                    m2(h2);
                  });
                } : function() {
                  if (d2.postMessage && !d2.importScripts) {
                    var h2 = true, k2 = d2.onmessage;
                    return d2.onmessage = function() {
                      h2 = false;
                    }, d2.postMessage("", "*"), d2.onmessage = k2, h2;
                  }
                }() ? (y2 = "setImmediate$" + Math.random() + "$", w2 = function(h2) {
                  h2.source === d2 && typeof h2.data == "string" && h2.data.indexOf(y2) === 0 && m2(+h2.data.slice(y2.length));
                }, d2.addEventListener ? d2.addEventListener("message", w2, false) : d2.attachEvent("onmessage", w2), u2 = function(h2) {
                  d2.postMessage(y2 + h2, "*");
                }) : d2.MessageChannel ? ((p2 = new MessageChannel()).port1.onmessage = function(h2) {
                  m2(h2.data);
                }, u2 = function(h2) {
                  p2.port2.postMessage(h2);
                }) : l2 && "onreadystatechange" in l2.createElement("script") ? (f2 = l2.documentElement, u2 = function(h2) {
                  var k2 = l2.createElement("script");
                  k2.onreadystatechange = function() {
                    m2(h2), k2.onreadystatechange = null, f2.removeChild(k2), k2 = null;
                  }, f2.appendChild(k2);
                }) : u2 = function(h2) {
                  setTimeout(m2, 0, h2);
                }, s2.setImmediate = function(h2) {
                  typeof h2 != "function" && (h2 = new Function("" + h2));
                  for (var k2 = new Array(arguments.length - 1), T2 = 0; T2 < k2.length; T2++)
                    k2[T2] = arguments[T2 + 1];
                  var C2 = { callback: h2, args: k2 };
                  return t2[v2] = C2, u2(v2), v2++;
                }, s2.clearImmediate = g2;
              }
              function g2(h2) {
                delete t2[h2];
              }
              function m2(h2) {
                if (e2)
                  setTimeout(m2, 0, h2);
                else {
                  var k2 = t2[h2];
                  if (k2) {
                    e2 = true;
                    try {
                      (function(T2) {
                        var C2 = T2.callback, S2 = T2.args;
                        switch (S2.length) {
                          case 0:
                            C2();
                            break;
                          case 1:
                            C2(S2[0]);
                            break;
                          case 2:
                            C2(S2[0], S2[1]);
                            break;
                          case 3:
                            C2(S2[0], S2[1], S2[2]);
                            break;
                          default:
                            C2.apply(b2, S2);
                        }
                      })(k2);
                    } finally {
                      g2(h2), e2 = false;
                    }
                  }
                }
              }
            })(typeof self > "u" ? n2 === void 0 ? this : n2 : self);
          }).call(this, r2(0), r2(7));
        }, function(i2, c2) {
          var r2, n2, o2 = i2.exports = {};
          function d2() {
            throw new Error("setTimeout has not been defined");
          }
          function b2() {
            throw new Error("clearTimeout has not been defined");
          }
          function u2(s2) {
            if (r2 === setTimeout)
              return setTimeout(s2, 0);
            if ((r2 === d2 || !r2) && setTimeout)
              return r2 = setTimeout, setTimeout(s2, 0);
            try {
              return r2(s2, 0);
            } catch {
              try {
                return r2.call(null, s2, 0);
              } catch {
                return r2.call(this, s2, 0);
              }
            }
          }
          (function() {
            try {
              r2 = typeof setTimeout == "function" ? setTimeout : d2;
            } catch {
              r2 = d2;
            }
            try {
              n2 = typeof clearTimeout == "function" ? clearTimeout : b2;
            } catch {
              n2 = b2;
            }
          })();
          var f2, p2 = [], y2 = false, w2 = -1;
          function v2() {
            y2 && f2 && (y2 = false, f2.length ? p2 = f2.concat(p2) : w2 = -1, p2.length && t2());
          }
          function t2() {
            if (!y2) {
              var s2 = u2(v2);
              y2 = true;
              for (var g2 = p2.length; g2; ) {
                for (f2 = p2, p2 = []; ++w2 < g2; )
                  f2 && f2[w2].run();
                w2 = -1, g2 = p2.length;
              }
              f2 = null, y2 = false, function(m2) {
                if (n2 === clearTimeout)
                  return clearTimeout(m2);
                if ((n2 === b2 || !n2) && clearTimeout)
                  return n2 = clearTimeout, clearTimeout(m2);
                try {
                  n2(m2);
                } catch {
                  try {
                    return n2.call(null, m2);
                  } catch {
                    return n2.call(this, m2);
                  }
                }
              }(s2);
            }
          }
          function e2(s2, g2) {
            this.fun = s2, this.array = g2;
          }
          function l2() {
          }
          o2.nextTick = function(s2) {
            var g2 = new Array(arguments.length - 1);
            if (arguments.length > 1)
              for (var m2 = 1; m2 < arguments.length; m2++)
                g2[m2 - 1] = arguments[m2];
            p2.push(new e2(s2, g2)), p2.length !== 1 || y2 || u2(t2);
          }, e2.prototype.run = function() {
            this.fun.apply(null, this.array);
          }, o2.title = "browser", o2.browser = true, o2.env = {}, o2.argv = [], o2.version = "", o2.versions = {}, o2.on = l2, o2.addListener = l2, o2.once = l2, o2.off = l2, o2.removeListener = l2, o2.removeAllListeners = l2, o2.emit = l2, o2.prependListener = l2, o2.prependOnceListener = l2, o2.listeners = function(s2) {
            return [];
          }, o2.binding = function(s2) {
            throw new Error("process.binding is not supported");
          }, o2.cwd = function() {
            return "/";
          }, o2.chdir = function(s2) {
            throw new Error("process.chdir is not supported");
          }, o2.umask = function() {
            return 0;
          };
        }, function(i2, c2, r2) {
          function n2(d2, b2) {
            for (var u2 = 0; u2 < b2.length; u2++) {
              var f2 = b2[u2];
              f2.enumerable = f2.enumerable || false, f2.configurable = true, "value" in f2 && (f2.writable = true), Object.defineProperty(d2, f2.key, f2);
            }
          }
          var o2 = r2(9);
          i2.exports = function() {
            function d2() {
              (function(p2, y2) {
                if (!(p2 instanceof y2))
                  throw new TypeError("Cannot call a class as a function");
              })(this, d2);
            }
            var b2, u2, f2;
            return b2 = d2, f2 = [{ key: "urlEncode", value: function(p2) {
              return o2(p2);
            } }, { key: "jsonEncode", value: function(p2) {
              return JSON.stringify(p2);
            } }, { key: "formEncode", value: function(p2) {
              if (this.isFormData(p2))
                return p2;
              if (this.isFormElement(p2))
                return new FormData(p2);
              if (this.isObject(p2)) {
                var y2 = new FormData();
                return Object.keys(p2).forEach(function(w2) {
                  var v2 = p2[w2];
                  y2.append(w2, v2);
                }), y2;
              }
              throw new Error("`data` must be an instance of Object, FormData or <FORM> HTMLElement");
            } }, { key: "isObject", value: function(p2) {
              return Object.prototype.toString.call(p2) === "[object Object]";
            } }, { key: "isFormData", value: function(p2) {
              return p2 instanceof FormData;
            } }, { key: "isFormElement", value: function(p2) {
              return p2 instanceof HTMLFormElement;
            } }, { key: "selectFiles", value: function() {
              var p2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              return new Promise(function(y2, w2) {
                var v2 = document.createElement("INPUT");
                v2.type = "file", p2.multiple && v2.setAttribute("multiple", "multiple"), p2.accept && v2.setAttribute("accept", p2.accept), v2.style.display = "none", document.body.appendChild(v2), v2.addEventListener("change", function(t2) {
                  var e2 = t2.target.files;
                  y2(e2), document.body.removeChild(v2);
                }, false), v2.click();
              });
            } }, { key: "parseHeaders", value: function(p2) {
              var y2 = p2.trim().split(/[\r\n]+/), w2 = {};
              return y2.forEach(function(v2) {
                var t2 = v2.split(": "), e2 = t2.shift(), l2 = t2.join(": ");
                e2 && (w2[e2] = l2);
              }), w2;
            } }], (u2 = null) && n2(b2.prototype, u2), f2 && n2(b2, f2), d2;
          }();
        }, function(i2, c2) {
          var r2 = function(o2) {
            return encodeURIComponent(o2).replace(/[!'()*]/g, escape).replace(/%20/g, "+");
          }, n2 = function(o2, d2, b2, u2) {
            return d2 = d2 || null, b2 = b2 || "&", u2 = u2 || null, o2 ? function(f2) {
              for (var p2 = new Array(), y2 = 0; y2 < f2.length; y2++)
                f2[y2] && p2.push(f2[y2]);
              return p2;
            }(Object.keys(o2).map(function(f2) {
              var p2, y2, w2 = f2;
              if (u2 && (w2 = u2 + "[" + w2 + "]"), typeof o2[f2] == "object" && o2[f2] !== null)
                p2 = n2(o2[f2], null, b2, w2);
              else {
                d2 && (y2 = w2, w2 = !isNaN(parseFloat(y2)) && isFinite(y2) ? d2 + Number(w2) : w2);
                var v2 = o2[f2];
                v2 = (v2 = (v2 = (v2 = v2 === true ? "1" : v2) === false ? "0" : v2) === 0 ? "0" : v2) || "", p2 = r2(w2) + "=" + r2(v2);
              }
              return p2;
            })).join(b2).replace(/[!'()*]/g, "") : "";
          };
          i2.exports = n2;
        }]);
      });
    })(I);
    var U = I.exports;
    const F = /* @__PURE__ */ x(U);
    function _(E2) {
      return E2 && typeof E2.then == "function";
    }
    class B {
      /**
       * @param {object} params - uploader module params
       * @param {ImageConfig} params.config - image tool config
       * @param {Function} params.onUpload - one callback for all uploading (file, url, d-n-d, pasting)
       * @param {Function} params.onError - callback for uploading errors
       */
      constructor({ config: a2, onUpload: i2, onError: c2 }) {
        this.config = a2, this.onUpload = i2, this.onError = c2;
      }
      /**
       * Handle clicks on the upload file button
       * Fires ajax.transport()
       *
       * @param {Function} onPreview - callback fired when preview is ready
       */
      uploadSelectedFile({ onPreview: a2 }) {
        const i2 = function(r2) {
          const n2 = new FileReader();
          n2.readAsDataURL(r2), n2.onload = (o2) => {
            a2(o2.target.result);
          };
        };
        let c2;
        this.config.uploader && typeof this.config.uploader.uploadByFile == "function" ? c2 = F.selectFiles({ accept: this.config.types }).then((r2) => {
          i2(r2[0]);
          const n2 = this.config.uploader.uploadByFile(r2[0]);
          return _(n2) || console.warn("Custom uploader method uploadByFile should return a Promise"), n2;
        }) : c2 = F.transport({
          url: this.config.endpoints.byFile,
          data: this.config.additionalRequestData,
          accept: this.config.types,
          headers: this.config.additionalRequestHeaders,
          beforeSend: (r2) => {
            i2(r2[0]);
          },
          fieldName: this.config.field
        }).then((r2) => r2.body), c2.then((r2) => {
          this.onUpload(r2);
        }).catch((r2) => {
          this.onError(r2);
        });
      }
      /**
       * Handle clicks on the upload file button
       * Fires ajax.post()
       *
       * @param {string} url - image source url
       */
      uploadByUrl(a2) {
        let i2;
        this.config.uploader && typeof this.config.uploader.uploadByUrl == "function" ? (i2 = this.config.uploader.uploadByUrl(a2), _(i2) || console.warn("Custom uploader method uploadByUrl should return a Promise")) : i2 = F.post({
          url: this.config.endpoints.byUrl,
          data: Object.assign({
            url: a2
          }, this.config.additionalRequestData),
          type: F.contentType.JSON,
          headers: this.config.additionalRequestHeaders
        }).then((c2) => c2.body), i2.then((c2) => {
          this.onUpload(c2);
        }).catch((c2) => {
          this.onError(c2);
        });
      }
      /**
       * Handle clicks on the upload file button
       * Fires ajax.post()
       *
       * @param {File} file - file pasted by drag-n-drop
       * @param {Function} onPreview - file pasted by drag-n-drop
       */
      uploadByFile(a2, { onPreview: i2 }) {
        const c2 = new FileReader();
        c2.readAsDataURL(a2), c2.onload = (n2) => {
          i2(n2.target.result);
        };
        let r2;
        if (this.config.uploader && typeof this.config.uploader.uploadByFile == "function")
          r2 = this.config.uploader.uploadByFile(a2), _(r2) || console.warn("Custom uploader method uploadByFile should return a Promise");
        else {
          const n2 = new FormData();
          n2.append(this.config.field, a2), this.config.additionalRequestData && Object.keys(this.config.additionalRequestData).length && Object.entries(this.config.additionalRequestData).forEach(([o2, d2]) => {
            n2.append(o2, d2);
          }), r2 = F.post({
            url: this.config.endpoints.byFile,
            data: n2,
            type: F.contentType.JSON,
            headers: this.config.additionalRequestHeaders
          }).then((o2) => o2.body);
        }
        r2.then((n2) => {
          this.onUpload(n2);
        }).catch((n2) => {
          this.onError(n2);
        });
      }
    }
    /**
     * Image Tool for the Editor.js
     *
     * @author CodeX <team@codex.so>
     * @license MIT
     * @see {@link https://github.com/editor-js/image}
     *
     * To developers.
     * To simplify Tool structure, we split it to 4 parts:
     *  1) index.js  main Tool's interface, public API and methods for working with data
     *  2) uploader.js  module that has methods for sending files via AJAX: from device, by URL or File pasting
     *  3) ui.js  module for UI manipulations: render, showing preloader, etc
     *  4) tunes.js  working with Block Tunes: render buttons, handle clicks
     *
     * For debug purposes there is a testing server
     * that can save uploaded files and return a Response {@link UploadResponseFormat}
     *
     *       $ node dev/server.js
     *
     * It will expose 8008 port, so you can pass http://localhost:8008 with the Tools config:
     *
     * image: {
     *   class: ImageTool,
     *   config: {
     *     endpoints: {
     *       byFile: 'http://localhost:8008/uploadFile',
     *       byUrl: 'http://localhost:8008/fetchUrl',
     *     }
     *   },
     * },
     */
    class P {
      /**
       * Notify core that read-only mode is supported
       *
       * @returns {boolean}
       */
      static get isReadOnlySupported() {
        return true;
      }
      /**
       * Get Tool toolbox settings
       * icon - Tool icon's SVG
       * title - title to show in toolbox
       *
       * @returns {{icon: string, title: string}}
       */
      static get toolbox() {
        return {
          icon: L,
          title: "Image"
        };
      }
      /**
       * Available image tools
       *
       * @returns {Array}
       */
      static get tunes() {
        return [
          {
            name: "withBorder",
            icon: H,
            title: "With border",
            toggle: true
          },
          {
            name: "stretched",
            icon: D,
            title: "Stretch image",
            toggle: true
          },
          {
            name: "withBackground",
            icon: R,
            title: "With background",
            toggle: true
          }
        ];
      }
      /**
       * @param {object} tool - tool properties got from editor.js
       * @param {ImageToolData} tool.data - previously saved data
       * @param {ImageConfig} tool.config - user config for Tool
       * @param {object} tool.api - Editor.js API
       * @param {boolean} tool.readOnly - read-only mode flag
       * @param {BlockAPI|{}} tool.block - current Block API
       */
      constructor({ data: a2, config: i2, api: c2, readOnly: r2, block: n2 }) {
        this.api = c2, this.readOnly = r2, this.block = n2, this.config = {
          endpoints: i2.endpoints || "",
          additionalRequestData: i2.additionalRequestData || {},
          additionalRequestHeaders: i2.additionalRequestHeaders || {},
          field: i2.field || "image",
          types: i2.types || "image/*",
          captionPlaceholder: this.api.i18n.t(i2.captionPlaceholder || "Caption"),
          buttonContent: i2.buttonContent || "",
          uploader: i2.uploader || void 0,
          actions: i2.actions || []
        }, this.uploader = new B({
          config: this.config,
          onUpload: (o2) => this.onUpload(o2),
          onError: (o2) => this.uploadingFailed(o2)
        }), this.ui = new j({
          api: c2,
          config: this.config,
          onSelectFile: () => {
            this.uploader.uploadSelectedFile({
              onPreview: (o2) => {
                this.ui.showPreloader(o2);
              }
            });
          },
          readOnly: r2
        }), this._data = {}, this.data = a2;
      }
      /**
       * Renders Block content
       *
       * @public
       *
       * @returns {HTMLDivElement}
       */
      render() {
        return this.ui.render(this.data);
      }
      /**
       * Validate data: check if Image exists
       *
       * @param {ImageToolData} savedData  data received after saving
       * @returns {boolean} false if saved data is not correct, otherwise true
       * @public
       */
      validate(a2) {
        return a2.file && a2.file.url;
      }
      /**
       * Return Block data
       *
       * @public
       *
       * @returns {ImageToolData}
       */
      save() {
        const a2 = this.ui.nodes.caption;
        return this._data.caption = a2.innerHTML, this.data;
      }
      /**
       * Returns configuration for block tunes: add background, add border, stretch image
       *
       * @public
       *
       * @returns {Array}
       */
      renderSettings() {
        return P.tunes.concat(this.config.actions).map((i2) => ({
          icon: i2.icon,
          label: this.api.i18n.t(i2.title),
          name: i2.name,
          toggle: i2.toggle,
          isActive: this.data[i2.name],
          onActivate: () => {
            if (typeof i2.action == "function") {
              i2.action(i2.name);
              return;
            }
            this.tuneToggled(i2.name);
          }
        }));
      }
      /**
       * Fires after clicks on the Toolbox Image Icon
       * Initiates click on the Select File button
       *
       * @public
       */
      appendCallback() {
        this.ui.nodes.fileButton.click();
      }
      /**
       * Specify paste substitutes
       *
       * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}
       * @returns {{tags: string[], patterns: object<string, RegExp>, files: {extensions: string[], mimeTypes: string[]}}}
       */
      static get pasteConfig() {
        return {
          /**
           * Paste HTML into Editor
           */
          tags: [
            {
              img: { src: true }
            }
          ],
          /**
           * Paste URL of image into the Editor
           */
          patterns: {
            image: /https?:\/\/\S+\.(gif|jpe?g|tiff|png|svg|webp)(\?[a-z0-9=]*)?$/i
          },
          /**
           * Drag n drop file from into the Editor
           */
          files: {
            mimeTypes: ["image/*"]
          }
        };
      }
      /**
       * Specify paste handlers
       *
       * @public
       * @see {@link https://github.com/codex-team/editor.js/blob/master/docs/tools.md#paste-handling}
       * @param {CustomEvent} event - editor.js custom paste event
       *                              {@link https://github.com/codex-team/editor.js/blob/master/types/tools/paste-events.d.ts}
       * @returns {void}
       */
      async onPaste(a2) {
        switch (a2.type) {
          case "tag": {
            const i2 = a2.detail.data;
            if (/^blob:/.test(i2.src)) {
              const r2 = await (await fetch(i2.src)).blob();
              this.uploadFile(r2);
              break;
            }
            this.uploadUrl(i2.src);
            break;
          }
          case "pattern": {
            const i2 = a2.detail.data;
            this.uploadUrl(i2);
            break;
          }
          case "file": {
            const i2 = a2.detail.file;
            this.uploadFile(i2);
            break;
          }
        }
      }
      /**
       * Private methods
       *    ''\\= (  ) =//    
       */
      /**
       * Stores all Tool's data
       *
       * @private
       *
       * @param {ImageToolData} data - data in Image Tool format
       */
      set data(a2) {
        this.image = a2.file, this._data.caption = a2.caption || "", this.ui.fillCaption(this._data.caption), P.tunes.forEach(({ name: i2 }) => {
          const c2 = typeof a2[i2] < "u" ? a2[i2] === true || a2[i2] === "true" : false;
          this.setTune(i2, c2);
        });
      }
      /**
       * Return Tool data
       *
       * @private
       *
       * @returns {ImageToolData}
       */
      get data() {
        return this._data;
      }
      /**
       * Set new image file
       *
       * @private
       *
       * @param {object} file - uploaded file data
       */
      set image(a2) {
        this._data.file = a2 || {}, a2 && a2.url && this.ui.fillImage(a2.url);
      }
      /**
       * File uploading callback
       *
       * @private
       *
       * @param {UploadResponseFormat} response - uploading server response
       * @returns {void}
       */
      onUpload(a2) {
        a2.success && a2.file ? this.image = a2.file : this.uploadingFailed("incorrect response: " + JSON.stringify(a2));
      }
      /**
       * Handle uploader errors
       *
       * @private
       * @param {string} errorText - uploading error text
       * @returns {void}
       */
      uploadingFailed(a2) {
        console.log("Image Tool: uploading failed because of", a2), this.api.notifier.show({
          message: this.api.i18n.t("Couldnt upload image. Please try another."),
          style: "error"
        }), this.ui.hidePreloader();
      }
      /**
       * Callback fired when Block Tune is activated
       *
       * @private
       *
       * @param {string} tuneName - tune that has been clicked
       * @returns {void}
       */
      tuneToggled(a2) {
        this.setTune(a2, !this._data[a2]);
      }
      /**
       * Set one tune
       *
       * @param {string} tuneName - {@link Tunes.tunes}
       * @param {boolean} value - tune state
       * @returns {void}
       */
      setTune(a2, i2) {
        this._data[a2] = i2, this.ui.applyTune(a2, i2), a2 === "stretched" && Promise.resolve().then(() => {
          this.block.stretched = i2;
        }).catch((c2) => {
          console.error(c2);
        });
      }
      /**
       * Show preloader and upload image file
       *
       * @param {File} file - file that is currently uploading (from paste)
       * @returns {void}
       */
      uploadFile(a2) {
        this.uploader.uploadByFile(a2, {
          onPreview: (i2) => {
            this.ui.showPreloader(i2);
          }
        });
      }
      /**
       * Show preloader and upload image by target url
       *
       * @param {string} url - url pasted
       * @returns {void}
       */
      uploadUrl(a2) {
        this.ui.showPreloader(a2), this.uploader.uploadByUrl(a2);
      }
    }
    (function() {
      try {
        if (typeof document < "u") {
          var e2 = document.createElement("style");
          e2.appendChild(document.createTextNode(".inline-code{background:rgba(250,239,240,.78);color:#b44437;padding:3px 4px;border-radius:5px;margin:0 1px;font-family:inherit;font-size:.86em;font-weight:500;letter-spacing:.3px}")), document.head.appendChild(e2);
        }
      } catch (n2) {
        console.error("vite-plugin-css-injected-by-js", n2);
      }
    })();
    const o = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9.5 8L6.11524 11.8683C6.04926 11.9437 6.04926 12.0563 6.11524 12.1317L9.5 16"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M15 8L18.3848 11.8683C18.4507 11.9437 18.4507 12.0563 18.3848 12.1317L15 16"/></svg>';
    class s {
      /**
       * Class name for term-tag
       *
       * @type {string}
       */
      static get CSS() {
        return "inline-code";
      }
      /**
       */
      constructor({ api: t2 }) {
        this.api = t2, this.button = null, this.tag = "CODE", this.iconClasses = {
          base: this.api.styles.inlineToolButton,
          active: this.api.styles.inlineToolButtonActive
        };
      }
      /**
       * Specifies Tool as Inline Toolbar Tool
       *
       * @return {boolean}
       */
      static get isInline() {
        return true;
      }
      /**
       * Create button element for Toolbar
       *
       * @return {HTMLElement}
       */
      render() {
        return this.button = document.createElement("button"), this.button.type = "button", this.button.classList.add(this.iconClasses.base), this.button.innerHTML = this.toolboxIcon, this.button;
      }
      /**
       * Wrap/Unwrap selected fragment
       *
       * @param {Range} range - selected fragment
       */
      surround(t2) {
        if (!t2)
          return;
        let e2 = this.api.selection.findParentTag(this.tag, s.CSS);
        e2 ? this.unwrap(e2) : this.wrap(t2);
      }
      /**
       * Wrap selection with term-tag
       *
       * @param {Range} range - selected fragment
       */
      wrap(t2) {
        let e2 = document.createElement(this.tag);
        e2.classList.add(s.CSS), e2.appendChild(t2.extractContents()), t2.insertNode(e2), this.api.selection.expandToTag(e2);
      }
      /**
       * Unwrap term-tag
       *
       * @param {HTMLElement} termWrapper - term wrapper tag
       */
      unwrap(t2) {
        this.api.selection.expandToTag(t2);
        let e2 = window.getSelection(), n2 = e2.getRangeAt(0), i2 = n2.extractContents();
        t2.parentNode.removeChild(t2), n2.insertNode(i2), e2.removeAllRanges(), e2.addRange(n2);
      }
      /**
       * Check and change Term's state for current selection
       */
      checkState() {
        const t2 = this.api.selection.findParentTag(this.tag, s.CSS);
        this.button.classList.toggle(this.iconClasses.active, !!t2);
      }
      /**
       * Get Tool icon's SVG
       * @return {string}
       */
      get toolboxIcon() {
        return o;
      }
      /**
       * Sanitizer rule
       * @return {{span: {class: string}}}
       */
      static get sanitize() {
        return {
          code: {
            class: s.CSS
          }
        };
      }
    }
    var main = { exports: {} };
    /*! For license information please see main.js.LICENSE.txt */
    (function(module2, exports2) {
      !function(e2, t2) {
        module2.exports = t2();
      }(self, function() {
        return (() => {
          var e2 = { 150: (e3, t3, n3) => {
            n3.d(t3, { Z: () => a2 });
            var r3 = n3(645), i2 = n3.n(r3)()(function(e4) {
              return e4[1];
            });
            i2.push([e3.id, ".block-wrapper {\n    padding: 20px 0;\n}\n\n.block-wrapper  input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #e4e4e4;\n    border-radius: 3px;\n    outline: none;\n    font-size: 14px;\n}\n\n.video-wrapper {\n    position: relative;\n    padding-bottom: 56.25%; /* 16:9 */\n    height: 0;\n}\n\n.video-wrapper iframe {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    border: 0px;\n}\n\ninput.invalid {\n    border: 1px solid #eb5959cc;\n}", ""]);
            const a2 = i2;
          }, 645: (e3) => {
            e3.exports = function(e4) {
              var t3 = [];
              return t3.toString = function() {
                return this.map(function(t4) {
                  var n3 = e4(t4);
                  return t4[2] ? "@media ".concat(t4[2], " {").concat(n3, "}") : n3;
                }).join("");
              }, t3.i = function(e5, n3, r3) {
                "string" == typeof e5 && (e5 = [[null, e5, ""]]);
                var i2 = {};
                if (r3)
                  for (var a2 = 0; a2 < this.length; a2++) {
                    var o2 = this[a2][0];
                    null != o2 && (i2[o2] = true);
                  }
                for (var u2 = 0; u2 < e5.length; u2++) {
                  var s2 = [].concat(e5[u2]);
                  r3 && i2[s2[0]] || (n3 && (s2[2] ? s2[2] = "".concat(n3, " and ").concat(s2[2]) : s2[2] = n3), t3.push(s2));
                }
              }, t3;
            };
          }, 379: (e3, t3, n3) => {
            var r3, i2 = function() {
              var e4 = {};
              return function(t4) {
                if (void 0 === e4[t4]) {
                  var n4 = document.querySelector(t4);
                  if (window.HTMLIFrameElement && n4 instanceof window.HTMLIFrameElement)
                    try {
                      n4 = n4.contentDocument.head;
                    } catch (e5) {
                      n4 = null;
                    }
                  e4[t4] = n4;
                }
                return e4[t4];
              };
            }(), a2 = [];
            function o2(e4) {
              for (var t4 = -1, n4 = 0; n4 < a2.length; n4++)
                if (a2[n4].identifier === e4) {
                  t4 = n4;
                  break;
                }
              return t4;
            }
            function u2(e4, t4) {
              for (var n4 = {}, r4 = [], i3 = 0; i3 < e4.length; i3++) {
                var u3 = e4[i3], s3 = t4.base ? u3[0] + t4.base : u3[0], l3 = n4[s3] || 0, c3 = "".concat(s3, " ").concat(l3);
                n4[s3] = l3 + 1;
                var d3 = o2(c3), p3 = { css: u3[1], media: u3[2], sourceMap: u3[3] };
                -1 !== d3 ? (a2[d3].references++, a2[d3].updater(p3)) : a2.push({ identifier: c3, updater: h2(p3, t4), references: 1 }), r4.push(c3);
              }
              return r4;
            }
            function s2(e4) {
              var t4 = document.createElement("style"), r4 = e4.attributes || {};
              if (void 0 === r4.nonce) {
                var a3 = n3.nc;
                a3 && (r4.nonce = a3);
              }
              if (Object.keys(r4).forEach(function(e5) {
                t4.setAttribute(e5, r4[e5]);
              }), "function" == typeof e4.insert)
                e4.insert(t4);
              else {
                var o3 = i2(e4.insert || "head");
                if (!o3)
                  throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                o3.appendChild(t4);
              }
              return t4;
            }
            var l2, c2 = (l2 = [], function(e4, t4) {
              return l2[e4] = t4, l2.filter(Boolean).join("\n");
            });
            function d2(e4, t4, n4, r4) {
              var i3 = n4 ? "" : r4.media ? "@media ".concat(r4.media, " {").concat(r4.css, "}") : r4.css;
              if (e4.styleSheet)
                e4.styleSheet.cssText = c2(t4, i3);
              else {
                var a3 = document.createTextNode(i3), o3 = e4.childNodes;
                o3[t4] && e4.removeChild(o3[t4]), o3.length ? e4.insertBefore(a3, o3[t4]) : e4.appendChild(a3);
              }
            }
            function p2(e4, t4, n4) {
              var r4 = n4.css, i3 = n4.media, a3 = n4.sourceMap;
              if (i3 ? e4.setAttribute("media", i3) : e4.removeAttribute("media"), a3 && "undefined" != typeof btoa && (r4 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a3)))), " */")), e4.styleSheet)
                e4.styleSheet.cssText = r4;
              else {
                for (; e4.firstChild; )
                  e4.removeChild(e4.firstChild);
                e4.appendChild(document.createTextNode(r4));
              }
            }
            var f2 = null, v2 = 0;
            function h2(e4, t4) {
              var n4, r4, i3;
              if (t4.singleton) {
                var a3 = v2++;
                n4 = f2 || (f2 = s2(t4)), r4 = d2.bind(null, n4, a3, false), i3 = d2.bind(null, n4, a3, true);
              } else
                n4 = s2(t4), r4 = p2.bind(null, n4, t4), i3 = function() {
                  !function(e5) {
                    if (null === e5.parentNode)
                      return false;
                    e5.parentNode.removeChild(e5);
                  }(n4);
                };
              return r4(e4), function(t5) {
                if (t5) {
                  if (t5.css === e4.css && t5.media === e4.media && t5.sourceMap === e4.sourceMap)
                    return;
                  r4(e4 = t5);
                } else
                  i3();
              };
            }
            e3.exports = function(e4, t4) {
              (t4 = t4 || {}).singleton || "boolean" == typeof t4.singleton || (t4.singleton = (void 0 === r3 && (r3 = Boolean(window && document && document.all && !window.atob)), r3));
              var n4 = u2(e4 = e4 || [], t4);
              return function(e5) {
                if (e5 = e5 || [], "[object Array]" === Object.prototype.toString.call(e5)) {
                  for (var r4 = 0; r4 < n4.length; r4++) {
                    var i3 = o2(n4[r4]);
                    a2[i3].references--;
                  }
                  for (var s3 = u2(e5, t4), l3 = 0; l3 < n4.length; l3++) {
                    var c3 = o2(n4[l3]);
                    0 === a2[c3].references && (a2[c3].updater(), a2.splice(c3, 1));
                  }
                  n4 = s3;
                }
              };
            };
          }, 884: (e3) => {
            e3.exports = '<svg xmlns="http://www.w3.org/2000/svg" height="20" width="30" viewBox="-35.20005 -41.33325 305.0671 247.9995"><path d="M229.763 25.817c-2.699-10.162-10.65-18.165-20.748-20.881C190.716 0 117.333 0 117.333 0S43.951 0 25.651 4.936C15.553 7.652 7.6 15.655 4.903 25.817 0 44.236 0 82.667 0 82.667s0 38.429 4.903 56.85C7.6 149.68 15.553 157.681 25.65 160.4c18.3 4.934 91.682 4.934 91.682 4.934s73.383 0 91.682-4.934c10.098-2.718 18.049-10.72 20.748-20.882 4.904-18.421 4.904-56.85 4.904-56.85s0-38.431-4.904-56.85" fill="red"></path><path d="M93.333 117.559l61.333-34.89-61.333-34.894z" fill="#fff"></path></svg>';
          } }, t2 = {};
          function n2(r3) {
            var i2 = t2[r3];
            if (void 0 !== i2)
              return i2.exports;
            var a2 = t2[r3] = { id: r3, exports: {} };
            return e2[r3](a2, a2.exports, n2), a2.exports;
          }
          n2.n = (e3) => {
            var t3 = e3 && e3.__esModule ? () => e3.default : () => e3;
            return n2.d(t3, { a: t3 }), t3;
          }, n2.d = (e3, t3) => {
            for (var r3 in t3)
              n2.o(t3, r3) && !n2.o(e3, r3) && Object.defineProperty(e3, r3, { enumerable: true, get: t3[r3] });
          }, n2.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), n2.r = (e3) => {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
          };
          var r2 = {};
          return (() => {
            n2.r(r2), n2.d(r2, { default: () => s2 });
            var e3 = n2(379), t3 = n2.n(e3), i2 = n2(150);
            t3()(i2.Z, { insert: "head", singleton: false }), i2.Z.locals;
            var a2 = n2(884), o2 = n2.n(a2);
            function u2(e4, t4) {
              for (var n3 = 0; n3 < t4.length; n3++) {
                var r3 = t4[n3];
                r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
              }
            }
            var s2 = function() {
              function e4(t5) {
                var n4 = t5.data, r4 = (t5.config, t5.api, t5.readOnly);
                !function(e5, t6) {
                  if (!(e5 instanceof t6))
                    throw new TypeError("Cannot call a class as a function");
                }(this, e4), this.data = n4, this.readOnly = r4, this.wrapper = null, this.url = null, this.isEdited = false;
              }
              var t4, n3, r3;
              return t4 = e4, r3 = [{ key: "toolbox", get: function() {
                return { title: "YouTube", icon: o2() };
              } }, { key: "isReadOnlySupported", get: function() {
                return true;
              } }], (n3 = [{ key: "render", value: function() {
                var e5 = this;
                this.wrapper = document.createElement("div");
                var t5 = document.createElement("input");
                return t5.value = this.data && this.data.url ? this.data.url : "", this.url = t5.value, t5.placeholder = "Paste YouTube url here...", this.wrapper.classList.add("block-wrapper"), this.wrapper.appendChild(t5), this._createIframe(t5.value), t5.addEventListener("change", function(n4) {
                  e5.isEdited = true, e5.url = t5.value, e5._createIframe(t5.value);
                }), this.wrapper;
              } }, { key: "_createIframe", value: function(e5) {
                var t5 = e5.match(new RegExp("(?<=v=)[a-zA-Z0-9_]+(?=\\&?)"));
                if (null != t5) {
                  this.wrapper.innerHTML = null;
                  var n4 = document.createElement("div");
                  n4.classList.add("video-wrapper");
                  var r4 = document.createElement("iframe");
                  r4.setAttribute("src", "https://www.youtube.com/embed/".concat(t5)), r4.setAttribute("allowfullscreen", true), n4.appendChild(r4), this.wrapper.appendChild(n4);
                } else
                  this.isEdited && this.wrapper.querySelector("input").classList.add("invalid");
              } }, { key: "save", value: function(e5) {
                return e5.querySelector("input"), { url: this.url };
              } }]) && u2(t4.prototype, n3), r3 && u2(t4, r3), e4;
            }();
          })(), r2;
        })();
      });
    })(main);
    var mainExports = main.exports;
    const Youtube = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
    var bundle = { exports: {} };
    (function(module2, exports2) {
      !function(e2, l2) {
        module2.exports = l2();
      }(window, function() {
        return function(e2) {
          var l2 = {};
          function a2(_2) {
            if (l2[_2])
              return l2[_2].exports;
            var t2 = l2[_2] = { i: _2, l: false, exports: {} };
            return e2[_2].call(t2.exports, t2, t2.exports, a2), t2.l = true, t2.exports;
          }
          return a2.m = e2, a2.c = l2, a2.d = function(e3, l3, _2) {
            a2.o(e3, l3) || Object.defineProperty(e3, l3, { enumerable: true, get: _2 });
          }, a2.r = function(e3) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
          }, a2.t = function(e3, l3) {
            if (1 & l3 && (e3 = a2(e3)), 8 & l3)
              return e3;
            if (4 & l3 && "object" == typeof e3 && e3 && e3.__esModule)
              return e3;
            var _2 = /* @__PURE__ */ Object.create(null);
            if (a2.r(_2), Object.defineProperty(_2, "default", { enumerable: true, value: e3 }), 2 & l3 && "string" != typeof e3)
              for (var t2 in e3)
                a2.d(_2, t2, (function(l4) {
                  return e3[l4];
                }).bind(null, t2));
            return _2;
          }, a2.n = function(e3) {
            var l3 = e3 && e3.__esModule ? function() {
              return e3.default;
            } : function() {
              return e3;
            };
            return a2.d(l3, "a", l3), l3;
          }, a2.o = function(e3, l3) {
            return Object.prototype.hasOwnProperty.call(e3, l3);
          }, a2.p = "", a2(a2.s = 2);
        }([function(e2, l2) {
          e2.exports = function(e3) {
            var l3 = [];
            return l3.toString = function() {
              return this.map(function(l4) {
                var a2 = function(e4, l5) {
                  var a3 = e4[1] || "", _2 = e4[3];
                  if (!_2)
                    return a3;
                  if (l5 && "function" == typeof btoa) {
                    var t2 = (o2 = _2, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(o2)))) + " */"), r2 = _2.sources.map(function(e5) {
                      return "/*# sourceURL=" + _2.sourceRoot + e5 + " */";
                    });
                    return [a3].concat(r2).concat([t2]).join("\n");
                  }
                  var o2;
                  return [a3].join("\n");
                }(l4, e3);
                return l4[2] ? "@media " + l4[2] + "{" + a2 + "}" : a2;
              }).join("");
            }, l3.i = function(e4, a2) {
              "string" == typeof e4 && (e4 = [[null, e4, ""]]);
              for (var _2 = {}, t2 = 0; t2 < this.length; t2++) {
                var r2 = this[t2][0];
                "number" == typeof r2 && (_2[r2] = true);
              }
              for (t2 = 0; t2 < e4.length; t2++) {
                var o2 = e4[t2];
                "number" == typeof o2[0] && _2[o2[0]] || (a2 && !o2[2] ? o2[2] = a2 : a2 && (o2[2] = "(" + o2[2] + ") and (" + a2 + ")"), l3.push(o2));
              }
            }, l3;
          };
        }, function(e2, l2, a2) {
          var _2, t2, r2 = {}, o2 = (_2 = function() {
            return window && document && document.all && !window.atob;
          }, function() {
            return void 0 === t2 && (t2 = _2.apply(this, arguments)), t2;
          }), s2 = function(e3, l3) {
            return l3 ? l3.querySelector(e3) : document.querySelector(e3);
          }, c2 = function(e3) {
            var l3 = {};
            return function(e4, a3) {
              if ("function" == typeof e4)
                return e4();
              if (void 0 === l3[e4]) {
                var _3 = s2.call(this, e4, a3);
                if (window.HTMLIFrameElement && _3 instanceof window.HTMLIFrameElement)
                  try {
                    _3 = _3.contentDocument.head;
                  } catch (e5) {
                    _3 = null;
                  }
                l3[e4] = _3;
              }
              return l3[e4];
            };
          }(), d2 = null, h2 = 0, n2 = [], i2 = a2(5);
          function v2(e3, l3) {
            for (var a3 = 0; a3 < e3.length; a3++) {
              var _3 = e3[a3], t3 = r2[_3.id];
              if (t3) {
                t3.refs++;
                for (var o3 = 0; o3 < t3.parts.length; o3++)
                  t3.parts[o3](_3.parts[o3]);
                for (; o3 < _3.parts.length; o3++)
                  t3.parts.push(b2(_3.parts[o3], l3));
              } else {
                var s3 = [];
                for (o3 = 0; o3 < _3.parts.length; o3++)
                  s3.push(b2(_3.parts[o3], l3));
                r2[_3.id] = { id: _3.id, refs: 1, parts: s3 };
              }
            }
          }
          function w2(e3, l3) {
            for (var a3 = [], _3 = {}, t3 = 0; t3 < e3.length; t3++) {
              var r3 = e3[t3], o3 = l3.base ? r3[0] + l3.base : r3[0], s3 = { css: r3[1], media: r3[2], sourceMap: r3[3] };
              _3[o3] ? _3[o3].parts.push(s3) : a3.push(_3[o3] = { id: o3, parts: [s3] });
            }
            return a3;
          }
          function C2(e3, l3) {
            var a3 = c2(e3.insertInto);
            if (!a3)
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
            var _3 = n2[n2.length - 1];
            if ("top" === e3.insertAt)
              _3 ? _3.nextSibling ? a3.insertBefore(l3, _3.nextSibling) : a3.appendChild(l3) : a3.insertBefore(l3, a3.firstChild), n2.push(l3);
            else if ("bottom" === e3.insertAt)
              a3.appendChild(l3);
            else {
              if ("object" != typeof e3.insertAt || !e3.insertAt.before)
                throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
              var t3 = c2(e3.insertAt.before, a3);
              a3.insertBefore(l3, t3);
            }
          }
          function u2(e3) {
            if (null === e3.parentNode)
              return false;
            e3.parentNode.removeChild(e3);
            var l3 = n2.indexOf(e3);
            l3 >= 0 && n2.splice(l3, 1);
          }
          function f2(e3) {
            var l3 = document.createElement("style");
            if (void 0 === e3.attrs.type && (e3.attrs.type = "text/css"), void 0 === e3.attrs.nonce) {
              var _3 = function() {
                return a2.nc;
              }();
              _3 && (e3.attrs.nonce = _3);
            }
            return p2(l3, e3.attrs), C2(e3, l3), l3;
          }
          function p2(e3, l3) {
            Object.keys(l3).forEach(function(a3) {
              e3.setAttribute(a3, l3[a3]);
            });
          }
          function b2(e3, l3) {
            var a3, _3, t3, r3;
            if (l3.transform && e3.css) {
              if (!(r3 = "function" == typeof l3.transform ? l3.transform(e3.css) : l3.transform.default(e3.css)))
                return function() {
                };
              e3.css = r3;
            }
            if (l3.singleton) {
              var o3 = h2++;
              a3 = d2 || (d2 = f2(l3)), _3 = y2.bind(null, a3, o3, false), t3 = y2.bind(null, a3, o3, true);
            } else
              e3.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (a3 = function(e4) {
                var l4 = document.createElement("link");
                return void 0 === e4.attrs.type && (e4.attrs.type = "text/css"), e4.attrs.rel = "stylesheet", p2(l4, e4.attrs), C2(e4, l4), l4;
              }(l3), _3 = M2.bind(null, a3, l3), t3 = function() {
                u2(a3), a3.href && URL.revokeObjectURL(a3.href);
              }) : (a3 = f2(l3), _3 = x2.bind(null, a3), t3 = function() {
                u2(a3);
              });
            return _3(e3), function(l4) {
              if (l4) {
                if (l4.css === e3.css && l4.media === e3.media && l4.sourceMap === e3.sourceMap)
                  return;
                _3(e3 = l4);
              } else
                t3();
            };
          }
          e2.exports = function(e3, l3) {
            if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document)
              throw new Error("The style-loader cannot be used in a non-browser environment");
            (l3 = l3 || {}).attrs = "object" == typeof l3.attrs ? l3.attrs : {}, l3.singleton || "boolean" == typeof l3.singleton || (l3.singleton = o2()), l3.insertInto || (l3.insertInto = "head"), l3.insertAt || (l3.insertAt = "bottom");
            var a3 = w2(e3, l3);
            return v2(a3, l3), function(e4) {
              for (var _3 = [], t3 = 0; t3 < a3.length; t3++) {
                var o3 = a3[t3];
                (s3 = r2[o3.id]).refs--, _3.push(s3);
              }
              e4 && v2(w2(e4, l3), l3);
              for (t3 = 0; t3 < _3.length; t3++) {
                var s3;
                if (0 === (s3 = _3[t3]).refs) {
                  for (var c3 = 0; c3 < s3.parts.length; c3++)
                    s3.parts[c3]();
                  delete r2[s3.id];
                }
              }
            };
          };
          var m2, g2 = (m2 = [], function(e3, l3) {
            return m2[e3] = l3, m2.filter(Boolean).join("\n");
          });
          function y2(e3, l3, a3, _3) {
            var t3 = a3 ? "" : _3.css;
            if (e3.styleSheet)
              e3.styleSheet.cssText = g2(l3, t3);
            else {
              var r3 = document.createTextNode(t3), o3 = e3.childNodes;
              o3[l3] && e3.removeChild(o3[l3]), o3.length ? e3.insertBefore(r3, o3[l3]) : e3.appendChild(r3);
            }
          }
          function x2(e3, l3) {
            var a3 = l3.css, _3 = l3.media;
            if (_3 && e3.setAttribute("media", _3), e3.styleSheet)
              e3.styleSheet.cssText = a3;
            else {
              for (; e3.firstChild; )
                e3.removeChild(e3.firstChild);
              e3.appendChild(document.createTextNode(a3));
            }
          }
          function M2(e3, l3, a3) {
            var _3 = a3.css, t3 = a3.sourceMap, r3 = void 0 === l3.convertToAbsoluteUrls && t3;
            (l3.convertToAbsoluteUrls || r3) && (_3 = i2(_3)), t3 && (_3 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(t3)))) + " */");
            var o3 = new Blob([_3], { type: "text/css" }), s3 = e3.href;
            e3.href = URL.createObjectURL(o3), s3 && URL.revokeObjectURL(s3);
          }
        }, function(e2, l2, a2) {
          const { TableConstructor: _2 } = a2(15), t2 = { Toolbox: a2(8), InsertColBefore: a2(9), InsertColAfter: a2(10), InsertRowBefore: a2(11), InsertRowAfter: a2(12), DeleteRow: a2(13), DeleteCol: a2(14) }, r2 = "tc-table__inp";
          e2.exports = class {
            static get enableLineBreaks() {
              return true;
            }
            static get toolbox() {
              return { icon: t2.Toolbox, title: "Table" };
            }
            constructor({ data: e3, config: l3, api: a3 }) {
              this.api = a3, this.wrapper = void 0, this.config = l3, this.data = e3, this._tableConstructor = new _2(e3, l3, a3), this.actions = [{ actionName: "InsertColBefore", icon: t2.InsertColBefore, label: "Insert column before" }, { actionName: "InsertColAfter", icon: t2.InsertColAfter, label: "Insert column after" }, { actionName: "InsertRowBefore", icon: t2.InsertRowBefore, label: "Insert row before" }, { actionName: "InsertRowAfter", icon: t2.InsertRowAfter, label: "Insert row after" }, { actionName: "DeleteRow", icon: t2.DeleteRow, label: "Delete row" }, { actionName: "DeleteCol", icon: t2.DeleteCol, label: "Delete column" }];
            }
            performAction(e3) {
              switch (e3) {
                case "InsertColBefore":
                  this._tableConstructor.table.insertColumnBefore();
                  break;
                case "InsertColAfter":
                  this._tableConstructor.table.insertColumnAfter();
                  break;
                case "InsertRowBefore":
                  this._tableConstructor.table.insertRowBefore();
                  break;
                case "InsertRowAfter":
                  this._tableConstructor.table.insertRowAfter();
                  break;
                case "DeleteRow":
                  this._tableConstructor.table.deleteRow();
                  break;
                case "DeleteCol":
                  this._tableConstructor.table.deleteColumn();
              }
            }
            renderSettings() {
              const e3 = document.createElement("div");
              return this.actions.forEach(({ actionName: l3, label: a3, icon: _3 }) => {
                const t3 = this.api.i18n.t(a3), r3 = document.createElement("div");
                r3.classList.add("cdx-settings-button"), r3.innerHTML = _3, r3.title = l3, this.api.tooltip.onHover(r3, t3, { placement: "top" }), r3.addEventListener("click", this.performAction.bind(this, l3)), e3.appendChild(r3), this._tableConstructor.table.selectedCell && this._tableConstructor.table.focusCellOnSelectedCell();
              }), e3;
            }
            render() {
              if (this.wrapper = document.createElement("div"), this.data && this.data.content)
                this._createTableConfiguration();
              else {
                this.wrapper.classList.add("table-selector"), this.wrapper.setAttribute("data-hoveredClass", "m,n");
                const e3 = 6;
                this.createCells(e3), "table-selector" === this.wrapper.className && this.wrapper.addEventListener("mouseover", (e4) => {
                  if (e4.target.id.length) {
                    const l3 = e4.target.attributes.row.value, a3 = e4.target.attributes.column.value;
                    this.wrapper.setAttribute("data-hoveredClass", `${l3},${a3}`);
                  }
                }), this.wrapper.addEventListener("click", (e4) => {
                  if (e4.target.id.length) {
                    const l3 = e4.target.attributes.row.value, a3 = e4.target.attributes.column.value;
                    this.wrapper.removeEventListener("mouseover", () => {
                    }), this.config.rows = l3, this.config.cols = a3, this._createTableConfiguration();
                  }
                });
              }
              return this.wrapper;
            }
            createCells(e3) {
              if (0 !== e3)
                for (let l4 = 0; l4 < e3; l4++) {
                  let a3 = document.createElement("div");
                  a3.setAttribute("class", "table-row");
                  for (let _3 = 0; _3 < e3; _3++) {
                    let e4 = document.createElement("div"), t3 = document.createElement("div");
                    e4.setAttribute("class", "table-cell-container"), t3.setAttribute("class", "table-cell"), e4.setAttribute("id", `row_${l4 + 1}_cell_${_3 + 1}`), e4.setAttribute("column", _3 + 1), e4.setAttribute("row", l4 + 1), t3.setAttribute("id", "cell_" + (_3 + 1)), t3.setAttribute("column", _3 + 1), t3.setAttribute("row", l4 + 1), e4.appendChild(t3), a3.appendChild(e4);
                  }
                  this.wrapper.appendChild(a3);
                }
              const l3 = document.createElement("input");
              l3.classList.add("hidden-element"), l3.setAttribute("tabindex", 0), this.wrapper.appendChild(l3);
            }
            _createTableConfiguration() {
              this.wrapper.innerHTML = "", this._tableConstructor = new _2(this.data, this.config, this.api), this.wrapper.appendChild(this._tableConstructor.htmlElement);
            }
            save(e3) {
              const l3 = e3.querySelector("table"), a3 = [], _3 = l3 ? l3.rows : 0;
              if (_3.length) {
                for (let e4 = 0; e4 < _3.length; e4++) {
                  const l4 = _3[e4], t3 = Array.from(l4.cells).map((e5) => e5.querySelector("." + r2));
                  t3.every(this._isEmpty) || a3.push(t3.map((e5) => e5.innerHTML));
                }
                return { content: a3 };
              }
            }
            _isEmpty(e3) {
              return !e3.textContent.trim();
            }
            static get pasteConfig() {
              return { tags: ["TABLE", "TR", "TD", "TBODY", "TH"] };
            }
            async onPaste(e3) {
              const l3 = e3.detail.data;
              this.data = this.pasteHandler(l3), this._createTableConfiguration();
            }
            pasteHandler(e3) {
              const { tagName: l3 } = e3, a3 = { content: [], config: { rows: 0, cols: 0 } };
              if ("TABLE" === l3) {
                let l4 = Array.from(e3.childNodes);
                l4 = l4.find((e4) => "TBODY" === e4.nodeName);
                let _3 = Array.from(l4.childNodes);
                _3 = [_3].map((e4) => e4.filter((e5) => "TR" === e5.nodeName)), a3.config.rows = _3[0].length, a3.content = _3[0].map((e4) => {
                  let l5 = e4.childNodes;
                  return a3.config.cols = l5.length, l5 = [...l5].map((e5) => e5.innerHTML), l5;
                });
              }
              return a3;
            }
          };
        }, function(e2, l2, a2) {
          var _2 = a2(4);
          "string" == typeof _2 && (_2 = [[e2.i, _2, ""]]);
          var t2 = { hmr: true, transform: void 0, insertInto: void 0 };
          a2(1)(_2, t2);
          _2.locals && (e2.exports = _2.locals);
        }, function(e2, l2, a2) {
          (e2.exports = a2(0)(false)).push([e2.i, ".tc-editor{padding:10px;position:relative;box-sizing:content-box;width:100%;left:-10px}", ""]);
        }, function(e2, l2) {
          e2.exports = function(e3) {
            var l3 = "undefined" != typeof window && window.location;
            if (!l3)
              throw new Error("fixUrls requires window.location");
            if (!e3 || "string" != typeof e3)
              return e3;
            var a2 = l3.protocol + "//" + l3.host, _2 = a2 + l3.pathname.replace(/\/[^\/]*$/, "/");
            return e3.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(e4, l4) {
              var t2, r2 = l4.trim().replace(/^"(.*)"$/, function(e5, l5) {
                return l5;
              }).replace(/^'(.*)'$/, function(e5, l5) {
                return l5;
              });
              return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(r2) ? e4 : (t2 = 0 === r2.indexOf("//") ? r2 : 0 === r2.indexOf("/") ? a2 + r2 : _2 + r2.replace(/^\.\//, ""), "url(" + JSON.stringify(t2) + ")");
            });
          };
        }, function(e2, l2, a2) {
          var _2 = a2(7);
          "string" == typeof _2 && (_2 = [[e2.i, _2, ""]]);
          var t2 = { hmr: true, transform: void 0, insertInto: void 0 };
          a2(1)(_2, t2);
          _2.locals && (e2.exports = _2.locals);
        }, function(e2, l2, a2) {
          (e2.exports = a2(0)(false)).push([e2.i, '.tc-table{width:100%;height:100%;border-collapse:collapse;table-layout:fixed;}.tc-table__wrap{border:1px solid #dbdbe2;border-radius:3px;position:relative;height:100%;width:100%;box-sizing:border-box}.tc-table__cell{border:1px solid #dbdbe2;padding:0;vertical-align:top}.tc-table__area{padding:10px;height:100%}.tc-table__inp{outline:none;flex-grow:100;min-height:1.5em;height:100%;overflow:hidden}.tc-table__highlight:focus-within{background-color:rgba(173,164,176,.1)}.tc-table tbody tr:first-child td{border-top:none}.tc-table tbody tr:last-child td{border-bottom:none}.tc-table tbody tr td:last-child{border-right:none}.tc-table tbody tr td:first-child{border-left:none}.table-selector{display:flex;flex-direction:column;}.table-selector .hidden-element{display:none}.table-row{display:flex;flex-direction:row}.table-cell-container{width:30px;height:30px}.table-cell{width:25px;height:25px;background:#f6f6f6;border:1px solid #e4e4e4;cursor:pointer}[data-hoveredClass="1,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="1,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="1,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="1,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="1,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="1,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="1,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="1,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="1,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="1,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="2,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="2,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="2,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="2,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="2,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="2,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="2,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="2,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="2,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="2,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="2,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="2,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="2,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="2,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="2,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="2,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="2,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="2,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="2,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="2,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="3,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,1"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,2"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,2"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="3,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="3,3"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,3"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,3"] #row_3_cell_3 #cell_3,[data-hoveredClass="3,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="3,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="3,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="3,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="3,4"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,4"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,4"] #row_3_cell_3 #cell_3,[data-hoveredClass="3,4"] #row_3_cell_4 #cell_4,[data-hoveredClass="3,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="3,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="3,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="3,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="3,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="3,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="3,5"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,5"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,5"] #row_3_cell_3 #cell_3,[data-hoveredClass="3,5"] #row_3_cell_4 #cell_4,[data-hoveredClass="3,5"] #row_3_cell_5 #cell_5,[data-hoveredClass="3,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="3,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="3,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="3,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="3,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="3,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="3,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="3,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="3,6"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,6"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,6"] #row_3_cell_3 #cell_3,[data-hoveredClass="3,6"] #row_3_cell_4 #cell_4,[data-hoveredClass="3,6"] #row_3_cell_5 #cell_5,[data-hoveredClass="3,6"] #row_3_cell_6 #cell_6,[data-hoveredClass="4,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,1"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,1"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,2"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,2"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="4,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="4,3"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,3"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_3_cell_3 #cell_3,[data-hoveredClass="4,3"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,3"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_4_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="4,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="4,4"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,4"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,4"] #row_3_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_3_cell_4 #cell_4,[data-hoveredClass="4,4"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,4"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,4"] #row_4_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_4_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="4,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="4,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="4,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="4,5"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,5"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,5"] #row_3_cell_3 #cell_3,[data-hoveredClass="4,5"] #row_3_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_3_cell_5 #cell_5,[data-hoveredClass="4,5"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,5"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,5"] #row_4_cell_3 #cell_3,[data-hoveredClass="4,5"] #row_4_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_4_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="4,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="4,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="4,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="4,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="4,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="4,6"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,6"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,6"] #row_3_cell_3 #cell_3,[data-hoveredClass="4,6"] #row_3_cell_4 #cell_4,[data-hoveredClass="4,6"] #row_3_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_3_cell_6 #cell_6,[data-hoveredClass="4,6"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,6"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,6"] #row_4_cell_3 #cell_3,[data-hoveredClass="4,6"] #row_4_cell_4 #cell_4,[data-hoveredClass="4,6"] #row_4_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_4_cell_6 #cell_6,[data-hoveredClass="5,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,1"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,1"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,1"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,2"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,2"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,2"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="5,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="5,3"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_3_cell_3 #cell_3,[data-hoveredClass="5,3"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_4_cell_3 #cell_3,[data-hoveredClass="5,3"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_5_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="5,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="5,4"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_3_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_3_cell_4 #cell_4,[data-hoveredClass="5,4"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_4_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_4_cell_4 #cell_4,[data-hoveredClass="5,4"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_5_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_5_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="5,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="5,5"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_3_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_3_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_3_cell_5 #cell_5,[data-hoveredClass="5,5"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_4_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_4_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_4_cell_5 #cell_5,[data-hoveredClass="5,5"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_5_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_5_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_5_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="5,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="5,6"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_3_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_3_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_3_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_3_cell_6 #cell_6,[data-hoveredClass="5,6"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_4_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_4_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_4_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_4_cell_6 #cell_6,[data-hoveredClass="5,6"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_5_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_5_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_5_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_5_cell_6 #cell_6,[data-hoveredClass="6,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_3_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_4_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_5_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_6_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_3_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_3_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_4_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_4_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_5_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_5_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_6_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_6_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_3_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_3_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_3_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_4_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_4_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_4_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_5_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_5_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_5_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_6_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_6_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_6_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_3_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_3_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_3_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_3_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_4_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_4_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_4_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_4_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_5_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_5_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_5_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_5_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_6_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_6_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_6_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_6_cell_6 #cell_6{background:#d5e4f9;border:1px solid #c0cffd}', ""]);
        }, function(e2, l2) {
          e2.exports = '<svg width="18" height="14"><path d="M2.833 8v1.95a1.7 1.7 0 0 0 1.7 1.7h3.45V8h-5.15zm0-2h5.15V2.35h-3.45a1.7 1.7 0 0 0-1.7 1.7V6zm12.3 2h-5.15v3.65h3.45a1.7 1.7 0 0 0 1.7-1.7V8zm0-2V4.05a1.7 1.7 0 0 0-1.7-1.7h-3.45V6h5.15zM4.533.1h8.9a3.95 3.95 0 0 1 3.95 3.95v5.9a3.95 3.95 0 0 1-3.95 3.95h-8.9a3.95 3.95 0 0 1-3.95-3.95v-5.9A3.95 3.95 0 0 1 4.533.1z"></path></svg>';
        }, function(e2, l2) {
          e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="-21 0 512 512" width="18" height="18"><path d="M181.332031 106.667969c-3.925781 0-7.828125-1.429688-10.921875-4.3125l-80-74.664063c-4.820312-4.480468-6.378906-11.457031-3.96875-17.558594C88.851562 4.011719 94.761719 0 101.332031 0h160c6.570313 0 12.480469 4.011719 14.871094 10.132812 2.410156 6.125.851563 13.078126-3.96875 17.558594l-80 74.664063c-3.070313 2.882812-6.976563 4.3125-10.902344 4.3125zM141.910156 32l39.421875 36.777344L220.757812 32zm0 0M90.667969 512H37.332031C16.746094 512 0 495.253906 0 474.667969V144c0-20.585938 16.746094-37.332031 37.332031-37.332031h53.335938C111.253906 106.667969 128 123.414062 128 144v330.667969C128 495.253906 111.253906 512 90.667969 512zM37.332031 138.667969C34.390625 138.667969 32 141.054688 32 144v330.667969C32 477.609375 34.390625 480 37.332031 480h53.335938C93.609375 480 96 477.609375 96 474.667969V144c0-2.945312-2.390625-5.332031-5.332031-5.332031zm0 0M432 512H272c-20.585938 0-37.332031-16.746094-37.332031-37.332031V144c0-20.585938 16.746093-37.332031 37.332031-37.332031h160c20.585938 0 37.332031 16.746093 37.332031 37.332031v330.667969C469.332031 495.253906 452.585938 512 432 512zM272 138.667969c-2.945312 0-5.332031 2.386719-5.332031 5.332031v330.667969C266.667969 477.609375 269.054688 480 272 480h160c2.945312 0 5.332031-2.390625 5.332031-5.332031V144c0-2.945312-2.386719-5.332031-5.332031-5.332031zm0 0"></path><path d="M112 325.332031H16c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16h96c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0M453.332031 325.332031H250.667969c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16h202.664062c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0"></path><path d="M352 512c-8.832031 0-16-7.167969-16-16V122.667969c0-8.832031 7.167969-16 16-16s16 7.167969 16 16V496c0 8.832031-7.167969 16-16 16zm0 0"></path></svg>';
        }, function(e2, l2) {
          e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="-21 0 512 512" width="18" height="18"><path d="M288 106.667969c-3.925781 0-7.851562-1.429688-10.921875-4.3125l-80-74.664063c-4.800781-4.480468-6.378906-11.457031-3.96875-17.558594C195.519531 4.03125 201.429688 0 208 0h160c6.570312 0 12.480469 4.011719 14.890625 10.132812 2.410156 6.125.832031 13.078126-3.96875 17.558594l-80 74.664063c-3.070313 2.882812-6.996094 4.3125-10.921875 4.3125zM248.597656 32L288 68.777344 327.402344 32zm0 0M432 512h-53.332031c-20.589844 0-37.335938-16.746094-37.335938-37.332031V144c0-20.585938 16.746094-37.332031 37.335938-37.332031H432c20.585938 0 37.332031 16.746093 37.332031 37.332031v330.667969C469.332031 495.253906 452.585938 512 432 512zm-53.332031-373.332031c-2.945313 0-5.335938 2.386719-5.335938 5.332031v330.667969c0 2.941406 2.390625 5.332031 5.335938 5.332031H432c2.945312 0 5.332031-2.390625 5.332031-5.332031V144c0-2.945312-2.386719-5.332031-5.332031-5.332031zm0 0M197.332031 512h-160C16.746094 512 0 495.253906 0 474.667969V144c0-20.585938 16.746094-37.332031 37.332031-37.332031h160c20.589844 0 37.335938 16.746093 37.335938 37.332031v330.667969c0 20.585937-16.746094 37.332031-37.335938 37.332031zm-160-373.332031C34.390625 138.667969 32 141.054688 32 144v330.667969C32 477.609375 34.390625 480 37.332031 480h160c2.945313 0 5.335938-2.390625 5.335938-5.332031V144c0-2.945312-2.390625-5.332031-5.335938-5.332031zm0 0"></path><path d="M453.332031 325.332031h-96c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16h96c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0M218.667969 325.332031H16c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16h202.667969c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0"></path><path d="M117.332031 512c-8.832031 0-16-7.167969-16-16V122.667969c0-8.832031 7.167969-16 16-16s16 7.167969 16 16V496c0 8.832031-7.167969 16-16 16zm0 0"></path></svg>';
        }, function(e2, l2) {
          e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -21 512 512" width="18" height="18"><path d="M16 277.332031c-1.984375 0-3.96875-.363281-5.867188-1.109375C4.011719 273.8125 0 267.902344 0 261.332031v-160c0-6.570312 4.011719-12.480469 10.132812-14.890625 6.144532-2.410156 13.078126-.851562 17.558594 3.96875l74.664063 80c5.761719 6.144532 5.761719 15.679688 0 21.824219l-74.664063 80C24.597656 275.5625 20.351562 277.332031 16 277.332031zm16-135.402343v78.804687l36.777344-39.402344zm0 0M474.667969 128H144c-20.585938 0-37.332031-16.746094-37.332031-37.332031V37.332031C106.667969 16.746094 123.414062 0 144 0h330.667969C495.253906 0 512 16.746094 512 37.332031v53.335938C512 111.253906 495.253906 128 474.667969 128zM144 32c-2.945312 0-5.332031 2.390625-5.332031 5.332031v53.335938C138.667969 93.609375 141.054688 96 144 96h330.667969C477.609375 96 480 93.609375 480 90.667969V37.332031C480 34.390625 477.609375 32 474.667969 32zm0 0M474.667969 469.332031H144c-20.585938 0-37.332031-16.746093-37.332031-37.332031V272c0-20.585938 16.746093-37.332031 37.332031-37.332031h330.667969C495.253906 234.667969 512 251.414062 512 272v160c0 20.585938-16.746094 37.332031-37.332031 37.332031zM144 266.667969c-2.945312 0-5.332031 2.386719-5.332031 5.332031v160c0 2.945312 2.386719 5.332031 5.332031 5.332031h330.667969C477.609375 437.332031 480 434.945312 480 432V272c0-2.945312-2.390625-5.332031-5.332031-5.332031zm0 0"></path><path d="M309.332031 128c-8.832031 0-16-7.167969-16-16V16c0-8.832031 7.167969-16 16-16s16 7.167969 16 16v96c0 8.832031-7.167969 16-16 16zm0 0M309.332031 469.332031c-8.832031 0-16-7.167969-16-16V250.667969c0-8.832031 7.167969-16 16-16s16 7.167969 16 16v202.664062c0 8.832031-7.167969 16-16 16zm0 0"></path><path d="M496 368H122.667969c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16H496c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0"></path></svg>';
        }, function(e2, l2) {
          e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -21 512 512" width="18" height="18"><path d="M16 384c-1.984375 0-3.96875-.363281-5.867188-1.109375C4.011719 380.480469 0 374.570312 0 368V208c0-6.570312 4.011719-12.480469 10.132812-14.890625 6.144532-2.410156 13.078126-.851563 17.558594 3.96875l74.664063 80c5.761719 6.144531 5.761719 15.679687 0 21.824219l-74.664063 80C24.597656 382.230469 20.351562 384 16 384zm16-135.402344v78.804688L68.777344 288zm0 0M474.667969 469.332031H144c-20.585938 0-37.332031-16.746093-37.332031-37.332031v-53.332031c0-20.589844 16.746093-37.335938 37.332031-37.335938h330.667969c20.585937 0 37.332031 16.746094 37.332031 37.335938V432c0 20.585938-16.746094 37.332031-37.332031 37.332031zm-330.667969-96c-2.945312 0-5.332031 2.390625-5.332031 5.335938V432c0 2.945312 2.386719 5.332031 5.332031 5.332031h330.667969C477.609375 437.332031 480 434.945312 480 432v-53.332031c0-2.945313-2.390625-5.335938-5.332031-5.335938zm0 0M474.667969 234.667969H144c-20.585938 0-37.332031-16.746094-37.332031-37.335938v-160C106.667969 16.746094 123.414062 0 144 0h330.667969C495.253906 0 512 16.746094 512 37.332031v160c0 20.589844-16.746094 37.335938-37.332031 37.335938zM144 32c-2.945312 0-5.332031 2.390625-5.332031 5.332031v160c0 2.945313 2.386719 5.335938 5.332031 5.335938h330.667969c2.941406 0 5.332031-2.390625 5.332031-5.335938v-160C480 34.390625 477.609375 32 474.667969 32zm0 0"></path><path d="M309.332031 469.332031c-8.832031 0-16-7.167969-16-16v-96c0-8.832031 7.167969-16 16-16s16 7.167969 16 16v96c0 8.832031-7.167969 16-16 16zm0 0M309.332031 234.667969c-8.832031 0-16-7.167969-16-16V16c0-8.832031 7.167969-16 16-16s16 7.167969 16 16v202.667969c0 8.832031-7.167969 16-16 16zm0 0"></path><path d="M496 133.332031H122.667969c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16H496c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0"></path></svg>';
        }, function(e2, l2) {
          e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.381 15.381" width="18" height="18"><g><path d="M0 1.732v7.732h6.053c0-.035-.004-.07-.004-.104 0-.434.061-.854.165-1.255H1.36V3.092h12.662v2.192c.546.396 1.01.897 1.359 1.477V1.732H0z"></path><path d="M11.196 5.28c-2.307 0-4.183 1.877-4.183 4.184 0 2.308 1.876 4.185 4.183 4.185 2.309 0 4.185-1.877 4.185-4.185 0-2.307-1.876-4.184-4.185-4.184zm0 7.233c-1.679 0-3.047-1.367-3.047-3.049 0-1.68 1.368-3.049 3.047-3.049 1.684 0 3.05 1.369 3.05 3.049 0 1.682-1.366 3.049-3.05 3.049z"></path><path d="M9.312 8.759h3.844v1.104H9.312z"></path></g></svg>';
        }, function(e2, l2) {
          e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="18" height="18"><path d="M13.594 20.85V24h-10V2h10v3.15c.633-.323 1.304-.565 2-.727V1c0-.551-.448-1-1-1h-12c-.55 0-1 .449-1 1v24c0 .551.449 1 1 1h12c.552 0 1-.449 1-1v-3.424c-.696-.161-1.367-.403-2-.726z"></path><path d="M17.594 6.188c-3.762 0-6.813 3.051-6.812 6.813-.001 3.761 3.05 6.812 6.812 6.812s6.813-3.051 6.813-6.813-3.052-6.812-6.813-6.812zm3.632 7.802l-7.267.001v-1.982h7.268l-.001 1.981z"></path></svg>';
        }, function(e2, l2, a2) {
          a2.r(l2), a2.d(l2, "TableConstructor", function() {
            return w2;
          });
          a2(3);
          function _2(e3) {
            return !(null == e3);
          }
          function t2(e3, l3 = null, a3 = null, t3 = null) {
            const r3 = document.createElement(e3);
            if (_2(l3))
              for (let e4 = 0; e4 < l3.length; e4++)
                _2(l3[e4]) && r3.classList.add(l3[e4]);
            if (_2(a3))
              for (let e4 in a3)
                r3.setAttribute(e4, a3[e4]);
            if (_2(t3))
              for (let e4 = 0; e4 < t3.length; e4++)
                _2(t3[e4]) && r3.appendChild(t3[e4]);
            return r3;
          }
          a2(6);
          const r2 = "tc-table", o2 = "tc-table__inp", s2 = "tc-table__cell", c2 = "tc-table__wrap", d2 = "tc-table__area", h2 = "tc-table__highlight";
          class n2 {
            constructor() {
              this._numberOfColumns = 0, this._numberOfRows = 0, this._element = this._createTableWrapper(), this._table = this._element.querySelector("table"), this._selectedCell = null, this._attachEvents();
            }
            get selectedCell() {
              return this._selectedCell;
            }
            set selectedCell(e3) {
              this._selectedCell && this._selectedCell.classList.remove(h2), this._selectedCell = e3, this._selectedCell && this._selectedCell.classList.add(h2);
            }
            get selectedRow() {
              return this.selectedCell ? this.selectedCell.closest("tr") : null;
            }
            insertColumnAfter() {
              this.insertColumn(1), this.focusCellOnSelectedCell();
            }
            insertColumnBefore() {
              this.insertColumn(), this.focusCellOnSelectedCell();
            }
            insertRowBefore() {
              this.insertRow(), this.focusCellOnSelectedCell();
            }
            insertRowAfter() {
              this.insertRow(1), this.focusCellOnSelectedCell();
            }
            insertColumn(e3 = 0) {
              e3 = Math.min(Math.max(e3, 0), 1);
              const l3 = this.selectedCell ? this.selectedCell.cellIndex + e3 : 0;
              this._numberOfColumns++;
              const a3 = this._table.rows;
              for (let e4 = 0; e4 < a3.length; e4++) {
                const _3 = a3[e4].insertCell(l3);
                this._fillCell(_3);
              }
            }
            deleteColumn() {
              if (!this.selectedCell)
                return;
              const e3 = this.selectedCell.cellIndex;
              this._numberOfColumns--;
              const l3 = this._table.rows;
              for (let a3 = 0; a3 < l3.length; a3++)
                l3[a3].deleteCell(e3);
            }
            insertRow(e3 = 0) {
              e3 = Math.min(Math.max(e3, 0), 1);
              const l3 = this.selectedRow ? this.selectedRow.rowIndex + e3 : 0, a3 = this._table.insertRow(l3);
              return this._numberOfRows++, this._fillRow(a3), a3;
            }
            deleteRow(e3 = -1) {
              if (!this.selectedRow)
                return;
              const l3 = this.selectedRow.rowIndex;
              this._table.deleteRow(l3), this._numberOfRows--;
            }
            get htmlElement() {
              return this._element;
            }
            get body() {
              return this._table;
            }
            _createTableWrapper() {
              return t2("div", [c2], null, [t2("table", [r2])]);
            }
            _createContenteditableArea() {
              return t2("div", [o2], { contenteditable: "true" });
            }
            _fillCell(e3) {
              e3.classList.add(s2);
              const l3 = this._createContenteditableArea();
              e3.appendChild(t2("div", [d2], null, [l3]));
            }
            _fillRow(e3) {
              for (let l3 = 0; l3 < this._numberOfColumns; l3++) {
                const l4 = e3.insertCell();
                this._fillCell(l4);
              }
            }
            _attachEvents() {
              this._table.addEventListener("focus", (e3) => {
                this._focusEditField(e3);
              }, true), this._table.addEventListener("keydown", (e3) => {
                this._pressedEnterInEditField(e3);
              }), this._table.addEventListener("click", (e3) => {
                this._clickedOnCell(e3);
              }), this.htmlElement.addEventListener("keydown", (e3) => {
                this._containerKeydown(e3);
              });
            }
            _focusEditField(e3) {
              this.selectedCell = "TD" === e3.target.tagName ? e3.target : e3.target.closest("td");
            }
            focusCellOnSelectedCell() {
              this.selectedCell.childNodes[0].childNodes[0].focus();
            }
            _pressedEnterInEditField(e3) {
              e3.target.classList.contains(o2) && ("Enter" !== e3.key || e3.shiftKey || e3.preventDefault());
            }
            _clickedOnCell(e3) {
              if (!e3.target.classList.contains(s2))
                return;
              e3.target.querySelector("." + o2).focus();
            }
            _containerKeydown(e3) {
              "Enter" === e3.key && e3.ctrlKey && this._containerEnterPressed(e3);
            }
            _containerEnterPressed(e3) {
              this.insertRow(1).cells[0].click();
            }
          }
          const i2 = "tc-editor", v2 = "tc-table__inp";
          class w2 {
            constructor(e3, l3, a3) {
              this._table = new n2();
              const _3 = this._resizeTable(e3, l3);
              this._fillTable(e3, _3), this._container = t2("div", [i2, a3.styles && a3.styles.block], null, [this._table.htmlElement]);
            }
            get htmlElement() {
              return this._container;
            }
            get table() {
              return this._table;
            }
            _fillTable(e3, l3) {
              if (void 0 !== e3.content)
                for (let a3 = 0; a3 < l3.rows && a3 < e3.content.length; a3++)
                  for (let _3 = 0; _3 < l3.cols && _3 < e3.content[a3].length; _3++) {
                    this._table.body.rows[a3].cells[_3].querySelector("." + v2).innerHTML = e3.content[a3][_3];
                  }
            }
            _resizeTable(e3, l3) {
              const a3 = Array.isArray(e3.content), _3 = !!a3 && e3.content.length, t3 = a3 ? e3.content.length : void 0, r3 = _3 ? e3.content[0].length : void 0, o3 = Number.parseInt(l3.rows), s3 = Number.parseInt(l3.cols), c3 = !isNaN(o3) && o3 > 0 ? o3 : void 0, d3 = !isNaN(s3) && s3 > 0 ? s3 : void 0, h3 = t3 || c3 || 1, n3 = r3 || d3 || 1;
              for (let e4 = 0; e4 < h3; e4++)
                this._table.insertRow();
              for (let e4 = 0; e4 < n3; e4++)
                this._table.insertColumn();
              return { rows: h3, cols: n3 };
            }
          }
        }]);
      });
    })(bundle);
    var bundleExports = bundle.exports;
    const Table = /* @__PURE__ */ getDefaultExportFromCjs(bundleExports);
    const EDITOR_JS_TOOLS = {
      embed: { class: m, inlineToolbar: true },
      // table: Table,
      list: {
        class: d,
        inlineToolbar: true
      },
      table: Table,
      // warning: Warning,
      youtube: {
        class: Youtube,
        inlineToolbar: true
      },
      // code: Code,
      // linkTool: { class: LinkTool, inlineToolbar: true },
      image: {
        class: P,
        inlineToolbar: true,
        config: {
          endpoints: {
            byFile: "/api/course/upload-temp-image"
            // byUrl: 'http://127.0.0.1:5173/assets/images/',
          }
        }
      },
      // raw: { class: Raw, inlineToolbar: true },
      // header: { class: Header, inlineToolbar: true },
      // quote: Quote,
      // marker: Marker,
      // checklist: { class: CheckList, inlineToolbar: true },
      // delimiter: Delimiter,
      inlineCode: s
      // image: { class: SimpleImage, inlineToolbar: true },
    };
    const EDITOR_INTERNATIONALIZATION_CONFIG = {
      /**
       * @type {I18nDictionary}
       */
      messages: {
        /**
         * Other below: translation of different UI components of the editor.js core
         */
        ui: {
          blockTunes: {
            toggler: {
              "Click to tune": ",  ",
              "or drag to move": " "
            }
          },
          inlineToolbar: {
            converter: {
              "Convert to": " "
            }
          },
          toolbar: {
            toolbox: {
              Add: ""
            }
          }
        },
        /**
         * Section for translation Tool Names: both block and inline tools
         */
        toolNames: {
          Text: "",
          // Heading: '',
          List: "",
          // Warning: '',
          // Checklist: '',
          // Quote: '',
          // Code: '',
          // Delimiter: '',
          // 'Raw HTML': 'HTML-',
          // Table: '',
          Link: "",
          // Marker: '',
          Bold: "",
          Italic: "",
          InlineCode: "",
          Image: ""
        },
        /**
         * Section for passing translations to the external tools classes
         */
        tools: {
          /**
           * Each subsection is the i18n dictionary that will be passed to the corresponded plugin
           * The name of a plugin should be equal the name you specify in the 'tool' section for that plugin
           */
          warning: {
            // <-- 'Warning' tool will accept this dictionary section
            Title: "",
            Message: ""
          },
          /**
           * Link is the internal Inline Tool
           */
          link: {
            "Add a link": " "
          },
          /**
           * The "stub" is an internal block tool, used to fit blocks that does not have the corresponded plugin
           */
          stub: {
            "The block can not be displayed correctly.": "    "
          },
          list: {
            Unordered: "",
            Ordered: ""
          }
        },
        /**
         * Section allows to translate Block Tunes
         */
        blockTunes: {
          /**
           * Each subsection is the i18n dictionary that will be passed to the corresponded Block Tune plugin
           * The name of a plugin should be equal the name you specify in the 'tunes' section for that plugin
           *
           * Also, there are few internal block tunes: "delete", "moveUp" and "moveDown"
           */
          delete: {
            Delete: ""
          },
          moveUp: {
            "Move up": " "
          },
          moveDown: {
            "Move down": " "
          }
        }
      }
    };
    const addIcon = "/assets/addIconWhite.svg";
    const Container$3 = st$1(FlexContainer)`
  flex-direction: column;
  padding-top: 40px;
  margin-bottom: 30px;
`;
    const TestName = st$1(InputWithState)`
  margin-bottom: 30px;
`;
    const Variants = st$1(FlexContainer)`
  flex-direction: column;
`;
    const AddVariant = st$1(DefaultBtn)`
  width: fit-content;
  padding: 0 20px 0 50px;
  margin-bottom: 45px;
  background-image: url(${addIcon});
  background-repeat: no-repeat;
  background-position: 23px 50%;
  background-size: 24px;
`;
    const DeleteTestBtn = st$1.button`
  display: flex;
  align-items: center;
  width: fit-content;
  padding: 0;
  margin: 0 0 45px;
  color: ${(props) => props.theme.colors.yRed};
  background-color: transparent;
`;
    const DeleteTestBtnIcon = st$1(Icon$2)`
  margin-right: 5px;
  background-image: url(${deleteIcon$1});
`;
    const Title$3 = st$1.h5`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 18px;
  font-weight: 600;
  line-height: 120%;
  color: ${(props) => props.theme.colors.grey57};
`;
    function Title$2({ value, children }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$3, { children: [
        value,
        children
      ] });
    }
    const Container$2 = st$1(FlexContainer)`
  flex-direction: column;
  margin-bottom: 15px;
  &:not(:last-child) {
    margin-bottom: 40px;
  }
`;
    const VariantInput = st$1(InputWithState)`
  margin-bottom: 20px;
`;
    const RadioGroup = st$1(FlexContainer)`
  align-items: center;
  margin-bottom: 20px;
`;
    const CommentInput = st$1(Input$4)`
  color: ${(props) => props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed};

  &:focus {
    color: ${(props) => props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed}; 
  }
`;
    const DeleteBtn$2 = st$1.button`
  background-color: transparent;
  padding: 0;
  margin: 0;
  margin-left: auto;
`;
    const DeleteBtnIcon = st$1(Icon$2)`
  background-image: url(${deleteIcon$1});
`;
    function DeleteBtn$1({ onClick: onClick2 = () => {
    }, styles: styles2 = {} }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        DeleteBtn$2,
        {
          style: styles2,
          onClick: onClick2,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteBtnIcon, {})
        }
      );
    }
    const Label$1 = st$1.label`
  display: flex;
  align-items: center;
  cursor: pointer;
`;
    const RadioInput = st$1.input`
  display: none;

  &:checked + div::before {
    display: block;
  }
`;
    const CustomRadioInput = st$1.div`
  width: 16px;
  height: 16px;
  margin-right: 14px;
  border-radius: 50%;
  position: relative;
  border: 1px solid #333;

  &::before {
    content: '';
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background-color: #333;
    transform: translate(-50%, -50%);
  }
`;
    function CustomRadioButton({
      onChange = () => {
      },
      name = "default",
      value,
      option,
      checked,
      styles: styles2 = {},
      radioStyles = {}
    }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Label$1, { style: styles2, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          RadioInput,
          {
            name,
            type: "radio",
            value,
            onChange,
            "data-option": option,
            checked
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRadioInput, { style: radioStyles }),
        value
      ] });
    }
    function Variant({ data, number, testId }) {
      const { toggleAnswer, changeAnswer, changeAnswerComment, deleteAnswer } = useActions();
      const [isValid, setValid] = reactExports.useState(false);
      const [isChanged, setChanged] = reactExports.useState(false);
      const [defaultCommentValue, setDefaultCommentValue] = reactExports.useState("");
      reactExports.useEffect(() => {
        const trueComment = ",   ";
        const falseComment = ",   ";
        changeAnswerComment({
          testId,
          answerId: data.id || "",
          value: ""
        });
        data.right_answer ? setDefaultCommentValue(trueComment) : setDefaultCommentValue(falseComment);
      }, [changeAnswerComment, data.id, data.right_answer, testId]);
      const handleSetRightAnswer = (isRight) => {
        const payload = {
          testId,
          answerId: data.id || "",
          isRight
        };
        toggleAnswer(payload);
      };
      const handleChangeAnswer = (event) => {
        changeAnswer({
          testId,
          answerId: data.id || "",
          value: event.target.value
        });
        if (event.target.value.length > 0) {
          setValid(true);
        }
        if (!isChanged) {
          setChanged(true);
        }
      };
      const handleChangeComment = (event) => {
        let value = event.target.value;
        if (!value.includes(defaultCommentValue)) {
          value = defaultCommentValue + value;
        }
        changeAnswerComment({
          testId,
          answerId: data.id || "",
          value
        });
      };
      const handleDeleteVariant = () => {
        deleteAnswer({
          testId,
          answerId: data.id || ""
        });
      };
      const radioFontStyles = {
        fontSize: "18px",
        fontWeight: "600"
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$2, { value: ` ${number}`, children: number > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteBtn$1, { onClick: handleDeleteVariant }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          VariantInput,
          {
            type: "text",
            value: data.answer,
            onChange: handleChangeAnswer,
            $isChanged: isChanged,
            $isValid: isValid
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioGroup, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CustomRadioButton,
            {
              styles: { marginRight: "25px", color: "#5B8930", ...radioFontStyles },
              name: data.id,
              value: "",
              checked: data.right_answer,
              onChange: () => {
                handleSetRightAnswer(true);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            CustomRadioButton,
            {
              styles: { color: "#E03638", ...radioFontStyles },
              name: data.id,
              value: "",
              checked: !data.right_answer,
              onChange: () => {
                handleSetRightAnswer(false);
              }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CommentInput,
          {
            type: "text",
            value: data.text || defaultCommentValue,
            $isRight: data.right_answer,
            onChange: handleChangeComment
          }
        )
      ] });
    }
    function CreateTestForm({ data }) {
      const { changeTestQuestion, addAnswer, deleteTest } = useActions();
      const [isChanged, setChanged] = reactExports.useState(false);
      const handleChangeTestName = (event) => {
        changeTestQuestion({ id: data.id, question: event.target.value });
        if (!isChanged) {
          setChanged(true);
        }
      };
      const handleAddVariant = () => {
        addAnswer({ id: data.id });
      };
      const handleDeleteTest = () => {
        deleteTest(data.id);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$3, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$2, { value: "  ()" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          TestName,
          {
            type: "text",
            value: data.question,
            onChange: handleChangeTestName,
            $isValid: true,
            $isChanged: isChanged
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Variants, { children: data.answers.length > 0 && data.answers.map((answer, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Variant,
          {
            testId: data.id,
            data: answer,
            number: index + 1
          }
        )) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AddVariant, { onClick: handleAddVariant, children: " " }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DeleteTestBtn, { onClick: handleDeleteTest, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteTestBtnIcon, {}),
          " "
        ] })
      ] });
    }
    var dist = { exports: {} };
    /*!
     * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md.
     */
    dist.exports;
    (function(module2, exports2) {
      !function(t2, e2) {
        module2.exports = e2(reactExports);
      }(self, (t2) => (() => {
        var e2 = { 703: (t3, e3, r3) => {
          var o3 = r3(414);
          function n3() {
          }
          function i2() {
          }
          i2.resetWarningCache = n3, t3.exports = function() {
            function t4(t5, e5, r5, n4, i3, s2) {
              if (s2 !== o3) {
                var a2 = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                throw a2.name = "Invariant Violation", a2;
              }
            }
            function e4() {
              return t4;
            }
            t4.isRequired = t4;
            var r4 = { array: t4, bigint: t4, bool: t4, func: t4, number: t4, object: t4, string: t4, symbol: t4, any: t4, arrayOf: e4, element: t4, elementType: t4, instanceOf: e4, node: t4, objectOf: e4, oneOf: e4, oneOfType: e4, shape: e4, exact: e4, checkPropTypes: i2, resetWarningCache: n3 };
            return r4.PropTypes = r4, r4;
          };
        }, 697: (t3, e3, r3) => {
          t3.exports = r3(703)();
        }, 414: (t3) => {
          t3.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        }, 787: (e3) => {
          e3.exports = t2;
        } }, r2 = {};
        function o2(t3) {
          var n3 = r2[t3];
          if (void 0 !== n3)
            return n3.exports;
          var i2 = r2[t3] = { exports: {} };
          return e2[t3](i2, i2.exports, o2), i2.exports;
        }
        o2.n = (t3) => {
          var e3 = t3 && t3.__esModule ? () => t3.default : () => t3;
          return o2.d(e3, { a: e3 }), e3;
        }, o2.d = (t3, e3) => {
          for (var r3 in e3)
            o2.o(e3, r3) && !o2.o(t3, r3) && Object.defineProperty(t3, r3, { enumerable: true, get: e3[r3] });
        }, o2.o = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), o2.r = (t3) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
        };
        var n2 = {};
        return (() => {
          o2.r(n2), o2.d(n2, { CKEditor: () => to2, CKEditorContext: () => Xr });
          var t3 = o2(787), e3 = o2.n(t3), r3 = o2(697), i2 = o2.n(r3);
          const s2 = new Array(256).fill("").map((t4, e4) => ("0" + e4.toString(16)).slice(-2));
          class a2 {
            constructor(t4) {
              if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = "number" == typeof t4.crashNumberLimit ? t4.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = "number" == typeof t4.minimumNonErrorTimePeriod ? t4.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t5) => {
                const e4 = "error" in t5 ? t5.error : t5.reason;
                e4 instanceof Error && this._handleError(e4, t5);
              }, this._listeners = {}, !this._restart)
                throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
            }
            destroy() {
              this._stopErrorHandling(), this._listeners = {};
            }
            on(t4, e4) {
              this._listeners[t4] || (this._listeners[t4] = []), this._listeners[t4].push(e4);
            }
            off(t4, e4) {
              this._listeners[t4] = this._listeners[t4].filter((t5) => t5 !== e4);
            }
            _fire(t4, ...e4) {
              const r4 = this._listeners[t4] || [];
              for (const t5 of r4)
                t5.apply(this, [null, ...e4]);
            }
            _startErrorHandling() {
              window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
            }
            _stopErrorHandling() {
              window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
            }
            _handleError(t4, e4) {
              if (this._shouldReactToError(t4)) {
                this.crashes.push({ message: t4.message, stack: t4.stack, filename: e4 instanceof ErrorEvent ? e4.filename : void 0, lineno: e4 instanceof ErrorEvent ? e4.lineno : void 0, colno: e4 instanceof ErrorEvent ? e4.colno : void 0, date: this._now() });
                const r4 = this._shouldRestart();
                this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: t4, causesRestart: r4 }), r4 ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
              }
            }
            _shouldReactToError(t4) {
              return t4.is && t4.is("CKEditorError") && void 0 !== t4.context && null !== t4.context && "ready" === this.state && this._isErrorComingFromThisItem(t4);
            }
            _shouldRestart() {
              if (this.crashes.length <= this._crashNumberLimit)
                return true;
              return (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
            }
          }
          function c2(t4, e4 = /* @__PURE__ */ new Set()) {
            const r4 = [t4], o3 = /* @__PURE__ */ new Set();
            let n3 = 0;
            for (; r4.length > n3; ) {
              const t5 = r4[n3++];
              if (!o3.has(t5) && u2(t5) && !e4.has(t5))
                if (o3.add(t5), Symbol.iterator in t5)
                  try {
                    for (const e5 of t5)
                      r4.push(e5);
                  } catch (t6) {
                  }
                else
                  for (const e5 in t5)
                    "defaultValue" !== e5 && r4.push(t5[e5]);
            }
            return o3;
          }
          function u2(t4) {
            const e4 = Object.prototype.toString.call(t4), r4 = typeof t4;
            return !("number" === r4 || "boolean" === r4 || "string" === r4 || "symbol" === r4 || "function" === r4 || "[object Date]" === e4 || "[object RegExp]" === e4 || "[object Module]" === e4 || null == t4 || t4._watchdogExcluded || t4 instanceof EventTarget || t4 instanceof Event);
          }
          function h2(t4, e4, r4 = /* @__PURE__ */ new Set()) {
            if (t4 === e4 && ("object" == typeof (o3 = t4) && null !== o3))
              return true;
            var o3;
            const n3 = c2(t4, r4), i3 = c2(e4, r4);
            for (const t5 of n3)
              if (i3.has(t5))
                return true;
            return false;
          }
          const d2 = function(t4) {
            var e4 = typeof t4;
            return null != t4 && ("object" == e4 || "function" == e4);
          };
          const l2 = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
          var p2 = "object" == typeof self && self && self.Object === Object && self;
          const f2 = l2 || p2 || Function("return this")();
          const _2 = function() {
            return f2.Date.now();
          };
          var y2 = /\s/;
          const g2 = function(t4) {
            for (var e4 = t4.length; e4-- && y2.test(t4.charAt(e4)); )
              ;
            return e4;
          };
          var b2 = /^\s+/;
          const v2 = function(t4) {
            return t4 ? t4.slice(0, g2(t4) + 1).replace(b2, "") : t4;
          };
          const m2 = f2.Symbol;
          var j2 = Object.prototype, w2 = j2.hasOwnProperty, x2 = j2.toString, E2 = m2 ? m2.toStringTag : void 0;
          const O2 = function(t4) {
            var e4 = w2.call(t4, E2), r4 = t4[E2];
            try {
              t4[E2] = void 0;
              var o3 = true;
            } catch (t5) {
            }
            var n3 = x2.call(t4);
            return o3 && (e4 ? t4[E2] = r4 : delete t4[E2]), n3;
          };
          var C2 = Object.prototype.toString;
          const P2 = function(t4) {
            return C2.call(t4);
          };
          var A2 = m2 ? m2.toStringTag : void 0;
          const W2 = function(t4) {
            return null == t4 ? void 0 === t4 ? "[object Undefined]" : "[object Null]" : A2 && A2 in Object(t4) ? O2(t4) : P2(t4);
          };
          const T2 = function(t4) {
            return null != t4 && "object" == typeof t4;
          };
          const S2 = function(t4) {
            return "symbol" == typeof t4 || T2(t4) && "[object Symbol]" == W2(t4);
          };
          var R2 = /^[-+]0x[0-9a-f]+$/i, I2 = /^0b[01]+$/i, D2 = /^0o[0-7]+$/i, z2 = parseInt;
          const M2 = function(t4) {
            if ("number" == typeof t4)
              return t4;
            if (S2(t4))
              return NaN;
            if (d2(t4)) {
              var e4 = "function" == typeof t4.valueOf ? t4.valueOf() : t4;
              t4 = d2(e4) ? e4 + "" : e4;
            }
            if ("string" != typeof t4)
              return 0 === t4 ? t4 : +t4;
            t4 = v2(t4);
            var r4 = I2.test(t4);
            return r4 || D2.test(t4) ? z2(t4.slice(2), r4 ? 2 : 8) : R2.test(t4) ? NaN : +t4;
          };
          var U2 = Math.max, N2 = Math.min;
          const F2 = function(t4, e4, r4) {
            var o3, n3, i3, s3, a3, c3, u3 = 0, h3 = false, l3 = false, p3 = true;
            if ("function" != typeof t4)
              throw new TypeError("Expected a function");
            function f3(e5) {
              var r5 = o3, i4 = n3;
              return o3 = n3 = void 0, u3 = e5, s3 = t4.apply(i4, r5);
            }
            function y3(t5) {
              var r5 = t5 - c3;
              return void 0 === c3 || r5 >= e4 || r5 < 0 || l3 && t5 - u3 >= i3;
            }
            function g3() {
              var t5 = _2();
              if (y3(t5))
                return b3(t5);
              a3 = setTimeout(g3, function(t6) {
                var r5 = e4 - (t6 - c3);
                return l3 ? N2(r5, i3 - (t6 - u3)) : r5;
              }(t5));
            }
            function b3(t5) {
              return a3 = void 0, p3 && o3 ? f3(t5) : (o3 = n3 = void 0, s3);
            }
            function v3() {
              var t5 = _2(), r5 = y3(t5);
              if (o3 = arguments, n3 = this, c3 = t5, r5) {
                if (void 0 === a3)
                  return function(t6) {
                    return u3 = t6, a3 = setTimeout(g3, e4), h3 ? f3(t6) : s3;
                  }(c3);
                if (l3)
                  return clearTimeout(a3), a3 = setTimeout(g3, e4), f3(c3);
              }
              return void 0 === a3 && (a3 = setTimeout(g3, e4)), s3;
            }
            return e4 = M2(e4) || 0, d2(r4) && (h3 = !!r4.leading, i3 = (l3 = "maxWait" in r4) ? U2(M2(r4.maxWait) || 0, e4) : i3, p3 = "trailing" in r4 ? !!r4.trailing : p3), v3.cancel = function() {
              void 0 !== a3 && clearTimeout(a3), u3 = 0, o3 = c3 = n3 = a3 = void 0;
            }, v3.flush = function() {
              return void 0 === a3 ? s3 : b3(_2());
            }, v3;
          };
          const q2 = function(t4, e4, r4) {
            var o3 = true, n3 = true;
            if ("function" != typeof t4)
              throw new TypeError("Expected a function");
            return d2(r4) && (o3 = "leading" in r4 ? !!r4.leading : o3, n3 = "trailing" in r4 ? !!r4.trailing : n3), F2(t4, e4, { leading: o3, maxWait: e4, trailing: n3 });
          };
          const L2 = function() {
            this.__data__ = [], this.size = 0;
          };
          const k2 = function(t4, e4) {
            return t4 === e4 || t4 != t4 && e4 != e4;
          };
          const B2 = function(t4, e4) {
            for (var r4 = t4.length; r4--; )
              if (k2(t4[r4][0], e4))
                return r4;
            return -1;
          };
          var $2 = Array.prototype.splice;
          const H2 = function(t4) {
            var e4 = this.__data__, r4 = B2(e4, t4);
            return !(r4 < 0) && (r4 == e4.length - 1 ? e4.pop() : $2.call(e4, r4, 1), --this.size, true);
          };
          const V2 = function(t4) {
            var e4 = this.__data__, r4 = B2(e4, t4);
            return r4 < 0 ? void 0 : e4[r4][1];
          };
          const K2 = function(t4) {
            return B2(this.__data__, t4) > -1;
          };
          const Q2 = function(t4, e4) {
            var r4 = this.__data__, o3 = B2(r4, t4);
            return o3 < 0 ? (++this.size, r4.push([t4, e4])) : r4[o3][1] = e4, this;
          };
          function G2(t4) {
            var e4 = -1, r4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < r4; ) {
              var o3 = t4[e4];
              this.set(o3[0], o3[1]);
            }
          }
          G2.prototype.clear = L2, G2.prototype.delete = H2, G2.prototype.get = V2, G2.prototype.has = K2, G2.prototype.set = Q2;
          const Y2 = G2;
          const J2 = function() {
            this.__data__ = new Y2(), this.size = 0;
          };
          const X2 = function(t4) {
            var e4 = this.__data__, r4 = e4.delete(t4);
            return this.size = e4.size, r4;
          };
          const Z2 = function(t4) {
            return this.__data__.get(t4);
          };
          const tt2 = function(t4) {
            return this.__data__.has(t4);
          };
          const et2 = function(t4) {
            if (!d2(t4))
              return false;
            var e4 = W2(t4);
            return "[object Function]" == e4 || "[object GeneratorFunction]" == e4 || "[object AsyncFunction]" == e4 || "[object Proxy]" == e4;
          };
          const rt2 = f2["__core-js_shared__"];
          var ot2 = function() {
            var t4 = /[^.]+$/.exec(rt2 && rt2.keys && rt2.keys.IE_PROTO || "");
            return t4 ? "Symbol(src)_1." + t4 : "";
          }();
          const nt2 = function(t4) {
            return !!ot2 && ot2 in t4;
          };
          var it2 = Function.prototype.toString;
          const st2 = function(t4) {
            if (null != t4) {
              try {
                return it2.call(t4);
              } catch (t5) {
              }
              try {
                return t4 + "";
              } catch (t5) {
              }
            }
            return "";
          };
          var at2 = /^\[object .+?Constructor\]$/, ct2 = Function.prototype, ut2 = Object.prototype, ht2 = ct2.toString, dt2 = ut2.hasOwnProperty, lt2 = RegExp("^" + ht2.call(dt2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          const pt2 = function(t4) {
            return !(!d2(t4) || nt2(t4)) && (et2(t4) ? lt2 : at2).test(st2(t4));
          };
          const ft2 = function(t4, e4) {
            return null == t4 ? void 0 : t4[e4];
          };
          const _t5 = function(t4, e4) {
            var r4 = ft2(t4, e4);
            return pt2(r4) ? r4 : void 0;
          };
          const yt2 = _t5(f2, "Map");
          const gt2 = _t5(Object, "create");
          const bt2 = function() {
            this.__data__ = gt2 ? gt2(null) : {}, this.size = 0;
          };
          const vt2 = function(t4) {
            var e4 = this.has(t4) && delete this.__data__[t4];
            return this.size -= e4 ? 1 : 0, e4;
          };
          var mt2 = Object.prototype.hasOwnProperty;
          const jt2 = function(t4) {
            var e4 = this.__data__;
            if (gt2) {
              var r4 = e4[t4];
              return "__lodash_hash_undefined__" === r4 ? void 0 : r4;
            }
            return mt2.call(e4, t4) ? e4[t4] : void 0;
          };
          var wt2 = Object.prototype.hasOwnProperty;
          const xt2 = function(t4) {
            var e4 = this.__data__;
            return gt2 ? void 0 !== e4[t4] : wt2.call(e4, t4);
          };
          const Et2 = function(t4, e4) {
            var r4 = this.__data__;
            return this.size += this.has(t4) ? 0 : 1, r4[t4] = gt2 && void 0 === e4 ? "__lodash_hash_undefined__" : e4, this;
          };
          function Ot2(t4) {
            var e4 = -1, r4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < r4; ) {
              var o3 = t4[e4];
              this.set(o3[0], o3[1]);
            }
          }
          Ot2.prototype.clear = bt2, Ot2.prototype.delete = vt2, Ot2.prototype.get = jt2, Ot2.prototype.has = xt2, Ot2.prototype.set = Et2;
          const Ct2 = Ot2;
          const Pt2 = function() {
            this.size = 0, this.__data__ = { hash: new Ct2(), map: new (yt2 || Y2)(), string: new Ct2() };
          };
          const At2 = function(t4) {
            var e4 = typeof t4;
            return "string" == e4 || "number" == e4 || "symbol" == e4 || "boolean" == e4 ? "__proto__" !== t4 : null === t4;
          };
          const Wt2 = function(t4, e4) {
            var r4 = t4.__data__;
            return At2(e4) ? r4["string" == typeof e4 ? "string" : "hash"] : r4.map;
          };
          const Tt2 = function(t4) {
            var e4 = Wt2(this, t4).delete(t4);
            return this.size -= e4 ? 1 : 0, e4;
          };
          const St2 = function(t4) {
            return Wt2(this, t4).get(t4);
          };
          const Rt2 = function(t4) {
            return Wt2(this, t4).has(t4);
          };
          const It2 = function(t4, e4) {
            var r4 = Wt2(this, t4), o3 = r4.size;
            return r4.set(t4, e4), this.size += r4.size == o3 ? 0 : 1, this;
          };
          function Dt2(t4) {
            var e4 = -1, r4 = null == t4 ? 0 : t4.length;
            for (this.clear(); ++e4 < r4; ) {
              var o3 = t4[e4];
              this.set(o3[0], o3[1]);
            }
          }
          Dt2.prototype.clear = Pt2, Dt2.prototype.delete = Tt2, Dt2.prototype.get = St2, Dt2.prototype.has = Rt2, Dt2.prototype.set = It2;
          const zt2 = Dt2;
          const Mt = function(t4, e4) {
            var r4 = this.__data__;
            if (r4 instanceof Y2) {
              var o3 = r4.__data__;
              if (!yt2 || o3.length < 199)
                return o3.push([t4, e4]), this.size = ++r4.size, this;
              r4 = this.__data__ = new zt2(o3);
            }
            return r4.set(t4, e4), this.size = r4.size, this;
          };
          function Ut2(t4) {
            var e4 = this.__data__ = new Y2(t4);
            this.size = e4.size;
          }
          Ut2.prototype.clear = J2, Ut2.prototype.delete = X2, Ut2.prototype.get = Z2, Ut2.prototype.has = tt2, Ut2.prototype.set = Mt;
          const Nt2 = Ut2;
          const Ft2 = function(t4, e4) {
            for (var r4 = -1, o3 = null == t4 ? 0 : t4.length; ++r4 < o3 && false !== e4(t4[r4], r4, t4); )
              ;
            return t4;
          };
          const qt2 = function() {
            try {
              var t4 = _t5(Object, "defineProperty");
              return t4({}, "", {}), t4;
            } catch (t5) {
            }
          }();
          const Lt = function(t4, e4, r4) {
            "__proto__" == e4 && qt2 ? qt2(t4, e4, { configurable: true, enumerable: true, value: r4, writable: true }) : t4[e4] = r4;
          };
          var kt2 = Object.prototype.hasOwnProperty;
          const Bt2 = function(t4, e4, r4) {
            var o3 = t4[e4];
            kt2.call(t4, e4) && k2(o3, r4) && (void 0 !== r4 || e4 in t4) || Lt(t4, e4, r4);
          };
          const $t2 = function(t4, e4, r4, o3) {
            var n3 = !r4;
            r4 || (r4 = {});
            for (var i3 = -1, s3 = e4.length; ++i3 < s3; ) {
              var a3 = e4[i3], c3 = o3 ? o3(r4[a3], t4[a3], a3, r4, t4) : void 0;
              void 0 === c3 && (c3 = t4[a3]), n3 ? Lt(r4, a3, c3) : Bt2(r4, a3, c3);
            }
            return r4;
          };
          const Ht2 = function(t4, e4) {
            for (var r4 = -1, o3 = Array(t4); ++r4 < t4; )
              o3[r4] = e4(r4);
            return o3;
          };
          const Vt2 = function(t4) {
            return T2(t4) && "[object Arguments]" == W2(t4);
          };
          var Kt2 = Object.prototype, Qt2 = Kt2.hasOwnProperty, Gt2 = Kt2.propertyIsEnumerable;
          const Yt2 = Vt2(function() {
            return arguments;
          }()) ? Vt2 : function(t4) {
            return T2(t4) && Qt2.call(t4, "callee") && !Gt2.call(t4, "callee");
          };
          const Jt2 = Array.isArray;
          const Xt2 = function() {
            return false;
          };
          var Zt2 = exports2 && !exports2.nodeType && exports2, te2 = Zt2 && true && module2 && !module2.nodeType && module2, ee2 = te2 && te2.exports === Zt2 ? f2.Buffer : void 0;
          const re2 = (ee2 ? ee2.isBuffer : void 0) || Xt2;
          var oe2 = /^(?:0|[1-9]\d*)$/;
          const ne2 = function(t4, e4) {
            var r4 = typeof t4;
            return !!(e4 = null == e4 ? 9007199254740991 : e4) && ("number" == r4 || "symbol" != r4 && oe2.test(t4)) && t4 > -1 && t4 % 1 == 0 && t4 < e4;
          };
          const ie2 = function(t4) {
            return "number" == typeof t4 && t4 > -1 && t4 % 1 == 0 && t4 <= 9007199254740991;
          };
          var se2 = {};
          se2["[object Float32Array]"] = se2["[object Float64Array]"] = se2["[object Int8Array]"] = se2["[object Int16Array]"] = se2["[object Int32Array]"] = se2["[object Uint8Array]"] = se2["[object Uint8ClampedArray]"] = se2["[object Uint16Array]"] = se2["[object Uint32Array]"] = true, se2["[object Arguments]"] = se2["[object Array]"] = se2["[object ArrayBuffer]"] = se2["[object Boolean]"] = se2["[object DataView]"] = se2["[object Date]"] = se2["[object Error]"] = se2["[object Function]"] = se2["[object Map]"] = se2["[object Number]"] = se2["[object Object]"] = se2["[object RegExp]"] = se2["[object Set]"] = se2["[object String]"] = se2["[object WeakMap]"] = false;
          const ae2 = function(t4) {
            return T2(t4) && ie2(t4.length) && !!se2[W2(t4)];
          };
          const ce2 = function(t4) {
            return function(e4) {
              return t4(e4);
            };
          };
          var ue2 = exports2 && !exports2.nodeType && exports2, he2 = ue2 && true && module2 && !module2.nodeType && module2, de2 = he2 && he2.exports === ue2 && l2.process;
          const le2 = function() {
            try {
              var t4 = he2 && he2.require && he2.require("util").types;
              return t4 || de2 && de2.binding && de2.binding("util");
            } catch (t5) {
            }
          }();
          var pe2 = le2 && le2.isTypedArray;
          const fe2 = pe2 ? ce2(pe2) : ae2;
          var _e2 = Object.prototype.hasOwnProperty;
          const ye2 = function(t4, e4) {
            var r4 = Jt2(t4), o3 = !r4 && Yt2(t4), n3 = !r4 && !o3 && re2(t4), i3 = !r4 && !o3 && !n3 && fe2(t4), s3 = r4 || o3 || n3 || i3, a3 = s3 ? Ht2(t4.length, String) : [], c3 = a3.length;
            for (var u3 in t4)
              !e4 && !_e2.call(t4, u3) || s3 && ("length" == u3 || n3 && ("offset" == u3 || "parent" == u3) || i3 && ("buffer" == u3 || "byteLength" == u3 || "byteOffset" == u3) || ne2(u3, c3)) || a3.push(u3);
            return a3;
          };
          var ge2 = Object.prototype;
          const be2 = function(t4) {
            var e4 = t4 && t4.constructor;
            return t4 === ("function" == typeof e4 && e4.prototype || ge2);
          };
          const ve2 = function(t4, e4) {
            return function(r4) {
              return t4(e4(r4));
            };
          };
          const me2 = ve2(Object.keys, Object);
          var je2 = Object.prototype.hasOwnProperty;
          const we2 = function(t4) {
            if (!be2(t4))
              return me2(t4);
            var e4 = [];
            for (var r4 in Object(t4))
              je2.call(t4, r4) && "constructor" != r4 && e4.push(r4);
            return e4;
          };
          const xe2 = function(t4) {
            return null != t4 && ie2(t4.length) && !et2(t4);
          };
          const Ee2 = function(t4) {
            return xe2(t4) ? ye2(t4) : we2(t4);
          };
          const Oe2 = function(t4, e4) {
            return t4 && $t2(e4, Ee2(e4), t4);
          };
          const Ce2 = function(t4) {
            var e4 = [];
            if (null != t4)
              for (var r4 in Object(t4))
                e4.push(r4);
            return e4;
          };
          var Pe2 = Object.prototype.hasOwnProperty;
          const Ae2 = function(t4) {
            if (!d2(t4))
              return Ce2(t4);
            var e4 = be2(t4), r4 = [];
            for (var o3 in t4)
              ("constructor" != o3 || !e4 && Pe2.call(t4, o3)) && r4.push(o3);
            return r4;
          };
          const We2 = function(t4) {
            return xe2(t4) ? ye2(t4, true) : Ae2(t4);
          };
          const Te2 = function(t4, e4) {
            return t4 && $t2(e4, We2(e4), t4);
          };
          var Se2 = exports2 && !exports2.nodeType && exports2, Re2 = Se2 && true && module2 && !module2.nodeType && module2, Ie2 = Re2 && Re2.exports === Se2 ? f2.Buffer : void 0, De2 = Ie2 ? Ie2.allocUnsafe : void 0;
          const ze2 = function(t4, e4) {
            if (e4)
              return t4.slice();
            var r4 = t4.length, o3 = De2 ? De2(r4) : new t4.constructor(r4);
            return t4.copy(o3), o3;
          };
          const Me2 = function(t4, e4) {
            var r4 = -1, o3 = t4.length;
            for (e4 || (e4 = Array(o3)); ++r4 < o3; )
              e4[r4] = t4[r4];
            return e4;
          };
          const Ue2 = function(t4, e4) {
            for (var r4 = -1, o3 = null == t4 ? 0 : t4.length, n3 = 0, i3 = []; ++r4 < o3; ) {
              var s3 = t4[r4];
              e4(s3, r4, t4) && (i3[n3++] = s3);
            }
            return i3;
          };
          const Ne2 = function() {
            return [];
          };
          var Fe2 = Object.prototype.propertyIsEnumerable, qe2 = Object.getOwnPropertySymbols;
          const Le2 = qe2 ? function(t4) {
            return null == t4 ? [] : (t4 = Object(t4), Ue2(qe2(t4), function(e4) {
              return Fe2.call(t4, e4);
            }));
          } : Ne2;
          const ke2 = function(t4, e4) {
            return $t2(t4, Le2(t4), e4);
          };
          const Be2 = function(t4, e4) {
            for (var r4 = -1, o3 = e4.length, n3 = t4.length; ++r4 < o3; )
              t4[n3 + r4] = e4[r4];
            return t4;
          };
          const $e2 = ve2(Object.getPrototypeOf, Object);
          const He2 = Object.getOwnPropertySymbols ? function(t4) {
            for (var e4 = []; t4; )
              Be2(e4, Le2(t4)), t4 = $e2(t4);
            return e4;
          } : Ne2;
          const Ve2 = function(t4, e4) {
            return $t2(t4, He2(t4), e4);
          };
          const Ke2 = function(t4, e4, r4) {
            var o3 = e4(t4);
            return Jt2(t4) ? o3 : Be2(o3, r4(t4));
          };
          const Qe2 = function(t4) {
            return Ke2(t4, Ee2, Le2);
          };
          const Ge2 = function(t4) {
            return Ke2(t4, We2, He2);
          };
          const Ye2 = _t5(f2, "DataView");
          const Je2 = _t5(f2, "Promise");
          const Xe2 = _t5(f2, "Set");
          const Ze2 = _t5(f2, "WeakMap");
          var tr = "[object Map]", er = "[object Promise]", rr = "[object Set]", or = "[object WeakMap]", nr = "[object DataView]", ir = st2(Ye2), sr = st2(yt2), ar = st2(Je2), cr = st2(Xe2), ur = st2(Ze2), hr = W2;
          (Ye2 && hr(new Ye2(new ArrayBuffer(1))) != nr || yt2 && hr(new yt2()) != tr || Je2 && hr(Je2.resolve()) != er || Xe2 && hr(new Xe2()) != rr || Ze2 && hr(new Ze2()) != or) && (hr = function(t4) {
            var e4 = W2(t4), r4 = "[object Object]" == e4 ? t4.constructor : void 0, o3 = r4 ? st2(r4) : "";
            if (o3)
              switch (o3) {
                case ir:
                  return nr;
                case sr:
                  return tr;
                case ar:
                  return er;
                case cr:
                  return rr;
                case ur:
                  return or;
              }
            return e4;
          });
          const dr = hr;
          var lr = Object.prototype.hasOwnProperty;
          const pr = function(t4) {
            var e4 = t4.length, r4 = new t4.constructor(e4);
            return e4 && "string" == typeof t4[0] && lr.call(t4, "index") && (r4.index = t4.index, r4.input = t4.input), r4;
          };
          const fr = f2.Uint8Array;
          const _r = function(t4) {
            var e4 = new t4.constructor(t4.byteLength);
            return new fr(e4).set(new fr(t4)), e4;
          };
          const yr = function(t4, e4) {
            var r4 = e4 ? _r(t4.buffer) : t4.buffer;
            return new t4.constructor(r4, t4.byteOffset, t4.byteLength);
          };
          var gr = /\w*$/;
          const br = function(t4) {
            var e4 = new t4.constructor(t4.source, gr.exec(t4));
            return e4.lastIndex = t4.lastIndex, e4;
          };
          var vr = m2 ? m2.prototype : void 0, mr = vr ? vr.valueOf : void 0;
          const jr = function(t4) {
            return mr ? Object(mr.call(t4)) : {};
          };
          const wr = function(t4, e4) {
            var r4 = e4 ? _r(t4.buffer) : t4.buffer;
            return new t4.constructor(r4, t4.byteOffset, t4.length);
          };
          const xr = function(t4, e4, r4) {
            var o3 = t4.constructor;
            switch (e4) {
              case "[object ArrayBuffer]":
                return _r(t4);
              case "[object Boolean]":
              case "[object Date]":
                return new o3(+t4);
              case "[object DataView]":
                return yr(t4, r4);
              case "[object Float32Array]":
              case "[object Float64Array]":
              case "[object Int8Array]":
              case "[object Int16Array]":
              case "[object Int32Array]":
              case "[object Uint8Array]":
              case "[object Uint8ClampedArray]":
              case "[object Uint16Array]":
              case "[object Uint32Array]":
                return wr(t4, r4);
              case "[object Map]":
              case "[object Set]":
                return new o3();
              case "[object Number]":
              case "[object String]":
                return new o3(t4);
              case "[object RegExp]":
                return br(t4);
              case "[object Symbol]":
                return jr(t4);
            }
          };
          var Er = Object.create;
          const Or = function() {
            function t4() {
            }
            return function(e4) {
              if (!d2(e4))
                return {};
              if (Er)
                return Er(e4);
              t4.prototype = e4;
              var r4 = new t4();
              return t4.prototype = void 0, r4;
            };
          }();
          const Cr = function(t4) {
            return "function" != typeof t4.constructor || be2(t4) ? {} : Or($e2(t4));
          };
          const Pr = function(t4) {
            return T2(t4) && "[object Map]" == dr(t4);
          };
          var Ar = le2 && le2.isMap;
          const Wr = Ar ? ce2(Ar) : Pr;
          const Tr = function(t4) {
            return T2(t4) && "[object Set]" == dr(t4);
          };
          var Sr = le2 && le2.isSet;
          const Rr = Sr ? ce2(Sr) : Tr;
          var Ir = "[object Arguments]", Dr = "[object Function]", zr = "[object Object]", Mr = {};
          Mr[Ir] = Mr["[object Array]"] = Mr["[object ArrayBuffer]"] = Mr["[object DataView]"] = Mr["[object Boolean]"] = Mr["[object Date]"] = Mr["[object Float32Array]"] = Mr["[object Float64Array]"] = Mr["[object Int8Array]"] = Mr["[object Int16Array]"] = Mr["[object Int32Array]"] = Mr["[object Map]"] = Mr["[object Number]"] = Mr[zr] = Mr["[object RegExp]"] = Mr["[object Set]"] = Mr["[object String]"] = Mr["[object Symbol]"] = Mr["[object Uint8Array]"] = Mr["[object Uint8ClampedArray]"] = Mr["[object Uint16Array]"] = Mr["[object Uint32Array]"] = true, Mr["[object Error]"] = Mr[Dr] = Mr["[object WeakMap]"] = false;
          const Ur = function t4(e4, r4, o3, n3, i3, s3) {
            var a3, c3 = 1 & r4, u3 = 2 & r4, h3 = 4 & r4;
            if (o3 && (a3 = i3 ? o3(e4, n3, i3, s3) : o3(e4)), void 0 !== a3)
              return a3;
            if (!d2(e4))
              return e4;
            var l3 = Jt2(e4);
            if (l3) {
              if (a3 = pr(e4), !c3)
                return Me2(e4, a3);
            } else {
              var p3 = dr(e4), f3 = p3 == Dr || "[object GeneratorFunction]" == p3;
              if (re2(e4))
                return ze2(e4, c3);
              if (p3 == zr || p3 == Ir || f3 && !i3) {
                if (a3 = u3 || f3 ? {} : Cr(e4), !c3)
                  return u3 ? Ve2(e4, Te2(a3, e4)) : ke2(e4, Oe2(a3, e4));
              } else {
                if (!Mr[p3])
                  return i3 ? e4 : {};
                a3 = xr(e4, p3, c3);
              }
            }
            s3 || (s3 = new Nt2());
            var _3 = s3.get(e4);
            if (_3)
              return _3;
            s3.set(e4, a3), Rr(e4) ? e4.forEach(function(n4) {
              a3.add(t4(n4, r4, o3, n4, e4, s3));
            }) : Wr(e4) && e4.forEach(function(n4, i4) {
              a3.set(i4, t4(n4, r4, o3, i4, e4, s3));
            });
            var y3 = l3 ? void 0 : (h3 ? u3 ? Ge2 : Qe2 : u3 ? We2 : Ee2)(e4);
            return Ft2(y3 || e4, function(n4, i4) {
              y3 && (n4 = e4[i4 = n4]), Bt2(a3, i4, t4(n4, r4, o3, i4, e4, s3));
            }), a3;
          };
          const Nr = function(t4, e4) {
            return Ur(t4, 5, e4 = "function" == typeof e4 ? e4 : void 0);
          };
          var Fr = Function.prototype, qr = Object.prototype, Lr = Fr.toString, kr = qr.hasOwnProperty, Br = Lr.call(Object);
          const $r = function(t4) {
            if (!T2(t4) || "[object Object]" != W2(t4))
              return false;
            var e4 = $e2(t4);
            if (null === e4)
              return true;
            var r4 = kr.call(e4, "constructor") && e4.constructor;
            return "function" == typeof r4 && r4 instanceof r4 && Lr.call(r4) == Br;
          };
          const Hr = function(t4) {
            return T2(t4) && 1 === t4.nodeType && !$r(t4);
          };
          class Vr extends a2 {
            constructor(t4, e4 = {}) {
              super(e4), this._editor = null, this._throttledSave = q2(this._save.bind(this), "number" == typeof e4.saveInterval ? e4.saveInterval : 5e3), t4 && (this._creator = (e5, r4) => t4.create(e5, r4)), this._destructor = (t5) => t5.destroy();
            }
            get editor() {
              return this._editor;
            }
            get _item() {
              return this._editor;
            }
            setCreator(t4) {
              this._creator = t4;
            }
            setDestructor(t4) {
              this._destructor = t4;
            }
            _restart() {
              return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((t4) => {
                console.error("An error happened during the editor destroying.", t4);
              }).then(() => {
                if ("string" == typeof this._elementOrData)
                  return this.create(this._data, this._config, this._config.context);
                {
                  const t4 = Object.assign({}, this._config, { initialData: this._data });
                  return this.create(this._elementOrData, t4, t4.context);
                }
              }).then(() => {
                this._fire("restart");
              });
            }
            create(t4 = this._elementOrData, e4 = this._config, r4) {
              return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = t4, this._config = this._cloneEditorConfiguration(e4) || {}, this._config.context = r4, this._creator(t4, this._config))).then((t5) => {
                this._editor = t5, t5.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = t5.model.document.version, this._data = this._getData(), this.state = "ready", this._fire("stateChange");
              });
            }
            destroy() {
              return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
            }
            _destroy() {
              return Promise.resolve().then(() => {
                this._stopErrorHandling(), this._throttledSave.flush();
                const t4 = this._editor;
                return this._editor = null, t4.model.document.off("change:data", this._throttledSave), this._destructor(t4);
              });
            }
            _save() {
              const t4 = this._editor.model.document.version;
              try {
                this._data = this._getData(), this._lastDocumentVersion = t4;
              } catch (t5) {
                console.error(t5, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
              }
            }
            _setExcludedProperties(t4) {
              this._excludedProps = t4;
            }
            _getData() {
              const t4 = {};
              for (const e4 of this._editor.model.document.getRootNames())
                t4[e4] = this._editor.data.get({ rootName: e4 });
              return t4;
            }
            _isErrorComingFromThisItem(t4) {
              return h2(this._editor, t4.context, this._excludedProps);
            }
            _cloneEditorConfiguration(t4) {
              return Nr(t4, (t5, e4) => Hr(t5) || "context" === e4 ? t5 : void 0);
            }
          }
          const Kr = Symbol("MainQueueId");
          class Qr extends a2 {
            constructor(t4, e4 = {}) {
              super(e4), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Gr(), this._watchdogConfig = e4, this._creator = (e5) => t4.create(e5), this._destructor = (t5) => t5.destroy(), this._actionQueues.onEmpty(() => {
                "initializing" === this.state && (this.state = "ready", this._fire("stateChange"));
              });
            }
            setCreator(t4) {
              this._creator = t4;
            }
            setDestructor(t4) {
              this._destructor = t4;
            }
            get context() {
              return this._context;
            }
            create(t4 = {}) {
              return this._actionQueues.enqueue(Kr, () => (this._contextConfig = t4, this._create()));
            }
            getItem(t4) {
              return this._getWatchdog(t4)._item;
            }
            getItemState(t4) {
              return this._getWatchdog(t4).state;
            }
            add(t4) {
              const e4 = Yr(t4);
              return Promise.all(e4.map((t5) => this._actionQueues.enqueue(t5.id, () => {
                if ("destroyed" === this.state)
                  throw new Error("Cannot add items to destroyed watchdog.");
                if (!this._context)
                  throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
                let e5;
                if (this._watchdogs.has(t5.id))
                  throw new Error(`Item with the given id is already added: '${t5.id}'.`);
                if ("editor" === t5.type)
                  return e5 = new Vr(null, this._watchdogConfig), e5.setCreator(t5.creator), e5._setExcludedProperties(this._contextProps), t5.destructor && e5.setDestructor(t5.destructor), this._watchdogs.set(t5.id, e5), e5.on("error", (r4, { error: o3, causesRestart: n3 }) => {
                    this._fire("itemError", { itemId: t5.id, error: o3 }), n3 && this._actionQueues.enqueue(t5.id, () => new Promise((r5) => {
                      const o4 = () => {
                        e5.off("restart", o4), this._fire("itemRestart", { itemId: t5.id }), r5();
                      };
                      e5.on("restart", o4);
                    }));
                  }), e5.create(t5.sourceElementOrData, t5.config, this._context);
                throw new Error(`Not supported item type: '${t5.type}'.`);
              })));
            }
            remove(t4) {
              const e4 = Yr(t4);
              return Promise.all(e4.map((t5) => this._actionQueues.enqueue(t5, () => {
                const e5 = this._getWatchdog(t5);
                return this._watchdogs.delete(t5), e5.destroy();
              })));
            }
            destroy() {
              return this._actionQueues.enqueue(Kr, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
            }
            _restart() {
              return this._actionQueues.enqueue(Kr, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((t4) => {
                console.error("An error happened during destroying the context or items.", t4);
              }).then(() => this._create()).then(() => this._fire("restart"))));
            }
            _create() {
              return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((t4) => (this._context = t4, this._contextProps = c2(this._context), Promise.all(Array.from(this._watchdogs.values()).map((t5) => (t5._setExcludedProperties(this._contextProps), t5.create(void 0, void 0, this._context))))));
            }
            _destroy() {
              return Promise.resolve().then(() => {
                this._stopErrorHandling();
                const t4 = this._context;
                return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((t5) => t5.destroy())).then(() => this._destructor(t4));
              });
            }
            _getWatchdog(t4) {
              const e4 = this._watchdogs.get(t4);
              if (!e4)
                throw new Error(`Item with the given id was not registered: ${t4}.`);
              return e4;
            }
            _isErrorComingFromThisItem(t4) {
              for (const e4 of this._watchdogs.values())
                if (e4._isErrorComingFromThisItem(t4))
                  return false;
              return h2(this._context, t4.context);
            }
          }
          class Gr {
            constructor() {
              this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
            }
            onEmpty(t4) {
              this._onEmptyCallbacks.push(t4);
            }
            enqueue(t4, e4) {
              const r4 = t4 === Kr;
              this._activeActions++, this._queues.get(t4) || this._queues.set(t4, Promise.resolve());
              const o3 = (r4 ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Kr), this._queues.get(t4)])).then(e4), n3 = o3.catch(() => {
              });
              return this._queues.set(t4, n3), o3.finally(() => {
                this._activeActions--, this._queues.get(t4) === n3 && 0 === this._activeActions && this._onEmptyCallbacks.forEach((t5) => t5());
              });
            }
          }
          function Yr(t4) {
            return Array.isArray(t4) ? t4 : [t4];
          }
          const Jr = e3().createContext("contextWatchdog");
          class Xr extends e3().Component {
            constructor(t4, e4) {
              super(t4, e4), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);
            }
            shouldComponentUpdate(t4) {
              return this._shouldComponentUpdate(t4);
            }
            async _shouldComponentUpdate(t4) {
              return t4.id !== this.props.id && (this.contextWatchdog && await this.contextWatchdog.destroy(), await this._initializeContextWatchdog(t4.config)), t4.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t4.config), true) : this.props.children !== t4.children;
            }
            render() {
              return e3().createElement(Jr.Provider, { value: this.contextWatchdog }, this.props.children);
            }
            componentWillUnmount() {
              this._destroyContext();
            }
            async _initializeContextWatchdog(t4) {
              this.contextWatchdog = new Qr(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on("error", (t5, e4) => {
                this.props.onError(e4.error, { phase: "runtime", willContextRestart: e4.causesRestart });
              }), this.contextWatchdog.on("stateChange", () => {
                "ready" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);
              }), await this.contextWatchdog.create(t4).catch((t5) => {
                this.props.onError(t5, { phase: "initialization", willContextRestart: false });
              });
            }
            async _destroyContext() {
              this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);
            }
          }
          Xr.defaultProps = { isLayoutReady: true, onError: (t4, e4) => console.error(t4, e4) }, Xr.propTypes = { id: i2().string, isLayoutReady: i2().bool, context: i2().func, watchdogConfig: i2().object, config: i2().object, onReady: i2().func, onError: i2().func };
          const Zr = "Lock from React integration (@ckeditor/ckeditor5-react)";
          class to2 extends e3().Component {
            constructor(t4) {
              super(t4), this.editorDestructionInProgress = null, this.domContainer = e3().createRef(), this.watchdog = null;
              const { CKEDITOR_VERSION: r4 } = window;
              if (r4) {
                const [t5] = r4.split(".").map(Number);
                t5 < 37 && console.warn("The <CKEditor> component requires using CKEditor 5 in version 37 or higher.");
              } else
                console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
            }
            get editor() {
              return this.props.disableWatchdog ? this.instance : this.watchdog ? this.watchdog.editor : null;
            }
            shouldComponentUpdate(t4) {
              return !!this.editor && (t4.id !== this.props.id || (t4.disableWatchdog !== this.props.disableWatchdog || (this._shouldUpdateEditor(t4) && this.editor.data.set(t4.data), "disabled" in t4 && (t4.disabled ? this.editor.enableReadOnlyMode(Zr) : this.editor.disableReadOnlyMode(Zr)), false)));
            }
            async componentDidMount() {
              await this._initializeEditor();
            }
            async componentDidUpdate() {
              await this._destroyEditor(), await this._initializeEditor();
            }
            async componentWillUnmount() {
              await this._destroyEditor();
            }
            render() {
              return e3().createElement("div", { ref: this.domContainer });
            }
            async _initializeEditor() {
              await this.editorDestructionInProgress, this.props.disableWatchdog ? this.instance = await this._createEditor(this.domContainer.current, this._getConfig()) : this.watchdog || (this.context instanceof Qr ? this.watchdog = new eo2(this.context) : this.watchdog = new to2._EditorWatchdog(this.props.editor, this.props.watchdogConfig), this.watchdog.setCreator((t4, e4) => this._createEditor(t4, e4)), this.watchdog.on("error", (t4, { error: e4, causesRestart: r4 }) => {
                (this.props.onError || console.error)(e4, { phase: "runtime", willEditorRestart: r4 });
              }), await this.watchdog.create(this.domContainer.current, this._getConfig()).catch((t4) => {
                (this.props.onError || console.error)(t4, { phase: "initialization", willEditorRestart: false });
              }));
            }
            _createEditor(t4, e4) {
              return this.props.editor.create(t4, e4).then((t5) => {
                "disabled" in this.props && this.props.disabled && t5.enableReadOnlyMode(Zr);
                const e5 = t5.model.document, r4 = t5.editing.view.document;
                return e5.on("change:data", (e6) => {
                  this.props.onChange && this.props.onChange(e6, t5);
                }), r4.on("focus", (e6) => {
                  this.props.onFocus && this.props.onFocus(e6, t5);
                }), r4.on("blur", (e6) => {
                  this.props.onBlur && this.props.onBlur(e6, t5);
                }), setTimeout(() => {
                  this.props.onReady && this.props.onReady(t5);
                }), t5;
              });
            }
            async _destroyEditor() {
              this.editorDestructionInProgress = new Promise((t4) => {
                setTimeout(async () => this.watchdog ? (await this.watchdog.destroy(), this.watchdog = null, t4()) : this.instance ? (await this.instance.destroy(), this.instance = null, t4()) : void t4());
              });
            }
            _shouldUpdateEditor(t4) {
              return this.props.data !== t4.data && this.editor.data.get() !== t4.data;
            }
            _getConfig() {
              const t4 = this.props.config || {};
              return this.props.data && t4.initialData && console.warn("Editor data should be provided either using `config.initialData` or `data` properties. The config property is over the data value and the first one will be used when specified both."), { ...t4, initialData: t4.initialData || this.props.data || "" };
            }
          }
          to2.contextType = Jr, to2.propTypes = { editor: i2().func.isRequired, data: i2().string, config: i2().object, disableWatchdog: i2().bool, watchdogConfig: i2().object, onChange: i2().func, onReady: i2().func, onFocus: i2().func, onBlur: i2().func, onError: i2().func, disabled: i2().bool, id: i2().any }, to2._EditorWatchdog = Vr;
          class eo2 {
            constructor(t4) {
              this._contextWatchdog = t4, this._id = function() {
                const t5 = 4294967296 * Math.random() >>> 0, e4 = 4294967296 * Math.random() >>> 0, r4 = 4294967296 * Math.random() >>> 0, o3 = 4294967296 * Math.random() >>> 0;
                return "e" + s2[t5 >> 0 & 255] + s2[t5 >> 8 & 255] + s2[t5 >> 16 & 255] + s2[t5 >> 24 & 255] + s2[e4 >> 0 & 255] + s2[e4 >> 8 & 255] + s2[e4 >> 16 & 255] + s2[e4 >> 24 & 255] + s2[r4 >> 0 & 255] + s2[r4 >> 8 & 255] + s2[r4 >> 16 & 255] + s2[r4 >> 24 & 255] + s2[o3 >> 0 & 255] + s2[o3 >> 8 & 255] + s2[o3 >> 16 & 255] + s2[o3 >> 24 & 255];
              }();
            }
            setCreator(t4) {
              this._creator = t4;
            }
            create(t4, e4) {
              return this._contextWatchdog.add({ sourceElementOrData: t4, config: e4, creator: this._creator, id: this._id, type: "editor" });
            }
            on(t4, e4) {
              this._contextWatchdog.on("itemError", (t5, { itemId: r4, error: o3 }) => {
                r4 === this._id && e4(null, { error: o3, causesRestart: void 0 });
              });
            }
            destroy() {
              return "ready" === this._contextWatchdog.state ? this._contextWatchdog.remove(this._id) : Promise.resolve();
            }
            get editor() {
              return this._contextWatchdog.getItem(this._id);
            }
          }
        })(), n2;
      })());
    })(dist, dist.exports);
    var distExports = dist.exports;
    var module = { exports: {} };
    var exports = module.exports;
    !function(t2) {
      const e2 = t2.ru = t2.ru || {};
      e2.dictionary = Object.assign(e2.dictionary || {}, { "%0 of %1": "%0  %1", Accept: "", "Align cell text to the bottom": "     ", "Align cell text to the center": "   ", "Align cell text to the left": "    ", "Align cell text to the middle": "    ", "Align cell text to the right": "    ", "Align cell text to the top": "     ", "Align table to the left": "    ", "Align table to the right": "    ", Alignment: "", All: "", "Almost equal to": " ", Angle: "", "Approximately equal to": " ( )", Aquamarine: "", Arrows: "", "Asterisk operator": " ", "Austral sign": "  ", "back with leftwards arrow above": "    BACK ()", Background: "", Big: "", "Bitcoin sign": " ", Black: "", "Block quote": "", "Block styles": " ", Blue: "", "Blue marker": "  ", Bold: "", Border: "", "Break text": " ", "Bulleted List": " ", "Bulleted list styles toolbar": "  ", Cancel: "", "Caption for image: %0": "  : %0", "Caption for the image": "  ", "Cedi sign": "  ", "Cell properties": " ", "Cent sign": " ", "Center table": "   ", "Centered image": "  ", "Change image text alternative": "  ", "Character categories": "", "Characters: %0": ": %0", "Choose heading": " ", "Choose language": " ", Circle: "", Clear: "", "Click to edit block": ",   ", Code: " ", "Colon sign": " ", Color: "", "Color picker": " ", Column: "", "Contains as member": "  ", "Copyright sign": "  ", "Cruzeiro sign": "  ", Currency: "", "Currency sign": " ", Dashed: "", Decimal: "", "Decimal with leading zero": "   ", "Decrease indent": " ", Default: " ", "Degree sign": " ", "Delete column": " ", "Delete row": " ", "Dim grey": "-", Dimensions: "", "Disable editing": " ", Disc: "", "Division sign": " ", "Document colors": " ", "Dollar sign": " ", "Dong sign": " ", Dotted: "", Double: "", "Double dagger": " ", "Double exclamation mark": "  ", "Double low-9 quotation mark": "   ", "Double question mark": "  ", Downloadable: "", "downwards arrow to bar": " ,   ", "downwards dashed arrow": "  ", "downwards double arrow": "  ", "downwards simple arrow": "  ", "Drachma sign": " ", "Drag to move": "", "Dropdown toolbar": "  ", "Edit block": " ", "Edit link": " ", "Edit source": " ", "Editor block content toolbar": "  ", "Editor contextual toolbar": "   ", "Editor editing area: %0": "  : %0", "Editor toolbar": "  ", "Element of": "", "Em dash": " ", "Empty set": " ", "Empty snippet content": " ", "En dash": " ", "Enable editing": " ", "end with leftwards arrow above": "    END ()", "Enter image caption": "  ", "Enter table caption": " ", "Euro sign": " ", "Euro-currency sign": " ", "Exclamation question mark": "  ", Find: "", "Find and replace": "  ", "Find in text": "  ", "Font Background Color": " ", "Font Color": " ", "Font Family": " ", "Font Size": " ", "For all": " ", "Fraction slash": "  ", "French franc sign": "  ", "Full size image": "  ", "German penny sign": "  ", "Greater-than or equal to": "  ", "Greater-than sign": " ", Green: "", "Green marker": "  ", "Green pen": "  ", Grey: "", Groove: "", "Guarani sign": " ", "Header column": " ", "Header row": " ", Heading: "", "Heading 1": " 1", "Heading 2": " 2", "Heading 3": " 3", "Heading 4": " 4", "Heading 5": " 5", "Heading 6": " 6", Height: "", HEX: "HEX", Highlight: "", "Horizontal ellipsis": "", "Horizontal line": " ", "Horizontal text alignment toolbar": "    ", "Hryvnia sign": " ", "HTML object": "HTML ", "HTML snippet": "HTML ", Huge: " ", "Identical to": " ", "Image resize list": " ", "Image toolbar": "  ", "image widget": " ", "In line": " ", "Increase indent": " ", "Indian rupee sign": "  ", Infinity: "", Insert: "", "Insert code block": " ", "Insert column left": "  ", "Insert column right": "  ", "Insert HTML": " HTML", "Insert image": " ", "Insert image via URL": "   URL", "Insert media": " ", "Insert paragraph after block": "   ", "Insert paragraph before block": "   ", "Insert row above": "  ", "Insert row below": "  ", "Insert table": " ", Inset: "", Integral: "", Intersection: "", "Inverted exclamation mark": "  ", "Inverted question mark": "  ", Italic: "", "Justify cell text": "   ", "Kip sign": " ", Language: "", Latin: "", "Latin capital letter a with breve": "   A  ", "Latin capital letter a with macron": "   A  ", "Latin capital letter a with ogonek": "   A  ", "Latin capital letter c with acute": "   C  ", "Latin capital letter c with caron": "   C  ", "Latin capital letter c with circumflex": "   C  ", "Latin capital letter c with dot above": "   C   ", "Latin capital letter d with caron": "   D  ", "Latin capital letter d with stroke": "   D  ", "Latin capital letter e with breve": "   E  ", "Latin capital letter e with caron": "   E  ", "Latin capital letter e with dot above": "   E   ", "Latin capital letter e with macron": "   E  ", "Latin capital letter e with ogonek": "   E  ", "Latin capital letter eng": "   ", "Latin capital letter g with breve": "   G  ", "Latin capital letter g with cedilla": "   G  ", "Latin capital letter g with circumflex": "   G  ", "Latin capital letter g with dot above": "   G   ", "Latin capital letter h with circumflex": "   H  ", "Latin capital letter h with stroke": "   H  ", "Latin capital letter i with breve": "   I  ", "Latin capital letter i with dot above": "   I   ", "Latin capital letter i with macron": "   I  ", "Latin capital letter i with ogonek": "   I  ", "Latin capital letter i with tilde": "   I  ", "Latin capital letter j with circumflex": "   J  ", "Latin capital letter k with cedilla": "   K  ", "Latin capital letter l with acute": "   L  ", "Latin capital letter l with caron": "   L  ", "Latin capital letter l with cedilla": "   L  ", "Latin capital letter l with middle dot": "   L   ", "Latin capital letter l with stroke": "   L  ", "Latin capital letter n with acute": "   N  ", "Latin capital letter n with caron": "   N  ", "Latin capital letter n with cedilla": "   N  ", "Latin capital letter o with breve": "   O  ", "Latin capital letter o with double acute": "   O   ", "Latin capital letter o with macron": "   O  ", "Latin capital letter r with acute": "   R  ", "Latin capital letter r with caron": "   R  ", "Latin capital letter r with cedilla": "   R  ", "Latin capital letter s with acute": "   S  ", "Latin capital letter s with caron": "   S  ", "Latin capital letter s with cedilla": "   S  ", "Latin capital letter s with circumflex": "   S  ", "Latin capital letter t with caron": "   T  ", "Latin capital letter t with cedilla": "   T  ", "Latin capital letter t with stroke": "   T  ", "Latin capital letter u with breve": "   U  ", "Latin capital letter u with double acute": "   U   ", "Latin capital letter u with macron": "   U  ", "Latin capital letter u with ogonek": "   U  ", "Latin capital letter u with ring above": "   U   ", "Latin capital letter u with tilde": "   U  ", "Latin capital letter w with circumflex": "   W  ", "Latin capital letter y with circumflex": "   Y  ", "Latin capital letter y with diaeresis": "   Y  ", "Latin capital letter z with acute": "   Z  ", "Latin capital letter z with caron": "   Z  ", "Latin capital letter z with dot above": "   Z   ", "Latin capital ligature ij": "   IJ", "Latin capital ligature oe": "   OE", "Latin small letter a with breve": "   a  ", "Latin small letter a with macron": "   a  ", "Latin small letter a with ogonek": "   a  ", "Latin small letter c with acute": "   c  ", "Latin small letter c with caron": "   c  ", "Latin small letter c with circumflex": "   c  ", "Latin small letter c with dot above": "   c   ", "Latin small letter d with caron": "   d  ", "Latin small letter d with stroke": "   d  ", "Latin small letter dotless i": "   i  ", "Latin small letter e with breve": "   e  ", "Latin small letter e with caron": "   e  ", "Latin small letter e with dot above": "   e   ", "Latin small letter e with macron": "   e  ", "Latin small letter e with ogonek": "   e  ", "Latin small letter eng": "   ", "Latin small letter f with hook": "   f  ", "Latin small letter g with breve": "   g  ", "Latin small letter g with cedilla": "   g  ", "Latin small letter g with circumflex": "   g  ", "Latin small letter g with dot above": "   g   ", "Latin small letter h with circumflex": "   h  ", "Latin small letter h with stroke": "   h  ", "Latin small letter i with breve": "   i  ", "Latin small letter i with macron": "   i  ", "Latin small letter i with ogonek": "   i  ", "Latin small letter i with tilde": "   i  ", "Latin small letter j with circumflex": "   j  ", "Latin small letter k with cedilla": "   k  ", "Latin small letter kra": "   ", "Latin small letter l with acute": "   l  ", "Latin small letter l with caron": "   l  ", "Latin small letter l with cedilla": "   l  ", "Latin small letter l with middle dot": "   l   ", "Latin small letter l with stroke": "   l  ", "Latin small letter long s": "    s", "Latin small letter n preceded by apostrophe": "   n   ", "Latin small letter n with acute": "   n  ", "Latin small letter n with caron": "   n  ", "Latin small letter n with cedilla": "   n  ", "Latin small letter o with breve": "   o  ", "Latin small letter o with double acute": "   o   ", "Latin small letter o with macron": "   o  ", "Latin small letter r with acute": "   r  ", "Latin small letter r with caron": "   r  ", "Latin small letter r with cedilla": "   r  ", "Latin small letter s with acute": "   s  ", "Latin small letter s with caron": "   s  ", "Latin small letter s with cedilla": "   s  ", "Latin small letter s with circumflex": "   s  ", "Latin small letter t with caron": "   t  ", "Latin small letter t with cedilla": "   t  ", "Latin small letter t with stroke": "   t  ", "Latin small letter u with breve": "   u  ", "Latin small letter u with double acute": "   u   ", "Latin small letter u with macron": "   u  ", "Latin small letter u with ogonek": "   u  ", "Latin small letter u with ring above": "   u   ", "Latin small letter u with tilde": "   u  ", "Latin small letter w with circumflex": "   w  ", "Latin small letter y with circumflex": "   y  ", "Latin small letter z with acute": "   z  ", "Latin small letter z with caron": "   z  ", "Latin small letter z with dot above": "   z   ", "Latin small ligature ij": "   ij", "Latin small ligature oe": "   oe", "Left aligned image": "   ", "Left double quotation mark": "  ", "Left single quotation mark": "  ", "Left-pointing double angle quotation mark": "   ", "leftwards arrow to bar": " ,   ", "leftwards dashed arrow": "  ", "leftwards double arrow": "  ", "leftwards simple arrow": "  ", "Less-than or equal to": "  ", "Less-than sign": " ", "Light blue": "", "Light green": "", "Light grey": "-", Link: "", "Link image": "  ", "Link URL": " URL", "Lira sign": " ", "List properties": " ", "Livre tournois sign": "  ", "Logical and": " ", "Logical or": " ", "Lower-latin": " ", "Lowerroman": " ", Macron: "", "Manat sign": " ", "Match case": "  ", Mathematical: "", "Media toolbar": "  ", "Media URL": "URL ", "media widget": "-", "Merge cell down": "   ", "Merge cell left": "   ", "Merge cell right": "   ", "Merge cell up": "   ", "Merge cells": " ", "Mill sign": " ", "Minus sign": " ", "Multiple styles": " ", "Multiplication sign": " ", "N-ary product": "N- ", "N-ary summation": "N- ", Nabla: "", "Naira sign": " ", "Navigate editable regions": "   ", "New sheqel sign": "  ", Next: "", "Next editable region": "  ", "Next result": " ", "No preview available": " ", "No results found": "  ", "No searchable items": "   ", None: "", "Nordic mark sign": "  ", "Not an element of": " ", "Not equal to": " ", "Not sign": " ", "Numbered List": " ", "Numbered list styles toolbar": "  ", "on with exclamation mark with left right arrow above": "      ON! ()", "Open in a new tab": "   ", "Open link in new tab": "    ", "Open media in new tab": "    ", Orange: "", Original: "", Outset: "", Overline: "", Padding: "", Paragraph: "", "Paragraph sign": " ", "Partial differential": " ", "Paste raw HTML here...": " HTML  ...", "Paste the media URL in the input.": " URL    .", "Per mille sign": " ", "Per ten thousand sign": "   ", "Peseta sign": " ", "Peso sign": " ", "Pink marker": "  ", "Plain text": " ", "Plus-minus sign": " -", "Pound sign": "  ", "Press Enter to type after or press Shift + Enter to type before the widget": " Enter        Shift + Enter     ", Previous: "", "Previous editable region": "  ", "Previous result": " ", "Proportional to": "", Purple: "", "Question exclamation mark": "  ", Red: "", "Red pen": "  ", Redo: "", "Registered sign": "  ", "Remove color": " ", "Remove Format": " ", "Remove highlight": " ", "Remove language": " ", Replace: "", "Replace all": " ", "Replace with": " ...", "Resize image": "  ", "Resize image to %0": "    %0", "Resize image to the original size": "    ", "Restore default": " ", "Reversed order": " ", "Reversed paragraph sign": "  ", "Rich Text Editor": "", Ridge: "", "Right aligned image": "   ", "Right double quotation mark": "  ", "Right single quotation mark": "  ", "Right-pointing double angle quotation mark": "   ", "rightwards arrow to bar": " ,   ", "rightwards dashed arrow": "  ", "rightwards double arrow": "  ", "rightwards simple arrow": "  ", Row: "", "Ruble sign": " ", "Rupee sign": " ", Save: "", "Save changes": " ", "Saving changes": " ", "Section sign": "", "Select all": " ", "Select column": " ", "Select row": " ", "Show more items": " ", "Show options": " ", "Side image": " ", "Single left-pointing angle quotation mark": "  ()   ", "Single low-9 quotation mark": "   ", "Single right-pointing angle quotation mark": "  ()   ", Small: "", Solid: "", "soon with rightwards arrow above": "    SOON ()", Source: "HTML ", "Special characters": "", "Spesmilo sign": " ", "Split cell horizontally": "  ", "Split cell vertically": "  ", Square: "", "Square root": " ", "Start at": " ", "Start index must be greater than 0.": "     0.", Strikethrough: "", Style: "", Styles: "", Subscript: "", Superscript: "", "Table alignment toolbar": "   ", "Table cell text alignment": "    ", "Table properties": " ", "Table toolbar": "  ", "Tenge sign": " ", Text: "", "Text alternative": " ", "Text highlight toolbar": "   ", "Text styles": " ", "Text to find must not be empty.": "     .", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': ' .  "#FF0000"  "rgb(255,0,0)"  "red".', "The URL must not be empty.": "URL    .", 'The value is invalid. Try "10px" or "2em" or simply "2".': ' .  "10px"  "2em"   "2".', "There exists": "", "This link has no URL": "      URL", "This media URL is not supported.": " URL   .", "Tilde operator": " ", Tiny: " ", "Tip: Find some text first in order to replace it.": ":   ,   .", "Tip: Paste the URL into the content to embed faster.": ":  URL     .", "To-do List": " ", "Toggle caption off": " ", "Toggle caption on": " ", "Toggle the circle list style": "         ", "Toggle the decimal list style": "      ", "Toggle the decimal with leading zero list style": "            ", "Toggle the disc list style": "         ", "Toggle the lowerlatin list style": "          ", "Toggle the lowerroman list style": "          ", "Toggle the square list style": "      ", "Toggle the upperlatin list style": "          ", "Toggle the upperroman list style": "          ", "top with upwards arrow above": "    TOP ()", "Trade mark sign": "  ", "Tugrik sign": " ", "Turkish lira sign": "  ", Turquoise: "", "Two dot leader": " ", "Type or paste your content here.": "     ", "Type your title": " ", Underline: "", Undo: "", Union: "", Unlink: " ", "up down arrow with base": "      ", Update: "", "Update image URL": " URL ", "Upload failed": "  ", "Upload in progress": " ", "Upper-latin": " ", "Upper-roman": " ", "upwards arrow to bar": " ,   ", "upwards dashed arrow": "  ", "upwards double arrow": "  ", "upwards simple arrow": "  ", "Vertical text alignment toolbar": "    ", "Vulgar fraction one half": "   ", "Vulgar fraction one quarter": "   ", "Vulgar fraction three quarters": "   ", White: "", "Whole words only": "  ", "Widget toolbar": "  ", Width: "", "Won sign": " ", "Words: %0": ": %0", "Wrap text": " ", Yellow: "", "Yellow marker": "  ", "Yen sign": " " }), e2.getPluralForm = function(t3) {
        return t3 % 10 == 1 && t3 % 100 != 11 ? 0 : t3 % 10 >= 2 && t3 % 10 <= 4 && (t3 % 100 < 12 || t3 % 100 > 14) ? 1 : t3 % 10 == 0 || t3 % 10 >= 5 && t3 % 10 <= 9 || t3 % 100 >= 11 && t3 % 100 <= 14 ? 2 : 3;
      };
    }(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), /*!
     * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
     * For licensing, see LICENSE.md.
     */
    function(t2, e2) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define([], e2) : "object" == typeof exports ? exports.CKSource = e2() : t2.CKSource = e2();
    }(self, () => (() => {
      var t2 = { 8168: (t3, e3, n3) => {
        const i3 = n3(8874), o2 = {};
        for (const t4 of Object.keys(i3))
          o2[i3[t4]] = t4;
        const r2 = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
        t3.exports = r2;
        for (const t4 of Object.keys(r2)) {
          if (!("channels" in r2[t4]))
            throw new Error("missing channels property: " + t4);
          if (!("labels" in r2[t4]))
            throw new Error("missing channel labels property: " + t4);
          if (r2[t4].labels.length !== r2[t4].channels)
            throw new Error("channel and label counts mismatch: " + t4);
          const { channels: e4, labels: n4 } = r2[t4];
          delete r2[t4].channels, delete r2[t4].labels, Object.defineProperty(r2[t4], "channels", { value: e4 }), Object.defineProperty(r2[t4], "labels", { value: n4 });
        }
        r2.rgb.hsl = function(t4) {
          const e4 = t4[0] / 255, n4 = t4[1] / 255, i4 = t4[2] / 255, o3 = Math.min(e4, n4, i4), r3 = Math.max(e4, n4, i4), s2 = r3 - o3;
          let a2, c2;
          r3 === o3 ? a2 = 0 : e4 === r3 ? a2 = (n4 - i4) / s2 : n4 === r3 ? a2 = 2 + (i4 - e4) / s2 : i4 === r3 && (a2 = 4 + (e4 - n4) / s2), a2 = Math.min(60 * a2, 360), a2 < 0 && (a2 += 360);
          const l2 = (o3 + r3) / 2;
          return c2 = r3 === o3 ? 0 : l2 <= 0.5 ? s2 / (r3 + o3) : s2 / (2 - r3 - o3), [a2, 100 * c2, 100 * l2];
        }, r2.rgb.hsv = function(t4) {
          let e4, n4, i4, o3, r3;
          const s2 = t4[0] / 255, a2 = t4[1] / 255, c2 = t4[2] / 255, l2 = Math.max(s2, a2, c2), d2 = l2 - Math.min(s2, a2, c2), h2 = function(t5) {
            return (l2 - t5) / 6 / d2 + 0.5;
          };
          return 0 === d2 ? (o3 = 0, r3 = 0) : (r3 = d2 / l2, e4 = h2(s2), n4 = h2(a2), i4 = h2(c2), s2 === l2 ? o3 = i4 - n4 : a2 === l2 ? o3 = 1 / 3 + e4 - i4 : c2 === l2 && (o3 = 2 / 3 + n4 - e4), o3 < 0 ? o3 += 1 : o3 > 1 && (o3 -= 1)), [360 * o3, 100 * r3, 100 * l2];
        }, r2.rgb.hwb = function(t4) {
          const e4 = t4[0], n4 = t4[1];
          let i4 = t4[2];
          const o3 = r2.rgb.hsl(t4)[0], s2 = 1 / 255 * Math.min(e4, Math.min(n4, i4));
          return i4 = 1 - 1 / 255 * Math.max(e4, Math.max(n4, i4)), [o3, 100 * s2, 100 * i4];
        }, r2.rgb.cmyk = function(t4) {
          const e4 = t4[0] / 255, n4 = t4[1] / 255, i4 = t4[2] / 255, o3 = Math.min(1 - e4, 1 - n4, 1 - i4);
          return [100 * ((1 - e4 - o3) / (1 - o3) || 0), 100 * ((1 - n4 - o3) / (1 - o3) || 0), 100 * ((1 - i4 - o3) / (1 - o3) || 0), 100 * o3];
        }, r2.rgb.keyword = function(t4) {
          const e4 = o2[t4];
          if (e4)
            return e4;
          let n4, r3 = 1 / 0;
          for (const e5 of Object.keys(i3)) {
            const o3 = i3[e5], c2 = (a2 = o3, ((s2 = t4)[0] - a2[0]) ** 2 + (s2[1] - a2[1]) ** 2 + (s2[2] - a2[2]) ** 2);
            c2 < r3 && (r3 = c2, n4 = e5);
          }
          var s2, a2;
          return n4;
        }, r2.keyword.rgb = function(t4) {
          return i3[t4];
        }, r2.rgb.xyz = function(t4) {
          let e4 = t4[0] / 255, n4 = t4[1] / 255, i4 = t4[2] / 255;
          e4 = e4 > 0.04045 ? ((e4 + 0.055) / 1.055) ** 2.4 : e4 / 12.92, n4 = n4 > 0.04045 ? ((n4 + 0.055) / 1.055) ** 2.4 : n4 / 12.92, i4 = i4 > 0.04045 ? ((i4 + 0.055) / 1.055) ** 2.4 : i4 / 12.92;
          return [100 * (0.4124 * e4 + 0.3576 * n4 + 0.1805 * i4), 100 * (0.2126 * e4 + 0.7152 * n4 + 0.0722 * i4), 100 * (0.0193 * e4 + 0.1192 * n4 + 0.9505 * i4)];
        }, r2.rgb.lab = function(t4) {
          const e4 = r2.rgb.xyz(t4);
          let n4 = e4[0], i4 = e4[1], o3 = e4[2];
          n4 /= 95.047, i4 /= 100, o3 /= 108.883, n4 = n4 > 8856e-6 ? n4 ** (1 / 3) : 7.787 * n4 + 16 / 116, i4 = i4 > 8856e-6 ? i4 ** (1 / 3) : 7.787 * i4 + 16 / 116, o3 = o3 > 8856e-6 ? o3 ** (1 / 3) : 7.787 * o3 + 16 / 116;
          return [116 * i4 - 16, 500 * (n4 - i4), 200 * (i4 - o3)];
        }, r2.hsl.rgb = function(t4) {
          const e4 = t4[0] / 360, n4 = t4[1] / 100, i4 = t4[2] / 100;
          let o3, r3, s2;
          if (0 === n4)
            return s2 = 255 * i4, [s2, s2, s2];
          o3 = i4 < 0.5 ? i4 * (1 + n4) : i4 + n4 - i4 * n4;
          const a2 = 2 * i4 - o3, c2 = [0, 0, 0];
          for (let t5 = 0; t5 < 3; t5++)
            r3 = e4 + 1 / 3 * -(t5 - 1), r3 < 0 && r3++, r3 > 1 && r3--, s2 = 6 * r3 < 1 ? a2 + 6 * (o3 - a2) * r3 : 2 * r3 < 1 ? o3 : 3 * r3 < 2 ? a2 + (o3 - a2) * (2 / 3 - r3) * 6 : a2, c2[t5] = 255 * s2;
          return c2;
        }, r2.hsl.hsv = function(t4) {
          const e4 = t4[0];
          let n4 = t4[1] / 100, i4 = t4[2] / 100, o3 = n4;
          const r3 = Math.max(i4, 0.01);
          i4 *= 2, n4 *= i4 <= 1 ? i4 : 2 - i4, o3 *= r3 <= 1 ? r3 : 2 - r3;
          return [e4, 100 * (0 === i4 ? 2 * o3 / (r3 + o3) : 2 * n4 / (i4 + n4)), 100 * ((i4 + n4) / 2)];
        }, r2.hsv.rgb = function(t4) {
          const e4 = t4[0] / 60, n4 = t4[1] / 100;
          let i4 = t4[2] / 100;
          const o3 = Math.floor(e4) % 6, r3 = e4 - Math.floor(e4), s2 = 255 * i4 * (1 - n4), a2 = 255 * i4 * (1 - n4 * r3), c2 = 255 * i4 * (1 - n4 * (1 - r3));
          switch (i4 *= 255, o3) {
            case 0:
              return [i4, c2, s2];
            case 1:
              return [a2, i4, s2];
            case 2:
              return [s2, i4, c2];
            case 3:
              return [s2, a2, i4];
            case 4:
              return [c2, s2, i4];
            case 5:
              return [i4, s2, a2];
          }
        }, r2.hsv.hsl = function(t4) {
          const e4 = t4[0], n4 = t4[1] / 100, i4 = t4[2] / 100, o3 = Math.max(i4, 0.01);
          let r3, s2;
          s2 = (2 - n4) * i4;
          const a2 = (2 - n4) * o3;
          return r3 = n4 * o3, r3 /= a2 <= 1 ? a2 : 2 - a2, r3 = r3 || 0, s2 /= 2, [e4, 100 * r3, 100 * s2];
        }, r2.hwb.rgb = function(t4) {
          const e4 = t4[0] / 360;
          let n4 = t4[1] / 100, i4 = t4[2] / 100;
          const o3 = n4 + i4;
          let r3;
          o3 > 1 && (n4 /= o3, i4 /= o3);
          const s2 = Math.floor(6 * e4), a2 = 1 - i4;
          r3 = 6 * e4 - s2, 0 != (1 & s2) && (r3 = 1 - r3);
          const c2 = n4 + r3 * (a2 - n4);
          let l2, d2, h2;
          switch (s2) {
            default:
            case 6:
            case 0:
              l2 = a2, d2 = c2, h2 = n4;
              break;
            case 1:
              l2 = c2, d2 = a2, h2 = n4;
              break;
            case 2:
              l2 = n4, d2 = a2, h2 = c2;
              break;
            case 3:
              l2 = n4, d2 = c2, h2 = a2;
              break;
            case 4:
              l2 = c2, d2 = n4, h2 = a2;
              break;
            case 5:
              l2 = a2, d2 = n4, h2 = c2;
          }
          return [255 * l2, 255 * d2, 255 * h2];
        }, r2.cmyk.rgb = function(t4) {
          const e4 = t4[0] / 100, n4 = t4[1] / 100, i4 = t4[2] / 100, o3 = t4[3] / 100;
          return [255 * (1 - Math.min(1, e4 * (1 - o3) + o3)), 255 * (1 - Math.min(1, n4 * (1 - o3) + o3)), 255 * (1 - Math.min(1, i4 * (1 - o3) + o3))];
        }, r2.xyz.rgb = function(t4) {
          const e4 = t4[0] / 100, n4 = t4[1] / 100, i4 = t4[2] / 100;
          let o3, r3, s2;
          return o3 = 3.2406 * e4 + -1.5372 * n4 + -0.4986 * i4, r3 = -0.9689 * e4 + 1.8758 * n4 + 0.0415 * i4, s2 = 0.0557 * e4 + -0.204 * n4 + 1.057 * i4, o3 = o3 > 31308e-7 ? 1.055 * o3 ** (1 / 2.4) - 0.055 : 12.92 * o3, r3 = r3 > 31308e-7 ? 1.055 * r3 ** (1 / 2.4) - 0.055 : 12.92 * r3, s2 = s2 > 31308e-7 ? 1.055 * s2 ** (1 / 2.4) - 0.055 : 12.92 * s2, o3 = Math.min(Math.max(0, o3), 1), r3 = Math.min(Math.max(0, r3), 1), s2 = Math.min(Math.max(0, s2), 1), [255 * o3, 255 * r3, 255 * s2];
        }, r2.xyz.lab = function(t4) {
          let e4 = t4[0], n4 = t4[1], i4 = t4[2];
          e4 /= 95.047, n4 /= 100, i4 /= 108.883, e4 = e4 > 8856e-6 ? e4 ** (1 / 3) : 7.787 * e4 + 16 / 116, n4 = n4 > 8856e-6 ? n4 ** (1 / 3) : 7.787 * n4 + 16 / 116, i4 = i4 > 8856e-6 ? i4 ** (1 / 3) : 7.787 * i4 + 16 / 116;
          return [116 * n4 - 16, 500 * (e4 - n4), 200 * (n4 - i4)];
        }, r2.lab.xyz = function(t4) {
          let e4, n4, i4;
          n4 = (t4[0] + 16) / 116, e4 = t4[1] / 500 + n4, i4 = n4 - t4[2] / 200;
          const o3 = n4 ** 3, r3 = e4 ** 3, s2 = i4 ** 3;
          return n4 = o3 > 8856e-6 ? o3 : (n4 - 16 / 116) / 7.787, e4 = r3 > 8856e-6 ? r3 : (e4 - 16 / 116) / 7.787, i4 = s2 > 8856e-6 ? s2 : (i4 - 16 / 116) / 7.787, e4 *= 95.047, n4 *= 100, i4 *= 108.883, [e4, n4, i4];
        }, r2.lab.lch = function(t4) {
          const e4 = t4[0], n4 = t4[1], i4 = t4[2];
          let o3;
          o3 = 360 * Math.atan2(i4, n4) / 2 / Math.PI, o3 < 0 && (o3 += 360);
          return [e4, Math.sqrt(n4 * n4 + i4 * i4), o3];
        }, r2.lch.lab = function(t4) {
          const e4 = t4[0], n4 = t4[1], i4 = t4[2] / 360 * 2 * Math.PI;
          return [e4, n4 * Math.cos(i4), n4 * Math.sin(i4)];
        }, r2.rgb.ansi16 = function(t4, e4 = null) {
          const [n4, i4, o3] = t4;
          let s2 = null === e4 ? r2.rgb.hsv(t4)[2] : e4;
          if (s2 = Math.round(s2 / 50), 0 === s2)
            return 30;
          let a2 = 30 + (Math.round(o3 / 255) << 2 | Math.round(i4 / 255) << 1 | Math.round(n4 / 255));
          return 2 === s2 && (a2 += 60), a2;
        }, r2.hsv.ansi16 = function(t4) {
          return r2.rgb.ansi16(r2.hsv.rgb(t4), t4[2]);
        }, r2.rgb.ansi256 = function(t4) {
          const e4 = t4[0], n4 = t4[1], i4 = t4[2];
          if (e4 === n4 && n4 === i4)
            return e4 < 8 ? 16 : e4 > 248 ? 231 : Math.round((e4 - 8) / 247 * 24) + 232;
          return 16 + 36 * Math.round(e4 / 255 * 5) + 6 * Math.round(n4 / 255 * 5) + Math.round(i4 / 255 * 5);
        }, r2.ansi16.rgb = function(t4) {
          let e4 = t4 % 10;
          if (0 === e4 || 7 === e4)
            return t4 > 50 && (e4 += 3.5), e4 = e4 / 10.5 * 255, [e4, e4, e4];
          const n4 = 0.5 * (1 + ~~(t4 > 50));
          return [(1 & e4) * n4 * 255, (e4 >> 1 & 1) * n4 * 255, (e4 >> 2 & 1) * n4 * 255];
        }, r2.ansi256.rgb = function(t4) {
          if (t4 >= 232) {
            const e5 = 10 * (t4 - 232) + 8;
            return [e5, e5, e5];
          }
          let e4;
          t4 -= 16;
          return [Math.floor(t4 / 36) / 5 * 255, Math.floor((e4 = t4 % 36) / 6) / 5 * 255, e4 % 6 / 5 * 255];
        }, r2.rgb.hex = function(t4) {
          const e4 = (((255 & Math.round(t4[0])) << 16) + ((255 & Math.round(t4[1])) << 8) + (255 & Math.round(t4[2]))).toString(16).toUpperCase();
          return "000000".substring(e4.length) + e4;
        }, r2.hex.rgb = function(t4) {
          const e4 = t4.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
          if (!e4)
            return [0, 0, 0];
          let n4 = e4[0];
          3 === e4[0].length && (n4 = n4.split("").map((t5) => t5 + t5).join(""));
          const i4 = parseInt(n4, 16);
          return [i4 >> 16 & 255, i4 >> 8 & 255, 255 & i4];
        }, r2.rgb.hcg = function(t4) {
          const e4 = t4[0] / 255, n4 = t4[1] / 255, i4 = t4[2] / 255, o3 = Math.max(Math.max(e4, n4), i4), r3 = Math.min(Math.min(e4, n4), i4), s2 = o3 - r3;
          let a2, c2;
          return a2 = s2 < 1 ? r3 / (1 - s2) : 0, c2 = s2 <= 0 ? 0 : o3 === e4 ? (n4 - i4) / s2 % 6 : o3 === n4 ? 2 + (i4 - e4) / s2 : 4 + (e4 - n4) / s2, c2 /= 6, c2 %= 1, [360 * c2, 100 * s2, 100 * a2];
        }, r2.hsl.hcg = function(t4) {
          const e4 = t4[1] / 100, n4 = t4[2] / 100, i4 = n4 < 0.5 ? 2 * e4 * n4 : 2 * e4 * (1 - n4);
          let o3 = 0;
          return i4 < 1 && (o3 = (n4 - 0.5 * i4) / (1 - i4)), [t4[0], 100 * i4, 100 * o3];
        }, r2.hsv.hcg = function(t4) {
          const e4 = t4[1] / 100, n4 = t4[2] / 100, i4 = e4 * n4;
          let o3 = 0;
          return i4 < 1 && (o3 = (n4 - i4) / (1 - i4)), [t4[0], 100 * i4, 100 * o3];
        }, r2.hcg.rgb = function(t4) {
          const e4 = t4[0] / 360, n4 = t4[1] / 100, i4 = t4[2] / 100;
          if (0 === n4)
            return [255 * i4, 255 * i4, 255 * i4];
          const o3 = [0, 0, 0], r3 = e4 % 1 * 6, s2 = r3 % 1, a2 = 1 - s2;
          let c2 = 0;
          switch (Math.floor(r3)) {
            case 0:
              o3[0] = 1, o3[1] = s2, o3[2] = 0;
              break;
            case 1:
              o3[0] = a2, o3[1] = 1, o3[2] = 0;
              break;
            case 2:
              o3[0] = 0, o3[1] = 1, o3[2] = s2;
              break;
            case 3:
              o3[0] = 0, o3[1] = a2, o3[2] = 1;
              break;
            case 4:
              o3[0] = s2, o3[1] = 0, o3[2] = 1;
              break;
            default:
              o3[0] = 1, o3[1] = 0, o3[2] = a2;
          }
          return c2 = (1 - n4) * i4, [255 * (n4 * o3[0] + c2), 255 * (n4 * o3[1] + c2), 255 * (n4 * o3[2] + c2)];
        }, r2.hcg.hsv = function(t4) {
          const e4 = t4[1] / 100, n4 = e4 + t4[2] / 100 * (1 - e4);
          let i4 = 0;
          return n4 > 0 && (i4 = e4 / n4), [t4[0], 100 * i4, 100 * n4];
        }, r2.hcg.hsl = function(t4) {
          const e4 = t4[1] / 100, n4 = t4[2] / 100 * (1 - e4) + 0.5 * e4;
          let i4 = 0;
          return n4 > 0 && n4 < 0.5 ? i4 = e4 / (2 * n4) : n4 >= 0.5 && n4 < 1 && (i4 = e4 / (2 * (1 - n4))), [t4[0], 100 * i4, 100 * n4];
        }, r2.hcg.hwb = function(t4) {
          const e4 = t4[1] / 100, n4 = e4 + t4[2] / 100 * (1 - e4);
          return [t4[0], 100 * (n4 - e4), 100 * (1 - n4)];
        }, r2.hwb.hcg = function(t4) {
          const e4 = t4[1] / 100, n4 = 1 - t4[2] / 100, i4 = n4 - e4;
          let o3 = 0;
          return i4 < 1 && (o3 = (n4 - i4) / (1 - i4)), [t4[0], 100 * i4, 100 * o3];
        }, r2.apple.rgb = function(t4) {
          return [t4[0] / 65535 * 255, t4[1] / 65535 * 255, t4[2] / 65535 * 255];
        }, r2.rgb.apple = function(t4) {
          return [t4[0] / 255 * 65535, t4[1] / 255 * 65535, t4[2] / 255 * 65535];
        }, r2.gray.rgb = function(t4) {
          return [t4[0] / 100 * 255, t4[0] / 100 * 255, t4[0] / 100 * 255];
        }, r2.gray.hsl = function(t4) {
          return [0, 0, t4[0]];
        }, r2.gray.hsv = r2.gray.hsl, r2.gray.hwb = function(t4) {
          return [0, 100, t4[0]];
        }, r2.gray.cmyk = function(t4) {
          return [0, 0, 0, t4[0]];
        }, r2.gray.lab = function(t4) {
          return [t4[0], 0, 0];
        }, r2.gray.hex = function(t4) {
          const e4 = 255 & Math.round(t4[0] / 100 * 255), n4 = ((e4 << 16) + (e4 << 8) + e4).toString(16).toUpperCase();
          return "000000".substring(n4.length) + n4;
        }, r2.rgb.gray = function(t4) {
          return [(t4[0] + t4[1] + t4[2]) / 3 / 255 * 100];
        };
      }, 2085: (t3, e3, n3) => {
        const i3 = n3(8168), o2 = n3(4111), r2 = {};
        Object.keys(i3).forEach((t4) => {
          r2[t4] = {}, Object.defineProperty(r2[t4], "channels", { value: i3[t4].channels }), Object.defineProperty(r2[t4], "labels", { value: i3[t4].labels });
          const e4 = o2(t4);
          Object.keys(e4).forEach((n4) => {
            const i4 = e4[n4];
            r2[t4][n4] = function(t5) {
              const e5 = function(...e6) {
                const n5 = e6[0];
                if (null == n5)
                  return n5;
                n5.length > 1 && (e6 = n5);
                const i5 = t5(e6);
                if ("object" == typeof i5)
                  for (let t6 = i5.length, e7 = 0; e7 < t6; e7++)
                    i5[e7] = Math.round(i5[e7]);
                return i5;
              };
              return "conversion" in t5 && (e5.conversion = t5.conversion), e5;
            }(i4), r2[t4][n4].raw = function(t5) {
              const e5 = function(...e6) {
                const n5 = e6[0];
                return null == n5 ? n5 : (n5.length > 1 && (e6 = n5), t5(e6));
              };
              return "conversion" in t5 && (e5.conversion = t5.conversion), e5;
            }(i4);
          });
        }), t3.exports = r2;
      }, 4111: (t3, e3, n3) => {
        const i3 = n3(8168);
        function o2(t4) {
          const e4 = function() {
            const t5 = {}, e5 = Object.keys(i3);
            for (let n5 = e5.length, i4 = 0; i4 < n5; i4++)
              t5[e5[i4]] = { distance: -1, parent: null };
            return t5;
          }(), n4 = [t4];
          for (e4[t4].distance = 0; n4.length; ) {
            const t5 = n4.pop(), o3 = Object.keys(i3[t5]);
            for (let i4 = o3.length, r3 = 0; r3 < i4; r3++) {
              const i5 = o3[r3], s3 = e4[i5];
              -1 === s3.distance && (s3.distance = e4[t5].distance + 1, s3.parent = t5, n4.unshift(i5));
            }
          }
          return e4;
        }
        function r2(t4, e4) {
          return function(n4) {
            return e4(t4(n4));
          };
        }
        function s2(t4, e4) {
          const n4 = [e4[t4].parent, t4];
          let o3 = i3[e4[t4].parent][t4], s3 = e4[t4].parent;
          for (; e4[s3].parent; )
            n4.unshift(e4[s3].parent), o3 = r2(i3[e4[s3].parent][s3], o3), s3 = e4[s3].parent;
          return o3.conversion = n4, o3;
        }
        t3.exports = function(t4) {
          const e4 = o2(t4), n4 = {}, i4 = Object.keys(e4);
          for (let t5 = i4.length, o3 = 0; o3 < t5; o3++) {
            const t6 = i4[o3];
            null !== e4[t6].parent && (n4[t6] = s2(t6, e4));
          }
          return n4;
        };
      }, 8874: (t3) => {
        t3.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
      }, 5363: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-basic-styles/theme/code.css"], names: [], mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n	background-color: hsla(0, 0%, 78%, 0.3);\n	padding: .15em;\n	border-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n	background-color: hsla(0, 0%, 78%, 0.5);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3789: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-block-quote/theme/blockquote.css"], names: [], mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n	/* See #12 */\n	overflow: hidden;\n\n	/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n	padding-right: 1.5em;\n	padding-left: 1.5em;\n\n	margin-left: 0;\n	margin-right: 0;\n	font-style: italic;\n	border-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n	border-left: 0;\n	border-right: solid 5px hsl(0, 0%, 80%);\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 799: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}.ck.ck-clipboard-drop-target-line:before{border-style:solid;content:"";height:0;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-width)*-.5);width:0}[dir=ltr] .ck.ck-clipboard-drop-target-line:before{border-color:transparent transparent transparent var(--ck-clipboard-drop-target-color);border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height);left:-1px}[dir=rtl] .ck.ck-clipboard-drop-target-line:before{border-color:transparent var(--ck-clipboard-drop-target-color) transparent transparent;border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0;right:-1px}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-clipboard/theme/clipboard.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"], names: [], mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CC9BA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eAwBD,CAtBC,yCAMC,kBAAmB,CALnB,UAAW,CAIX,QAAS,CAHT,iBAAkB,CAClB,uDAA0D,CAC1D,OAiBD,CArBA,mDAYE,sFAAuF,CADvF,+JAAoK,CAFpK,SAYF,CArBA,mDAmBE,sFAAuF,CADvF,+JAAmK,CAFnK,UAKF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	/*\n	 * Vertical drop target (in text).\n	 */\n	& .ck.ck-clipboard-drop-target-position {\n		display: inline;\n		position: relative;\n		pointer-events: none;\n\n		& span {\n			position: absolute;\n			width: 0;\n		}\n	}\n\n	/*\n	 * Styles of the widget being dragged (its preview).\n	 */\n	& .ck-widget:-webkit-drag {\n		& > .ck-widget__selection-handle {\n			display: none;\n		}\n\n		& > .ck-widget__type-around {\n			display: none;\n		}\n	}\n}\n\n.ck.ck-clipboard-drop-target-line {\n	position: absolute;\n	pointer-events: none;\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-clipboard-drop-target-dot-width: 12px;
	--ck-clipboard-drop-target-dot-height: 8px;
	--ck-clipboard-drop-target-color: var(--ck-color-focus-border);
}

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		& span {
			bottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			border: 1px solid var(--ck-clipboard-drop-target-color);
			background: var(--ck-clipboard-drop-target-color);
			margin-left: -1px;

			/* The triangle above the marker */
			&::after {
				content: '';
				width: 0;
				height: 0;

				display: block;
				position: absolute;
				left: 50%;
				top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));

				transform: translateX(-50%);
				border-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;
				border-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));
				border-style: solid;
			}
		}
	}

	/*
	 * Styles of the widget that it a drop target.
	 */
	& .ck-widget.ck-clipboard-drop-target-range {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		zoom: 0.6;
		outline: none !important;
	}
}

.ck.ck-clipboard-drop-target-line {
	height: 0;
	border: 1px solid var(--ck-clipboard-drop-target-color);
	background: var(--ck-clipboard-drop-target-color);
	margin-top: -1px;

	&::before {
		content: '';
		position: absolute;
		top: calc(-.5 * var(--ck-clipboard-drop-target-dot-width));
		width: 0;
		height: 0;
		border-style: solid;

		@mixin ck-dir ltr {
			left: -1px;

			border-width: calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height);
			border-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);
		}

		@mixin ck-dir rtl {
			right: -1px;

			border-width:calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0;
			border-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;
		}
	}
}
`], sourceRoot: "" }]);
        const a2 = s2;
      }, 3229: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content pre{background:hsla(0,0%,78%,.3);border:1px solid #c4c4c4;border-radius:2px;color:#353535;direction:ltr;font-style:normal;min-width:200px;padding:1em;tab-size:4;text-align:left;white-space:pre-wrap}.ck-content pre code{background:unset;border-radius:0;padding:0}.ck.ck-editor__editable pre{position:relative}.ck.ck-editor__editable pre[data-language]:after{content:attr(data-language);position:absolute}:root{--ck-color-code-block-label-background:#757575}.ck.ck-editor__editable pre[data-language]:after{background:var(--ck-color-code-block-label-background);color:#fff;font-family:var(--ck-font-face);font-size:10px;line-height:16px;padding:var(--ck-spacing-tiny) var(--ck-spacing-medium);right:10px;top:-1px;white-space:nowrap}.ck.ck-code-block-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-code-block/theme/codeblock.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-code-block/codeblock.css"], names: [], mappings: "AAKA,gBAGC,4BAAiC,CACjC,wBAAiC,CACjC,iBAAkB,CAHlB,aAAwB,CAOxB,aAAc,CAMd,iBAAkB,CAGlB,eAAgB,CAjBhB,WAAY,CAUZ,UAAW,CAHX,eAAgB,CAIhB,oBAaD,CALC,qBACC,gBAAiB,CAEjB,eAAgB,CADhB,SAED,CAGD,4BACC,iBAMD,CAJC,iDACC,2BAA4B,CAC5B,iBACD,CCjCD,MACC,8CACD,CAEA,iDAGC,sDAAuD,CAMvD,UAAuB,CAHvB,+BAAgC,CADhC,cAAe,CAEf,gBAAiB,CACjB,uDAAwD,CANxD,UAAW,CADX,QAAS,CAST,kBACD,CAEA,+CAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content pre {\n	padding: 1em;\n	color: hsl(0, 0%, 20.8%);\n	background: hsla(0, 0%, 78%, 0.3);\n	border: 1px solid hsl(0, 0%, 77%);\n	border-radius: 2px;\n\n	/* Code block are language directionagnostic. */\n	text-align: left;\n	direction: ltr;\n\n	tab-size: 4;\n	white-space: pre-wrap;\n\n	/* Don't inherit the style, e.g. when in a block quote. */\n	font-style: normal;\n\n	/* Don't let the code be squashed e.g. when in a table cell. */\n	min-width: 200px;\n\n	& code {\n		background: unset;\n		padding: 0;\n		border-radius: 0;\n	}\n}\n\n.ck.ck-editor__editable pre {\n	position: relative;\n\n	&[data-language]::after {\n		content: attr(data-language);\n		position: absolute;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-code-block-label-background: hsl(0, 0%, 46%);\n}\n\n.ck.ck-editor__editable pre[data-language]::after {\n	top: -1px;\n	right: 10px;\n	background: var(--ck-color-code-block-label-background);\n\n	font-size: 10px;\n	font-family: var(--ck-font-face);\n	line-height: 16px;\n	padding: var(--ck-spacing-tiny) var(--ck-spacing-medium);\n	color: hsl(0, 0%, 100%);\n	white-space: nowrap;\n}\n\n.ck.ck-code-block-dropdown .ck-dropdown__panel {\n	/* There could be dozens of languages available. Use scroll to prevent a 10e6px dropdown. */\n	max-height: 250px;\n	overflow-y: auto;\n	overflow-x: hidden;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3624: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n	/* All the elements within `.ck-editor` are positioned relatively to it.\n	 If any element needs to be positioned with respect to the <body>, etc.,\n	 it must land outside of the `.ck-editor` in DOM. */\n	position: relative;\n\n	& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n		/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n		z-index: var(--ck-z-modal);\n	}\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

.ck.ck-editor__top {
	& .ck-sticky-panel {
		& .ck-toolbar {
			@mixin ck-rounded-corners {
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}

			border-bottom-width: 0;
		}

		& .ck-sticky-panel__content_sticky .ck-toolbar {
			border-bottom-width: 1px;

			@mixin ck-rounded-corners {
				border-radius: 0;
			}
		}
	}
}

/* Note: Use ck-editor__main to make sure these styles don't apply to other editor types */
.ck.ck-editor__main > .ck-editor__editable {
	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */
	background: var(--ck-color-base-background);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not(.ck-focused) {
		border-color: var(--ck-color-base-border);
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7372: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"], names: [], mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n	position: relative;\n\n	&::before {\n		position: absolute;\n		left: 0;\n		right: 0;\n		content: attr(data-placeholder);\n\n		/* See ckeditor/ckeditor5#469. */\n		pointer-events: none;\n	}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n	&::before {\n		display: none;\n	}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n	position: relative;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n	&::before {\n		cursor: text;\n		color: var(--ck-color-engine-placeholder-text);\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 5037: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-engine/theme/renderer.css"], names: [], mappings: "AAMA,qDACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n	display: none;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2218: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-find-result{background:var(--ck-color-highlight-background);color:var(--ck-color-text)}.ck-find-result_selected{background:#ff9633}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplace.css"], names: [], mappings: "AAKA,gBACC,+CAAgD,CAChD,0BACD,CAEA,yBACC,kBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-find-result {\n	background: var(--ck-color-highlight-background);\n	color: var(--ck-color-text);\n}\n\n.ck-find-result_selected {\n	background: hsl(29, 100%, 60%);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3403: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-find-and-replace-form{max-width:100%}.ck.ck-find-and-replace-form fieldset{display:flex}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{position:absolute}.ck.ck-find-and-replace-form{width:400px}.ck.ck-find-and-replace-form:focus{outline:none}.ck.ck-find-and-replace-form fieldset{align-content:stretch;align-items:center;border:0;flex-direction:row;flex-wrap:nowrap;margin:0;padding:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset>.ck-button{flex:0 0 auto}[dir=ltr] .ck.ck-find-and-replace-form fieldset>*+*{margin-left:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form fieldset>*+*{margin-right:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view{flex:1 1 auto}.ck.ck-find-and-replace-form fieldset .ck-labeled-field-view .ck-input{min-width:50px;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find{align-items:flex-start}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find{font-weight:700}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-find .ck-button__label{padding-left:var(--ck-spacing-large);padding-right:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-prev>.ck-icon{transform:rotate(90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button-next>.ck-icon{transform:rotate(-90deg)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{left:var(--ck-spacing-standard)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-results-counter{color:var(--ck-color-base-border)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace{flex-wrap:wrap;justify-content:flex-end;margin-top:calc(var(--ck-spacing-large)*-1)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view{margin-bottom:var(--ck-spacing-large)}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-options-dropdown{margin-left:0;margin-right:auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view,.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-labeled-field-view .ck-input{width:100%}@media screen and (max-width:600px){.ck.ck-find-and-replace-form{width:300px}.ck.ck-find-and-replace-form fieldset{flex-wrap:wrap}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find .ck-labeled-field-view{flex:1 0 auto;margin-bottom:var(--ck-spacing-standard);width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button{text-align:center}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{flex:1 1 auto}[dir=ltr] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{margin-left:0}[dir=rtl] .ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type{margin-right:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__find>.ck-button:first-of-type .ck-button__label{text-align:center;width:100%}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>:not(.ck-labeled-field-view){flex:1 1 auto}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-dropdown:not(.ck-labeled-field-view){flex-grow:0}.ck.ck-find-and-replace-form fieldset.ck-find-and-replace-form__replace>.ck-button:not(.ck-labeled-field-view)>.ck-button__label{text-align:center;width:100%}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-find-and-replace/theme/findandreplaceform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-find-and-replace/findandreplaceform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAKA,6BACC,cAUD,CARC,sCACC,YAMD,CAHC,yFACC,iBACD,CCNF,6BACC,WAyGD,CAnGC,mCACC,YACD,CAEA,sCAIC,qBAAsB,CADtB,kBAAmB,CAInB,QAAS,CANT,kBAAmB,CACnB,gBAAiB,CAMjB,QAAS,CAFT,+BAwFD,CApFC,iDACC,aACD,CAGC,oDACC,sCACD,CAIA,oDACC,uCACD,CAGD,6DACC,aAMD,CAJC,uEAEC,cAAe,CADf,UAED,CAID,qEAEC,sBAkCD,CAhCC,qFACC,eAOD,CAJC,uGACC,oCAAqC,CACrC,qCACD,CAGD,8FACC,uBACD,CAEA,8FACC,wBACD,CAEA,yFACC,OAAQ,CACR,0BAWD,CAbA,mGAKE,gCAQF,CAbA,mGASE,+BAIF,CAbA,yFAYC,iCACD,CAID,wEACC,cAAe,CACf,wBAAyB,CACzB,2CAeD,CAbC,+FACC,qCACD,CAEA,6FAEC,aAAc,CADd,iBAED,CAEA,wMAEC,UACD,CCzGF,oCD+GA,6BACC,WAiDD,CA/CC,sCACC,cA6CD,CAzCE,4FACC,aAAc,CAEd,wCAAyC,CADzC,UAED,CAEA,gFACC,iBAkBD,CAhBC,8FACC,aAcD,CAfA,wGAIE,aAWF,CAfA,wGAQE,cAOF,CAJC,gHAEC,iBAAkB,CADlB,UAED,CAMH,qGACC,aAUD,CARC,iHACC,WACD,CAEA,iIAEC,iBAAkB,CADlB,UAED,CC5JH", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-find-and-replace-form {\n	max-width: 100%;\n\n	& fieldset {\n		display: flex;\n\n		/* The find fieldset */\n		&.ck-find-and-replace-form__find .ck-results-counter {\n			position: absolute;\n		}\n	}\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-find-and-replace-form {
	width: 400px;

	/*
	 * The <form> needs tabindex="-1" for proper Esc handling after being clicked
	 * but the side effect is that this creates a nasty focus outline in some browsers.
	 */
	&:focus {
		outline: none;
	}

	& fieldset {
		flex-direction: row;
		flex-wrap: nowrap;
		align-items: center;
		align-content: stretch;

		padding: var(--ck-spacing-large);
		border: 0;
		margin: 0;

		& > .ck-button {
			flex: 0 0 auto;
		}

		@mixin ck-dir ltr {
			& > * + * {
				margin-left: var(--ck-spacing-standard);
			}
		}

		@mixin ck-dir rtl {
			& > * + * {
				margin-right: var(--ck-spacing-standard);
			}
		}

		& .ck-labeled-field-view {
			flex: 1 1 auto;

			& .ck-input {
				width: 100%;
				min-width: 50px;
			}
		}

		/* The find fieldset */
		&.ck-find-and-replace-form__find {
			/* To display all controls in line when there's an error under the input */
			align-items: flex-start;

			& > .ck-button-find {
				font-weight: bold;

				/* Beef the find button up a little. It's the main action button in the form */
				& .ck-button__label {
					padding-left: var(--ck-spacing-large);
					padding-right: var(--ck-spacing-large);
				}
			}

			& > .ck-button-prev > .ck-icon {
				transform: rotate(90deg);
			}

			& > .ck-button-next > .ck-icon {
				transform: rotate(-90deg);
			}

			& .ck-results-counter {
				top: 50%;
				transform: translateY(-50%);

				@mixin ck-dir ltr {
					right: var(--ck-spacing-standard);
				}

				@mixin ck-dir rtl {
					left: var(--ck-spacing-standard);
				}

				color: var(--ck-color-base-border);
			}
		}

		/* The replace fieldset */
		&.ck-find-and-replace-form__replace {
			flex-wrap: wrap;
			justify-content: flex-end;
			margin-top: calc( -1 * var(--ck-spacing-large) );

			& > .ck-labeled-field-view {
				margin-bottom: var(--ck-spacing-large);
			}

			& > .ck-options-dropdown {
				margin-right: auto;
				margin-left: 0;
			}

			& > .ck-labeled-field-view,
			& > .ck-labeled-field-view .ck-input {
				width: 100%;
			}
		}
	}
}

@mixin ck-media-phone {
	.ck.ck-find-and-replace-form {
		width: 300px;

		& fieldset {
			flex-wrap: wrap;

			/* The find fieldset */
			&.ck-find-and-replace-form__find {
				& .ck-labeled-field-view {
					flex: 1 0 auto;
					width: 100%;
					margin-bottom: var(--ck-spacing-standard);
				}

				& > .ck-button {
					text-align: center;

					&:first-of-type {
						flex: 1 1 auto;

						@mixin ck-dir ltr {
							margin-left: 0;
						}

						@mixin ck-dir rtl {
							margin-right: 0;
						}

						& .ck-button__label {
							width: 100%;
							text-align: center;
						}
					}
				}
			}

			/* The replace fieldset */
			&.ck-find-and-replace-form__replace > :not(.ck-labeled-field-view) {
				flex: 1 1 auto;

				&.ck-dropdown {
					flex-grow: 0;
				}

				&.ck-button > .ck-button__label {
					width: 100%;
					text-align: center;
				}
			}
		}
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 5991: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content .text-tiny{font-size:.7em}.ck-content .text-small{font-size:.85em}.ck-content .text-big{font-size:1.4em}.ck-content .text-huge{font-size:1.8em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css"], names: [], mappings: "AAUC,uBACC,cACD,CAEA,wBACC,eACD,CAEA,sBACC,eACD,CAEA,uBACC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* The values should be synchronized with the "FONT_SIZE_PRESET_UNITS" object in the "/src/fontsize/utils.js" file. */\n\n/* Styles should be prefixed with the `.ck-content` class.\nSee https://github.com/ckeditor/ckeditor5/issues/6636 */\n.ck-content {\n	& .text-tiny {\n		font-size: .7em;\n	}\n\n	& .text-small {\n		font-size: .85em;\n	}\n\n	& .text-big {\n		font-size: 1.4em;\n	}\n\n	& .text-huge {\n		font-size: 1.8em;\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 4249: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"], names: [], mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n	font-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n	font-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n	font-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n	font-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n	& .ck-dropdown__button .ck-button__label {\n		width: 8em;\n	}\n\n	& .ck-dropdown__panel .ck-list__item {\n		min-width: 18em;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7263: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-highlight-marker-yellow:#fdfd77;--ck-highlight-marker-green:#62f962;--ck-highlight-marker-pink:#fc7899;--ck-highlight-marker-blue:#72ccfd;--ck-highlight-pen-red:#e71313;--ck-highlight-pen-green:#128a00}.ck-content .marker-yellow{background-color:var(--ck-highlight-marker-yellow)}.ck-content .marker-green{background-color:var(--ck-highlight-marker-green)}.ck-content .marker-pink{background-color:var(--ck-highlight-marker-pink)}.ck-content .marker-blue{background-color:var(--ck-highlight-marker-blue)}.ck-content .pen-red{background-color:transparent;color:var(--ck-highlight-pen-red)}.ck-content .pen-green{background-color:transparent;color:var(--ck-highlight-pen-green)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-highlight/theme/highlight.css"], names: [], mappings: "AAKA,MACC,oCAA+C,CAC/C,mCAA+C,CAC/C,kCAA8C,CAC9C,kCAA8C,CAC9C,8BAAwC,CACxC,gCACD,CAGC,2BACC,kDACD,CAFA,0BACC,iDACD,CAFA,yBACC,gDACD,CAFA,yBACC,gDACD,CAIA,qBAIC,4BAA6B,CAH7B,iCAID,CALA,uBAIC,4BAA6B,CAH7B,mCAID", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-highlight-marker-yellow: hsl(60, 97%, 73%);\n	--ck-highlight-marker-green: hsl(120, 93%, 68%);\n	--ck-highlight-marker-pink: hsl(345, 96%, 73%);\n	--ck-highlight-marker-blue: hsl(201, 97%, 72%);\n	--ck-highlight-pen-red: hsl(0, 85%, 49%);\n	--ck-highlight-pen-green: hsl(112, 100%, 27%);\n}\n\n@define-mixin highlight-marker-color $color {\n	.ck-content .marker-$color {\n		background-color: var(--ck-highlight-marker-$color);\n	}\n}\n\n@define-mixin highlight-pen-color $color {\n	.ck-content .pen-$color {\n		color: var(--ck-highlight-pen-$color);\n\n		/* Override default yellow background of `<mark>` from user agent stylesheet */\n		background-color: transparent;\n	}\n}\n\n@mixin highlight-marker-color yellow;\n@mixin highlight-marker-color green;\n@mixin highlight-marker-color pink;\n@mixin highlight-marker-color blue;\n\n@mixin highlight-pen-color red;\n@mixin highlight-pen-color green;\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 9893: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-editor__editable .ck-horizontal-line{display:flow-root}.ck-content hr{background:#dedede;border:0;height:4px;margin:15px 0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-horizontal-line/theme/horizontalline.css"], names: [], mappings: "AAMA,yCAEC,iBACD,CAEA,eAGC,kBAA2B,CAC3B,QAAS,CAFT,UAAW,CADX,aAID", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n\n.ck-editor__editable .ck-horizontal-line {\n	/* Necessary to render properly next to floated objects, e.g. side image case. */\n	display: flow-root;\n}\n\n.ck-content hr {\n	margin: 15px 0;\n	height: 4px;\n	background: hsl(0, 0%, 87%);\n	border: 0;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7319: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-widget.raw-html-embed{display:flow-root;font-style:normal;margin:.9em auto;min-width:15em;position:relative}.ck-widget.raw-html-embed:before{position:absolute;z-index:1}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper{display:flex;flex-direction:column;position:absolute}.ck-widget.raw-html-embed .raw-html-embed__preview{display:flex;overflow:hidden;position:relative}.ck-widget.raw-html-embed .raw-html-embed__preview-content{border-collapse:separate;border-spacing:7px;display:table;margin:auto;position:relative;width:100%}.ck-widget.raw-html-embed .raw-html-embed__preview-placeholder{align-items:center;bottom:0;display:flex;justify-content:center;left:0;position:absolute;right:0;top:0}:root{--ck-html-embed-content-width:calc(100% - var(--ck-icon-size)*1.5);--ck-html-embed-source-height:10em;--ck-html-embed-unfocused-outline-width:1px;--ck-html-embed-content-min-height:calc(var(--ck-icon-size) + var(--ck-spacing-standard));--ck-html-embed-source-disabled-background:var(--ck-color-base-foreground);--ck-html-embed-source-disabled-color:#737373}.ck-widget.raw-html-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base)}.ck-widget.raw-html-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.raw-html-embed[dir=ltr]{text-align:left}.ck-widget.raw-html-embed[dir=rtl]{text-align:right}.ck-widget.raw-html-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);top:calc(var(--ck-html-embed-unfocused-outline-width)*-1);transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.raw-html-embed[dir=rtl]:before{left:auto;right:var(--ck-spacing-standard)}.ck-widget.raw-html-embed[dir=ltr] .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck.ck-editor__editable.ck-blurred .ck-widget.raw-html-embed.ck-widget_selected:before{padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck.ck-editor__editable:not(.ck-blurred) .ck-widget.raw-html-embed.ck-widget_selected:before{background:var(--ck-color-focus-border);padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck.ck-editor__editable .ck-widget.raw-html-embed:not(.ck-widget_selected):hover:before{padding:var(--ck-spacing-tiny) var(--ck-spacing-small);top:0}.ck-widget.raw-html-embed .raw-html-embed__content-wrapper{padding:var(--ck-spacing-standard)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper{right:var(--ck-spacing-standard);top:var(--ck-spacing-standard)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button.raw-html-embed__save-button{color:var(--ck-color-button-save)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button.raw-html-embed__cancel-button{color:var(--ck-color-button-cancel)}.ck-widget.raw-html-embed .raw-html-embed__buttons-wrapper .ck-button:not(:first-child){margin-top:var(--ck-spacing-small)}.ck-widget.raw-html-embed[dir=rtl] .raw-html-embed__buttons-wrapper{left:var(--ck-spacing-standard);right:auto}.ck-widget.raw-html-embed .raw-html-embed__source{box-sizing:border-box;direction:ltr;font-family:monospace;font-size:var(--ck-font-size-base);height:var(--ck-html-embed-source-height);min-width:0;padding:var(--ck-spacing-standard);resize:none;tab-size:4;text-align:left;white-space:pre-wrap;width:var(--ck-html-embed-content-width)}.ck-widget.raw-html-embed .raw-html-embed__source[disabled]{-webkit-text-fill-color:var(--ck-html-embed-source-disabled-color);background:var(--ck-html-embed-source-disabled-background);color:var(--ck-html-embed-source-disabled-color);opacity:1}.ck-widget.raw-html-embed .raw-html-embed__preview{min-height:var(--ck-html-embed-content-min-height);width:var(--ck-html-embed-content-width)}.ck-editor__editable:not(.ck-read-only) .ck-widget.raw-html-embed .raw-html-embed__preview{pointer-events:none}.ck-widget.raw-html-embed .raw-html-embed__preview-content{background-color:var(--ck-color-base-foreground);box-sizing:border-box}.ck-widget.raw-html-embed .raw-html-embed__preview-content>*{margin-left:auto;margin-right:auto}.ck-widget.raw-html-embed .raw-html-embed__preview-placeholder{color:var(--ck-html-embed-source-disabled-color)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-html-embed/theme/htmlembed.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-html-embed/htmlembed.css"], names: [], mappings: "AAMA,0BAMC,iBAAkB,CAOlB,iBAAkB,CATlB,gBAAkB,CAMlB,cAAe,CALf,iBAwDD,CA5CC,iCACC,iBAAkB,CAGlB,SACD,CAKA,2DAEC,YAAa,CACb,qBAAsB,CAFtB,iBAGD,CAEA,mDAGC,YAAa,CADb,eAAgB,CADhB,iBAGD,CAEA,2DAOC,wBAAyB,CACzB,kBAAmB,CAFnB,aAAc,CAHd,WAAY,CADZ,iBAAkB,CADlB,UAQD,CAEA,+DAQC,kBAAmB,CAHnB,QAAS,CAET,YAAa,CAEb,sBAAuB,CAPvB,MAAO,CADP,iBAAkB,CAGlB,OAAQ,CADR,KAOD,CC7DD,MACC,kEAAqE,CACrE,kCAAmC,CACnC,2CAA4C,CAC5C,yFAA0F,CAE1F,0EAA2E,CAC3E,6CACD,CAGA,0BAEC,gDAAiD,CADjD,kCA0ID,CAvIC,+DACC,iGACD,CAGA,mCACC,eACD,CAEA,mCACC,gBACD,CAIA,iCAIC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,mCAAoC,CASpC,+BAAgC,CADhC,kCAAmC,CANnC,+BAAgC,CAGhC,kIAAmI,CAJnI,yDAA4D,CAG5D,0GAMD,CAEA,0CACC,SAAU,CACV,gCACD,CAGA,iIACC,gBACD,CAxCD,uFA4CE,sDAAuD,CADvD,KAgGF,CA3IA,6FAkDE,uCAAwC,CADxC,sDAAuD,CADvD,KA2FF,CA3IA,wFAuDE,sDAAuD,CADvD,KAqFF,CA/EC,2DACC,kCACD,CAGA,2DAEC,gCAAiC,CADjC,8BAcD,CAXC,kGACC,iCACD,CAEA,oGACC,mCACD,CAEA,wFACC,kCACD,CAGD,oEACC,+BAAgC,CAChC,UACD,CAGA,kDACC,qBAAsB,CActB,aAAc,CAPd,qBAAsB,CAGtB,kCAAmC,CATnC,yCAA0C,CAG1C,WAAY,CACZ,kCAAmC,CAFnC,WAAY,CAKZ,UAAW,CAKX,eAAgB,CAJhB,oBAAqB,CAPrB,wCAsBD,CARC,4DAKC,kEAAmE,CAJnE,0DAA2D,CAC3D,gDAAiD,CAIjD,SACD,CAID,mDACC,kDAAmD,CACnD,wCAMD,CARA,2FAME,mBAEF,CAEA,2DAEC,gDAAiD,CADjD,qBAOD,CAJC,6DACC,gBAAiB,CACjB,iBACD,CAGD,+DACC,gDACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* The feature container. */
.ck-widget.raw-html-embed {
	/* Give the embed some air. */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	position: relative;
	display: flow-root;

	/* Give the html embed some minimal width in the content to prevent them
	from being "squashed" in tight spaces, e.g. in table cells (https://github.com/ckeditor/ckeditor5/issues/8331) */
	min-width: 15em;

	/* Don't inherit the style, e.g. when in a block quote. */
	font-style: normal;

	/* ----- Emebed label in the upper left corner ----------------------------------------------- */

	&::before {
		position: absolute;

		/* Make sure the content does not cover the label. */
		z-index: 1;
	}

	/* ----- Emebed internals --------------------------------------------------------------------- */

	/* The switch mode button wrapper. */
	& .raw-html-embed__buttons-wrapper {
		position: absolute;
		display: flex;
		flex-direction: column;
	}

	& .raw-html-embed__preview {
		position: relative;
		overflow: hidden;
		display: flex;
	}

	& .raw-html-embed__preview-content {
		width: 100%;
		position: relative;
		margin: auto;

		/* Gives spacing to the small renderable elements, so they always cover the placeholder. */
		display: table;
		border-collapse: separate;
		border-spacing: 7px;
	}

	& .raw-html-embed__preview-placeholder {
		position: absolute;
		left: 0;
		top: 0;
		right: 0;
		bottom: 0;

		display: flex;
		align-items: center;
		justify-content: center;
	}
}
`, '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-html-embed-content-width: calc(100% - 1.5 * var(--ck-icon-size));\n	--ck-html-embed-source-height: 10em;\n	--ck-html-embed-unfocused-outline-width: 1px;\n	--ck-html-embed-content-min-height: calc(var(--ck-icon-size) + var(--ck-spacing-standard));\n\n	--ck-html-embed-source-disabled-background: var(--ck-color-base-foreground);\n	--ck-html-embed-source-disabled-color: hsl(0deg 0% 45%);\n}\n\n/* The feature container. */\n.ck-widget.raw-html-embed {\n	font-size: var(--ck-font-size-base);\n	background-color: var(--ck-color-base-foreground);\n\n	&:not(.ck-widget_selected):not(:hover) {\n		outline: var(--ck-html-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);\n	}\n\n	/* HTML embed widget itself should respect UI language direction */\n	&[dir="ltr"] {\n		text-align: left;\n	}\n\n	&[dir="rtl"] {\n		text-align: right;\n	}\n\n	/* ----- Embed label in the upper left corner ----------------------------------------------- */\n\n	&::before {\n		content: attr(data-html-embed-label);\n		top: calc(-1 * var(--ck-html-embed-unfocused-outline-width));\n		left: var(--ck-spacing-standard);\n		background: hsl(0deg 0% 60%);\n		transition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n		padding: calc(var(--ck-spacing-tiny) + var(--ck-html-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);\n		border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n		color: var(--ck-color-base-background);\n		font-size: var(--ck-font-size-tiny);\n		font-family: var(--ck-font-face);\n	}\n\n	&[dir="rtl"]::before {\n		left: auto;\n		right: var(--ck-spacing-standard);\n	}\n\n	/* Make space for label but it only collides in LTR languages */\n	&[dir="ltr"] .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {\n		margin-left: 50px;\n	}\n\n	@nest .ck.ck-editor__editable.ck-blurred &.ck-widget_selected::before {\n		top: 0px;\n		padding: var(--ck-spacing-tiny) var(--ck-spacing-small);\n	}\n\n	@nest .ck.ck-editor__editable:not(.ck-blurred) &.ck-widget_selected::before {\n		top: 0;\n		padding: var(--ck-spacing-tiny) var(--ck-spacing-small);\n		background: var(--ck-color-focus-border);\n	}\n\n	@nest .ck.ck-editor__editable &:not(.ck-widget_selected):hover::before {\n		top: 0px;\n		padding: var(--ck-spacing-tiny) var(--ck-spacing-small);\n	}\n\n	/* ----- Emebed internals --------------------------------------------------------------------- */\n\n	& .raw-html-embed__content-wrapper {\n		padding: var(--ck-spacing-standard);\n	}\n\n	/* The switch mode button wrapper. */\n	& .raw-html-embed__buttons-wrapper {\n		top: var(--ck-spacing-standard);\n		right: var(--ck-spacing-standard);\n\n		& .ck-button.raw-html-embed__save-button {\n			color: var(--ck-color-button-save);\n		}\n\n		& .ck-button.raw-html-embed__cancel-button {\n			color: var(--ck-color-button-cancel);\n		}\n\n		& .ck-button:not(:first-child) {\n			margin-top: var(--ck-spacing-small);\n		}\n	}\n\n	&[dir="rtl"] .raw-html-embed__buttons-wrapper {\n		left: var(--ck-spacing-standard);\n		right: auto;\n	}\n\n	/* The edit source element. */\n	& .raw-html-embed__source {\n		box-sizing: border-box;\n		height: var(--ck-html-embed-source-height);\n		width: var(--ck-html-embed-content-width);\n		resize: none;\n		min-width: 0;\n		padding: var(--ck-spacing-standard);\n\n		font-family: monospace;\n		tab-size: 4;\n		white-space: pre-wrap;\n		font-size: var(--ck-font-size-base); /* Safari needs this. */\n\n		/* HTML code is directionagnostic. */\n		text-align: left;\n		direction: ltr;\n\n		&[disabled] {\n			background: var(--ck-html-embed-source-disabled-background);\n			color: var(--ck-html-embed-source-disabled-color);\n\n			/* Safari needs this for the proper text color in disabled input (https://github.com/ckeditor/ckeditor5/issues/8320). */\n			-webkit-text-fill-color: var(--ck-html-embed-source-disabled-color);\n			opacity: 1;\n		}\n	}\n\n	/* The preview data container. */\n	& .raw-html-embed__preview {\n		min-height: var(--ck-html-embed-content-min-height);\n		width: var(--ck-html-embed-content-width);\n\n		/* Disable all mouse interaction as long as the editor is not readonly. */\n		@nest .ck-editor__editable:not(.ck-read-only) & {\n			pointer-events: none;\n		}\n	}\n\n	& .raw-html-embed__preview-content {\n		box-sizing: border-box;\n		background-color: var(--ck-color-base-foreground);\n\n		& > * {\n			margin-left: auto;\n			margin-right: auto;\n		}\n	}\n\n	& .raw-html-embed__preview-placeholder {\n		color: var(--ck-html-embed-source-disabled-color)\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 1710: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-html-object-embed-unfocused-outline-width:1px}.ck-widget.html-object-embed{background-color:var(--ck-color-base-foreground);font-size:var(--ck-font-size-base);min-width:calc(76px + var(--ck-spacing-standard));padding:var(--ck-spacing-small);padding-top:calc(var(--ck-font-size-tiny) + var(--ck-spacing-large))}.ck-widget.html-object-embed:not(.ck-widget_selected):not(:hover){outline:var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border)}.ck-widget.html-object-embed:before{background:#999;border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius);color:var(--ck-color-base-background);content:attr(data-html-object-embed-label);font-family:var(--ck-font-face);font-size:var(--ck-font-size-tiny);font-style:normal;font-weight:400;left:var(--ck-spacing-standard);padding:calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);position:absolute;top:0;transition:background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck-widget.html-object-embed .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before{margin-left:50px}.ck-widget.html-object-embed .html-object-embed__content{pointer-events:none}div.ck-widget.html-object-embed{margin:1em auto}span.ck-widget.html-object-embed{display:inline-block}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-html-support/theme/datafilter.css"], names: [], mappings: "AAKA,MACC,kDACD,CAEA,6BAEC,gDAAiD,CADjD,kCAAmC,CAKnC,iDAAkD,CAHlD,+BAAgC,CAEhC,oEAgCD,CA7BC,kEACC,wGACD,CAEA,oCAOC,eAA4B,CAG5B,iEAAkE,CAClE,qCAAsC,CAPtC,0CAA2C,CAS3C,+BAAgC,CADhC,kCAAmC,CAVnC,iBAAkB,CADlB,eAAmB,CAKnB,+BAAgC,CAGhC,yIAA0I,CAN1I,iBAAkB,CAElB,KAAM,CAGN,0GAMD,CAGA,2HACC,gBACD,CAEA,yDAEC,mBACD,CAGD,gCACC,eACD,CAEA,iCACC,oBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-html-object-embed-unfocused-outline-width: 1px;\n}\n\n.ck-widget.html-object-embed {\n	font-size: var(--ck-font-size-base);\n	background-color: var(--ck-color-base-foreground);\n	padding: var(--ck-spacing-small);\n	/* Leave space for label */\n	padding-top: calc(var(--ck-font-size-tiny) + var(--ck-spacing-large));\n	min-width: calc(76px + var(--ck-spacing-standard));\n\n	&:not(.ck-widget_selected):not(:hover) {\n		outline: var(--ck-html-object-embed-unfocused-outline-width) dashed var(--ck-color-widget-blurred-border);\n	}\n\n	&::before {\n		font-weight: normal;\n		font-style: normal;\n		position: absolute;\n		content: attr(data-html-object-embed-label);\n		top: 0;\n		left: var(--ck-spacing-standard);\n		background: hsl(0deg 0% 60%);\n		transition: background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n		padding: calc(var(--ck-spacing-tiny) + var(--ck-html-object-embed-unfocused-outline-width)) var(--ck-spacing-small) var(--ck-spacing-tiny);\n		border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n		color: var(--ck-color-base-background);\n		font-size: var(--ck-font-size-tiny);\n		font-family: var(--ck-font-face);\n	}\n\n	/* Make space for label. */\n	& .ck-widget__type-around .ck-widget__type-around__button.ck-widget__type-around__button_before {\n		margin-left: 50px;\n	}\n\n	& .html-object-embed__content {\n		/* Disable user interaction with embed content */\n		pointer-events: none;\n	}\n}\n\ndiv.ck-widget.html-object-embed {\n	margin: 1em auto;\n}\n\nspan.ck-widget.html-object-embed {\n	display: inline-block;\n}\n\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2430: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;height:auto;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image{z-index:1}.ck.ck-editor__editable .image.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable .image-inline img{height:auto}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/image.css"], names: [], mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBA2BD,CAjBC,uBAEC,aAAc,CAad,WAAY,CAVZ,aAAc,CAGd,cAAe,CAGf,cAKD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAKA,+BACC,SASD,CAHC,kDACC,SACD,CAMD,sCACC,SAkBD,CAZC,yDACC,SAUD,CAHC,qEACC,YACD,CAMF,0CACC,WACD,CAMC,0FACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n	& .image {\n		display: table;\n		clear: both;\n		text-align: center;\n\n		/* Make sure there is some space between the content and the image. Center image by default. */\n		/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n	 	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n		margin: 0.9em auto;\n\n		/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n		min-width: 50px;\n\n		& img {\n			/* Prevent unnecessary margins caused by line-height (see #44). */\n			display: block;\n\n			/* Center the image if its width is smaller than the content\'s width. */\n			margin: 0 auto;\n\n			/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n			max-width: 100%;\n\n			/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n			min-width: 100%;\n\n			/* Keep proportions of the block image if the height is set and the image is wider than the editor width.\n			See https://github.com/ckeditor/ckeditor5/issues/14542. */\n			height: auto;\n		}\n	}\n\n	& .image-inline {\n		/*\n		 * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n		 * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n		 * This strange behavior does not happen with inline-flex.\n		 */\n		display: inline-flex;\n\n		/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n		max-width: 100%;\n\n		/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n		align-items: flex-start;\n\n		/* When the picture is present it must act as a flex container to let the img resize properly */\n		& picture {\n			display: flex;\n		}\n\n		/* When the picture is present, it must act like a resizable img. */\n		& picture,\n		& img {\n			/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n			flex-grow: 1;\n			flex-shrink: 1;\n\n			/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n			max-width: 100%;\n		}\n	}\n}\n\n.ck.ck-editor__editable {\n	/*\n	 * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n	 * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n	 * caret does, and not at the edge of <figcaption>.\n	 */\n	& .image > figcaption.ck-placeholder::before {\n		padding-left: inherit;\n		padding-right: inherit;\n\n		/*\n		 * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9162.\n		 */\n		white-space: nowrap;\n		overflow: hidden;\n		text-overflow: ellipsis;\n	}\n\n	/*\n	 * See https://github.com/ckeditor/ckeditor5/issues/15115.\n	 */\n	& .image {\n		z-index: 1;\n\n		/*\n		 * Make sure the selected image always stays on top of its siblings.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9108.\n		 */\n		&.ck-widget_selected {\n			z-index: 2;\n		}\n	}\n\n	/*\n	 * See https://github.com/ckeditor/ckeditor5/issues/15115.\n	 */\n	& .image-inline {\n		z-index: 1;\n\n		/*\n		 * Make sure the selected inline image always stays on top of its siblings.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9108.\n		 */\n		&.ck-widget_selected {\n			z-index: 2;\n\n			/*\n			 * Make sure the native browser selection style is not displayed.\n			 * Inline image widgets have their own styles for the selected state and\n			 * leaving this up to the browser is asking for a visual collision.\n			 */\n			& ::selection {\n				display: none;\n			}\n		}\n	}\n\n	/* Keep proportions of the inline image if the height is set and the image is wider than the editor width.\n	See https://github.com/ckeditor/ckeditor5/issues/14542. */\n	& .image-inline img {\n		height: auto;\n	}\n\n	/* The inline image nested in the table should have its original size if not resized.\n	See https://github.com/ckeditor/ckeditor5/issues/9117. */\n	& td,\n	& th {\n		& .image-inline img {\n			max-width: none;\n		}\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 2423: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-image-caption-background: hsl(0, 0%, 97%);\n	--ck-color-image-caption-text: hsl(0, 0%, 20%);\n	--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n	display: table-caption;\n	caption-side: bottom;\n	word-break: break-word;\n	color: var(--ck-color-image-caption-text);\n	background-color: var(--ck-color-image-caption-background);\n	padding: .6em;\n	font-size: .75em;\n	outline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n	animation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n	0% {\n		background-color: var(--ck-color-image-caption-highligted-background);\n	}\n\n	100% {\n		background-color: var(--ck-color-image-caption-background);\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 8879: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsert.css"], names: [], mappings: "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert__panel {\n	padding: var(--ck-spacing-large);\n}\n\n.ck.ck-image-insert__ck-finder-button {\n	display: block;\n	width: 100%;\n	margin: var(--ck-spacing-standard) auto;\n	border: 1px solid hsl(0, 0%, 80%);\n	border-radius: var(--ck-border-radius);\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\n	padding: 0;\n	margin: 0;\n	border: none;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 8340: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageinsertformrowview.css"], names: [], mappings: "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert-form {\n	&:focus {\n		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n		outline: none;\n	}\n}\n\n.ck.ck-form__row {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	justify-content: space-between;\n\n	/* Ignore labels that work as fieldset legends */\n	& > *:not(.ck-label) {\n		flex-grow: 1;\n	}\n\n	&.ck-image-insert-form__action-row {\n		margin-top: var(--ck-spacing-standard);\n\n		& .ck-button-save,\n		& .ck-button-cancel {\n			justify-content: center;\n		}\n\n		& .ck-button .ck-button__label {\n			color: var(--ck-color-text);\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 31: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-editor__editable img.image_placeholder{background-size:100% 100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageplaceholder.css"], names: [], mappings: "AAMC,8CACC,yBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	& img.image_placeholder {\n		background-size: 100% 100%;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2400: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content img.image_resized{height:auto}.ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageresize.css"], names: [], mappings: "AAMA,8BACC,WACD,CAEA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Preserve aspect ratio of the resized image after introducing image height attribute. */\n.ck-content img.image_resized {\n	height: auto;\n}\n\n.ck-content .image.image_resized {\n	max-width: 100%;\n	/*\n	The `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n	See https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n	Fortunately, since we control the width, there is no risk that the image will look bad.\n	*/\n	display: block;\n	box-sizing: border-box;\n\n	& img {\n		/* For resized images it is the `<figure>` element that determines the image width. */\n		width: 100%;\n	}\n\n	& > figcaption {\n		/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n		display: block;\n	}\n}\n\n.ck.ck-editor__editable {\n	/* The resized inline image nested in the table should respect its parent size.\n	See https://github.com/ckeditor/ckeditor5/issues/9117. */\n	& td,\n	& th {\n		& .image-inline.image_resized img {\n			max-width: 100%;\n		}\n	}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n	margin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n	margin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n	width: 4em;\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 3534: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css"], names: [], mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-image-style-spacing: 1.5em;\n	--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n	/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n	confirming successful application of the style if image width exceeds the editor's size.\n	See https://github.com/ckeditor/ckeditor5/issues/9342 */\n	& .image-style-block-align-left,\n	& .image-style-block-align-right {\n		max-width: calc(100% - var(--ck-image-style-spacing));\n	}\n\n	/* Allows displaying multiple floating images in the same line.\n	See https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n	& .image-style-align-left,\n	& .image-style-align-right {\n		clear: none;\n	}\n\n	& .image-style-side {\n		float: right;\n		margin-left: var(--ck-image-style-spacing);\n		max-width: 50%;\n	}\n\n	& .image-style-align-left {\n		float: left;\n		margin-right: var(--ck-image-style-spacing);\n	}\n\n	& .image-style-align-center {\n		margin-left: auto;\n		margin-right: auto;\n	}\n\n	& .image-style-align-right {\n		float: right;\n		margin-left: var(--ck-image-style-spacing);\n	}\n\n	& .image-style-block-align-right {\n		margin-right: 0;\n		margin-left: auto;\n	}\n\n	& .image-style-block-align-left {\n		margin-left: 0;\n		margin-right: auto;\n	}\n\n	/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n	& p + .image-style-align-left,\n	& p + .image-style-align-right,\n	& p + .image-style-side {\n		margin-top: 0;\n	}\n\n	& .image-inline {\n		&.image-style-align-left,\n		&.image-style-align-right {\n			margin-top: var(--ck-inline-image-style-spacing);\n			margin-bottom: var(--ck-inline-image-style-spacing);\n		}\n\n		&.image-style-align-left {\n			margin-right: var(--ck-inline-image-style-spacing);\n		}\n\n		&.image-style-align-right {\n			margin-left: var(--ck-inline-image-style-spacing);\n		}\n	}\n}\n\n.ck.ck-splitbutton {\n	/* The button should display as a regular drop-down if the action button\n	is forced to fire the same action as the arrow button. */\n	&.ck-splitbutton_flatten {\n		&:hover,\n		&.ck-splitbutton_open {\n			& > .ck-splitbutton__action:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n				background-color: var(--ck-color-button-on-background);\n\n				&::after {\n					display: none;\n				}\n			}\n		}\n\n		&.ck-splitbutton_open:hover {\n			& > .ck-splitbutton__action:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n				background-color: var(--ck-color-button-on-hover-background);\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 1547: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"], names: [], mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n	display: block;\n	position: absolute;\n\n	/*\n	 * Smaller images should have the icon closer to the border.\n	 * Match the icon position with the linked image indicator brought by the link image feature.\n	 */\n	top: min(var(--ck-spacing-medium), 6%);\n	right: min(var(--ck-spacing-medium), 6%);\n	border-radius: 50%;\n	z-index: 1;\n\n	&::after {\n		content: "";\n		position: absolute;\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n	--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n	/* Match the icon size with the linked image indicator brought by the link image feature. */\n	--ck-image-upload-icon-size: 20;\n	--ck-image-upload-icon-width: 2px;\n	--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n	opacity: 0;\n	background: var(--ck-color-image-upload-icon-background);\n	animation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n	animation-fill-mode: forwards, forwards;\n	animation-duration: 500ms, 500ms;\n\n	/* To make animation scalable. */\n	font-size: calc(1px * var(--ck-image-upload-icon-size));\n\n	/* Hide completed upload icon after 3 seconds. */\n	animation-delay: 0ms, 3000ms;\n\n	/*\n	 * Use CSS math to simulate container queries.\n	 * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n	 */\n	overflow: hidden;\n	width: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n	height: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n	/* This is check icon element made from border-width mixed with animations. */\n	&::after {\n		/* Because of border transformation we need to "hard code" left position. */\n		left: 25%;\n\n		top: 50%;\n		opacity: 0;\n		height: 0;\n		width: 0;\n\n		transform: scaleX(-1) rotate(135deg);\n		transform-origin: left top;\n		border-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n		border-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n		animation-name: ck-upload-complete-icon-check;\n		animation-duration: 500ms;\n		animation-delay: 500ms;\n		animation-fill-mode: forwards;\n\n		/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n		box-sizing: border-box;\n	}\n}\n\n@keyframes ck-upload-complete-icon-show {\n	from {\n		opacity: 0;\n	}\n\n	to {\n		opacity: 1;\n	}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n	from {\n		opacity: 1;\n	}\n\n	to {\n		opacity: 0;\n	}\n}\n\n@keyframes ck-upload-complete-icon-check {\n	0% {\n		opacity: 1;\n		width: 0;\n		height: 0;\n	}\n	33% {\n		width: 0.3em;\n		height: 0;\n	}\n	100% {\n		opacity: 1;\n		width: 0.3em;\n		height: 0.45em;\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 6618: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"], names: [], mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n	position: absolute;\n	display: flex;\n	align-items: center;\n	justify-content: center;\n	top: 0;\n	left: 0;\n\n	&::before {\n		content: '';\n		position: relative;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n	--ck-upload-placeholder-loader-size: 32px;\n	--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n	/* We need to control the full width of the SVG gray background. */\n	width: 100%;\n	margin: 0;\n\n	&.image-inline {\n		width: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n	}\n\n	& img {\n		/*\n		 * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n		 * There's nothing special about this number except that it should make the image placeholder look like\n		 * a real image during this short period after the upload started and before the image was read from the\n		 * file system (and a rich preview was loaded).\n		 */\n		aspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n	}\n}\n\n.ck .ck-upload-placeholder-loader {\n	width: 100%;\n	height: 100%;\n\n	&::before {\n		width: var(--ck-upload-placeholder-loader-size);\n		height: var(--ck-upload-placeholder-loader-size);\n		border-radius: 50%;\n		border-top: 3px solid var(--ck-color-upload-placeholder-loader);\n		border-right: 2px solid transparent;\n		animation: ck-upload-placeholder-loader 1s linear infinite;\n	}\n}\n\n@keyframes ck-upload-placeholder-loader {\n	to {\n		transform: rotate( 360deg );\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2926: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"], names: [], mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	& .image,\n	& .image-inline {\n		position: relative;\n	}\n\n	/* Upload progress bar. */\n	& .image .ck-progress-bar,\n	& .image-inline .ck-progress-bar {\n		position: absolute;\n		top: 0;\n		left: 0;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	& .image,\n	& .image-inline {\n		/* Showing animation. */\n		&.ck-appear {\n			animation: fadeIn 700ms;\n		}\n	}\n\n	/* Upload progress bar. */\n	& .image .ck-progress-bar,\n	& .image-inline .ck-progress-bar {\n		height: 2px;\n		width: 0;\n		background: var(--ck-color-upload-bar-background);\n		transition: width 100ms;\n	}\n}\n\n@keyframes fadeIn {\n	from { opacity: 0; }\n	to   { opacity: 1; }\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 5269: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-labeled-field-view {\n		display: inline-block;\n	}\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3925: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/link.css"], names: [], mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n	background: var(--ck-color-link-selected-background);\n\n	/* Give linked inline images some outline to let the user know they are also part of the link. */\n	& span.image-inline {\n		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n	}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n	background: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n	height: 100%;\n	border-right: 1px solid var(--ck-color-base-text);\n	margin-right: -1px;\n	outline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 7536: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"], names: [], mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-link-actions__preview {\n		display: inline-block;\n\n		& .ck-button__label {\n			overflow: hidden;\n		}\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-link-actions__preview {\n			flex-basis: 100%;\n		}\n\n		& .ck-button:not(.ck-link-actions__preview) {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	& .ck-button.ck-link-actions__preview {
		padding-left: 0;
		padding-right: 0;

		& .ck-button__label {
			padding: 0 var(--ck-spacing-medium);
			color: var(--ck-color-link-default);
			text-overflow: ellipsis;
			cursor: pointer;

			/* Match the box model of the link editor form's input so the balloon
			does not change width when moving between actions and the form. */
			max-width: var(--ck-input-width);
			min-width: 3em;
			text-align: center;

			&:hover {
				text-decoration: underline;
			}
		}

		&,
		&:hover,
		&:focus,
		&:active {
			background: none;
		}

		&:active {
			box-shadow: none;
		}

		&:focus {
			& .ck-button__label {
				text-decoration: underline;
			}
		}
	}

	@mixin ck-dir ltr {
		& .ck-button:not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-button:not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		& .ck-button.ck-link-actions__preview {
			margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;

			& .ck-button__label {
				min-width: 0;
				max-width: 100%;
			}
		}

		& .ck-button:not(.ck-link-actions__preview) {
			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;
			}
		}
	}
}
`], sourceRoot: "" }]);
        const a2 = s2;
      }, 4874: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"], names: [], mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n	display: flex;\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n	display: block;\n\n	/*\n	 * Whether the form is in the responsive mode or not, if there are decorator buttons\n	 * keep the top margin of action buttons medium.\n	 */\n	& .ck-button {\n		&.ck-button-save,\n		&.ck-button-cancel {\n			margin-top: var(--ck-spacing-medium);\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n	padding: 0;\n	min-width: var(--ck-input-width);\n\n	& .ck-labeled-field-view {\n		margin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n		& .ck-input-text {\n			min-width: 0;\n			width: 100%;\n		}\n	}\n\n	& > .ck-button {\n		padding: var(--ck-spacing-standard);\n		margin: 0;\n		width: 50%;\n		border-radius: 0;\n\n		&:not(:focus) {\n			border-top: 1px solid var(--ck-color-base-border);\n		}\n\n		@mixin ck-dir ltr {\n			margin-left: 0;\n		}\n\n		@mixin ck-dir rtl {\n			margin-left: 0;\n\n			&:last-of-type {\n				border-right: 1px solid var(--ck-color-base-border);\n			}\n		}\n	}\n\n	/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n	& .ck.ck-list {\n		margin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n		& .ck-button.ck-switchbutton {\n			padding: 0;\n			width: 100%;\n\n			&:hover {\n				background: none;\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 4330: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-link/theme/linkimage.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"], names: [], mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	/* Linked image indicator */\n	& figure.image > a,\n	& a span.image-inline {\n		&::after {\n			display: block;\n			position: absolute;\n		}\n	}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/* Match the icon size with the upload indicator brought by the image upload feature. */\n	--ck-link-image-indicator-icon-size: 20;\n	--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck.ck-editor__editable {\n	/* Linked image indicator */\n	& figure.image > a,\n	& a span.image-inline {\n		&::after {\n			content: "";\n\n			/*\n			 * Smaller images should have the icon closer to the border.\n			 * Match the icon position with the upload indicator brought by the image upload feature.\n			 */\n			top: min(var(--ck-spacing-medium), 6%);\n			right: min(var(--ck-spacing-medium), 6%);\n\n			background-color: hsla(0, 0%, 0%, .4);\n			background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");\n			background-size: 14px;\n			background-repeat: no-repeat;\n			background-position: center;\n			border-radius: 100%;\n\n			/*\n			* Use CSS math to simulate container queries.\n			* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n			*/\n			overflow: hidden;\n			width: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n			height: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n		}\n	}\n}\n\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 5782: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/collapsible.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"], names: [], mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-collapsible.ck-collapsible_collapsed {\n	& > .ck-collapsible__children {\n		display: none;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-collapsible {\n	& > .ck.ck-button {\n		width: 100%;\n		font-weight: bold;\n		padding: var(--ck-spacing-medium) var(--ck-spacing-large);\n		border-radius: 0;\n		color: inherit;\n\n		&:focus {\n			background: transparent;\n		}\n\n		&:active, &:not(:focus), &:hover:not(:focus) {\n			background: transparent;\n			border-color: transparent;\n			box-shadow: none;\n		}\n\n		& > .ck-icon {\n			margin-right: var(--ck-spacing-medium);\n			width: var(--ck-collapsible-arrow-size);\n		}\n	}\n\n	& > .ck-collapsible__children {\n		padding: 0 var(--ck-spacing-large) var(--ck-spacing-large);\n	}\n\n	&.ck-collapsible_collapsed {\n		& > .ck.ck-button .ck-icon {\n			transform: rotate(-90deg);\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3190: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/documentlist.css"], names: [], mappings: "AAKA,8CACC,aACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-editor__editable .ck-list-bogus-paragraph {\n	display: block;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4784: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/list.css"], names: [], mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content ol {\n	list-style-type: decimal;\n\n	& ol {\n		list-style-type: lower-latin;\n\n		& ol {\n			list-style-type: lower-roman;\n\n			& ol {\n				list-style-type: upper-latin;\n\n				& ol {\n					list-style-type: upper-roman;\n				}\n			}\n		}\n	}\n}\n\n.ck-content ul {\n	list-style-type: disc;\n\n	& ul {\n		list-style-type: circle;\n\n		& ul {\n			list-style-type: square;\n\n			& ul {\n				list-style-type: square;\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 9938: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"], names: [], mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-properties {\n	/* When there are no list styles and there is no collapsible. */\n	&.ck-list-properties_without-styles {\n		padding: var(--ck-spacing-large);\n\n		& > * {\n			min-width: 14em;\n\n			& + * {\n				margin-top: var(--ck-spacing-standard);\n			}\n		}\n	}\n\n	/*\n	 * When the numbered list property fields (start at, reversed) should be displayed,\n	 * more horizontal space is needed. Reconfigure the style grid to create that space.\n	 */\n	&.ck-list-properties_with-numbered-properties {\n		& > .ck-list-styles-list {\n			grid-template-columns: repeat( 4, auto );\n		}\n\n		/* When list styles are rendered and property fields are in a collapsible. */\n		& > .ck-collapsible {\n			border-top: 1px solid var(--ck-color-base-border);\n\n			& > .ck-collapsible__children {\n				& > * {\n					width: 100%;\n\n					& + * {\n						margin-top: var(--ck-spacing-standard);\n					}\n				}\n			}\n		}\n	}\n\n	& .ck.ck-numbered-list-properties__start-index .ck-input {\n		min-width: auto;\n		width: 100%;\n	}\n\n	& .ck.ck-numbered-list-properties__reversed-order {\n		background: transparent;\n		padding-left: 0;\n		padding-right: 0;\n		margin-bottom: calc(-1 * var(--ck-spacing-tiny));\n\n		&:active, &:hover {\n			box-shadow: none;\n			border-color: transparent;\n			background: none;\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2591: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/liststyles.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"], names: [], mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-list {\n	display: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-list {\n	grid-template-columns: repeat( 3, auto );\n	row-gap: var(--ck-spacing-medium);\n	column-gap: var(--ck-spacing-medium);\n	padding: var(--ck-spacing-large);\n\n	& .ck-button {\n		/* Make the button look like a thumbnail (the icon "takes it all"). */\n		width: var(--ck-list-style-button-size);\n		height: var(--ck-list-style-button-size);\n		padding: 0;\n\n		/*\n		 * Buttons are aligned by the grid so disable default button margins to not collide with the\n		 * gaps in the grid.\n		 */\n		margin: 0;\n\n		/*\n		 * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n		 * from the button dimensions and, as a result, decrease the size of the icon\n		 * (which becomes blurry as it scales down).\n		 */\n		box-sizing: content-box;\n\n		& .ck-icon {\n			width: var(--ck-list-style-button-size);\n			height: var(--ck-list-style-button-size);\n		}\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 9292: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px;position:relative}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}.ck-editor__editable.ck-content .todo-list .todo-list__label>input,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{cursor:pointer}.ck-editor__editable.ck-content .todo-list .todo-list__label>input:hover:before,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-editor__editable.ck-content[dir=rtl] .todo-list .todo-list__label>span[contenteditable=false]>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:after{border-color:#fff}.ck-editor__editable.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-list/theme/todolist.css"], names: [], mappings: "AAKA,MACC,kCACD,CAwEA,uBACC,eAwBD,CAtBC,0BAEC,iBAAkB,CADlB,iBAMD,CAHC,qCACC,cACD,CAIA,+CAlFD,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAiFC,CAFA,wDAhEA,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAgEA,CA5DD,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,sCAAwC,CAJxC,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAwBA,wEACC,qBACD,CAEA,mGACC,iBACD,CAYD,kKAEC,cAKD,CAHC,4LACC,mCACD,CAMD,+FApHA,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAmHA,CAFA,wGAlGC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAkGD,CA9FA,sGAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,sCAAwC,CAJxC,UAKD,CAEA,qGAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+GACC,kBAA8B,CAC9B,oBACD,CAEA,8GACC,iBACD,CA2DA,uHACC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-todo-list-checkmark-size: 16px;\n}\n\n@define-mixin todo-list-checkbox {\n	-webkit-appearance: none;\n	display: inline-block;\n	position: relative;\n	width: var(--ck-todo-list-checkmark-size);\n	height: var(--ck-todo-list-checkmark-size);\n	vertical-align: middle;\n\n	/* Needed on iOS */\n	border: 0;\n\n	/* LTR styles */\n	left: -25px;\n	margin-right: -15px;\n	right: 0;\n	margin-left: 0;\n\n	/* RTL styles */\n	@nest [dir=rtl]& {\n		left: 0;\n		margin-right: 0;\n		right: -25px;\n		margin-left: -15px;\n	}\n\n	&::before {\n		display: block;\n		position: absolute;\n		box-sizing: border-box;\n		content: '';\n		width: 100%;\n		height: 100%;\n		border: 1px solid hsl(0, 0%, 20%);\n		border-radius: 2px;\n		transition: 250ms ease-in-out box-shadow;\n	}\n\n	&::after {\n		display: block;\n		position: absolute;\n		box-sizing: content-box;\n		pointer-events: none;\n		content: '';\n\n		/* Calculate tick position, size and border-width proportional to the checkmark size. */\n		left: calc( var(--ck-todo-list-checkmark-size) / 3 );\n		top: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n		width: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n		height: calc( var(--ck-todo-list-checkmark-size) / 2.6 );\n		border-style: solid;\n		border-color: transparent;\n		border-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;\n		transform: rotate(45deg);\n	}\n\n	&[checked] {\n		&::before {\n			background: hsl(126, 64%, 41%);\n			border-color: hsl(126, 64%, 41%);\n		}\n\n		&::after {\n			border-color: hsl(0, 0%, 100%);\n		}\n	}\n}\n\n/*\n * To-do list content styles.\n */\n.ck-content .todo-list {\n	list-style: none;\n\n	& li {\n		position: relative;\n		margin-bottom: 5px;\n\n		& .todo-list {\n			margin-top: 5px;\n		}\n	}\n\n	& .todo-list__label {\n		& > input {\n			@mixin todo-list-checkbox;\n		}\n\n		& .todo-list__label__description {\n			vertical-align: middle;\n		}\n\n		&.todo-list__label_without-description input[type=checkbox] {\n			position: absolute;\n		}\n	}\n}\n\n/*\n * To-do list editing view styles.\n */\n.ck-editor__editable.ck-content .todo-list .todo-list__label {\n	/*\n	 * To-do list should be interactive only during the editing\n	 * (https://github.com/ckeditor/ckeditor5/issues/2090).\n	 */\n	& > input,\n	& > span[contenteditable=false] > input {\n		cursor: pointer;\n\n		&:hover::before {\n			box-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);\n		}\n	}\n\n	/*\n	 * Document Lists - editing view has an additional span around checkbox.\n	 */\n	& > span[contenteditable=false] > input {\n		@mixin todo-list-checkbox;\n	}\n\n	&.todo-list__label_without-description {\n		& input[type=checkbox] {\n			position: absolute;\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 8705: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembed.css"], names: [], mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n	/* Don\'t allow floated content overlap the media.\n	https://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n	clear: both;\n\n	/* Make sure there is some space between the content and the media. */\n	/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n	margin: 0.9em 0;\n\n	/* Make sure media is not overriden with Bootstrap default `flex` value.\n	See: https://github.com/ckeditor/ckeditor5/issues/1373. */\n	display: block;\n\n	/* Give the media some minimal width in the content to prevent them\n	from being "squashed" in tight spaces, e.g. in table cells (#44) */\n	min-width: 15em;\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 1922: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"], names: [], mappings: "AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-media__wrapper {\n	& .ck-media__placeholder {\n		display: flex;\n		flex-direction: column;\n		align-items: center;\n\n		& .ck-media__placeholder__url {\n			/* Otherwise the URL will overflow when the content is very narrow. */\n			max-width: 100%;\n\n			position: relative;\n\n			& .ck-media__placeholder__url__text {\n				overflow: hidden;\n				display: block;\n			}\n		}\n	}\n\n	&[data-oembed-url*="twitter.com"],\n	&[data-oembed-url*="google.com/maps"],\n	&[data-oembed-url*="goo.gl/maps"],\n	&[data-oembed-url*="maps.google.com"],\n	&[data-oembed-url*="maps.app.goo.gl"],\n	&[data-oembed-url*="facebook.com"],\n	&[data-oembed-url*="instagram.com"] {\n		& .ck-media__placeholder__icon * {\n			display: none;\n		}\n	}\n}\n\n/* Disable all mouse interaction as long as the editor is not readonly.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n	pointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n	pointer-events: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-media-embed-placeholder-icon-size: 3em;\n\n	--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n	--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n	margin: 0 auto;\n\n	& .ck-media__placeholder {\n		padding: calc( 3 * var(--ck-spacing-standard) );\n		background: var(--ck-color-base-foreground);\n\n		& .ck-media__placeholder__icon {\n			min-width: var(--ck-media-embed-placeholder-icon-size);\n			height: var(--ck-media-embed-placeholder-icon-size);\n			margin-bottom: var(--ck-spacing-large);\n			background-position: center;\n			background-size: cover;\n\n			& .ck-icon {\n				width: 100%;\n				height: 100%;\n			}\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: var(--ck-color-media-embed-placeholder-url-text);\n			white-space: nowrap;\n			text-align: center;\n			font-style: italic;\n			text-overflow: ellipsis;\n\n			&:hover {\n				color: var(--ck-color-media-embed-placeholder-url-text-hover);\n				cursor: pointer;\n				text-decoration: underline;\n			}\n		}\n	}\n\n	&[data-oembed-url*="open.spotify.com"] {\n		max-width: 300px;\n		max-height: 380px;\n	}\n\n	&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n		background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n	}\n\n	&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n		background: hsl(220, 46%, 48%);\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: hsl(220, 100%, 90%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n\n	&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n		background: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n		}\n\n		/* stylelint-disable-next-line no-descending-specificity */\n		& .ck-media__placeholder__url__text {\n			color: hsl(302, 100%, 94%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n\n	&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n		/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n		background: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: hsl(201, 100%, 86%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 7138: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-media-embed/theme/mediaform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n	display: flex;\n	align-items: flex-start;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-labeled-field-view {\n		display: inline-block;\n	}\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 8544: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-color-mention-background:rgba(153,0,48,.1);--ck-color-mention-text:#990030}.ck-content .mention{background:var(--ck-color-mention-background);color:var(--ck-color-mention-text)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-mention/mention.css"], names: [], mappings: "AAKA,MACC,+CAAwD,CACxD,+BACD,CAEA,qBACC,6CAA8C,CAC9C,kCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-mention-background: hsla(341, 100%, 30%, 0.1);\n	--ck-color-mention-text: hsl(341, 100%, 30%);\n}\n\n.ck-content .mention {\n	background: var(--ck-color-mention-background);\n	color: var(--ck-color-mention-text);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 9139: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-mention-list-max-height:300px}.ck.ck-mentions{max-height:var(--ck-mention-list-max-height);overflow-x:hidden;overflow-y:auto;overscroll-behavior:contain}.ck.ck-mentions>.ck-list__item{flex-shrink:0;overflow:hidden}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-mention/theme/mentionui.css"], names: [], mappings: "AAKA,MACC,kCACD,CAEA,gBACC,4CAA6C,CAM7C,iBAAkB,CAJlB,eAAgB,CAMhB,2BAQD,CAJC,+BAEC,aAAc,CADd,eAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-mention-list-max-height: 300px;\n}\n\n.ck.ck-mentions {\n	max-height: var(--ck-mention-list-max-height);\n\n	overflow-y: auto;\n\n	/* Prevent unnecessary horizontal scrollbar in Safari\n	https://github.com/ckeditor/ckeditor5-mention/issues/41 */\n	overflow-x: hidden;\n\n	overscroll-behavior: contain;\n\n	/* Prevent unnecessary vertical scrollbar in Safari\n	https://github.com/ckeditor/ckeditor5-mention/issues/41 */\n	& > .ck-list__item {\n		overflow: hidden;\n		flex-shrink: 0;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 9347: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-color-restricted-editing-exception-background:rgba(255,169,77,.2);--ck-color-restricted-editing-exception-hover-background:rgba(255,169,77,.35);--ck-color-restricted-editing-exception-brackets:rgba(204,105,0,.4);--ck-color-restricted-editing-selected-exception-background:rgba(255,169,77,.5);--ck-color-restricted-editing-selected-exception-brackets:rgba(204,105,0,.6)}.ck-editor__editable .restricted-editing-exception{background-color:var(--ck-color-restricted-editing-exception-background);border:1px solid;border-image:linear-gradient(to right,var(--ck-color-restricted-editing-exception-brackets) 0,var(--ck-color-restricted-editing-exception-brackets) 5px,transparent 6px,transparent calc(100% - 6px),var(--ck-color-restricted-editing-exception-brackets) calc(100% - 5px),var(--ck-color-restricted-editing-exception-brackets) 100%) 1;transition:background .2s ease-in-out}.ck-editor__editable .restricted-editing-exception.restricted-editing-exception_selected{background-color:var(--ck-color-restricted-editing-selected-exception-background);border-image:linear-gradient(to right,var(--ck-color-restricted-editing-selected-exception-brackets) 0,var(--ck-color-restricted-editing-selected-exception-brackets) 5px,var(--ck-color-restricted-editing-selected-exception-brackets) calc(100% - 5px),var(--ck-color-restricted-editing-selected-exception-brackets) 100%) 1}.ck-editor__editable .restricted-editing-exception.restricted-editing-exception_collapsed{padding-left:1ch}.ck-restricted-editing_mode_restricted,.ck-restricted-editing_mode_restricted *{cursor:default}.ck-restricted-editing_mode_restricted .restricted-editing-exception,.ck-restricted-editing_mode_restricted .restricted-editing-exception *{cursor:text}.ck-restricted-editing_mode_restricted .restricted-editing-exception:hover{background:var(--ck-color-restricted-editing-exception-hover-background)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-restricted-editing/restrictedediting.css"], names: [], mappings: "AAKA,MACC,sEAA2E,CAC3E,6EAAkF,CAClF,mEAAyE,CACzE,+EAAoF,CACpF,4EACD,CAEA,mDAEC,wEAAyE,CACzE,gBAAiB,CACjB,yUAQG,CAXH,qCA4BD,CAfC,yFACC,iFAAkF,CAClF,gUAOD,CAEA,0FAEC,gBACD,CAQA,gFACC,cACD,CAKC,4IACC,WACD,CAEA,2EACC,wEACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-restricted-editing-exception-background: hsla(31, 100%, 65%, .2);\n	--ck-color-restricted-editing-exception-hover-background: hsla(31, 100%, 65%, .35);\n	--ck-color-restricted-editing-exception-brackets: hsla(31, 100%, 40%, .4);\n	--ck-color-restricted-editing-selected-exception-background: hsla(31, 100%, 65%, .5);\n	--ck-color-restricted-editing-selected-exception-brackets: hsla(31, 100%, 40%, .6);\n}\n\n.ck-editor__editable .restricted-editing-exception {\n	transition: .2s ease-in-out background;\n	background-color: var(--ck-color-restricted-editing-exception-background);\n	border: 1px solid;\n	border-image: linear-gradient(\n		to right,\n		var(--ck-color-restricted-editing-exception-brackets) 0%,\n		var(--ck-color-restricted-editing-exception-brackets) 5px,\n		hsla(0, 0%, 0%, 0) 6px,\n		hsla(0, 0%, 0%, 0) calc(100% - 6px),\n		var(--ck-color-restricted-editing-exception-brackets) calc(100% - 5px),\n		var(--ck-color-restricted-editing-exception-brackets) 100%\n	) 1;\n\n	&.restricted-editing-exception_selected {\n		background-color: var(--ck-color-restricted-editing-selected-exception-background);\n		border-image: linear-gradient(\n			to right,\n			var(--ck-color-restricted-editing-selected-exception-brackets) 0%,\n			var(--ck-color-restricted-editing-selected-exception-brackets) 5px,\n			var(--ck-color-restricted-editing-selected-exception-brackets) calc(100% - 5px),\n			var(--ck-color-restricted-editing-selected-exception-brackets) 100%\n		) 1;\n	}\n\n	&.restricted-editing-exception_collapsed {\n		/* Empty exception should have the same width as exception with at least 1 char */\n		padding-left: 1ch;\n	}\n}\n\n.ck-restricted-editing_mode_restricted {\n	cursor: default;\n\n	/* We also have to override all elements inside the restricted editable to prevent cursor switching between default and text\n	during the pointer movement. */\n	& * {\n		cursor: default;\n	}\n\n	& .restricted-editing-exception {\n		cursor: text;\n\n		& * {\n			cursor: text;\n		}\n\n		&:hover {\n			background: var(--ck-color-restricted-editing-exception-hover-background);\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4420: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck-source-editing-area{overflow:hidden;position:relative}.ck-source-editing-area textarea,.ck-source-editing-area:after{border:1px solid transparent;font-family:monospace;font-size:var(--ck-font-size-normal);line-height:var(--ck-line-height-base);margin:0;padding:var(--ck-spacing-large);white-space:pre-wrap}.ck-source-editing-area:after{content:attr(data-value) " ";display:block;visibility:hidden}.ck-source-editing-area textarea{border-color:var(--ck-color-base-border);border-radius:0;box-sizing:border-box;height:100%;outline:none;overflow:hidden;position:absolute;resize:none;width:100%}.ck-rounded-corners .ck-source-editing-area textarea,.ck-source-editing-area textarea.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck-source-editing-area textarea:not([readonly]):focus{border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-source-editing/theme/sourceediting.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,wBAEC,eAAgB,CADhB,iBAED,CAEA,+DAIC,4BAA6B,CAG7B,qBAAsB,CADtB,oCAAqC,CADrC,sCAAuC,CAFvC,QAAS,CADT,+BAAgC,CAMhC,oBACD,CAEA,8BACC,4BAA6B,CAE7B,aAAc,CADd,iBAED,CAEA,iCASC,wCAAyC,CC7BzC,eAAgB,CD2BhB,qBAAsB,CAJtB,WAAY,CAEZ,YAAa,CACb,eAAgB,CALhB,iBAAkB,CAGlB,WAAY,CAFZ,UAkBD,CApBA,yGChBE,qCAAsC,CD4BtC,wBAAyB,CACzB,yBAOF,CAJC,uDEpCA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFwCA", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";\n\n.ck-source-editing-area {\n	position: relative;\n	overflow: hidden;\n}\n\n.ck-source-editing-area::after,\n.ck-source-editing-area textarea {\n	padding: var(--ck-spacing-large);\n	margin: 0;\n	border: 1px solid transparent;\n	line-height: var(--ck-line-height-base);\n	font-size: var(--ck-font-size-normal);\n	font-family: monospace;\n	white-space: pre-wrap;\n}\n\n.ck-source-editing-area::after {\n	content: attr(data-value) " ";\n	visibility: hidden;\n	display: block;\n}\n\n.ck-source-editing-area textarea {\n	position: absolute;\n	width: 100%;\n	height: 100%;\n	resize: none;\n	outline: none;\n	overflow: hidden;\n	box-sizing: border-box;\n\n	border-color: var(--ck-color-base-border);\n\n	@mixin ck-rounded-corners {\n		border-top-left-radius: 0;\n		border-top-right-radius: 0;\n	}\n\n	&:not([readonly]):focus {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-inner-shadow);\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 1550: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-character-grid{max-width:100%}.ck.ck-character-grid .ck-character-grid__tiles{display:grid}:root{--ck-character-grid-tile-size:24px}.ck.ck-character-grid{max-height:200px;overflow-x:hidden;overflow-y:auto;width:350px}@media screen and (max-width:600px){.ck.ck-character-grid{width:190px}}.ck.ck-character-grid .ck-character-grid__tiles{grid-gap:var(--ck-spacing-standard);grid-template-columns:repeat(10,1fr);margin:var(--ck-spacing-standard) var(--ck-spacing-large)}@media screen and (max-width:600px){.ck.ck-character-grid .ck-character-grid__tiles{grid-template-columns:repeat(5,1fr)}}.ck.ck-character-grid .ck-character-grid__tile{border:0;font-size:1.2em;height:var(--ck-character-grid-tile-size);min-height:var(--ck-character-grid-tile-size);min-width:var(--ck-character-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-character-grid-tile-size)}.ck.ck-character-grid .ck-character-grid__tile:focus:not(.ck-disabled),.ck.ck-character-grid .ck-character-grid__tile:hover:not(.ck-disabled){border:0;box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-character-grid .ck-character-grid__tile .ck-button__label{line-height:var(--ck-character-grid-tile-size);text-align:center;width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/charactergrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/charactergrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAKA,sBACC,cAKD,CAHC,gDACC,YACD,CCFD,MACC,kCACD,CAEA,sBAIC,gBAAiB,CAFjB,iBAAkB,CADlB,eAAgB,CAEhB,WAyCD,CClDC,oCDMD,sBAOE,WAqCF,CChDC,CDcA,gDAGC,mCAAoC,CAFpC,oCAAsC,CACtC,yDAMD,CCxBA,oCDgBA,gDAME,mCAEF,CCtBA,CDwBA,+CAQC,QAAS,CAHT,eAAgB,CAHhB,yCAA0C,CAE1C,6CAA8C,CAD9C,4CAA6C,CAG7C,SAAU,CACV,8BAA+B,CAN/B,wCAsBD,CAbC,8IAGC,QAAS,CACT,iGACD,CAGA,iEACC,8CAA+C,CAE/C,iBAAkB,CADlB,UAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-grid {\n	max-width: 100%;\n	\n	& .ck-character-grid__tiles {\n		display: grid;\n	}\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";
@import "../mixins/_rounded.css";

:root {
	--ck-character-grid-tile-size: 24px;
}

.ck.ck-character-grid {
	overflow-y: auto;
	overflow-x: hidden;
	width: 350px;
	max-height: 200px;

	@mixin ck-media-phone {
		width: 190px;
	}

	& .ck-character-grid__tiles {
		grid-template-columns: repeat(10, 1fr);
		margin: var(--ck-spacing-standard) var(--ck-spacing-large);
		grid-gap: var(--ck-spacing-standard);

		@mixin ck-media-phone {
			grid-template-columns: repeat(5, 1fr);
		}
	}

	& .ck-character-grid__tile {
		width: var(--ck-character-grid-tile-size);
		height: var(--ck-character-grid-tile-size);
		min-width: var(--ck-character-grid-tile-size);
		min-height: var(--ck-character-grid-tile-size);
		font-size: 1.2em;
		padding: 0;
		transition: .2s ease box-shadow;
		border: 0;

		&:focus:not( .ck-disabled ),
		&:hover:not( .ck-disabled ) {
			/* Disable the default .ck-button's border ring. */
			border: 0;
			box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
		}

		/* Make sure the glyph is rendered in the center of the button */
		& .ck-button__label {
			line-height: var(--ck-character-grid-tile-size);
			width: 100%;
			text-align: center;
		}
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2234: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-character-info{border-top:1px solid var(--ck-color-base-border);display:flex;justify-content:space-between;padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-character-info>*{font-size:var(--ck-font-size-small);text-transform:uppercase}.ck.ck-character-info .ck-character-info__name{max-width:280px;overflow:hidden;text-overflow:ellipsis}.ck.ck-character-info .ck-character-info__code{opacity:.6}@media screen and (max-width:600px){.ck.ck-character-info{max-width:190px}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-special-characters/theme/characterinfo.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/characterinfo.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAKA,sBCIC,gDAAiD,CDHjD,YAAa,CACb,6BAA8B,CCC9B,uDDAD,CCGC,wBAEC,mCAAoC,CADpC,wBAED,CAEA,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,+CACC,UACD,CClBA,oCDCD,sBAoBE,eAEF,CCrBC", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-character-info {\n	display: flex;\n	justify-content: space-between;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-character-info {\n	padding: var(--ck-spacing-small) var(--ck-spacing-large);\n	border-top: 1px solid var(--ck-color-base-border);\n\n	& > * {\n		text-transform: uppercase;\n		font-size: var(--ck-font-size-small);\n	}\n\n	& .ck-character-info__name {\n		max-width: 280px;\n		text-overflow: ellipsis;\n		overflow: hidden;\n	}\n\n	& .ck-character-info__code {\n		opacity: .6;\n	}\n\n	@mixin ck-media-phone {\n		max-width: 190px;\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2538: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-special-characters-navigation>.ck-label{max-width:160px;overflow:hidden;text-overflow:ellipsis}.ck.ck-special-characters-navigation>.ck-dropdown .ck-dropdown__panel{max-height:250px;overflow-x:hidden;overflow-y:auto}@media screen and (max-width:600px){.ck.ck-special-characters-navigation{max-width:190px}.ck.ck-special-characters-navigation>.ck-form__header__label{overflow:hidden;text-overflow:ellipsis}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-special-characters/specialcharacters.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAUC,+CACC,eAAgB,CAEhB,eAAgB,CADhB,sBAED,CAEA,sEAEC,gBAAiB,CAEjB,iBAAkB,CADlB,eAED,CCfA,oCDED,qCAgBE,eAOF,CALE,6DAEC,eAAgB,CADhB,sBAED,CCrBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-special-characters-navigation {\n\n	& > .ck-label {\n		max-width: 160px;\n		text-overflow: ellipsis;\n		overflow: hidden;\n	}\n\n	& > .ck-dropdown .ck-dropdown__panel {\n		/* There could be dozens of categories available. Use scroll to prevent a 10e6px dropdown. */\n		max-height: 250px;\n		overflow-y: auto;\n		overflow-x: hidden;\n	}\n\n	@mixin ck-media-phone {\n		max-width: 190px;\n\n		& > .ck-form__header__label {\n			text-overflow: ellipsis;\n			overflow: hidden;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 8624: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-dropdown.ck-style-dropdown.ck-style-dropdown_multiple-active>.ck-button>.ck-button__label{font-style:italic}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-style/style.css"], names: [], mappings: "AAKA,iGACC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-dropdown.ck-style-dropdown.ck-style-dropdown_multiple-active > .ck-button > .ck-button__label {\n	font-style: italic;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7775: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-style-panel-columns:3}.ck.ck-style-panel .ck-style-grid{display:grid;grid-template-columns:repeat(var(--ck-style-panel-columns),auto);justify-content:start}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button{display:flex;flex-direction:column;justify-content:space-between}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button .ck-style-grid__button__preview{align-content:center;align-items:center;display:flex;flex-basis:100%;flex-grow:1;justify-content:flex-start}:root{--ck-style-panel-button-width:120px;--ck-style-panel-button-height:80px;--ck-style-panel-button-label-background:#f0f0f0;--ck-style-panel-button-hover-label-background:#ebebeb;--ck-style-panel-button-hover-border-color:#b3b3b3}.ck.ck-style-panel .ck-style-grid{column-gap:var(--ck-spacing-large);row-gap:var(--ck-spacing-large)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button{--ck-color-button-default-hover-background:var(--ck-color-base-background);--ck-color-button-default-active-background:var(--ck-color-base-background);height:var(--ck-style-panel-button-height);padding:0;width:var(--ck-style-panel-button-width)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button .ck-button__label{flex-shrink:0;height:22px;line-height:22px;overflow:hidden;padding:0 var(--ck-spacing-medium);text-overflow:ellipsis;width:100%}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button .ck-style-grid__button__preview{background:var(--ck-color-base-background);border:2px solid var(--ck-color-base-background);opacity:.9;overflow:hidden;padding:var(--ck-spacing-medium);width:100%}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-disabled{--ck-color-button-default-disabled-background:var(--ck-color-base-foreground)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-disabled:not(:focus){border-color:var(--ck-style-panel-button-label-background)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-disabled .ck-style-grid__button__preview{border-color:var(--ck-color-base-foreground);filter:saturate(.3);opacity:.4}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-on{border-color:var(--ck-color-base-active)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-on .ck-button__label{box-shadow:0 -1px 0 var(--ck-color-base-active);z-index:1}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button.ck-on:hover{border-color:var(--ck-color-base-active-focus)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:not(.ck-on) .ck-button__label{background:var(--ck-style-panel-button-label-background)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:not(.ck-on):hover .ck-button__label{background:var(--ck-style-panel-button-hover-label-background)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:hover:not(.ck-disabled):not(.ck-on){border-color:var(--ck-style-panel-button-hover-border-color)}.ck.ck-style-panel .ck-style-grid .ck-style-grid__button:hover:not(.ck-disabled):not(.ck-on) .ck-style-grid__button__preview{opacity:1}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-style/theme/stylegrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-style/stylegrid.css"], names: [], mappings: "AAKA,MACC,0BACD,CAEA,kCACC,YAAa,CACb,gEAAiE,CACjE,qBAgBD,CAdC,yDACC,YAAa,CAEb,qBAAsB,CADtB,6BAWD,CARC,yFAEC,oBAAqB,CAErB,kBAAmB,CAHnB,YAAa,CAKb,eAAgB,CADhB,WAAY,CAFZ,0BAID,CCrBF,MACC,mCAAoC,CACpC,mCAAoC,CACpC,gDAA2D,CAC3D,sDAAiE,CACjE,kDACD,CAEA,kCAEC,kCAAmC,CADnC,+BAmFD,CAhFC,yDACC,0EAA2E,CAC3E,2EAA4E,CAI5E,0CAA2C,CAF3C,SAAU,CACV,wCA0ED,CAtEC,qEACC,4CACD,CAEA,2EAOC,aAAc,CANd,WAAY,CACZ,gBAAiB,CAGjB,eAAgB,CADhB,kCAAmC,CAEnC,sBAAuB,CAHvB,UAKD,CAEA,yFAMC,0CAA2C,CAC3C,gDAAiD,CAJjD,UAAW,CADX,eAAgB,CAGhB,gCAAiC,CAJjC,UAOD,CAEA,qEACC,6EAaD,CAVC,iFACC,0DACD,CAEA,qGAGC,4CAA6C,CAC7C,mBAAoB,CAHpB,UAID,CAGD,+DACC,wCAUD,CARC,iFACC,+CAAgD,CAChD,SACD,CAEA,qEACC,8CACD,CAIA,uFACC,wDACD,CAEA,6FACC,8DACD,CAGD,6FACC,4DAKD,CAHC,6HACC,SACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-style-panel-columns: 3;\n}\n\n.ck.ck-style-panel .ck-style-grid {\n	display: grid;\n	grid-template-columns: repeat(var(--ck-style-panel-columns),auto);\n	justify-content: start;\n\n	& .ck-style-grid__button {\n		display: flex;\n		justify-content: space-between;\n		flex-direction: column;\n\n		& .ck-style-grid__button__preview {\n			display: flex;\n			align-content: center;\n			justify-content: flex-start;\n			align-items: center;\n			flex-grow: 1;\n			flex-basis: 100%;\n		}\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-style-panel-button-width: 120px;\n	--ck-style-panel-button-height: 80px;\n	--ck-style-panel-button-label-background: hsl(0, 0%, 94.1%);\n	--ck-style-panel-button-hover-label-background: hsl(0, 0%, 92.1%);\n	--ck-style-panel-button-hover-border-color: hsl(0, 0%, 70%);\n}\n\n.ck.ck-style-panel .ck-style-grid {\n	row-gap: var(--ck-spacing-large);\n	column-gap: var(--ck-spacing-large);\n\n	& .ck-style-grid__button {\n		--ck-color-button-default-hover-background: var(--ck-color-base-background);\n		--ck-color-button-default-active-background: var(--ck-color-base-background);\n\n		padding: 0;\n		width: var(--ck-style-panel-button-width);\n		height: var(--ck-style-panel-button-height);\n\n		/* Let default .ck-button :focus styles apply */\n		&:not(:focus) {\n			border: 1px solid var(--ck-color-base-border);\n		}\n\n		& .ck-button__label {\n			height: 22px;\n			line-height: 22px;\n			width: 100%;\n			padding: 0 var(--ck-spacing-medium);\n			overflow: hidden;\n			text-overflow: ellipsis;\n			flex-shrink: 0;\n		}\n\n		& .ck-style-grid__button__preview {\n			width: 100%;\n			overflow: hidden;\n			opacity: .9;\n\n			padding: var(--ck-spacing-medium);\n			background: var(--ck-color-base-background);\n			border: 2px solid var(--ck-color-base-background);\n		}\n\n		&.ck-disabled {\n			--ck-color-button-default-disabled-background: var(--ck-color-base-foreground);\n\n			/* Let default .ck-button :focus styles apply */\n			&:not(:focus) {\n				border-color: var(--ck-style-panel-button-label-background);\n			}\n\n			& .ck-style-grid__button__preview {\n				opacity: .4;\n\n				border-color: var(--ck-color-base-foreground);\n				filter: saturate(.3);\n			}\n		}\n\n		&.ck-on {\n			border-color: var(--ck-color-base-active);\n\n			& .ck-button__label {\n				box-shadow: 0 -1px 0 var(--ck-color-base-active);\n				z-index: 1; /* Stay on top of the preview with the shadow. */\n			}\n\n			&:hover {\n				border-color: var(--ck-color-base-active-focus);\n			}\n		}\n\n		&:not(.ck-on) {\n			& .ck-button__label {\n				background: var(--ck-style-panel-button-label-background);\n			}\n\n			&:hover .ck-button__label {\n				background: var(--ck-style-panel-button-hover-label-background);\n			}\n		}\n\n		&:hover:not(.ck-disabled):not(.ck-on) {\n			border-color: var(--ck-style-panel-button-hover-border-color);\n\n			& .ck-style-grid__button__preview {\n				opacity: 1;\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 5634: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-style-panel .ck-style-panel__style-group>.ck-label{margin:var(--ck-spacing-large) 0}.ck.ck-style-panel .ck-style-panel__style-group:first-child>.ck-label{margin-top:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-style/stylegroup.css"], names: [], mappings: "AAMC,0DACC,gCACD,CAGC,sEACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-style-panel .ck-style-panel__style-group {\n	& > .ck-label {\n		margin: var(--ck-spacing-large) 0;\n	}\n\n	&:first-child {\n		& > .ck-label {\n			margin-top: 0;\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4637: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-style-panel-max-height:470px}.ck.ck-style-panel{max-height:var(--ck-style-panel-max-height);overflow-y:auto;padding:var(--ck-spacing-large)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-style/stylepanel.css"], names: [], mappings: "AAKA,MACC,iCACD,CAEA,mBAGC,2CAA4C,CAD5C,eAAgB,CADhB,+BAGD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-style-panel-max-height: 470px;\n}\n\n.ck.ck-style-panel {\n	padding: var(--ck-spacing-large);\n	overflow-y: auto;\n	max-height: var(--ck-style-panel-max-height);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 9953: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/colorinput.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-input-color {\n	width: 100%;\n	display: flex;\n	flex-direction: row-reverse;\n\n	& > input.ck.ck-input-text {\n		min-width: auto;\n		flex-grow: 1;\n	}\n\n	& > div.ck.ck-dropdown {\n		min-width: auto;\n\n		/* This dropdown has no arrow but a color preview instead. */\n		& > .ck-input-color__button .ck-dropdown__arrow {\n			display: none;\n		}\n	}\n\n	& .ck.ck-input-color__button {\n		/* Resolving issue with misaligned buttons on Safari (see #10589) */\n		display: flex;\n\n		& .ck.ck-input-color__button__preview {\n			position: relative;\n			overflow: hidden;\n\n			& > .ck.ck-input-color__button__preview__no-color-indicator {\n				position: absolute;\n				display: block;\n			}\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_rounded.css";\n\n.ck.ck-input-color {\n	& > .ck.ck-input-text {\n		@mixin ck-dir ltr {\n			border-top-right-radius: 0;\n			border-bottom-right-radius: 0;\n		}\n\n		@mixin ck-dir rtl {\n			border-top-left-radius: 0;\n			border-bottom-left-radius: 0;\n		}\n\n		/* Make sure the focused input is always on top of the dropdown button so its\n		   outline and border are never cropped (also when the input is read-only). */\n		&:focus {\n			z-index: 0;\n		}\n	}\n\n	& > .ck.ck-dropdown {\n		& > .ck.ck-button.ck-input-color__button {\n			padding: 0;\n\n			@mixin ck-dir ltr {\n				border-top-left-radius: 0;\n				border-bottom-left-radius: 0;\n\n				&:not(:focus) {\n					border-left: 1px solid transparent;\n				}\n			}\n\n			@mixin ck-dir rtl {\n				border-top-right-radius: 0;\n				border-bottom-right-radius: 0;\n\n				&:not(:focus) {\n					border-right: 1px solid transparent;\n				}\n			}\n\n			&.ck-disabled {\n				background: var(--ck-color-input-disabled-background);\n			}\n\n			& > .ck.ck-input-color__button__preview {\n				@mixin ck-rounded-corners;\n\n				width: 20px;\n				height: 20px;\n				border: 1px solid var(--ck-color-input-border);\n\n				& > .ck.ck-input-color__button__preview__no-color-indicator {\n					top: -30%;\n					left: 50%;\n					height: 150%;\n					width: 8%;\n					background: hsl(0, 100%, 50%);\n					border-radius: 2px;\n					transform: rotate(45deg);\n					transform-origin: 50%;\n				}\n			}\n		}\n	}\n\n	& .ck.ck-input-color__remove-color {\n		width: 100%;\n		padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\n		border-bottom-left-radius: 0;\n		border-bottom-right-radius: 0;\n\n		&:not(:focus) {\n			border-bottom: 1px solid var(--ck-color-input-border);\n		}\n\n		@mixin ck-dir ltr {\n			border-top-right-radius: 0;\n		}\n\n		@mixin ck-dir rtl {\n			border-top-left-radius: 0;\n		}\n\n		& .ck.ck-icon {\n			margin-right: var(--ck-spacing-standard);\n\n			@mixin ck-dir rtl {\n				margin-right: 0;\n				margin-left: var(--ck-spacing-standard);\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7502: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/form.css"], names: [], mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form {\n	padding: 0 0 var(--ck-spacing-large);\n\n	&:focus {\n		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n		outline: none;\n	}\n\n	& .ck.ck-input-text {\n		min-width: 100%;\n		width: 0;\n	}\n\n	& .ck.ck-dropdown {\n		min-width: 100%;\n\n		& .ck-dropdown__button {\n			&:not(:focus) {\n				border: 1px solid var(--ck-color-base-border);\n			}\n\n			& .ck-button__label {\n				width: 100%;\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 6908: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/formrow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"], names: [], mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__row {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	justify-content: space-between;\n\n	/* Ignore labels that work as fieldset legends */\n	& > *:not(.ck-label) {\n		flex-grow: 1;\n	}\n\n	&.ck-table-form__action-row {\n		& .ck-button-save,\n		& .ck-button-cancel {\n			justify-content: center;\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-form__row {\n	padding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;\n\n	/* Ignore labels that work as fieldset legends */\n	& > *:not(.ck-label) {\n		& + * {\n			@mixin ck-dir ltr {\n				margin-left: var(--ck-spacing-large);\n			}\n\n			@mixin ck-dir rtl {\n				margin-right: var(--ck-spacing-large);\n			}\n		}\n	}\n\n	& > .ck-label {\n		width: 100%;\n		min-width: 100%;\n	}\n\n	&.ck-table-form__action-row {\n		margin-top: var(--ck-spacing-large);\n\n		& .ck-button .ck-button__label {\n			color: var(--ck-color-text);\n		}\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 468: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"], names: [], mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: wrap;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-insert-table-dropdown-padding: 10px;\n	--ck-insert-table-dropdown-box-height: 11px;\n	--ck-insert-table-dropdown-box-width: 12px;\n	--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n	/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n	width: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n	padding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label,\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\n	text-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n	min-width: var(--ck-insert-table-dropdown-box-width);\n	min-height: var(--ck-insert-table-dropdown-box-height);\n	margin: var(--ck-insert-table-dropdown-box-margin);\n	border: 1px solid var(--ck-color-base-border);\n	border-radius: 1px;\n	outline: none;\n	transition: none;\n\n	&:focus {\n		box-shadow: none;\n	}\n\n	&.ck-on {\n		border-color: var(--ck-color-focus-border);\n		background: var(--ck-color-focus-outer-shadow);\n	}\n}\n\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2510: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/table.css"], names: [], mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .table {
	/* Give the table widget some air and center it horizontally */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	display: table;

	& table {
		/* The table cells should have slight borders */
		border-collapse: collapse;
		border-spacing: 0;

		/* Table width and height are set on the parent <figure>. Make sure the table inside stretches
		to the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */
		width: 100%;
		height: 100%;

		/* The outer border of the table should be slightly darker than the inner lines.
		Also see https://github.com/ckeditor/ckeditor5-table/issues/50. */
		border: 1px double hsl(0, 0%, 70%);

		& td,
		& th {
			min-width: 2em;
			padding: .4em;

			/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it's not necessary here.
			However, the border is a content style, so it should use .ck-content (so it works outside the editor).
			Hence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */
			border: 1px solid hsl(0, 0%, 75%);
		}

		& th {
			font-weight: bold;
			background: hsla(0, 0%, 0%, 5%);
		}
	}
}

/* Text alignment of the table header should match the editor settings and override the native browser styling,
when content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */
.ck-content[dir="rtl"] .table th {
	text-align: right;
}

.ck-content[dir="ltr"] .table th {
	text-align: left;
}

.ck-editor__editable .ck-table-bogus-paragraph {
	/*
	 * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
	 * See https://github.com/ckeditor/ckeditor5/issues/6062.
	 */
	display: inline-block;

	/*
	 * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.
	 * See https://github.com/ckeditor/ckeditor5/issues/9117.
	 */
	width: 100%;
}
`], sourceRoot: "" }]);
        const a2 = s2;
      }, 1111: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-color-selector-caption-background:#f7f7f7;--ck-color-selector-caption-text:#333;--ck-color-selector-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-selector-caption-background);caption-side:top;color:var(--ck-color-selector-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-selector-caption-highlighted-background)}to{background-color:var(--ck-color-selector-caption-background)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecaption.css"], names: [], mappings: "AAKA,MACC,8CAAuD,CACvD,qCAAiD,CACjD,uDACD,CAGA,8BAMC,4DAA6D,CAJ7D,gBAAiB,CAGjB,2CAA4C,CAJ5C,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,wEACD,CAEA,GACC,4DACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-selector-caption-background: hsl(0, 0%, 97%);\n	--ck-color-selector-caption-text: hsl(0, 0%, 20%);\n	--ck-color-selector-caption-highlighted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .table > figcaption {\n	display: table-caption;\n	caption-side: top;\n	word-break: break-word;\n	text-align: center;\n	color: var(--ck-color-selector-caption-text);\n	background-color: var(--ck-color-selector-caption-background);\n	padding: .6em;\n	font-size: .75em;\n	outline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .table > figcaption {\n	&.table__caption_highlighted {\n		animation: ck-table-caption-highlight .6s ease-out;\n	}\n\n	&.ck-placeholder::before {\n		padding-left: inherit;\n		padding-right: inherit;\n\n		/*\n		 * Make sure the table caption placeholder doesn't overflow the placeholder area.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9162.\n		 */\n		white-space: nowrap;\n		overflow: hidden;\n		text-overflow: ellipsis;\n	}\n}\n\n@keyframes ck-table-caption-highlight {\n	0% {\n		background-color: var(--ck-color-selector-caption-highlighted-background);\n	}\n\n	100% {\n		background-color: var(--ck-color-selector-caption-background);\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3964: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecellproperties.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"], names: [], mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n	& .ck-form__row {\n		&.ck-table-cell-properties-form__alignment-row {\n			flex-wrap: wrap;\n\n			& .ck.ck-toolbar {\n				&:first-of-type {\n					/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */\n					flex-grow: 0.57;\n				}\n\n				&:last-of-type {\n					/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */\n					flex-grow: 0.43;\n				}\n\n				& .ck-button {\n					flex-grow: 1;\n				}\n			}\n		}\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n	width: 320px;\n\n	& .ck-form__row {\n		&.ck-table-cell-properties-form__padding-row {\n			align-self: flex-end;\n			padding: 0;\n			width: 25%;\n		}\n\n		&.ck-table-cell-properties-form__alignment-row {\n			& .ck.ck-toolbar {\n				background: none;\n\n				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n				margin-top: var(--ck-spacing-standard);\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7176: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-color-selector-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{overflow-wrap:break-word;position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:0;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:0;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-selector-column-resizer-hover);bottom:-999999px;opacity:.25;top:-999999px}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tablecolumnresize.css"], names: [], mappings: "AAKA,MACC,oEAAqE,CACrE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAIC,wBAAyB,CACzB,iBACD,CAEA,wDAGC,QAAS,CAGT,iBAAkB,CALlB,iBAAkB,CAGlB,oDAAqD,CAFrD,KAAM,CAKN,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,8DAA+D,CAO/D,gBAAiB,CANjB,WAAa,CAKb,aAED,CAEA,iEACC,mDAAoD,CACpD,WACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-selector-column-resizer-hover: var(--ck-color-base-active);\n	--ck-table-column-resizer-width: 7px;\n\n	/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.\n	   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */\n	--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);\n}\n\n.ck-content .table .ck-table-resized {\n	table-layout: fixed;\n}\n\n.ck-content .table table {\n	overflow: hidden;\n}\n\n.ck-content .table td,\n.ck-content .table th {\n	/* To prevent text overflowing beyond its cell when columns are resized by resize handler\n	(https://github.com/ckeditor/ckeditor5/pull/14379#issuecomment-1589460978). */\n	overflow-wrap: break-word;\n	position: relative;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer {\n	position: absolute;\n	top: 0;\n	bottom: 0;\n	right: var(--ck-table-column-resizer-position-offset);\n	width: var(--ck-table-column-resizer-width);\n	cursor: col-resize;\n	user-select: none;\n	z-index: var(--ck-z-default);\n}\n\n.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {\n	display: none;\n}\n\n/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,\n   all resizers must be hidden while the table is dragged. */\n.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {\n	display: none;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer:hover,\n.ck.ck-editor__editable .table .ck-table-column-resizer__active {\n	background-color: var(--ck-color-selector-column-resizer-hover);\n	opacity: 0.25;\n	/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,\n	   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as\n	   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally\n	   unrealistic height for a single table. */\n	top: -999999px;\n	bottom: -999999px;\n}\n\n.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {\n	left: var(--ck-table-column-resizer-position-offset);\n	right: unset;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 8361: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-color-selector-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-selector-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"], names: [], mappings: "AAKA,MACC,gEACD,CAKE,8QAGC,2DAA4D,CAK5D,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-selector-focused-cell-background: hsla(212, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n	& td,\n	& th {\n		&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n		&.ck-editor__nested-editable:focus {\n			/* A very slight background to highlight the focused cell */\n			background: var(--ck-color-selector-focused-cell-background);\n\n			/* Fixes the problem where surrounding cells cover the focused cell's border.\n			It does not fix the problem in all places but the UX is improved.\n			See https://github.com/ckeditor/ckeditor5-table/issues/29. */\n			border-style: none;\n			outline: 1px solid var(--ck-color-focus-border);\n			outline-offset: -1px; /* progressive enhancement - no IE support */\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 9429: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-form {\n	& .ck-form__row {\n		&.ck-table-form__border-row {\n			flex-wrap: wrap;\n		}\n\n		&.ck-table-form__background-row {\n			flex-wrap: wrap;\n		}\n\n		&.ck-table-form__dimensions-row {\n			flex-wrap: wrap;\n			align-items: center;\n\n			& .ck-labeled-field-view {\n				display: flex;\n				flex-direction: column-reverse;\n				align-items: center;\n\n				& .ck.ck-dropdown {\n					flex-grow: 0;\n				}\n			}\n\n			& .ck-table-form__dimension-operator {\n				flex-grow: 0;\n			}\n		}\n	}\n\n	& .ck.ck-labeled-field-view {\n		/* Allow absolute positioning of the status (error) balloons. */\n		position: relative;\n\n		& .ck.ck-labeled-field-view__status {\n			position: absolute;\n			left: 50%;\n			bottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n			transform: translate(-50%,100%);\n\n			/* Make sure the balloon status stays on top of other form elements. */\n			z-index: 1;\n\n			/* The arrow pointing towards the field. */\n			&::after {\n				content: "";\n				position: absolute;\n				top: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n				left: 50%;\n				transform: translateX( -50% );\n			}\n		}\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n:root {\n	--ck-table-properties-error-arrow-size: 6px;\n	--ck-table-properties-min-error-width: 150px;\n}\n\n.ck.ck-table-form {\n	& .ck-form__row {\n		&.ck-table-form__border-row {\n			& .ck-labeled-field-view {\n				& > .ck-label {\n					font-size: var(--ck-font-size-tiny);\n					text-align: center;\n				}\n			}\n\n			& .ck-table-form__border-style,\n			& .ck-table-form__border-width {\n				width: 80px;\n				min-width: 80px;\n				max-width: 80px;\n			}\n		}\n\n		&.ck-table-form__dimensions-row {\n			padding: 0;\n\n			& .ck-table-form__dimensions-row__width,\n			& .ck-table-form__dimensions-row__height {\n				margin: 0\n			}\n\n			& .ck-table-form__dimension-operator {\n				align-self: flex-end;\n				display: inline-block;\n				height: var(--ck-ui-component-min-height);\n				line-height: var(--ck-ui-component-min-height);\n				margin: 0 var(--ck-spacing-small);\n			}\n		}\n	}\n\n	& .ck.ck-labeled-field-view {\n		padding-top: var(--ck-spacing-standard);\n\n		& .ck.ck-labeled-field-view__status {\n			@mixin ck-rounded-corners;\n\n			background: var(--ck-color-base-error);\n			color: var(--ck-color-base-background);\n			padding: var(--ck-spacing-small) var(--ck-spacing-medium);\n			min-width: var(--ck-table-properties-min-error-width);\n			text-align: center;\n\n			/* The arrow pointing towards the field. */\n			&::after {\n				border-color: transparent transparent var(--ck-color-base-error) transparent;\n				border-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);\n				border-style: solid;\n			}\n\n			animation: ck-table-form-labeled-view-status-appear .15s ease both;\n		}\n\n		/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */\n		& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {\n			display: none;\n		}\n	}\n}\n\n@keyframes ck-table-form-labeled-view-status-appear {\n	0% {\n		opacity: 0;\n	}\n\n	100% {\n		opacity: 1;\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 6596: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-table/theme/tableproperties.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"], names: [], mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n	& .ck-form__row {\n		&.ck-table-properties-form__alignment-row {\n			flex-wrap: wrap;\n			flex-basis: 0;\n			align-content: baseline;\n\n			& .ck.ck-toolbar .ck-toolbar__items {\n				flex-wrap: nowrap;\n			}\n		}\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n	width: 320px;\n\n	& .ck-form__row {\n		&.ck-table-properties-form__alignment-row {\n			align-self: flex-end;\n			padding: 0;\n\n			& .ck.ck-toolbar {\n				background: none;\n\n				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n				margin-top: var(--ck-spacing-standard);\n\n				& .ck-toolbar__items > * {\n					width: 40px;\n				}\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 1546: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"], names: [], mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n	& td.ck-editor__editable_selected,\n	& th.ck-editor__editable_selected {\n		position: relative;\n		caret-color: transparent;\n		outline: unset;\n		box-shadow: unset;\n\n		/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n		&:after {\n			content: '';\n			pointer-events: none;\n			background-color: var(--ck-table-selected-cell-background);\n			position: absolute;\n			top: 0;\n			left: 0;\n			right: 0;\n			bottom: 0;\n		}\n\n		& ::selection,\n		&:focus {\n			background-color: transparent;\n		}\n\n		/*\n		 * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9491.\n		 */\n		& .ck-widget {\n			outline: unset;\n\n			& > .ck-widget__selection-handle {\n				display: none;\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3290: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-aria-live-announcer{left:-10000px;position:absolute;top:-10000px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/arialiveannouncer/arialiveannouncer.css"], names: [], mappings: "AAKA,2BAEC,aAAc,CADd,iBAAkB,CAElB,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-aria-live-announcer {\n	position: absolute;\n	left: -10000px;\n	top: -10000px;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4029: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-autocomplete{position:relative}.ck.ck-autocomplete>.ck-search__results{position:absolute;z-index:var(--ck-z-modal)}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{bottom:100%}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{bottom:auto;top:100%}.ck.ck-autocomplete>.ck-search__results{border-radius:0}.ck-rounded-corners .ck.ck-autocomplete>.ck-search__results,.ck.ck-autocomplete>.ck-search__results.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-autocomplete>.ck-search__results{background:var(--ck-color-base-background);border:1px solid var(--ck-color-dropdown-panel-border);box-shadow:var(--ck-drop-shadow),0 0;max-height:200px;min-width:auto;overflow-y:auto}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{border-bottom-left-radius:0;border-bottom-right-radius:0;margin-bottom:-1px}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{border-top-left-radius:0;border-top-right-radius:0;margin-top:-1px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/autocomplete/autocomplete.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/autocomplete/autocomplete.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,oBACC,iBAeD,CAbC,wCACC,iBAAkB,CAClB,yBAUD,CARC,6DACC,WACD,CAEA,6DAEC,WAAY,CADZ,QAED,CCVD,wCCEA,eDuBA,CAzBA,uHCMC,qCDmBD,CAzBA,wCAMC,0CAA2C,CAC3C,sDAAuD,CEPxD,oCAA8B,CFI7B,gBAAiB,CAIjB,cAAe,CAHf,eAoBD,CAfC,6DACC,2BAA4B,CAC5B,4BAA6B,CAG7B,kBACD,CAEA,6DACC,wBAAyB,CACzB,yBAA0B,CAG1B,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-autocomplete {\n	position: relative;\n\n	& > .ck-search__results {\n		position: absolute;\n		z-index: var(--ck-z-modal);\n\n		&.ck-search__results_n {\n			bottom: 100%;\n		}\n\n		&.ck-search__results_s {\n			top: 100%;\n			bottom: auto;\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";\n\n.ck.ck-autocomplete {\n	& > .ck-search__results {\n		@mixin ck-rounded-corners;\n		@mixin ck-drop-shadow;\n\n		max-height: 200px;\n		overflow-y: auto;\n		background: var(--ck-color-base-background);\n		border: 1px solid var(--ck-color-dropdown-panel-border);\n		min-width: auto;\n\n		&.ck-search__results_n {\n			border-bottom-left-radius: 0;\n			border-bottom-right-radius: 0;\n\n			/* Prevent duplicated borders between the input and the results pane. */\n			margin-bottom: -1px;\n		}\n\n		&.ck-search__results_s {\n			border-top-left-radius: 0;\n			border-top-right-radius: 0;\n\n			/* Prevent duplicated borders between the input and the results pane. */\n			margin-top: -1px;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4971: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}[dir=ltr] .ck.ck-button,[dir=ltr] a.ck.ck-button{justify-content:left}[dir=rtl] .ck.ck-button,[dir=rtl] a.ck.ck-button{justify-content:right}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AAQA,6BAMC,kBAAmB,CADnB,mBAAoB,CADpB,iBAAkB,CCHlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD0BD,CA9BA,iDASE,oBAqBF,CA9BA,iDAaE,qBAiBF,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEzBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n@import "../../mixins/_dir.css";\n\n.ck.ck-button,\na.ck.ck-button {\n	@mixin ck-unselectable;\n\n	position: relative;\n	display: inline-flex;\n	align-items: center;\n\n	@mixin ck-dir ltr {\n		justify-content: left;\n	}\n\n	@mixin ck-dir rtl {\n		justify-content: right;\n	}\n\n	& .ck-button__label {\n		display: none;\n	}\n\n	&.ck-button_with-text {\n		& .ck-button__label {\n			display: inline-block;\n		}\n	}\n\n	/* Center the icon horizontally in a button without text. */\n	&:not(.ck-button_with-text)  {\n		justify-content: center;\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-button-colors --ck-color-button-default;
	@mixin ck-rounded-corners;

	white-space: nowrap;
	cursor: default;
	vertical-align: middle;
	padding: var(--ck-spacing-tiny);
	text-align: center;

	/* A very important piece of styling. Go to variable declaration to learn more. */
	min-width: var(--ck-ui-component-min-height);
	min-height: var(--ck-ui-component-min-height);

	/* Normalize the height of the line. Removing this will break consistent height
	among text and text-less buttons (with icons). */
	line-height: 1;

	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	/* Avoid flickering when the foucs border shows up. */
	border: 1px solid transparent;

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .2s ease-in-out, border .2s ease-in-out;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */
	-webkit-appearance: none;

	&:active,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	/* Allow icon coloring using the text "color" property. */
	& .ck-button__icon {
		& use,
		& use * {
			color: inherit;
		}
	}

	& .ck-button__label {
		/* Enable font size inheritance, which allows fluid UI scaling. */
		font-size: inherit;
		font-weight: inherit;
		color: inherit;
		cursor: inherit;

		/* Must be consistent with .ck-icon's vertical align. Otherwise, buttons with and
		without labels (but with icons) have different sizes in Chrome */
		vertical-align: middle;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& .ck-button__keystroke {
		color: inherit;

		@mixin ck-dir ltr {
			margin-left: var(--ck-spacing-large);
		}

		@mixin ck-dir rtl {
			margin-right: var(--ck-spacing-large);
		}

		font-weight: bold;
		opacity: .7;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
	&.ck-disabled {
		&:active,
		&:focus {
			/* The disabled button should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}

		& .ck-button__icon {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
		& .ck-button__label {
			@mixin ck-disabled;
		}

		& .ck-button__keystroke {
			opacity: .3;
		}
	}

	&.ck-button_with-text {
		padding: var(--ck-spacing-tiny) var(--ck-spacing-standard);

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__icon {
			@mixin ck-dir ltr {
				margin-left: calc(-1 * var(--ck-spacing-small));
				margin-right: var(--ck-spacing-small);
			}

			@mixin ck-dir rtl {
				margin-right: calc(-1 * var(--ck-spacing-small));
				margin-left: var(--ck-spacing-small);
			}
		}
	}

	&.ck-button_with-keystroke {
		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__label {
			flex-grow: 1;
		}
	}

	/* A style of the button which is currently on, e.g. its feature is active. */
	&.ck-on {
		@mixin ck-button-colors --ck-color-button-on;

		color: var(--ck-color-button-on-color);
	}

	&.ck-button-save {
		color: var(--ck-color-button-save);
	}

	&.ck-button-cancel {
		color: var(--ck-color-button-cancel);
	}
}

/* A style of the button which handles the primary action. */
.ck.ck-button-action,
a.ck.ck-button-action {
	@mixin ck-button-colors --ck-color-button-action;

	color: var(--ck-color-button-action-text);
}

.ck.ck-button-bold,
a.ck.ck-button-bold {
	font-weight: bold;
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n	background: var($(prefix)-background);\n\n	&:not(.ck-disabled) {\n		&:hover {\n			background: var($(prefix)-hover-background);\n		}\n\n		&:active {\n			background: var($(prefix)-active-background);\n		}\n	}\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n	&.ck-disabled {\n		background: var($(prefix)-disabled-background);\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7258: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n	& .ck-button__toggle {\n		display: block;\n\n		& .ck-button__toggle__inner {\n			display: block;\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floatingpoint numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n	/* 34px at 13px font-size */\n	--ck-switch-button-toggle-width: 2.6153846154em;\n	/* 14px at 13px font-size */\n	--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n	--ck-switch-button-translation: calc(\n		var(--ck-switch-button-toggle-width) -\n		var(--ck-switch-button-toggle-inner-size) -\n		2px /* Border */\n	);\n	--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n	/* Unlike a regular button, the switch button text color and background should never change.\n	 * Changing toggle switch (background, outline) is enough to carry the information about the\n	 * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n	 */\n	&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n		color: inherit;\n		background: transparent;\n	}\n\n	& .ck-button__label {\n		@mixin ck-dir ltr {\n			/* Separate the label from the switch */\n			margin-right: calc(2 * var(--ck-spacing-large));\n		}\n\n		@mixin ck-dir rtl {\n			/* Separate the label from the switch */\n			margin-left: calc(2 * var(--ck-spacing-large));\n		}\n	}\n\n	& .ck-button__toggle {\n		@mixin ck-rounded-corners;\n\n		@mixin ck-dir ltr {\n			/* Make sure the toggle is always to the right as far as possible. */\n			margin-left: auto;\n		}\n\n		@mixin ck-dir rtl {\n			/* Make sure the toggle is always to the left as far as possible. */\n			margin-right: auto;\n		}\n\n		/* Apply some smooth transition to the box-shadow and border. */\n		/* Gently animate the background color of the toggle switch */\n		transition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n		border: 1px solid transparent;\n		width: var(--ck-switch-button-toggle-width);\n		background: var(--ck-color-switch-button-off-background);\n\n		& .ck-button__toggle__inner {\n			@mixin ck-rounded-corners {\n				border-radius: calc(.5 * var(--ck-border-radius));\n			}\n\n			width: var(--ck-switch-button-toggle-inner-size);\n			height: var(--ck-switch-button-toggle-inner-size);\n			background: var(--ck-color-switch-button-inner-background);\n\n			/* Gently animate the inner part of the toggle switch */\n			transition: all 300ms ease;\n		}\n\n		&:hover {\n			background: var(--ck-color-switch-button-off-hover-background);\n\n			& .ck-button__toggle__inner {\n				box-shadow: var(--ck-switch-button-inner-hover-shadow);\n			}\n		}\n	}\n\n	&.ck-disabled .ck-button__toggle {\n		@mixin ck-disabled;\n	}\n\n	/* Overriding default .ck-button:focus styles + an outline around the toogle */\n	&:focus {\n		border-color: transparent;\n		outline: none;\n		box-shadow: none;\n\n		& .ck-button__toggle {\n			box-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n			outline-offset: 1px;\n			outline: var(--ck-focus-ring);\n		}\n	}\n\n	/* stylelint-disable-next-line no-descending-specificity */\n	&.ck-on {\n		& .ck-button__toggle {\n			background: var(--ck-color-switch-button-on-background);\n\n			&:hover {\n				background: var(--ck-color-switch-button-on-hover-background);\n			}\n\n			& .ck-button__toggle__inner {\n				/*\n				* Move the toggle switch to the right. It will be animated.\n				*/\n				@mixin ck-dir ltr {\n					transform: translateX( var( --ck-switch-button-translation ) );\n				}\n\n				@mixin ck-dir rtl {\n					transform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n				}\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4923: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-selector__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"], names: [], mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,+DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n	display: grid;\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-grid-tile-size: 24px;

	/* Not using global colors here because these may change but some colors in a pallette
	 * require special treatment. For instance, this ensures no matter what the UI text color is,
	 * the check icon will look good on the black color tile. */
	--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);
}

.ck.ck-color-grid {
	grid-gap: 5px;
	padding: 8px;
}

.ck.ck-color-grid__tile {
	width: var(--ck-color-grid-tile-size);
	height: var(--ck-color-grid-tile-size);
	min-width: var(--ck-color-grid-tile-size);
	min-height: var(--ck-color-grid-tile-size);
	padding: 0;
	transition: .2s ease box-shadow;
	border: 0;

	&.ck-disabled {
		cursor: unset;
		transition: unset;
	}

	&.ck-color-selector__color-tile_bordered {
		box-shadow: 0 0 0 1px var(--ck-color-base-border);
	}

	& .ck.ck-icon {
		display: none;
		color: var(--ck-color-color-grid-check-icon);
	}

	&.ck-on {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);

		& .ck.ck-icon {
			display: block;
		}
	}

	&.ck-on,
	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		/* Disable the default .ck-button's border ring. */
		border: 0;
	}

	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
	}
}

.ck.ck-color-grid__label {
	padding: 0 var(--ck-spacing-standard);
}
`], sourceRoot: "" }]);
        const a2 = s2;
      }, 4257: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;margin:var(--ck-spacing-large) 0 0;width:unset}.ck.ck-color-picker__row .ck.ck-labeled-field-view{padding-top:unset}.ck.ck-color-picker__row .ck.ck-input-text{width:unset}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorpicker/colorpicker.css"], names: [], mappings: "AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAA8B,CAC9B,kCAAmC,CACnC,WAcD,CAZC,mDACC,iBACD,CAEA,2CACC,WACD,CAEA,qDAEC,sCAAuC,CADvC,kCAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.color-picker-hex-input {\n	width: max-content;\n\n	& .ck.ck-input {\n		min-width: unset;\n	}\n}\n\n.ck.ck-color-picker__row {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	justify-content: space-between;\n	margin: var(--ck-spacing-large) 0 0;\n	width: unset;\n\n	& .ck.ck-labeled-field-view {\n		padding-top: unset;\n	}\n\n	& .ck.ck-input-text {\n		width: unset;\n	}\n\n	& .ck-color-picker__hash-view {\n		padding-top: var(--ck-spacing-tiny);\n		padding-right: var(--ck-spacing-medium);\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 6306: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{align-items:center;display:flex}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{justify-content:flex-start}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{display:flex;flex-direction:row;justify-content:space-around}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-cancel,.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-save{flex:1}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{width:100%}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker{padding:8px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker{height:100px;min-width:180px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{padding:0 8px 8px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorselector/colorselector.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorselector/colorselector.css"], names: [], mappings: "AAUE,oLAGC,kBAAmB,CADnB,YAMD,CARA,wMAME,0BAEF,CAKA,iFACC,YAAa,CACb,kBAAmB,CACnB,4BAMD,CAJC,oMAEC,MACD,CCrBD,oLAEC,UACD,CAEA,0FAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,sGACC,gDACD,CAEA,gHAEE,uCAMF,CARA,gHAME,sCAEF,CAGD,6EACC,iBACD,CAKA,oEACC,WAoBD,CAlBC,sFACC,YAAa,CACb,eAeD,CAbC,wGACC,iEACD,CAEA,iGACC,iEACD,CAEA,yNAGC,WAAY,CADZ,UAED,CAIF,iFACC,iBACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n	/* View fragment with color grids. */\n	& .ck-color-grids-fragment {\n		& .ck-button.ck-color-selector__remove-color,\n		& .ck-button.ck-color-selector__color-picker {\n			display: flex;\n			align-items: center;\n\n			@mixin ck-dir rtl {\n				justify-content: flex-start;\n			}\n		}\n	}\n\n	/* View fragment with a color picker. */\n	& .ck-color-picker-fragment {\n		& .ck.ck-color-selector_action-bar {\n			display: flex;\n			flex-direction: row;\n			justify-content: space-around;\n\n			& .ck-button-save,\n			& .ck-button-cancel {\n				flex: 1\n			}\n		}\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n	/* View fragment with color grids. */\n	& .ck-color-grids-fragment {\n		& .ck-button.ck-color-selector__remove-color,\n		& .ck-button.ck-color-selector__color-picker {\n			width: 100%;\n		}\n\n		& .ck-button.ck-color-selector__color-picker {\n			padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n			border-bottom-left-radius: 0;\n			border-bottom-right-radius: 0;\n\n			&:not(:focus) {\n				border-top: 1px solid var(--ck-color-base-border);\n			}\n\n			& .ck.ck-icon {\n				@mixin ck-dir ltr {\n					margin-right: var(--ck-spacing-standard);\n				}\n\n				@mixin ck-dir rtl {\n					margin-left: var(--ck-spacing-standard);\n				}\n			}\n		}\n\n		& label.ck.ck-color-grid__label {\n			font-weight: unset;\n		}\n	}\n\n	/* View fragment with a color picker. */\n	& .ck-color-picker-fragment {\n		& .ck.ck-color-picker {\n			padding: 8px;\n\n			& .hex-color-picker {\n				height: 100px;\n				min-width: 180px;\n\n				&::part(saturation) {\n					border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n				}\n\n				&::part(hue) {\n					border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n				}\n\n				&::part(saturation-pointer),\n				&::part(hue-pointer) {\n					width: 15px;\n					height: 15px;\n				}\n			}\n		}\n\n		& .ck.ck-color-selector_action-bar {\n			padding: 0 8px 8px;\n		}\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 5062: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}.ck.ck-dropdown__panel:focus{outline:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eHkHD,CAhCA,qFG9EE,qCH8GF,CAhCA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAuBD,CAnBC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD,CAEA,6BACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n	display: inline-block;\n	position: relative;\n\n	& .ck-dropdown__arrow {\n		pointer-events: none;\n		z-index: var(--ck-z-default);\n	}\n\n	/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n	& .ck-button.ck-dropdown__button {\n		width: 100%;\n	}\n\n	& .ck-dropdown__panel {\n		display: none;\n		z-index: var(--ck-z-modal);\n		max-width: var(--ck-dropdown-max-width);\n\n		position: absolute;\n\n		&.ck-dropdown__panel-visible {\n			display: inline-block;\n		}\n\n		&.ck-dropdown__panel_ne,\n		&.ck-dropdown__panel_nw,\n		&.ck-dropdown__panel_n,\n		&.ck-dropdown__panel_nmw,\n		&.ck-dropdown__panel_nme {\n			bottom: 100%;\n		}\n\n		&.ck-dropdown__panel_se,\n		&.ck-dropdown__panel_sw,\n		&.ck-dropdown__panel_smw,\n		&.ck-dropdown__panel_sme,\n		&.ck-dropdown__panel_s {\n			/*\n			 * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n			 * See https://github.com/ckeditor/ckeditor5/issues/1053.\n			 */\n			top: 100%;\n			bottom: auto;\n		}\n\n		&.ck-dropdown__panel_ne,\n		&.ck-dropdown__panel_se {\n			left: 0px;\n		}\n\n		&.ck-dropdown__panel_nw,\n		&.ck-dropdown__panel_sw {\n			right: 0px;\n		}\n\n		&.ck-dropdown__panel_s,\n		&.ck-dropdown__panel_n {\n			/* Positioning panels relative to the center of the button */\n			left: 50%;\n			transform: translateX(-50%);\n		}\n\n		&.ck-dropdown__panel_nmw,\n		&.ck-dropdown__panel_smw {\n			/* Positioning panels relative to the middle-west of the button */\n			left: 75%;\n			transform: translateX(-75%);\n		}\n\n		&.ck-dropdown__panel_nme,\n		&.ck-dropdown__panel_sme {\n			/* Positioning panels relative to the middle-east of the button */\n			left: 25%;\n			transform: translateX(-25%);\n		}\n	}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n	z-index: calc( var(--ck-z-modal) + 1 );\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-dropdown {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-dropdown__arrow {
		width: var(--ck-dropdown-arrow-size);
	}

	@mixin ck-dir ltr {
		& .ck-dropdown__arrow {
			right: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-dropdown__arrow {
			left: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-right: var(--ck-spacing-small);
		}
	}

	&.ck-disabled .ck-dropdown__arrow {
		@mixin ck-disabled;
	}

	& .ck-button.ck-dropdown__button {
		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-right: var(--ck-spacing-small);
			}
		}

		/* #23 */
		& .ck-button__label {
			width: 7em;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
		&.ck-disabled .ck-button__label {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/816 */
		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		&.ck-dropdown__button_label-width_auto .ck-button__label {
			width: auto;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/8699 */
		&.ck-off:active,
		&.ck-on:active {
			box-shadow: none;

			&:focus {
				@mixin ck-box-shadow var(--ck-focus-outer-shadow);
			}
		}
	}
}

.ck.ck-dropdown__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;

	/* Make sure the panel is at least as wide as the drop-down's button. */
	min-width: 100%;

	/* Disabled corner border radius to be consistent with the .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-dropdown__panel_se {
		border-top-left-radius: 0;
	}

	&.ck-dropdown__panel_sw {
		border-top-right-radius: 0;
	}

	&.ck-dropdown__panel_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-dropdown__panel_nw {
		border-bottom-right-radius: 0;
	}

	&:focus {
		outline: none;
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 1883: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n	/* Disabled radius of top-left border to be consistent with .dropdown__button\n	https://github.com/ckeditor/ckeditor5/issues/816 */\n	@mixin ck-rounded-corners {\n		border-top-left-radius: 0;\n	}\n\n	/* Make sure the button belonging to the first/last child of the list goes well with the\n	border radius of the entire panel. */\n	& .ck-list__item {\n		&:first-child .ck-button {\n			@mixin ck-rounded-corners {\n				border-top-left-radius: 0;\n				border-bottom-left-radius: 0;\n				border-bottom-right-radius: 0;\n			}\n		}\n\n		&:last-child .ck-button {\n			@mixin ck-rounded-corners {\n				border-top-left-radius: 0;\n				border-top-right-radius: 0;\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4791: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n	/* Enable font size inheritance, which allows fluid UI scaling. */\n	font-size: inherit;\n\n	& .ck-splitbutton__action:focus {\n		z-index: calc(var(--ck-z-default) + 1);\n	}\n}\n\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-split-button-hover-background: hsl(0, 0%, 92%);
	--ck-color-split-button-hover-border: hsl(0, 0%, 70%);
}

.ck.ck-splitbutton {
	/*
	 * Note: ck-rounded and ck-dir mixins don't go together (because they both use @nest).
	 */
	&:hover > .ck-splitbutton__action,
	&.ck-splitbutton_open > .ck-splitbutton__action {
		@nest [dir="ltr"] & {
			/* Don't round the action button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the action button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}
	}

	& > .ck-splitbutton__arrow {
		/* It's a text-less button and since the icon is positioned absolutely in such situation,
		it must get some arbitrary min-width. */
		min-width: unset;

		@nest [dir="ltr"] & {
			/* Don't round the arrow button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the arrow button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		& svg {
			width: var(--ck-dropdown-arrow-size);
		}
	}

	/* Make sure the divider stretches 100% height of the button
	https://github.com/ckeditor/ckeditor5/issues/10936 */
	& > .ck-splitbutton__arrow:not(:focus) {
		border-top-width: 0px;
		border-bottom-width: 0px;
	}

	/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling
	as a whole. The background of both buttons should stand out and there should be a visual
	separation between both buttons. */
	&.ck-splitbutton_open,
	&:hover {
		/* When the split button hovered as a whole, not as individual buttons. */
		& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {
			background: var(--ck-color-split-button-hover-background);
		}

		/* Splitbutton separator needs to be set with the ::after pseudoselector
		to display properly the borders on focus */
		& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
			content: '';
			position: absolute;
			width: 1px;
			height: 100%;
			background-color: var(--ck-color-split-button-hover-border);
		}

		/* Make sure the divider between the buttons looks fine when the button is focused */
		& > .ck-splitbutton__arrow:focus::after {
			--ck-color-split-button-hover-border: var(--ck-color-focus-border);
		}

		@nest [dir="ltr"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				left: -1px;
			}
		}

		@nest [dir="rtl"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				right: -1px;
			}
		}
	}

	/* Don't round the bottom left and right corners of the buttons when "open"
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-splitbutton_open {
		@mixin ck-rounded-corners {
			& > .ck-splitbutton__action {
				border-bottom-left-radius: 0;
			}

			& > .ck-splitbutton__arrow {
				border-bottom-right-radius: 0;
			}
		}
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2704: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"], names: [], mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n	/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n	width: max-content;\n	max-width: var(--ck-toolbar-dropdown-max-width);\n\n	& .ck-button {\n		&:focus {\n			z-index: calc(var(--ck-z-default) + 1);\n		}\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n	border: 0;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 9847: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,oDACD,CAIA,gEACC,iDACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n	--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n	@mixin ck-rounded-corners;\n\n	&.ck-focused {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-inner-shadow);\n	}\n}\n\n.ck.ck-editor__editable_inline {\n	overflow: auto;\n	padding: 0 var(--ck-spacing-standard);\n	border: 1px solid transparent;\n\n	&[dir="ltr"] {\n		text-align: left;\n	}\n\n	&[dir="rtl"] {\n		text-align: right;\n	}\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n	& > *:first-child {\n		margin-top: var(--ck-spacing-large);\n	}\n\n	/* https://github.com/ckeditor/ckeditor5/issues/847 */\n	& > *:last-child {\n		/*\n		 * This value should match with the default margins of the block elements (like .media or .image)\n		 * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n		 */\n		margin-bottom: var(--ck-spacing-large);\n	}\n\n	/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n	&.ck-blurred ::selection {\n		background: var(--ck-color-editable-blur-selection);\n	}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n	&::after {\n		border-bottom-color: var(--ck-color-panel-background);\n	}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n	&::after {\n		border-top-color: var(--ck-color-panel-background);\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 1874: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__header h2.ck-form__header__label{flex-grow:1}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}[dir=ltr] .ck.ck-form__header .ck-icon{margin-right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-form__header .ck-icon{margin-left:var(--ck-spacing-medium)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"], names: [], mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BAKD,CAHC,8CACC,WACD,CCPD,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAkBD,CAbC,uCAEE,qCAMF,CARA,uCAME,oCAEF,CAEA,4CACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	align-items: center;\n	justify-content: space-between;\n\n	& h2.ck-form__header__label {\n		flex-grow: 1;\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n	--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n	padding: var(--ck-spacing-small) var(--ck-spacing-large);\n	height: var(--ck-form-header-height);\n	line-height: var(--ck-form-header-height);\n	border-bottom: 1px solid var(--ck-color-base-border);\n\n	& .ck-icon {\n		@mixin ck-dir ltr {\n			margin-right: var(--ck-spacing-medium);\n		}\n\n		@mixin ck-dir rtl {\n			margin-left: var(--ck-spacing-medium);\n		}\n	}\n\n	& .ck-form__header__label {\n		font-weight: bold;\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 4746: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-highlighted-text mark{background:var(--ck-color-highlight-background);font-size:inherit;font-weight:inherit;line-height:inherit;vertical-align:initial}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/highlightedtext/highlightedtext.css"], names: [], mappings: "AAKA,6BACC,+CAAgD,CAIhD,iBAAkB,CAFlB,mBAAoB,CACpB,mBAAoB,CAFpB,sBAID", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-highlighted-text mark {\n	background: var(--ck-color-highlight-background);\n	vertical-align: initial;\n	font-weight: inherit;\n	line-height: inherit;\n	font-size: inherit;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 1977: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"], names: [], mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n	vertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n	width: var(--ck-icon-size);\n	height: var(--ck-icon-size);\n\n	/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n	font-size: .8333350694em;\n\n	/* Inherit cursor style (#5). */\n	cursor: inherit;\n\n	/* This will prevent blurry icons on Firefox. See #340. */\n	will-change: transform;\n\n	& * {\n		/* Inherit cursor style (#5). */\n		cursor: inherit;\n	}\n\n	/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n	&.ck-icon_inherit-color {\n		color: inherit;\n\n		& * {\n			color: inherit;\n\n			&:not([fill]) {\n				/* Needed by FF. */\n				fill: currentColor;\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 2470: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-input-width: 18em;\n\n	/* Backward compatibility. */\n	--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n	@mixin ck-rounded-corners;\n\n	background: var(--ck-color-input-background);\n	border: 1px solid var(--ck-color-input-border);\n	padding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n	min-width: var(--ck-input-width);\n\n	/* This is important to stay of the same height as surrounding buttons */\n	min-height: var(--ck-ui-component-min-height);\n\n	/* Apply some smooth transition to the box-shadow and border. */\n	transition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n	&:focus {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n	}\n\n	&[readonly] {\n		border: 1px solid var(--ck-color-input-disabled-border);\n		background: var(--ck-color-input-disabled-background);\n		color: var(--ck-color-input-disabled-text);\n\n		&:focus {\n			/* The read-only input should have a slightly less visible shadow when focused. */\n			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n		}\n	}\n\n	&.ck-error {\n		border-color: var(--ck-color-input-error-border);\n		animation: ck-input-shake .3s ease both;\n\n		&:focus {\n			@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n		}\n	}\n}\n\n@keyframes ck-input-shake {\n	20% {\n		transform: translateX(-2px);\n	}\n\n	40% {\n		transform: translateX(2px);\n	}\n\n	60% {\n		transform: translateX(-1px);\n	}\n\n	80% {\n		transform: translateX(1px);\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3525: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"], names: [], mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n	display: block;\n}\n\n.ck.ck-voice-label {\n	display: none;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n	font-weight: bold;\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2933: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0;transform:translate(calc(var(--ck-spacing-medium)*-1),-6px) scale(.75);transform-origin:100% 0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD+GD,CA1GA,2FCDE,qCD2GF,CAvGC,mEACC,UAoCD,CAlCC,gFACC,KAgCD,CAjCA,0FAIE,MAAS,CAGT,6DAA+D,CAF/D,oBA4BF,CAjCA,0FAWE,OAAU,CAEV,sEAA0E,CAD1E,uBAqBF,CAjCA,gFAkBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAH9C,mBAAoB,CAQpB,sBAAuB,CAKvB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n	& > .ck.ck-labeled-field-view__input-wrapper {\n		display: flex;\n		position: relative;\n	}\n\n	& .ck.ck-label {\n		display: block;\n		position: absolute;\n	}\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../../../mixins/_rounded.css";

:root {
	--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);
	--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));
	--ck-color-labeled-field-label-background: var(--ck-color-base-background);
}

.ck.ck-labeled-field-view {
	@mixin ck-rounded-corners;

	& > .ck.ck-labeled-field-view__input-wrapper {
		width: 100%;

		& > .ck.ck-label {
			top: 0px;

			@mixin ck-dir ltr {
				left: 0px;
				transform-origin: 0 0;
				/* By default, display the label scaled down above the field. */
				transform: translate(var(--ck-spacing-medium), -6px) scale(.75);
			}

			@mixin ck-dir rtl {
				right: 0px;
				transform-origin: 100% 0;
				transform: translate(calc(-1 * var(--ck-spacing-medium)), -6px) scale(.75);
			}

			pointer-events: none;

			background: var(--ck-color-labeled-field-label-background);
			padding: 0 calc(.5 * var(--ck-font-size-tiny));
			line-height: initial;
			font-weight: normal;

			/* Prevent overflow when the label is longer than the input */
			text-overflow: ellipsis;
			overflow: hidden;

			max-width: 100%;

			transition:
				transform var(--ck-labeled-field-view-transition),
				padding var(--ck-labeled-field-view-transition),
				background var(--ck-labeled-field-view-transition);
		}
	}

	&.ck-error {
		& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
			color: var(--ck-color-base-error);
		}

		& .ck-input:not([readonly]) + .ck.ck-label {
			color: var(--ck-color-base-error);
		}
	}

	& .ck-labeled-field-view__status {
		font-size: var(--ck-font-size-small);
		margin-top: var(--ck-spacing-small);

		/* Let the info wrap to the next line to avoid stretching the layout horizontally.
		The status could be very long. */
		white-space: normal;

		&.ck-labeled-field-view__status_error {
			color: var(--ck-color-base-error);
		}
	}

	/* Disabled fields and fields that have no focus should fade out. */
	&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		color: var(--ck-color-input-disabled-text);
	}

	/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */
	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		@mixin ck-dir ltr {
			transform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		@mixin ck-dir rtl {
			transform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		/* Compensate for the default translate position. */
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));

		background: transparent;
		padding: 0;
	}

	/*------ DropdownView integration ----------------------------------------------------------------------------------- */

	/* Make sure dropdown' background color in any of dropdown's state does not collide with labeled field. */
	& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {
		background: transparent;
	}

	/* When the dropdown is "empty", the labeled field label replaces its label. */
	&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {
		opacity: 0;
	}

	/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 179: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;width:100%}[dir=ltr] .ck.ck-list__item .ck-button{text-align:left}[dir=rtl] .ck.ck-list__item .ck-button{text-align:right}.ck.ck-list__item .ck-button{padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base))}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck-list .ck-list__group{padding-top:var(--ck-spacing-medium);:not(.ck-hidden)~&{border-top:1px solid var(--ck-color-base-border)}}.ck-list .ck-list__group>.ck-label{font-size:11px;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-medium) 0 var(--ck-spacing-medium)}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEdD,YCCC,eDID,CALA,+DCKE,qCDAF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cAkED,CAhEC,6BAGC,eAAgB,CAFhB,gBAAiB,CACjB,UA+CD,CAjDA,uCAME,eA2CF,CAjDA,uCAUE,gBAuCF,CAjDA,6BAgBC,iIAiCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,yBACC,oCAAqC,CAGrC,mBACC,gDACD,CAOD,CALC,mCACC,cAAe,CACf,eAAiB,CACjB,oFACD,CAGD,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n	@mixin ck-unselectable;\n\n	display: flex;\n	flex-direction: column;\n\n	& .ck-list__item,\n	& .ck-list__separator {\n		display: block;\n	}\n\n	/* Make sure that whatever child of the list item gets focus, it remains on the\n	top. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n	adjacent list items. */\n	& .ck-list__item > *:focus {\n		position: relative;\n		z-index: var(--ck-z-default);\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-list {
	@mixin ck-rounded-corners;

	list-style-type: none;
	background: var(--ck-color-list-background);
}

.ck.ck-list__item {
	cursor: default;
	min-width: 12em;

	& .ck-button {
		min-height: unset;
		width: 100%;
		border-radius: 0;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}

		/* List items should have the same height. Use absolute units to make sure it is so
		   because e.g. different heading styles may have different height
		   https://github.com/ckeditor/ckeditor5-heading/issues/63 */
		padding:
			calc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))
			calc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));

		& .ck-button__label {
			/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */
			line-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));
		}

		&:active {
			box-shadow: none;
		}

		&.ck-on {
			background: var(--ck-color-list-button-on-background);
			color: var(--ck-color-list-button-on-text);

			&:active {
				box-shadow: none;
			}

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-on-background-focus);
			}

			&:focus:not(.ck-switchbutton):not(.ck-disabled) {
				border-color: var(--ck-color-base-background);
			}
		}

		&:hover:not(.ck-disabled) {
			background: var(--ck-color-list-button-hover-background);
		}
	}

	/* It's unnecessary to change the background/text of a switch toggle; it has different ways
	of conveying its state (like the switcher) */
	& .ck-switchbutton {
		&.ck-on {
			background: var(--ck-color-list-background);
			color: inherit;

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-hover-background);
				color: inherit;
			}
		}
	}
}

.ck-list .ck-list__group {
	padding-top: var(--ck-spacing-medium);

	/* The group should have a border when it's not the first item. */
	*:not(.ck-hidden) ~ & {
		border-top: 1px solid var(--ck-color-base-border);
	}

	& > .ck-label {
		font-size: 11px;
		font-weight: bold;
		padding: var(--ck-spacing-medium) var(--ck-spacing-medium) 0 var(--ck-spacing-medium);
	}
}

.ck.ck-list__separator {
	height: 1px;
	width: 100%;
	background: var(--ck-color-base-border);
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4460: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/* Make sure the balloon arrow does not float over its children. */\n	--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n	display: none;\n	position: absolute;\n\n	z-index: var(--ck-z-modal);\n\n	&.ck-balloon-panel_with-arrow {\n		&::before,\n		&::after {\n			content: "";\n			position: absolute;\n		}\n\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&[class*="arrow_n"] {\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&[class*="arrow_s"] {\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&.ck-balloon-panel_visible {\n		display: block;\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-balloon-border-width: 1px;\n	--ck-balloon-arrow-offset: 2px;\n	--ck-balloon-arrow-height: 10px;\n	--ck-balloon-arrow-half-width: 8px;\n	--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n	@mixin ck-rounded-corners;\n	@mixin ck-drop-shadow;\n\n	min-height: 15px;\n\n	background: var(--ck-color-panel-background);\n	border: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n	&.ck-balloon-panel_with-arrow {\n		&::before,\n		&::after {\n			width: 0;\n			height: 0;\n			border-style: solid;\n		}\n	}\n\n	&[class*="arrow_n"] {\n		&::before,\n		&::after {\n			border-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n		}\n\n		&::before {\n			border-color: transparent transparent var(--ck-color-panel-border) transparent;\n			margin-top: calc( -1 * var(--ck-balloon-border-width) );\n		}\n\n		&::after {\n			border-color: transparent transparent var(--ck-color-panel-background) transparent;\n			margin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n		}\n	}\n\n	&[class*="arrow_s"] {\n		&::before,\n		&::after {\n			border-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n		}\n\n		&::before {\n			border-color: var(--ck-color-panel-border) transparent transparent;\n			filter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n			margin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n		}\n\n		&::after {\n			border-color: var(--ck-color-panel-background) transparent transparent transparent;\n			margin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n		}\n	}\n\n	&[class*="arrow_e"] {\n		&::before,\n		&::after {\n			border-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n		}\n\n		&::before {\n			border-color: transparent transparent transparent var(--ck-color-panel-border);\n			margin-right: calc( -1 * var(--ck-balloon-border-width) );\n		}\n\n		&::after {\n			border-color: transparent transparent transparent var(--ck-color-panel-background);\n			margin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n		}\n	}\n\n	&[class*="arrow_w"] {\n		&::before,\n		&::after {\n			border-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n		}\n\n		&::before {\n			border-color: transparent var(--ck-color-panel-border) transparent transparent;\n			margin-left: calc( -1 * var(--ck-balloon-border-width) );\n		}\n\n		&::after {\n			border-color: transparent var(--ck-color-panel-background) transparent transparent;\n			margin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n		}\n	}\n\n	&.ck-balloon-panel_arrow_n {\n		&::before,\n		&::after {\n			left: 50%;\n			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nw {\n		&::before,\n		&::after {\n			left: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_ne {\n		&::before,\n		&::after {\n			right: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_s {\n		&::before,\n		&::after {\n			left: 50%;\n			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_sw {\n		&::before,\n		&::after {\n			left: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_se {\n		&::before,\n		&::after {\n			right: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_sme {\n		&::before,\n		&::after {\n			right: 25%;\n			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_smw {\n		&::before,\n		&::after {\n			left: 25%;\n			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nme {\n		&::before,\n		&::after {\n			right: 25%;\n			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nmw {\n		&::before,\n		&::after {\n			left: 25%;\n			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_e {\n		&::before,\n		&::after {\n			right: calc(-1 * var(--ck-balloon-arrow-height));\n			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n			top: 50%;\n		}\n	}\n\n	&.ck-balloon-panel_arrow_w {\n		&::before,\n		&::after {\n			left: calc(-1 * var(--ck-balloon-arrow-height));\n			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n			top: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7592: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"], names: [], mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n	display: flex;\n	align-items: center;\n	justify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n	justify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n	background: var(--ck-color-toolbar-background);\n	border-bottom: 1px solid var(--ck-color-toolbar-border);\n	padding: 0 var(--ck-spacing-small);\n\n	/* Let's keep similar appearance to `ck-toolbar`. */\n	& > * {\n		margin-right: var(--ck-spacing-small);\n		margin-top: var(--ck-spacing-small);\n		margin-bottom: var(--ck-spacing-small);\n	}\n\n	/* Gives counter more breath than buttons. */\n	& .ck-balloon-rotator__counter {\n		margin-right: var(--ck-spacing-standard);\n\n		/* We need to use smaller margin because of previous button's right margin. */\n		margin-left: var(--ck-spacing-small);\n	}\n}\n\n.ck .ck-balloon-rotator__content {\n\n	/* Disable default annotation shadow inside rotator with fake panels. */\n	& .ck.ck-annotation-wrapper {\n		box-shadow: none;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 6356: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n	position: absolute;\n\n	/* Fake panels should be placed under main balloon content. */\n	z-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n	position: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n	z-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n	z-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-balloon-fake-panel-offset-horizontal: 6px;\n	--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n	@mixin ck-drop-shadow;\n\n	min-height: 15px;\n\n	background: var(--ck-color-panel-background);\n	border: 1px solid var(--ck-color-panel-border);\n	border-radius: var(--ck-border-radius);\n\n	width: 100%;\n	height: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n	margin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n	margin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n	--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3707: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n	& .ck-sticky-panel__content_sticky {\n		z-index: var(--ck-z-modal); /* #315 */\n		position: fixed;\n		top: 0;\n	}\n\n	& .ck-sticky-panel__content_sticky_bottom-limit {\n		top: auto;\n		position: absolute;\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n	& .ck-sticky-panel__content_sticky {\n		@mixin ck-drop-shadow;\n\n		border-width: 0 1px 1px;\n		border-top-left-radius: 0;\n		border-top-right-radius: 0;\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 6603: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"], names: [], mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n	&::after {\n		content: "";\n		width: 0;\n		position: absolute;\n		right: -1px;\n		top: -1px;\n		bottom: -1px;\n		z-index: 1;\n	}\n\n	&:focus::after {\n		display: none;\n	}\n}\n\n.ck.ck-responsive-form {\n	@mixin ck-media-phone {\n		& .ck-button {\n			&::after {\n				content: "";\n				width: 0;\n				position: absolute;\n				right: -1px;\n				top: -1px;\n				bottom: -1px;\n				z-index: 1;\n			}\n\n			&:focus::after {\n				display: none;\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n	border-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n	padding: var(--ck-spacing-large);\n\n	&:focus {\n		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n		outline: none;\n	}\n\n	@mixin ck-dir ltr {\n		& > :not(:first-child) {\n			margin-left: var(--ck-spacing-standard);\n		}\n	}\n\n	@mixin ck-dir rtl {\n		& > :not(:last-child) {\n			margin-left: var(--ck-spacing-standard);\n		}\n	}\n\n	@mixin ck-media-phone {\n		padding: 0;\n		width: calc(.8 * var(--ck-input-width));\n\n		& .ck-labeled-field-view {\n			margin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n			& .ck-input-text {\n				min-width: 0;\n				width: 100%;\n			}\n\n			/* Let the long error messages wrap in the narrow form. */\n			& .ck-labeled-field-view__error {\n				white-space: normal;\n			}\n		}\n\n		/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n		& > .ck-button:nth-last-child(2) {\n			&::after {\n				border-right: 1px solid var(--ck-color-base-border);\n			}\n		}\n\n		& > .ck-button:nth-last-child(1),\n		& > .ck-button:nth-last-child(2) {\n			padding: var(--ck-spacing-standard);\n			margin-top: var(--ck-spacing-large);\n			border-radius: 0;\n\n			&:not(:focus) {\n				border-top: 1px solid var(--ck-color-base-border);\n			}\n\n			@mixin ck-dir ltr {\n				margin-left: 0;\n			}\n\n			@mixin ck-dir rtl {\n				margin-left: 0;\n\n				&:last-of-type {\n					border-right: 1px solid var(--ck-color-base-border);\n				}\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 9332: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{left:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{right:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view .ck-search__reset{position:absolute;top:50%;transform:translateY(-50%)}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{display:block}.ck.ck-search>.ck-search__results>.ck-search__info:not(.ck-hidden)~*{display:none}:root{--ck-search-field-view-horizontal-spacing:calc(var(--ck-icon-size) + var(--ck-spacing-medium))}.ck.ck-search>.ck-labeled-field-view .ck-input{width:100%}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon{--ck-labeled-field-label-default-position-x:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon>.ck-labeled-field-view__input-wrapper>.ck-icon{opacity:.5;pointer-events:none}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input,[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input:not(.ck-input-text_empty){padding-left:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset{--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset.ck-labeled-field-view_empty{--ck-labeled-field-empty-unfocused-max-width:100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{background:none;min-height:auto;min-width:auto;opacity:.5;padding:0}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{left:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset:hover{opacity:1}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input:not(.ck-input-text_empty),[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{padding-right:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-search__results{min-width:100%}.ck.ck-search>.ck-search__results>.ck-search__info{padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-search>.ck-search__results>.ck-search__info *{white-space:normal}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{font-weight:700}.ck.ck-search>.ck-search__results>.ck-search__info>span:last-child{margin-top:var(--ck-spacing-medium)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/search/search.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/search/search.css"], names: [], mappings: "AASE,oFACC,iBAAkB,CAClB,OAAQ,CACR,0BASD,CAZA,8FAME,6BAMF,CAZA,8FAUE,8BAEF,CAEA,uDACC,iBAAkB,CAClB,OAAQ,CACR,0BACD,CAKC,oEACC,aACD,CAGA,qEACC,YACD,CChCH,MACC,8FACD,CAIE,+CACC,UACD,CAEA,gEACC,0FAoBD,CAlBC,+GACC,UAAW,CACX,mBACD,CAEA,0EACC,UAWD,CAJE,kMACC,2DACD,CAKH,iEACC,sGAwCD,CAtCC,6FACC,6HACD,CAEA,mFAIC,eAAgB,CAFhB,eAAgB,CADhB,cAAe,CAIf,UAAW,CACX,SAaD,CAnBA,6FASE,8BAUF,CAnBA,6FAaE,6BAMF,CAHC,yFACC,SACD,CAGD,2EACC,UAWD,CAZA,oMAUE,4DAEF,CAIF,kCACC,cAkBD,CAhBC,mDAEC,wDAAyD,CADzD,UAcD,CAXC,qDACC,kBACD,CAEA,oEACC,eACD,CAEA,mEACC,mCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-search {\n	& > .ck-labeled-field-view {\n		& > .ck-labeled-field-view__input-wrapper > .ck-icon {\n			position: absolute;\n			top: 50%;\n			transform: translateY(-50%);\n\n			@mixin ck-dir ltr {\n				left: var(--ck-spacing-medium);\n			}\n\n			@mixin ck-dir rtl {\n				right: var(--ck-spacing-medium);\n			}\n		}\n\n		& .ck-search__reset {\n			position: absolute;\n			top: 50%;\n			transform: translateY(-50%);\n		}\n	}\n\n	& > .ck-search__results {\n		& > .ck-search__info {\n			& > span:first-child {\n				display: block;\n			}\n\n			/* Hide the filtered view when nothing was found */\n			&:not(.ck-hidden) ~ * {\n				display: none;\n			}\n		}\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n	--ck-search-field-view-horizontal-spacing: calc(var(--ck-icon-size) + var(--ck-spacing-medium));\n}\n\n.ck.ck-search {\n	& > .ck-labeled-field-view {\n		& .ck-input {\n			width: 100%;\n		}\n\n		&.ck-search__query_with-icon {\n			--ck-labeled-field-label-default-position-x: var(--ck-search-field-view-horizontal-spacing);\n\n			& > .ck-labeled-field-view__input-wrapper > .ck-icon {\n				opacity: .5;\n				pointer-events: none;\n			}\n\n			& .ck-input {\n				width: 100%;\n\n				@mixin ck-dir ltr {\n					padding-left: var(--ck-search-field-view-horizontal-spacing);\n				}\n\n				@mixin ck-dir rtl {\n					&:not(.ck-input-text_empty) {\n						padding-left: var(--ck-search-field-view-horizontal-spacing);\n					}\n				}\n			}\n		}\n\n		&.ck-search__query_with-reset {\n			--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-search-field-view-horizontal-spacing);\n\n			&.ck-labeled-field-view_empty {\n				--ck-labeled-field-empty-unfocused-max-width: 100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium);\n			}\n\n			& .ck-search__reset {\n				min-width: auto;\n				min-height: auto;\n\n				background: none;\n				opacity: .5;\n				padding: 0;\n\n				@mixin ck-dir ltr {\n					right: var(--ck-spacing-medium);\n				}\n\n				@mixin ck-dir rtl {\n					left: var(--ck-spacing-medium);\n				}\n\n				&:hover {\n					opacity: 1;\n				}\n			}\n\n			& .ck-input {\n				width: 100%;\n\n				@mixin ck-dir ltr {\n					&:not(.ck-input-text_empty) {\n						padding-right: var(--ck-search-field-view-horizontal-spacing);\n					}\n				}\n\n				@mixin ck-dir rtl {\n					padding-right: var(--ck-search-field-view-horizontal-spacing);\n				}\n			}\n		}\n	}\n\n	& > .ck-search__results {\n		min-width: 100%;\n\n		& > .ck-search__info {\n			width: 100%;\n			padding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\n			& * {\n				white-space: normal;\n			}\n\n			& > span:first-child {\n				font-weight: bold;\n			}\n\n			& > span:last-child {\n				margin-top: var(--ck-spacing-medium);\n			}\n		}\n	}\n}\n\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 6446: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-spinner-container{display:block;position:relative}.ck.ck-spinner{left:0;margin:0 auto;position:absolute;right:0;top:50%;transform:translateY(-50%);z-index:1}:root{--ck-toolbar-spinner-size:18px}.ck.ck-spinner-container{animation:rotate 1.5s linear infinite}.ck.ck-spinner,.ck.ck-spinner-container{height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}.ck.ck-spinner{border:2px solid var(--ck-color-text);border-radius:50%;border-top:2px solid transparent}@keyframes rotate{to{transform:rotate(1turn)}}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/spinner/spinner.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/spinner/spinner.css"], names: [], mappings: "AASA,yBACC,aAAc,CACd,iBACD,CAEA,eAGC,MAAO,CAEP,aAAc,CAJd,iBAAkB,CAGlB,OAAQ,CAFR,OAAQ,CAIR,0BAA2B,CAC3B,SACD,CCjBA,MACC,8BACD,CAEA,yBAGC,qCACD,CAEA,wCAJC,qCAAsC,CADtC,oCAWD,CANA,eAKC,qCAA6B,CAF7B,iBAAkB,CAElB,gCACD,CAEA,kBACC,GACC,uBACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-toolbar-spinner-size: 18px;\n}\n\n.ck.ck-spinner-container {\n	display: block;\n	position: relative;\n}\n\n.ck.ck-spinner {\n	position: absolute;\n	top: 50%;\n	left: 0;\n	right: 0;\n	margin: 0 auto;\n	transform: translateY(-50%);\n	z-index: 1;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-toolbar-spinner-size: 18px;\n}\n\n.ck.ck-spinner-container {\n	width: var(--ck-toolbar-spinner-size);\n	height: var(--ck-toolbar-spinner-size);\n	animation: 1.5s infinite rotate linear;\n}\n\n.ck.ck-spinner {\n	width: var(--ck-toolbar-spinner-size);\n	height: var(--ck-toolbar-spinner-size);\n	border-radius: 50%;\n	border: 2px solid var(--ck-color-text);\n	border-top-color: transparent;\n}\n\n@keyframes rotate {\n	to {\n		transform: rotate(360deg)\n	}\n}\n\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 5224: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-textarea{overflow-x:hidden}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/textarea/textarea.css"], names: [], mappings: "AASA,aACC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/*\n * This fixes a problem in Firefox when the initial height of the complement does not match the number of rows.\n * This bug is especially visible when rows=1.\n */\n.ck-textarea {\n	overflow-x: hidden\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4176: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"], names: [], mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n	position: absolute;\n	z-index: var(--ck-z-default);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-block-toolbar-button: var(--ck-color-text);\n	--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n	color: var(--ck-color-block-toolbar-button);\n	font-size: var(--ck-block-toolbar-size);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4768: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n	@mixin ck-unselectable;\n\n	display: flex;\n	flex-flow: row nowrap;\n	align-items: center;\n\n	& > .ck-toolbar__items {\n		display: flex;\n		flex-flow: row wrap;\n		align-items: center;\n		flex-grow: 1;\n\n	}\n\n	& .ck.ck-toolbar__separator {\n		display: inline-block;\n\n		/*\n		 * A leading or trailing separator makes no sense (separates from nothing on one side).\n		 * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n		 * moved to another toolbar in the dropdown.\n		 */\n		&:first-child,\n		&:last-child {\n			display: none;\n		}\n	}\n\n	& .ck-toolbar__line-break {\n		flex-basis: 100%;\n	}\n\n	&.ck-toolbar_grouping > .ck-toolbar__items {\n		flex-wrap: nowrap;\n	}\n\n	&.ck-toolbar_vertical > .ck-toolbar__items {\n		flex-direction: column;\n	}\n\n	&.ck-toolbar_floating > .ck-toolbar__items {\n		flex-wrap: nowrap;\n	}\n\n	& > .ck.ck-toolbar__grouped-dropdown {\n		& > .ck-dropdown__button .ck-dropdown__arrow {\n			display: none;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-toolbar {
	@mixin ck-rounded-corners;

	background: var(--ck-color-toolbar-background);
	padding: 0 var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);

	& .ck.ck-toolbar__separator {
		align-self: stretch;
		width: 1px;
		min-width: 1px;
		background: var(--ck-color-toolbar-border);

		/*
		 * These margins make the separators look better in balloon toolbars (when aligned with the "tip").
		 * See https://github.com/ckeditor/ckeditor5/issues/7493.
		 */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	& .ck-toolbar__line-break {
		height: 0;
	}

	& > .ck-toolbar__items {
		& > *:not(.ck-toolbar__line-break) {
			/* (#11) Separate toolbar items. */
			margin-right: var(--ck-spacing-small);
		}

		/* Don't display a separator after an empty items container, for instance,
		when all items were grouped */
		&:empty + .ck.ck-toolbar__separator {
			display: none;
		}
	}

	& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),
	& > .ck.ck-toolbar__grouped-dropdown {
		/* Make sure items wrapped to the next line have v-spacing */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	&.ck-toolbar_vertical {
		/* Items in a vertical toolbar span the entire width. */
		padding: 0;

		/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */
		& > .ck-toolbar__items > .ck {
			/* Items in a vertical toolbar should span the horizontal space. */
			width: 100%;

			/* Items in a vertical toolbar should have no margin. */
			margin: 0;

			/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */
			border-radius: 0;
		}
	}

	&.ck-toolbar_compact {
		/* No spacing around items. */
		padding: 0;

		& > .ck-toolbar__items > * {
			/* Compact toolbar items have no spacing between them. */
			margin: 0;

			/* "Middle" children should have no rounded corners. */
			&:not(:first-child):not(:last-child) {
				border-radius: 0;
			}
		}
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		/*
		 * Dropdown button has asymmetric padding to fit the arrow.
		 * This button has no arrow so let's revert that padding back to normal.
		 */
		& > .ck.ck-button.ck-dropdown__button {
			padding-left: var(--ck-spacing-tiny);
		}
	}

	/* A drop-down containing the nested toolbar with configured items. */
	& .ck-toolbar__nested-toolbar-dropdown {
		/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */
		& > .ck-dropdown__panel {
			min-width: auto;
		}

		& > .ck-button > .ck-button__label {
			max-width: 7em;
			width: auto;
		}
	}

	&:focus {
		outline: none;
	}

	@nest .ck-toolbar-container & {
		border: 0;
	}
}

/* stylelint-disable */

/*
 * Styles for RTL toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="rtl"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="rtl"] {
	& > .ck-toolbar__items > .ck {
		margin-right: 0;
	}

	&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {
		/* (#11) Separate toolbar items. */
		margin-left: var(--ck-spacing-small);
	}

	& > .ck-toolbar__items > .ck:last-child {
		margin-left: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-left: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-left: var(--ck-spacing-small);
	}
}

/*
 * Styles for LTR toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="ltr"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="ltr"] {
	& > .ck-toolbar__items > .ck:last-child {
		margin-right: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-right: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-right: var(--ck-spacing-small);
	}
}

/* stylelint-enable */
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 3888: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-tooltip-text-padding:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip.ck-tooltip_multi-line .ck-tooltip__text{display:inline-block;padding:var(--ck-tooltip-text-padding) 0;white-space:break-spaces}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"], names: [], mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDRnC,mBAAoB,CAEpB,qCACD,CCOC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAEA,wEAEC,oBAAqB,CACrB,wCAAyC,CAFzC,wBAGD,CApBD,gCAuBC,eAMD,CAHC,uCACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n	/* Keep tooltips transparent for any interactions. */\n	pointer-events: none;\n\n	z-index: calc( var(--ck-z-modal) + 100 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n	--ck-balloon-border-width: 0px;\n	--ck-balloon-arrow-offset: 0px;\n	--ck-balloon-arrow-half-width: 4px;\n	--ck-balloon-arrow-height: 4px;\n	--ck-tooltip-text-padding: 4px;\n	--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n	padding: 0 var(--ck-spacing-medium);\n\n	& .ck-tooltip__text {\n		font-size: .9em;\n		line-height: 1.5;\n		color: var(--ck-color-tooltip-text);\n	}\n\n	&.ck-tooltip_multi-line .ck-tooltip__text {\n		white-space: break-spaces;\n		display: inline-block;\n		padding: var(--ck-tooltip-text-padding) 0;\n	}\n\n	/* Reset balloon panel styles */\n	box-shadow: none;\n\n	/* Hide the default shadow of the .ck-balloon-panel tip */\n	&::before {\n		display: none;\n	}\n}\n'], sourceRoot: "" }]);
        const a2 = s2;
      }, 5167: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-modal) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-color-light-red:#fcc;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_hidden.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_zindex.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_transition.css", "webpack://./node_modules/@ckeditor/ckeditor5-ui/theme/globals/_poweredby.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"], names: [], mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAyD,CAIzD,yBAAgD,CC3GhD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJ2GD,CIrGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n	/* Override selector specificity. Otherwise, all elements with some display\n	style defined will override this one, which is not a desired result. */\n	display: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n	box-sizing: border-box;\n	width: auto;\n	height: auto;\n	position: static;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-z-default: 1;\n	--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n	transition: none !important;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-powered-by-line-height: 10px;\n	--ck-powered-by-padding-vertical: 2px;\n	--ck-powered-by-padding-horizontal: 4px;\n	--ck-powered-by-text-color: hsl(0, 0%, 31%);\n	--ck-powered-by-border-radius: var(--ck-border-radius);\n	--ck-powered-by-background: hsl(0, 0%, 100%);\n	--ck-powered-by-border-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-balloon-panel.ck-powered-by-balloon {\n	--ck-border-radius: var(--ck-powered-by-border-radius);\n\n	box-shadow: none;\n	background: var(--ck-powered-by-background);\n	min-height: unset;\n	z-index: calc( var(--ck-z-modal) - 1 );\n\n	& .ck.ck-powered-by {\n		line-height: var(--ck-powered-by-line-height);\n\n		& a {\n			cursor: pointer;\n			display: flex;\n			align-items: center;\n			opacity: .66;\n			filter: grayscale(80%);\n			line-height: var(--ck-powered-by-line-height);\n			padding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);\n		}\n\n		& .ck-powered-by__label {\n			font-size: 7.5px;\n			letter-spacing: -.2px;\n			padding-left: 2px;\n			text-transform: uppercase;\n			font-weight: bold;\n			margin-right: 4px;\n			cursor: pointer;\n			line-height: normal;\n			color: var(--ck-powered-by-text-color);\n\n		}\n\n		& .ck-icon {\n			display: block;\n			cursor: pointer;\n		}\n\n		&:hover {\n			& a {\n				filter: grayscale(0%);\n				opacity: 1;\n			}\n		}\n	}\n\n	&[class*="position_inside"] {\n		border-color: transparent;\n	}\n\n	&[class*="position_border"] {\n		border: var(--ck-focus-ring);\n		border-color: var(--ck-powered-by-border-color);\n	}\n}\n\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-base-foreground: 								hsl(0, 0%, 98%);\n	--ck-color-base-background: 								hsl(0, 0%, 100%);\n	--ck-color-base-border: 									hsl(220, 6%, 81%);\n	--ck-color-base-action: 									hsl(104, 50.2%, 42.5%);\n	--ck-color-base-focus: 										hsl(209, 92%, 70%);\n	--ck-color-base-text: 										hsl(0, 0%, 20%);\n	--ck-color-base-active: 									hsl(218.1, 100%, 58%);\n	--ck-color-base-active-focus:								hsl(218.2, 100%, 52.5%);\n	--ck-color-base-error:										hsl(15, 100%, 43%);\n\n	/* -- Generic colors ------------------------------------------------------------------------ */\n\n	--ck-color-focus-border-coordinates: 						218, 81.8%, 56.9%;\n	--ck-color-focus-border: 									hsl(var(--ck-color-focus-border-coordinates));\n	--ck-color-focus-outer-shadow:								hsl(212.4, 89.3%, 89%);\n	--ck-color-focus-disabled-shadow:							hsla(209, 90%, 72%,.3);\n	--ck-color-focus-error-shadow:								hsla(9,100%,56%,.3);\n	--ck-color-text: 											var(--ck-color-base-text);\n	--ck-color-shadow-drop: 									hsla(0, 0%, 0%, 0.15);\n	--ck-color-shadow-drop-active:								hsla(0, 0%, 0%, 0.2);\n	--ck-color-shadow-inner: 									hsla(0, 0%, 0%, 0.1);\n\n	/* -- Buttons ------------------------------------------------------------------------------- */\n\n	--ck-color-button-default-background: 						transparent;\n	--ck-color-button-default-hover-background: 				hsl(0, 0%, 94.1%);\n	--ck-color-button-default-active-background: 				hsl(0, 0%, 94.1%);\n	--ck-color-button-default-disabled-background: 				transparent;\n\n	--ck-color-button-on-background: 							hsl(212, 100%, 97.1%);\n	--ck-color-button-on-hover-background: 						hsl(211.7, 100%, 92.9%);\n	--ck-color-button-on-active-background: 					hsl(211.7, 100%, 92.9%);\n	--ck-color-button-on-disabled-background: 					hsl(211, 15%, 95%);\n	--ck-color-button-on-color:									hsl(218.1, 100%, 58%);\n\n\n	--ck-color-button-action-background: 						var(--ck-color-base-action);\n	--ck-color-button-action-hover-background: 					hsl(104, 53.2%, 40.2%);\n	--ck-color-button-action-active-background: 				hsl(104, 53.2%, 40.2%);\n	--ck-color-button-action-disabled-background: 				hsl(104, 44%, 58%);\n	--ck-color-button-action-text: 								var(--ck-color-base-background);\n\n	--ck-color-button-save: 									hsl(120, 100%, 27%);\n	--ck-color-button-cancel: 									hsl(15, 100%, 43%);\n\n	--ck-color-switch-button-off-background:					hsl(0, 0%, 57.6%);\n	--ck-color-switch-button-off-hover-background:				hsl(0, 0%, 49%);\n	--ck-color-switch-button-on-background:						var(--ck-color-button-action-background);\n	--ck-color-switch-button-on-hover-background:				hsl(104, 53.2%, 40.2%);\n	--ck-color-switch-button-inner-background:					var(--ck-color-base-background);\n	--ck-color-switch-button-inner-shadow:						hsla(0, 0%, 0%, 0.1);\n\n	/* -- Dropdown ------------------------------------------------------------------------------ */\n\n	--ck-color-dropdown-panel-background: 						var(--ck-color-base-background);\n	--ck-color-dropdown-panel-border: 							var(--ck-color-base-border);\n\n	/* -- Input --------------------------------------------------------------------------------- */\n\n	--ck-color-input-background: 								var(--ck-color-base-background);\n	--ck-color-input-border: 									var(--ck-color-base-border);\n	--ck-color-input-error-border:								var(--ck-color-base-error);\n	--ck-color-input-text: 										var(--ck-color-base-text);\n	--ck-color-input-disabled-background: 						hsl(0, 0%, 95%);\n	--ck-color-input-disabled-border: 							var(--ck-color-base-border);\n	--ck-color-input-disabled-text: 							hsl(0, 0%, 46%);\n\n	/* -- List ---------------------------------------------------------------------------------- */\n\n	--ck-color-list-background: 								var(--ck-color-base-background);\n	--ck-color-list-button-hover-background: 					var(--ck-color-button-default-hover-background);\n	--ck-color-list-button-on-background: 						var(--ck-color-button-on-color);\n	--ck-color-list-button-on-background-focus: 				var(--ck-color-button-on-color);\n	--ck-color-list-button-on-text:								var(--ck-color-base-background);\n\n	/* -- Panel --------------------------------------------------------------------------------- */\n\n	--ck-color-panel-background: 								var(--ck-color-base-background);\n	--ck-color-panel-border: 									var(--ck-color-base-border);\n\n	/* -- Toolbar ------------------------------------------------------------------------------- */\n\n	--ck-color-toolbar-background: 								var(--ck-color-base-background);\n	--ck-color-toolbar-border: 									var(--ck-color-base-border);\n\n	/* -- Tooltip ------------------------------------------------------------------------------- */\n\n	--ck-color-tooltip-background: 								var(--ck-color-base-text);\n	--ck-color-tooltip-text: 									var(--ck-color-base-background);\n\n	/* -- Engine -------------------------------------------------------------------------------- */\n\n	--ck-color-engine-placeholder-text: 						hsl(0, 0%, 44%);\n\n	/* -- Upload -------------------------------------------------------------------------------- */\n\n	--ck-color-upload-bar-background:		 					hsl(209, 92%, 70%);\n\n	/* -- Link -------------------------------------------------------------------------------- */\n\n	--ck-color-link-default:									hsl(240, 100%, 47%);\n	--ck-color-link-selected-background:						hsla(201, 100%, 56%, 0.1);\n	--ck-color-link-fake-selection:								hsla(201, 100%, 56%, 0.3);\n\n	/* -- Search result highlight ---------------------------------------------------------------- */\n\n	--ck-color-highlight-background:							hsl(60, 100%, 50%);\n\n	/* -- Generic colors ------------------------------------------------------------------------- */\n\n	--ck-color-light-red:										hsl(0, 100%, 90%);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * An opacity value of disabled UI item.\n	 */\n	--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * The geometry of the of focused element's outer shadow.\n	 */\n	--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n	/**\n	 * A visual style of focused element's outer shadow.\n	 */\n	--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n	/**\n	 * A visual style of focused element's outer shadow (when disabled).\n	 */\n	--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n	/**\n	 * A visual style of focused element's outer shadow (when has errors).\n	 */\n	--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n	/**\n	 * A visual style of focused element's border or outline.\n	 */\n	--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-font-size-base: 13px;\n	--ck-line-height-base: 1.84615;\n	--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n	--ck-font-size-tiny: 0.7em;\n	--ck-font-size-small: 0.75em;\n	--ck-font-size-normal: 1em;\n	--ck-font-size-big: 1.4em;\n	--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/* This is super-important. This is **manually** adjusted so a button without an icon\n	is never smaller than a button with icon, additionally making sure that text-less buttons\n	are perfect squares. The value is also shared by other components which should stay "in-line"\n	with buttons. */\n	--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n	/* Do not include inheritable rules here. */\n	margin: 0;\n	padding: 0;\n	border: 0;\n	background: transparent;\n	text-decoration: none;\n	vertical-align: middle;\n	transition: none;\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n	word-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n	/* These are rule inherited by all children elements. */\n	border-collapse: collapse;\n	font: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n	color: var(--ck-color-text);\n	text-align: left;\n	white-space: nowrap;\n	cursor: auto;\n	float: none;\n}\n\n.ck-reset_all {\n	& .ck-rtl *:not(.ck-reset_all-excluded *) {\n		text-align: right;\n	}\n\n	& iframe:not(.ck-reset_all-excluded *) {\n		/* For IE */\n		vertical-align: inherit;\n	}\n\n	& textarea:not(.ck-reset_all-excluded *) {\n		white-space: pre-wrap;\n	}\n\n	& textarea:not(.ck-reset_all-excluded *),\n	& input[type="text"]:not(.ck-reset_all-excluded *),\n	& input[type="password"]:not(.ck-reset_all-excluded *) {\n		cursor: text;\n	}\n\n	& textarea[disabled]:not(.ck-reset_all-excluded *),\n	& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n	& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n		cursor: default;\n	}\n\n	& fieldset:not(.ck-reset_all-excluded *) {\n		padding: 10px;\n		border: 2px groove hsl(255, 7%, 88%);\n	}\n\n	& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n		/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n		padding: 0;\n		border: 0\n	}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n	text-align: right;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n	--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * A visual style of element's inner shadow (i.e. input).\n	 */\n	--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n	/**\n	 * A visual style of element's drop shadow (i.e. panel).\n	 */\n	--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n	/**\n	 * A visual style of element's active shadow (i.e. comment or suggestion).\n	 */\n	--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-spacing-unit: 						0.6em;\n	--ck-spacing-large: 					calc(var(--ck-spacing-unit) * 1.5);\n	--ck-spacing-standard: 					var(--ck-spacing-unit);\n	--ck-spacing-medium: 					calc(var(--ck-spacing-unit) * 0.8);\n	--ck-spacing-small: 					calc(var(--ck-spacing-unit) * 0.5);\n	--ck-spacing-tiny: 						calc(var(--ck-spacing-unit) * 0.3);\n	--ck-spacing-extra-tiny: 				calc(var(--ck-spacing-unit) * 0.16);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 7153: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-resizer: var(--ck-color-focus-border);\n	--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n	--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n	--ck-resizer-border-radius: var(--ck-border-radius);\n	--ck-resizer-tooltip-offset: 10px;\n	--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n	/* This is neccessary for type around UI to be positioned properly. */\n	position: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n	/* Make the widget wrapper a relative positioning container for the drag handle. */\n	position: relative;\n\n	& .ck-widget__selection-handle {\n		position: absolute;\n\n		& .ck-icon {\n			/* Make sure the icon in not a subject to font-size or line-height to avoid\n			unnecessary spacing around it. */\n			display: block;\n		}\n	}\n\n	/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n	&:hover > .ck-widget__selection-handle {\n		visibility: visible;\n	}\n\n	/* Show the selection handle when the widget is selected, but not for nested widgets. */\n	&.ck-widget_selected > .ck-widget__selection-handle {\n		visibility: visible;\n	}\n}\n\n.ck .ck-size-view {\n	background: var(--ck-color-resizer-tooltip-background);\n	color: var(--ck-color-resizer-tooltip-text);\n	border: 1px solid var(--ck-color-resizer-tooltip-text);\n	border-radius: var(--ck-resizer-border-radius);\n	font-size: var(--ck-font-size-tiny);\n	display: block;\n	padding: 0 var(--ck-spacing-small);\n	height: var(--ck-resizer-tooltip-height);\n	line-height: var(--ck-resizer-tooltip-height);\n\n	&.ck-orientation-top-left,\n	&.ck-orientation-top-right,\n	&.ck-orientation-bottom-right,\n	&.ck-orientation-bottom-left,\n	&.ck-orientation-above-center {\n		position: absolute;\n	}\n\n	&.ck-orientation-top-left {\n		top: var(--ck-resizer-tooltip-offset);\n		left: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-top-right {\n		top: var(--ck-resizer-tooltip-offset);\n		right: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-bottom-right {\n		bottom: var(--ck-resizer-tooltip-offset);\n		right: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-bottom-left {\n		bottom: var(--ck-resizer-tooltip-offset);\n		left: var(--ck-resizer-tooltip-offset);\n	}\n\n	/* Class applied if the widget is too small to contain the size label */\n	&.ck-orientation-above-center {\n		top: calc(var(--ck-resizer-tooltip-height) * -1);\n		left: 50%;\n		transform: translate(-50%);\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n	--ck-widget-outline-thickness: 3px;\n	--ck-widget-handler-icon-size: 16px;\n	--ck-widget-handler-animation-duration: 200ms;\n	--ck-widget-handler-animation-curve: ease;\n\n	--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n	--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n	--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n	--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n	outline-width: var(--ck-widget-outline-thickness);\n	outline-style: solid;\n	outline-color: transparent;\n	transition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n	}\n\n	&:hover {\n		outline-color: var(--ck-color-widget-hover-border);\n	}\n}\n\n.ck .ck-editor__nested-editable {\n	border: 1px solid transparent;\n\n	/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n	These styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n	&.ck-editor__nested-editable_focused,\n	&:focus {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-inner-shadow);\n\n		background-color: var(--ck-color-widget-editable-focus-background);\n	}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n	& .ck-widget__selection-handle {\n		padding: 4px;\n		box-sizing: border-box;\n\n		/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n		background-color: transparent;\n		opacity: 0;\n\n		/* Transition:\n		   * background-color for the .ck-widget_selected state change,\n		   * visibility for hiding the handler,\n		   * opacity for the proper look of the icon when the handler disappears. */\n		transition:\n			background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n			visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n			opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n		/* Make only top corners round. */\n		border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n		/* Place the drag handler outside the widget wrapper. */\n		transform: translateY(-100%);\n		left: calc(0px - var(--ck-widget-outline-thickness));\n		top: 0;\n\n		& .ck-icon {\n			/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n			width: var(--ck-widget-handler-icon-size);\n			height: var(--ck-widget-handler-icon-size);\n			color: var(--ck-color-widget-drag-handler-icon-color);\n\n			/* The "selected" part of the icon is invisible by default */\n			& .ck-icon__selected-indicator {\n				opacity: 0;\n\n				/* Note: The animation is longer on purpose. Simply feels better. */\n				transition: opacity 300ms var(--ck-widget-handler-animation-curve);\n			}\n		}\n\n		/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n		&:hover .ck-icon .ck-icon__selected-indicator {\n			opacity: 1;\n		}\n	}\n\n	/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n	&:hover > .ck-widget__selection-handle {\n		opacity: 1;\n		background-color: var(--ck-color-widget-hover-border);\n	}\n\n	/* Show the selection handler when the widget is selected, but not for nested widgets. */\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		& > .ck-widget__selection-handle {\n			opacity: 1;\n			background-color: var(--ck-color-focus-border);\n\n			/* When the widget is selected, notify the user using the proper look of the icon. */\n			& .ck-icon .ck-icon__selected-indicator {\n				opacity: 1;\n			}\n		}\n	}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n	left: auto;\n	right: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n	/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n	transition: none;\n\n	&:not(.ck-widget_selected) {\n		/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n		 * See: https://github.com/ckeditor/ckeditor5/issues/1261\n		 *\n		 * Leave the unit because this custom property is used in calc() by other features.\n		 * See: https://github.com/ckeditor/ckeditor5/issues/6775\n		 */\n		--ck-widget-outline-thickness: 0px;\n	}\n\n	&.ck-widget_with-selection-handle {\n		& .ck-widget__selection-handle,\n		& .ck-widget__selection-handle:hover {\n			background: var(--ck-color-widget-blurred-border);\n		}\n	}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		outline-color: var(--ck-color-widget-blurred-border);\n\n		&.ck-widget_with-selection-handle {\n			& > .ck-widget__selection-handle,\n			& > .ck-widget__selection-handle:hover {\n				background: var(--ck-color-widget-blurred-border);\n			}\n		}\n	}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n	/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n	In fact, anything with overflow: hidden.\n	https://github.com/ckeditor/ckeditor5-block-quote/issues/28\n	https://github.com/ckeditor/ckeditor5-widget/issues/44\n	https://github.com/ckeditor/ckeditor5-widget/issues/66 */\n	margin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 4875: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgetresize.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"], names: [], mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n	/* Make the widget wrapper a relative positioning container for the drag handle. */\n	position: relative;\n}\n\n.ck .ck-widget__resizer {\n	display: none;\n	position: absolute;\n\n	/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n	pointer-events: none;\n\n	left: 0;\n	top: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n	& > .ck-widget__resizer {\n		display: block;\n	}\n}\n\n.ck .ck-widget__resizer__handle {\n	position: absolute;\n\n	/* Resizers are the only UI elements that should interfere with a pointer device. */\n	pointer-events: all;\n\n	&.ck-widget__resizer__handle-top-left,\n	&.ck-widget__resizer__handle-bottom-right {\n		cursor: nwse-resize;\n	}\n\n	&.ck-widget__resizer__handle-top-right,\n	&.ck-widget__resizer__handle-bottom-left {\n		cursor: nesw-resize;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-resizer-size: 10px;\n\n	/* Set the resizer with a 50% offset. */\n	--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n	--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n	outline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n	width: var(--ck-resizer-size);\n	height: var(--ck-resizer-size);\n	background: var(--ck-color-focus-border);\n	border: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n	border-radius: var(--ck-resizer-border-radius);\n\n	&.ck-widget__resizer__handle-top-left {\n		top: var(--ck-resizer-offset);\n		left: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-top-right {\n		top: var(--ck-resizer-offset);\n		right: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-bottom-right {\n		bottom: var(--ck-resizer-offset);\n		right: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-bottom-left {\n		bottom: var(--ck-resizer-offset);\n		left: var(--ck-resizer-offset);\n	}\n}\n"], sourceRoot: "" }]);
        const a2 = s2;
      }, 2347: (t3, e3, n3) => {
        n3.d(e3, { Z: () => a2 });
        var i3 = n3(4015), o2 = n3.n(i3), r2 = n3(3645), s2 = n3.n(r2)()(o2());
        s2.push([t3.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css", "webpack://./node_modules/@ckeditor/ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"], names: [], mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		display: block;
		position: absolute;
		overflow: hidden;
		z-index: var(--ck-z-default);

		& svg {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: calc(var(--ck-z-default) + 2);
		}

		&.ck-widget__type-around__button_before {
			/* Place it in the middle of the outline */
			top: calc(-0.5 * var(--ck-widget-outline-thickness));
			left: min(10%, 30px);

			transform: translateY(-50%);
		}

		&.ck-widget__type-around__button_after {
			/* Place it in the middle of the outline */
			bottom: calc(-0.5 * var(--ck-widget-outline-thickness));
			right: min(10%, 30px);

			transform: translateY(50%);
		}
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		&::after {
			content: "";
			display: block;
			position: absolute;
			top: 1px;
			left: 1px;
			z-index: calc(var(--ck-z-default) + 1);
		}
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		display: none;
		position: absolute;
		left: 0;
		right: 0;
	}

	/*
	 * When the widget is hovered the "fake caret" would normally be narrower than the
	 * extra outline displayed around the widget. Let's extend the "fake caret" to match
	 * the full width of the widget.
	 */
	&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		left: calc( -1 * var(--ck-widget-outline-thickness) );
		right: calc( -1 * var(--ck-widget-outline-thickness) );
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		top: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		bottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}
}

/*
 * Integration with the read-only mode of the editor.
 */
.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the restricted editing mode (feature) of the editor.
 */
.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the #isEnabled property of the WidgetTypeAround plugin.
 */
.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-widget-type-around-button-size: 20px;
	--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);
	--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);
	--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);
	--ck-color-widget-type-around-button-radar-start-alpha: 0;
	--ck-color-widget-type-around-button-radar-end-alpha: .3;
	--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);
}

@define-mixin ck-widget-type-around-button-visible {
	opacity: 1;
	pointer-events: auto;
}

@define-mixin ck-widget-type-around-button-hidden {
	opacity: 0;
	pointer-events: none;
}

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		width: var(--ck-widget-type-around-button-size);
		height: var(--ck-widget-type-around-button-size);
		background: var(--ck-color-widget-type-around-button);
		border-radius: 100px;
		transition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		@mixin ck-widget-type-around-button-hidden;

		& svg {
			width: 10px;
			height: 8px;
			transform: translate(-50%,-50%);
			transition: transform .5s ease;
			margin-top: 1px;

			& * {
				stroke-dasharray: 10;
				stroke-dashoffset: 0;

				fill: none;
				stroke: var(--ck-color-widget-type-around-button-icon);
				stroke-width: 1.5px;
				stroke-linecap: round;
				stroke-linejoin: round;
			}

			& line {
				stroke-dasharray: 7;
			}
		}

		&:hover {
			/*
			 * Display the "sonar" around the button when hovered.
			 */
			animation: ck-widget-type-around-button-sonar 1s ease infinite;

			/*
			 * Animate active button's icon.
			 */
			& svg {
				& polyline {
					animation: ck-widget-type-around-arrow-dash 2s linear;
				}

				& line {
					animation: ck-widget-type-around-arrow-tip-dash 2s linear;
				}
			}
		}
	}

	/*
	 * Show type around buttons when the widget gets selected or being hovered.
	 */
	&.ck-widget_selected,
	&:hover {
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-visible;
		}
	}

	/*
	 * Styles for the buttons when the widget is NOT selected (but the buttons are visible
	 * and still can be hovered).
	 */
	&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {
		background: var(--ck-color-widget-type-around-button-hover);
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		background: var(--ck-color-widget-type-around-button-active);

		&::after {
			width: calc(var(--ck-widget-type-around-button-size) - 2px);
			height: calc(var(--ck-widget-type-around-button-size) - 2px);
			border-radius: 100px;
			background: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);
		}
	}

	/*
	 * Styles for the "before" button when the widget has a selection handle. Because some space
	 * is consumed by the handle, the button must be moved slightly to the right to let it breathe.
	 */
	&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {
		margin-left: 20px;
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& .ck-widget__type-around__fake-caret {
		pointer-events: none;
		height: 1px;
		animation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;

		/*
		 * The semi-transparent-outline+background combo improves the contrast
		 * when the background underneath the fake caret is dark.
		 */
		outline: solid 1px hsla(0, 0%, 100%, .5);
		background: var(--ck-color-base-text);
	}

	/*
	 * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).
	 * Despite the widget being physically selected in the model, its outline should disappear.
	 */
	&.ck-widget_selected {
		&.ck-widget_type-around_show-fake-caret_before,
		&.ck-widget_type-around_show-fake-caret_after {
			outline-color: transparent;
		}
	}

	&.ck-widget_type-around_show-fake-caret_before,
	&.ck-widget_type-around_show-fake-caret_after {
		/*
		 * When the "fake caret" is visible we simulate that the widget is not selected
		 * (despite being physically selected), so the outline color should be for the
		 * unselected widget.
		 */
		&.ck-widget_selected:hover {
			outline-color: var(--ck-color-widget-hover-border);
		}

		/*
		 * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).
		 * In this state, the type around buttons would collide with the fake carets so they should disappear.
		 */
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-hidden;
		}

		/*
		 * Fake horizontal caret integration with the selection handle. When the caret is visible, simply
		 * hide the handle because it intersects with the caret (and does not make much sense anyway).
		 */
		&.ck-widget_with-selection-handle {
			&.ck-widget_selected,
			&.ck-widget_selected:hover {
				& > .ck-widget__selection-handle {
					opacity: 0
				}
			}
		}

		/*
		 * Fake horizontal caret integration with the resize UI. When the caret is visible, simply
		 * hide the resize UI because it creates too much noise. It can be visible when the user
		 * hovers the widget, though.
		 */
		&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {
			opacity: 0
		}
	}
}

/*
 * Styles for the "before" button when the widget has a selection handle in an RTL environment.
 * The selection handler is aligned to the right side of the widget so there is no need to create
 * additional space for it next to the "before" button.
 */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {
	margin-left: 0;
	margin-right: 20px;
}

/*
 * Hide type around buttons when the widget is selected as a child of a selected
 * nested editable (e.g. mulit-cell table selection).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/7263.
 */
.ck-editor__nested-editable.ck-editor__editable_selected {
	& .ck-widget {
		&.ck-widget_selected,
		&:hover {
			& > .ck-widget__type-around > .ck-widget__type-around__button {
				@mixin ck-widget-type-around-button-hidden;
			}
		}
	}
}

/*
 * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).
 */
.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {
	background: var(--ck-color-widget-type-around-button-blurred-editable);

	& svg * {
		stroke: hsl(0,0%,60%);
	}
}

@keyframes ck-widget-type-around-arrow-dash {
	0% {
		stroke-dashoffset: 10;
	}
	20%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-arrow-tip-dash {
	0%, 20% {
		stroke-dashoffset: 7;
	}
	40%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-button-sonar {
	0% {
		box-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
	50% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));
	}
	100% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
}

@keyframes ck-widget-type-around-fake-caret-pulse {
	0% {
		opacity: 1;
	}
	49% {
		opacity: 1;
	}
	50% {
		opacity: 0;
	}
	99% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
`], sourceRoot: "" }]);
        const a2 = s2;
      }, 3645: (t3) => {
        t3.exports = function(t4) {
          var e3 = [];
          return e3.toString = function() {
            return this.map(function(e4) {
              var n3 = t4(e4);
              return e4[2] ? "@media ".concat(e4[2], " {").concat(n3, "}") : n3;
            }).join("");
          }, e3.i = function(t5, n3, i3) {
            "string" == typeof t5 && (t5 = [[null, t5, ""]]);
            var o2 = {};
            if (i3)
              for (var r2 = 0; r2 < this.length; r2++) {
                var s2 = this[r2][0];
                null != s2 && (o2[s2] = true);
              }
            for (var a2 = 0; a2 < t5.length; a2++) {
              var c2 = [].concat(t5[a2]);
              i3 && o2[c2[0]] || (n3 && (c2[2] ? c2[2] = "".concat(n3, " and ").concat(c2[2]) : c2[2] = n3), e3.push(c2));
            }
          }, e3;
        };
      }, 4015: (t3) => {
        function e3(t4, e4) {
          return function(t5) {
            if (Array.isArray(t5))
              return t5;
          }(t4) || function(t5, e5) {
            var n4 = t5 && ("undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"]);
            if (null == n4)
              return;
            var i3, o2, r2 = [], s2 = true, a2 = false;
            try {
              for (n4 = n4.call(t5); !(s2 = (i3 = n4.next()).done) && (r2.push(i3.value), !e5 || r2.length !== e5); s2 = true)
                ;
            } catch (t6) {
              a2 = true, o2 = t6;
            } finally {
              try {
                s2 || null == n4.return || n4.return();
              } finally {
                if (a2)
                  throw o2;
              }
            }
            return r2;
          }(t4, e4) || function(t5, e5) {
            if (!t5)
              return;
            if ("string" == typeof t5)
              return n3(t5, e5);
            var i3 = Object.prototype.toString.call(t5).slice(8, -1);
            "Object" === i3 && t5.constructor && (i3 = t5.constructor.name);
            if ("Map" === i3 || "Set" === i3)
              return Array.from(t5);
            if ("Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3))
              return n3(t5, e5);
          }(t4, e4) || function() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
          }();
        }
        function n3(t4, e4) {
          (null == e4 || e4 > t4.length) && (e4 = t4.length);
          for (var n4 = 0, i3 = new Array(e4); n4 < e4; n4++)
            i3[n4] = t4[n4];
          return i3;
        }
        t3.exports = function(t4) {
          var n4 = e3(t4, 4), i3 = n4[1], o2 = n4[3];
          if (!o2)
            return i3;
          if ("function" == typeof btoa) {
            var r2 = btoa(unescape(encodeURIComponent(JSON.stringify(o2)))), s2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r2), a2 = "/*# ".concat(s2, " */"), c2 = o2.sources.map(function(t5) {
              return "/*# sourceURL=".concat(o2.sourceRoot || "").concat(t5, " */");
            });
            return [i3].concat(c2).concat([a2]).join("\n");
          }
          return [i3].join("\n");
        };
      }, 3379: (t3, e3, n3) => {
        var i3, o2 = function() {
          return void 0 === i3 && (i3 = Boolean(window && document && document.all && !window.atob)), i3;
        }, r2 = function() {
          var t4 = {};
          return function(e4) {
            if (void 0 === t4[e4]) {
              var n4 = document.querySelector(e4);
              if (window.HTMLIFrameElement && n4 instanceof window.HTMLIFrameElement)
                try {
                  n4 = n4.contentDocument.head;
                } catch (t5) {
                  n4 = null;
                }
              t4[e4] = n4;
            }
            return t4[e4];
          };
        }(), s2 = [];
        function a2(t4) {
          for (var e4 = -1, n4 = 0; n4 < s2.length; n4++)
            if (s2[n4].identifier === t4) {
              e4 = n4;
              break;
            }
          return e4;
        }
        function c2(t4, e4) {
          for (var n4 = {}, i4 = [], o3 = 0; o3 < t4.length; o3++) {
            var r3 = t4[o3], c3 = e4.base ? r3[0] + e4.base : r3[0], l3 = n4[c3] || 0, d3 = "".concat(c3, " ").concat(l3);
            n4[c3] = l3 + 1;
            var h3 = a2(d3), u3 = { css: r3[1], media: r3[2], sourceMap: r3[3] };
            -1 !== h3 ? (s2[h3].references++, s2[h3].updater(u3)) : s2.push({ identifier: d3, updater: f2(u3, e4), references: 1 }), i4.push(d3);
          }
          return i4;
        }
        function l2(t4) {
          var e4 = document.createElement("style"), i4 = t4.attributes || {};
          if (void 0 === i4.nonce) {
            var o3 = n3.nc;
            o3 && (i4.nonce = o3);
          }
          if (Object.keys(i4).forEach(function(t5) {
            e4.setAttribute(t5, i4[t5]);
          }), "function" == typeof t4.insert)
            t4.insert(e4);
          else {
            var s3 = r2(t4.insert || "head");
            if (!s3)
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
            s3.appendChild(e4);
          }
          return e4;
        }
        var d2, h2 = (d2 = [], function(t4, e4) {
          return d2[t4] = e4, d2.filter(Boolean).join("\n");
        });
        function u2(t4, e4, n4, i4) {
          var o3 = n4 ? "" : i4.media ? "@media ".concat(i4.media, " {").concat(i4.css, "}") : i4.css;
          if (t4.styleSheet)
            t4.styleSheet.cssText = h2(e4, o3);
          else {
            var r3 = document.createTextNode(o3), s3 = t4.childNodes;
            s3[e4] && t4.removeChild(s3[e4]), s3.length ? t4.insertBefore(r3, s3[e4]) : t4.appendChild(r3);
          }
        }
        function g2(t4, e4, n4) {
          var i4 = n4.css, o3 = n4.media, r3 = n4.sourceMap;
          if (o3 ? t4.setAttribute("media", o3) : t4.removeAttribute("media"), r3 && "undefined" != typeof btoa && (i4 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r3)))), " */")), t4.styleSheet)
            t4.styleSheet.cssText = i4;
          else {
            for (; t4.firstChild; )
              t4.removeChild(t4.firstChild);
            t4.appendChild(document.createTextNode(i4));
          }
        }
        var m2 = null, p2 = 0;
        function f2(t4, e4) {
          var n4, i4, o3;
          if (e4.singleton) {
            var r3 = p2++;
            n4 = m2 || (m2 = l2(e4)), i4 = u2.bind(null, n4, r3, false), o3 = u2.bind(null, n4, r3, true);
          } else
            n4 = l2(e4), i4 = g2.bind(null, n4, e4), o3 = function() {
              !function(t5) {
                if (null === t5.parentNode)
                  return false;
                t5.parentNode.removeChild(t5);
              }(n4);
            };
          return i4(t4), function(e5) {
            if (e5) {
              if (e5.css === t4.css && e5.media === t4.media && e5.sourceMap === t4.sourceMap)
                return;
              i4(t4 = e5);
            } else
              o3();
          };
        }
        t3.exports = function(t4, e4) {
          (e4 = e4 || {}).singleton || "boolean" == typeof e4.singleton || (e4.singleton = o2());
          var n4 = c2(t4 = t4 || [], e4);
          return function(t5) {
            if (t5 = t5 || [], "[object Array]" === Object.prototype.toString.call(t5)) {
              for (var i4 = 0; i4 < n4.length; i4++) {
                var o3 = a2(n4[i4]);
                s2[o3].references--;
              }
              for (var r3 = c2(t5, e4), l3 = 0; l3 < n4.length; l3++) {
                var d3 = a2(n4[l3]);
                0 === s2[d3].references && (s2[d3].updater(), s2.splice(d3, 1));
              }
              n4 = r3;
            }
          };
        };
      } }, e2 = {};
      function n2(i3) {
        var o2 = e2[i3];
        if (void 0 !== o2)
          return o2.exports;
        var r2 = e2[i3] = { id: i3, exports: {} };
        return t2[i3](r2, r2.exports, n2), r2.exports;
      }
      n2.n = (t3) => {
        var e3 = t3 && t3.__esModule ? () => t3.default : () => t3;
        return n2.d(e3, { a: e3 }), e3;
      }, n2.d = (t3, e3) => {
        for (var i3 in e3)
          n2.o(e3, i3) && !n2.o(t3, i3) && Object.defineProperty(t3, i3, { enumerable: true, get: e3[i3] });
      }, n2.o = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), n2.nc = void 0;
      var i2 = {};
      return (() => {
        function t3({ emitter: t4, activator: e4, callback: n3, contextElements: i3 }) {
          t4.listenTo(document, "mousedown", (t5, o3) => {
            if (!e4())
              return;
            const r3 = "function" == typeof o3.composedPath ? o3.composedPath() : [], s3 = "function" == typeof i3 ? i3() : i3;
            for (const t6 of s3)
              if (t6.contains(o3.target) || r3.includes(t6))
                return;
            n3();
          });
        }
        function e3(t4) {
          return class extends t4 {
            disableCssTransitions() {
              this._isCssTransitionsDisabled = true;
            }
            enableCssTransitions() {
              this._isCssTransitionsDisabled = false;
            }
            constructor(...t5) {
              super(...t5), this.set("_isCssTransitionsDisabled", false), this.initializeCssTransitionDisablerMixin();
            }
            initializeCssTransitionDisablerMixin() {
              this.extendTemplate({ attributes: { class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } });
            }
          };
        }
        function o2({ view: t4 }) {
          t4.listenTo(t4.element, "submit", (e4, n3) => {
            n3.preventDefault(), t4.fire("submit");
          }, { useCapture: true });
        }
        function r2({ keystrokeHandler: t4, focusTracker: e4, gridItems: n3, numberOfColumns: i3, uiLanguageDirection: o3 }) {
          const r3 = "number" == typeof i3 ? () => i3 : i3;
          function s3(t5) {
            return (i4) => {
              const o4 = n3.find((t6) => t6.element === e4.focusedElement), r4 = n3.getIndex(o4), s4 = t5(r4, n3);
              n3.get(s4).focus(), i4.stopPropagation(), i4.preventDefault();
            };
          }
          function a3(t5, e5) {
            return t5 === e5 - 1 ? 0 : t5 + 1;
          }
          function c3(t5, e5) {
            return 0 === t5 ? e5 - 1 : t5 - 1;
          }
          t4.set("arrowright", s3((t5, e5) => "rtl" === o3 ? c3(t5, e5.length) : a3(t5, e5.length))), t4.set("arrowleft", s3((t5, e5) => "rtl" === o3 ? a3(t5, e5.length) : c3(t5, e5.length))), t4.set("arrowup", s3((t5, e5) => {
            let n4 = t5 - r3();
            return n4 < 0 && (n4 = t5 + r3() * Math.floor(e5.length / r3()), n4 > e5.length - 1 && (n4 -= r3())), n4;
          })), t4.set("arrowdown", s3((t5, e5) => {
            let n4 = t5 + r3();
            return n4 > e5.length - 1 && (n4 = t5 % r3()), n4;
          }));
        }
        n2.d(i2, { default: () => kM });
        const s2 = function() {
          try {
            return navigator.userAgent.toLowerCase();
          } catch (t4) {
            return "";
          }
        }(), a2 = { isMac: l2(s2), isWindows: function(t4) {
          return t4.indexOf("windows") > -1;
        }(s2), isGecko: function(t4) {
          return !!t4.match(/gecko\/\d+/);
        }(s2), isSafari: function(t4) {
          return t4.indexOf(" applewebkit/") > -1 && -1 === t4.indexOf("chrome");
        }(s2), isiOS: function(t4) {
          return !!t4.match(/iphone|ipad/i) || l2(t4) && navigator.maxTouchPoints > 0;
        }(s2), isAndroid: function(t4) {
          return t4.indexOf("android") > -1;
        }(s2), isBlink: function(t4) {
          return t4.indexOf("chrome/") > -1 && t4.indexOf("edge/") < 0;
        }(s2), features: { isRegExpUnicodePropertySupported: function() {
          let t4 = false;
          try {
            t4 = 0 === "".search(new RegExp("[\\p{L}]", "u"));
          } catch (t5) {
          }
          return t4;
        }() } }, c2 = a2;
        function l2(t4) {
          return t4.indexOf("macintosh") > -1;
        }
        function d2(t4, e4, n3, i3) {
          n3 = n3 || function(t5, e5) {
            return t5 === e5;
          };
          const o3 = Array.isArray(t4) ? t4 : Array.prototype.slice.call(t4), r3 = Array.isArray(e4) ? e4 : Array.prototype.slice.call(e4), s3 = function(t5, e5, n4) {
            const i4 = h2(t5, e5, n4);
            if (-1 === i4)
              return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
            const o4 = u2(t5, i4), r4 = u2(e5, i4), s4 = h2(o4, r4, n4), a4 = t5.length - s4, c3 = e5.length - s4;
            return { firstIndex: i4, lastIndexOld: a4, lastIndexNew: c3 };
          }(o3, r3, n3), a3 = i3 ? function(t5, e5) {
            const { firstIndex: n4, lastIndexOld: i4, lastIndexNew: o4 } = t5;
            if (-1 === n4)
              return Array(e5).fill("equal");
            let r4 = [];
            n4 > 0 && (r4 = r4.concat(Array(n4).fill("equal")));
            o4 - n4 > 0 && (r4 = r4.concat(Array(o4 - n4).fill("insert")));
            i4 - n4 > 0 && (r4 = r4.concat(Array(i4 - n4).fill("delete")));
            o4 < e5 && (r4 = r4.concat(Array(e5 - o4).fill("equal")));
            return r4;
          }(s3, r3.length) : function(t5, e5) {
            const n4 = [], { firstIndex: i4, lastIndexOld: o4, lastIndexNew: r4 } = e5;
            r4 - i4 > 0 && n4.push({ index: i4, type: "insert", values: t5.slice(i4, r4) });
            o4 - i4 > 0 && n4.push({ index: i4 + (r4 - i4), type: "delete", howMany: o4 - i4 });
            return n4;
          }(r3, s3);
          return a3;
        }
        function h2(t4, e4, n3) {
          for (let i3 = 0; i3 < Math.max(t4.length, e4.length); i3++)
            if (void 0 === t4[i3] || void 0 === e4[i3] || !n3(t4[i3], e4[i3]))
              return i3;
          return -1;
        }
        function u2(t4, e4) {
          return t4.slice(e4).reverse();
        }
        function g2(t4, e4, n3) {
          n3 = n3 || function(t5, e5) {
            return t5 === e5;
          };
          const i3 = t4.length, o3 = e4.length;
          if (i3 > 200 || o3 > 200 || i3 + o3 > 300)
            return g2.fastDiff(t4, e4, n3, true);
          let r3, s3;
          if (o3 < i3) {
            const n4 = t4;
            t4 = e4, e4 = n4, r3 = "delete", s3 = "insert";
          } else
            r3 = "insert", s3 = "delete";
          const a3 = t4.length, c3 = e4.length, l3 = c3 - a3, d3 = {}, h3 = {};
          function u3(i4) {
            const o4 = (void 0 !== h3[i4 - 1] ? h3[i4 - 1] : -1) + 1, l4 = void 0 !== h3[i4 + 1] ? h3[i4 + 1] : -1, u4 = o4 > l4 ? -1 : 1;
            d3[i4 + u4] && (d3[i4] = d3[i4 + u4].slice(0)), d3[i4] || (d3[i4] = []), d3[i4].push(o4 > l4 ? r3 : s3);
            let g3 = Math.max(o4, l4), m4 = g3 - i4;
            for (; m4 < a3 && g3 < c3 && n3(t4[m4], e4[g3]); )
              m4++, g3++, d3[i4].push("equal");
            return g3;
          }
          let m3, p3 = 0;
          do {
            for (m3 = -p3; m3 < l3; m3++)
              h3[m3] = u3(m3);
            for (m3 = l3 + p3; m3 > l3; m3--)
              h3[m3] = u3(m3);
            h3[l3] = u3(l3), p3++;
          } while (h3[l3] !== c3);
          return d3[l3].slice(1);
        }
        g2.fastDiff = d2;
        const m2 = function() {
          return function t4() {
            t4.called = true;
          };
        };
        class p2 {
          constructor(t4, e4) {
            this.source = t4, this.name = e4, this.path = [], this.stop = m2(), this.off = m2();
          }
        }
        const f2 = new Array(256).fill("").map((t4, e4) => ("0" + e4.toString(16)).slice(-2));
        function k2() {
          const t4 = 4294967296 * Math.random() >>> 0, e4 = 4294967296 * Math.random() >>> 0, n3 = 4294967296 * Math.random() >>> 0, i3 = 4294967296 * Math.random() >>> 0;
          return "e" + f2[t4 >> 0 & 255] + f2[t4 >> 8 & 255] + f2[t4 >> 16 & 255] + f2[t4 >> 24 & 255] + f2[e4 >> 0 & 255] + f2[e4 >> 8 & 255] + f2[e4 >> 16 & 255] + f2[e4 >> 24 & 255] + f2[n3 >> 0 & 255] + f2[n3 >> 8 & 255] + f2[n3 >> 16 & 255] + f2[n3 >> 24 & 255] + f2[i3 >> 0 & 255] + f2[i3 >> 8 & 255] + f2[i3 >> 16 & 255] + f2[i3 >> 24 & 255];
        }
        const b2 = { get(t4 = "normal") {
          return "number" != typeof t4 ? this[t4] || this.normal : t4;
        }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 };
        function w2(t4, e4) {
          const n3 = b2.get(e4.priority);
          for (let i3 = 0; i3 < t4.length; i3++)
            if (b2.get(t4[i3].priority) < n3)
              return void t4.splice(i3, 0, e4);
          t4.push(e4);
        }
        const A2 = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
        class C2 extends Error {
          constructor(t4, e4, n3) {
            super(function(t5, e5) {
              const n4 = /* @__PURE__ */ new WeakSet(), i3 = (t6, e6) => {
                if ("object" == typeof e6 && null !== e6) {
                  if (n4.has(e6))
                    return `[object ${e6.constructor.name}]`;
                  n4.add(e6);
                }
                return e6;
              }, o3 = e5 ? ` ${JSON.stringify(e5, i3)}` : "", r3 = v2(t5);
              return t5 + o3 + r3;
            }(t4, n3)), this.name = "CKEditorError", this.context = e4, this.data = n3;
          }
          is(t4) {
            return "CKEditorError" === t4;
          }
          static rethrowUnexpectedError(t4, e4) {
            if (t4.is && t4.is("CKEditorError"))
              throw t4;
            const n3 = new C2(t4.message, e4);
            throw n3.stack = t4.stack, n3;
          }
        }
        function _2(t4, e4) {
          console.warn(...y2(t4, e4));
        }
        function v2(t4) {
          return `
Read more: ${A2}#error-${t4}`;
        }
        function y2(t4, e4) {
          const n3 = v2(t4);
          return e4 ? [t4, e4, n3] : [t4, n3];
        }
        const x2 = "40.1.0", E2 = new Date(2023, 10, 15);
        if (globalThis.CKEDITOR_VERSION)
          throw new C2("ckeditor-duplicated-modules", null);
        globalThis.CKEDITOR_VERSION = x2;
        const D2 = Symbol("listeningTo"), S2 = Symbol("emitterId"), T2 = Symbol("delegations"), I2 = B2(Object);
        function B2(t4) {
          if (!t4)
            return I2;
          return class extends t4 {
            on(t5, e4, n3) {
              this.listenTo(this, t5, e4, n3);
            }
            once(t5, e4, n3) {
              let i3 = false;
              this.listenTo(this, t5, (t6, ...n4) => {
                i3 || (i3 = true, t6.off(), e4.call(this, t6, ...n4));
              }, n3);
            }
            off(t5, e4) {
              this.stopListening(this, t5, e4);
            }
            listenTo(t5, e4, n3, i3 = {}) {
              let o3, r3;
              this[D2] || (this[D2] = {});
              const s3 = this[D2];
              N2(t5) || M2(t5);
              const a3 = N2(t5);
              (o3 = s3[a3]) || (o3 = s3[a3] = { emitter: t5, callbacks: {} }), (r3 = o3.callbacks[e4]) || (r3 = o3.callbacks[e4] = []), r3.push(n3), function(t6, e5, n4, i4, o4) {
                e5._addEventListener ? e5._addEventListener(n4, i4, o4) : t6._addEventListener.call(e5, n4, i4, o4);
              }(this, t5, e4, n3, i3);
            }
            stopListening(t5, e4, n3) {
              const i3 = this[D2];
              let o3 = t5 && N2(t5);
              const r3 = i3 && o3 ? i3[o3] : void 0, s3 = r3 && e4 ? r3.callbacks[e4] : void 0;
              if (!(!i3 || t5 && !r3 || e4 && !s3))
                if (n3) {
                  O2(this, t5, e4, n3);
                  -1 !== s3.indexOf(n3) && (1 === s3.length ? delete r3.callbacks[e4] : O2(this, t5, e4, n3));
                } else if (s3) {
                  for (; n3 = s3.pop(); )
                    O2(this, t5, e4, n3);
                  delete r3.callbacks[e4];
                } else if (r3) {
                  for (e4 in r3.callbacks)
                    this.stopListening(t5, e4);
                  delete i3[o3];
                } else {
                  for (o3 in i3)
                    this.stopListening(i3[o3].emitter);
                  delete this[D2];
                }
            }
            fire(t5, ...e4) {
              try {
                const n3 = t5 instanceof p2 ? t5 : new p2(this, t5), i3 = n3.name;
                let o3 = P2(this, i3);
                if (n3.path.push(this), o3) {
                  const t6 = [n3, ...e4];
                  o3 = Array.from(o3);
                  for (let e5 = 0; e5 < o3.length && (o3[e5].callback.apply(this, t6), n3.off.called && (delete n3.off.called, this._removeEventListener(i3, o3[e5].callback)), !n3.stop.called); e5++)
                    ;
                }
                const r3 = this[T2];
                if (r3) {
                  const t6 = r3.get(i3), o4 = r3.get("*");
                  t6 && R2(t6, n3, e4), o4 && R2(o4, n3, e4);
                }
                return n3.return;
              } catch (t6) {
                C2.rethrowUnexpectedError(t6, this);
              }
            }
            delegate(...t5) {
              return { to: (e4, n3) => {
                this[T2] || (this[T2] = /* @__PURE__ */ new Map()), t5.forEach((t6) => {
                  const i3 = this[T2].get(t6);
                  i3 ? i3.set(e4, n3) : this[T2].set(t6, /* @__PURE__ */ new Map([[e4, n3]]));
                });
              } };
            }
            stopDelegating(t5, e4) {
              if (this[T2])
                if (t5)
                  if (e4) {
                    const n3 = this[T2].get(t5);
                    n3 && n3.delete(e4);
                  } else
                    this[T2].delete(t5);
                else
                  this[T2].clear();
            }
            _addEventListener(t5, e4, n3) {
              !function(t6, e5) {
                const n4 = L2(t6);
                if (n4[e5])
                  return;
                let i4 = e5, o4 = null;
                const r3 = [];
                for (; "" !== i4 && !n4[i4]; )
                  n4[i4] = { callbacks: [], childEvents: [] }, r3.push(n4[i4]), o4 && n4[i4].childEvents.push(o4), o4 = i4, i4 = i4.substr(0, i4.lastIndexOf(":"));
                if ("" !== i4) {
                  for (const t7 of r3)
                    t7.callbacks = n4[i4].callbacks.slice();
                  n4[i4].childEvents.push(o4);
                }
              }(this, t5);
              const i3 = z2(this, t5), o3 = { callback: e4, priority: b2.get(n3.priority) };
              for (const t6 of i3)
                w2(t6, o3);
            }
            _removeEventListener(t5, e4) {
              const n3 = z2(this, t5);
              for (const t6 of n3)
                for (let n4 = 0; n4 < t6.length; n4++)
                  t6[n4].callback == e4 && (t6.splice(n4, 1), n4--);
            }
          };
        }
        function M2(t4, e4) {
          t4[S2] || (t4[S2] = e4 || k2());
        }
        function N2(t4) {
          return t4[S2];
        }
        function L2(t4) {
          return t4._events || Object.defineProperty(t4, "_events", { value: {} }), t4._events;
        }
        function z2(t4, e4) {
          const n3 = L2(t4)[e4];
          if (!n3)
            return [];
          let i3 = [n3.callbacks];
          for (let e5 = 0; e5 < n3.childEvents.length; e5++) {
            const o3 = z2(t4, n3.childEvents[e5]);
            i3 = i3.concat(o3);
          }
          return i3;
        }
        function P2(t4, e4) {
          let n3;
          return t4._events && (n3 = t4._events[e4]) && n3.callbacks.length ? n3.callbacks : e4.indexOf(":") > -1 ? P2(t4, e4.substr(0, e4.lastIndexOf(":"))) : null;
        }
        function R2(t4, e4, n3) {
          for (let [i3, o3] of t4) {
            o3 ? "function" == typeof o3 && (o3 = o3(e4.name)) : o3 = e4.name;
            const t5 = new p2(e4.source, o3);
            t5.path = [...e4.path], i3.fire(t5, ...n3);
          }
        }
        function O2(t4, e4, n3, i3) {
          e4._removeEventListener ? e4._removeEventListener(n3, i3) : t4._removeEventListener.call(e4, n3, i3);
        }
        ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t4) => {
          B2[t4] = I2.prototype[t4];
        });
        const F2 = function(t4) {
          var e4 = typeof t4;
          return null != t4 && ("object" == e4 || "function" == e4);
        }, V2 = Symbol("observableProperties"), j2 = Symbol("boundObservables"), H2 = Symbol("boundProperties"), U2 = Symbol("decoratedMethods"), G2 = Symbol("decoratedOriginal"), W2 = q2(B2());
        function q2(t4) {
          if (!t4)
            return W2;
          return class extends t4 {
            set(t5, e4) {
              if (F2(t5))
                return void Object.keys(t5).forEach((e5) => {
                  this.set(e5, t5[e5]);
                }, this);
              $2(this);
              const n3 = this[V2];
              if (t5 in this && !n3.has(t5))
                throw new C2("observable-set-cannot-override", this);
              Object.defineProperty(this, t5, { enumerable: true, configurable: true, get: () => n3.get(t5), set(e5) {
                const i3 = n3.get(t5);
                let o3 = this.fire(`set:${t5}`, t5, e5, i3);
                void 0 === o3 && (o3 = e5), i3 === o3 && n3.has(t5) || (n3.set(t5, o3), this.fire(`change:${t5}`, t5, o3, i3));
              } }), this[t5] = e4;
            }
            bind(...t5) {
              if (!t5.length || !Y2(t5))
                throw new C2("observable-bind-wrong-properties", this);
              if (new Set(t5).size !== t5.length)
                throw new C2("observable-bind-duplicate-properties", this);
              $2(this);
              const e4 = this[H2];
              t5.forEach((t6) => {
                if (e4.has(t6))
                  throw new C2("observable-bind-rebind", this);
              });
              const n3 = /* @__PURE__ */ new Map();
              return t5.forEach((t6) => {
                const i3 = { property: t6, to: [] };
                e4.set(t6, i3), n3.set(t6, i3);
              }), { to: K2, toMany: Z2, _observable: this, _bindProperties: t5, _to: [], _bindings: n3 };
            }
            unbind(...t5) {
              if (!this[V2])
                return;
              const e4 = this[H2], n3 = this[j2];
              if (t5.length) {
                if (!Y2(t5))
                  throw new C2("observable-unbind-wrong-properties", this);
                t5.forEach((t6) => {
                  const i3 = e4.get(t6);
                  i3 && (i3.to.forEach(([t7, e5]) => {
                    const o3 = n3.get(t7), r3 = o3[e5];
                    r3.delete(i3), r3.size || delete o3[e5], Object.keys(o3).length || (n3.delete(t7), this.stopListening(t7, "change"));
                  }), e4.delete(t6));
                });
              } else
                n3.forEach((t6, e5) => {
                  this.stopListening(e5, "change");
                }), n3.clear(), e4.clear();
            }
            decorate(t5) {
              $2(this);
              const e4 = this[t5];
              if (!e4)
                throw new C2("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: t5 });
              this.on(t5, (t6, n3) => {
                t6.return = e4.apply(this, n3);
              }), this[t5] = function(...e5) {
                return this.fire(t5, e5);
              }, this[t5][G2] = e4, this[U2] || (this[U2] = []), this[U2].push(t5);
            }
            stopListening(t5, e4, n3) {
              if (!t5 && this[U2]) {
                for (const t6 of this[U2])
                  this[t6] = this[t6][G2];
                delete this[U2];
              }
              super.stopListening(t5, e4, n3);
            }
          };
        }
        function $2(t4) {
          t4[V2] || (Object.defineProperty(t4, V2, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(t4, j2, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(t4, H2, { value: /* @__PURE__ */ new Map() }));
        }
        function K2(...t4) {
          const e4 = function(...t5) {
            if (!t5.length)
              throw new C2("observable-bind-to-parse-error", null);
            const e5 = { to: [] };
            let n4;
            "function" == typeof t5[t5.length - 1] && (e5.callback = t5.pop());
            return t5.forEach((t6) => {
              if ("string" == typeof t6)
                n4.properties.push(t6);
              else {
                if ("object" != typeof t6)
                  throw new C2("observable-bind-to-parse-error", null);
                n4 = { observable: t6, properties: [] }, e5.to.push(n4);
              }
            }), e5;
          }(...t4), n3 = Array.from(this._bindings.keys()), i3 = n3.length;
          if (!e4.callback && e4.to.length > 1)
            throw new C2("observable-bind-to-no-callback", this);
          if (i3 > 1 && e4.callback)
            throw new C2("observable-bind-to-extra-callback", this);
          var o3;
          e4.to.forEach((t5) => {
            if (t5.properties.length && t5.properties.length !== i3)
              throw new C2("observable-bind-to-properties-length", this);
            t5.properties.length || (t5.properties = this._bindProperties);
          }), this._to = e4.to, e4.callback && (this._bindings.get(n3[0]).callback = e4.callback), o3 = this._observable, this._to.forEach((t5) => {
            const e5 = o3[j2];
            let n4;
            e5.get(t5.observable) || o3.listenTo(t5.observable, "change", (i4, r3) => {
              n4 = e5.get(t5.observable)[r3], n4 && n4.forEach((t6) => {
                Q2(o3, t6.property);
              });
            });
          }), function(t5) {
            let e5;
            t5._bindings.forEach((n4, i4) => {
              t5._to.forEach((o4) => {
                e5 = o4.properties[n4.callback ? 0 : t5._bindProperties.indexOf(i4)], n4.to.push([o4.observable, e5]), function(t6, e6, n5, i5) {
                  const o5 = t6[j2], r3 = o5.get(n5), s3 = r3 || {};
                  s3[i5] || (s3[i5] = /* @__PURE__ */ new Set());
                  s3[i5].add(e6), r3 || o5.set(n5, s3);
                }(t5._observable, n4, o4.observable, e5);
              });
            });
          }(this), this._bindProperties.forEach((t5) => {
            Q2(this._observable, t5);
          });
        }
        function Z2(t4, e4, n3) {
          if (this._bindings.size > 1)
            throw new C2("observable-bind-to-many-not-one-binding", this);
          this.to(...function(t5, e5) {
            const n4 = t5.map((t6) => [t6, e5]);
            return Array.prototype.concat.apply([], n4);
          }(t4, e4), n3);
        }
        function Y2(t4) {
          return t4.every((t5) => "string" == typeof t5);
        }
        function Q2(t4, e4) {
          const n3 = t4[H2].get(e4);
          let i3;
          n3.callback ? i3 = n3.callback.apply(t4, n3.to.map((t5) => t5[0][t5[1]])) : (i3 = n3.to[0], i3 = i3[0][i3[1]]), Object.prototype.hasOwnProperty.call(t4, e4) ? t4[e4] = i3 : t4.set(e4, i3);
        }
        ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t4) => {
          q2[t4] = W2.prototype[t4];
        });
        class J2 {
          constructor() {
            this._replacedElements = [];
          }
          replace(t4, e4) {
            this._replacedElements.push({ element: t4, newElement: e4 }), t4.style.display = "none", e4 && t4.parentNode.insertBefore(e4, t4.nextSibling);
          }
          restore() {
            this._replacedElements.forEach(({ element: t4, newElement: e4 }) => {
              t4.style.display = "", e4 && e4.remove();
            }), this._replacedElements = [];
          }
        }
        function X2(t4) {
          let e4 = 0;
          for (const n3 of t4)
            e4++;
          return e4;
        }
        function tt2(t4, e4) {
          const n3 = Math.min(t4.length, e4.length);
          for (let i3 = 0; i3 < n3; i3++)
            if (t4[i3] != e4[i3])
              return i3;
          return t4.length == e4.length ? "same" : t4.length < e4.length ? "prefix" : "extension";
        }
        function et2(t4) {
          return !(!t4 || !t4[Symbol.iterator]);
        }
        const nt2 = "object" == typeof global && global && global.Object === Object && global;
        var it2 = "object" == typeof self && self && self.Object === Object && self;
        const ot2 = nt2 || it2 || Function("return this")();
        const rt2 = ot2.Symbol;
        var st2 = Object.prototype, at2 = st2.hasOwnProperty, ct2 = st2.toString, lt2 = rt2 ? rt2.toStringTag : void 0;
        const dt2 = function(t4) {
          var e4 = at2.call(t4, lt2), n3 = t4[lt2];
          try {
            t4[lt2] = void 0;
            var i3 = true;
          } catch (t5) {
          }
          var o3 = ct2.call(t4);
          return i3 && (e4 ? t4[lt2] = n3 : delete t4[lt2]), o3;
        };
        var ht2 = Object.prototype.toString;
        const ut2 = function(t4) {
          return ht2.call(t4);
        };
        var gt2 = rt2 ? rt2.toStringTag : void 0;
        const mt2 = function(t4) {
          return null == t4 ? void 0 === t4 ? "[object Undefined]" : "[object Null]" : gt2 && gt2 in Object(t4) ? dt2(t4) : ut2(t4);
        };
        const pt2 = Array.isArray;
        const ft2 = function(t4) {
          return null != t4 && "object" == typeof t4;
        };
        const kt2 = function(t4) {
          return "string" == typeof t4 || !pt2(t4) && ft2(t4) && "[object String]" == mt2(t4);
        };
        function bt2(t4, e4, n3 = {}, i3 = []) {
          const o3 = n3 && n3.xmlns, r3 = o3 ? t4.createElementNS(o3, e4) : t4.createElement(e4);
          for (const t5 in n3)
            r3.setAttribute(t5, n3[t5]);
          !kt2(i3) && et2(i3) || (i3 = [i3]);
          for (let e5 of i3)
            kt2(e5) && (e5 = t4.createTextNode(e5)), r3.appendChild(e5);
          return r3;
        }
        const wt2 = function(t4, e4) {
          return function(n3) {
            return t4(e4(n3));
          };
        };
        const At2 = wt2(Object.getPrototypeOf, Object);
        var Ct2 = Function.prototype, _t5 = Object.prototype, vt2 = Ct2.toString, yt2 = _t5.hasOwnProperty, xt2 = vt2.call(Object);
        const Et2 = function(t4) {
          if (!ft2(t4) || "[object Object]" != mt2(t4))
            return false;
          var e4 = At2(t4);
          if (null === e4)
            return true;
          var n3 = yt2.call(e4, "constructor") && e4.constructor;
          return "function" == typeof n3 && n3 instanceof n3 && vt2.call(n3) == xt2;
        };
        const Dt2 = function() {
          this.__data__ = [], this.size = 0;
        };
        const St2 = function(t4, e4) {
          return t4 === e4 || t4 != t4 && e4 != e4;
        };
        const Tt2 = function(t4, e4) {
          for (var n3 = t4.length; n3--; )
            if (St2(t4[n3][0], e4))
              return n3;
          return -1;
        };
        var It2 = Array.prototype.splice;
        const Bt2 = function(t4) {
          var e4 = this.__data__, n3 = Tt2(e4, t4);
          return !(n3 < 0) && (n3 == e4.length - 1 ? e4.pop() : It2.call(e4, n3, 1), --this.size, true);
        };
        const Mt = function(t4) {
          var e4 = this.__data__, n3 = Tt2(e4, t4);
          return n3 < 0 ? void 0 : e4[n3][1];
        };
        const Nt2 = function(t4) {
          return Tt2(this.__data__, t4) > -1;
        };
        const Lt = function(t4, e4) {
          var n3 = this.__data__, i3 = Tt2(n3, t4);
          return i3 < 0 ? (++this.size, n3.push([t4, e4])) : n3[i3][1] = e4, this;
        };
        function zt2(t4) {
          var e4 = -1, n3 = null == t4 ? 0 : t4.length;
          for (this.clear(); ++e4 < n3; ) {
            var i3 = t4[e4];
            this.set(i3[0], i3[1]);
          }
        }
        zt2.prototype.clear = Dt2, zt2.prototype.delete = Bt2, zt2.prototype.get = Mt, zt2.prototype.has = Nt2, zt2.prototype.set = Lt;
        const Pt2 = zt2;
        const Rt2 = function() {
          this.__data__ = new Pt2(), this.size = 0;
        };
        const Ot2 = function(t4) {
          var e4 = this.__data__, n3 = e4.delete(t4);
          return this.size = e4.size, n3;
        };
        const Ft2 = function(t4) {
          return this.__data__.get(t4);
        };
        const Vt2 = function(t4) {
          return this.__data__.has(t4);
        };
        const jt2 = function(t4) {
          if (!F2(t4))
            return false;
          var e4 = mt2(t4);
          return "[object Function]" == e4 || "[object GeneratorFunction]" == e4 || "[object AsyncFunction]" == e4 || "[object Proxy]" == e4;
        };
        const Ht2 = ot2["__core-js_shared__"];
        var Ut2 = function() {
          var t4 = /[^.]+$/.exec(Ht2 && Ht2.keys && Ht2.keys.IE_PROTO || "");
          return t4 ? "Symbol(src)_1." + t4 : "";
        }();
        const Gt2 = function(t4) {
          return !!Ut2 && Ut2 in t4;
        };
        var Wt2 = Function.prototype.toString;
        const qt2 = function(t4) {
          if (null != t4) {
            try {
              return Wt2.call(t4);
            } catch (t5) {
            }
            try {
              return t4 + "";
            } catch (t5) {
            }
          }
          return "";
        };
        var $t2 = /^\[object .+?Constructor\]$/, Kt2 = Function.prototype, Zt2 = Object.prototype, Yt2 = Kt2.toString, Qt2 = Zt2.hasOwnProperty, Jt2 = RegExp("^" + Yt2.call(Qt2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        const Xt2 = function(t4) {
          return !(!F2(t4) || Gt2(t4)) && (jt2(t4) ? Jt2 : $t2).test(qt2(t4));
        };
        const te2 = function(t4, e4) {
          return null == t4 ? void 0 : t4[e4];
        };
        const ee2 = function(t4, e4) {
          var n3 = te2(t4, e4);
          return Xt2(n3) ? n3 : void 0;
        };
        const ne2 = ee2(ot2, "Map");
        const ie2 = ee2(Object, "create");
        const oe2 = function() {
          this.__data__ = ie2 ? ie2(null) : {}, this.size = 0;
        };
        const re2 = function(t4) {
          var e4 = this.has(t4) && delete this.__data__[t4];
          return this.size -= e4 ? 1 : 0, e4;
        };
        var se2 = Object.prototype.hasOwnProperty;
        const ae2 = function(t4) {
          var e4 = this.__data__;
          if (ie2) {
            var n3 = e4[t4];
            return "__lodash_hash_undefined__" === n3 ? void 0 : n3;
          }
          return se2.call(e4, t4) ? e4[t4] : void 0;
        };
        var ce2 = Object.prototype.hasOwnProperty;
        const le2 = function(t4) {
          var e4 = this.__data__;
          return ie2 ? void 0 !== e4[t4] : ce2.call(e4, t4);
        };
        const de2 = function(t4, e4) {
          var n3 = this.__data__;
          return this.size += this.has(t4) ? 0 : 1, n3[t4] = ie2 && void 0 === e4 ? "__lodash_hash_undefined__" : e4, this;
        };
        function he2(t4) {
          var e4 = -1, n3 = null == t4 ? 0 : t4.length;
          for (this.clear(); ++e4 < n3; ) {
            var i3 = t4[e4];
            this.set(i3[0], i3[1]);
          }
        }
        he2.prototype.clear = oe2, he2.prototype.delete = re2, he2.prototype.get = ae2, he2.prototype.has = le2, he2.prototype.set = de2;
        const ue2 = he2;
        const ge2 = function() {
          this.size = 0, this.__data__ = { hash: new ue2(), map: new (ne2 || Pt2)(), string: new ue2() };
        };
        const me2 = function(t4) {
          var e4 = typeof t4;
          return "string" == e4 || "number" == e4 || "symbol" == e4 || "boolean" == e4 ? "__proto__" !== t4 : null === t4;
        };
        const pe2 = function(t4, e4) {
          var n3 = t4.__data__;
          return me2(e4) ? n3["string" == typeof e4 ? "string" : "hash"] : n3.map;
        };
        const fe2 = function(t4) {
          var e4 = pe2(this, t4).delete(t4);
          return this.size -= e4 ? 1 : 0, e4;
        };
        const ke2 = function(t4) {
          return pe2(this, t4).get(t4);
        };
        const be2 = function(t4) {
          return pe2(this, t4).has(t4);
        };
        const we2 = function(t4, e4) {
          var n3 = pe2(this, t4), i3 = n3.size;
          return n3.set(t4, e4), this.size += n3.size == i3 ? 0 : 1, this;
        };
        function Ae2(t4) {
          var e4 = -1, n3 = null == t4 ? 0 : t4.length;
          for (this.clear(); ++e4 < n3; ) {
            var i3 = t4[e4];
            this.set(i3[0], i3[1]);
          }
        }
        Ae2.prototype.clear = ge2, Ae2.prototype.delete = fe2, Ae2.prototype.get = ke2, Ae2.prototype.has = be2, Ae2.prototype.set = we2;
        const Ce2 = Ae2;
        const _e2 = function(t4, e4) {
          var n3 = this.__data__;
          if (n3 instanceof Pt2) {
            var i3 = n3.__data__;
            if (!ne2 || i3.length < 199)
              return i3.push([t4, e4]), this.size = ++n3.size, this;
            n3 = this.__data__ = new Ce2(i3);
          }
          return n3.set(t4, e4), this.size = n3.size, this;
        };
        function ve2(t4) {
          var e4 = this.__data__ = new Pt2(t4);
          this.size = e4.size;
        }
        ve2.prototype.clear = Rt2, ve2.prototype.delete = Ot2, ve2.prototype.get = Ft2, ve2.prototype.has = Vt2, ve2.prototype.set = _e2;
        const ye2 = ve2;
        const xe2 = function(t4, e4) {
          for (var n3 = -1, i3 = null == t4 ? 0 : t4.length; ++n3 < i3 && false !== e4(t4[n3], n3, t4); )
            ;
          return t4;
        };
        const Ee2 = function() {
          try {
            var t4 = ee2(Object, "defineProperty");
            return t4({}, "", {}), t4;
          } catch (t5) {
          }
        }();
        const De2 = function(t4, e4, n3) {
          "__proto__" == e4 && Ee2 ? Ee2(t4, e4, { configurable: true, enumerable: true, value: n3, writable: true }) : t4[e4] = n3;
        };
        var Se2 = Object.prototype.hasOwnProperty;
        const Te2 = function(t4, e4, n3) {
          var i3 = t4[e4];
          Se2.call(t4, e4) && St2(i3, n3) && (void 0 !== n3 || e4 in t4) || De2(t4, e4, n3);
        };
        const Ie2 = function(t4, e4, n3, i3) {
          var o3 = !n3;
          n3 || (n3 = {});
          for (var r3 = -1, s3 = e4.length; ++r3 < s3; ) {
            var a3 = e4[r3], c3 = i3 ? i3(n3[a3], t4[a3], a3, n3, t4) : void 0;
            void 0 === c3 && (c3 = t4[a3]), o3 ? De2(n3, a3, c3) : Te2(n3, a3, c3);
          }
          return n3;
        };
        const Be2 = function(t4, e4) {
          for (var n3 = -1, i3 = Array(t4); ++n3 < t4; )
            i3[n3] = e4(n3);
          return i3;
        };
        const Me2 = function(t4) {
          return ft2(t4) && "[object Arguments]" == mt2(t4);
        };
        var Ne2 = Object.prototype, Le2 = Ne2.hasOwnProperty, ze2 = Ne2.propertyIsEnumerable;
        const Pe2 = Me2(function() {
          return arguments;
        }()) ? Me2 : function(t4) {
          return ft2(t4) && Le2.call(t4, "callee") && !ze2.call(t4, "callee");
        };
        const Re2 = function() {
          return false;
        };
        var Oe2 = "object" == typeof exports && exports && !exports.nodeType && exports, Fe2 = Oe2 && "object" == typeof module && module && !module.nodeType && module, Ve2 = Fe2 && Fe2.exports === Oe2 ? ot2.Buffer : void 0;
        const je2 = (Ve2 ? Ve2.isBuffer : void 0) || Re2;
        var He2 = /^(?:0|[1-9]\d*)$/;
        const Ue2 = function(t4, e4) {
          var n3 = typeof t4;
          return !!(e4 = null == e4 ? 9007199254740991 : e4) && ("number" == n3 || "symbol" != n3 && He2.test(t4)) && t4 > -1 && t4 % 1 == 0 && t4 < e4;
        };
        const Ge2 = function(t4) {
          return "number" == typeof t4 && t4 > -1 && t4 % 1 == 0 && t4 <= 9007199254740991;
        };
        var We2 = {};
        We2["[object Float32Array]"] = We2["[object Float64Array]"] = We2["[object Int8Array]"] = We2["[object Int16Array]"] = We2["[object Int32Array]"] = We2["[object Uint8Array]"] = We2["[object Uint8ClampedArray]"] = We2["[object Uint16Array]"] = We2["[object Uint32Array]"] = true, We2["[object Arguments]"] = We2["[object Array]"] = We2["[object ArrayBuffer]"] = We2["[object Boolean]"] = We2["[object DataView]"] = We2["[object Date]"] = We2["[object Error]"] = We2["[object Function]"] = We2["[object Map]"] = We2["[object Number]"] = We2["[object Object]"] = We2["[object RegExp]"] = We2["[object Set]"] = We2["[object String]"] = We2["[object WeakMap]"] = false;
        const qe2 = function(t4) {
          return ft2(t4) && Ge2(t4.length) && !!We2[mt2(t4)];
        };
        const $e2 = function(t4) {
          return function(e4) {
            return t4(e4);
          };
        };
        var Ke2 = "object" == typeof exports && exports && !exports.nodeType && exports, Ze2 = Ke2 && "object" == typeof module && module && !module.nodeType && module, Ye2 = Ze2 && Ze2.exports === Ke2 && nt2.process;
        const Qe2 = function() {
          try {
            var t4 = Ze2 && Ze2.require && Ze2.require("util").types;
            return t4 || Ye2 && Ye2.binding && Ye2.binding("util");
          } catch (t5) {
          }
        }();
        var Je2 = Qe2 && Qe2.isTypedArray;
        const Xe2 = Je2 ? $e2(Je2) : qe2;
        var tn2 = Object.prototype.hasOwnProperty;
        const en2 = function(t4, e4) {
          var n3 = pt2(t4), i3 = !n3 && Pe2(t4), o3 = !n3 && !i3 && je2(t4), r3 = !n3 && !i3 && !o3 && Xe2(t4), s3 = n3 || i3 || o3 || r3, a3 = s3 ? Be2(t4.length, String) : [], c3 = a3.length;
          for (var l3 in t4)
            !e4 && !tn2.call(t4, l3) || s3 && ("length" == l3 || o3 && ("offset" == l3 || "parent" == l3) || r3 && ("buffer" == l3 || "byteLength" == l3 || "byteOffset" == l3) || Ue2(l3, c3)) || a3.push(l3);
          return a3;
        };
        var nn2 = Object.prototype;
        const on2 = function(t4) {
          var e4 = t4 && t4.constructor;
          return t4 === ("function" == typeof e4 && e4.prototype || nn2);
        };
        const rn2 = wt2(Object.keys, Object);
        var sn = Object.prototype.hasOwnProperty;
        const an2 = function(t4) {
          if (!on2(t4))
            return rn2(t4);
          var e4 = [];
          for (var n3 in Object(t4))
            sn.call(t4, n3) && "constructor" != n3 && e4.push(n3);
          return e4;
        };
        const cn2 = function(t4) {
          return null != t4 && Ge2(t4.length) && !jt2(t4);
        };
        const ln = function(t4) {
          return cn2(t4) ? en2(t4) : an2(t4);
        };
        const dn = function(t4, e4) {
          return t4 && Ie2(e4, ln(e4), t4);
        };
        const hn = function(t4) {
          var e4 = [];
          if (null != t4)
            for (var n3 in Object(t4))
              e4.push(n3);
          return e4;
        };
        var un2 = Object.prototype.hasOwnProperty;
        const gn = function(t4) {
          if (!F2(t4))
            return hn(t4);
          var e4 = on2(t4), n3 = [];
          for (var i3 in t4)
            ("constructor" != i3 || !e4 && un2.call(t4, i3)) && n3.push(i3);
          return n3;
        };
        const mn = function(t4) {
          return cn2(t4) ? en2(t4, true) : gn(t4);
        };
        const pn2 = function(t4, e4) {
          return t4 && Ie2(e4, mn(e4), t4);
        };
        var fn2 = "object" == typeof exports && exports && !exports.nodeType && exports, kn = fn2 && "object" == typeof module && module && !module.nodeType && module, bn = kn && kn.exports === fn2 ? ot2.Buffer : void 0, wn = bn ? bn.allocUnsafe : void 0;
        const An = function(t4, e4) {
          if (e4)
            return t4.slice();
          var n3 = t4.length, i3 = wn ? wn(n3) : new t4.constructor(n3);
          return t4.copy(i3), i3;
        };
        const Cn = function(t4, e4) {
          var n3 = -1, i3 = t4.length;
          for (e4 || (e4 = Array(i3)); ++n3 < i3; )
            e4[n3] = t4[n3];
          return e4;
        };
        const _n = function(t4, e4) {
          for (var n3 = -1, i3 = null == t4 ? 0 : t4.length, o3 = 0, r3 = []; ++n3 < i3; ) {
            var s3 = t4[n3];
            e4(s3, n3, t4) && (r3[o3++] = s3);
          }
          return r3;
        };
        const vn = function() {
          return [];
        };
        var yn = Object.prototype.propertyIsEnumerable, xn = Object.getOwnPropertySymbols;
        const En = xn ? function(t4) {
          return null == t4 ? [] : (t4 = Object(t4), _n(xn(t4), function(e4) {
            return yn.call(t4, e4);
          }));
        } : vn;
        const Dn = function(t4, e4) {
          return Ie2(t4, En(t4), e4);
        };
        const Sn = function(t4, e4) {
          for (var n3 = -1, i3 = e4.length, o3 = t4.length; ++n3 < i3; )
            t4[o3 + n3] = e4[n3];
          return t4;
        };
        const Tn = Object.getOwnPropertySymbols ? function(t4) {
          for (var e4 = []; t4; )
            Sn(e4, En(t4)), t4 = At2(t4);
          return e4;
        } : vn;
        const In = function(t4, e4) {
          return Ie2(t4, Tn(t4), e4);
        };
        const Bn = function(t4, e4, n3) {
          var i3 = e4(t4);
          return pt2(t4) ? i3 : Sn(i3, n3(t4));
        };
        const Mn = function(t4) {
          return Bn(t4, ln, En);
        };
        const Nn = function(t4) {
          return Bn(t4, mn, Tn);
        };
        const Ln = ee2(ot2, "DataView");
        const zn = ee2(ot2, "Promise");
        const Pn = ee2(ot2, "Set");
        const Rn = ee2(ot2, "WeakMap");
        var On = "[object Map]", Fn = "[object Promise]", Vn = "[object Set]", jn = "[object WeakMap]", Hn = "[object DataView]", Un = qt2(Ln), Gn = qt2(ne2), Wn = qt2(zn), qn = qt2(Pn), $n = qt2(Rn), Kn = mt2;
        (Ln && Kn(new Ln(new ArrayBuffer(1))) != Hn || ne2 && Kn(new ne2()) != On || zn && Kn(zn.resolve()) != Fn || Pn && Kn(new Pn()) != Vn || Rn && Kn(new Rn()) != jn) && (Kn = function(t4) {
          var e4 = mt2(t4), n3 = "[object Object]" == e4 ? t4.constructor : void 0, i3 = n3 ? qt2(n3) : "";
          if (i3)
            switch (i3) {
              case Un:
                return Hn;
              case Gn:
                return On;
              case Wn:
                return Fn;
              case qn:
                return Vn;
              case $n:
                return jn;
            }
          return e4;
        });
        const Zn = Kn;
        var Yn = Object.prototype.hasOwnProperty;
        const Qn = function(t4) {
          var e4 = t4.length, n3 = new t4.constructor(e4);
          return e4 && "string" == typeof t4[0] && Yn.call(t4, "index") && (n3.index = t4.index, n3.input = t4.input), n3;
        };
        const Jn = ot2.Uint8Array;
        const Xn = function(t4) {
          var e4 = new t4.constructor(t4.byteLength);
          return new Jn(e4).set(new Jn(t4)), e4;
        };
        const ti2 = function(t4, e4) {
          var n3 = e4 ? Xn(t4.buffer) : t4.buffer;
          return new t4.constructor(n3, t4.byteOffset, t4.byteLength);
        };
        var ei2 = /\w*$/;
        const ni2 = function(t4) {
          var e4 = new t4.constructor(t4.source, ei2.exec(t4));
          return e4.lastIndex = t4.lastIndex, e4;
        };
        var ii2 = rt2 ? rt2.prototype : void 0, oi2 = ii2 ? ii2.valueOf : void 0;
        const ri2 = function(t4) {
          return oi2 ? Object(oi2.call(t4)) : {};
        };
        const si2 = function(t4, e4) {
          var n3 = e4 ? Xn(t4.buffer) : t4.buffer;
          return new t4.constructor(n3, t4.byteOffset, t4.length);
        };
        const ai2 = function(t4, e4, n3) {
          var i3 = t4.constructor;
          switch (e4) {
            case "[object ArrayBuffer]":
              return Xn(t4);
            case "[object Boolean]":
            case "[object Date]":
              return new i3(+t4);
            case "[object DataView]":
              return ti2(t4, n3);
            case "[object Float32Array]":
            case "[object Float64Array]":
            case "[object Int8Array]":
            case "[object Int16Array]":
            case "[object Int32Array]":
            case "[object Uint8Array]":
            case "[object Uint8ClampedArray]":
            case "[object Uint16Array]":
            case "[object Uint32Array]":
              return si2(t4, n3);
            case "[object Map]":
            case "[object Set]":
              return new i3();
            case "[object Number]":
            case "[object String]":
              return new i3(t4);
            case "[object RegExp]":
              return ni2(t4);
            case "[object Symbol]":
              return ri2(t4);
          }
        };
        var ci2 = Object.create;
        const li2 = function() {
          function t4() {
          }
          return function(e4) {
            if (!F2(e4))
              return {};
            if (ci2)
              return ci2(e4);
            t4.prototype = e4;
            var n3 = new t4();
            return t4.prototype = void 0, n3;
          };
        }();
        const di2 = function(t4) {
          return "function" != typeof t4.constructor || on2(t4) ? {} : li2(At2(t4));
        };
        const hi2 = function(t4) {
          return ft2(t4) && "[object Map]" == Zn(t4);
        };
        var ui2 = Qe2 && Qe2.isMap;
        const gi2 = ui2 ? $e2(ui2) : hi2;
        const mi2 = function(t4) {
          return ft2(t4) && "[object Set]" == Zn(t4);
        };
        var pi2 = Qe2 && Qe2.isSet;
        const fi2 = pi2 ? $e2(pi2) : mi2;
        var ki2 = "[object Arguments]", bi2 = "[object Function]", wi2 = "[object Object]", Ai2 = {};
        Ai2[ki2] = Ai2["[object Array]"] = Ai2["[object ArrayBuffer]"] = Ai2["[object DataView]"] = Ai2["[object Boolean]"] = Ai2["[object Date]"] = Ai2["[object Float32Array]"] = Ai2["[object Float64Array]"] = Ai2["[object Int8Array]"] = Ai2["[object Int16Array]"] = Ai2["[object Int32Array]"] = Ai2["[object Map]"] = Ai2["[object Number]"] = Ai2[wi2] = Ai2["[object RegExp]"] = Ai2["[object Set]"] = Ai2["[object String]"] = Ai2["[object Symbol]"] = Ai2["[object Uint8Array]"] = Ai2["[object Uint8ClampedArray]"] = Ai2["[object Uint16Array]"] = Ai2["[object Uint32Array]"] = true, Ai2["[object Error]"] = Ai2[bi2] = Ai2["[object WeakMap]"] = false;
        const Ci2 = function t4(e4, n3, i3, o3, r3, s3) {
          var a3, c3 = 1 & n3, l3 = 2 & n3, d3 = 4 & n3;
          if (i3 && (a3 = r3 ? i3(e4, o3, r3, s3) : i3(e4)), void 0 !== a3)
            return a3;
          if (!F2(e4))
            return e4;
          var h3 = pt2(e4);
          if (h3) {
            if (a3 = Qn(e4), !c3)
              return Cn(e4, a3);
          } else {
            var u3 = Zn(e4), g3 = u3 == bi2 || "[object GeneratorFunction]" == u3;
            if (je2(e4))
              return An(e4, c3);
            if (u3 == wi2 || u3 == ki2 || g3 && !r3) {
              if (a3 = l3 || g3 ? {} : di2(e4), !c3)
                return l3 ? In(e4, pn2(a3, e4)) : Dn(e4, dn(a3, e4));
            } else {
              if (!Ai2[u3])
                return r3 ? e4 : {};
              a3 = ai2(e4, u3, c3);
            }
          }
          s3 || (s3 = new ye2());
          var m3 = s3.get(e4);
          if (m3)
            return m3;
          s3.set(e4, a3), fi2(e4) ? e4.forEach(function(o4) {
            a3.add(t4(o4, n3, i3, o4, e4, s3));
          }) : gi2(e4) && e4.forEach(function(o4, r4) {
            a3.set(r4, t4(o4, n3, i3, r4, e4, s3));
          });
          var p3 = h3 ? void 0 : (d3 ? l3 ? Nn : Mn : l3 ? mn : ln)(e4);
          return xe2(p3 || e4, function(o4, r4) {
            p3 && (o4 = e4[r4 = o4]), Te2(a3, r4, t4(o4, n3, i3, r4, e4, s3));
          }), a3;
        };
        const _i = function(t4, e4) {
          return Ci2(t4, 5, e4 = "function" == typeof e4 ? e4 : void 0);
        };
        const vi2 = function(t4) {
          return ft2(t4) && 1 === t4.nodeType && !Et2(t4);
        };
        class yi2 {
          constructor(t4, e4) {
            this._config = {}, e4 && this.define(xi2(e4)), t4 && this._setObjectToTarget(this._config, t4);
          }
          set(t4, e4) {
            this._setToTarget(this._config, t4, e4);
          }
          define(t4, e4) {
            this._setToTarget(this._config, t4, e4, true);
          }
          get(t4) {
            return this._getFromSource(this._config, t4);
          }
          *names() {
            for (const t4 of Object.keys(this._config))
              yield t4;
          }
          _setToTarget(t4, e4, n3, i3 = false) {
            if (Et2(e4))
              return void this._setObjectToTarget(t4, e4, i3);
            const o3 = e4.split(".");
            e4 = o3.pop();
            for (const e5 of o3)
              Et2(t4[e5]) || (t4[e5] = {}), t4 = t4[e5];
            if (Et2(n3))
              return Et2(t4[e4]) || (t4[e4] = {}), t4 = t4[e4], void this._setObjectToTarget(t4, n3, i3);
            i3 && void 0 !== t4[e4] || (t4[e4] = n3);
          }
          _getFromSource(t4, e4) {
            const n3 = e4.split(".");
            e4 = n3.pop();
            for (const e5 of n3) {
              if (!Et2(t4[e5])) {
                t4 = null;
                break;
              }
              t4 = t4[e5];
            }
            return t4 ? xi2(t4[e4]) : void 0;
          }
          _setObjectToTarget(t4, e4, n3) {
            Object.keys(e4).forEach((i3) => {
              this._setToTarget(t4, i3, e4[i3], n3);
            });
          }
        }
        function xi2(t4) {
          return _i(t4, Ei2);
        }
        function Ei2(t4) {
          return vi2(t4) || "function" == typeof t4 ? t4 : void 0;
        }
        function Di2(t4) {
          if (t4) {
            if (t4.defaultView)
              return t4 instanceof t4.defaultView.Document;
            if (t4.ownerDocument && t4.ownerDocument.defaultView)
              return t4 instanceof t4.ownerDocument.defaultView.Node;
          }
          return false;
        }
        function Si2(t4) {
          const e4 = Object.prototype.toString.apply(t4);
          return "[object Window]" == e4 || "[object global]" == e4;
        }
        const Ti2 = Ii2(B2());
        function Ii2(t4) {
          if (!t4)
            return Ti2;
          return class extends t4 {
            listenTo(t5, e4, n3, i3 = {}) {
              if (Di2(t5) || Si2(t5)) {
                const o3 = { capture: !!i3.useCapture, passive: !!i3.usePassive }, r3 = this._getProxyEmitter(t5, o3) || new Bi2(t5, o3);
                this.listenTo(r3, e4, n3, i3);
              } else
                super.listenTo(t5, e4, n3, i3);
            }
            stopListening(t5, e4, n3) {
              if (Di2(t5) || Si2(t5)) {
                const i3 = this._getAllProxyEmitters(t5);
                for (const t6 of i3)
                  this.stopListening(t6, e4, n3);
              } else
                super.stopListening(t5, e4, n3);
            }
            _getProxyEmitter(t5, e4) {
              return function(t6, e5) {
                const n3 = t6[D2];
                return n3 && n3[e5] ? n3[e5].emitter : null;
              }(this, Mi2(t5, e4));
            }
            _getAllProxyEmitters(t5) {
              return [{ capture: false, passive: false }, { capture: false, passive: true }, { capture: true, passive: false }, { capture: true, passive: true }].map((e4) => this._getProxyEmitter(t5, e4)).filter((t6) => !!t6);
            }
          };
        }
        ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t4) => {
          Ii2[t4] = Ti2.prototype[t4];
        });
        class Bi2 extends B2() {
          constructor(t4, e4) {
            super(), M2(this, Mi2(t4, e4)), this._domNode = t4, this._options = e4;
          }
          attach(t4) {
            if (this._domListeners && this._domListeners[t4])
              return;
            const e4 = this._createDomListener(t4);
            this._domNode.addEventListener(t4, e4, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[t4] = e4;
          }
          detach(t4) {
            let e4;
            !this._domListeners[t4] || (e4 = this._events[t4]) && e4.callbacks.length || this._domListeners[t4].removeListener();
          }
          _addEventListener(t4, e4, n3) {
            this.attach(t4), B2().prototype._addEventListener.call(this, t4, e4, n3);
          }
          _removeEventListener(t4, e4) {
            B2().prototype._removeEventListener.call(this, t4, e4), this.detach(t4);
          }
          _createDomListener(t4) {
            const e4 = (e5) => {
              this.fire(t4, e5);
            };
            return e4.removeListener = () => {
              this._domNode.removeEventListener(t4, e4, this._options), delete this._domListeners[t4];
            }, e4;
          }
        }
        function Mi2(t4, e4) {
          let n3 = function(t5) {
            return t5["data-ck-expando"] || (t5["data-ck-expando"] = k2());
          }(t4);
          for (const t5 of Object.keys(e4).sort())
            e4[t5] && (n3 += "-" + t5);
          return n3;
        }
        let Ni2;
        try {
          Ni2 = { window, document };
        } catch (t4) {
          Ni2 = { window: {}, document: {} };
        }
        const Li2 = Ni2;
        function zi2(t4) {
          return "[object Text]" == Object.prototype.toString.call(t4);
        }
        function Pi2(t4) {
          return "[object Range]" == Object.prototype.toString.apply(t4);
        }
        function Ri2(t4) {
          const e4 = t4.ownerDocument.defaultView.getComputedStyle(t4);
          return { top: parseInt(e4.borderTopWidth, 10), right: parseInt(e4.borderRightWidth, 10), bottom: parseInt(e4.borderBottomWidth, 10), left: parseInt(e4.borderLeftWidth, 10) };
        }
        function Oi2(t4) {
          return t4 && t4.parentNode ? t4.offsetParent === Li2.document.body ? null : t4.offsetParent : null;
        }
        const Fi2 = ["top", "right", "bottom", "left", "width", "height"];
        class Vi2 {
          constructor(t4) {
            const e4 = Pi2(t4);
            if (Object.defineProperty(this, "_source", { value: t4._source || t4, writable: true, enumerable: false }), Ui2(t4) || e4)
              if (e4) {
                const e5 = Vi2.getDomRangeRects(t4);
                ji2(this, Vi2.getBoundingRect(e5));
              } else
                ji2(this, t4.getBoundingClientRect());
            else if (Si2(t4)) {
              const { innerWidth: e5, innerHeight: n3 } = t4;
              ji2(this, { top: 0, right: e5, bottom: n3, left: 0, width: e5, height: n3 });
            } else
              ji2(this, t4);
          }
          clone() {
            return new Vi2(this);
          }
          moveTo(t4, e4) {
            return this.top = e4, this.right = t4 + this.width, this.bottom = e4 + this.height, this.left = t4, this;
          }
          moveBy(t4, e4) {
            return this.top += e4, this.right += t4, this.left += t4, this.bottom += e4, this;
          }
          getIntersection(t4) {
            const e4 = { top: Math.max(this.top, t4.top), right: Math.min(this.right, t4.right), bottom: Math.min(this.bottom, t4.bottom), left: Math.max(this.left, t4.left), width: 0, height: 0 };
            if (e4.width = e4.right - e4.left, e4.height = e4.bottom - e4.top, e4.width < 0 || e4.height < 0)
              return null;
            {
              const t5 = new Vi2(e4);
              return t5._source = this._source, t5;
            }
          }
          getIntersectionArea(t4) {
            const e4 = this.getIntersection(t4);
            return e4 ? e4.getArea() : 0;
          }
          getArea() {
            return this.width * this.height;
          }
          getVisible() {
            const t4 = this._source;
            let e4 = this.clone();
            if (Hi2(t4))
              return e4;
            let n3, i3 = t4, o3 = t4.parentNode || t4.commonAncestorContainer;
            for (; o3 && !Hi2(o3); ) {
              const t5 = "visible" === ((r3 = o3) instanceof HTMLElement ? r3.ownerDocument.defaultView.getComputedStyle(r3).overflow : "visible");
              i3 instanceof HTMLElement && "absolute" === Gi2(i3) && (n3 = i3);
              const s3 = Gi2(o3);
              if (t5 || n3 && ("relative" === s3 && t5 || "relative" !== s3)) {
                i3 = o3, o3 = o3.parentNode;
                continue;
              }
              const a3 = new Vi2(o3), c3 = e4.getIntersection(a3);
              if (!c3)
                return null;
              c3.getArea() < e4.getArea() && (e4 = c3), i3 = o3, o3 = o3.parentNode;
            }
            var r3;
            return e4;
          }
          isEqual(t4) {
            for (const e4 of Fi2)
              if (this[e4] !== t4[e4])
                return false;
            return true;
          }
          contains(t4) {
            const e4 = this.getIntersection(t4);
            return !(!e4 || !e4.isEqual(t4));
          }
          toAbsoluteRect() {
            const { scrollX: t4, scrollY: e4 } = Li2.window, n3 = this.clone().moveBy(t4, e4);
            if (Ui2(n3._source)) {
              const t5 = Oi2(n3._source);
              t5 && function(t6, e5) {
                const n4 = new Vi2(e5), i3 = Ri2(e5);
                let o3 = 0, r3 = 0;
                o3 -= n4.left, r3 -= n4.top, o3 += e5.scrollLeft, r3 += e5.scrollTop, o3 -= i3.left, r3 -= i3.top, t6.moveBy(o3, r3);
              }(n3, t5);
            }
            return n3;
          }
          excludeScrollbarsAndBorders() {
            const t4 = this._source;
            let e4, n3, i3;
            if (Si2(t4))
              e4 = t4.innerWidth - t4.document.documentElement.clientWidth, n3 = t4.innerHeight - t4.document.documentElement.clientHeight, i3 = t4.getComputedStyle(t4.document.documentElement).direction;
            else {
              const o3 = Ri2(t4);
              e4 = t4.offsetWidth - t4.clientWidth - o3.left - o3.right, n3 = t4.offsetHeight - t4.clientHeight - o3.top - o3.bottom, i3 = t4.ownerDocument.defaultView.getComputedStyle(t4).direction, this.left += o3.left, this.top += o3.top, this.right -= o3.right, this.bottom -= o3.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
            }
            return this.width -= e4, "ltr" === i3 ? this.right -= e4 : this.left += e4, this.height -= n3, this.bottom -= n3, this;
          }
          static getDomRangeRects(t4) {
            const e4 = [], n3 = Array.from(t4.getClientRects());
            if (n3.length)
              for (const t5 of n3)
                e4.push(new Vi2(t5));
            else {
              let n4 = t4.startContainer;
              zi2(n4) && (n4 = n4.parentNode);
              const i3 = new Vi2(n4.getBoundingClientRect());
              i3.right = i3.left, i3.width = 0, e4.push(i3);
            }
            return e4;
          }
          static getBoundingRect(t4) {
            const e4 = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY, width: 0, height: 0 };
            let n3 = 0;
            for (const i3 of t4)
              n3++, e4.left = Math.min(e4.left, i3.left), e4.top = Math.min(e4.top, i3.top), e4.right = Math.max(e4.right, i3.right), e4.bottom = Math.max(e4.bottom, i3.bottom);
            return 0 == n3 ? null : (e4.width = e4.right - e4.left, e4.height = e4.bottom - e4.top, new Vi2(e4));
          }
        }
        function ji2(t4, e4) {
          for (const n3 of Fi2)
            t4[n3] = e4[n3];
        }
        function Hi2(t4) {
          return !!Ui2(t4) && t4 === t4.ownerDocument.body;
        }
        function Ui2(t4) {
          return null !== t4 && "object" == typeof t4 && 1 === t4.nodeType && "function" == typeof t4.getBoundingClientRect;
        }
        function Gi2(t4) {
          return t4 instanceof HTMLElement ? t4.ownerDocument.defaultView.getComputedStyle(t4).position : "static";
        }
        class Wi2 {
          constructor(t4, e4) {
            Wi2._observerInstance || Wi2._createObserver(), this._element = t4, this._callback = e4, Wi2._addElementCallback(t4, e4), Wi2._observerInstance.observe(t4);
          }
          get element() {
            return this._element;
          }
          destroy() {
            Wi2._deleteElementCallback(this._element, this._callback);
          }
          static _addElementCallback(t4, e4) {
            Wi2._elementCallbacks || (Wi2._elementCallbacks = /* @__PURE__ */ new Map());
            let n3 = Wi2._elementCallbacks.get(t4);
            n3 || (n3 = /* @__PURE__ */ new Set(), Wi2._elementCallbacks.set(t4, n3)), n3.add(e4);
          }
          static _deleteElementCallback(t4, e4) {
            const n3 = Wi2._getElementCallbacks(t4);
            n3 && (n3.delete(e4), n3.size || (Wi2._elementCallbacks.delete(t4), Wi2._observerInstance.unobserve(t4))), Wi2._elementCallbacks && !Wi2._elementCallbacks.size && (Wi2._observerInstance = null, Wi2._elementCallbacks = null);
          }
          static _getElementCallbacks(t4) {
            return Wi2._elementCallbacks ? Wi2._elementCallbacks.get(t4) : null;
          }
          static _createObserver() {
            Wi2._observerInstance = new Li2.window.ResizeObserver((t4) => {
              for (const e4 of t4) {
                const t5 = Wi2._getElementCallbacks(e4.target);
                if (t5)
                  for (const n3 of t5)
                    n3(e4);
              }
            });
          }
        }
        function qi2(t4, e4) {
          t4 instanceof HTMLTextAreaElement && (t4.value = e4), t4.innerHTML = e4;
        }
        function $i2(t4) {
          return (e4) => e4 + t4;
        }
        function Ki2(t4) {
          let e4 = 0;
          for (; t4.previousSibling; )
            t4 = t4.previousSibling, e4++;
          return e4;
        }
        function Zi2(t4, e4, n3) {
          t4.insertBefore(n3, t4.childNodes[e4] || null);
        }
        function Yi2(t4) {
          return t4 && t4.nodeType === Node.COMMENT_NODE;
        }
        function Qi2(t4) {
          try {
            Li2.document.createAttribute(t4);
          } catch (t5) {
            return false;
          }
          return true;
        }
        function Ji2(t4) {
          return !!(t4 && t4.getClientRects && t4.getClientRects().length);
        }
        function Xi2({ element: t4, target: e4, positions: n3, limiter: i3, fitInViewport: o3, viewportOffsetConfig: r3 }) {
          jt2(e4) && (e4 = e4()), jt2(i3) && (i3 = i3());
          const s3 = Oi2(t4), a3 = function(t5) {
            t5 = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t5);
            const e5 = new Vi2(Li2.window);
            return e5.top += t5.top, e5.height -= t5.top, e5.bottom -= t5.bottom, e5.height -= t5.bottom, e5;
          }(r3), c3 = new Vi2(t4), l3 = to2(e4, a3);
          let d3;
          if (!l3 || !a3.getIntersection(l3))
            return null;
          const h3 = { targetRect: l3, elementRect: c3, positionedElementAncestor: s3, viewportRect: a3 };
          if (i3 || o3) {
            if (i3) {
              const t5 = to2(i3, a3);
              t5 && (h3.limiterRect = t5);
            }
            d3 = function(t5, e5) {
              const { elementRect: n4 } = e5, i4 = n4.getArea(), o4 = t5.map((t6) => new eo2(t6, e5)).filter((t6) => !!t6.name);
              let r4 = 0, s4 = null;
              for (const t6 of o4) {
                const { limiterIntersectionArea: e6, viewportIntersectionArea: n5 } = t6;
                if (e6 === i4)
                  return t6;
                const o5 = n5 ** 2 + e6 ** 2;
                o5 > r4 && (r4 = o5, s4 = t6);
              }
              return s4;
            }(n3, h3);
          } else
            d3 = new eo2(n3[0], h3);
          return d3;
        }
        function to2(t4, e4) {
          const n3 = new Vi2(t4).getVisible();
          return n3 ? n3.getIntersection(e4) : null;
        }
        Wi2._observerInstance = null, Wi2._elementCallbacks = null;
        class eo2 {
          constructor(t4, e4) {
            const n3 = t4(e4.targetRect, e4.elementRect, e4.viewportRect, e4.limiterRect);
            if (!n3)
              return;
            const { left: i3, top: o3, name: r3, config: s3 } = n3;
            this.name = r3, this.config = s3, this._positioningFunctionCoordinates = { left: i3, top: o3 }, this._options = e4;
          }
          get left() {
            return this._absoluteRect.left;
          }
          get top() {
            return this._absoluteRect.top;
          }
          get limiterIntersectionArea() {
            const t4 = this._options.limiterRect;
            return t4 ? t4.getIntersectionArea(this._rect) : 0;
          }
          get viewportIntersectionArea() {
            return this._options.viewportRect.getIntersectionArea(this._rect);
          }
          get _rect() {
            return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top)), this._cachedRect;
          }
          get _absoluteRect() {
            return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = this._rect.toAbsoluteRect()), this._cachedAbsoluteRect;
          }
        }
        function no2(t4) {
          const e4 = t4.parentNode;
          e4 && e4.removeChild(t4);
        }
        function io2({ target: t4, viewportOffset: e4 = 0, ancestorOffset: n3 = 0, alignToTop: i3, forceScroll: o3 }) {
          const r3 = ho2(t4);
          let s3 = r3, a3 = null;
          for (e4 = function(t5) {
            if ("number" == typeof t5)
              return { top: t5, bottom: t5, left: t5, right: t5 };
            return t5;
          }(e4); s3; ) {
            let c3;
            c3 = uo2(s3 == r3 ? t4 : a3), ro2({ parent: c3, getRect: () => go2(t4, s3), alignToTop: i3, ancestorOffset: n3, forceScroll: o3 });
            const l3 = go2(t4, s3);
            if (oo2({ window: s3, rect: l3, viewportOffset: e4, alignToTop: i3, forceScroll: o3 }), s3.parent != s3) {
              if (a3 = s3.frameElement, s3 = s3.parent, !a3)
                return;
            } else
              s3 = null;
          }
        }
        function oo2({ window: t4, rect: e4, alignToTop: n3, forceScroll: i3, viewportOffset: o3 }) {
          const r3 = e4.clone().moveBy(0, o3.bottom), s3 = e4.clone().moveBy(0, -o3.top), a3 = new Vi2(t4).excludeScrollbarsAndBorders(), c3 = n3 && i3, l3 = [s3, r3].every((t5) => a3.contains(t5));
          let { scrollX: d3, scrollY: h3 } = t4;
          const u3 = d3, g3 = h3;
          c3 ? h3 -= a3.top - e4.top + o3.top : l3 || (ao2(s3, a3) ? h3 -= a3.top - e4.top + o3.top : so2(r3, a3) && (h3 += n3 ? e4.top - a3.top - o3.top : e4.bottom - a3.bottom + o3.bottom)), l3 || (co2(e4, a3) ? d3 -= a3.left - e4.left + o3.left : lo2(e4, a3) && (d3 += e4.right - a3.right + o3.right)), d3 == u3 && h3 === g3 || t4.scrollTo(d3, h3);
        }
        function ro2({ parent: t4, getRect: e4, alignToTop: n3, forceScroll: i3, ancestorOffset: o3 = 0, limiterElement: r3 }) {
          const s3 = ho2(t4), a3 = n3 && i3;
          let c3, l3, d3;
          const h3 = r3 || s3.document.body;
          for (; t4 != h3; )
            l3 = e4(), c3 = new Vi2(t4).excludeScrollbarsAndBorders(), d3 = c3.contains(l3), a3 ? t4.scrollTop -= c3.top - l3.top + o3 : d3 || (ao2(l3, c3) ? t4.scrollTop -= c3.top - l3.top + o3 : so2(l3, c3) && (t4.scrollTop += n3 ? l3.top - c3.top - o3 : l3.bottom - c3.bottom + o3)), d3 || (co2(l3, c3) ? t4.scrollLeft -= c3.left - l3.left + o3 : lo2(l3, c3) && (t4.scrollLeft += l3.right - c3.right + o3)), t4 = t4.parentNode;
        }
        function so2(t4, e4) {
          return t4.bottom > e4.bottom;
        }
        function ao2(t4, e4) {
          return t4.top < e4.top;
        }
        function co2(t4, e4) {
          return t4.left < e4.left;
        }
        function lo2(t4, e4) {
          return t4.right > e4.right;
        }
        function ho2(t4) {
          return Pi2(t4) ? t4.startContainer.ownerDocument.defaultView : t4.ownerDocument.defaultView;
        }
        function uo2(t4) {
          if (Pi2(t4)) {
            let e4 = t4.commonAncestorContainer;
            return zi2(e4) && (e4 = e4.parentNode), e4;
          }
          return t4.parentNode;
        }
        function go2(t4, e4) {
          const n3 = ho2(t4), i3 = new Vi2(t4);
          if (n3 === e4)
            return i3;
          {
            let t5 = n3;
            for (; t5 != e4; ) {
              const e5 = t5.frameElement, n4 = new Vi2(e5).excludeScrollbarsAndBorders();
              i3.moveBy(n4.left, n4.top), t5 = t5.parent;
            }
          }
          return i3;
        }
        const mo2 = { ctrl: "", cmd: "", alt: "", shift: "" }, po2 = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }, fo2 = function() {
          const t4 = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 };
          for (let e4 = 65; e4 <= 90; e4++) {
            t4[String.fromCharCode(e4).toLowerCase()] = e4;
          }
          for (let e4 = 48; e4 <= 57; e4++)
            t4[e4 - 48] = e4;
          for (let e4 = 112; e4 <= 123; e4++)
            t4["f" + (e4 - 111)] = e4;
          for (const e4 of "`-=[];',./\\")
            t4[e4] = e4.charCodeAt(0);
          return t4;
        }(), ko2 = Object.fromEntries(Object.entries(fo2).map(([t4, e4]) => [e4, t4.charAt(0).toUpperCase() + t4.slice(1)]));
        function bo2(t4) {
          let e4;
          if ("string" == typeof t4) {
            if (e4 = fo2[t4.toLowerCase()], !e4)
              throw new C2("keyboard-unknown-key", null, { key: t4 });
          } else
            e4 = t4.keyCode + (t4.altKey ? fo2.alt : 0) + (t4.ctrlKey ? fo2.ctrl : 0) + (t4.shiftKey ? fo2.shift : 0) + (t4.metaKey ? fo2.cmd : 0);
          return e4;
        }
        function wo2(t4) {
          return "string" == typeof t4 && (t4 = function(t5) {
            return t5.split("+").map((t6) => t6.trim());
          }(t4)), t4.map((t5) => "string" == typeof t5 ? function(t6) {
            if (t6.endsWith("!"))
              return bo2(t6.slice(0, -1));
            const e4 = bo2(t6);
            return (c2.isMac || c2.isiOS) && e4 == fo2.ctrl ? fo2.cmd : e4;
          }(t5) : t5).reduce((t5, e4) => e4 + t5, 0);
        }
        function Ao2(t4) {
          let e4 = wo2(t4);
          return Object.entries(c2.isMac || c2.isiOS ? mo2 : po2).reduce((t5, [n3, i3]) => (0 != (e4 & fo2[n3]) && (e4 &= ~fo2[n3], t5 += i3), t5), "") + (e4 ? ko2[e4] : "");
        }
        function Co2(t4, e4) {
          const n3 = "ltr" === e4;
          switch (t4) {
            case fo2.arrowleft:
              return n3 ? "left" : "right";
            case fo2.arrowright:
              return n3 ? "right" : "left";
            case fo2.arrowup:
              return "up";
            case fo2.arrowdown:
              return "down";
          }
        }
        const _o2 = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
        function vo2(t4) {
          return _o2.includes(t4) ? "rtl" : "ltr";
        }
        function yo2(t4) {
          return Array.isArray(t4) ? t4 : [t4];
        }
        function xo2(t4, e4, n3 = 1) {
          if ("number" != typeof n3)
            throw new C2("translation-service-quantity-not-a-number", null, { quantity: n3 });
          const i3 = Object.keys(Li2.window.CKEDITOR_TRANSLATIONS).length;
          1 === i3 && (t4 = Object.keys(Li2.window.CKEDITOR_TRANSLATIONS)[0]);
          const o3 = e4.id || e4.string;
          if (0 === i3 || !function(t5, e5) {
            return !!Li2.window.CKEDITOR_TRANSLATIONS[t5] && !!Li2.window.CKEDITOR_TRANSLATIONS[t5].dictionary[e5];
          }(t4, o3))
            return 1 !== n3 ? e4.plural : e4.string;
          const r3 = Li2.window.CKEDITOR_TRANSLATIONS[t4].dictionary, s3 = Li2.window.CKEDITOR_TRANSLATIONS[t4].getPluralForm || ((t5) => 1 === t5 ? 0 : 1), a3 = r3[o3];
          if ("string" == typeof a3)
            return a3;
          return a3[Number(s3(n3))];
        }
        Li2.window.CKEDITOR_TRANSLATIONS || (Li2.window.CKEDITOR_TRANSLATIONS = {});
        class Eo2 {
          constructor({ uiLanguage: t4 = "en", contentLanguage: e4 } = {}) {
            this.uiLanguage = t4, this.contentLanguage = e4 || this.uiLanguage, this.uiLanguageDirection = vo2(this.uiLanguage), this.contentLanguageDirection = vo2(this.contentLanguage), this.t = (t5, e5) => this._t(t5, e5);
          }
          get language() {
            return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
          }
          _t(t4, e4 = []) {
            e4 = yo2(e4), "string" == typeof t4 && (t4 = { string: t4 });
            const n3 = !!t4.plural ? e4[0] : 1;
            return function(t5, e5) {
              return t5.replace(/%(\d+)/g, (t6, n4) => n4 < e5.length ? e5[n4] : t6);
            }(xo2(this.uiLanguage, t4, n3), e4);
          }
        }
        class Do2 extends B2() {
          constructor(t4 = {}, e4 = {}) {
            super();
            const n3 = et2(t4);
            if (n3 || (e4 = t4), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = e4.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n3)
              for (const e5 of t4)
                this._items.push(e5), this._itemMap.set(this._getItemIdBeforeAdding(e5), e5);
          }
          get length() {
            return this._items.length;
          }
          get first() {
            return this._items[0] || null;
          }
          get last() {
            return this._items[this.length - 1] || null;
          }
          add(t4, e4) {
            return this.addMany([t4], e4);
          }
          addMany(t4, e4) {
            if (void 0 === e4)
              e4 = this._items.length;
            else if (e4 > this._items.length || e4 < 0)
              throw new C2("collection-add-item-invalid-index", this);
            let n3 = 0;
            for (const i3 of t4) {
              const t5 = this._getItemIdBeforeAdding(i3), o3 = e4 + n3;
              this._items.splice(o3, 0, i3), this._itemMap.set(t5, i3), this.fire("add", i3, o3), n3++;
            }
            return this.fire("change", { added: t4, removed: [], index: e4 }), this;
          }
          get(t4) {
            let e4;
            if ("string" == typeof t4)
              e4 = this._itemMap.get(t4);
            else {
              if ("number" != typeof t4)
                throw new C2("collection-get-invalid-arg", this);
              e4 = this._items[t4];
            }
            return e4 || null;
          }
          has(t4) {
            if ("string" == typeof t4)
              return this._itemMap.has(t4);
            {
              const e4 = t4[this._idProperty];
              return e4 && this._itemMap.has(e4);
            }
          }
          getIndex(t4) {
            let e4;
            return e4 = "string" == typeof t4 ? this._itemMap.get(t4) : t4, e4 ? this._items.indexOf(e4) : -1;
          }
          remove(t4) {
            const [e4, n3] = this._remove(t4);
            return this.fire("change", { added: [], removed: [e4], index: n3 }), e4;
          }
          map(t4, e4) {
            return this._items.map(t4, e4);
          }
          forEach(t4, e4) {
            this._items.forEach(t4, e4);
          }
          find(t4, e4) {
            return this._items.find(t4, e4);
          }
          filter(t4, e4) {
            return this._items.filter(t4, e4);
          }
          clear() {
            this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
            const t4 = Array.from(this._items);
            for (; this.length; )
              this._remove(0);
            this.fire("change", { added: [], removed: t4, index: 0 });
          }
          bindTo(t4) {
            if (this._bindToCollection)
              throw new C2("collection-bind-to-rebind", this);
            return this._bindToCollection = t4, { as: (t5) => {
              this._setUpBindToBinding((e4) => new t5(e4));
            }, using: (t5) => {
              "function" == typeof t5 ? this._setUpBindToBinding(t5) : this._setUpBindToBinding((e4) => e4[t5]);
            } };
          }
          _setUpBindToBinding(t4) {
            const e4 = this._bindToCollection, n3 = (n4, i3, o3) => {
              const r3 = e4._bindToCollection == this, s3 = e4._bindToInternalToExternalMap.get(i3);
              if (r3 && s3)
                this._bindToExternalToInternalMap.set(i3, s3), this._bindToInternalToExternalMap.set(s3, i3);
              else {
                const n5 = t4(i3);
                if (!n5)
                  return void this._skippedIndexesFromExternal.push(o3);
                let r4 = o3;
                for (const t5 of this._skippedIndexesFromExternal)
                  o3 > t5 && r4--;
                for (const t5 of e4._skippedIndexesFromExternal)
                  r4 >= t5 && r4++;
                this._bindToExternalToInternalMap.set(i3, n5), this._bindToInternalToExternalMap.set(n5, i3), this.add(n5, r4);
                for (let t5 = 0; t5 < e4._skippedIndexesFromExternal.length; t5++)
                  r4 <= e4._skippedIndexesFromExternal[t5] && e4._skippedIndexesFromExternal[t5]++;
              }
            };
            for (const t5 of e4)
              n3(0, t5, e4.getIndex(t5));
            this.listenTo(e4, "add", n3), this.listenTo(e4, "remove", (t5, e5, n4) => {
              const i3 = this._bindToExternalToInternalMap.get(e5);
              i3 && this.remove(i3), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t6, e6) => (n4 < e6 && t6.push(e6 - 1), n4 > e6 && t6.push(e6), t6), []);
            });
          }
          _getItemIdBeforeAdding(t4) {
            const e4 = this._idProperty;
            let n3;
            if (e4 in t4) {
              if (n3 = t4[e4], "string" != typeof n3)
                throw new C2("collection-add-invalid-id", this);
              if (this.get(n3))
                throw new C2("collection-add-item-already-exists", this);
            } else
              t4[e4] = n3 = k2();
            return n3;
          }
          _remove(t4) {
            let e4, n3, i3, o3 = false;
            const r3 = this._idProperty;
            if ("string" == typeof t4 ? (n3 = t4, i3 = this._itemMap.get(n3), o3 = !i3, i3 && (e4 = this._items.indexOf(i3))) : "number" == typeof t4 ? (e4 = t4, i3 = this._items[e4], o3 = !i3, i3 && (n3 = i3[r3])) : (i3 = t4, n3 = i3[r3], e4 = this._items.indexOf(i3), o3 = -1 == e4 || !this._itemMap.get(n3)), o3)
              throw new C2("collection-remove-404", this);
            this._items.splice(e4, 1), this._itemMap.delete(n3);
            const s3 = this._bindToInternalToExternalMap.get(i3);
            return this._bindToInternalToExternalMap.delete(i3), this._bindToExternalToInternalMap.delete(s3), this.fire("remove", i3, e4), [i3, e4];
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
        }
        function So2(t4) {
          const e4 = t4.next();
          return e4.done ? null : e4.value;
        }
        class To2 extends Ii2(q2()) {
          constructor() {
            super(), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null, this.set("isFocused", false), this.set("focusedElement", null);
          }
          add(t4) {
            if (this._elements.has(t4))
              throw new C2("focustracker-add-element-already-exist", this);
            this.listenTo(t4, "focus", () => this._focus(t4), { useCapture: true }), this.listenTo(t4, "blur", () => this._blur(), { useCapture: true }), this._elements.add(t4);
          }
          remove(t4) {
            t4 === this.focusedElement && this._blur(), this._elements.has(t4) && (this.stopListening(t4), this._elements.delete(t4));
          }
          destroy() {
            this.stopListening();
          }
          _focus(t4) {
            clearTimeout(this._nextEventLoopTimeout), this.focusedElement = t4, this.isFocused = true;
          }
          _blur() {
            clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
              this.focusedElement = null, this.isFocused = false;
            }, 0);
          }
        }
        class Io2 {
          constructor() {
            this._listener = new (Ii2())();
          }
          listenTo(t4) {
            this._listener.listenTo(t4, "keydown", (t5, e4) => {
              this._listener.fire("_keydown:" + bo2(e4), e4);
            });
          }
          set(t4, e4, n3 = {}) {
            const i3 = wo2(t4), o3 = n3.priority;
            this._listener.listenTo(this._listener, "_keydown:" + i3, (t5, n4) => {
              e4(n4, () => {
                n4.preventDefault(), n4.stopPropagation(), t5.stop();
              }), t5.return = true;
            }, { priority: o3 });
          }
          press(t4) {
            return !!this._listener.fire("_keydown:" + bo2(t4), t4);
          }
          stopListening(t4) {
            this._listener.stopListening(t4);
          }
          destroy() {
            this.stopListening();
          }
        }
        function Bo2(t4) {
          return et2(t4) ? new Map(t4) : function(t5) {
            const e4 = /* @__PURE__ */ new Map();
            for (const n3 in t5)
              e4.set(n3, t5[n3]);
            return e4;
          }(t4);
        }
        function Mo2(t4, e4) {
          let n3;
          function i3(...o3) {
            i3.cancel(), n3 = setTimeout(() => t4(...o3), e4);
          }
          return i3.cancel = () => {
            clearTimeout(n3);
          }, i3;
        }
        function No2(t4, e4) {
          return !!(n3 = t4.charAt(e4 - 1)) && 1 == n3.length && /[\ud800-\udbff]/.test(n3) && function(t5) {
            return !!t5 && 1 == t5.length && /[\udc00-\udfff]/.test(t5);
          }(t4.charAt(e4));
          var n3;
        }
        function Lo2(t4, e4) {
          return !!(n3 = t4.charAt(e4)) && 1 == n3.length && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n3);
          var n3;
        }
        const zo2 = function() {
          const t4 = /\p{Regional_Indicator}{2}/u.source, e4 = "(?:" + [/\p{Emoji}[\u{E0020}-\u{E007E}]+\u{E007F}/u, /\p{Emoji}\u{FE0F}?\u{20E3}/u, /\p{Emoji}\u{FE0F}/u, /(?=\p{General_Category=Other_Symbol})\p{Emoji}\p{Emoji_Modifier}*/u].map((t5) => t5.source).join("|") + ")";
          return new RegExp(`${t4}|${e4}(?:${e4})*`, "ug");
        }();
        function Po2(t4, e4) {
          const n3 = String(t4).matchAll(zo2);
          return Array.from(n3).some((t5) => t5.index < e4 && e4 < t5.index + t5[0].length);
        }
        class Ro2 extends Do2 {
          constructor(t4 = []) {
            super(t4, { idProperty: "viewUid" }), this.on("add", (t5, e4, n3) => {
              this._renderViewIntoCollectionParent(e4, n3);
            }), this.on("remove", (t5, e4) => {
              e4.element && this._parentElement && e4.element.remove();
            }), this._parentElement = null;
          }
          destroy() {
            this.map((t4) => t4.destroy());
          }
          setParent(t4) {
            this._parentElement = t4;
            for (const t5 of this)
              this._renderViewIntoCollectionParent(t5);
          }
          delegate(...t4) {
            if (!t4.length || !t4.every((t5) => "string" == typeof t5))
              throw new C2("ui-viewcollection-delegate-wrong-events", this);
            return { to: (e4) => {
              for (const n3 of this)
                for (const i3 of t4)
                  n3.delegate(i3).to(e4);
              this.on("add", (n3, i3) => {
                for (const n4 of t4)
                  i3.delegate(n4).to(e4);
              }), this.on("remove", (n3, i3) => {
                for (const n4 of t4)
                  i3.stopDelegating(n4, e4);
              });
            } };
          }
          _renderViewIntoCollectionParent(t4, e4) {
            t4.isRendered || t4.render(), t4.element && this._parentElement && this._parentElement.insertBefore(t4.element, this._parentElement.children[e4]);
          }
          remove(t4) {
            return super.remove(t4);
          }
        }
        var Oo2 = n2(3379), Fo2 = n2.n(Oo2), Vo2 = n2(5167), jo2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Vo2.Z, jo2);
        Vo2.Z.locals;
        class Ho2 extends Ii2(q2()) {
          constructor(t4) {
            super(), this.element = null, this.isRendered = false, this.locale = t4, this.t = t4 && t4.t, this._viewCollections = new Do2(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (e4, n3) => {
              n3.locale = t4, n3.t = t4 && t4.t;
            }), this.decorate("render");
          }
          get bindTemplate() {
            return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Uo2.bind(this, this);
          }
          createCollection(t4) {
            const e4 = new Ro2(t4);
            return this._viewCollections.add(e4), e4;
          }
          registerChild(t4) {
            et2(t4) || (t4 = [t4]);
            for (const e4 of t4)
              this._unboundChildren.add(e4);
          }
          deregisterChild(t4) {
            et2(t4) || (t4 = [t4]);
            for (const e4 of t4)
              this._unboundChildren.remove(e4);
          }
          setTemplate(t4) {
            this.template = new Uo2(t4);
          }
          extendTemplate(t4) {
            Uo2.extend(this.template, t4);
          }
          render() {
            if (this.isRendered)
              throw new C2("ui-view-render-already-rendered", this);
            this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = true;
          }
          destroy() {
            this.stopListening(), this._viewCollections.map((t4) => t4.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
          }
        }
        class Uo2 extends B2() {
          constructor(t4) {
            super(), Object.assign(this, Xo2(Jo2(t4))), this._isRendered = false, this._revertData = null;
          }
          render() {
            const t4 = this._renderNode({ intoFragment: true });
            return this._isRendered = true, t4;
          }
          apply(t4) {
            return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: t4, intoFragment: false, isApplying: true, revertData: this._revertData }), t4;
          }
          revert(t4) {
            if (!this._revertData)
              throw new C2("ui-template-revert-not-applied", [this, t4]);
            this._revertTemplateFromNode(t4, this._revertData);
          }
          *getViews() {
            yield* function* t4(e4) {
              if (e4.children)
                for (const n3 of e4.children)
                  rr(n3) ? yield n3 : sr(n3) && (yield* t4(n3));
            }(this);
          }
          static bind(t4, e4) {
            return { to: (n3, i3) => new Wo2({ eventNameOrFunction: n3, attribute: n3, observable: t4, emitter: e4, callback: i3 }), if: (n3, i3, o3) => new qo2({ observable: t4, emitter: e4, attribute: n3, valueIfTrue: i3, callback: o3 }) };
          }
          static extend(t4, e4) {
            if (t4._isRendered)
              throw new C2("template-extend-render", [this, t4]);
            ir(t4, Xo2(Jo2(e4)));
          }
          _renderNode(t4) {
            let e4;
            if (e4 = t4.node ? this.tag && this.text : this.tag ? this.text : !this.text, e4)
              throw new C2("ui-template-wrong-syntax", this);
            return this.text ? this._renderText(t4) : this._renderElement(t4);
          }
          _renderElement(t4) {
            let e4 = t4.node;
            return e4 || (e4 = t4.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(t4), this._renderElementChildren(t4), this._setUpListeners(t4), e4;
          }
          _renderText(t4) {
            let e4 = t4.node;
            return e4 ? t4.revertData.text = e4.textContent : e4 = t4.node = document.createTextNode(""), $o2(this.text) ? this._bindToObservable({ schema: this.text, updater: Zo2(e4), data: t4 }) : e4.textContent = this.text.join(""), e4;
          }
          _renderAttributes(t4) {
            if (!this.attributes)
              return;
            const e4 = t4.node, n3 = t4.revertData;
            for (const i3 in this.attributes) {
              const o3 = e4.getAttribute(i3), r3 = this.attributes[i3];
              n3 && (n3.attributes[i3] = o3);
              const s3 = cr(r3) ? r3[0].ns : null;
              if ($o2(r3)) {
                const a3 = cr(r3) ? r3[0].value : r3;
                n3 && lr(i3) && a3.unshift(o3), this._bindToObservable({ schema: a3, updater: Yo2(e4, i3, s3), data: t4 });
              } else if ("style" == i3 && "string" != typeof r3[0])
                this._renderStyleAttribute(r3[0], t4);
              else {
                n3 && o3 && lr(i3) && r3.unshift(o3);
                const t5 = r3.map((t6) => t6 && t6.value || t6).reduce((t6, e5) => t6.concat(e5), []).reduce(er, "");
                or(t5) || e4.setAttributeNS(s3, i3, t5);
              }
            }
          }
          _renderStyleAttribute(t4, e4) {
            const n3 = e4.node;
            for (const i3 in t4) {
              const o3 = t4[i3];
              $o2(o3) ? this._bindToObservable({ schema: [o3], updater: Qo2(n3, i3), data: e4 }) : n3.style[i3] = o3;
            }
          }
          _renderElementChildren(t4) {
            const e4 = t4.node, n3 = t4.intoFragment ? document.createDocumentFragment() : e4, i3 = t4.isApplying;
            let o3 = 0;
            for (const r3 of this.children)
              if (ar(r3)) {
                if (!i3) {
                  r3.setParent(e4);
                  for (const t5 of r3)
                    n3.appendChild(t5.element);
                }
              } else if (rr(r3))
                i3 || (r3.isRendered || r3.render(), n3.appendChild(r3.element));
              else if (Di2(r3))
                n3.appendChild(r3);
              else if (i3) {
                const e5 = { children: [], bindings: [], attributes: {} };
                t4.revertData.children.push(e5), r3._renderNode({ intoFragment: false, node: n3.childNodes[o3++], isApplying: true, revertData: e5 });
              } else
                n3.appendChild(r3.render());
            t4.intoFragment && e4.appendChild(n3);
          }
          _setUpListeners(t4) {
            if (this.eventListeners)
              for (const e4 in this.eventListeners) {
                const n3 = this.eventListeners[e4].map((n4) => {
                  const [i3, o3] = e4.split("@");
                  return n4.activateDomEventListener(i3, o3, t4);
                });
                t4.revertData && t4.revertData.bindings.push(n3);
              }
          }
          _bindToObservable({ schema: t4, updater: e4, data: n3 }) {
            const i3 = n3.revertData;
            Ko2(t4, e4, n3);
            const o3 = t4.filter((t5) => !or(t5)).filter((t5) => t5.observable).map((i4) => i4.activateAttributeListener(t4, e4, n3));
            i3 && i3.bindings.push(o3);
          }
          _revertTemplateFromNode(t4, e4) {
            for (const t5 of e4.bindings)
              for (const e5 of t5)
                e5();
            if (e4.text)
              return void (t4.textContent = e4.text);
            const n3 = t4;
            for (const t5 in e4.attributes) {
              const i3 = e4.attributes[t5];
              null === i3 ? n3.removeAttribute(t5) : n3.setAttribute(t5, i3);
            }
            for (let t5 = 0; t5 < e4.children.length; ++t5)
              this._revertTemplateFromNode(n3.childNodes[t5], e4.children[t5]);
          }
        }
        class Go2 {
          constructor(t4) {
            this.attribute = t4.attribute, this.observable = t4.observable, this.emitter = t4.emitter, this.callback = t4.callback;
          }
          getValue(t4) {
            const e4 = this.observable[this.attribute];
            return this.callback ? this.callback(e4, t4) : e4;
          }
          activateAttributeListener(t4, e4, n3) {
            const i3 = () => Ko2(t4, e4, n3);
            return this.emitter.listenTo(this.observable, `change:${this.attribute}`, i3), () => {
              this.emitter.stopListening(this.observable, `change:${this.attribute}`, i3);
            };
          }
        }
        class Wo2 extends Go2 {
          constructor(t4) {
            super(t4), this.eventNameOrFunction = t4.eventNameOrFunction;
          }
          activateDomEventListener(t4, e4, n3) {
            const i3 = (t5, n4) => {
              e4 && !n4.target.matches(e4) || ("function" == typeof this.eventNameOrFunction ? this.eventNameOrFunction(n4) : this.observable.fire(this.eventNameOrFunction, n4));
            };
            return this.emitter.listenTo(n3.node, t4, i3), () => {
              this.emitter.stopListening(n3.node, t4, i3);
            };
          }
        }
        class qo2 extends Go2 {
          constructor(t4) {
            super(t4), this.valueIfTrue = t4.valueIfTrue;
          }
          getValue(t4) {
            return !or(super.getValue(t4)) && (this.valueIfTrue || true);
          }
        }
        function $o2(t4) {
          return !!t4 && (t4.value && (t4 = t4.value), Array.isArray(t4) ? t4.some($o2) : t4 instanceof Go2);
        }
        function Ko2(t4, e4, { node: n3 }) {
          const i3 = function(t5, e5) {
            return t5.map((t6) => t6 instanceof Go2 ? t6.getValue(e5) : t6);
          }(t4, n3);
          let o3;
          o3 = 1 == t4.length && t4[0] instanceof qo2 ? i3[0] : i3.reduce(er, ""), or(o3) ? e4.remove() : e4.set(o3);
        }
        function Zo2(t4) {
          return { set(e4) {
            t4.textContent = e4;
          }, remove() {
            t4.textContent = "";
          } };
        }
        function Yo2(t4, e4, n3) {
          return { set(i3) {
            t4.setAttributeNS(n3, e4, i3);
          }, remove() {
            t4.removeAttributeNS(n3, e4);
          } };
        }
        function Qo2(t4, e4) {
          return { set(n3) {
            t4.style[e4] = n3;
          }, remove() {
            t4.style[e4] = null;
          } };
        }
        function Jo2(t4) {
          return _i(t4, (t5) => {
            if (t5 && (t5 instanceof Go2 || sr(t5) || rr(t5) || ar(t5)))
              return t5;
          });
        }
        function Xo2(t4) {
          if ("string" == typeof t4 ? t4 = function(t5) {
            return { text: [t5] };
          }(t4) : t4.text && function(t5) {
            t5.text = yo2(t5.text);
          }(t4), t4.on && (t4.eventListeners = function(t5) {
            for (const e4 in t5)
              tr(t5, e4);
            return t5;
          }(t4.on), delete t4.on), !t4.text) {
            t4.attributes && function(t5) {
              for (const e5 in t5)
                t5[e5].value && (t5[e5].value = yo2(t5[e5].value)), tr(t5, e5);
            }(t4.attributes);
            const e4 = [];
            if (t4.children)
              if (ar(t4.children))
                e4.push(t4.children);
              else
                for (const n3 of t4.children)
                  sr(n3) || rr(n3) || Di2(n3) ? e4.push(n3) : e4.push(new Uo2(n3));
            t4.children = e4;
          }
          return t4;
        }
        function tr(t4, e4) {
          t4[e4] = yo2(t4[e4]);
        }
        function er(t4, e4) {
          return or(e4) ? t4 : or(t4) ? e4 : `${t4} ${e4}`;
        }
        function nr(t4, e4) {
          for (const n3 in e4)
            t4[n3] ? t4[n3].push(...e4[n3]) : t4[n3] = e4[n3];
        }
        function ir(t4, e4) {
          if (e4.attributes && (t4.attributes || (t4.attributes = {}), nr(t4.attributes, e4.attributes)), e4.eventListeners && (t4.eventListeners || (t4.eventListeners = {}), nr(t4.eventListeners, e4.eventListeners)), e4.text && t4.text.push(...e4.text), e4.children && e4.children.length) {
            if (t4.children.length != e4.children.length)
              throw new C2("ui-template-extend-children-mismatch", t4);
            let n3 = 0;
            for (const i3 of e4.children)
              ir(t4.children[n3++], i3);
          }
        }
        function or(t4) {
          return !t4 && 0 !== t4;
        }
        function rr(t4) {
          return t4 instanceof Ho2;
        }
        function sr(t4) {
          return t4 instanceof Uo2;
        }
        function ar(t4) {
          return t4 instanceof Ro2;
        }
        function cr(t4) {
          return F2(t4[0]) && t4[0].ns;
        }
        function lr(t4) {
          return "class" == t4 || "style" == t4;
        }
        class dr extends Ro2 {
          constructor(t4, e4 = []) {
            super(e4), this.locale = t4;
          }
          get bodyCollectionContainer() {
            return this._bodyCollectionContainer;
          }
          attachToDom() {
            this._bodyCollectionContainer = new Uo2({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render();
            let t4 = document.querySelector(".ck-body-wrapper");
            t4 || (t4 = bt2(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(t4)), t4.appendChild(this._bodyCollectionContainer);
          }
          detachFromDom() {
            super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
            const t4 = document.querySelector(".ck-body-wrapper");
            t4 && 0 == t4.childElementCount && t4.remove();
          }
        }
        var hr = n2(1977), ur = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(hr.Z, ur);
        hr.Z.locals;
        class gr extends Ho2 {
          constructor() {
            super();
            const t4 = this.bindTemplate;
            this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", true), this.set("isVisible", true), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon", t4.if("isVisible", "ck-hidden", (t5) => !t5), "ck-reset_all-excluded", t4.if("isColorInherited", "ck-icon_inherit-color")], viewBox: t4.to("viewBox") } });
          }
          render() {
            super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
              this._updateXMLContent(), this._colorFillPaths();
            }), this.on("change:fillColor", () => {
              this._colorFillPaths();
            });
          }
          _updateXMLContent() {
            if (this.content) {
              const t4 = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), e4 = t4.getAttribute("viewBox");
              e4 && (this.viewBox = e4);
              for (const { name: e5, value: n3 } of Array.from(t4.attributes))
                gr.presentationalAttributeNames.includes(e5) && this.element.setAttribute(e5, n3);
              for (; this.element.firstChild; )
                this.element.removeChild(this.element.firstChild);
              for (; t4.childNodes.length > 0; )
                this.element.appendChild(t4.childNodes[0]);
            }
          }
          _colorFillPaths() {
            this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((t4) => {
              t4.style.fill = this.fillColor;
            });
          }
        }
        gr.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];
        class mr extends Ho2 {
          constructor() {
            super(), this.set({ style: void 0, text: void 0, id: void 0 });
            const t4 = this.bindTemplate;
            this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: t4.to("style"), id: t4.to("id") }, children: [{ text: t4.to("text") }] });
          }
        }
        var pr = n2(4971), fr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(pr.Z, fr);
        pr.Z.locals;
        class kr extends Ho2 {
          constructor(t4, e4 = new mr()) {
            super(t4), this._focusDelayed = null;
            const n3 = this.bindTemplate, i3 = k2();
            this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${i3}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", true), this.set("isOn", false), this.set("isVisible", true), this.set("isToggleable", false), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", false), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.set("withKeystroke", false), this.children = this.createCollection(), this.labelView = this._setupLabelView(e4), this.iconView = new gr(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
            const o3 = { tag: "button", attributes: { class: ["ck", "ck-button", n3.to("class"), n3.if("isEnabled", "ck-disabled", (t5) => !t5), n3.if("isVisible", "ck-hidden", (t5) => !t5), n3.to("isOn", (t5) => t5 ? "ck-on" : "ck-off"), n3.if("withText", "ck-button_with-text"), n3.if("withKeystroke", "ck-button_with-keystroke")], role: n3.to("role"), type: n3.to("type", (t5) => t5 || "button"), tabindex: n3.to("tabindex"), "aria-label": n3.to("ariaLabel"), "aria-labelledby": n3.to("ariaLabelledBy"), "aria-disabled": n3.if("isEnabled", true, (t5) => !t5), "aria-pressed": n3.to("isOn", (t5) => !!this.isToggleable && String(!!t5)), "data-cke-tooltip-text": n3.to("_tooltipString"), "data-cke-tooltip-position": n3.to("tooltipPosition") }, children: this.children, on: { click: n3.to((t5) => {
              this.isEnabled ? this.fire("execute") : t5.preventDefault();
            }) } };
            c2.isSafari && (this._focusDelayed || (this._focusDelayed = Mo2(() => this.focus(), 0)), o3.on.mousedown = n3.to(() => {
              this._focusDelayed();
            }), o3.on.mouseup = n3.to(() => {
              this._focusDelayed.cancel();
            })), this.setTemplate(o3);
          }
          render() {
            super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
          }
          focus() {
            this.element.focus();
          }
          destroy() {
            this._focusDelayed && this._focusDelayed.cancel(), super.destroy();
          }
          _setupLabelView(t4) {
            return t4.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy"), t4;
          }
          _createKeystrokeView() {
            const t4 = new Ho2();
            return t4.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t5) => Ao2(t5)) }] }), t4;
          }
          _getTooltipString(t4, e4, n3) {
            return t4 ? "string" == typeof t4 ? t4 : (n3 && (n3 = Ao2(n3)), t4 instanceof Function ? t4(e4, n3) : `${e4}${n3 ? ` (${n3})` : ""}`) : "";
          }
        }
        var br = n2(7258), wr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(br.Z, wr);
        br.Z.locals;
        class Ar extends kr {
          constructor(t4) {
            super(t4), this.isToggleable = true, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
          }
          render() {
            super.render(), this.children.add(this.toggleSwitchView);
          }
          _createToggleView() {
            const t4 = new Ho2();
            return t4.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), t4;
          }
        }
        function Cr(t4, e4) {
          const n3 = t4.t, i3 = { Black: n3("Black"), "Dim grey": n3("Dim grey"), Grey: n3("Grey"), "Light grey": n3("Light grey"), White: n3("White"), Red: n3("Red"), Orange: n3("Orange"), Yellow: n3("Yellow"), "Light green": n3("Light green"), Green: n3("Green"), Aquamarine: n3("Aquamarine"), Turquoise: n3("Turquoise"), "Light blue": n3("Light blue"), Blue: n3("Blue"), Purple: n3("Purple") };
          return e4.map((t5) => {
            const e5 = i3[t5.label];
            return e5 && e5 != t5.label && (t5.label = e5), t5;
          });
        }
        function _r(t4) {
          return t4.map(vr).filter((t5) => !!t5);
        }
        function vr(t4) {
          return "string" == typeof t4 ? { model: t4, label: t4, hasBorder: false, view: { name: "span", styles: { color: t4 } } } : { model: t4.color, label: t4.label || t4.color, hasBorder: void 0 !== t4.hasBorder && t4.hasBorder, view: { name: "span", styles: { color: `${t4.color}` } } };
        }
        class yr extends kr {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.set("color", void 0), this.set("hasBorder", false), this.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z"/><path d="M14.814 6.035 8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z"/></svg>', this.extendTemplate({ attributes: { style: { backgroundColor: e4.to("color") }, class: ["ck", "ck-color-grid__tile", e4.if("hasBorder", "ck-color-selector__color-tile_bordered")] } });
          }
          render() {
            super.render(), this.iconView.fillColor = "hsl(0, 0%, 100%)";
          }
        }
        var xr = n2(4923), Er = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(xr.Z, Er);
        xr.Z.locals;
        class Dr extends Ho2 {
          constructor(t4, e4) {
            super(t4);
            const n3 = e4 && e4.colorDefinitions ? e4.colorDefinitions : [];
            this.columns = e4 && e4.columns ? e4.columns : 5;
            const i3 = { gridTemplateColumns: `repeat( ${this.columns}, 1fr)` };
            this.set("selectedColor", void 0), this.items = this.createCollection(), this.focusTracker = new To2(), this.keystrokes = new Io2(), this.items.on("add", (t5, e5) => {
              e5.isOn = e5.color === this.selectedColor;
            }), n3.forEach((t5) => {
              const e5 = new yr();
              e5.set({ color: t5.color, label: t5.label, tooltip: true, hasBorder: t5.options.hasBorder }), e5.on("execute", () => {
                this.fire("execute", { value: t5.color, hasBorder: t5.options.hasBorder, label: t5.label });
              }), this.items.add(e5);
            }), this.setTemplate({ tag: "div", children: this.items, attributes: { class: ["ck", "ck-color-grid"], style: i3 } }), this.on("change:selectedColor", (t5, e5, n4) => {
              for (const t6 of this.items)
                t6.isOn = t6.color === n4;
            });
          }
          focus() {
            this.items.length && this.items.first.focus();
          }
          focusLast() {
            this.items.length && this.items.last.focus();
          }
          render() {
            super.render();
            for (const t4 of this.items)
              this.focusTracker.add(t4.element);
            this.items.on("add", (t4, e4) => {
              this.focusTracker.add(e4.element);
            }), this.items.on("remove", (t4, e4) => {
              this.focusTracker.remove(e4.element);
            }), this.keystrokes.listenTo(this.element), r2({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: this.columns, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
        }
        var Sr = n2(8874);
        const Tr = function(t4) {
          var e4, n3, i3 = [], o3 = 1;
          if ("string" == typeof t4)
            if (Sr[t4])
              i3 = Sr[t4].slice(), n3 = "rgb";
            else if ("transparent" === t4)
              o3 = 0, n3 = "rgb", i3 = [0, 0, 0];
            else if (/^#[A-Fa-f0-9]+$/.test(t4)) {
              var r3 = t4.slice(1);
              o3 = 1, (c3 = r3.length) <= 4 ? (i3 = [parseInt(r3[0] + r3[0], 16), parseInt(r3[1] + r3[1], 16), parseInt(r3[2] + r3[2], 16)], 4 === c3 && (o3 = parseInt(r3[3] + r3[3], 16) / 255)) : (i3 = [parseInt(r3[0] + r3[1], 16), parseInt(r3[2] + r3[3], 16), parseInt(r3[4] + r3[5], 16)], 8 === c3 && (o3 = parseInt(r3[6] + r3[7], 16) / 255)), i3[0] || (i3[0] = 0), i3[1] || (i3[1] = 0), i3[2] || (i3[2] = 0), n3 = "rgb";
            } else if (e4 = /^((?:rgb|hs[lvb]|hwb|cmyk?|xy[zy]|gray|lab|lchu?v?|[ly]uv|lms)a?)\s*\(([^\)]*)\)/.exec(t4)) {
              var s3 = e4[1], a3 = "rgb" === s3;
              n3 = r3 = s3.replace(/a$/, "");
              var c3 = "cmyk" === r3 ? 4 : "gray" === r3 ? 1 : 3;
              i3 = e4[2].trim().split(/\s*[,\/]\s*|\s+/).map(function(t5, e5) {
                if (/%$/.test(t5))
                  return e5 === c3 ? parseFloat(t5) / 100 : "rgb" === r3 ? 255 * parseFloat(t5) / 100 : parseFloat(t5);
                if ("h" === r3[e5]) {
                  if (/deg$/.test(t5))
                    return parseFloat(t5);
                  if (void 0 !== Ir[t5])
                    return Ir[t5];
                }
                return parseFloat(t5);
              }), s3 === r3 && i3.push(1), o3 = a3 || void 0 === i3[c3] ? 1 : i3[c3], i3 = i3.slice(0, c3);
            } else
              t4.length > 10 && /[0-9](?:\s|\/)/.test(t4) && (i3 = t4.match(/([0-9]+)/g).map(function(t5) {
                return parseFloat(t5);
              }), n3 = t4.match(/([a-z])/gi).join("").toLowerCase());
          else
            isNaN(t4) ? Array.isArray(t4) || t4.length ? (i3 = [t4[0], t4[1], t4[2]], n3 = "rgb", o3 = 4 === t4.length ? t4[3] : 1) : t4 instanceof Object && (null != t4.r || null != t4.red || null != t4.R ? (n3 = "rgb", i3 = [t4.r || t4.red || t4.R || 0, t4.g || t4.green || t4.G || 0, t4.b || t4.blue || t4.B || 0]) : (n3 = "hsl", i3 = [t4.h || t4.hue || t4.H || 0, t4.s || t4.saturation || t4.S || 0, t4.l || t4.lightness || t4.L || t4.b || t4.brightness]), o3 = t4.a || t4.alpha || t4.opacity || 1, null != t4.opacity && (o3 /= 100)) : (n3 = "rgb", i3 = [t4 >>> 16, (65280 & t4) >>> 8, 255 & t4]);
          return { space: n3, values: i3, alpha: o3 };
        };
        var Ir = { red: 0, orange: 60, yellow: 120, green: 180, blue: 240, purple: 300 };
        var Br = n2(2085);
        function Mr(t4, e4) {
          if (!t4)
            return "";
          const n3 = Nr(t4);
          if (!n3)
            return "";
          if (n3.space === e4)
            return t4;
          if (i3 = n3, !Object.keys(Br).includes(i3.space))
            return "";
          var i3;
          const o3 = Br[n3.space][e4];
          if (!o3)
            return "";
          return function(t5, e5) {
            switch (e5) {
              case "hex":
                return `#${t5}`;
              case "rgb":
                return `rgb( ${t5[0]}, ${t5[1]}, ${t5[2]} )`;
              case "hsl":
                return `hsl( ${t5[0]}, ${t5[1]}%, ${t5[2]}% )`;
              case "hwb":
                return `hwb( ${t5[0]}, ${t5[1]}, ${t5[2]} )`;
              case "lab":
                return `lab( ${t5[0]}% ${t5[1]} ${t5[2]} )`;
              case "lch":
                return `lch( ${t5[0]}% ${t5[1]} ${t5[2]} )`;
              default:
                return "";
            }
          }(o3("hex" === n3.space ? n3.hexValue : n3.values), e4);
        }
        function Nr(t4) {
          if (t4.startsWith("#")) {
            const e5 = Tr(t4);
            return { space: "hex", values: e5.values, hexValue: t4, alpha: e5.alpha };
          }
          const e4 = Tr(t4);
          return e4.space ? e4 : null;
        }
        const Lr = function() {
          return ot2.Date.now();
        };
        var zr = /\s/;
        const Pr = function(t4) {
          for (var e4 = t4.length; e4-- && zr.test(t4.charAt(e4)); )
            ;
          return e4;
        };
        var Rr = /^\s+/;
        const Or = function(t4) {
          return t4 ? t4.slice(0, Pr(t4) + 1).replace(Rr, "") : t4;
        };
        const Fr = function(t4) {
          return "symbol" == typeof t4 || ft2(t4) && "[object Symbol]" == mt2(t4);
        };
        var Vr = /^[-+]0x[0-9a-f]+$/i, jr = /^0b[01]+$/i, Hr = /^0o[0-7]+$/i, Ur = parseInt;
        const Gr = function(t4) {
          if ("number" == typeof t4)
            return t4;
          if (Fr(t4))
            return NaN;
          if (F2(t4)) {
            var e4 = "function" == typeof t4.valueOf ? t4.valueOf() : t4;
            t4 = F2(e4) ? e4 + "" : e4;
          }
          if ("string" != typeof t4)
            return 0 === t4 ? t4 : +t4;
          t4 = Or(t4);
          var n3 = jr.test(t4);
          return n3 || Hr.test(t4) ? Ur(t4.slice(2), n3 ? 2 : 8) : Vr.test(t4) ? NaN : +t4;
        };
        var Wr = Math.max, qr = Math.min;
        const $r = function(t4, e4, n3) {
          var i3, o3, r3, s3, a3, c3, l3 = 0, d3 = false, h3 = false, u3 = true;
          if ("function" != typeof t4)
            throw new TypeError("Expected a function");
          function g3(e5) {
            var n4 = i3, r4 = o3;
            return i3 = o3 = void 0, l3 = e5, s3 = t4.apply(r4, n4);
          }
          function m3(t5) {
            var n4 = t5 - c3;
            return void 0 === c3 || n4 >= e4 || n4 < 0 || h3 && t5 - l3 >= r3;
          }
          function p3() {
            var t5 = Lr();
            if (m3(t5))
              return f3(t5);
            a3 = setTimeout(p3, function(t6) {
              var n4 = e4 - (t6 - c3);
              return h3 ? qr(n4, r3 - (t6 - l3)) : n4;
            }(t5));
          }
          function f3(t5) {
            return a3 = void 0, u3 && i3 ? g3(t5) : (i3 = o3 = void 0, s3);
          }
          function k3() {
            var t5 = Lr(), n4 = m3(t5);
            if (i3 = arguments, o3 = this, c3 = t5, n4) {
              if (void 0 === a3)
                return function(t6) {
                  return l3 = t6, a3 = setTimeout(p3, e4), d3 ? g3(t6) : s3;
                }(c3);
              if (h3)
                return clearTimeout(a3), a3 = setTimeout(p3, e4), g3(c3);
            }
            return void 0 === a3 && (a3 = setTimeout(p3, e4)), s3;
          }
          return e4 = Gr(e4) || 0, F2(n3) && (d3 = !!n3.leading, r3 = (h3 = "maxWait" in n3) ? Wr(Gr(n3.maxWait) || 0, e4) : r3, u3 = "trailing" in n3 ? !!n3.trailing : u3), k3.cancel = function() {
            void 0 !== a3 && clearTimeout(a3), l3 = 0, i3 = c3 = o3 = a3 = void 0;
          }, k3.flush = function() {
            return void 0 === a3 ? s3 : f3(Lr());
          }, k3;
        };
        var Kr = n2(3525), Zr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Kr.Z, Zr);
        Kr.Z.locals;
        class Yr extends Ho2 {
          constructor(t4) {
            super(t4), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${k2()}`;
            const e4 = this.bindTemplate;
            this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: e4.to("for") }, children: [{ text: e4.to("text") }] });
          }
        }
        var Qr = n2(2933), Jr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Qr.Z, Jr);
        Qr.Z.locals;
        class Xr extends Ho2 {
          constructor(t4, e4) {
            super(t4);
            const n3 = `ck-labeled-field-view-${k2()}`, i3 = `ck-labeled-field-view-status-${k2()}`;
            this.fieldView = e4(this, n3, i3), this.set("label", void 0), this.set("isEnabled", true), this.set("isEmpty", true), this.set("isFocused", false), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n3), this.statusView = this._createStatusView(i3), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (t5, e5) => t5 || e5);
            const o3 = this.bindTemplate;
            this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", o3.to("class"), o3.if("isEnabled", "ck-disabled", (t5) => !t5), o3.if("isEmpty", "ck-labeled-field-view_empty"), o3.if("isFocused", "ck-labeled-field-view_focused"), o3.if("placeholder", "ck-labeled-field-view_placeholder"), o3.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: this.fieldWrapperChildren }, this.statusView] });
          }
          _createLabelView(t4) {
            const e4 = new Yr(this.locale);
            return e4.for = t4, e4.bind("text").to(this, "label"), e4;
          }
          _createStatusView(t4) {
            const e4 = new Ho2(this.locale), n3 = this.bindTemplate;
            return e4.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n3.if("errorText", "ck-labeled-field-view__status_error"), n3.if("_statusText", "ck-hidden", (t5) => !t5)], id: t4, role: n3.if("errorText", "alert") }, children: [{ text: n3.to("_statusText") }] }), e4;
          }
          focus(t4) {
            this.fieldView.focus(t4);
          }
        }
        class ts extends Ho2 {
          constructor(t4) {
            super(t4), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", false), this.set("hasError", false), this.set("ariaDescribedById", void 0), this.focusTracker = new To2(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", true);
            const e4 = this.bindTemplate;
            this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", e4.if("isFocused", "ck-input_focused"), e4.if("isEmpty", "ck-input-text_empty"), e4.if("hasError", "ck-error")], id: e4.to("id"), placeholder: e4.to("placeholder"), readonly: e4.to("isReadOnly"), "aria-invalid": e4.if("hasError", true), "aria-describedby": e4.to("ariaDescribedById") }, on: { input: e4.to((...t5) => {
              this.fire("input", ...t5), this._updateIsEmpty();
            }), change: e4.to(this._updateIsEmpty.bind(this)) } });
          }
          render() {
            super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (t4, e4, n3) => {
              this._setDomElementValue(n3), this._updateIsEmpty();
            });
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy();
          }
          select() {
            this.element.select();
          }
          focus() {
            this.element.focus();
          }
          reset() {
            this.value = this.element.value = "", this._updateIsEmpty();
          }
          _updateIsEmpty() {
            this.isEmpty = !this.element.value;
          }
          _setDomElementValue(t4) {
            this.element.value = t4 || 0 === t4 ? t4 : "";
          }
        }
        var es = n2(2470), ns = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(es.Z, ns);
        es.Z.locals;
        class is2 extends ts {
          constructor(t4) {
            super(t4), this.set("inputMode", "text");
            const e4 = this.bindTemplate;
            this.extendTemplate({ attributes: { inputmode: e4.to("inputMode") } });
          }
        }
        class os extends is2 {
          constructor(t4) {
            super(t4), this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } });
          }
        }
        var rs = n2(5224), ss = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(rs.Z, ss);
        rs.Z.locals;
        class as extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.set("isVisible", false), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", e4.to("position", (t5) => `ck-dropdown__panel_${t5}`), e4.if("isVisible", "ck-dropdown__panel-visible")], tabindex: "-1" }, children: this.children, on: { selectstart: e4.to((t5) => {
              "input" !== t5.target.tagName.toLocaleLowerCase() && t5.preventDefault();
            }) } });
          }
          focus() {
            if (this.children.length) {
              const t4 = this.children.first;
              "function" == typeof t4.focus ? t4.focus() : _2("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
            }
          }
          focusLast() {
            if (this.children.length) {
              const t4 = this.children.last;
              "function" == typeof t4.focusLast ? t4.focusLast() : t4.focus();
            }
          }
        }
        var cs = n2(5062), ls = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(cs.Z, ls);
        cs.Z.locals;
        class ds extends Ho2 {
          constructor(t4, e4, n3) {
            super(t4);
            const i3 = this.bindTemplate;
            this.buttonView = e4, this.panelView = n3, this.set("isOpen", false), this.set("isEnabled", true), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.panelView.bind("isVisible").to(this, "isOpen"), this.keystrokes = new Io2(), this.focusTracker = new To2(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", i3.to("class"), i3.if("isEnabled", "ck-disabled", (t5) => !t5)], id: i3.to("id"), "aria-describedby": i3.to("ariaDescribedById") }, children: [e4, n3] }), e4.extendTemplate({ attributes: { class: ["ck-dropdown__button"], "data-cke-tooltip-disabled": i3.to("isOpen") } });
          }
          render() {
            super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
              this.isOpen = !this.isOpen;
            }), this.on("change:isOpen", (t5, e4, n3) => {
              if (n3)
                if ("auto" === this.panelPosition) {
                  const t6 = ds._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: true, positions: this._panelPositions });
                  this.panelView.position = t6 ? t6.name : this._panelPositions[0].name;
                } else
                  this.panelView.position = this.panelPosition;
            }), this.keystrokes.listenTo(this.element);
            const t4 = (t5, e4) => {
              this.isOpen && (this.isOpen = false, e4());
            };
            this.keystrokes.set("arrowdown", (t5, e4) => {
              this.buttonView.isEnabled && !this.isOpen && (this.isOpen = true, e4());
            }), this.keystrokes.set("arrowright", (t5, e4) => {
              this.isOpen && e4();
            }), this.keystrokes.set("arrowleft", t4), this.keystrokes.set("esc", t4);
          }
          focus() {
            this.buttonView.focus();
          }
          get _panelPositions() {
            const { south: t4, north: e4, southEast: n3, southWest: i3, northEast: o3, northWest: r3, southMiddleEast: s3, southMiddleWest: a3, northMiddleEast: c3, northMiddleWest: l3 } = ds.defaultPanelPositions;
            return "rtl" !== this.locale.uiLanguageDirection ? [n3, i3, s3, a3, t4, o3, r3, c3, l3, e4] : [i3, n3, a3, s3, t4, r3, o3, l3, c3, e4];
          }
        }
        ds.defaultPanelPositions = { south: (t4, e4) => ({ top: t4.bottom, left: t4.left - (e4.width - t4.width) / 2, name: "s" }), southEast: (t4) => ({ top: t4.bottom, left: t4.left, name: "se" }), southWest: (t4, e4) => ({ top: t4.bottom, left: t4.left - e4.width + t4.width, name: "sw" }), southMiddleEast: (t4, e4) => ({ top: t4.bottom, left: t4.left - (e4.width - t4.width) / 4, name: "sme" }), southMiddleWest: (t4, e4) => ({ top: t4.bottom, left: t4.left - 3 * (e4.width - t4.width) / 4, name: "smw" }), north: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left - (e4.width - t4.width) / 2, name: "n" }), northEast: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left, name: "ne" }), northWest: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left - e4.width + t4.width, name: "nw" }), northMiddleEast: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left - (e4.width - t4.width) / 4, name: "nme" }), northMiddleWest: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left - 3 * (e4.width - t4.width) / 4, name: "nmw" }) }, ds._getOptimalPosition = Xi2;
        const hs = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
        class us extends kr {
          constructor(t4) {
            super(t4), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": true, "aria-expanded": this.bindTemplate.to("isOn", (t5) => String(t5)) } }), this.delegate("execute").to(this, "open");
          }
          render() {
            super.render(), this.children.add(this.arrowView);
          }
          _createArrowView() {
            const t4 = new gr();
            return t4.content = hs, t4.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), t4;
          }
        }
        class gs extends B2() {
          constructor(t4) {
            if (super(), this.focusables = t4.focusables, this.focusTracker = t4.focusTracker, this.keystrokeHandler = t4.keystrokeHandler, this.actions = t4.actions, t4.actions && t4.keystrokeHandler)
              for (const e4 in t4.actions) {
                let n3 = t4.actions[e4];
                "string" == typeof n3 && (n3 = [n3]);
                for (const i3 of n3)
                  t4.keystrokeHandler.set(i3, (t5, n4) => {
                    this[e4](), n4();
                  });
              }
            this.on("forwardCycle", () => this.focusFirst(), { priority: "low" }), this.on("backwardCycle", () => this.focusLast(), { priority: "low" });
          }
          get first() {
            return this.focusables.find(ms) || null;
          }
          get last() {
            return this.focusables.filter(ms).slice(-1)[0] || null;
          }
          get next() {
            return this._getFocusableItem(1);
          }
          get previous() {
            return this._getFocusableItem(-1);
          }
          get current() {
            let t4 = null;
            return null === this.focusTracker.focusedElement ? null : (this.focusables.find((e4, n3) => {
              const i3 = e4.element === this.focusTracker.focusedElement;
              return i3 && (t4 = n3), i3;
            }), t4);
          }
          focusFirst() {
            this._focus(this.first, 1);
          }
          focusLast() {
            this._focus(this.last, -1);
          }
          focusNext() {
            const t4 = this.next;
            t4 && this.focusables.getIndex(t4) === this.current || (t4 === this.first ? this.fire("forwardCycle") : this._focus(t4, 1));
          }
          focusPrevious() {
            const t4 = this.previous;
            t4 && this.focusables.getIndex(t4) === this.current || (t4 === this.last ? this.fire("backwardCycle") : this._focus(t4, -1));
          }
          _focus(t4, e4) {
            t4 && t4.focus(e4);
          }
          _getFocusableItem(t4) {
            const e4 = this.current, n3 = this.focusables.length;
            if (!n3)
              return null;
            if (null === e4)
              return this[1 === t4 ? "first" : "last"];
            let i3 = (e4 + n3 + t4) % n3;
            do {
              const e5 = this.focusables.get(i3);
              if (ms(e5))
                return e5;
              i3 = (i3 + n3 + t4) % n3;
            } while (i3 !== e4);
            return null;
          }
        }
        function ms(t4) {
          return !(!("focus" in t4) || !Ji2(t4.element));
        }
        class ps extends Ho2 {
          constructor(t4) {
            super(t4), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
          }
        }
        class fs extends Ho2 {
          constructor(t4) {
            super(t4), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } });
          }
        }
        function ks(t4) {
          if (Array.isArray(t4))
            return { items: t4, removeItems: [] };
          const e4 = { items: [], removeItems: [] };
          return t4 ? { ...e4, ...t4 } : e4;
        }
        class bs extends q2() {
          constructor(t4) {
            super(), this._disableStack = /* @__PURE__ */ new Set(), this.editor = t4, this.set("isEnabled", true);
          }
          forceDisabled(t4) {
            this._disableStack.add(t4), 1 == this._disableStack.size && (this.on("set:isEnabled", ws, { priority: "highest" }), this.isEnabled = false);
          }
          clearForceDisabled(t4) {
            this._disableStack.delete(t4), 0 == this._disableStack.size && (this.off("set:isEnabled", ws), this.isEnabled = true);
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return false;
          }
        }
        function ws(t4) {
          t4.return = false, t4.stop();
        }
        class As extends q2() {
          constructor(t4) {
            super(), this.editor = t4, this.set("value", void 0), this.set("isEnabled", false), this._affectsData = true, this._isEnabledBasedOnSelection = true, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
              this.refresh();
            }), this.listenTo(t4, "change:isReadOnly", () => {
              this.refresh();
            }), this.on("set:isEnabled", (e4) => {
              if (!this.affectsData)
                return;
              const n3 = t4.model.document.selection, i3 = !("$graveyard" == n3.getFirstPosition().root.rootName) && t4.model.canEditAt(n3);
              (t4.isReadOnly || this._isEnabledBasedOnSelection && !i3) && (e4.return = false, e4.stop());
            }, { priority: "highest" }), this.on("execute", (t5) => {
              this.isEnabled || t5.stop();
            }, { priority: "high" });
          }
          get affectsData() {
            return this._affectsData;
          }
          set affectsData(t4) {
            this._affectsData = t4;
          }
          refresh() {
            this.isEnabled = true;
          }
          forceDisabled(t4) {
            this._disableStack.add(t4), 1 == this._disableStack.size && (this.on("set:isEnabled", Cs, { priority: "highest" }), this.isEnabled = false);
          }
          clearForceDisabled(t4) {
            this._disableStack.delete(t4), 0 == this._disableStack.size && (this.off("set:isEnabled", Cs), this.refresh());
          }
          execute(...t4) {
          }
          destroy() {
            this.stopListening();
          }
        }
        function Cs(t4) {
          t4.return = false, t4.stop();
        }
        class _s extends As {
          constructor() {
            super(...arguments), this._childCommandsDefinitions = [];
          }
          refresh() {
          }
          execute(...t4) {
            const e4 = this._getFirstEnabledCommand();
            return !!e4 && e4.execute(t4);
          }
          registerChildCommand(t4, e4 = {}) {
            w2(this._childCommandsDefinitions, { command: t4, priority: e4.priority || "normal" }), t4.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
          }
          _checkEnabled() {
            this.isEnabled = !!this._getFirstEnabledCommand();
          }
          _getFirstEnabledCommand() {
            const t4 = this._childCommandsDefinitions.find(({ command: t5 }) => t5.isEnabled);
            return t4 && t4.command;
          }
        }
        class vs extends B2() {
          constructor(t4, e4 = [], n3 = []) {
            super(), this._plugins = /* @__PURE__ */ new Map(), this._context = t4, this._availablePlugins = /* @__PURE__ */ new Map();
            for (const t5 of e4)
              t5.pluginName && this._availablePlugins.set(t5.pluginName, t5);
            this._contextPlugins = /* @__PURE__ */ new Map();
            for (const [t5, e5] of n3)
              this._contextPlugins.set(t5, e5), this._contextPlugins.set(e5, t5), t5.pluginName && this._availablePlugins.set(t5.pluginName, t5);
          }
          *[Symbol.iterator]() {
            for (const t4 of this._plugins)
              "function" == typeof t4[0] && (yield t4);
          }
          get(t4) {
            const e4 = this._plugins.get(t4);
            if (!e4) {
              let e5 = t4;
              throw "function" == typeof t4 && (e5 = t4.pluginName || t4.name), new C2("plugincollection-plugin-not-loaded", this._context, { plugin: e5 });
            }
            return e4;
          }
          has(t4) {
            return this._plugins.has(t4);
          }
          init(t4, e4 = [], n3 = []) {
            const i3 = this, o3 = this._context;
            !function t5(e5, n4 = /* @__PURE__ */ new Set()) {
              e5.forEach((e6) => {
                a3(e6) && (n4.has(e6) || (n4.add(e6), e6.pluginName && !i3._availablePlugins.has(e6.pluginName) && i3._availablePlugins.set(e6.pluginName, e6), e6.requires && t5(e6.requires, n4)));
              });
            }(t4), h3(t4);
            const r3 = [...function t5(e5, n4 = /* @__PURE__ */ new Set()) {
              return e5.map((t6) => a3(t6) ? t6 : i3._availablePlugins.get(t6)).reduce((e6, i4) => n4.has(i4) ? e6 : (n4.add(i4), i4.requires && (h3(i4.requires, i4), t5(i4.requires, n4).forEach((t6) => e6.add(t6))), e6.add(i4)), /* @__PURE__ */ new Set());
            }(t4.filter((t5) => !l3(t5, e4)))];
            !function(t5, e5) {
              for (const n4 of e5) {
                if ("function" != typeof n4)
                  throw new C2("plugincollection-replace-plugin-invalid-type", null, { pluginItem: n4 });
                const e6 = n4.pluginName;
                if (!e6)
                  throw new C2("plugincollection-replace-plugin-missing-name", null, { pluginItem: n4 });
                if (n4.requires && n4.requires.length)
                  throw new C2("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: e6 });
                const o4 = i3._availablePlugins.get(e6);
                if (!o4)
                  throw new C2("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: e6 });
                const r4 = t5.indexOf(o4);
                if (-1 === r4) {
                  if (i3._contextPlugins.has(o4))
                    return;
                  throw new C2("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: e6 });
                }
                if (o4.requires && o4.requires.length)
                  throw new C2("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: e6 });
                t5.splice(r4, 1, n4), i3._availablePlugins.set(e6, n4);
              }
            }(r3, n3);
            const s3 = function(t5) {
              return t5.map((t6) => {
                let e5 = i3._contextPlugins.get(t6);
                return e5 = e5 || new t6(o3), i3._add(t6, e5), e5;
              });
            }(r3);
            return u3(s3, "init").then(() => u3(s3, "afterInit")).then(() => s3);
            function a3(t5) {
              return "function" == typeof t5;
            }
            function c3(t5) {
              return a3(t5) && !!t5.isContextPlugin;
            }
            function l3(t5, e5) {
              return e5.some((e6) => e6 === t5 || (d3(t5) === e6 || d3(e6) === t5));
            }
            function d3(t5) {
              return a3(t5) ? t5.pluginName || t5.name : t5;
            }
            function h3(t5, n4 = null) {
              t5.map((t6) => a3(t6) ? t6 : i3._availablePlugins.get(t6) || t6).forEach((t6) => {
                !function(t7, e5) {
                  if (a3(t7))
                    return;
                  if (e5)
                    throw new C2("plugincollection-soft-required", o3, { missingPlugin: t7, requiredBy: d3(e5) });
                  throw new C2("plugincollection-plugin-not-found", o3, { plugin: t7 });
                }(t6, n4), function(t7, e5) {
                  if (!c3(e5))
                    return;
                  if (c3(t7))
                    return;
                  throw new C2("plugincollection-context-required", o3, { plugin: d3(t7), requiredBy: d3(e5) });
                }(t6, n4), function(t7, n5) {
                  if (!n5)
                    return;
                  if (!l3(t7, e4))
                    return;
                  throw new C2("plugincollection-required", o3, { plugin: d3(t7), requiredBy: d3(n5) });
                }(t6, n4);
              });
            }
            function u3(t5, e5) {
              return t5.reduce((t6, n4) => n4[e5] ? i3._contextPlugins.has(n4) ? t6 : t6.then(n4[e5].bind(n4)) : t6, Promise.resolve());
            }
          }
          destroy() {
            const t4 = [];
            for (const [, e4] of this)
              "function" != typeof e4.destroy || this._contextPlugins.has(e4) || t4.push(e4.destroy());
            return Promise.all(t4);
          }
          _add(t4, e4) {
            this._plugins.set(t4, e4);
            const n3 = t4.pluginName;
            if (n3) {
              if (this._plugins.has(n3))
                throw new C2("plugincollection-plugin-name-conflict", null, { pluginName: n3, plugin1: this._plugins.get(n3).constructor, plugin2: t4 });
              this._plugins.set(n3, e4);
            }
          }
        }
        class ys {
          constructor(t4) {
            this._contextOwner = null, this.config = new yi2(t4, this.constructor.defaultConfig);
            const e4 = this.constructor.builtinPlugins;
            this.config.define("plugins", e4), this.plugins = new vs(this, e4);
            const n3 = this.config.get("language") || {};
            this.locale = new Eo2({ uiLanguage: "string" == typeof n3 ? n3 : n3.ui, contentLanguage: this.config.get("language.content") }), this.t = this.locale.t, this.editors = new Do2();
          }
          initPlugins() {
            const t4 = this.config.get("plugins") || [], e4 = this.config.get("substitutePlugins") || [];
            for (const n3 of t4.concat(e4)) {
              if ("function" != typeof n3)
                throw new C2("context-initplugins-constructor-only", null, { Plugin: n3 });
              if (true !== n3.isContextPlugin)
                throw new C2("context-initplugins-invalid-plugin", null, { Plugin: n3 });
            }
            return this.plugins.init(t4, [], e4);
          }
          destroy() {
            return Promise.all(Array.from(this.editors, (t4) => t4.destroy())).then(() => this.plugins.destroy());
          }
          _addEditor(t4, e4) {
            if (this._contextOwner)
              throw new C2("context-addeditor-private-context");
            this.editors.add(t4), e4 && (this._contextOwner = t4);
          }
          _removeEditor(t4) {
            return this.editors.has(t4) && this.editors.remove(t4), this._contextOwner === t4 ? this.destroy() : Promise.resolve();
          }
          _getEditorConfig() {
            const t4 = {};
            for (const e4 of this.config.names())
              ["plugins", "removePlugins", "extraPlugins"].includes(e4) || (t4[e4] = this.config.get(e4));
            return t4;
          }
          static create(t4) {
            return new Promise((e4) => {
              const n3 = new this(t4);
              e4(n3.initPlugins().then(() => n3));
            });
          }
        }
        class xs extends q2() {
          constructor(t4) {
            super(), this.context = t4;
          }
          destroy() {
            this.stopListening();
          }
          static get isContextPlugin() {
            return true;
          }
        }
        var Es = n2(7372), Ds = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Es.Z, Ds);
        Es.Z.locals;
        const Ss = /* @__PURE__ */ new WeakMap();
        let Ts = false;
        function Is({ view: t4, element: e4, text: n3, isDirectHost: i3 = true, keepOnFocus: o3 = false }) {
          const r3 = t4.document;
          function s3(n4) {
            Ss.get(r3).set(e4, { text: n4, isDirectHost: i3, keepOnFocus: o3, hostElement: i3 ? e4 : null }), t4.change((t5) => Ms(r3, t5));
          }
          Ss.has(r3) || (Ss.set(r3, /* @__PURE__ */ new Map()), r3.registerPostFixer((t5) => Ms(r3, t5)), r3.on("change:isComposing", () => {
            t4.change((t5) => Ms(r3, t5));
          }, { priority: "high" })), e4.is("editableElement") && e4.on("change:placeholder", (t5, e5, n4) => {
            s3(n4);
          }), e4.placeholder ? s3(e4.placeholder) : n3 && s3(n3), n3 && function() {
            Ts || _2("enableplaceholder-deprecated-text-option");
            Ts = true;
          }();
        }
        function Bs(t4, e4) {
          return !!e4.hasClass("ck-placeholder") && (t4.removeClass("ck-placeholder", e4), true);
        }
        function Ms(t4, e4) {
          const n3 = Ss.get(t4), i3 = [];
          let o3 = false;
          for (const [t5, r3] of n3)
            r3.isDirectHost && (i3.push(t5), Ns(e4, t5, r3) && (o3 = true));
          for (const [t5, r3] of n3) {
            if (r3.isDirectHost)
              continue;
            const n4 = Ls(t5);
            n4 && (i3.includes(n4) || (r3.hostElement = n4, Ns(e4, t5, r3) && (o3 = true)));
          }
          return o3;
        }
        function Ns(t4, e4, n3) {
          const { text: i3, isDirectHost: o3, hostElement: r3 } = n3;
          let s3 = false;
          r3.getAttribute("data-placeholder") !== i3 && (t4.setAttribute("data-placeholder", i3, r3), s3 = true);
          return (o3 || 1 == e4.childCount) && function(t5, e5) {
            if (!t5.isAttached())
              return false;
            const n4 = Array.from(t5.getChildren()).some((t6) => !t6.is("uiElement"));
            if (n4)
              return false;
            const i4 = t5.document, o4 = i4.selection.anchor;
            return !(i4.isComposing && o4 && o4.parent === t5 || !e5 && i4.isFocused && (!o4 || o4.parent === t5));
          }(r3, n3.keepOnFocus) ? function(t5, e5) {
            return !e5.hasClass("ck-placeholder") && (t5.addClass("ck-placeholder", e5), true);
          }(t4, r3) && (s3 = true) : Bs(t4, r3) && (s3 = true), s3;
        }
        function Ls(t4) {
          if (t4.childCount) {
            const e4 = t4.getChild(0);
            if (e4.is("element") && !e4.is("uiElement") && !e4.is("attributeElement"))
              return e4;
          }
          return null;
        }
        class zs {
          is() {
            throw new Error("is() method is abstract");
          }
        }
        const Ps = function(t4) {
          return Ci2(t4, 4);
        };
        class Rs extends B2(zs) {
          constructor(t4) {
            super(), this.document = t4, this.parent = null;
          }
          get index() {
            let t4;
            if (!this.parent)
              return null;
            if (-1 == (t4 = this.parent.getChildIndex(this)))
              throw new C2("view-node-not-found-in-parent", this);
            return t4;
          }
          get nextSibling() {
            const t4 = this.index;
            return null !== t4 && this.parent.getChild(t4 + 1) || null;
          }
          get previousSibling() {
            const t4 = this.index;
            return null !== t4 && this.parent.getChild(t4 - 1) || null;
          }
          get root() {
            let t4 = this;
            for (; t4.parent; )
              t4 = t4.parent;
            return t4;
          }
          isAttached() {
            return this.root.is("rootElement");
          }
          getPath() {
            const t4 = [];
            let e4 = this;
            for (; e4.parent; )
              t4.unshift(e4.index), e4 = e4.parent;
            return t4;
          }
          getAncestors(t4 = {}) {
            const e4 = [];
            let n3 = t4.includeSelf ? this : this.parent;
            for (; n3; )
              e4[t4.parentFirst ? "push" : "unshift"](n3), n3 = n3.parent;
            return e4;
          }
          getCommonAncestor(t4, e4 = {}) {
            const n3 = this.getAncestors(e4), i3 = t4.getAncestors(e4);
            let o3 = 0;
            for (; n3[o3] == i3[o3] && n3[o3]; )
              o3++;
            return 0 === o3 ? null : n3[o3 - 1];
          }
          isBefore(t4) {
            if (this == t4)
              return false;
            if (this.root !== t4.root)
              return false;
            const e4 = this.getPath(), n3 = t4.getPath(), i3 = tt2(e4, n3);
            switch (i3) {
              case "prefix":
                return true;
              case "extension":
                return false;
              default:
                return e4[i3] < n3[i3];
            }
          }
          isAfter(t4) {
            return this != t4 && (this.root === t4.root && !this.isBefore(t4));
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _fireChange(t4, e4) {
            this.fire(`change:${t4}`, e4), this.parent && this.parent._fireChange(t4, e4);
          }
          toJSON() {
            const t4 = Ps(this);
            return delete t4.parent, t4;
          }
        }
        Rs.prototype.is = function(t4) {
          return "node" === t4 || "view:node" === t4;
        };
        class Os extends Rs {
          constructor(t4, e4) {
            super(t4), this._textData = e4;
          }
          get data() {
            return this._textData;
          }
          get _data() {
            return this.data;
          }
          set _data(t4) {
            this._fireChange("text", this), this._textData = t4;
          }
          isSimilar(t4) {
            return t4 instanceof Os && (this === t4 || this.data === t4.data);
          }
          _clone() {
            return new Os(this.document, this.data);
          }
        }
        Os.prototype.is = function(t4) {
          return "$text" === t4 || "view:$text" === t4 || "text" === t4 || "view:text" === t4 || "node" === t4 || "view:node" === t4;
        };
        class Fs extends zs {
          constructor(t4, e4, n3) {
            if (super(), this.textNode = t4, e4 < 0 || e4 > t4.data.length)
              throw new C2("view-textproxy-wrong-offsetintext", this);
            if (n3 < 0 || e4 + n3 > t4.data.length)
              throw new C2("view-textproxy-wrong-length", this);
            this.data = t4.data.substring(e4, e4 + n3), this.offsetInText = e4;
          }
          get offsetSize() {
            return this.data.length;
          }
          get isPartial() {
            return this.data.length !== this.textNode.data.length;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          get document() {
            return this.textNode.document;
          }
          getAncestors(t4 = {}) {
            const e4 = [];
            let n3 = t4.includeSelf ? this.textNode : this.parent;
            for (; null !== n3; )
              e4[t4.parentFirst ? "push" : "unshift"](n3), n3 = n3.parent;
            return e4;
          }
        }
        Fs.prototype.is = function(t4) {
          return "$textProxy" === t4 || "view:$textProxy" === t4 || "textProxy" === t4 || "view:textProxy" === t4;
        };
        class Vs {
          constructor(...t4) {
            this._patterns = [], this.add(...t4);
          }
          add(...t4) {
            for (let e4 of t4)
              ("string" == typeof e4 || e4 instanceof RegExp) && (e4 = { name: e4 }), this._patterns.push(e4);
          }
          match(...t4) {
            for (const e4 of t4)
              for (const t5 of this._patterns) {
                const n3 = js(e4, t5);
                if (n3)
                  return { element: e4, pattern: t5, match: n3 };
              }
            return null;
          }
          matchAll(...t4) {
            const e4 = [];
            for (const n3 of t4)
              for (const t5 of this._patterns) {
                const i3 = js(n3, t5);
                i3 && e4.push({ element: n3, pattern: t5, match: i3 });
              }
            return e4.length > 0 ? e4 : null;
          }
          getElementName() {
            if (1 !== this._patterns.length)
              return null;
            const t4 = this._patterns[0], e4 = t4.name;
            return "function" == typeof t4 || !e4 || e4 instanceof RegExp ? null : e4;
          }
        }
        function js(t4, e4) {
          if ("function" == typeof e4)
            return e4(t4);
          const n3 = {};
          return e4.name && (n3.name = function(t5, e5) {
            if (t5 instanceof RegExp)
              return !!e5.match(t5);
            return t5 === e5;
          }(e4.name, t4.name), !n3.name) || e4.attributes && (n3.attributes = function(t5, e5) {
            const n4 = new Set(e5.getAttributeKeys());
            Et2(t5) ? (void 0 !== t5.style && _2("matcher-pattern-deprecated-attributes-style-key", t5), void 0 !== t5.class && _2("matcher-pattern-deprecated-attributes-class-key", t5)) : (n4.delete("style"), n4.delete("class"));
            return Hs(t5, n4, (t6) => e5.getAttribute(t6));
          }(e4.attributes, t4), !n3.attributes) || e4.classes && (n3.classes = function(t5, e5) {
            return Hs(t5, e5.getClassNames(), () => {
            });
          }(e4.classes, t4), !n3.classes) || e4.styles && (n3.styles = function(t5, e5) {
            return Hs(t5, e5.getStyleNames(true), (t6) => e5.getStyle(t6));
          }(e4.styles, t4), !n3.styles) ? null : n3;
        }
        function Hs(t4, e4, n3) {
          const i3 = function(t5) {
            if (Array.isArray(t5))
              return t5.map((t6) => Et2(t6) ? (void 0 !== t6.key && void 0 !== t6.value || _2("matcher-pattern-missing-key-or-value", t6), [t6.key, t6.value]) : [t6, true]);
            if (Et2(t5))
              return Object.entries(t5);
            return [[t5, true]];
          }(t4), o3 = Array.from(e4), r3 = [];
          if (i3.forEach(([t5, e5]) => {
            o3.forEach((i4) => {
              (function(t6, e6) {
                return true === t6 || t6 === e6 || t6 instanceof RegExp && e6.match(t6);
              })(t5, i4) && function(t6, e6, n4) {
                if (true === t6)
                  return true;
                const i5 = n4(e6);
                return t6 === i5 || t6 instanceof RegExp && !!String(i5).match(t6);
              }(e5, i4, n3) && r3.push(i4);
            });
          }), i3.length && !(r3.length < i3.length))
            return r3;
        }
        var Us = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Gs = /^\w*$/;
        const Ws = function(t4, e4) {
          if (pt2(t4))
            return false;
          var n3 = typeof t4;
          return !("number" != n3 && "symbol" != n3 && "boolean" != n3 && null != t4 && !Fr(t4)) || (Gs.test(t4) || !Us.test(t4) || null != e4 && t4 in Object(e4));
        };
        function qs(t4, e4) {
          if ("function" != typeof t4 || null != e4 && "function" != typeof e4)
            throw new TypeError("Expected a function");
          var n3 = function() {
            var i3 = arguments, o3 = e4 ? e4.apply(this, i3) : i3[0], r3 = n3.cache;
            if (r3.has(o3))
              return r3.get(o3);
            var s3 = t4.apply(this, i3);
            return n3.cache = r3.set(o3, s3) || r3, s3;
          };
          return n3.cache = new (qs.Cache || Ce2)(), n3;
        }
        qs.Cache = Ce2;
        const $s = qs;
        const Ks = function(t4) {
          var e4 = $s(t4, function(t5) {
            return 500 === n3.size && n3.clear(), t5;
          }), n3 = e4.cache;
          return e4;
        };
        var Zs = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ys = /\\(\\)?/g, Qs = Ks(function(t4) {
          var e4 = [];
          return 46 === t4.charCodeAt(0) && e4.push(""), t4.replace(Zs, function(t5, n3, i3, o3) {
            e4.push(i3 ? o3.replace(Ys, "$1") : n3 || t5);
          }), e4;
        });
        const Js = Qs;
        const Xs = function(t4, e4) {
          for (var n3 = -1, i3 = null == t4 ? 0 : t4.length, o3 = Array(i3); ++n3 < i3; )
            o3[n3] = e4(t4[n3], n3, t4);
          return o3;
        };
        var ta2 = rt2 ? rt2.prototype : void 0, ea2 = ta2 ? ta2.toString : void 0;
        const na = function t4(e4) {
          if ("string" == typeof e4)
            return e4;
          if (pt2(e4))
            return Xs(e4, t4) + "";
          if (Fr(e4))
            return ea2 ? ea2.call(e4) : "";
          var n3 = e4 + "";
          return "0" == n3 && 1 / e4 == -Infinity ? "-0" : n3;
        };
        const ia2 = function(t4) {
          return null == t4 ? "" : na(t4);
        };
        const oa2 = function(t4, e4) {
          return pt2(t4) ? t4 : Ws(t4, e4) ? [t4] : Js(ia2(t4));
        };
        const ra2 = function(t4) {
          var e4 = null == t4 ? 0 : t4.length;
          return e4 ? t4[e4 - 1] : void 0;
        };
        const sa2 = function(t4) {
          if ("string" == typeof t4 || Fr(t4))
            return t4;
          var e4 = t4 + "";
          return "0" == e4 && 1 / t4 == -Infinity ? "-0" : e4;
        };
        const aa2 = function(t4, e4) {
          for (var n3 = 0, i3 = (e4 = oa2(e4, t4)).length; null != t4 && n3 < i3; )
            t4 = t4[sa2(e4[n3++])];
          return n3 && n3 == i3 ? t4 : void 0;
        };
        const ca2 = function(t4, e4, n3) {
          var i3 = -1, o3 = t4.length;
          e4 < 0 && (e4 = -e4 > o3 ? 0 : o3 + e4), (n3 = n3 > o3 ? o3 : n3) < 0 && (n3 += o3), o3 = e4 > n3 ? 0 : n3 - e4 >>> 0, e4 >>>= 0;
          for (var r3 = Array(o3); ++i3 < o3; )
            r3[i3] = t4[i3 + e4];
          return r3;
        };
        const la2 = function(t4, e4) {
          return e4.length < 2 ? t4 : aa2(t4, ca2(e4, 0, -1));
        };
        const da2 = function(t4, e4) {
          return e4 = oa2(e4, t4), null == (t4 = la2(t4, e4)) || delete t4[sa2(ra2(e4))];
        };
        const ha2 = function(t4, e4) {
          return null == t4 || da2(t4, e4);
        };
        const ua2 = function(t4, e4, n3) {
          var i3 = null == t4 ? void 0 : aa2(t4, e4);
          return void 0 === i3 ? n3 : i3;
        };
        const ga = function(t4, e4, n3) {
          (void 0 !== n3 && !St2(t4[e4], n3) || void 0 === n3 && !(e4 in t4)) && De2(t4, e4, n3);
        };
        const ma2 = function(t4) {
          return function(e4, n3, i3) {
            for (var o3 = -1, r3 = Object(e4), s3 = i3(e4), a3 = s3.length; a3--; ) {
              var c3 = s3[t4 ? a3 : ++o3];
              if (false === n3(r3[c3], c3, r3))
                break;
            }
            return e4;
          };
        }();
        const pa2 = function(t4) {
          return ft2(t4) && cn2(t4);
        };
        const fa2 = function(t4, e4) {
          if (("constructor" !== e4 || "function" != typeof t4[e4]) && "__proto__" != e4)
            return t4[e4];
        };
        const ka2 = function(t4) {
          return Ie2(t4, mn(t4));
        };
        const ba = function(t4, e4, n3, i3, o3, r3, s3) {
          var a3 = fa2(t4, n3), c3 = fa2(e4, n3), l3 = s3.get(c3);
          if (l3)
            ga(t4, n3, l3);
          else {
            var d3 = r3 ? r3(a3, c3, n3 + "", t4, e4, s3) : void 0, h3 = void 0 === d3;
            if (h3) {
              var u3 = pt2(c3), g3 = !u3 && je2(c3), m3 = !u3 && !g3 && Xe2(c3);
              d3 = c3, u3 || g3 || m3 ? pt2(a3) ? d3 = a3 : pa2(a3) ? d3 = Cn(a3) : g3 ? (h3 = false, d3 = An(c3, true)) : m3 ? (h3 = false, d3 = si2(c3, true)) : d3 = [] : Et2(c3) || Pe2(c3) ? (d3 = a3, Pe2(a3) ? d3 = ka2(a3) : F2(a3) && !jt2(a3) || (d3 = di2(c3))) : h3 = false;
            }
            h3 && (s3.set(c3, d3), o3(d3, c3, i3, r3, s3), s3.delete(c3)), ga(t4, n3, d3);
          }
        };
        const wa2 = function t4(e4, n3, i3, o3, r3) {
          e4 !== n3 && ma2(n3, function(s3, a3) {
            if (r3 || (r3 = new ye2()), F2(s3))
              ba(e4, n3, a3, i3, t4, o3, r3);
            else {
              var c3 = o3 ? o3(fa2(e4, a3), s3, a3 + "", e4, n3, r3) : void 0;
              void 0 === c3 && (c3 = s3), ga(e4, a3, c3);
            }
          }, mn);
        };
        const Aa2 = function(t4) {
          return t4;
        };
        const Ca2 = function(t4, e4, n3) {
          switch (n3.length) {
            case 0:
              return t4.call(e4);
            case 1:
              return t4.call(e4, n3[0]);
            case 2:
              return t4.call(e4, n3[0], n3[1]);
            case 3:
              return t4.call(e4, n3[0], n3[1], n3[2]);
          }
          return t4.apply(e4, n3);
        };
        var _a = Math.max;
        const va2 = function(t4, e4, n3) {
          return e4 = _a(void 0 === e4 ? t4.length - 1 : e4, 0), function() {
            for (var i3 = arguments, o3 = -1, r3 = _a(i3.length - e4, 0), s3 = Array(r3); ++o3 < r3; )
              s3[o3] = i3[e4 + o3];
            o3 = -1;
            for (var a3 = Array(e4 + 1); ++o3 < e4; )
              a3[o3] = i3[o3];
            return a3[e4] = n3(s3), Ca2(t4, this, a3);
          };
        };
        const ya2 = function(t4) {
          return function() {
            return t4;
          };
        };
        const xa = Ee2 ? function(t4, e4) {
          return Ee2(t4, "toString", { configurable: true, enumerable: false, value: ya2(e4), writable: true });
        } : Aa2;
        var Ea2 = Date.now;
        const Da2 = function(t4) {
          var e4 = 0, n3 = 0;
          return function() {
            var i3 = Ea2(), o3 = 16 - (i3 - n3);
            if (n3 = i3, o3 > 0) {
              if (++e4 >= 800)
                return arguments[0];
            } else
              e4 = 0;
            return t4.apply(void 0, arguments);
          };
        };
        const Sa2 = Da2(xa);
        const Ta2 = function(t4, e4) {
          return Sa2(va2(t4, e4, Aa2), t4 + "");
        };
        const Ia2 = function(t4, e4, n3) {
          if (!F2(n3))
            return false;
          var i3 = typeof e4;
          return !!("number" == i3 ? cn2(n3) && Ue2(e4, n3.length) : "string" == i3 && e4 in n3) && St2(n3[e4], t4);
        };
        const Ba2 = function(t4) {
          return Ta2(function(e4, n3) {
            var i3 = -1, o3 = n3.length, r3 = o3 > 1 ? n3[o3 - 1] : void 0, s3 = o3 > 2 ? n3[2] : void 0;
            for (r3 = t4.length > 3 && "function" == typeof r3 ? (o3--, r3) : void 0, s3 && Ia2(n3[0], n3[1], s3) && (r3 = o3 < 3 ? void 0 : r3, o3 = 1), e4 = Object(e4); ++i3 < o3; ) {
              var a3 = n3[i3];
              a3 && t4(e4, a3, i3, r3);
            }
            return e4;
          });
        };
        const Ma2 = Ba2(function(t4, e4, n3) {
          wa2(t4, e4, n3);
        });
        const Na2 = function(t4, e4, n3, i3) {
          if (!F2(t4))
            return t4;
          for (var o3 = -1, r3 = (e4 = oa2(e4, t4)).length, s3 = r3 - 1, a3 = t4; null != a3 && ++o3 < r3; ) {
            var c3 = sa2(e4[o3]), l3 = n3;
            if ("__proto__" === c3 || "constructor" === c3 || "prototype" === c3)
              return t4;
            if (o3 != s3) {
              var d3 = a3[c3];
              void 0 === (l3 = i3 ? i3(d3, c3, a3) : void 0) && (l3 = F2(d3) ? d3 : Ue2(e4[o3 + 1]) ? [] : {});
            }
            Te2(a3, c3, l3), a3 = a3[c3];
          }
          return t4;
        };
        const La2 = function(t4, e4, n3) {
          return null == t4 ? t4 : Na2(t4, e4, n3);
        };
        class za2 {
          constructor(t4) {
            this._styles = {}, this._styleProcessor = t4;
          }
          get isEmpty() {
            return !Object.entries(this._styles).length;
          }
          get size() {
            return this.isEmpty ? 0 : this.getStyleNames().length;
          }
          setTo(t4) {
            this.clear();
            const e4 = function(t5) {
              let e5 = null, n3 = 0, i3 = 0, o3 = null;
              const r3 = /* @__PURE__ */ new Map();
              if ("" === t5)
                return r3;
              ";" != t5.charAt(t5.length - 1) && (t5 += ";");
              for (let s3 = 0; s3 < t5.length; s3++) {
                const a3 = t5.charAt(s3);
                if (null === e5)
                  switch (a3) {
                    case ":":
                      o3 || (o3 = t5.substr(n3, s3 - n3), i3 = s3 + 1);
                      break;
                    case '"':
                    case "'":
                      e5 = a3;
                      break;
                    case ";": {
                      const e6 = t5.substr(i3, s3 - i3);
                      o3 && r3.set(o3.trim(), e6.trim()), o3 = null, n3 = s3 + 1;
                      break;
                    }
                  }
                else
                  a3 === e5 && (e5 = null);
              }
              return r3;
            }(t4);
            for (const [t5, n3] of e4)
              this._styleProcessor.toNormalizedForm(t5, n3, this._styles);
          }
          has(t4) {
            if (this.isEmpty)
              return false;
            const e4 = this._styleProcessor.getReducedForm(t4, this._styles).find(([e5]) => e5 === t4);
            return Array.isArray(e4);
          }
          set(t4, e4) {
            if (F2(t4))
              for (const [e5, n3] of Object.entries(t4))
                this._styleProcessor.toNormalizedForm(e5, n3, this._styles);
            else
              this._styleProcessor.toNormalizedForm(t4, e4, this._styles);
          }
          remove(t4) {
            const e4 = Ra2(t4);
            ha2(this._styles, e4), delete this._styles[t4], this._cleanEmptyObjectsOnPath(e4);
          }
          getNormalized(t4) {
            return this._styleProcessor.getNormalized(t4, this._styles);
          }
          toString() {
            return this.isEmpty ? "" : this._getStylesEntries().map((t4) => t4.join(":")).sort().join(";") + ";";
          }
          getAsString(t4) {
            if (this.isEmpty)
              return;
            if (this._styles[t4] && !F2(this._styles[t4]))
              return this._styles[t4];
            const e4 = this._styleProcessor.getReducedForm(t4, this._styles).find(([e5]) => e5 === t4);
            return Array.isArray(e4) ? e4[1] : void 0;
          }
          getStyleNames(t4 = false) {
            if (this.isEmpty)
              return [];
            if (t4)
              return this._styleProcessor.getStyleNames(this._styles);
            return this._getStylesEntries().map(([t5]) => t5);
          }
          clear() {
            this._styles = {};
          }
          _getStylesEntries() {
            const t4 = [], e4 = Object.keys(this._styles);
            for (const n3 of e4)
              t4.push(...this._styleProcessor.getReducedForm(n3, this._styles));
            return t4;
          }
          _cleanEmptyObjectsOnPath(t4) {
            const e4 = t4.split(".");
            if (!(e4.length > 1))
              return;
            const n3 = e4.splice(0, e4.length - 1).join("."), i3 = ua2(this._styles, n3);
            if (!i3)
              return;
            !Object.keys(i3).length && this.remove(n3);
          }
        }
        class Pa2 {
          constructor() {
            this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
          }
          toNormalizedForm(t4, e4, n3) {
            if (F2(e4))
              Oa2(n3, Ra2(t4), e4);
            else if (this._normalizers.has(t4)) {
              const i3 = this._normalizers.get(t4), { path: o3, value: r3 } = i3(e4);
              Oa2(n3, o3, r3);
            } else
              Oa2(n3, t4, e4);
          }
          getNormalized(t4, e4) {
            if (!t4)
              return Ma2({}, e4);
            if (void 0 !== e4[t4])
              return e4[t4];
            if (this._extractors.has(t4)) {
              const n3 = this._extractors.get(t4);
              if ("string" == typeof n3)
                return ua2(e4, n3);
              const i3 = n3(t4, e4);
              if (i3)
                return i3;
            }
            return ua2(e4, Ra2(t4));
          }
          getReducedForm(t4, e4) {
            const n3 = this.getNormalized(t4, e4);
            if (void 0 === n3)
              return [];
            if (this._reducers.has(t4)) {
              return this._reducers.get(t4)(n3);
            }
            return [[t4, n3]];
          }
          getStyleNames(t4) {
            const e4 = Array.from(this._consumables.keys()).filter((e5) => {
              const n4 = this.getNormalized(e5, t4);
              return n4 && "object" == typeof n4 ? Object.keys(n4).length : n4;
            }), n3 = /* @__PURE__ */ new Set([...e4, ...Object.keys(t4)]);
            return Array.from(n3);
          }
          getRelatedStyles(t4) {
            return this._consumables.get(t4) || [];
          }
          setNormalizer(t4, e4) {
            this._normalizers.set(t4, e4);
          }
          setExtractor(t4, e4) {
            this._extractors.set(t4, e4);
          }
          setReducer(t4, e4) {
            this._reducers.set(t4, e4);
          }
          setStyleRelation(t4, e4) {
            this._mapStyleNames(t4, e4);
            for (const n3 of e4)
              this._mapStyleNames(n3, [t4]);
          }
          _mapStyleNames(t4, e4) {
            this._consumables.has(t4) || this._consumables.set(t4, []), this._consumables.get(t4).push(...e4);
          }
        }
        function Ra2(t4) {
          return t4.replace("-", ".");
        }
        function Oa2(t4, e4, n3) {
          let i3 = n3;
          F2(n3) && (i3 = Ma2({}, ua2(t4, e4), n3)), La2(t4, e4, i3);
        }
        class Fa2 extends Rs {
          constructor(t4, e4, n3, i3) {
            if (super(t4), this._unsafeAttributesToRender = [], this._customProperties = /* @__PURE__ */ new Map(), this.name = e4, this._attrs = function(t5) {
              const e5 = Bo2(t5);
              for (const [t6, n4] of e5)
                null === n4 ? e5.delete(t6) : "string" != typeof n4 && e5.set(t6, String(n4));
              return e5;
            }(n3), this._children = [], i3 && this._insertChild(0, i3), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
              const t5 = this._attrs.get("class");
              Va2(this._classes, t5), this._attrs.delete("class");
            }
            this._styles = new za2(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"));
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return 0 === this._children.length;
          }
          getChild(t4) {
            return this._children[t4];
          }
          getChildIndex(t4) {
            return this._children.indexOf(t4);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          *getAttributeKeys() {
            this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
          }
          *getAttributes() {
            yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
          }
          getAttribute(t4) {
            if ("class" == t4)
              return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
            if ("style" == t4) {
              const t5 = this._styles.toString();
              return "" == t5 ? void 0 : t5;
            }
            return this._attrs.get(t4);
          }
          hasAttribute(t4) {
            return "class" == t4 ? this._classes.size > 0 : "style" == t4 ? !this._styles.isEmpty : this._attrs.has(t4);
          }
          isSimilar(t4) {
            if (!(t4 instanceof Fa2))
              return false;
            if (this === t4)
              return true;
            if (this.name != t4.name)
              return false;
            if (this._attrs.size !== t4._attrs.size || this._classes.size !== t4._classes.size || this._styles.size !== t4._styles.size)
              return false;
            for (const [e4, n3] of this._attrs)
              if (!t4._attrs.has(e4) || t4._attrs.get(e4) !== n3)
                return false;
            for (const e4 of this._classes)
              if (!t4._classes.has(e4))
                return false;
            for (const e4 of this._styles.getStyleNames())
              if (!t4._styles.has(e4) || t4._styles.getAsString(e4) !== this._styles.getAsString(e4))
                return false;
            return true;
          }
          hasClass(...t4) {
            for (const e4 of t4)
              if (!this._classes.has(e4))
                return false;
            return true;
          }
          getClassNames() {
            return this._classes.keys();
          }
          getStyle(t4) {
            return this._styles.getAsString(t4);
          }
          getNormalizedStyle(t4) {
            return this._styles.getNormalized(t4);
          }
          getStyleNames(t4) {
            return this._styles.getStyleNames(t4);
          }
          hasStyle(...t4) {
            for (const e4 of t4)
              if (!this._styles.has(e4))
                return false;
            return true;
          }
          findAncestor(...t4) {
            const e4 = new Vs(...t4);
            let n3 = this.parent;
            for (; n3 && !n3.is("documentFragment"); ) {
              if (e4.match(n3))
                return n3;
              n3 = n3.parent;
            }
            return null;
          }
          getCustomProperty(t4) {
            return this._customProperties.get(t4);
          }
          *getCustomProperties() {
            yield* this._customProperties.entries();
          }
          getIdentity() {
            const t4 = Array.from(this._classes).sort().join(","), e4 = this._styles.toString(), n3 = Array.from(this._attrs).map((t5) => `${t5[0]}="${t5[1]}"`).sort().join(" ");
            return this.name + ("" == t4 ? "" : ` class="${t4}"`) + (e4 ? ` style="${e4}"` : "") + ("" == n3 ? "" : ` ${n3}`);
          }
          shouldRenderUnsafeAttribute(t4) {
            return this._unsafeAttributesToRender.includes(t4);
          }
          _clone(t4 = false) {
            const e4 = [];
            if (t4)
              for (const n4 of this.getChildren())
                e4.push(n4._clone(t4));
            const n3 = new this.constructor(this.document, this.name, this._attrs, e4);
            return n3._classes = new Set(this._classes), n3._styles.set(this._styles.getNormalized()), n3._customProperties = new Map(this._customProperties), n3.getFillerOffset = this.getFillerOffset, n3._unsafeAttributesToRender = this._unsafeAttributesToRender, n3;
          }
          _appendChild(t4) {
            return this._insertChild(this.childCount, t4);
          }
          _insertChild(t4, e4) {
            this._fireChange("children", this);
            let n3 = 0;
            const i3 = function(t5, e5) {
              if ("string" == typeof e5)
                return [new Os(t5, e5)];
              et2(e5) || (e5 = [e5]);
              return Array.from(e5).map((e6) => "string" == typeof e6 ? new Os(t5, e6) : e6 instanceof Fs ? new Os(t5, e6.data) : e6);
            }(this.document, e4);
            for (const e5 of i3)
              null !== e5.parent && e5._remove(), e5.parent = this, e5.document = this.document, this._children.splice(t4, 0, e5), t4++, n3++;
            return n3;
          }
          _removeChildren(t4, e4 = 1) {
            this._fireChange("children", this);
            for (let n3 = t4; n3 < t4 + e4; n3++)
              this._children[n3].parent = null;
            return this._children.splice(t4, e4);
          }
          _setAttribute(t4, e4) {
            const n3 = String(e4);
            this._fireChange("attributes", this), "class" == t4 ? Va2(this._classes, n3) : "style" == t4 ? this._styles.setTo(n3) : this._attrs.set(t4, n3);
          }
          _removeAttribute(t4) {
            return this._fireChange("attributes", this), "class" == t4 ? this._classes.size > 0 && (this._classes.clear(), true) : "style" == t4 ? !this._styles.isEmpty && (this._styles.clear(), true) : this._attrs.delete(t4);
          }
          _addClass(t4) {
            this._fireChange("attributes", this);
            for (const e4 of yo2(t4))
              this._classes.add(e4);
          }
          _removeClass(t4) {
            this._fireChange("attributes", this);
            for (const e4 of yo2(t4))
              this._classes.delete(e4);
          }
          _setStyle(t4, e4) {
            this._fireChange("attributes", this), "string" != typeof t4 ? this._styles.set(t4) : this._styles.set(t4, e4);
          }
          _removeStyle(t4) {
            this._fireChange("attributes", this);
            for (const e4 of yo2(t4))
              this._styles.remove(e4);
          }
          _setCustomProperty(t4, e4) {
            this._customProperties.set(t4, e4);
          }
          _removeCustomProperty(t4) {
            return this._customProperties.delete(t4);
          }
        }
        function Va2(t4, e4) {
          const n3 = e4.split(/\s+/);
          t4.clear(), n3.forEach((e5) => t4.add(e5));
        }
        Fa2.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("element" === t4 || "view:element" === t4) : "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
        };
        class ja2 extends Fa2 {
          constructor(t4, e4, n3, i3) {
            super(t4, e4, n3, i3), this.getFillerOffset = Ha2;
          }
        }
        function Ha2() {
          const t4 = [...this.getChildren()], e4 = t4[this.childCount - 1];
          if (e4 && e4.is("element", "br"))
            return this.childCount;
          for (const e5 of t4)
            if (!e5.is("uiElement"))
              return null;
          return this.childCount;
        }
        ja2.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4) : "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
        };
        class Ua2 extends q2(ja2) {
          constructor(t4, e4, n3, i3) {
            super(t4, e4, n3, i3), this.set("isReadOnly", false), this.set("isFocused", false), this.set("placeholder", void 0), this.bind("isReadOnly").to(t4), this.bind("isFocused").to(t4, "isFocused", (e5) => e5 && t4.selection.editableElement == this), this.listenTo(t4.selection, "change", () => {
              this.isFocused = t4.isFocused && t4.selection.editableElement == this;
            });
          }
          destroy() {
            this.stopListening();
          }
        }
        Ua2.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("editableElement" === t4 || "view:editableElement" === t4 || "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4) : "editableElement" === t4 || "view:editableElement" === t4 || "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
        };
        const Ga2 = Symbol("rootName");
        class Wa2 extends Ua2 {
          constructor(t4, e4) {
            super(t4, e4), this.rootName = "main";
          }
          get rootName() {
            return this.getCustomProperty(Ga2);
          }
          set rootName(t4) {
            this._setCustomProperty(Ga2, t4);
          }
          set _name(t4) {
            this.name = t4;
          }
        }
        Wa2.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("rootElement" === t4 || "view:rootElement" === t4 || "editableElement" === t4 || "view:editableElement" === t4 || "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4) : "rootElement" === t4 || "view:rootElement" === t4 || "editableElement" === t4 || "view:editableElement" === t4 || "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
        };
        class qa2 {
          constructor(t4 = {}) {
            if (!t4.boundaries && !t4.startPosition)
              throw new C2("view-tree-walker-no-start-position", null);
            if (t4.direction && "forward" != t4.direction && "backward" != t4.direction)
              throw new C2("view-tree-walker-unknown-direction", t4.startPosition, { direction: t4.direction });
            this.boundaries = t4.boundaries || null, t4.startPosition ? this._position = $a._createAt(t4.startPosition) : this._position = $a._createAt(t4.boundaries["backward" == t4.direction ? "end" : "start"]), this.direction = t4.direction || "forward", this.singleCharacters = !!t4.singleCharacters, this.shallow = !!t4.shallow, this.ignoreElementEnd = !!t4.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
          }
          [Symbol.iterator]() {
            return this;
          }
          get position() {
            return this._position;
          }
          skip(t4) {
            let e4, n3;
            do {
              n3 = this.position, e4 = this.next();
            } while (!e4.done && t4(e4.value));
            e4.done || (this._position = n3);
          }
          next() {
            return "forward" == this.direction ? this._next() : this._previous();
          }
          _next() {
            let t4 = this.position.clone();
            const e4 = this.position, n3 = t4.parent;
            if (null === n3.parent && t4.offset === n3.childCount)
              return { done: true, value: void 0 };
            if (n3 === this._boundaryEndParent && t4.offset == this.boundaries.end.offset)
              return { done: true, value: void 0 };
            let i3;
            if (n3 instanceof Os) {
              if (t4.isAtEnd)
                return this._position = $a._createAfter(n3), this._next();
              i3 = n3.data[t4.offset];
            } else
              i3 = n3.getChild(t4.offset);
            if (i3 instanceof Fa2) {
              if (this.shallow) {
                if (this.boundaries && this.boundaries.end.isBefore(t4))
                  return { done: true, value: void 0 };
                t4.offset++;
              } else
                t4 = new $a(i3, 0);
              return this._position = t4, this._formatReturnValue("elementStart", i3, e4, t4, 1);
            }
            if (i3 instanceof Os) {
              if (this.singleCharacters)
                return t4 = new $a(i3, 0), this._position = t4, this._next();
              let n4, o3 = i3.data.length;
              return i3 == this._boundaryEndParent ? (o3 = this.boundaries.end.offset, n4 = new Fs(i3, 0, o3), t4 = $a._createAfter(n4)) : (n4 = new Fs(i3, 0, i3.data.length), t4.offset++), this._position = t4, this._formatReturnValue("text", n4, e4, t4, o3);
            }
            if ("string" == typeof i3) {
              let i4;
              if (this.singleCharacters)
                i4 = 1;
              else {
                i4 = (n3 === this._boundaryEndParent ? this.boundaries.end.offset : n3.data.length) - t4.offset;
              }
              const o3 = new Fs(n3, t4.offset, i4);
              return t4.offset += i4, this._position = t4, this._formatReturnValue("text", o3, e4, t4, i4);
            }
            return t4 = $a._createAfter(n3), this._position = t4, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n3, e4, t4);
          }
          _previous() {
            let t4 = this.position.clone();
            const e4 = this.position, n3 = t4.parent;
            if (null === n3.parent && 0 === t4.offset)
              return { done: true, value: void 0 };
            if (n3 == this._boundaryStartParent && t4.offset == this.boundaries.start.offset)
              return { done: true, value: void 0 };
            let i3;
            if (n3 instanceof Os) {
              if (t4.isAtStart)
                return this._position = $a._createBefore(n3), this._previous();
              i3 = n3.data[t4.offset - 1];
            } else
              i3 = n3.getChild(t4.offset - 1);
            if (i3 instanceof Fa2)
              return this.shallow ? (t4.offset--, this._position = t4, this._formatReturnValue("elementStart", i3, e4, t4, 1)) : (t4 = new $a(i3, i3.childCount), this._position = t4, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", i3, e4, t4));
            if (i3 instanceof Os) {
              if (this.singleCharacters)
                return t4 = new $a(i3, i3.data.length), this._position = t4, this._previous();
              let n4, o3 = i3.data.length;
              if (i3 == this._boundaryStartParent) {
                const e5 = this.boundaries.start.offset;
                n4 = new Fs(i3, e5, i3.data.length - e5), o3 = n4.data.length, t4 = $a._createBefore(n4);
              } else
                n4 = new Fs(i3, 0, i3.data.length), t4.offset--;
              return this._position = t4, this._formatReturnValue("text", n4, e4, t4, o3);
            }
            if ("string" == typeof i3) {
              let i4;
              if (this.singleCharacters)
                i4 = 1;
              else {
                const e5 = n3 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
                i4 = t4.offset - e5;
              }
              t4.offset -= i4;
              const o3 = new Fs(n3, t4.offset, i4);
              return this._position = t4, this._formatReturnValue("text", o3, e4, t4, i4);
            }
            return t4 = $a._createBefore(n3), this._position = t4, this._formatReturnValue("elementStart", n3, e4, t4, 1);
          }
          _formatReturnValue(t4, e4, n3, i3, o3) {
            return e4 instanceof Fs && (e4.offsetInText + e4.data.length == e4.textNode.data.length && ("forward" != this.direction || this.boundaries && this.boundaries.end.isEqual(this.position) ? n3 = $a._createAfter(e4.textNode) : (i3 = $a._createAfter(e4.textNode), this._position = i3)), 0 === e4.offsetInText && ("backward" != this.direction || this.boundaries && this.boundaries.start.isEqual(this.position) ? n3 = $a._createBefore(e4.textNode) : (i3 = $a._createBefore(e4.textNode), this._position = i3))), { done: false, value: { type: t4, item: e4, previousPosition: n3, nextPosition: i3, length: o3 } };
          }
        }
        class $a extends zs {
          constructor(t4, e4) {
            super(), this.parent = t4, this.offset = e4;
          }
          get nodeAfter() {
            return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
          }
          get nodeBefore() {
            return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
          }
          get isAtStart() {
            return 0 === this.offset;
          }
          get isAtEnd() {
            const t4 = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
            return this.offset === t4;
          }
          get root() {
            return this.parent.root;
          }
          get editableElement() {
            let t4 = this.parent;
            for (; !(t4 instanceof Ua2); ) {
              if (!t4.parent)
                return null;
              t4 = t4.parent;
            }
            return t4;
          }
          getShiftedBy(t4) {
            const e4 = $a._createAt(this), n3 = e4.offset + t4;
            return e4.offset = n3 < 0 ? 0 : n3, e4;
          }
          getLastMatchingPosition(t4, e4 = {}) {
            e4.startPosition = this;
            const n3 = new qa2(e4);
            return n3.skip(t4), n3.position;
          }
          getAncestors() {
            return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: true });
          }
          getCommonAncestor(t4) {
            const e4 = this.getAncestors(), n3 = t4.getAncestors();
            let i3 = 0;
            for (; e4[i3] == n3[i3] && e4[i3]; )
              i3++;
            return 0 === i3 ? null : e4[i3 - 1];
          }
          isEqual(t4) {
            return this.parent == t4.parent && this.offset == t4.offset;
          }
          isBefore(t4) {
            return "before" == this.compareWith(t4);
          }
          isAfter(t4) {
            return "after" == this.compareWith(t4);
          }
          compareWith(t4) {
            if (this.root !== t4.root)
              return "different";
            if (this.isEqual(t4))
              return "same";
            const e4 = this.parent.is("node") ? this.parent.getPath() : [], n3 = t4.parent.is("node") ? t4.parent.getPath() : [];
            e4.push(this.offset), n3.push(t4.offset);
            const i3 = tt2(e4, n3);
            switch (i3) {
              case "prefix":
                return "before";
              case "extension":
                return "after";
              default:
                return e4[i3] < n3[i3] ? "before" : "after";
            }
          }
          getWalker(t4 = {}) {
            return t4.startPosition = this, new qa2(t4);
          }
          clone() {
            return new $a(this.parent, this.offset);
          }
          static _createAt(t4, e4) {
            if (t4 instanceof $a)
              return new this(t4.parent, t4.offset);
            {
              const n3 = t4;
              if ("end" == e4)
                e4 = n3.is("$text") ? n3.data.length : n3.childCount;
              else {
                if ("before" == e4)
                  return this._createBefore(n3);
                if ("after" == e4)
                  return this._createAfter(n3);
                if (0 !== e4 && !e4)
                  throw new C2("view-createpositionat-offset-required", n3);
              }
              return new $a(n3, e4);
            }
          }
          static _createAfter(t4) {
            if (t4.is("$textProxy"))
              return new $a(t4.textNode, t4.offsetInText + t4.data.length);
            if (!t4.parent)
              throw new C2("view-position-after-root", t4, { root: t4 });
            return new $a(t4.parent, t4.index + 1);
          }
          static _createBefore(t4) {
            if (t4.is("$textProxy"))
              return new $a(t4.textNode, t4.offsetInText);
            if (!t4.parent)
              throw new C2("view-position-before-root", t4, { root: t4 });
            return new $a(t4.parent, t4.index);
          }
        }
        $a.prototype.is = function(t4) {
          return "position" === t4 || "view:position" === t4;
        };
        class Ka2 extends zs {
          constructor(t4, e4 = null) {
            super(), this.start = t4.clone(), this.end = e4 ? e4.clone() : t4.clone();
          }
          *[Symbol.iterator]() {
            yield* new qa2({ boundaries: this, ignoreElementEnd: true });
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return this.start.parent === this.end.parent;
          }
          get root() {
            return this.start.root;
          }
          getEnlarged() {
            let t4 = this.start.getLastMatchingPosition(Za2, { direction: "backward" }), e4 = this.end.getLastMatchingPosition(Za2);
            return t4.parent.is("$text") && t4.isAtStart && (t4 = $a._createBefore(t4.parent)), e4.parent.is("$text") && e4.isAtEnd && (e4 = $a._createAfter(e4.parent)), new Ka2(t4, e4);
          }
          getTrimmed() {
            let t4 = this.start.getLastMatchingPosition(Za2);
            if (t4.isAfter(this.end) || t4.isEqual(this.end))
              return new Ka2(t4, t4);
            let e4 = this.end.getLastMatchingPosition(Za2, { direction: "backward" });
            const n3 = t4.nodeAfter, i3 = e4.nodeBefore;
            return n3 && n3.is("$text") && (t4 = new $a(n3, 0)), i3 && i3.is("$text") && (e4 = new $a(i3, i3.data.length)), new Ka2(t4, e4);
          }
          isEqual(t4) {
            return this == t4 || this.start.isEqual(t4.start) && this.end.isEqual(t4.end);
          }
          containsPosition(t4) {
            return t4.isAfter(this.start) && t4.isBefore(this.end);
          }
          containsRange(t4, e4 = false) {
            t4.isCollapsed && (e4 = false);
            const n3 = this.containsPosition(t4.start) || e4 && this.start.isEqual(t4.start), i3 = this.containsPosition(t4.end) || e4 && this.end.isEqual(t4.end);
            return n3 && i3;
          }
          getDifference(t4) {
            const e4 = [];
            return this.isIntersecting(t4) ? (this.containsPosition(t4.start) && e4.push(new Ka2(this.start, t4.start)), this.containsPosition(t4.end) && e4.push(new Ka2(t4.end, this.end))) : e4.push(this.clone()), e4;
          }
          getIntersection(t4) {
            if (this.isIntersecting(t4)) {
              let e4 = this.start, n3 = this.end;
              return this.containsPosition(t4.start) && (e4 = t4.start), this.containsPosition(t4.end) && (n3 = t4.end), new Ka2(e4, n3);
            }
            return null;
          }
          getWalker(t4 = {}) {
            return t4.boundaries = this, new qa2(t4);
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed)
              return null;
            let t4 = this.start.nodeAfter, e4 = this.end.nodeBefore;
            return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (t4 = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (e4 = this.end.parent.previousSibling), t4 && t4.is("element") && t4 === e4 ? t4 : null;
          }
          clone() {
            return new Ka2(this.start, this.end);
          }
          *getItems(t4 = {}) {
            t4.boundaries = this, t4.ignoreElementEnd = true;
            const e4 = new qa2(t4);
            for (const t5 of e4)
              yield t5.item;
          }
          *getPositions(t4 = {}) {
            t4.boundaries = this;
            const e4 = new qa2(t4);
            yield e4.position;
            for (const t5 of e4)
              yield t5.nextPosition;
          }
          isIntersecting(t4) {
            return this.start.isBefore(t4.end) && this.end.isAfter(t4.start);
          }
          static _createFromParentsAndOffsets(t4, e4, n3, i3) {
            return new this(new $a(t4, e4), new $a(n3, i3));
          }
          static _createFromPositionAndShift(t4, e4) {
            const n3 = t4, i3 = t4.getShiftedBy(e4);
            return e4 > 0 ? new this(n3, i3) : new this(i3, n3);
          }
          static _createIn(t4) {
            return this._createFromParentsAndOffsets(t4, 0, t4, t4.childCount);
          }
          static _createOn(t4) {
            const e4 = t4.is("$textProxy") ? t4.offsetSize : 1;
            return this._createFromPositionAndShift($a._createBefore(t4), e4);
          }
        }
        function Za2(t4) {
          return !(!t4.item.is("attributeElement") && !t4.item.is("uiElement"));
        }
        Ka2.prototype.is = function(t4) {
          return "range" === t4 || "view:range" === t4;
        };
        class Ya2 extends B2(zs) {
          constructor(...t4) {
            super(), this._ranges = [], this._lastRangeBackward = false, this._isFake = false, this._fakeSelectionLabel = "", t4.length && this.setTo(...t4);
          }
          get isFake() {
            return this._isFake;
          }
          get fakeSelectionLabel() {
            return this._fakeSelectionLabel;
          }
          get anchor() {
            if (!this._ranges.length)
              return null;
            const t4 = this._ranges[this._ranges.length - 1];
            return (this._lastRangeBackward ? t4.end : t4.start).clone();
          }
          get focus() {
            if (!this._ranges.length)
              return null;
            const t4 = this._ranges[this._ranges.length - 1];
            return (this._lastRangeBackward ? t4.start : t4.end).clone();
          }
          get isCollapsed() {
            return 1 === this.rangeCount && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          get editableElement() {
            return this.anchor ? this.anchor.editableElement : null;
          }
          *getRanges() {
            for (const t4 of this._ranges)
              yield t4.clone();
          }
          getFirstRange() {
            let t4 = null;
            for (const e4 of this._ranges)
              t4 && !e4.start.isBefore(t4.start) || (t4 = e4);
            return t4 ? t4.clone() : null;
          }
          getLastRange() {
            let t4 = null;
            for (const e4 of this._ranges)
              t4 && !e4.end.isAfter(t4.end) || (t4 = e4);
            return t4 ? t4.clone() : null;
          }
          getFirstPosition() {
            const t4 = this.getFirstRange();
            return t4 ? t4.start.clone() : null;
          }
          getLastPosition() {
            const t4 = this.getLastRange();
            return t4 ? t4.end.clone() : null;
          }
          isEqual(t4) {
            if (this.isFake != t4.isFake)
              return false;
            if (this.isFake && this.fakeSelectionLabel != t4.fakeSelectionLabel)
              return false;
            if (this.rangeCount != t4.rangeCount)
              return false;
            if (0 === this.rangeCount)
              return true;
            if (!this.anchor.isEqual(t4.anchor) || !this.focus.isEqual(t4.focus))
              return false;
            for (const e4 of this._ranges) {
              let n3 = false;
              for (const i3 of t4._ranges)
                if (e4.isEqual(i3)) {
                  n3 = true;
                  break;
                }
              if (!n3)
                return false;
            }
            return true;
          }
          isSimilar(t4) {
            if (this.isBackward != t4.isBackward)
              return false;
            const e4 = X2(this.getRanges());
            if (e4 != X2(t4.getRanges()))
              return false;
            if (0 == e4)
              return true;
            for (let e5 of this.getRanges()) {
              e5 = e5.getTrimmed();
              let n3 = false;
              for (let i3 of t4.getRanges())
                if (i3 = i3.getTrimmed(), e5.start.isEqual(i3.start) && e5.end.isEqual(i3.end)) {
                  n3 = true;
                  break;
                }
              if (!n3)
                return false;
            }
            return true;
          }
          getSelectedElement() {
            return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
          }
          setTo(...t4) {
            let [e4, n3, i3] = t4;
            if ("object" == typeof n3 && (i3 = n3, n3 = void 0), null === e4)
              this._setRanges([]), this._setFakeOptions(i3);
            else if (e4 instanceof Ya2 || e4 instanceof Qa2)
              this._setRanges(e4.getRanges(), e4.isBackward), this._setFakeOptions({ fake: e4.isFake, label: e4.fakeSelectionLabel });
            else if (e4 instanceof Ka2)
              this._setRanges([e4], i3 && i3.backward), this._setFakeOptions(i3);
            else if (e4 instanceof $a)
              this._setRanges([new Ka2(e4)]), this._setFakeOptions(i3);
            else if (e4 instanceof Rs) {
              const t5 = !!i3 && !!i3.backward;
              let o3;
              if (void 0 === n3)
                throw new C2("view-selection-setto-required-second-parameter", this);
              o3 = "in" == n3 ? Ka2._createIn(e4) : "on" == n3 ? Ka2._createOn(e4) : new Ka2($a._createAt(e4, n3)), this._setRanges([o3], t5), this._setFakeOptions(i3);
            } else {
              if (!et2(e4))
                throw new C2("view-selection-setto-not-selectable", this);
              this._setRanges(e4, i3 && i3.backward), this._setFakeOptions(i3);
            }
            this.fire("change");
          }
          setFocus(t4, e4) {
            if (null === this.anchor)
              throw new C2("view-selection-setfocus-no-ranges", this);
            const n3 = $a._createAt(t4, e4);
            if ("same" == n3.compareWith(this.focus))
              return;
            const i3 = this.anchor;
            this._ranges.pop(), "before" == n3.compareWith(i3) ? this._addRange(new Ka2(n3, i3), true) : this._addRange(new Ka2(i3, n3)), this.fire("change");
          }
          _setRanges(t4, e4 = false) {
            t4 = Array.from(t4), this._ranges = [];
            for (const e5 of t4)
              this._addRange(e5);
            this._lastRangeBackward = !!e4;
          }
          _setFakeOptions(t4 = {}) {
            this._isFake = !!t4.fake, this._fakeSelectionLabel = t4.fake && t4.label || "";
          }
          _addRange(t4, e4 = false) {
            if (!(t4 instanceof Ka2))
              throw new C2("view-selection-add-range-not-range", this);
            this._pushRange(t4), this._lastRangeBackward = !!e4;
          }
          _pushRange(t4) {
            for (const e4 of this._ranges)
              if (t4.isIntersecting(e4))
                throw new C2("view-selection-range-intersects", this, { addedRange: t4, intersectingRange: e4 });
            this._ranges.push(new Ka2(t4.start, t4.end));
          }
        }
        Ya2.prototype.is = function(t4) {
          return "selection" === t4 || "view:selection" === t4;
        };
        class Qa2 extends B2(zs) {
          constructor(...t4) {
            super(), this._selection = new Ya2(), this._selection.delegate("change").to(this), t4.length && this._selection.setTo(...t4);
          }
          get isFake() {
            return this._selection.isFake;
          }
          get fakeSelectionLabel() {
            return this._selection.fakeSelectionLabel;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get editableElement() {
            return this._selection.editableElement;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          *getRanges() {
            yield* this._selection.getRanges();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          isEqual(t4) {
            return this._selection.isEqual(t4);
          }
          isSimilar(t4) {
            return this._selection.isSimilar(t4);
          }
          _setTo(...t4) {
            this._selection.setTo(...t4);
          }
          _setFocus(t4, e4) {
            this._selection.setFocus(t4, e4);
          }
        }
        Qa2.prototype.is = function(t4) {
          return "selection" === t4 || "documentSelection" == t4 || "view:selection" == t4 || "view:documentSelection" == t4;
        };
        class Ja2 extends p2 {
          constructor(t4, e4, n3) {
            super(t4, e4), this.startRange = n3, this._eventPhase = "none", this._currentTarget = null;
          }
          get eventPhase() {
            return this._eventPhase;
          }
          get currentTarget() {
            return this._currentTarget;
          }
        }
        const Xa2 = Symbol("bubbling contexts");
        function tc2(t4) {
          return class extends t4 {
            fire(t5, ...e4) {
              try {
                const n3 = t5 instanceof p2 ? t5 : new p2(this, t5), i3 = oc2(this);
                if (!i3.size)
                  return;
                if (ec2(n3, "capturing", this), nc2(i3, "$capture", n3, ...e4))
                  return n3.return;
                const o3 = n3.startRange || this.selection.getFirstRange(), r3 = o3 ? o3.getContainedElement() : null, s3 = !!r3 && Boolean(ic2(i3, r3));
                let a3 = r3 || function(t6) {
                  if (!t6)
                    return null;
                  const e5 = t6.start.parent, n4 = t6.end.parent, i4 = e5.getPath(), o4 = n4.getPath();
                  return i4.length > o4.length ? e5 : n4;
                }(o3);
                if (ec2(n3, "atTarget", a3), !s3) {
                  if (nc2(i3, "$text", n3, ...e4))
                    return n3.return;
                  ec2(n3, "bubbling", a3);
                }
                for (; a3; ) {
                  if (a3.is("rootElement")) {
                    if (nc2(i3, "$root", n3, ...e4))
                      return n3.return;
                  } else if (a3.is("element") && nc2(i3, a3.name, n3, ...e4))
                    return n3.return;
                  if (nc2(i3, a3, n3, ...e4))
                    return n3.return;
                  a3 = a3.parent, ec2(n3, "bubbling", a3);
                }
                return ec2(n3, "bubbling", this), nc2(i3, "$document", n3, ...e4), n3.return;
              } catch (t6) {
                C2.rethrowUnexpectedError(t6, this);
              }
            }
            _addEventListener(t5, e4, n3) {
              const i3 = yo2(n3.context || "$document"), o3 = oc2(this);
              for (const r3 of i3) {
                let i4 = o3.get(r3);
                i4 || (i4 = new (B2())(), o3.set(r3, i4)), this.listenTo(i4, t5, e4, n3);
              }
            }
            _removeEventListener(t5, e4) {
              const n3 = oc2(this);
              for (const i3 of n3.values())
                this.stopListening(i3, t5, e4);
            }
          };
        }
        {
          const t4 = tc2(Object);
          ["fire", "_addEventListener", "_removeEventListener"].forEach((e4) => {
            tc2[e4] = t4.prototype[e4];
          });
        }
        function ec2(t4, e4, n3) {
          t4 instanceof Ja2 && (t4._eventPhase = e4, t4._currentTarget = n3);
        }
        function nc2(t4, e4, n3, ...i3) {
          const o3 = "string" == typeof e4 ? t4.get(e4) : ic2(t4, e4);
          return !!o3 && (o3.fire(n3, ...i3), n3.stop.called);
        }
        function ic2(t4, e4) {
          for (const [n3, i3] of t4)
            if ("function" == typeof n3 && n3(e4))
              return i3;
          return null;
        }
        function oc2(t4) {
          return t4[Xa2] || (t4[Xa2] = /* @__PURE__ */ new Map()), t4[Xa2];
        }
        class rc2 extends tc2(q2()) {
          constructor(t4) {
            super(), this._postFixers = /* @__PURE__ */ new Set(), this.selection = new Qa2(), this.roots = new Do2({ idProperty: "rootName" }), this.stylesProcessor = t4, this.set("isReadOnly", false), this.set("isFocused", false), this.set("isSelecting", false), this.set("isComposing", false);
          }
          getRoot(t4 = "main") {
            return this.roots.get(t4);
          }
          registerPostFixer(t4) {
            this._postFixers.add(t4);
          }
          destroy() {
            this.roots.forEach((t4) => t4.destroy()), this.stopListening();
          }
          _callPostFixers(t4) {
            let e4 = false;
            do {
              for (const n3 of this._postFixers)
                if (e4 = n3(t4), e4)
                  break;
            } while (e4);
          }
        }
        class sc2 extends Fa2 {
          constructor(t4, e4, n3, i3) {
            super(t4, e4, n3, i3), this._priority = 10, this._id = null, this._clonesGroup = null, this.getFillerOffset = ac2;
          }
          get priority() {
            return this._priority;
          }
          get id() {
            return this._id;
          }
          getElementsWithSameId() {
            if (null === this.id)
              throw new C2("attribute-element-get-elements-with-same-id-no-id", this);
            return new Set(this._clonesGroup);
          }
          isSimilar(t4) {
            return null !== this.id || null !== t4.id ? this.id === t4.id : super.isSimilar(t4) && this.priority == t4.priority;
          }
          _clone(t4 = false) {
            const e4 = super._clone(t4);
            return e4._priority = this._priority, e4._id = this._id, e4;
          }
        }
        function ac2() {
          if (cc2(this))
            return null;
          let t4 = this.parent;
          for (; t4 && t4.is("attributeElement"); ) {
            if (cc2(t4) > 1)
              return null;
            t4 = t4.parent;
          }
          return !t4 || cc2(t4) > 1 ? null : this.childCount;
        }
        function cc2(t4) {
          return Array.from(t4.getChildren()).filter((t5) => !t5.is("uiElement")).length;
        }
        sc2.DEFAULT_PRIORITY = 10, sc2.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("attributeElement" === t4 || "view:attributeElement" === t4 || "element" === t4 || "view:element" === t4) : "attributeElement" === t4 || "view:attributeElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
        };
        class lc2 extends Fa2 {
          constructor(t4, e4, n3, i3) {
            super(t4, e4, n3, i3), this.getFillerOffset = dc2;
          }
          _insertChild(t4, e4) {
            if (e4 && (e4 instanceof Rs || Array.from(e4).length > 0))
              throw new C2("view-emptyelement-cannot-add", [this, e4]);
            return 0;
          }
        }
        function dc2() {
          return null;
        }
        lc2.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("emptyElement" === t4 || "view:emptyElement" === t4 || "element" === t4 || "view:element" === t4) : "emptyElement" === t4 || "view:emptyElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
        };
        class hc2 extends Fa2 {
          constructor(t4, e4, n3, i3) {
            super(t4, e4, n3, i3), this.getFillerOffset = gc2;
          }
          _insertChild(t4, e4) {
            if (e4 && (e4 instanceof Rs || Array.from(e4).length > 0))
              throw new C2("view-uielement-cannot-add", [this, e4]);
            return 0;
          }
          render(t4, e4) {
            return this.toDomElement(t4);
          }
          toDomElement(t4) {
            const e4 = t4.createElement(this.name);
            for (const t5 of this.getAttributeKeys())
              e4.setAttribute(t5, this.getAttribute(t5));
            return e4;
          }
        }
        function uc2(t4) {
          t4.document.on("arrowKey", (e4, n3) => function(t5, e5, n4) {
            if (e5.keyCode == fo2.arrowright) {
              const t6 = e5.domTarget.ownerDocument.defaultView.getSelection(), i3 = 1 == t6.rangeCount && t6.getRangeAt(0).collapsed;
              if (i3 || e5.shiftKey) {
                const e6 = t6.focusNode, o3 = t6.focusOffset, r3 = n4.domPositionToView(e6, o3);
                if (null === r3)
                  return;
                let s3 = false;
                const a3 = r3.getLastMatchingPosition((t7) => (t7.item.is("uiElement") && (s3 = true), !(!t7.item.is("uiElement") && !t7.item.is("attributeElement"))));
                if (s3) {
                  const e7 = n4.viewPositionToDom(a3);
                  i3 ? t6.collapse(e7.parent, e7.offset) : t6.extend(e7.parent, e7.offset);
                }
              }
            }
          }(0, n3, t4.domConverter), { priority: "low" });
        }
        function gc2() {
          return null;
        }
        hc2.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("uiElement" === t4 || "view:uiElement" === t4 || "element" === t4 || "view:element" === t4) : "uiElement" === t4 || "view:uiElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
        };
        class mc2 extends Fa2 {
          constructor(t4, e4, n3, i3) {
            super(t4, e4, n3, i3), this.getFillerOffset = pc2;
          }
          _insertChild(t4, e4) {
            if (e4 && (e4 instanceof Rs || Array.from(e4).length > 0))
              throw new C2("view-rawelement-cannot-add", [this, e4]);
            return 0;
          }
          render(t4, e4) {
          }
        }
        function pc2() {
          return null;
        }
        mc2.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("rawElement" === t4 || "view:rawElement" === t4 || "element" === t4 || "view:element" === t4) : "rawElement" === t4 || "view:rawElement" === t4 || t4 === this.name || t4 === "view:" + this.name || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
        };
        class fc2 extends B2(zs) {
          constructor(t4, e4) {
            super(), this._children = [], this._customProperties = /* @__PURE__ */ new Map(), this.document = t4, e4 && this._insertChild(0, e4);
          }
          [Symbol.iterator]() {
            return this._children[Symbol.iterator]();
          }
          get childCount() {
            return this._children.length;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          get name() {
          }
          get getFillerOffset() {
          }
          getCustomProperty(t4) {
            return this._customProperties.get(t4);
          }
          *getCustomProperties() {
            yield* this._customProperties.entries();
          }
          _appendChild(t4) {
            return this._insertChild(this.childCount, t4);
          }
          getChild(t4) {
            return this._children[t4];
          }
          getChildIndex(t4) {
            return this._children.indexOf(t4);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          _insertChild(t4, e4) {
            this._fireChange("children", this);
            let n3 = 0;
            const i3 = function(t5, e5) {
              if ("string" == typeof e5)
                return [new Os(t5, e5)];
              et2(e5) || (e5 = [e5]);
              return Array.from(e5).map((e6) => "string" == typeof e6 ? new Os(t5, e6) : e6 instanceof Fs ? new Os(t5, e6.data) : e6);
            }(this.document, e4);
            for (const e5 of i3)
              null !== e5.parent && e5._remove(), e5.parent = this, this._children.splice(t4, 0, e5), t4++, n3++;
            return n3;
          }
          _removeChildren(t4, e4 = 1) {
            this._fireChange("children", this);
            for (let n3 = t4; n3 < t4 + e4; n3++)
              this._children[n3].parent = null;
            return this._children.splice(t4, e4);
          }
          _fireChange(t4, e4) {
            this.fire("change:" + t4, e4);
          }
          _setCustomProperty(t4, e4) {
            this._customProperties.set(t4, e4);
          }
          _removeCustomProperty(t4) {
            return this._customProperties.delete(t4);
          }
        }
        fc2.prototype.is = function(t4) {
          return "documentFragment" === t4 || "view:documentFragment" === t4;
        };
        class kc2 {
          constructor(t4) {
            this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null, this.document = t4;
          }
          setSelection(...t4) {
            this.document.selection._setTo(...t4);
          }
          setSelectionFocus(t4, e4) {
            this.document.selection._setFocus(t4, e4);
          }
          createDocumentFragment(t4) {
            return new fc2(this.document, t4);
          }
          createText(t4) {
            return new Os(this.document, t4);
          }
          createAttributeElement(t4, e4, n3 = {}) {
            const i3 = new sc2(this.document, t4, e4);
            return "number" == typeof n3.priority && (i3._priority = n3.priority), n3.id && (i3._id = n3.id), n3.renderUnsafeAttributes && i3._unsafeAttributesToRender.push(...n3.renderUnsafeAttributes), i3;
          }
          createContainerElement(t4, e4, n3 = {}, i3 = {}) {
            let o3 = null;
            Et2(n3) ? i3 = n3 : o3 = n3;
            const r3 = new ja2(this.document, t4, e4, o3);
            return i3.renderUnsafeAttributes && r3._unsafeAttributesToRender.push(...i3.renderUnsafeAttributes), r3;
          }
          createEditableElement(t4, e4, n3 = {}) {
            const i3 = new Ua2(this.document, t4, e4);
            return n3.renderUnsafeAttributes && i3._unsafeAttributesToRender.push(...n3.renderUnsafeAttributes), i3;
          }
          createEmptyElement(t4, e4, n3 = {}) {
            const i3 = new lc2(this.document, t4, e4);
            return n3.renderUnsafeAttributes && i3._unsafeAttributesToRender.push(...n3.renderUnsafeAttributes), i3;
          }
          createUIElement(t4, e4, n3) {
            const i3 = new hc2(this.document, t4, e4);
            return n3 && (i3.render = n3), i3;
          }
          createRawElement(t4, e4, n3, i3 = {}) {
            const o3 = new mc2(this.document, t4, e4);
            return n3 && (o3.render = n3), i3.renderUnsafeAttributes && o3._unsafeAttributesToRender.push(...i3.renderUnsafeAttributes), o3;
          }
          setAttribute(t4, e4, n3) {
            n3._setAttribute(t4, e4);
          }
          removeAttribute(t4, e4) {
            e4._removeAttribute(t4);
          }
          addClass(t4, e4) {
            e4._addClass(t4);
          }
          removeClass(t4, e4) {
            e4._removeClass(t4);
          }
          setStyle(t4, e4, n3) {
            Et2(t4) && void 0 === n3 ? e4._setStyle(t4) : n3._setStyle(t4, e4);
          }
          removeStyle(t4, e4) {
            e4._removeStyle(t4);
          }
          setCustomProperty(t4, e4, n3) {
            n3._setCustomProperty(t4, e4);
          }
          removeCustomProperty(t4, e4) {
            return e4._removeCustomProperty(t4);
          }
          breakAttributes(t4) {
            return t4 instanceof $a ? this._breakAttributes(t4) : this._breakAttributesRange(t4);
          }
          breakContainer(t4) {
            const e4 = t4.parent;
            if (!e4.is("containerElement"))
              throw new C2("view-writer-break-non-container-element", this.document);
            if (!e4.parent)
              throw new C2("view-writer-break-root", this.document);
            if (t4.isAtStart)
              return $a._createBefore(e4);
            if (!t4.isAtEnd) {
              const n3 = e4._clone(false);
              this.insert($a._createAfter(e4), n3);
              const i3 = new Ka2(t4, $a._createAt(e4, "end")), o3 = new $a(n3, 0);
              this.move(i3, o3);
            }
            return $a._createAfter(e4);
          }
          mergeAttributes(t4) {
            const e4 = t4.offset, n3 = t4.parent;
            if (n3.is("$text"))
              return t4;
            if (n3.is("attributeElement") && 0 === n3.childCount) {
              const t5 = n3.parent, e5 = n3.index;
              return n3._remove(), this._removeFromClonedElementsGroup(n3), this.mergeAttributes(new $a(t5, e5));
            }
            const i3 = n3.getChild(e4 - 1), o3 = n3.getChild(e4);
            if (!i3 || !o3)
              return t4;
            if (i3.is("$text") && o3.is("$text"))
              return _c(i3, o3);
            if (i3.is("attributeElement") && o3.is("attributeElement") && i3.isSimilar(o3)) {
              const t5 = i3.childCount;
              return i3._appendChild(o3.getChildren()), o3._remove(), this._removeFromClonedElementsGroup(o3), this.mergeAttributes(new $a(i3, t5));
            }
            return t4;
          }
          mergeContainers(t4) {
            const e4 = t4.nodeBefore, n3 = t4.nodeAfter;
            if (!(e4 && n3 && e4.is("containerElement") && n3.is("containerElement")))
              throw new C2("view-writer-merge-containers-invalid-position", this.document);
            const i3 = e4.getChild(e4.childCount - 1), o3 = i3 instanceof Os ? $a._createAt(i3, "end") : $a._createAt(e4, "end");
            return this.move(Ka2._createIn(n3), $a._createAt(e4, "end")), this.remove(Ka2._createOn(n3)), o3;
          }
          insert(t4, e4) {
            yc2(e4 = et2(e4) ? [...e4] : [e4], this.document);
            const n3 = e4.reduce((t5, e5) => {
              const n4 = t5[t5.length - 1], i4 = !e5.is("uiElement");
              return n4 && n4.breakAttributes == i4 ? n4.nodes.push(e5) : t5.push({ breakAttributes: i4, nodes: [e5] }), t5;
            }, []);
            let i3 = null, o3 = t4;
            for (const { nodes: t5, breakAttributes: e5 } of n3) {
              const n4 = this._insertNodes(o3, t5, e5);
              i3 || (i3 = n4.start), o3 = n4.end;
            }
            return i3 ? new Ka2(i3, o3) : new Ka2(t4);
          }
          remove(t4) {
            const e4 = t4 instanceof Ka2 ? t4 : Ka2._createOn(t4);
            if (Ec2(e4, this.document), e4.isCollapsed)
              return new fc2(this.document);
            const { start: n3, end: i3 } = this._breakAttributesRange(e4, true), o3 = n3.parent, r3 = i3.offset - n3.offset, s3 = o3._removeChildren(n3.offset, r3);
            for (const t5 of s3)
              this._removeFromClonedElementsGroup(t5);
            const a3 = this.mergeAttributes(n3);
            return e4.start = a3, e4.end = a3.clone(), new fc2(this.document, s3);
          }
          clear(t4, e4) {
            Ec2(t4, this.document);
            const n3 = t4.getWalker({ direction: "backward", ignoreElementEnd: true });
            for (const i3 of n3) {
              const n4 = i3.item;
              let o3;
              if (n4.is("element") && e4.isSimilar(n4))
                o3 = Ka2._createOn(n4);
              else if (!i3.nextPosition.isAfter(t4.start) && n4.is("$textProxy")) {
                const t5 = n4.getAncestors().find((t6) => t6.is("element") && e4.isSimilar(t6));
                t5 && (o3 = Ka2._createIn(t5));
              }
              o3 && (o3.end.isAfter(t4.end) && (o3.end = t4.end), o3.start.isBefore(t4.start) && (o3.start = t4.start), this.remove(o3));
            }
          }
          move(t4, e4) {
            let n3;
            if (e4.isAfter(t4.end)) {
              const i3 = (e4 = this._breakAttributes(e4, true)).parent, o3 = i3.childCount;
              t4 = this._breakAttributesRange(t4, true), n3 = this.remove(t4), e4.offset += i3.childCount - o3;
            } else
              n3 = this.remove(t4);
            return this.insert(e4, n3);
          }
          wrap(t4, e4) {
            if (!(e4 instanceof sc2))
              throw new C2("view-writer-wrap-invalid-attribute", this.document);
            if (Ec2(t4, this.document), t4.isCollapsed) {
              let i3 = t4.start;
              i3.parent.is("element") && (n3 = i3.parent, !Array.from(n3.getChildren()).some((t5) => !t5.is("uiElement"))) && (i3 = i3.getLastMatchingPosition((t5) => t5.item.is("uiElement"))), i3 = this._wrapPosition(i3, e4);
              const o3 = this.document.selection;
              return o3.isCollapsed && o3.getFirstPosition().isEqual(t4.start) && this.setSelection(i3), new Ka2(i3);
            }
            return this._wrapRange(t4, e4);
            var n3;
          }
          unwrap(t4, e4) {
            if (!(e4 instanceof sc2))
              throw new C2("view-writer-unwrap-invalid-attribute", this.document);
            if (Ec2(t4, this.document), t4.isCollapsed)
              return t4;
            const { start: n3, end: i3 } = this._breakAttributesRange(t4, true), o3 = n3.parent, r3 = this._unwrapChildren(o3, n3.offset, i3.offset, e4), s3 = this.mergeAttributes(r3.start);
            s3.isEqual(r3.start) || r3.end.offset--;
            const a3 = this.mergeAttributes(r3.end);
            return new Ka2(s3, a3);
          }
          rename(t4, e4) {
            const n3 = new ja2(this.document, t4, e4.getAttributes());
            return this.insert($a._createAfter(e4), n3), this.move(Ka2._createIn(e4), $a._createAt(n3, 0)), this.remove(Ka2._createOn(e4)), n3;
          }
          clearClonedElementsGroup(t4) {
            this._cloneGroups.delete(t4);
          }
          createPositionAt(t4, e4) {
            return $a._createAt(t4, e4);
          }
          createPositionAfter(t4) {
            return $a._createAfter(t4);
          }
          createPositionBefore(t4) {
            return $a._createBefore(t4);
          }
          createRange(t4, e4) {
            return new Ka2(t4, e4);
          }
          createRangeOn(t4) {
            return Ka2._createOn(t4);
          }
          createRangeIn(t4) {
            return Ka2._createIn(t4);
          }
          createSelection(...t4) {
            return new Ya2(...t4);
          }
          createSlot(t4 = "children") {
            if (!this._slotFactory)
              throw new C2("view-writer-invalid-create-slot-context", this.document);
            return this._slotFactory(this, t4);
          }
          _registerSlotFactory(t4) {
            this._slotFactory = t4;
          }
          _clearSlotFactory() {
            this._slotFactory = null;
          }
          _insertNodes(t4, e4, n3) {
            let i3, o3;
            if (i3 = n3 ? bc2(t4) : t4.parent.is("$text") ? t4.parent.parent : t4.parent, !i3)
              throw new C2("view-writer-invalid-position-container", this.document);
            o3 = n3 ? this._breakAttributes(t4, true) : t4.parent.is("$text") ? Cc2(t4) : t4;
            const r3 = i3._insertChild(o3.offset, e4);
            for (const t5 of e4)
              this._addToClonedElementsGroup(t5);
            const s3 = o3.getShiftedBy(r3), a3 = this.mergeAttributes(o3);
            a3.isEqual(o3) || s3.offset--;
            const c3 = this.mergeAttributes(s3);
            return new Ka2(a3, c3);
          }
          _wrapChildren(t4, e4, n3, i3) {
            let o3 = e4;
            const r3 = [];
            for (; o3 < n3; ) {
              const e5 = t4.getChild(o3), n4 = e5.is("$text"), s4 = e5.is("attributeElement");
              if (s4 && this._wrapAttributeElement(i3, e5))
                r3.push(new $a(t4, o3));
              else if (n4 || !s4 || wc2(i3, e5)) {
                const n5 = i3._clone();
                e5._remove(), n5._appendChild(e5), t4._insertChild(o3, n5), this._addToClonedElementsGroup(n5), r3.push(new $a(t4, o3));
              } else
                this._wrapChildren(e5, 0, e5.childCount, i3);
              o3++;
            }
            let s3 = 0;
            for (const t5 of r3) {
              if (t5.offset -= s3, t5.offset == e4)
                continue;
              this.mergeAttributes(t5).isEqual(t5) || (s3++, n3--);
            }
            return Ka2._createFromParentsAndOffsets(t4, e4, t4, n3);
          }
          _unwrapChildren(t4, e4, n3, i3) {
            let o3 = e4;
            const r3 = [];
            for (; o3 < n3; ) {
              const e5 = t4.getChild(o3);
              if (e5.is("attributeElement"))
                if (e5.isSimilar(i3)) {
                  const i4 = e5.getChildren(), s4 = e5.childCount;
                  e5._remove(), t4._insertChild(o3, i4), this._removeFromClonedElementsGroup(e5), r3.push(new $a(t4, o3), new $a(t4, o3 + s4)), o3 += s4, n3 += s4 - 1;
                } else
                  this._unwrapAttributeElement(i3, e5) ? (r3.push(new $a(t4, o3), new $a(t4, o3 + 1)), o3++) : (this._unwrapChildren(e5, 0, e5.childCount, i3), o3++);
              else
                o3++;
            }
            let s3 = 0;
            for (const t5 of r3) {
              if (t5.offset -= s3, t5.offset == e4 || t5.offset == n3)
                continue;
              this.mergeAttributes(t5).isEqual(t5) || (s3++, n3--);
            }
            return Ka2._createFromParentsAndOffsets(t4, e4, t4, n3);
          }
          _wrapRange(t4, e4) {
            const { start: n3, end: i3 } = this._breakAttributesRange(t4, true), o3 = n3.parent, r3 = this._wrapChildren(o3, n3.offset, i3.offset, e4), s3 = this.mergeAttributes(r3.start);
            s3.isEqual(r3.start) || r3.end.offset--;
            const a3 = this.mergeAttributes(r3.end);
            return new Ka2(s3, a3);
          }
          _wrapPosition(t4, e4) {
            if (e4.isSimilar(t4.parent))
              return Ac2(t4.clone());
            t4.parent.is("$text") && (t4 = Cc2(t4));
            const n3 = this.createAttributeElement("_wrapPosition-fake-element");
            n3._priority = Number.POSITIVE_INFINITY, n3.isSimilar = () => false, t4.parent._insertChild(t4.offset, n3);
            const i3 = new Ka2(t4, t4.getShiftedBy(1));
            this.wrap(i3, e4);
            const o3 = new $a(n3.parent, n3.index);
            n3._remove();
            const r3 = o3.nodeBefore, s3 = o3.nodeAfter;
            return r3 instanceof Os && s3 instanceof Os ? _c(r3, s3) : Ac2(o3);
          }
          _wrapAttributeElement(t4, e4) {
            if (!Dc2(t4, e4))
              return false;
            if (t4.name !== e4.name || t4.priority !== e4.priority)
              return false;
            for (const n3 of t4.getAttributeKeys())
              if ("class" !== n3 && "style" !== n3 && e4.hasAttribute(n3) && e4.getAttribute(n3) !== t4.getAttribute(n3))
                return false;
            for (const n3 of t4.getStyleNames())
              if (e4.hasStyle(n3) && e4.getStyle(n3) !== t4.getStyle(n3))
                return false;
            for (const n3 of t4.getAttributeKeys())
              "class" !== n3 && "style" !== n3 && (e4.hasAttribute(n3) || this.setAttribute(n3, t4.getAttribute(n3), e4));
            for (const n3 of t4.getStyleNames())
              e4.hasStyle(n3) || this.setStyle(n3, t4.getStyle(n3), e4);
            for (const n3 of t4.getClassNames())
              e4.hasClass(n3) || this.addClass(n3, e4);
            return true;
          }
          _unwrapAttributeElement(t4, e4) {
            if (!Dc2(t4, e4))
              return false;
            if (t4.name !== e4.name || t4.priority !== e4.priority)
              return false;
            for (const n3 of t4.getAttributeKeys())
              if ("class" !== n3 && "style" !== n3 && (!e4.hasAttribute(n3) || e4.getAttribute(n3) !== t4.getAttribute(n3)))
                return false;
            if (!e4.hasClass(...t4.getClassNames()))
              return false;
            for (const n3 of t4.getStyleNames())
              if (!e4.hasStyle(n3) || e4.getStyle(n3) !== t4.getStyle(n3))
                return false;
            for (const n3 of t4.getAttributeKeys())
              "class" !== n3 && "style" !== n3 && this.removeAttribute(n3, e4);
            return this.removeClass(Array.from(t4.getClassNames()), e4), this.removeStyle(Array.from(t4.getStyleNames()), e4), true;
          }
          _breakAttributesRange(t4, e4 = false) {
            const n3 = t4.start, i3 = t4.end;
            if (Ec2(t4, this.document), t4.isCollapsed) {
              const n4 = this._breakAttributes(t4.start, e4);
              return new Ka2(n4, n4);
            }
            const o3 = this._breakAttributes(i3, e4), r3 = o3.parent.childCount, s3 = this._breakAttributes(n3, e4);
            return o3.offset += o3.parent.childCount - r3, new Ka2(s3, o3);
          }
          _breakAttributes(t4, e4 = false) {
            const n3 = t4.offset, i3 = t4.parent;
            if (t4.parent.is("emptyElement"))
              throw new C2("view-writer-cannot-break-empty-element", this.document);
            if (t4.parent.is("uiElement"))
              throw new C2("view-writer-cannot-break-ui-element", this.document);
            if (t4.parent.is("rawElement"))
              throw new C2("view-writer-cannot-break-raw-element", this.document);
            if (!e4 && i3.is("$text") && xc2(i3.parent))
              return t4.clone();
            if (xc2(i3))
              return t4.clone();
            if (i3.is("$text"))
              return this._breakAttributes(Cc2(t4), e4);
            if (n3 == i3.childCount) {
              const t5 = new $a(i3.parent, i3.index + 1);
              return this._breakAttributes(t5, e4);
            }
            if (0 === n3) {
              const t5 = new $a(i3.parent, i3.index);
              return this._breakAttributes(t5, e4);
            }
            {
              const t5 = i3.index + 1, o3 = i3._clone();
              i3.parent._insertChild(t5, o3), this._addToClonedElementsGroup(o3);
              const r3 = i3.childCount - n3, s3 = i3._removeChildren(n3, r3);
              o3._appendChild(s3);
              const a3 = new $a(i3.parent, t5);
              return this._breakAttributes(a3, e4);
            }
          }
          _addToClonedElementsGroup(t4) {
            if (!t4.root.is("rootElement"))
              return;
            if (t4.is("element"))
              for (const e5 of t4.getChildren())
                this._addToClonedElementsGroup(e5);
            const e4 = t4.id;
            if (!e4)
              return;
            let n3 = this._cloneGroups.get(e4);
            n3 || (n3 = /* @__PURE__ */ new Set(), this._cloneGroups.set(e4, n3)), n3.add(t4), t4._clonesGroup = n3;
          }
          _removeFromClonedElementsGroup(t4) {
            if (t4.is("element"))
              for (const e5 of t4.getChildren())
                this._removeFromClonedElementsGroup(e5);
            const e4 = t4.id;
            if (!e4)
              return;
            const n3 = this._cloneGroups.get(e4);
            n3 && n3.delete(t4);
          }
        }
        function bc2(t4) {
          let e4 = t4.parent;
          for (; !xc2(e4); ) {
            if (!e4)
              return;
            e4 = e4.parent;
          }
          return e4;
        }
        function wc2(t4, e4) {
          return t4.priority < e4.priority || !(t4.priority > e4.priority) && t4.getIdentity() < e4.getIdentity();
        }
        function Ac2(t4) {
          const e4 = t4.nodeBefore;
          if (e4 && e4.is("$text"))
            return new $a(e4, e4.data.length);
          const n3 = t4.nodeAfter;
          return n3 && n3.is("$text") ? new $a(n3, 0) : t4;
        }
        function Cc2(t4) {
          if (t4.offset == t4.parent.data.length)
            return new $a(t4.parent.parent, t4.parent.index + 1);
          if (0 === t4.offset)
            return new $a(t4.parent.parent, t4.parent.index);
          const e4 = t4.parent.data.slice(t4.offset);
          return t4.parent._data = t4.parent.data.slice(0, t4.offset), t4.parent.parent._insertChild(t4.parent.index + 1, new Os(t4.root.document, e4)), new $a(t4.parent.parent, t4.parent.index + 1);
        }
        function _c(t4, e4) {
          const n3 = t4.data.length;
          return t4._data += e4.data, e4._remove(), new $a(t4, n3);
        }
        const vc2 = [Os, sc2, ja2, lc2, mc2, hc2];
        function yc2(t4, e4) {
          for (const n3 of t4) {
            if (!vc2.some((t5) => n3 instanceof t5))
              throw new C2("view-writer-insert-invalid-node-type", e4);
            n3.is("$text") || yc2(n3.getChildren(), e4);
          }
        }
        function xc2(t4) {
          return t4 && (t4.is("containerElement") || t4.is("documentFragment"));
        }
        function Ec2(t4, e4) {
          const n3 = bc2(t4.start), i3 = bc2(t4.end);
          if (!n3 || !i3 || n3 !== i3)
            throw new C2("view-writer-invalid-range-container", e4);
        }
        function Dc2(t4, e4) {
          return null === t4.id && null === e4.id;
        }
        const Sc2 = (t4) => t4.createTextNode(""), Tc2 = (t4) => {
          const e4 = t4.createElement("span");
          return e4.dataset.ckeFiller = "true", e4.innerText = "", e4;
        }, Ic2 = (t4) => {
          const e4 = t4.createElement("br");
          return e4.dataset.ckeFiller = "true", e4;
        }, Bc2 = 7, Mc2 = "".repeat(Bc2);
        function Nc2(t4) {
          return "string" == typeof t4 ? t4.substr(0, Bc2) === Mc2 : zi2(t4) && t4.data.substr(0, Bc2) === Mc2;
        }
        function Lc2(t4) {
          return t4.data.length == Bc2 && Nc2(t4);
        }
        function zc2(t4) {
          const e4 = "string" == typeof t4 ? t4 : t4.data;
          return Nc2(t4) ? e4.slice(Bc2) : e4;
        }
        function Pc2(t4, e4) {
          if (e4.keyCode == fo2.arrowleft) {
            const t5 = e4.domTarget.ownerDocument.defaultView.getSelection();
            if (1 == t5.rangeCount && t5.getRangeAt(0).collapsed) {
              const e5 = t5.getRangeAt(0).startContainer, n3 = t5.getRangeAt(0).startOffset;
              Nc2(e5) && n3 <= Bc2 && t5.collapse(e5, 0);
            }
          }
        }
        var Rc2 = n2(5037), Oc2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Rc2.Z, Oc2);
        Rc2.Z.locals;
        class Fc2 extends q2() {
          constructor(t4, e4) {
            super(), this.domDocuments = /* @__PURE__ */ new Set(), this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = t4, this.selection = e4, this.set("isFocused", false), this.set("isSelecting", false), c2.isBlink && !c2.isAndroid && this.on("change:isSelecting", () => {
              this.isSelecting || this.render();
            }), this.set("isComposing", false), this.on("change:isComposing", () => {
              this.isComposing || this.render();
            });
          }
          markToSync(t4, e4) {
            if ("text" === t4)
              this.domConverter.mapViewToDom(e4.parent) && this.markedTexts.add(e4);
            else {
              if (!this.domConverter.mapViewToDom(e4))
                return;
              if ("attributes" === t4)
                this.markedAttributes.add(e4);
              else {
                if ("children" !== t4) {
                  throw new C2("view-renderer-unknown-type", this);
                }
                this.markedChildren.add(e4);
              }
            }
          }
          render() {
            if (this.isComposing && !c2.isAndroid)
              return;
            let t4 = null;
            const e4 = !(c2.isBlink && !c2.isAndroid) || !this.isSelecting;
            for (const t5 of this.markedChildren)
              this._updateChildrenMappings(t5);
            e4 ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? t4 = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (t4 = this.selection.getFirstPosition(), this.markedChildren.add(t4.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (t4 = this.domConverter.domPositionToView(this._inlineFiller), t4 && t4.parent.is("$text") && (t4 = $a._createBefore(t4.parent)));
            for (const t5 of this.markedAttributes)
              this._updateAttrs(t5);
            for (const e5 of this.markedChildren)
              this._updateChildren(e5, { inlineFillerPosition: t4 });
            for (const e5 of this.markedTexts)
              !this.markedChildren.has(e5.parent) && this.domConverter.mapViewToDom(e5.parent) && this._updateText(e5, { inlineFillerPosition: t4 });
            if (e4)
              if (t4) {
                const e5 = this.domConverter.viewPositionToDom(t4), n3 = e5.parent.ownerDocument;
                Nc2(e5.parent) ? this._inlineFiller = e5.parent : this._inlineFiller = Vc2(n3, e5.parent, e5.offset);
              } else
                this._inlineFiller = null;
            this._updateFocus(), this._updateSelection(), this.domConverter._clearTemporaryCustomProperties(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
          }
          _updateChildrenMappings(t4) {
            const e4 = this.domConverter.mapViewToDom(t4);
            if (!e4)
              return;
            const n3 = Array.from(e4.childNodes), i3 = Array.from(this.domConverter.viewChildrenToDom(t4, { withChildren: false })), o3 = this._diffNodeLists(n3, i3), r3 = this._findUpdateActions(o3, n3, i3, jc2);
            if (-1 !== r3.indexOf("update")) {
              const e5 = { equal: 0, insert: 0, delete: 0 };
              for (const o4 of r3)
                if ("update" === o4) {
                  const o5 = e5.equal + e5.insert, r4 = e5.equal + e5.delete, s3 = t4.getChild(o5);
                  !s3 || s3.is("uiElement") || s3.is("rawElement") || this._updateElementMappings(s3, n3[r4]), no2(i3[o5]), e5.equal++;
                } else
                  e5[o4]++;
            }
          }
          _updateElementMappings(t4, e4) {
            this.domConverter.unbindDomElement(e4), this.domConverter.bindElements(e4, t4), this.markedChildren.add(t4), this.markedAttributes.add(t4);
          }
          _getInlineFillerPosition() {
            const t4 = this.selection.getFirstPosition();
            return t4.parent.is("$text") ? $a._createBefore(t4.parent) : t4;
          }
          _isSelectionInInlineFiller() {
            if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
              return false;
            const t4 = this.selection.getFirstPosition(), e4 = this.domConverter.viewPositionToDom(t4);
            return !!(e4 && zi2(e4.parent) && Nc2(e4.parent));
          }
          _removeInlineFiller() {
            const t4 = this._inlineFiller;
            if (!Nc2(t4))
              throw new C2("view-renderer-filler-was-lost", this);
            Lc2(t4) ? t4.remove() : t4.data = t4.data.substr(Bc2), this._inlineFiller = null;
          }
          _needsInlineFillerAtSelection() {
            if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
              return false;
            const t4 = this.selection.getFirstPosition(), e4 = t4.parent, n3 = t4.offset;
            if (!this.domConverter.mapViewToDom(e4.root))
              return false;
            if (!e4.is("element"))
              return false;
            if (!function(t5) {
              if ("false" == t5.getAttribute("contenteditable"))
                return false;
              const e5 = t5.findAncestor((t6) => t6.hasAttribute("contenteditable"));
              return !e5 || "true" == e5.getAttribute("contenteditable");
            }(e4))
              return false;
            if (n3 === e4.getFillerOffset())
              return false;
            const i3 = t4.nodeBefore, o3 = t4.nodeAfter;
            return !(i3 instanceof Os || o3 instanceof Os) && (!c2.isAndroid || !i3 && !o3);
          }
          _updateText(t4, e4) {
            const n3 = this.domConverter.findCorrespondingDomText(t4);
            let i3 = this.domConverter.viewToDom(t4).data;
            const o3 = e4.inlineFillerPosition;
            o3 && o3.parent == t4.parent && o3.offset == t4.index && (i3 = Mc2 + i3), Gc2(n3, i3);
          }
          _updateAttrs(t4) {
            const e4 = this.domConverter.mapViewToDom(t4);
            if (!e4)
              return;
            const n3 = Array.from(e4.attributes).map((t5) => t5.name), i3 = t4.getAttributeKeys();
            for (const n4 of i3)
              this.domConverter.setDomElementAttribute(e4, n4, t4.getAttribute(n4), t4);
            for (const i4 of n3)
              t4.hasAttribute(i4) || this.domConverter.removeDomElementAttribute(e4, i4);
          }
          _updateChildren(t4, e4) {
            const n3 = this.domConverter.mapViewToDom(t4);
            if (!n3)
              return;
            if (c2.isAndroid) {
              let t5 = null;
              for (const e5 of Array.from(n3.childNodes)) {
                if (t5 && zi2(t5) && zi2(e5)) {
                  n3.normalize();
                  break;
                }
                t5 = e5;
              }
            }
            const i3 = e4.inlineFillerPosition, o3 = n3.childNodes, r3 = Array.from(this.domConverter.viewChildrenToDom(t4, { bind: true }));
            i3 && i3.parent === t4 && Vc2(n3.ownerDocument, r3, i3.offset);
            const s3 = this._diffNodeLists(o3, r3), a3 = this._findUpdateActions(s3, o3, r3, Hc2);
            let l3 = 0;
            const d3 = /* @__PURE__ */ new Set();
            for (const t5 of a3)
              "delete" === t5 ? (d3.add(o3[l3]), no2(o3[l3])) : "equal" !== t5 && "update" !== t5 || l3++;
            l3 = 0;
            for (const t5 of a3)
              "insert" === t5 ? (Zi2(n3, l3, r3[l3]), l3++) : "update" === t5 ? (Gc2(o3[l3], r3[l3].data), l3++) : "equal" === t5 && (this._markDescendantTextToSync(this.domConverter.domToView(r3[l3])), l3++);
            for (const t5 of d3)
              t5.parentNode || this.domConverter.unbindDomElement(t5);
          }
          _diffNodeLists(t4, e4) {
            return t4 = function(t5, e5) {
              const n3 = Array.from(t5);
              if (0 == n3.length || !e5)
                return n3;
              const i3 = n3[n3.length - 1];
              i3 == e5 && n3.pop();
              return n3;
            }(t4, this._fakeSelectionContainer), g2(t4, e4, Uc2.bind(null, this.domConverter));
          }
          _findUpdateActions(t4, e4, n3, i3) {
            if (-1 === t4.indexOf("insert") || -1 === t4.indexOf("delete"))
              return t4;
            let o3 = [], r3 = [], s3 = [];
            const a3 = { equal: 0, insert: 0, delete: 0 };
            for (const c3 of t4)
              "insert" === c3 ? s3.push(n3[a3.equal + a3.insert]) : "delete" === c3 ? r3.push(e4[a3.equal + a3.delete]) : (o3 = o3.concat(g2(r3, s3, i3).map((t5) => "equal" === t5 ? "update" : t5)), o3.push("equal"), r3 = [], s3 = []), a3[c3]++;
            return o3.concat(g2(r3, s3, i3).map((t5) => "equal" === t5 ? "update" : t5));
          }
          _markDescendantTextToSync(t4) {
            if (t4) {
              if (t4.is("$text"))
                this.markedTexts.add(t4);
              else if (t4.is("element"))
                for (const e4 of t4.getChildren())
                  this._markDescendantTextToSync(e4);
            }
          }
          _updateSelection() {
            if (c2.isBlink && !c2.isAndroid && this.isSelecting && !this.markedChildren.size)
              return;
            if (0 === this.selection.rangeCount)
              return this._removeDomSelection(), void this._removeFakeSelection();
            const t4 = this.domConverter.mapViewToDom(this.selection.editableElement);
            this.isFocused && t4 && (this.selection.isFake ? this._updateFakeSelection(t4) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(t4)) : this.isComposing && c2.isAndroid || this._updateDomSelection(t4));
          }
          _updateFakeSelection(t4) {
            const e4 = t4.ownerDocument;
            this._fakeSelectionContainer || (this._fakeSelectionContainer = function(t5) {
              const e5 = t5.createElement("div");
              return e5.className = "ck-fake-selection-container", Object.assign(e5.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), e5.textContent = "", e5;
            }(e4));
            const n3 = this._fakeSelectionContainer;
            if (this.domConverter.bindFakeSelection(n3, this.selection), !this._fakeSelectionNeedsUpdate(t4))
              return;
            n3.parentElement && n3.parentElement == t4 || t4.appendChild(n3), n3.textContent = this.selection.fakeSelectionLabel || "";
            const i3 = e4.getSelection(), o3 = e4.createRange();
            i3.removeAllRanges(), o3.selectNodeContents(n3), i3.addRange(o3);
          }
          _updateDomSelection(t4) {
            const e4 = t4.ownerDocument.defaultView.getSelection();
            if (!this._domSelectionNeedsUpdate(e4))
              return;
            const n3 = this.domConverter.viewPositionToDom(this.selection.anchor), i3 = this.domConverter.viewPositionToDom(this.selection.focus);
            e4.setBaseAndExtent(n3.parent, n3.offset, i3.parent, i3.offset), c2.isGecko && function(t5, e5) {
              const n4 = t5.parent;
              if (n4.nodeType != Node.ELEMENT_NODE || t5.offset != n4.childNodes.length - 1)
                return;
              const i4 = n4.childNodes[t5.offset];
              i4 && "BR" == i4.tagName && e5.addRange(e5.getRangeAt(0));
            }(i3, e4);
          }
          _domSelectionNeedsUpdate(t4) {
            if (!this.domConverter.isDomSelectionCorrect(t4))
              return true;
            const e4 = t4 && this.domConverter.domSelectionToView(t4);
            return (!e4 || !this.selection.isEqual(e4)) && !(!this.selection.isCollapsed && this.selection.isSimilar(e4));
          }
          _fakeSelectionNeedsUpdate(t4) {
            const e4 = this._fakeSelectionContainer, n3 = t4.ownerDocument.getSelection();
            return !e4 || e4.parentElement !== t4 || (n3.anchorNode !== e4 && !e4.contains(n3.anchorNode) || e4.textContent !== this.selection.fakeSelectionLabel);
          }
          _removeDomSelection() {
            for (const t4 of this.domDocuments) {
              const e4 = t4.getSelection();
              if (e4.rangeCount) {
                const n3 = t4.activeElement, i3 = this.domConverter.mapDomToView(n3);
                n3 && i3 && e4.removeAllRanges();
              }
            }
          }
          _removeFakeSelection() {
            const t4 = this._fakeSelectionContainer;
            t4 && t4.remove();
          }
          _updateFocus() {
            if (this.isFocused) {
              const t4 = this.selection.editableElement;
              t4 && this.domConverter.focus(t4);
            }
          }
        }
        function Vc2(t4, e4, n3) {
          const i3 = e4 instanceof Array ? e4 : e4.childNodes, o3 = i3[n3];
          if (zi2(o3))
            return o3.data = Mc2 + o3.data, o3;
          {
            const o4 = t4.createTextNode(Mc2);
            return Array.isArray(e4) ? i3.splice(n3, 0, o4) : Zi2(e4, n3, o4), o4;
          }
        }
        function jc2(t4, e4) {
          return Di2(t4) && Di2(e4) && !zi2(t4) && !zi2(e4) && !Yi2(t4) && !Yi2(e4) && t4.tagName.toLowerCase() === e4.tagName.toLowerCase();
        }
        function Hc2(t4, e4) {
          return Di2(t4) && Di2(e4) && zi2(t4) && zi2(e4);
        }
        function Uc2(t4, e4, n3) {
          return e4 === n3 || (zi2(e4) && zi2(n3) ? e4.data === n3.data : !(!t4.isBlockFiller(e4) || !t4.isBlockFiller(n3)));
        }
        function Gc2(t4, e4) {
          const n3 = t4.data;
          if (n3 == e4)
            return;
          const i3 = d2(n3, e4);
          for (const e5 of i3)
            "insert" === e5.type ? t4.insertData(e5.index, e5.values.join("")) : t4.deleteData(e5.index, e5.howMany);
        }
        const Wc2 = Ic2(Li2.document), qc2 = Sc2(Li2.document), $c2 = Tc2(Li2.document), Kc2 = "data-ck-unsafe-attribute-", Zc2 = "data-ck-unsafe-element";
        class Yc2 {
          constructor(t4, { blockFillerMode: e4, renderingMode: n3 = "editing" } = {}) {
            this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new Vs(), this._inlineObjectElementMatcher = new Vs(), this._elementsWithTemporaryCustomProperties = /* @__PURE__ */ new Set(), this.document = t4, this.renderingMode = n3, this.blockFillerMode = e4 || ("editing" === n3 ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = "editing" === this.renderingMode ? Li2.document : Li2.document.implementation.createHTMLDocument("");
          }
          bindFakeSelection(t4, e4) {
            this._fakeSelectionMapping.set(t4, new Ya2(e4));
          }
          fakeSelectionToView(t4) {
            return this._fakeSelectionMapping.get(t4);
          }
          bindElements(t4, e4) {
            this._domToViewMapping.set(t4, e4), this._viewToDomMapping.set(e4, t4);
          }
          unbindDomElement(t4) {
            const e4 = this._domToViewMapping.get(t4);
            if (e4) {
              this._domToViewMapping.delete(t4), this._viewToDomMapping.delete(e4);
              for (const e5 of Array.from(t4.children))
                this.unbindDomElement(e5);
            }
          }
          bindDocumentFragments(t4, e4) {
            this._domToViewMapping.set(t4, e4), this._viewToDomMapping.set(e4, t4);
          }
          shouldRenderAttribute(t4, e4, n3) {
            return "data" === this.renderingMode || !(t4 = t4.toLowerCase()).startsWith("on") && (("srcdoc" !== t4 || !e4.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && ("img" === n3 && ("src" === t4 || "srcset" === t4) || ("source" === n3 && "srcset" === t4 || !e4.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))));
          }
          setContentOf(t4, e4) {
            if ("data" === this.renderingMode)
              return void (t4.innerHTML = e4);
            const n3 = new DOMParser().parseFromString(e4, "text/html"), i3 = n3.createDocumentFragment(), o3 = n3.body.childNodes;
            for (; o3.length > 0; )
              i3.appendChild(o3[0]);
            const r3 = n3.createTreeWalker(i3, NodeFilter.SHOW_ELEMENT), s3 = [];
            let a3;
            for (; a3 = r3.nextNode(); )
              s3.push(a3);
            for (const t5 of s3) {
              for (const e6 of t5.getAttributeNames())
                this.setDomElementAttribute(t5, e6, t5.getAttribute(e6));
              const e5 = t5.tagName.toLowerCase();
              this._shouldRenameElement(e5) && (tl2(e5), t5.replaceWith(this._createReplacementDomElement(e5, t5)));
            }
            for (; t4.firstChild; )
              t4.firstChild.remove();
            t4.append(i3);
          }
          viewToDom(t4, e4 = {}) {
            if (t4.is("$text")) {
              const e5 = this._processDataFromViewText(t4);
              return this._domDocument.createTextNode(e5);
            }
            {
              const n3 = t4;
              if (this.mapViewToDom(n3)) {
                if (!n3.getCustomProperty("editingPipeline:doNotReuseOnce"))
                  return this.mapViewToDom(n3);
                this._elementsWithTemporaryCustomProperties.add(n3);
              }
              let i3;
              if (n3.is("documentFragment"))
                i3 = this._domDocument.createDocumentFragment(), e4.bind && this.bindDocumentFragments(i3, n3);
              else {
                if (n3.is("uiElement"))
                  return i3 = "$comment" === n3.name ? this._domDocument.createComment(n3.getCustomProperty("$rawContent")) : n3.render(this._domDocument, this), e4.bind && this.bindElements(i3, n3), i3;
                this._shouldRenameElement(n3.name) ? (tl2(n3.name), i3 = this._createReplacementDomElement(n3.name)) : i3 = n3.hasAttribute("xmlns") ? this._domDocument.createElementNS(n3.getAttribute("xmlns"), n3.name) : this._domDocument.createElement(n3.name), n3.is("rawElement") && n3.render(i3, this), e4.bind && this.bindElements(i3, n3);
                for (const t5 of n3.getAttributeKeys())
                  this.setDomElementAttribute(i3, t5, n3.getAttribute(t5), n3);
              }
              if (false !== e4.withChildren)
                for (const t5 of this.viewChildrenToDom(n3, e4))
                  i3.appendChild(t5);
              return i3;
            }
          }
          setDomElementAttribute(t4, e4, n3, i3) {
            const o3 = this.shouldRenderAttribute(e4, n3, t4.tagName.toLowerCase()) || i3 && i3.shouldRenderUnsafeAttribute(e4);
            o3 || _2("domconverter-unsafe-attribute-detected", { domElement: t4, key: e4, value: n3 }), Qi2(e4) ? (t4.hasAttribute(e4) && !o3 ? t4.removeAttribute(e4) : t4.hasAttribute(Kc2 + e4) && o3 && t4.removeAttribute(Kc2 + e4), t4.setAttribute(o3 ? e4 : Kc2 + e4, n3)) : _2("domconverter-invalid-attribute-detected", { domElement: t4, key: e4, value: n3 });
          }
          removeDomElementAttribute(t4, e4) {
            e4 != Zc2 && (t4.removeAttribute(e4), t4.removeAttribute(Kc2 + e4));
          }
          *viewChildrenToDom(t4, e4 = {}) {
            const n3 = t4.getFillerOffset && t4.getFillerOffset();
            let i3 = 0;
            for (const o3 of t4.getChildren()) {
              n3 === i3 && (yield this._getBlockFiller());
              const t5 = o3.is("element") && !!o3.getCustomProperty("dataPipeline:transparentRendering") && !So2(o3.getAttributes());
              t5 && "data" == this.renderingMode ? yield* this.viewChildrenToDom(o3, e4) : (t5 && _2("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: o3 }), yield this.viewToDom(o3, e4)), i3++;
            }
            n3 === i3 && (yield this._getBlockFiller());
          }
          viewRangeToDom(t4) {
            const e4 = this.viewPositionToDom(t4.start), n3 = this.viewPositionToDom(t4.end), i3 = this._domDocument.createRange();
            return i3.setStart(e4.parent, e4.offset), i3.setEnd(n3.parent, n3.offset), i3;
          }
          viewPositionToDom(t4) {
            const e4 = t4.parent;
            if (e4.is("$text")) {
              const n3 = this.findCorrespondingDomText(e4);
              if (!n3)
                return null;
              let i3 = t4.offset;
              return Nc2(n3) && (i3 += Bc2), { parent: n3, offset: i3 };
            }
            {
              let n3, i3, o3;
              if (0 === t4.offset) {
                if (n3 = this.mapViewToDom(e4), !n3)
                  return null;
                o3 = n3.childNodes[0];
              } else {
                const e5 = t4.nodeBefore;
                if (i3 = e5.is("$text") ? this.findCorrespondingDomText(e5) : this.mapViewToDom(e5), !i3)
                  return null;
                n3 = i3.parentNode, o3 = i3.nextSibling;
              }
              if (zi2(o3) && Nc2(o3))
                return { parent: o3, offset: Bc2 };
              return { parent: n3, offset: i3 ? Ki2(i3) + 1 : 0 };
            }
          }
          domToView(t4, e4 = {}) {
            const n3 = [], i3 = this._domToView(t4, e4, n3), o3 = i3.next().value;
            return o3 ? (i3.next(), this._processDomInlineNodes(null, n3, e4), o3.is("$text") && 0 == o3.data.length ? null : o3) : null;
          }
          *domChildrenToView(t4, e4 = {}, n3 = []) {
            for (let i3 = 0; i3 < t4.childNodes.length; i3++) {
              const o3 = t4.childNodes[i3], r3 = this._domToView(o3, e4, n3), s3 = r3.next().value;
              null !== s3 && (this._isBlockViewElement(s3) && this._processDomInlineNodes(t4, n3, e4), yield s3, r3.next());
            }
            this._processDomInlineNodes(t4, n3, e4);
          }
          domSelectionToView(t4) {
            if (function(t5) {
              if (!c2.isGecko)
                return false;
              if (!t5.rangeCount)
                return false;
              const e5 = t5.getRangeAt(0).startContainer;
              try {
                Object.prototype.toString.call(e5);
              } catch (t6) {
                return true;
              }
              return false;
            }(t4))
              return new Ya2([]);
            if (1 === t4.rangeCount) {
              let e5 = t4.getRangeAt(0).startContainer;
              zi2(e5) && (e5 = e5.parentNode);
              const n4 = this.fakeSelectionToView(e5);
              if (n4)
                return n4;
            }
            const e4 = this.isDomSelectionBackward(t4), n3 = [];
            for (let e5 = 0; e5 < t4.rangeCount; e5++) {
              const i3 = t4.getRangeAt(e5), o3 = this.domRangeToView(i3);
              o3 && n3.push(o3);
            }
            return new Ya2(n3, { backward: e4 });
          }
          domRangeToView(t4) {
            const e4 = this.domPositionToView(t4.startContainer, t4.startOffset), n3 = this.domPositionToView(t4.endContainer, t4.endOffset);
            return e4 && n3 ? new Ka2(e4, n3) : null;
          }
          domPositionToView(t4, e4 = 0) {
            if (this.isBlockFiller(t4))
              return this.domPositionToView(t4.parentNode, Ki2(t4));
            const n3 = this.mapDomToView(t4);
            if (n3 && (n3.is("uiElement") || n3.is("rawElement")))
              return $a._createBefore(n3);
            if (zi2(t4)) {
              if (Lc2(t4))
                return this.domPositionToView(t4.parentNode, Ki2(t4));
              const n4 = this.findCorrespondingViewText(t4);
              let i3 = e4;
              return n4 ? (Nc2(t4) && (i3 -= Bc2, i3 = i3 < 0 ? 0 : i3), new $a(n4, i3)) : null;
            }
            if (0 === e4) {
              const e5 = this.mapDomToView(t4);
              if (e5)
                return new $a(e5, 0);
            } else {
              const n4 = t4.childNodes[e4 - 1];
              if (zi2(n4) && Lc2(n4) || n4 && this.isBlockFiller(n4))
                return this.domPositionToView(n4.parentNode, Ki2(n4));
              const i3 = zi2(n4) ? this.findCorrespondingViewText(n4) : this.mapDomToView(n4);
              if (i3 && i3.parent)
                return new $a(i3.parent, i3.index + 1);
            }
            return null;
          }
          mapDomToView(t4) {
            return this.getHostViewElement(t4) || this._domToViewMapping.get(t4);
          }
          findCorrespondingViewText(t4) {
            if (Lc2(t4))
              return null;
            const e4 = this.getHostViewElement(t4);
            if (e4)
              return e4;
            const n3 = t4.previousSibling;
            if (n3) {
              if (!this.isElement(n3))
                return null;
              const t5 = this.mapDomToView(n3);
              if (t5) {
                const e5 = t5.nextSibling;
                return e5 instanceof Os ? e5 : null;
              }
            } else {
              const e5 = this.mapDomToView(t4.parentNode);
              if (e5) {
                const t5 = e5.getChild(0);
                return t5 instanceof Os ? t5 : null;
              }
            }
            return null;
          }
          mapViewToDom(t4) {
            return this._viewToDomMapping.get(t4);
          }
          findCorrespondingDomText(t4) {
            const e4 = t4.previousSibling;
            return e4 && this.mapViewToDom(e4) ? this.mapViewToDom(e4).nextSibling : !e4 && t4.parent && this.mapViewToDom(t4.parent) ? this.mapViewToDom(t4.parent).childNodes[0] : null;
          }
          focus(t4) {
            const e4 = this.mapViewToDom(t4);
            if (e4 && e4.ownerDocument.activeElement !== e4) {
              const { scrollX: t5, scrollY: n3 } = Li2.window, i3 = [];
              Jc2(e4, (t6) => {
                const { scrollLeft: e5, scrollTop: n4 } = t6;
                i3.push([e5, n4]);
              }), e4.focus(), Jc2(e4, (t6) => {
                const [e5, n4] = i3.shift();
                t6.scrollLeft = e5, t6.scrollTop = n4;
              }), Li2.window.scrollTo(t5, n3);
            }
          }
          _clearDomSelection() {
            const t4 = this.mapViewToDom(this.document.selection.editableElement);
            if (!t4)
              return;
            const e4 = t4.ownerDocument.defaultView.getSelection(), n3 = this.domSelectionToView(e4);
            n3 && n3.rangeCount > 0 && e4.removeAllRanges();
          }
          isElement(t4) {
            return t4 && t4.nodeType == Node.ELEMENT_NODE;
          }
          isDocumentFragment(t4) {
            return t4 && t4.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
          }
          isBlockFiller(t4) {
            return "br" == this.blockFillerMode ? t4.isEqualNode(Wc2) : !("BR" !== t4.tagName || !Xc2(t4, this.blockElements) || 1 !== t4.parentNode.childNodes.length) || (t4.isEqualNode($c2) || function(t5, e4) {
              const n3 = t5.isEqualNode(qc2);
              return n3 && Xc2(t5, e4) && 1 === t5.parentNode.childNodes.length;
            }(t4, this.blockElements));
          }
          isDomSelectionBackward(t4) {
            if (t4.isCollapsed)
              return false;
            const e4 = this._domDocument.createRange();
            try {
              e4.setStart(t4.anchorNode, t4.anchorOffset), e4.setEnd(t4.focusNode, t4.focusOffset);
            } catch (t5) {
              return false;
            }
            const n3 = e4.collapsed;
            return e4.detach(), n3;
          }
          getHostViewElement(t4) {
            const e4 = function(t5) {
              const e5 = [];
              let n3 = t5;
              for (; n3 && n3.nodeType != Node.DOCUMENT_NODE; )
                e5.unshift(n3), n3 = n3.parentNode;
              return e5;
            }(t4);
            for (e4.pop(); e4.length; ) {
              const t5 = e4.pop(), n3 = this._domToViewMapping.get(t5);
              if (n3 && (n3.is("uiElement") || n3.is("rawElement")))
                return n3;
            }
            return null;
          }
          isDomSelectionCorrect(t4) {
            return this._isDomSelectionPositionCorrect(t4.anchorNode, t4.anchorOffset) && this._isDomSelectionPositionCorrect(t4.focusNode, t4.focusOffset);
          }
          registerRawContentMatcher(t4) {
            this._rawContentElementMatcher.add(t4);
          }
          registerInlineObjectMatcher(t4) {
            this._inlineObjectElementMatcher.add(t4);
          }
          _clearTemporaryCustomProperties() {
            for (const t4 of this._elementsWithTemporaryCustomProperties)
              t4._removeCustomProperty("editingPipeline:doNotReuseOnce");
            this._elementsWithTemporaryCustomProperties.clear();
          }
          _getBlockFiller() {
            switch (this.blockFillerMode) {
              case "nbsp":
                return Sc2(this._domDocument);
              case "markedNbsp":
                return Tc2(this._domDocument);
              case "br":
                return Ic2(this._domDocument);
            }
          }
          _isDomSelectionPositionCorrect(t4, e4) {
            if (zi2(t4) && Nc2(t4) && e4 < Bc2)
              return false;
            if (this.isElement(t4) && Nc2(t4.childNodes[e4]))
              return false;
            const n3 = this.mapDomToView(t4);
            return !n3 || !n3.is("uiElement") && !n3.is("rawElement");
          }
          *_domToView(t4, e4, n3) {
            if (this.isBlockFiller(t4))
              return null;
            const i3 = this.getHostViewElement(t4);
            if (i3)
              return i3;
            if (Yi2(t4) && e4.skipComments)
              return null;
            if (zi2(t4)) {
              if (Lc2(t4))
                return null;
              {
                const e5 = t4.data;
                if ("" === e5)
                  return null;
                const i4 = new Os(this.document, e5);
                return n3.push(i4), i4;
              }
            }
            {
              let i4 = this.mapDomToView(t4);
              if (i4)
                return this._isInlineObjectElement(i4) && n3.push(i4), i4;
              if (this.isDocumentFragment(t4))
                i4 = new fc2(this.document), e4.bind && this.bindDocumentFragments(t4, i4);
              else {
                i4 = this._createViewElement(t4, e4), e4.bind && this.bindElements(t4, i4);
                const o4 = t4.attributes;
                if (o4)
                  for (let t5 = o4.length, e5 = 0; e5 < t5; e5++)
                    i4._setAttribute(o4[e5].name, o4[e5].value);
                if (this._isViewElementWithRawContent(i4, e4))
                  return i4._setCustomProperty("$rawContent", t4.innerHTML), this._isBlockViewElement(i4) || n3.push(i4), i4;
                if (Yi2(t4))
                  return i4._setCustomProperty("$rawContent", t4.data), i4;
              }
              yield i4;
              const o3 = [];
              if (false !== e4.withChildren)
                for (const n4 of this.domChildrenToView(t4, e4, o3))
                  i4._appendChild(n4);
              if (this._isInlineObjectElement(i4))
                n3.push(i4);
              else
                for (const t5 of o3)
                  n3.push(t5);
            }
          }
          _processDomInlineNodes(t4, e4, n3) {
            if (!e4.length)
              return;
            if (t4 && !this.isDocumentFragment(t4) && !this._isBlockDomElement(t4))
              return;
            let i3 = false;
            for (let t5 = 0; t5 < e4.length; t5++) {
              const o3 = e4[t5];
              if (!o3.is("$text")) {
                i3 = false;
                continue;
              }
              let r3, s3 = false;
              if (Qc2(o3, this.preElements))
                r3 = zc2(o3.data);
              else {
                r3 = o3.data.replace(/[ \n\t\r]{1,}/g, " "), s3 = /[^\S\u00A0]/.test(r3.charAt(r3.length - 1));
                const a3 = t5 > 0 ? e4[t5 - 1] : null, c3 = t5 + 1 < e4.length ? e4[t5 + 1] : null, l3 = !a3 || a3.is("element") && "br" == a3.name || i3, d3 = !c3 && !Nc2(o3.data);
                false !== n3.withChildren && (l3 && (r3 = r3.replace(/^ /, "")), d3 && (r3 = r3.replace(/ $/, ""))), r3 = zc2(r3), r3 = r3.replace(/ \u00A0/g, "  ");
                const h3 = c3 && c3.is("element") && "br" != c3.name, u3 = c3 && c3.is("$text") && " " == c3.data.charAt(0);
                (/[ \u00A0]\u00A0$/.test(r3) || !c3 || h3 || u3) && (r3 = r3.replace(/\u00A0$/, " ")), (l3 || a3 && a3.is("element") && "br" != a3.name) && (r3 = r3.replace(/^\u00A0/, " "));
              }
              0 == r3.length && o3.parent ? (o3._remove(), e4.splice(t5, 1), t5--) : (o3._data = r3, i3 = s3);
            }
            e4.length = 0;
          }
          _processDataFromViewText(t4) {
            let e4 = t4.data;
            if (t4.getAncestors().some((t5) => this.preElements.includes(t5.name)))
              return e4;
            if (" " == e4.charAt(0)) {
              const n3 = this._getTouchingInlineViewNode(t4, false);
              !(n3 && n3.is("$textProxy") && this._nodeEndsWithSpace(n3)) && n3 || (e4 = "" + e4.substr(1));
            }
            if (" " == e4.charAt(e4.length - 1)) {
              const n3 = this._getTouchingInlineViewNode(t4, true), i3 = n3 && n3.is("$textProxy") && " " == n3.data.charAt(0);
              " " != e4.charAt(e4.length - 2) && n3 && !i3 || (e4 = e4.substr(0, e4.length - 1) + "");
            }
            return e4.replace(/ {2}/g, " ");
          }
          _nodeEndsWithSpace(t4) {
            if (t4.getAncestors().some((t5) => this.preElements.includes(t5.name)))
              return false;
            const e4 = this._processDataFromViewText(t4);
            return " " == e4.charAt(e4.length - 1);
          }
          _getTouchingInlineViewNode(t4, e4) {
            const n3 = new qa2({ startPosition: e4 ? $a._createAfter(t4) : $a._createBefore(t4), direction: e4 ? "forward" : "backward" });
            for (const t5 of n3) {
              if (t5.item.is("element", "br"))
                return null;
              if (this._isInlineObjectElement(t5.item))
                return t5.item;
              if (t5.item.is("containerElement"))
                return null;
              if (t5.item.is("$textProxy"))
                return t5.item;
            }
            return null;
          }
          _isBlockDomElement(t4) {
            return this.isElement(t4) && this.blockElements.includes(t4.tagName.toLowerCase());
          }
          _isBlockViewElement(t4) {
            return t4.is("element") && this.blockElements.includes(t4.name);
          }
          _isInlineObjectElement(t4) {
            return !!t4.is("element") && ("br" == t4.name || this.inlineObjectElements.includes(t4.name) || !!this._inlineObjectElementMatcher.match(t4));
          }
          _createViewElement(t4, e4) {
            if (Yi2(t4))
              return new hc2(this.document, "$comment");
            const n3 = e4.keepOriginalCase ? t4.tagName : t4.tagName.toLowerCase();
            return new Fa2(this.document, n3);
          }
          _isViewElementWithRawContent(t4, e4) {
            return false !== e4.withChildren && t4.is("element") && !!this._rawContentElementMatcher.match(t4);
          }
          _shouldRenameElement(t4) {
            const e4 = t4.toLowerCase();
            return "editing" === this.renderingMode && this.unsafeElements.includes(e4);
          }
          _createReplacementDomElement(t4, e4) {
            const n3 = this._domDocument.createElement("span");
            if (n3.setAttribute(Zc2, t4), e4) {
              for (; e4.firstChild; )
                n3.appendChild(e4.firstChild);
              for (const t5 of e4.getAttributeNames())
                n3.setAttribute(t5, e4.getAttribute(t5));
            }
            return n3;
          }
        }
        function Qc2(t4, e4) {
          return t4.getAncestors().some((t5) => t5.is("element") && e4.includes(t5.name));
        }
        function Jc2(t4, e4) {
          let n3 = t4;
          for (; n3; )
            e4(n3), n3 = n3.parentElement;
        }
        function Xc2(t4, e4) {
          const n3 = t4.parentNode;
          return !!n3 && !!n3.tagName && e4.includes(n3.tagName.toLowerCase());
        }
        function tl2(t4) {
          "script" === t4 && _2("domconverter-unsafe-script-element-detected"), "style" === t4 && _2("domconverter-unsafe-style-element-detected");
        }
        class el2 extends Ii2() {
          constructor(t4) {
            super(), this._isEnabled = false, this.view = t4, this.document = t4.document;
          }
          get isEnabled() {
            return this._isEnabled;
          }
          enable() {
            this._isEnabled = true;
          }
          disable() {
            this._isEnabled = false;
          }
          destroy() {
            this.disable(), this.stopListening();
          }
          checkShouldIgnoreEventFromTarget(t4) {
            return t4 && 3 === t4.nodeType && (t4 = t4.parentNode), !(!t4 || 1 !== t4.nodeType) && t4.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
          }
        }
        const nl2 = Ba2(function(t4, e4) {
          Ie2(e4, mn(e4), t4);
        });
        class il2 {
          constructor(t4, e4, n3) {
            this.view = t4, this.document = t4.document, this.domEvent = e4, this.domTarget = e4.target, nl2(this, n3);
          }
          get target() {
            return this.view.domConverter.mapDomToView(this.domTarget);
          }
          preventDefault() {
            this.domEvent.preventDefault();
          }
          stopPropagation() {
            this.domEvent.stopPropagation();
          }
        }
        class ol2 extends el2 {
          constructor() {
            super(...arguments), this.useCapture = false;
          }
          observe(t4) {
            ("string" == typeof this.domEventType ? [this.domEventType] : this.domEventType).forEach((e4) => {
              this.listenTo(t4, e4, (t5, e5) => {
                this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e5.target) && this.onDomEvent(e5);
              }, { useCapture: this.useCapture });
            });
          }
          stopObserving(t4) {
            this.stopListening(t4);
          }
          fire(t4, e4, n3) {
            this.isEnabled && this.document.fire(t4, new il2(this.view, e4, n3));
          }
        }
        class rl2 extends ol2 {
          constructor() {
            super(...arguments), this.domEventType = ["keydown", "keyup"];
          }
          onDomEvent(t4) {
            const e4 = { keyCode: t4.keyCode, altKey: t4.altKey, ctrlKey: t4.ctrlKey, shiftKey: t4.shiftKey, metaKey: t4.metaKey, get keystroke() {
              return bo2(this);
            } };
            this.fire(t4.type, t4, e4);
          }
        }
        class sl2 extends el2 {
          constructor(t4) {
            super(t4), this._fireSelectionChangeDoneDebounced = $r((t5) => {
              this.document.fire("selectionChangeDone", t5);
            }, 200);
          }
          observe() {
            const t4 = this.document;
            t4.on("arrowKey", (e4, n3) => {
              t4.selection.isFake && this.isEnabled && n3.preventDefault();
            }, { context: "$capture" }), t4.on("arrowKey", (e4, n3) => {
              t4.selection.isFake && this.isEnabled && this._handleSelectionMove(n3.keyCode);
            }, { priority: "lowest" });
          }
          stopObserving() {
          }
          destroy() {
            super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
          }
          _handleSelectionMove(t4) {
            const e4 = this.document.selection, n3 = new Ya2(e4.getRanges(), { backward: e4.isBackward, fake: false });
            t4 != fo2.arrowleft && t4 != fo2.arrowup || n3.setTo(n3.getFirstPosition()), t4 != fo2.arrowright && t4 != fo2.arrowdown || n3.setTo(n3.getLastPosition());
            const i3 = { oldSelection: e4, newSelection: n3, domSelection: null };
            this.document.fire("selectionChange", i3), this._fireSelectionChangeDoneDebounced(i3);
          }
        }
        const al2 = function(t4) {
          return this.__data__.set(t4, "__lodash_hash_undefined__"), this;
        };
        const cl2 = function(t4) {
          return this.__data__.has(t4);
        };
        function ll2(t4) {
          var e4 = -1, n3 = null == t4 ? 0 : t4.length;
          for (this.__data__ = new Ce2(); ++e4 < n3; )
            this.add(t4[e4]);
        }
        ll2.prototype.add = ll2.prototype.push = al2, ll2.prototype.has = cl2;
        const dl2 = ll2;
        const hl2 = function(t4, e4) {
          for (var n3 = -1, i3 = null == t4 ? 0 : t4.length; ++n3 < i3; )
            if (e4(t4[n3], n3, t4))
              return true;
          return false;
        };
        const ul2 = function(t4, e4) {
          return t4.has(e4);
        };
        const gl2 = function(t4, e4, n3, i3, o3, r3) {
          var s3 = 1 & n3, a3 = t4.length, c3 = e4.length;
          if (a3 != c3 && !(s3 && c3 > a3))
            return false;
          var l3 = r3.get(t4), d3 = r3.get(e4);
          if (l3 && d3)
            return l3 == e4 && d3 == t4;
          var h3 = -1, u3 = true, g3 = 2 & n3 ? new dl2() : void 0;
          for (r3.set(t4, e4), r3.set(e4, t4); ++h3 < a3; ) {
            var m3 = t4[h3], p3 = e4[h3];
            if (i3)
              var f3 = s3 ? i3(p3, m3, h3, e4, t4, r3) : i3(m3, p3, h3, t4, e4, r3);
            if (void 0 !== f3) {
              if (f3)
                continue;
              u3 = false;
              break;
            }
            if (g3) {
              if (!hl2(e4, function(t5, e5) {
                if (!ul2(g3, e5) && (m3 === t5 || o3(m3, t5, n3, i3, r3)))
                  return g3.push(e5);
              })) {
                u3 = false;
                break;
              }
            } else if (m3 !== p3 && !o3(m3, p3, n3, i3, r3)) {
              u3 = false;
              break;
            }
          }
          return r3.delete(t4), r3.delete(e4), u3;
        };
        const ml2 = function(t4) {
          var e4 = -1, n3 = Array(t4.size);
          return t4.forEach(function(t5, i3) {
            n3[++e4] = [i3, t5];
          }), n3;
        };
        const pl2 = function(t4) {
          var e4 = -1, n3 = Array(t4.size);
          return t4.forEach(function(t5) {
            n3[++e4] = t5;
          }), n3;
        };
        var fl2 = rt2 ? rt2.prototype : void 0, kl2 = fl2 ? fl2.valueOf : void 0;
        const bl2 = function(t4, e4, n3, i3, o3, r3, s3) {
          switch (n3) {
            case "[object DataView]":
              if (t4.byteLength != e4.byteLength || t4.byteOffset != e4.byteOffset)
                return false;
              t4 = t4.buffer, e4 = e4.buffer;
            case "[object ArrayBuffer]":
              return !(t4.byteLength != e4.byteLength || !r3(new Jn(t4), new Jn(e4)));
            case "[object Boolean]":
            case "[object Date]":
            case "[object Number]":
              return St2(+t4, +e4);
            case "[object Error]":
              return t4.name == e4.name && t4.message == e4.message;
            case "[object RegExp]":
            case "[object String]":
              return t4 == e4 + "";
            case "[object Map]":
              var a3 = ml2;
            case "[object Set]":
              var c3 = 1 & i3;
              if (a3 || (a3 = pl2), t4.size != e4.size && !c3)
                return false;
              var l3 = s3.get(t4);
              if (l3)
                return l3 == e4;
              i3 |= 2, s3.set(t4, e4);
              var d3 = gl2(a3(t4), a3(e4), i3, o3, r3, s3);
              return s3.delete(t4), d3;
            case "[object Symbol]":
              if (kl2)
                return kl2.call(t4) == kl2.call(e4);
          }
          return false;
        };
        var wl2 = Object.prototype.hasOwnProperty;
        const Al = function(t4, e4, n3, i3, o3, r3) {
          var s3 = 1 & n3, a3 = Mn(t4), c3 = a3.length;
          if (c3 != Mn(e4).length && !s3)
            return false;
          for (var l3 = c3; l3--; ) {
            var d3 = a3[l3];
            if (!(s3 ? d3 in e4 : wl2.call(e4, d3)))
              return false;
          }
          var h3 = r3.get(t4), u3 = r3.get(e4);
          if (h3 && u3)
            return h3 == e4 && u3 == t4;
          var g3 = true;
          r3.set(t4, e4), r3.set(e4, t4);
          for (var m3 = s3; ++l3 < c3; ) {
            var p3 = t4[d3 = a3[l3]], f3 = e4[d3];
            if (i3)
              var k3 = s3 ? i3(f3, p3, d3, e4, t4, r3) : i3(p3, f3, d3, t4, e4, r3);
            if (!(void 0 === k3 ? p3 === f3 || o3(p3, f3, n3, i3, r3) : k3)) {
              g3 = false;
              break;
            }
            m3 || (m3 = "constructor" == d3);
          }
          if (g3 && !m3) {
            var b3 = t4.constructor, w3 = e4.constructor;
            b3 == w3 || !("constructor" in t4) || !("constructor" in e4) || "function" == typeof b3 && b3 instanceof b3 && "function" == typeof w3 && w3 instanceof w3 || (g3 = false);
          }
          return r3.delete(t4), r3.delete(e4), g3;
        };
        var Cl = "[object Arguments]", _l = "[object Array]", vl2 = "[object Object]", yl = Object.prototype.hasOwnProperty;
        const xl = function(t4, e4, n3, i3, o3, r3) {
          var s3 = pt2(t4), a3 = pt2(e4), c3 = s3 ? _l : Zn(t4), l3 = a3 ? _l : Zn(e4), d3 = (c3 = c3 == Cl ? vl2 : c3) == vl2, h3 = (l3 = l3 == Cl ? vl2 : l3) == vl2, u3 = c3 == l3;
          if (u3 && je2(t4)) {
            if (!je2(e4))
              return false;
            s3 = true, d3 = false;
          }
          if (u3 && !d3)
            return r3 || (r3 = new ye2()), s3 || Xe2(t4) ? gl2(t4, e4, n3, i3, o3, r3) : bl2(t4, e4, c3, n3, i3, o3, r3);
          if (!(1 & n3)) {
            var g3 = d3 && yl.call(t4, "__wrapped__"), m3 = h3 && yl.call(e4, "__wrapped__");
            if (g3 || m3) {
              var p3 = g3 ? t4.value() : t4, f3 = m3 ? e4.value() : e4;
              return r3 || (r3 = new ye2()), o3(p3, f3, n3, i3, r3);
            }
          }
          return !!u3 && (r3 || (r3 = new ye2()), Al(t4, e4, n3, i3, o3, r3));
        };
        const El = function t4(e4, n3, i3, o3, r3) {
          return e4 === n3 || (null == e4 || null == n3 || !ft2(e4) && !ft2(n3) ? e4 != e4 && n3 != n3 : xl(e4, n3, i3, o3, t4, r3));
        };
        const Dl = function(t4, e4, n3) {
          var i3 = (n3 = "function" == typeof n3 ? n3 : void 0) ? n3(t4, e4) : void 0;
          return void 0 === i3 ? El(t4, e4, void 0, n3) : !!i3;
        };
        class Sl extends el2 {
          constructor(t4) {
            super(t4), this._config = { childList: true, characterData: true, subtree: true }, this.domConverter = t4.domConverter, this.renderer = t4._renderer, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
          }
          flush() {
            this._onMutations(this._mutationObserver.takeRecords());
          }
          observe(t4) {
            this._domElements.add(t4), this.isEnabled && this._mutationObserver.observe(t4, this._config);
          }
          stopObserving(t4) {
            if (this._domElements.delete(t4), this.isEnabled) {
              this._mutationObserver.disconnect();
              for (const t5 of this._domElements)
                this._mutationObserver.observe(t5, this._config);
            }
          }
          enable() {
            super.enable();
            for (const t4 of this._domElements)
              this._mutationObserver.observe(t4, this._config);
          }
          disable() {
            super.disable(), this._mutationObserver.disconnect();
          }
          destroy() {
            super.destroy(), this._mutationObserver.disconnect();
          }
          _onMutations(t4) {
            if (0 === t4.length)
              return;
            const e4 = this.domConverter, n3 = /* @__PURE__ */ new Set(), i3 = /* @__PURE__ */ new Set();
            for (const n4 of t4) {
              const t5 = e4.mapDomToView(n4.target);
              t5 && (t5.is("uiElement") || t5.is("rawElement") || "childList" !== n4.type || this._isBogusBrMutation(n4) || i3.add(t5));
            }
            for (const o4 of t4) {
              const t5 = e4.mapDomToView(o4.target);
              if ((!t5 || !t5.is("uiElement") && !t5.is("rawElement")) && "characterData" === o4.type) {
                const t6 = e4.findCorrespondingViewText(o4.target);
                t6 && !i3.has(t6.parent) ? n3.add(t6) : !t6 && Nc2(o4.target) && i3.add(e4.mapDomToView(o4.target.parentNode));
              }
            }
            let o3 = false;
            for (const t5 of n3)
              o3 = true, this.renderer.markToSync("text", t5);
            for (const t5 of i3) {
              const n4 = e4.mapViewToDom(t5), i4 = Array.from(t5.getChildren()), r3 = Array.from(e4.domChildrenToView(n4, { withChildren: false }));
              Dl(i4, r3, Tl) || (o3 = true, this.renderer.markToSync("children", t5));
            }
            o3 && this.view.forceRender();
          }
          _isBogusBrMutation(t4) {
            let e4 = null;
            return null === t4.nextSibling && 0 === t4.removedNodes.length && 1 == t4.addedNodes.length && (e4 = this.domConverter.domToView(t4.addedNodes[0], { withChildren: false })), e4 && e4.is("element", "br");
          }
        }
        function Tl(t4, e4) {
          if (!Array.isArray(t4))
            return t4 === e4 || !(!t4.is("$text") || !e4.is("$text")) && t4.data === e4.data;
        }
        class Il extends ol2 {
          constructor(t4) {
            super(t4), this._isFocusChanging = false, this.domEventType = ["focus", "blur"], this.useCapture = true;
            const e4 = this.document;
            e4.on("focus", () => {
              this._isFocusChanging = true, this._renderTimeoutId = setTimeout(() => {
                this.flush(), t4.change(() => {
                });
              }, 50);
            }), e4.on("blur", (n3, i3) => {
              const o3 = e4.selection.editableElement;
              null !== o3 && o3 !== i3.target || (e4.isFocused = false, this._isFocusChanging = false, t4.change(() => {
              }));
            });
          }
          flush() {
            this._isFocusChanging && (this._isFocusChanging = false, this.document.isFocused = true);
          }
          onDomEvent(t4) {
            this.fire(t4.type, t4);
          }
          destroy() {
            this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
          }
        }
        class Bl extends el2 {
          constructor(t4) {
            super(t4), this.mutationObserver = t4.getObserver(Sl), this.focusObserver = t4.getObserver(Il), this.selection = this.document.selection, this.domConverter = t4.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = $r((t5) => {
              this.document.fire("selectionChangeDone", t5);
            }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = $r(() => this.document.isSelecting = false, 5e3), this._loopbackCounter = 0;
          }
          observe(t4) {
            const e4 = t4.ownerDocument, n3 = () => {
              this.document.isSelecting && (this._handleSelectionChange(null, e4), this.document.isSelecting = false, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
            };
            this.listenTo(t4, "selectstart", () => {
              this.document.isSelecting = true, this._documentIsSelectingInactivityTimeoutDebounced();
            }, { priority: "highest" }), this.listenTo(t4, "keydown", n3, { priority: "highest", useCapture: true }), this.listenTo(t4, "keyup", n3, { priority: "highest", useCapture: true }), this._documents.has(e4) || (this.listenTo(e4, "mouseup", n3, { priority: "highest", useCapture: true }), this.listenTo(e4, "selectionchange", (t5, n4) => {
              this.document.isComposing && !c2.isAndroid || (this._handleSelectionChange(n4, e4), this._documentIsSelectingInactivityTimeoutDebounced());
            }), this._documents.add(e4));
          }
          stopObserving(t4) {
            this.stopListening(t4);
          }
          destroy() {
            super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
          }
          _reportInfiniteLoop() {
          }
          _handleSelectionChange(t4, e4) {
            if (!this.isEnabled)
              return;
            const n3 = e4.defaultView.getSelection();
            if (this.checkShouldIgnoreEventFromTarget(n3.anchorNode))
              return;
            this.mutationObserver.flush();
            const i3 = this.domConverter.domSelectionToView(n3);
            if (0 != i3.rangeCount) {
              if (this.view.hasDomSelection = true, this.focusObserver.flush(), !this.selection.isEqual(i3) || !this.domConverter.isDomSelectionCorrect(n3))
                if (++this._loopbackCounter > 60)
                  this._reportInfiniteLoop();
                else if (this.selection.isSimilar(i3))
                  this.view.forceRender();
                else {
                  const t5 = { oldSelection: this.selection, newSelection: i3, domSelection: n3 };
                  this.document.fire("selectionChange", t5), this._fireSelectionChangeDoneDebounced(t5);
                }
            } else
              this.view.hasDomSelection = false;
          }
          _clearInfiniteLoop() {
            this._loopbackCounter = 0;
          }
        }
        class Ml extends ol2 {
          constructor(t4) {
            super(t4), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
            const e4 = this.document;
            e4.on("compositionstart", () => {
              e4.isComposing = true;
            }, { priority: "low" }), e4.on("compositionend", () => {
              e4.isComposing = false;
            }, { priority: "low" });
          }
          onDomEvent(t4) {
            this.fire(t4.type, t4, { data: t4.data });
          }
        }
        class Nl {
          constructor(t4, e4 = {}) {
            this._files = e4.cacheFiles ? Ll(t4) : null, this._native = t4;
          }
          get files() {
            return this._files || (this._files = Ll(this._native)), this._files;
          }
          get types() {
            return this._native.types;
          }
          getData(t4) {
            return this._native.getData(t4);
          }
          setData(t4, e4) {
            this._native.setData(t4, e4);
          }
          set effectAllowed(t4) {
            this._native.effectAllowed = t4;
          }
          get effectAllowed() {
            return this._native.effectAllowed;
          }
          set dropEffect(t4) {
            this._native.dropEffect = t4;
          }
          get dropEffect() {
            return this._native.dropEffect;
          }
          setDragImage(t4, e4, n3) {
            this._native.setDragImage(t4, e4, n3);
          }
          get isCanceled() {
            return "none" == this._native.dropEffect || !!this._native.mozUserCancelled;
          }
        }
        function Ll(t4) {
          const e4 = Array.from(t4.files || []), n3 = Array.from(t4.items || []);
          return e4.length ? e4 : n3.filter((t5) => "file" === t5.kind).map((t5) => t5.getAsFile());
        }
        class zl extends ol2 {
          constructor() {
            super(...arguments), this.domEventType = "beforeinput";
          }
          onDomEvent(t4) {
            const e4 = t4.getTargetRanges(), n3 = this.view, i3 = n3.document;
            let o3 = null, r3 = null, s3 = [];
            if (t4.dataTransfer && (o3 = new Nl(t4.dataTransfer)), null !== t4.data ? r3 = t4.data : o3 && (r3 = o3.getData("text/plain")), i3.selection.isFake)
              s3 = Array.from(i3.selection.getRanges());
            else if (e4.length)
              s3 = e4.map((t5) => {
                const e5 = n3.domConverter.domPositionToView(t5.startContainer, t5.startOffset), i4 = n3.domConverter.domPositionToView(t5.endContainer, t5.endOffset);
                return e5 ? n3.createRange(e5, i4) : i4 ? n3.createRange(i4) : void 0;
              }).filter((t5) => !!t5);
            else if (c2.isAndroid) {
              const e5 = t4.target.ownerDocument.defaultView.getSelection();
              s3 = Array.from(n3.domConverter.domSelectionToView(e5).getRanges());
            }
            if (c2.isAndroid && "insertCompositionText" == t4.inputType && r3 && r3.endsWith("\n"))
              this.fire(t4.type, t4, { inputType: "insertParagraph", targetRanges: [n3.createRange(s3[0].end)] });
            else if ("insertText" == t4.inputType && r3 && r3.includes("\n")) {
              const e5 = r3.split(/\n{1,2}/g);
              let n4 = s3;
              for (let r4 = 0; r4 < e5.length; r4++) {
                const s4 = e5[r4];
                "" != s4 && (this.fire(t4.type, t4, { data: s4, dataTransfer: o3, targetRanges: n4, inputType: t4.inputType, isComposing: t4.isComposing }), n4 = [i3.selection.getFirstRange()]), r4 + 1 < e5.length && (this.fire(t4.type, t4, { inputType: "insertParagraph", targetRanges: n4 }), n4 = [i3.selection.getFirstRange()]);
              }
            } else
              this.fire(t4.type, t4, { data: r3, dataTransfer: o3, targetRanges: s3, inputType: t4.inputType, isComposing: t4.isComposing });
          }
        }
        class Pl extends el2 {
          constructor(t4) {
            super(t4), this.document.on("keydown", (t5, e4) => {
              if (this.isEnabled && ((n3 = e4.keyCode) == fo2.arrowright || n3 == fo2.arrowleft || n3 == fo2.arrowup || n3 == fo2.arrowdown)) {
                const n4 = new Ja2(this.document, "arrowKey", this.document.selection.getFirstRange());
                this.document.fire(n4, e4), n4.stop.called && t5.stop();
              }
              var n3;
            });
          }
          observe() {
          }
          stopObserving() {
          }
        }
        class Rl extends el2 {
          constructor(t4) {
            super(t4);
            const e4 = this.document;
            e4.on("keydown", (t5, n3) => {
              if (!this.isEnabled || n3.keyCode != fo2.tab || n3.ctrlKey)
                return;
              const i3 = new Ja2(e4, "tab", e4.selection.getFirstRange());
              e4.fire(i3, n3), i3.stop.called && t5.stop();
            });
          }
          observe() {
          }
          stopObserving() {
          }
        }
        const Ol = function(t4) {
          return Ci2(t4, 5);
        };
        class Fl extends q2() {
          constructor(t4) {
            super(), this.domRoots = /* @__PURE__ */ new Map(), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = false, this._postFixersInProgress = false, this._renderingDisabled = false, this._hasChangedSinceTheLastRendering = false, this.document = new rc2(t4), this.domConverter = new Yc2(this.document), this.set("isRenderingInProgress", false), this.set("hasDomSelection", false), this._renderer = new Fc2(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new kc2(this.document), this.addObserver(Sl), this.addObserver(Il), this.addObserver(Bl), this.addObserver(rl2), this.addObserver(sl2), this.addObserver(Ml), this.addObserver(Pl), this.addObserver(zl), this.addObserver(Rl), this.document.on("arrowKey", Pc2, { priority: "low" }), uc2(this), this.on("render", () => {
              this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = false;
            }), this.listenTo(this.document.selection, "change", () => {
              this._hasChangedSinceTheLastRendering = true;
            }), this.listenTo(this.document, "change:isFocused", () => {
              this._hasChangedSinceTheLastRendering = true;
            }), c2.isiOS && this.listenTo(this.document, "blur", (t5, e4) => {
              this.domConverter.mapDomToView(e4.domEvent.relatedTarget) || this.domConverter._clearDomSelection();
            });
          }
          attachDomRoot(t4, e4 = "main") {
            const n3 = this.document.getRoot(e4);
            n3._name = t4.tagName.toLowerCase();
            const i3 = {};
            for (const { name: e5, value: o4 } of Array.from(t4.attributes))
              i3[e5] = o4, "class" === e5 ? this._writer.addClass(o4.split(" "), n3) : this._writer.setAttribute(e5, o4, n3);
            this._initialDomRootAttributes.set(t4, i3);
            const o3 = () => {
              this._writer.setAttribute("contenteditable", (!n3.isReadOnly).toString(), n3), n3.isReadOnly ? this._writer.addClass("ck-read-only", n3) : this._writer.removeClass("ck-read-only", n3);
            };
            o3(), this.domRoots.set(e4, t4), this.domConverter.bindElements(t4, n3), this._renderer.markToSync("children", n3), this._renderer.markToSync("attributes", n3), this._renderer.domDocuments.add(t4.ownerDocument), n3.on("change:children", (t5, e5) => this._renderer.markToSync("children", e5)), n3.on("change:attributes", (t5, e5) => this._renderer.markToSync("attributes", e5)), n3.on("change:text", (t5, e5) => this._renderer.markToSync("text", e5)), n3.on("change:isReadOnly", () => this.change(o3)), n3.on("change", () => {
              this._hasChangedSinceTheLastRendering = true;
            });
            for (const n4 of this._observers.values())
              n4.observe(t4, e4);
          }
          detachDomRoot(t4) {
            const e4 = this.domRoots.get(t4);
            Array.from(e4.attributes).forEach(({ name: t5 }) => e4.removeAttribute(t5));
            const n3 = this._initialDomRootAttributes.get(e4);
            for (const t5 in n3)
              e4.setAttribute(t5, n3[t5]);
            this.domRoots.delete(t4), this.domConverter.unbindDomElement(e4);
            for (const t5 of this._observers.values())
              t5.stopObserving(e4);
          }
          getDomRoot(t4 = "main") {
            return this.domRoots.get(t4);
          }
          addObserver(t4) {
            let e4 = this._observers.get(t4);
            if (e4)
              return e4;
            e4 = new t4(this), this._observers.set(t4, e4);
            for (const [t5, n3] of this.domRoots)
              e4.observe(n3, t5);
            return e4.enable(), e4;
          }
          getObserver(t4) {
            return this._observers.get(t4);
          }
          disableObservers() {
            for (const t4 of this._observers.values())
              t4.disable();
          }
          enableObservers() {
            for (const t4 of this._observers.values())
              t4.enable();
          }
          scrollToTheSelection({ alignToTop: t4, forceScroll: e4, viewportOffset: n3 = 20, ancestorOffset: i3 = 20 } = {}) {
            const o3 = this.document.selection.getFirstRange();
            if (!o3)
              return;
            const r3 = Ol({ alignToTop: t4, forceScroll: e4, viewportOffset: n3, ancestorOffset: i3 });
            "number" == typeof n3 && (n3 = { top: n3, bottom: n3, left: n3, right: n3 });
            const s3 = { target: this.domConverter.viewRangeToDom(o3), viewportOffset: n3, ancestorOffset: i3, alignToTop: t4, forceScroll: e4 };
            this.fire("scrollToTheSelection", s3, r3), io2(s3);
          }
          focus() {
            if (!this.document.isFocused) {
              const t4 = this.document.selection.editableElement;
              t4 && (this.domConverter.focus(t4), this.forceRender());
            }
          }
          change(t4) {
            if (this.isRenderingInProgress || this._postFixersInProgress)
              throw new C2("cannot-change-view-tree", this);
            try {
              if (this._ongoingChange)
                return t4(this._writer);
              this._ongoingChange = true;
              const e4 = t4(this._writer);
              return this._ongoingChange = false, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = true, this.document._callPostFixers(this._writer), this._postFixersInProgress = false, this.fire("render")), e4;
            } catch (t5) {
              C2.rethrowUnexpectedError(t5, this);
            }
          }
          forceRender() {
            this._hasChangedSinceTheLastRendering = true, this.getObserver(Il).flush(), this.change(() => {
            });
          }
          destroy() {
            for (const t4 of this._observers.values())
              t4.destroy();
            this.document.destroy(), this.stopListening();
          }
          createPositionAt(t4, e4) {
            return $a._createAt(t4, e4);
          }
          createPositionAfter(t4) {
            return $a._createAfter(t4);
          }
          createPositionBefore(t4) {
            return $a._createBefore(t4);
          }
          createRange(t4, e4) {
            return new Ka2(t4, e4);
          }
          createRangeOn(t4) {
            return Ka2._createOn(t4);
          }
          createRangeIn(t4) {
            return Ka2._createIn(t4);
          }
          createSelection(...t4) {
            return new Ya2(...t4);
          }
          _disableRendering(t4) {
            this._renderingDisabled = t4, 0 == t4 && this.change(() => {
            });
          }
          _render() {
            this.isRenderingInProgress = true, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = false;
          }
        }
        class Vl {
          is() {
            throw new Error("is() method is abstract");
          }
        }
        class jl2 extends Vl {
          constructor(t4) {
            super(), this.parent = null, this._attrs = Bo2(t4);
          }
          get document() {
            return null;
          }
          get index() {
            let t4;
            if (!this.parent)
              return null;
            if (null === (t4 = this.parent.getChildIndex(this)))
              throw new C2("model-node-not-found-in-parent", this);
            return t4;
          }
          get startOffset() {
            let t4;
            if (!this.parent)
              return null;
            if (null === (t4 = this.parent.getChildStartOffset(this)))
              throw new C2("model-node-not-found-in-parent", this);
            return t4;
          }
          get offsetSize() {
            return 1;
          }
          get endOffset() {
            return this.parent ? this.startOffset + this.offsetSize : null;
          }
          get nextSibling() {
            const t4 = this.index;
            return null !== t4 && this.parent.getChild(t4 + 1) || null;
          }
          get previousSibling() {
            const t4 = this.index;
            return null !== t4 && this.parent.getChild(t4 - 1) || null;
          }
          get root() {
            let t4 = this;
            for (; t4.parent; )
              t4 = t4.parent;
            return t4;
          }
          isAttached() {
            return null !== this.parent && this.root.isAttached();
          }
          getPath() {
            const t4 = [];
            let e4 = this;
            for (; e4.parent; )
              t4.unshift(e4.startOffset), e4 = e4.parent;
            return t4;
          }
          getAncestors(t4 = {}) {
            const e4 = [];
            let n3 = t4.includeSelf ? this : this.parent;
            for (; n3; )
              e4[t4.parentFirst ? "push" : "unshift"](n3), n3 = n3.parent;
            return e4;
          }
          getCommonAncestor(t4, e4 = {}) {
            const n3 = this.getAncestors(e4), i3 = t4.getAncestors(e4);
            let o3 = 0;
            for (; n3[o3] == i3[o3] && n3[o3]; )
              o3++;
            return 0 === o3 ? null : n3[o3 - 1];
          }
          isBefore(t4) {
            if (this == t4)
              return false;
            if (this.root !== t4.root)
              return false;
            const e4 = this.getPath(), n3 = t4.getPath(), i3 = tt2(e4, n3);
            switch (i3) {
              case "prefix":
                return true;
              case "extension":
                return false;
              default:
                return e4[i3] < n3[i3];
            }
          }
          isAfter(t4) {
            return this != t4 && (this.root === t4.root && !this.isBefore(t4));
          }
          hasAttribute(t4) {
            return this._attrs.has(t4);
          }
          getAttribute(t4) {
            return this._attrs.get(t4);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          toJSON() {
            const t4 = {};
            return this._attrs.size && (t4.attributes = Array.from(this._attrs).reduce((t5, e4) => (t5[e4[0]] = e4[1], t5), {})), t4;
          }
          _clone(t4) {
            return new this.constructor(this._attrs);
          }
          _remove() {
            this.parent._removeChildren(this.index);
          }
          _setAttribute(t4, e4) {
            this._attrs.set(t4, e4);
          }
          _setAttributesTo(t4) {
            this._attrs = Bo2(t4);
          }
          _removeAttribute(t4) {
            return this._attrs.delete(t4);
          }
          _clearAttributes() {
            this._attrs.clear();
          }
        }
        jl2.prototype.is = function(t4) {
          return "node" === t4 || "model:node" === t4;
        };
        class Hl {
          constructor(t4) {
            this._nodes = [], t4 && this._insertNodes(0, t4);
          }
          [Symbol.iterator]() {
            return this._nodes[Symbol.iterator]();
          }
          get length() {
            return this._nodes.length;
          }
          get maxOffset() {
            return this._nodes.reduce((t4, e4) => t4 + e4.offsetSize, 0);
          }
          getNode(t4) {
            return this._nodes[t4] || null;
          }
          getNodeIndex(t4) {
            const e4 = this._nodes.indexOf(t4);
            return -1 == e4 ? null : e4;
          }
          getNodeStartOffset(t4) {
            const e4 = this.getNodeIndex(t4);
            return null === e4 ? null : this._nodes.slice(0, e4).reduce((t5, e5) => t5 + e5.offsetSize, 0);
          }
          indexToOffset(t4) {
            if (t4 == this._nodes.length)
              return this.maxOffset;
            const e4 = this._nodes[t4];
            if (!e4)
              throw new C2("model-nodelist-index-out-of-bounds", this);
            return this.getNodeStartOffset(e4);
          }
          offsetToIndex(t4) {
            let e4 = 0;
            for (const n3 of this._nodes) {
              if (t4 >= e4 && t4 < e4 + n3.offsetSize)
                return this.getNodeIndex(n3);
              e4 += n3.offsetSize;
            }
            if (e4 != t4)
              throw new C2("model-nodelist-offset-out-of-bounds", this, { offset: t4, nodeList: this });
            return this.length;
          }
          _insertNodes(t4, e4) {
            for (const t5 of e4)
              if (!(t5 instanceof jl2))
                throw new C2("model-nodelist-insertnodes-not-node", this);
            this._nodes = function(t5, e5, n3, i3) {
              if (Math.max(e5.length, t5.length) > 1e4)
                return t5.slice(0, n3).concat(e5).concat(t5.slice(n3 + i3, t5.length));
              {
                const o3 = Array.from(t5);
                return o3.splice(n3, i3, ...e5), o3;
              }
            }(this._nodes, Array.from(e4), t4, 0);
          }
          _removeNodes(t4, e4 = 1) {
            return this._nodes.splice(t4, e4);
          }
          toJSON() {
            return this._nodes.map((t4) => t4.toJSON());
          }
        }
        class Ul extends jl2 {
          constructor(t4, e4) {
            super(e4), this._data = t4 || "";
          }
          get offsetSize() {
            return this.data.length;
          }
          get data() {
            return this._data;
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.data = this.data, t4;
          }
          _clone() {
            return new Ul(this.data, this.getAttributes());
          }
          static fromJSON(t4) {
            return new Ul(t4.data, t4.attributes);
          }
        }
        Ul.prototype.is = function(t4) {
          return "$text" === t4 || "model:$text" === t4 || "text" === t4 || "model:text" === t4 || "node" === t4 || "model:node" === t4;
        };
        class Gl extends Vl {
          constructor(t4, e4, n3) {
            if (super(), this.textNode = t4, e4 < 0 || e4 > t4.offsetSize)
              throw new C2("model-textproxy-wrong-offsetintext", this);
            if (n3 < 0 || e4 + n3 > t4.offsetSize)
              throw new C2("model-textproxy-wrong-length", this);
            this.data = t4.data.substring(e4, e4 + n3), this.offsetInText = e4;
          }
          get startOffset() {
            return null !== this.textNode.startOffset ? this.textNode.startOffset + this.offsetInText : null;
          }
          get offsetSize() {
            return this.data.length;
          }
          get endOffset() {
            return null !== this.startOffset ? this.startOffset + this.offsetSize : null;
          }
          get isPartial() {
            return this.offsetSize !== this.textNode.offsetSize;
          }
          get parent() {
            return this.textNode.parent;
          }
          get root() {
            return this.textNode.root;
          }
          getPath() {
            const t4 = this.textNode.getPath();
            return t4.length > 0 && (t4[t4.length - 1] += this.offsetInText), t4;
          }
          getAncestors(t4 = {}) {
            const e4 = [];
            let n3 = t4.includeSelf ? this : this.parent;
            for (; n3; )
              e4[t4.parentFirst ? "push" : "unshift"](n3), n3 = n3.parent;
            return e4;
          }
          hasAttribute(t4) {
            return this.textNode.hasAttribute(t4);
          }
          getAttribute(t4) {
            return this.textNode.getAttribute(t4);
          }
          getAttributes() {
            return this.textNode.getAttributes();
          }
          getAttributeKeys() {
            return this.textNode.getAttributeKeys();
          }
        }
        Gl.prototype.is = function(t4) {
          return "$textProxy" === t4 || "model:$textProxy" === t4 || "textProxy" === t4 || "model:textProxy" === t4;
        };
        class Wl extends jl2 {
          constructor(t4, e4, n3) {
            super(e4), this._children = new Hl(), this.name = t4, n3 && this._insertChild(0, n3);
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          getChild(t4) {
            return this._children.getNode(t4);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t4) {
            return this._children.getNodeIndex(t4);
          }
          getChildStartOffset(t4) {
            return this._children.getNodeStartOffset(t4);
          }
          offsetToIndex(t4) {
            return this._children.offsetToIndex(t4);
          }
          getNodeByPath(t4) {
            let e4 = this;
            for (const n3 of t4)
              e4 = e4.getChild(e4.offsetToIndex(n3));
            return e4;
          }
          findAncestor(t4, e4 = {}) {
            let n3 = e4.includeSelf ? this : this.parent;
            for (; n3; ) {
              if (n3.name === t4)
                return n3;
              n3 = n3.parent;
            }
            return null;
          }
          toJSON() {
            const t4 = super.toJSON();
            if (t4.name = this.name, this._children.length > 0) {
              t4.children = [];
              for (const e4 of this._children)
                t4.children.push(e4.toJSON());
            }
            return t4;
          }
          _clone(t4 = false) {
            const e4 = t4 ? Array.from(this._children).map((t5) => t5._clone(true)) : void 0;
            return new Wl(this.name, this.getAttributes(), e4);
          }
          _appendChild(t4) {
            this._insertChild(this.childCount, t4);
          }
          _insertChild(t4, e4) {
            const n3 = function(t5) {
              if ("string" == typeof t5)
                return [new Ul(t5)];
              et2(t5) || (t5 = [t5]);
              return Array.from(t5).map((t6) => "string" == typeof t6 ? new Ul(t6) : t6 instanceof Gl ? new Ul(t6.data, t6.getAttributes()) : t6);
            }(e4);
            for (const t5 of n3)
              null !== t5.parent && t5._remove(), t5.parent = this;
            this._children._insertNodes(t4, n3);
          }
          _removeChildren(t4, e4 = 1) {
            const n3 = this._children._removeNodes(t4, e4);
            for (const t5 of n3)
              t5.parent = null;
            return n3;
          }
          static fromJSON(t4) {
            let e4;
            if (t4.children) {
              e4 = [];
              for (const n3 of t4.children)
                n3.name ? e4.push(Wl.fromJSON(n3)) : e4.push(Ul.fromJSON(n3));
            }
            return new Wl(t4.name, t4.attributes, e4);
          }
        }
        Wl.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("element" === t4 || "model:element" === t4) : "element" === t4 || "model:element" === t4 || "node" === t4 || "model:node" === t4;
        };
        class ql2 {
          constructor(t4) {
            if (!t4 || !t4.boundaries && !t4.startPosition)
              throw new C2("model-tree-walker-no-start-position", null);
            const e4 = t4.direction || "forward";
            if ("forward" != e4 && "backward" != e4)
              throw new C2("model-tree-walker-unknown-direction", t4, { direction: e4 });
            this.direction = e4, this.boundaries = t4.boundaries || null, t4.startPosition ? this._position = t4.startPosition.clone() : this._position = Kl._createAt(this.boundaries["backward" == this.direction ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!t4.singleCharacters, this.shallow = !!t4.shallow, this.ignoreElementEnd = !!t4.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
          }
          [Symbol.iterator]() {
            return this;
          }
          get position() {
            return this._position;
          }
          skip(t4) {
            let e4, n3, i3, o3;
            do {
              i3 = this.position, o3 = this._visitedParent, { done: e4, value: n3 } = this.next();
            } while (!e4 && t4(n3));
            e4 || (this._position = i3, this._visitedParent = o3);
          }
          next() {
            return "forward" == this.direction ? this._next() : this._previous();
          }
          _next() {
            const t4 = this.position, e4 = this.position.clone(), n3 = this._visitedParent;
            if (null === n3.parent && e4.offset === n3.maxOffset)
              return { done: true, value: void 0 };
            if (n3 === this._boundaryEndParent && e4.offset == this.boundaries.end.offset)
              return { done: true, value: void 0 };
            const i3 = Zl(e4, n3), o3 = i3 || Yl(e4, n3, i3);
            if (o3 instanceof Wl) {
              if (this.shallow) {
                if (this.boundaries && this.boundaries.end.isBefore(e4))
                  return { done: true, value: void 0 };
                e4.offset++;
              } else
                e4.path.push(0), this._visitedParent = o3;
              return this._position = e4, $l("elementStart", o3, t4, e4, 1);
            }
            if (o3 instanceof Ul) {
              let i4;
              if (this.singleCharacters)
                i4 = 1;
              else {
                let t5 = o3.endOffset;
                this._boundaryEndParent == n3 && this.boundaries.end.offset < t5 && (t5 = this.boundaries.end.offset), i4 = t5 - e4.offset;
              }
              const r3 = e4.offset - o3.startOffset, s3 = new Gl(o3, r3, i4);
              return e4.offset += i4, this._position = e4, $l("text", s3, t4, e4, i4);
            }
            return e4.path.pop(), e4.offset++, this._position = e4, this._visitedParent = n3.parent, this.ignoreElementEnd ? this._next() : $l("elementEnd", n3, t4, e4);
          }
          _previous() {
            const t4 = this.position, e4 = this.position.clone(), n3 = this._visitedParent;
            if (null === n3.parent && 0 === e4.offset)
              return { done: true, value: void 0 };
            if (n3 == this._boundaryStartParent && e4.offset == this.boundaries.start.offset)
              return { done: true, value: void 0 };
            const i3 = e4.parent, o3 = Zl(e4, i3), r3 = o3 || Ql(e4, i3, o3);
            if (r3 instanceof Wl)
              return e4.offset--, this.shallow ? (this._position = e4, $l("elementStart", r3, t4, e4, 1)) : (e4.path.push(r3.maxOffset), this._position = e4, this._visitedParent = r3, this.ignoreElementEnd ? this._previous() : $l("elementEnd", r3, t4, e4));
            if (r3 instanceof Ul) {
              let i4;
              if (this.singleCharacters)
                i4 = 1;
              else {
                let t5 = r3.startOffset;
                this._boundaryStartParent == n3 && this.boundaries.start.offset > t5 && (t5 = this.boundaries.start.offset), i4 = e4.offset - t5;
              }
              const o4 = e4.offset - r3.startOffset, s3 = new Gl(r3, o4 - i4, i4);
              return e4.offset -= i4, this._position = e4, $l("text", s3, t4, e4, i4);
            }
            return e4.path.pop(), this._position = e4, this._visitedParent = n3.parent, $l("elementStart", n3, t4, e4, 1);
          }
        }
        function $l(t4, e4, n3, i3, o3) {
          return { done: false, value: { type: t4, item: e4, previousPosition: n3, nextPosition: i3, length: o3 } };
        }
        class Kl extends Vl {
          constructor(t4, e4, n3 = "toNone") {
            if (super(), !t4.is("element") && !t4.is("documentFragment"))
              throw new C2("model-position-root-invalid", t4);
            if (!(e4 instanceof Array) || 0 === e4.length)
              throw new C2("model-position-path-incorrect-format", t4, { path: e4 });
            t4.is("rootElement") ? e4 = e4.slice() : (e4 = [...t4.getPath(), ...e4], t4 = t4.root), this.root = t4, this.path = e4, this.stickiness = n3;
          }
          get offset() {
            return this.path[this.path.length - 1];
          }
          set offset(t4) {
            this.path[this.path.length - 1] = t4;
          }
          get parent() {
            let t4 = this.root;
            for (let e4 = 0; e4 < this.path.length - 1; e4++)
              if (t4 = t4.getChild(t4.offsetToIndex(this.path[e4])), !t4)
                throw new C2("model-position-path-incorrect", this, { position: this });
            if (t4.is("$text"))
              throw new C2("model-position-path-incorrect", this, { position: this });
            return t4;
          }
          get index() {
            return this.parent.offsetToIndex(this.offset);
          }
          get textNode() {
            return Zl(this, this.parent);
          }
          get nodeAfter() {
            const t4 = this.parent;
            return Yl(this, t4, Zl(this, t4));
          }
          get nodeBefore() {
            const t4 = this.parent;
            return Ql(this, t4, Zl(this, t4));
          }
          get isAtStart() {
            return 0 === this.offset;
          }
          get isAtEnd() {
            return this.offset == this.parent.maxOffset;
          }
          compareWith(t4) {
            if (this.root != t4.root)
              return "different";
            const e4 = tt2(this.path, t4.path);
            switch (e4) {
              case "same":
                return "same";
              case "prefix":
                return "before";
              case "extension":
                return "after";
              default:
                return this.path[e4] < t4.path[e4] ? "before" : "after";
            }
          }
          getLastMatchingPosition(t4, e4 = {}) {
            e4.startPosition = this;
            const n3 = new ql2(e4);
            return n3.skip(t4), n3.position;
          }
          getParentPath() {
            return this.path.slice(0, -1);
          }
          getAncestors() {
            const t4 = this.parent;
            return t4.is("documentFragment") ? [t4] : t4.getAncestors({ includeSelf: true });
          }
          findAncestor(t4) {
            const e4 = this.parent;
            return e4.is("element") ? e4.findAncestor(t4, { includeSelf: true }) : null;
          }
          getCommonPath(t4) {
            if (this.root != t4.root)
              return [];
            const e4 = tt2(this.path, t4.path), n3 = "string" == typeof e4 ? Math.min(this.path.length, t4.path.length) : e4;
            return this.path.slice(0, n3);
          }
          getCommonAncestor(t4) {
            const e4 = this.getAncestors(), n3 = t4.getAncestors();
            let i3 = 0;
            for (; e4[i3] == n3[i3] && e4[i3]; )
              i3++;
            return 0 === i3 ? null : e4[i3 - 1];
          }
          getShiftedBy(t4) {
            const e4 = this.clone(), n3 = e4.offset + t4;
            return e4.offset = n3 < 0 ? 0 : n3, e4;
          }
          isAfter(t4) {
            return "after" == this.compareWith(t4);
          }
          isBefore(t4) {
            return "before" == this.compareWith(t4);
          }
          isEqual(t4) {
            return "same" == this.compareWith(t4);
          }
          isTouching(t4) {
            if (this.root !== t4.root)
              return false;
            const e4 = Math.min(this.path.length, t4.path.length);
            for (let n3 = 0; n3 < e4; n3++) {
              const e5 = this.path[n3] - t4.path[n3];
              if (e5 < -1 || e5 > 1)
                return false;
              if (1 === e5)
                return Jl(t4, this, n3);
              if (-1 === e5)
                return Jl(this, t4, n3);
            }
            return this.path.length === t4.path.length || (this.path.length > t4.path.length ? Xl(this.path, e4) : Xl(t4.path, e4));
          }
          hasSameParentAs(t4) {
            if (this.root !== t4.root)
              return false;
            return "same" == tt2(this.getParentPath(), t4.getParentPath());
          }
          getTransformedByOperation(t4) {
            let e4;
            switch (t4.type) {
              case "insert":
                e4 = this._getTransformedByInsertOperation(t4);
                break;
              case "move":
              case "remove":
              case "reinsert":
                e4 = this._getTransformedByMoveOperation(t4);
                break;
              case "split":
                e4 = this._getTransformedBySplitOperation(t4);
                break;
              case "merge":
                e4 = this._getTransformedByMergeOperation(t4);
                break;
              default:
                e4 = Kl._createAt(this);
            }
            return e4;
          }
          _getTransformedByInsertOperation(t4) {
            return this._getTransformedByInsertion(t4.position, t4.howMany);
          }
          _getTransformedByMoveOperation(t4) {
            return this._getTransformedByMove(t4.sourcePosition, t4.targetPosition, t4.howMany);
          }
          _getTransformedBySplitOperation(t4) {
            const e4 = t4.movedRange;
            return e4.containsPosition(this) || e4.start.isEqual(this) && "toNext" == this.stickiness ? this._getCombined(t4.splitPosition, t4.moveTargetPosition) : t4.graveyardPosition ? this._getTransformedByMove(t4.graveyardPosition, t4.insertionPosition, 1) : this._getTransformedByInsertion(t4.insertionPosition, 1);
          }
          _getTransformedByMergeOperation(t4) {
            const e4 = t4.movedRange;
            let n3;
            return e4.containsPosition(this) || e4.start.isEqual(this) ? (n3 = this._getCombined(t4.sourcePosition, t4.targetPosition), t4.sourcePosition.isBefore(t4.targetPosition) && (n3 = n3._getTransformedByDeletion(t4.deletionPosition, 1))) : n3 = this.isEqual(t4.deletionPosition) ? Kl._createAt(t4.deletionPosition) : this._getTransformedByMove(t4.deletionPosition, t4.graveyardPosition, 1), n3;
          }
          _getTransformedByDeletion(t4, e4) {
            const n3 = Kl._createAt(this);
            if (this.root != t4.root)
              return n3;
            if ("same" == tt2(t4.getParentPath(), this.getParentPath())) {
              if (t4.offset < this.offset) {
                if (t4.offset + e4 > this.offset)
                  return null;
                n3.offset -= e4;
              }
            } else if ("prefix" == tt2(t4.getParentPath(), this.getParentPath())) {
              const i3 = t4.path.length - 1;
              if (t4.offset <= this.path[i3]) {
                if (t4.offset + e4 > this.path[i3])
                  return null;
                n3.path[i3] -= e4;
              }
            }
            return n3;
          }
          _getTransformedByInsertion(t4, e4) {
            const n3 = Kl._createAt(this);
            if (this.root != t4.root)
              return n3;
            if ("same" == tt2(t4.getParentPath(), this.getParentPath()))
              (t4.offset < this.offset || t4.offset == this.offset && "toPrevious" != this.stickiness) && (n3.offset += e4);
            else if ("prefix" == tt2(t4.getParentPath(), this.getParentPath())) {
              const i3 = t4.path.length - 1;
              t4.offset <= this.path[i3] && (n3.path[i3] += e4);
            }
            return n3;
          }
          _getTransformedByMove(t4, e4, n3) {
            if (e4 = e4._getTransformedByDeletion(t4, n3), t4.isEqual(e4))
              return Kl._createAt(this);
            const i3 = this._getTransformedByDeletion(t4, n3);
            return null === i3 || t4.isEqual(this) && "toNext" == this.stickiness || t4.getShiftedBy(n3).isEqual(this) && "toPrevious" == this.stickiness ? this._getCombined(t4, e4) : i3._getTransformedByInsertion(e4, n3);
          }
          _getCombined(t4, e4) {
            const n3 = t4.path.length - 1, i3 = Kl._createAt(e4);
            return i3.stickiness = this.stickiness, i3.offset = i3.offset + this.path[n3] - t4.offset, i3.path = [...i3.path, ...this.path.slice(n3 + 1)], i3;
          }
          toJSON() {
            return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
          }
          clone() {
            return new this.constructor(this.root, this.path, this.stickiness);
          }
          static _createAt(t4, e4, n3 = "toNone") {
            if (t4 instanceof Kl)
              return new Kl(t4.root, t4.path, t4.stickiness);
            {
              const i3 = t4;
              if ("end" == e4)
                e4 = i3.maxOffset;
              else {
                if ("before" == e4)
                  return this._createBefore(i3, n3);
                if ("after" == e4)
                  return this._createAfter(i3, n3);
                if (0 !== e4 && !e4)
                  throw new C2("model-createpositionat-offset-required", [this, t4]);
              }
              if (!i3.is("element") && !i3.is("documentFragment"))
                throw new C2("model-position-parent-incorrect", [this, t4]);
              const o3 = i3.getPath();
              return o3.push(e4), new this(i3.root, o3, n3);
            }
          }
          static _createAfter(t4, e4) {
            if (!t4.parent)
              throw new C2("model-position-after-root", [this, t4], { root: t4 });
            return this._createAt(t4.parent, t4.endOffset, e4);
          }
          static _createBefore(t4, e4) {
            if (!t4.parent)
              throw new C2("model-position-before-root", t4, { root: t4 });
            return this._createAt(t4.parent, t4.startOffset, e4);
          }
          static fromJSON(t4, e4) {
            if ("$graveyard" === t4.root) {
              const n3 = new Kl(e4.graveyard, t4.path);
              return n3.stickiness = t4.stickiness, n3;
            }
            if (!e4.getRoot(t4.root))
              throw new C2("model-position-fromjson-no-root", e4, { rootName: t4.root });
            return new Kl(e4.getRoot(t4.root), t4.path, t4.stickiness);
          }
        }
        function Zl(t4, e4) {
          const n3 = e4.getChild(e4.offsetToIndex(t4.offset));
          return n3 && n3.is("$text") && n3.startOffset < t4.offset ? n3 : null;
        }
        function Yl(t4, e4, n3) {
          return null !== n3 ? null : e4.getChild(e4.offsetToIndex(t4.offset));
        }
        function Ql(t4, e4, n3) {
          return null !== n3 ? null : e4.getChild(e4.offsetToIndex(t4.offset) - 1);
        }
        function Jl(t4, e4, n3) {
          return n3 + 1 !== t4.path.length && (!!Xl(e4.path, n3 + 1) && !!function(t5, e5) {
            let n4 = t5.parent, i3 = t5.path.length - 1, o3 = 0;
            for (; i3 >= e5; ) {
              if (t5.path[i3] + o3 !== n4.maxOffset)
                return false;
              o3 = 1, i3--, n4 = n4.parent;
            }
            return true;
          }(t4, n3 + 1));
        }
        function Xl(t4, e4) {
          for (; e4 < t4.length; ) {
            if (0 !== t4[e4])
              return false;
            e4++;
          }
          return true;
        }
        Kl.prototype.is = function(t4) {
          return "position" === t4 || "model:position" === t4;
        };
        class td2 extends Vl {
          constructor(t4, e4) {
            super(), this.start = Kl._createAt(t4), this.end = e4 ? Kl._createAt(e4) : Kl._createAt(t4), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
          }
          *[Symbol.iterator]() {
            yield* new ql2({ boundaries: this, ignoreElementEnd: true });
          }
          get isCollapsed() {
            return this.start.isEqual(this.end);
          }
          get isFlat() {
            return "same" == tt2(this.start.getParentPath(), this.end.getParentPath());
          }
          get root() {
            return this.start.root;
          }
          containsPosition(t4) {
            return t4.isAfter(this.start) && t4.isBefore(this.end);
          }
          containsRange(t4, e4 = false) {
            t4.isCollapsed && (e4 = false);
            const n3 = this.containsPosition(t4.start) || e4 && this.start.isEqual(t4.start), i3 = this.containsPosition(t4.end) || e4 && this.end.isEqual(t4.end);
            return n3 && i3;
          }
          containsItem(t4) {
            const e4 = Kl._createBefore(t4);
            return this.containsPosition(e4) || this.start.isEqual(e4);
          }
          isEqual(t4) {
            return this.start.isEqual(t4.start) && this.end.isEqual(t4.end);
          }
          isIntersecting(t4) {
            return this.start.isBefore(t4.end) && this.end.isAfter(t4.start);
          }
          getDifference(t4) {
            const e4 = [];
            return this.isIntersecting(t4) ? (this.containsPosition(t4.start) && e4.push(new td2(this.start, t4.start)), this.containsPosition(t4.end) && e4.push(new td2(t4.end, this.end))) : e4.push(new td2(this.start, this.end)), e4;
          }
          getIntersection(t4) {
            if (this.isIntersecting(t4)) {
              let e4 = this.start, n3 = this.end;
              return this.containsPosition(t4.start) && (e4 = t4.start), this.containsPosition(t4.end) && (n3 = t4.end), new td2(e4, n3);
            }
            return null;
          }
          getJoined(t4, e4 = false) {
            let n3 = this.isIntersecting(t4);
            if (n3 || (n3 = this.start.isBefore(t4.start) ? e4 ? this.end.isTouching(t4.start) : this.end.isEqual(t4.start) : e4 ? t4.end.isTouching(this.start) : t4.end.isEqual(this.start)), !n3)
              return null;
            let i3 = this.start, o3 = this.end;
            return t4.start.isBefore(i3) && (i3 = t4.start), t4.end.isAfter(o3) && (o3 = t4.end), new td2(i3, o3);
          }
          getMinimalFlatRanges() {
            const t4 = [], e4 = this.start.getCommonPath(this.end).length, n3 = Kl._createAt(this.start);
            let i3 = n3.parent;
            for (; n3.path.length > e4 + 1; ) {
              const e5 = i3.maxOffset - n3.offset;
              0 !== e5 && t4.push(new td2(n3, n3.getShiftedBy(e5))), n3.path = n3.path.slice(0, -1), n3.offset++, i3 = i3.parent;
            }
            for (; n3.path.length <= this.end.path.length; ) {
              const e5 = this.end.path[n3.path.length - 1], i4 = e5 - n3.offset;
              0 !== i4 && t4.push(new td2(n3, n3.getShiftedBy(i4))), n3.offset = e5, n3.path.push(0);
            }
            return t4;
          }
          getWalker(t4 = {}) {
            return t4.boundaries = this, new ql2(t4);
          }
          *getItems(t4 = {}) {
            t4.boundaries = this, t4.ignoreElementEnd = true;
            const e4 = new ql2(t4);
            for (const t5 of e4)
              yield t5.item;
          }
          *getPositions(t4 = {}) {
            t4.boundaries = this;
            const e4 = new ql2(t4);
            yield e4.position;
            for (const t5 of e4)
              yield t5.nextPosition;
          }
          getTransformedByOperation(t4) {
            switch (t4.type) {
              case "insert":
                return this._getTransformedByInsertOperation(t4);
              case "move":
              case "remove":
              case "reinsert":
                return this._getTransformedByMoveOperation(t4);
              case "split":
                return [this._getTransformedBySplitOperation(t4)];
              case "merge":
                return [this._getTransformedByMergeOperation(t4)];
            }
            return [new td2(this.start, this.end)];
          }
          getTransformedByOperations(t4) {
            const e4 = [new td2(this.start, this.end)];
            for (const n3 of t4)
              for (let t5 = 0; t5 < e4.length; t5++) {
                const i3 = e4[t5].getTransformedByOperation(n3);
                e4.splice(t5, 1, ...i3), t5 += i3.length - 1;
              }
            for (let t5 = 0; t5 < e4.length; t5++) {
              const n3 = e4[t5];
              for (let i3 = t5 + 1; i3 < e4.length; i3++) {
                const t6 = e4[i3];
                (n3.containsRange(t6) || t6.containsRange(n3) || n3.isEqual(t6)) && e4.splice(i3, 1);
              }
            }
            return e4;
          }
          getCommonAncestor() {
            return this.start.getCommonAncestor(this.end);
          }
          getContainedElement() {
            if (this.isCollapsed)
              return null;
            const t4 = this.start.nodeAfter, e4 = this.end.nodeBefore;
            return t4 && t4.is("element") && t4 === e4 ? t4 : null;
          }
          toJSON() {
            return { start: this.start.toJSON(), end: this.end.toJSON() };
          }
          clone() {
            return new this.constructor(this.start, this.end);
          }
          _getTransformedByInsertOperation(t4, e4 = false) {
            return this._getTransformedByInsertion(t4.position, t4.howMany, e4);
          }
          _getTransformedByMoveOperation(t4, e4 = false) {
            const n3 = t4.sourcePosition, i3 = t4.howMany, o3 = t4.targetPosition;
            return this._getTransformedByMove(n3, o3, i3, e4);
          }
          _getTransformedBySplitOperation(t4) {
            const e4 = this.start._getTransformedBySplitOperation(t4);
            let n3 = this.end._getTransformedBySplitOperation(t4);
            return this.end.isEqual(t4.insertionPosition) && (n3 = this.end.getShiftedBy(1)), e4.root != n3.root && (n3 = this.end.getShiftedBy(-1)), new td2(e4, n3);
          }
          _getTransformedByMergeOperation(t4) {
            if (this.start.isEqual(t4.targetPosition) && this.end.isEqual(t4.deletionPosition))
              return new td2(this.start);
            let e4 = this.start._getTransformedByMergeOperation(t4), n3 = this.end._getTransformedByMergeOperation(t4);
            return e4.root != n3.root && (n3 = this.end.getShiftedBy(-1)), e4.isAfter(n3) ? (t4.sourcePosition.isBefore(t4.targetPosition) ? (e4 = Kl._createAt(n3), e4.offset = 0) : (t4.deletionPosition.isEqual(e4) || (n3 = t4.deletionPosition), e4 = t4.targetPosition), new td2(e4, n3)) : new td2(e4, n3);
          }
          _getTransformedByInsertion(t4, e4, n3 = false) {
            if (n3 && this.containsPosition(t4))
              return [new td2(this.start, t4), new td2(t4.getShiftedBy(e4), this.end._getTransformedByInsertion(t4, e4))];
            {
              const n4 = new td2(this.start, this.end);
              return n4.start = n4.start._getTransformedByInsertion(t4, e4), n4.end = n4.end._getTransformedByInsertion(t4, e4), [n4];
            }
          }
          _getTransformedByMove(t4, e4, n3, i3 = false) {
            if (this.isCollapsed) {
              const i4 = this.start._getTransformedByMove(t4, e4, n3);
              return [new td2(i4)];
            }
            const o3 = td2._createFromPositionAndShift(t4, n3), r3 = e4._getTransformedByDeletion(t4, n3);
            if (this.containsPosition(e4) && !i3 && (o3.containsPosition(this.start) || o3.containsPosition(this.end))) {
              const i4 = this.start._getTransformedByMove(t4, e4, n3), o4 = this.end._getTransformedByMove(t4, e4, n3);
              return [new td2(i4, o4)];
            }
            let s3;
            const a3 = this.getDifference(o3);
            let c3 = null;
            const l3 = this.getIntersection(o3);
            if (1 == a3.length ? c3 = new td2(a3[0].start._getTransformedByDeletion(t4, n3), a3[0].end._getTransformedByDeletion(t4, n3)) : 2 == a3.length && (c3 = new td2(this.start, this.end._getTransformedByDeletion(t4, n3))), s3 = c3 ? c3._getTransformedByInsertion(r3, n3, null !== l3 || i3) : [], l3) {
              const t5 = new td2(l3.start._getCombined(o3.start, r3), l3.end._getCombined(o3.start, r3));
              2 == s3.length ? s3.splice(1, 0, t5) : s3.push(t5);
            }
            return s3;
          }
          _getTransformedByDeletion(t4, e4) {
            let n3 = this.start._getTransformedByDeletion(t4, e4), i3 = this.end._getTransformedByDeletion(t4, e4);
            return null == n3 && null == i3 ? null : (null == n3 && (n3 = t4), null == i3 && (i3 = t4), new td2(n3, i3));
          }
          static _createFromPositionAndShift(t4, e4) {
            const n3 = t4, i3 = t4.getShiftedBy(e4);
            return e4 > 0 ? new this(n3, i3) : new this(i3, n3);
          }
          static _createIn(t4) {
            return new this(Kl._createAt(t4, 0), Kl._createAt(t4, t4.maxOffset));
          }
          static _createOn(t4) {
            return this._createFromPositionAndShift(Kl._createBefore(t4), t4.offsetSize);
          }
          static _createFromRanges(t4) {
            if (0 === t4.length)
              throw new C2("range-create-from-ranges-empty-array", null);
            if (1 == t4.length)
              return t4[0].clone();
            const e4 = t4[0];
            t4.sort((t5, e5) => t5.start.isAfter(e5.start) ? 1 : -1);
            const n3 = t4.indexOf(e4), i3 = new this(e4.start, e4.end);
            if (n3 > 0)
              for (let e5 = n3 - 1; t4[e5].end.isEqual(i3.start); e5++)
                i3.start = Kl._createAt(t4[e5].start);
            for (let e5 = n3 + 1; e5 < t4.length && t4[e5].start.isEqual(i3.end); e5++)
              i3.end = Kl._createAt(t4[e5].end);
            return i3;
          }
          static fromJSON(t4, e4) {
            return new this(Kl.fromJSON(t4.start, e4), Kl.fromJSON(t4.end, e4));
          }
        }
        td2.prototype.is = function(t4) {
          return "range" === t4 || "model:range" === t4;
        };
        class ed2 extends B2() {
          constructor() {
            super(), this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (t4, e4) => {
              if (e4.viewPosition)
                return;
              const n3 = this._modelToViewMapping.get(e4.modelPosition.parent);
              if (!n3)
                throw new C2("mapping-model-position-view-parent-not-found", this, { modelPosition: e4.modelPosition });
              e4.viewPosition = this.findPositionIn(n3, e4.modelPosition.offset);
            }, { priority: "low" }), this.on("viewToModelPosition", (t4, e4) => {
              if (e4.modelPosition)
                return;
              const n3 = this.findMappedViewAncestor(e4.viewPosition), i3 = this._viewToModelMapping.get(n3), o3 = this._toModelOffset(e4.viewPosition.parent, e4.viewPosition.offset, n3);
              e4.modelPosition = Kl._createAt(i3, o3);
            }, { priority: "low" });
          }
          bindElements(t4, e4) {
            this._modelToViewMapping.set(t4, e4), this._viewToModelMapping.set(e4, t4);
          }
          unbindViewElement(t4, e4 = {}) {
            const n3 = this.toModelElement(t4);
            if (this._elementToMarkerNames.has(t4))
              for (const e5 of this._elementToMarkerNames.get(t4))
                this._unboundMarkerNames.add(e5);
            e4.defer ? this._deferredBindingRemovals.set(t4, t4.root) : (this._viewToModelMapping.delete(t4), this._modelToViewMapping.get(n3) == t4 && this._modelToViewMapping.delete(n3));
          }
          unbindModelElement(t4) {
            const e4 = this.toViewElement(t4);
            this._modelToViewMapping.delete(t4), this._viewToModelMapping.get(e4) == t4 && this._viewToModelMapping.delete(e4);
          }
          bindElementToMarker(t4, e4) {
            const n3 = this._markerNameToElements.get(e4) || /* @__PURE__ */ new Set();
            n3.add(t4);
            const i3 = this._elementToMarkerNames.get(t4) || /* @__PURE__ */ new Set();
            i3.add(e4), this._markerNameToElements.set(e4, n3), this._elementToMarkerNames.set(t4, i3);
          }
          unbindElementFromMarkerName(t4, e4) {
            const n3 = this._markerNameToElements.get(e4);
            n3 && (n3.delete(t4), 0 == n3.size && this._markerNameToElements.delete(e4));
            const i3 = this._elementToMarkerNames.get(t4);
            i3 && (i3.delete(e4), 0 == i3.size && this._elementToMarkerNames.delete(t4));
          }
          flushUnboundMarkerNames() {
            const t4 = Array.from(this._unboundMarkerNames);
            return this._unboundMarkerNames.clear(), t4;
          }
          flushDeferredBindings() {
            for (const [t4, e4] of this._deferredBindingRemovals)
              t4.root == e4 && this.unbindViewElement(t4);
            this._deferredBindingRemovals = /* @__PURE__ */ new Map();
          }
          clearBindings() {
            this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
          }
          toModelElement(t4) {
            return this._viewToModelMapping.get(t4);
          }
          toViewElement(t4) {
            return this._modelToViewMapping.get(t4);
          }
          toModelRange(t4) {
            return new td2(this.toModelPosition(t4.start), this.toModelPosition(t4.end));
          }
          toViewRange(t4) {
            return new Ka2(this.toViewPosition(t4.start), this.toViewPosition(t4.end));
          }
          toModelPosition(t4) {
            const e4 = { viewPosition: t4, mapper: this };
            return this.fire("viewToModelPosition", e4), e4.modelPosition;
          }
          toViewPosition(t4, e4 = {}) {
            const n3 = { modelPosition: t4, mapper: this, isPhantom: e4.isPhantom };
            return this.fire("modelToViewPosition", n3), n3.viewPosition;
          }
          markerNameToElements(t4) {
            const e4 = this._markerNameToElements.get(t4);
            if (!e4)
              return null;
            const n3 = /* @__PURE__ */ new Set();
            for (const t5 of e4)
              if (t5.is("attributeElement"))
                for (const e5 of t5.getElementsWithSameId())
                  n3.add(e5);
              else
                n3.add(t5);
            return n3;
          }
          registerViewToModelLength(t4, e4) {
            this._viewToModelLengthCallbacks.set(t4, e4);
          }
          findMappedViewAncestor(t4) {
            let e4 = t4.parent;
            for (; !this._viewToModelMapping.has(e4); )
              e4 = e4.parent;
            return e4;
          }
          _toModelOffset(t4, e4, n3) {
            if (n3 != t4) {
              return this._toModelOffset(t4.parent, t4.index, n3) + this._toModelOffset(t4, e4, t4);
            }
            if (t4.is("$text"))
              return e4;
            let i3 = 0;
            for (let n4 = 0; n4 < e4; n4++)
              i3 += this.getModelLength(t4.getChild(n4));
            return i3;
          }
          getModelLength(t4) {
            if (this._viewToModelLengthCallbacks.get(t4.name)) {
              return this._viewToModelLengthCallbacks.get(t4.name)(t4);
            }
            if (this._viewToModelMapping.has(t4))
              return 1;
            if (t4.is("$text"))
              return t4.data.length;
            if (t4.is("uiElement"))
              return 0;
            {
              let e4 = 0;
              for (const n3 of t4.getChildren())
                e4 += this.getModelLength(n3);
              return e4;
            }
          }
          findPositionIn(t4, e4) {
            let n3, i3 = 0, o3 = 0, r3 = 0;
            if (t4.is("$text"))
              return new $a(t4, e4);
            for (; o3 < e4; )
              n3 = t4.getChild(r3), i3 = this.getModelLength(n3), o3 += i3, r3++;
            return o3 == e4 ? this._moveViewPositionToTextNode(new $a(t4, r3)) : this.findPositionIn(n3, e4 - (o3 - i3));
          }
          _moveViewPositionToTextNode(t4) {
            const e4 = t4.nodeBefore, n3 = t4.nodeAfter;
            return e4 instanceof Os ? new $a(e4, e4.data.length) : n3 instanceof Os ? new $a(n3, 0) : t4;
          }
        }
        class nd2 {
          constructor() {
            this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
          }
          add(t4, e4) {
            e4 = id2(e4), t4 instanceof Gl && (t4 = this._getSymbolForTextProxy(t4)), this._consumable.has(t4) || this._consumable.set(t4, /* @__PURE__ */ new Map()), this._consumable.get(t4).set(e4, true);
          }
          consume(t4, e4) {
            return e4 = id2(e4), t4 instanceof Gl && (t4 = this._getSymbolForTextProxy(t4)), !!this.test(t4, e4) && (this._consumable.get(t4).set(e4, false), true);
          }
          test(t4, e4) {
            e4 = id2(e4), t4 instanceof Gl && (t4 = this._getSymbolForTextProxy(t4));
            const n3 = this._consumable.get(t4);
            if (void 0 === n3)
              return null;
            const i3 = n3.get(e4);
            return void 0 === i3 ? null : i3;
          }
          revert(t4, e4) {
            e4 = id2(e4), t4 instanceof Gl && (t4 = this._getSymbolForTextProxy(t4));
            const n3 = this.test(t4, e4);
            return false === n3 ? (this._consumable.get(t4).set(e4, true), true) : true !== n3 && null;
          }
          verifyAllConsumed(t4) {
            const e4 = [];
            for (const [n3, i3] of this._consumable)
              for (const [o3, r3] of i3) {
                const i4 = o3.split(":")[0];
                r3 && t4 == i4 && e4.push({ event: o3, item: n3.name || n3.description });
              }
            if (e4.length)
              throw new C2("conversion-model-consumable-not-consumed", null, { items: e4 });
          }
          _getSymbolForTextProxy(t4) {
            let e4 = null;
            const n3 = this._textProxyRegistry.get(t4.startOffset);
            if (n3) {
              const i3 = n3.get(t4.endOffset);
              i3 && (e4 = i3.get(t4.parent));
            }
            return e4 || (e4 = this._addSymbolForTextProxy(t4)), e4;
          }
          _addSymbolForTextProxy(t4) {
            const e4 = t4.startOffset, n3 = t4.endOffset, i3 = t4.parent, o3 = Symbol("$textProxy:" + t4.data);
            let r3, s3;
            return r3 = this._textProxyRegistry.get(e4), r3 || (r3 = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(e4, r3)), s3 = r3.get(n3), s3 || (s3 = /* @__PURE__ */ new Map(), r3.set(n3, s3)), s3.set(i3, o3), o3;
          }
        }
        function id2(t4) {
          const e4 = t4.split(":");
          return "insert" == e4[0] ? e4[0] : "addMarker" == e4[0] || "removeMarker" == e4[0] ? t4 : e4.length > 1 ? e4[0] + ":" + e4[1] : e4[0];
        }
        class od2 extends B2() {
          constructor(t4) {
            super(), this._conversionApi = { dispatcher: this, ...t4 }, this._firedEventsMap = /* @__PURE__ */ new WeakMap();
          }
          convertChanges(t4, e4, n3) {
            const i3 = this._createConversionApi(n3, t4.getRefreshedItems());
            for (const e5 of t4.getMarkersToRemove())
              this._convertMarkerRemove(e5.name, e5.range, i3);
            const o3 = this._reduceChanges(t4.getChanges());
            for (const t5 of o3)
              "insert" === t5.type ? this._convertInsert(td2._createFromPositionAndShift(t5.position, t5.length), i3) : "reinsert" === t5.type ? this._convertReinsert(td2._createFromPositionAndShift(t5.position, t5.length), i3) : "remove" === t5.type ? this._convertRemove(t5.position, t5.length, t5.name, i3) : this._convertAttribute(t5.range, t5.attributeKey, t5.attributeOldValue, t5.attributeNewValue, i3);
            for (const t5 of i3.mapper.flushUnboundMarkerNames()) {
              const n4 = e4.get(t5).getRange();
              this._convertMarkerRemove(t5, n4, i3), this._convertMarkerAdd(t5, n4, i3);
            }
            for (const e5 of t4.getMarkersToAdd())
              this._convertMarkerAdd(e5.name, e5.range, i3);
            i3.mapper.flushDeferredBindings(), i3.consumable.verifyAllConsumed("insert");
          }
          convert(t4, e4, n3, i3 = {}) {
            const o3 = this._createConversionApi(n3, void 0, i3);
            this._convertInsert(t4, o3);
            for (const [t5, n4] of e4)
              this._convertMarkerAdd(t5, n4, o3);
            o3.consumable.verifyAllConsumed("insert");
          }
          convertSelection(t4, e4, n3) {
            const i3 = this._createConversionApi(n3);
            this.fire("cleanSelection", { selection: t4 }, i3);
            const o3 = t4.getFirstPosition().root;
            if (!i3.mapper.toViewElement(o3))
              return;
            const r3 = Array.from(e4.getMarkersAtPosition(t4.getFirstPosition()));
            if (this._addConsumablesForSelection(i3.consumable, t4, r3), this.fire("selection", { selection: t4 }, i3), t4.isCollapsed) {
              for (const e5 of r3)
                if (i3.consumable.test(t4, "addMarker:" + e5.name)) {
                  const n4 = e5.getRange();
                  if (!rd2(t4.getFirstPosition(), e5, i3.mapper))
                    continue;
                  const o4 = { item: t4, markerName: e5.name, markerRange: n4 };
                  this.fire(`addMarker:${e5.name}`, o4, i3);
                }
              for (const e5 of t4.getAttributeKeys())
                if (i3.consumable.test(t4, "attribute:" + e5)) {
                  const n4 = { item: t4, range: t4.getFirstRange(), attributeKey: e5, attributeOldValue: null, attributeNewValue: t4.getAttribute(e5) };
                  this.fire(`attribute:${e5}:$text`, n4, i3);
                }
            }
          }
          _convertInsert(t4, e4, n3 = {}) {
            n3.doNotAddConsumables || this._addConsumablesForInsert(e4.consumable, t4);
            for (const n4 of Array.from(t4.getWalker({ shallow: true })).map(sd2))
              this._testAndFire("insert", n4, e4);
          }
          _convertRemove(t4, e4, n3, i3) {
            this.fire(`remove:${n3}`, { position: t4, length: e4 }, i3);
          }
          _convertAttribute(t4, e4, n3, i3, o3) {
            this._addConsumablesForRange(o3.consumable, t4, `attribute:${e4}`);
            for (const r3 of t4) {
              const t5 = { item: r3.item, range: td2._createFromPositionAndShift(r3.previousPosition, r3.length), attributeKey: e4, attributeOldValue: n3, attributeNewValue: i3 };
              this._testAndFire(`attribute:${e4}`, t5, o3);
            }
          }
          _convertReinsert(t4, e4) {
            const n3 = Array.from(t4.getWalker({ shallow: true }));
            this._addConsumablesForInsert(e4.consumable, n3);
            for (const t5 of n3.map(sd2))
              this._testAndFire("insert", { ...t5, reconversion: true }, e4);
          }
          _convertMarkerAdd(t4, e4, n3) {
            if ("$graveyard" == e4.root.rootName)
              return;
            const i3 = `addMarker:${t4}`;
            if (n3.consumable.add(e4, i3), this.fire(i3, { markerName: t4, markerRange: e4 }, n3), n3.consumable.consume(e4, i3)) {
              this._addConsumablesForRange(n3.consumable, e4, i3);
              for (const o3 of e4.getItems()) {
                if (!n3.consumable.test(o3, i3))
                  continue;
                const r3 = { item: o3, range: td2._createOn(o3), markerName: t4, markerRange: e4 };
                this.fire(i3, r3, n3);
              }
            }
          }
          _convertMarkerRemove(t4, e4, n3) {
            "$graveyard" != e4.root.rootName && this.fire(`removeMarker:${t4}`, { markerName: t4, markerRange: e4 }, n3);
          }
          _reduceChanges(t4) {
            const e4 = { changes: t4 };
            return this.fire("reduceChanges", e4), e4.changes;
          }
          _addConsumablesForInsert(t4, e4) {
            for (const n3 of e4) {
              const e5 = n3.item;
              if (null === t4.test(e5, "insert")) {
                t4.add(e5, "insert");
                for (const n4 of e5.getAttributeKeys())
                  t4.add(e5, "attribute:" + n4);
              }
            }
            return t4;
          }
          _addConsumablesForRange(t4, e4, n3) {
            for (const i3 of e4.getItems())
              t4.add(i3, n3);
            return t4;
          }
          _addConsumablesForSelection(t4, e4, n3) {
            t4.add(e4, "selection");
            for (const i3 of n3)
              t4.add(e4, "addMarker:" + i3.name);
            for (const n4 of e4.getAttributeKeys())
              t4.add(e4, "attribute:" + n4);
            return t4;
          }
          _testAndFire(t4, e4, n3) {
            const i3 = function(t5, e5) {
              const n4 = e5.item.is("element") ? e5.item.name : "$text";
              return `${t5}:${n4}`;
            }(t4, e4), o3 = e4.item.is("$textProxy") ? n3.consumable._getSymbolForTextProxy(e4.item) : e4.item, r3 = this._firedEventsMap.get(n3), s3 = r3.get(o3);
            if (s3) {
              if (s3.has(i3))
                return;
              s3.add(i3);
            } else
              r3.set(o3, /* @__PURE__ */ new Set([i3]));
            this.fire(i3, e4, n3);
          }
          _testAndFireAddAttributes(t4, e4) {
            const n3 = { item: t4, range: td2._createOn(t4) };
            for (const t5 of n3.item.getAttributeKeys())
              n3.attributeKey = t5, n3.attributeOldValue = null, n3.attributeNewValue = n3.item.getAttribute(t5), this._testAndFire(`attribute:${t5}`, n3, e4);
          }
          _createConversionApi(t4, e4 = /* @__PURE__ */ new Set(), n3 = {}) {
            const i3 = { ...this._conversionApi, consumable: new nd2(), writer: t4, options: n3, convertItem: (t5) => this._convertInsert(td2._createOn(t5), i3), convertChildren: (t5) => this._convertInsert(td2._createIn(t5), i3, { doNotAddConsumables: true }), convertAttributes: (t5) => this._testAndFireAddAttributes(t5, i3), canReuseView: (t5) => !e4.has(i3.mapper.toModelElement(t5)) };
            return this._firedEventsMap.set(i3, /* @__PURE__ */ new Map()), i3;
          }
        }
        function rd2(t4, e4, n3) {
          const i3 = e4.getRange(), o3 = Array.from(t4.getAncestors());
          o3.shift(), o3.reverse();
          return !o3.some((t5) => {
            if (i3.containsItem(t5)) {
              return !!n3.toViewElement(t5).getCustomProperty("addHighlight");
            }
          });
        }
        function sd2(t4) {
          return { item: t4.item, range: td2._createFromPositionAndShift(t4.previousPosition, t4.length) };
        }
        class ad2 extends B2(Vl) {
          constructor(...t4) {
            super(), this._lastRangeBackward = false, this._attrs = /* @__PURE__ */ new Map(), this._ranges = [], t4.length && this.setTo(...t4);
          }
          get anchor() {
            if (this._ranges.length > 0) {
              const t4 = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t4.end : t4.start;
            }
            return null;
          }
          get focus() {
            if (this._ranges.length > 0) {
              const t4 = this._ranges[this._ranges.length - 1];
              return this._lastRangeBackward ? t4.start : t4.end;
            }
            return null;
          }
          get isCollapsed() {
            return 1 === this._ranges.length && this._ranges[0].isCollapsed;
          }
          get rangeCount() {
            return this._ranges.length;
          }
          get isBackward() {
            return !this.isCollapsed && this._lastRangeBackward;
          }
          isEqual(t4) {
            if (this.rangeCount != t4.rangeCount)
              return false;
            if (0 === this.rangeCount)
              return true;
            if (!this.anchor.isEqual(t4.anchor) || !this.focus.isEqual(t4.focus))
              return false;
            for (const e4 of this._ranges) {
              let n3 = false;
              for (const i3 of t4._ranges)
                if (e4.isEqual(i3)) {
                  n3 = true;
                  break;
                }
              if (!n3)
                return false;
            }
            return true;
          }
          *getRanges() {
            for (const t4 of this._ranges)
              yield new td2(t4.start, t4.end);
          }
          getFirstRange() {
            let t4 = null;
            for (const e4 of this._ranges)
              t4 && !e4.start.isBefore(t4.start) || (t4 = e4);
            return t4 ? new td2(t4.start, t4.end) : null;
          }
          getLastRange() {
            let t4 = null;
            for (const e4 of this._ranges)
              t4 && !e4.end.isAfter(t4.end) || (t4 = e4);
            return t4 ? new td2(t4.start, t4.end) : null;
          }
          getFirstPosition() {
            const t4 = this.getFirstRange();
            return t4 ? t4.start.clone() : null;
          }
          getLastPosition() {
            const t4 = this.getLastRange();
            return t4 ? t4.end.clone() : null;
          }
          setTo(...t4) {
            let [e4, n3, i3] = t4;
            if ("object" == typeof n3 && (i3 = n3, n3 = void 0), null === e4)
              this._setRanges([]);
            else if (e4 instanceof ad2)
              this._setRanges(e4.getRanges(), e4.isBackward);
            else if (e4 && "function" == typeof e4.getRanges)
              this._setRanges(e4.getRanges(), e4.isBackward);
            else if (e4 instanceof td2)
              this._setRanges([e4], !!i3 && !!i3.backward);
            else if (e4 instanceof Kl)
              this._setRanges([new td2(e4)]);
            else if (e4 instanceof jl2) {
              const t5 = !!i3 && !!i3.backward;
              let o3;
              if ("in" == n3)
                o3 = td2._createIn(e4);
              else if ("on" == n3)
                o3 = td2._createOn(e4);
              else {
                if (void 0 === n3)
                  throw new C2("model-selection-setto-required-second-parameter", [this, e4]);
                o3 = new td2(Kl._createAt(e4, n3));
              }
              this._setRanges([o3], t5);
            } else {
              if (!et2(e4))
                throw new C2("model-selection-setto-not-selectable", [this, e4]);
              this._setRanges(e4, i3 && !!i3.backward);
            }
          }
          _setRanges(t4, e4 = false) {
            const n3 = Array.from(t4), i3 = n3.some((e5) => {
              if (!(e5 instanceof td2))
                throw new C2("model-selection-set-ranges-not-range", [this, t4]);
              return this._ranges.every((t5) => !t5.isEqual(e5));
            });
            (n3.length !== this._ranges.length || i3) && (this._replaceAllRanges(n3), this._lastRangeBackward = !!e4, this.fire("change:range", { directChange: true }));
          }
          setFocus(t4, e4) {
            if (null === this.anchor)
              throw new C2("model-selection-setfocus-no-ranges", [this, t4]);
            const n3 = Kl._createAt(t4, e4);
            if ("same" == n3.compareWith(this.focus))
              return;
            const i3 = this.anchor;
            this._ranges.length && this._popRange(), "before" == n3.compareWith(i3) ? (this._pushRange(new td2(n3, i3)), this._lastRangeBackward = true) : (this._pushRange(new td2(i3, n3)), this._lastRangeBackward = false), this.fire("change:range", { directChange: true });
          }
          getAttribute(t4) {
            return this._attrs.get(t4);
          }
          getAttributes() {
            return this._attrs.entries();
          }
          getAttributeKeys() {
            return this._attrs.keys();
          }
          hasAttribute(t4) {
            return this._attrs.has(t4);
          }
          removeAttribute(t4) {
            this.hasAttribute(t4) && (this._attrs.delete(t4), this.fire("change:attribute", { attributeKeys: [t4], directChange: true }));
          }
          setAttribute(t4, e4) {
            this.getAttribute(t4) !== e4 && (this._attrs.set(t4, e4), this.fire("change:attribute", { attributeKeys: [t4], directChange: true }));
          }
          getSelectedElement() {
            return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
          }
          *getSelectedBlocks() {
            const t4 = /* @__PURE__ */ new WeakSet();
            for (const e4 of this.getRanges()) {
              const n3 = dd2(e4.start, t4);
              ud2(n3, e4) && (yield n3);
              for (const n4 of e4.getWalker()) {
                const i4 = n4.item;
                "elementEnd" == n4.type && ld2(i4, t4, e4) && (yield i4);
              }
              const i3 = dd2(e4.end, t4);
              gd2(i3, e4) && (yield i3);
            }
          }
          containsEntireContent(t4 = this.anchor.root) {
            const e4 = Kl._createAt(t4, 0), n3 = Kl._createAt(t4, "end");
            return e4.isTouching(this.getFirstPosition()) && n3.isTouching(this.getLastPosition());
          }
          _pushRange(t4) {
            this._checkRange(t4), this._ranges.push(new td2(t4.start, t4.end));
          }
          _checkRange(t4) {
            for (let e4 = 0; e4 < this._ranges.length; e4++)
              if (t4.isIntersecting(this._ranges[e4]))
                throw new C2("model-selection-range-intersects", [this, t4], { addedRange: t4, intersectingRange: this._ranges[e4] });
          }
          _replaceAllRanges(t4) {
            this._removeAllRanges();
            for (const e4 of t4)
              this._pushRange(e4);
          }
          _removeAllRanges() {
            for (; this._ranges.length > 0; )
              this._popRange();
          }
          _popRange() {
            this._ranges.pop();
          }
        }
        function cd2(t4, e4) {
          return !e4.has(t4) && (e4.add(t4), t4.root.document.model.schema.isBlock(t4) && !!t4.parent);
        }
        function ld2(t4, e4, n3) {
          return cd2(t4, e4) && hd2(t4, n3);
        }
        function dd2(t4, e4) {
          const n3 = t4.parent.root.document.model.schema, i3 = t4.parent.getAncestors({ parentFirst: true, includeSelf: true });
          let o3 = false;
          const r3 = i3.find((t5) => !o3 && (o3 = n3.isLimit(t5), !o3 && cd2(t5, e4)));
          return i3.forEach((t5) => e4.add(t5)), r3;
        }
        function hd2(t4, e4) {
          const n3 = function(t5) {
            const e5 = t5.root.document.model.schema;
            let n4 = t5.parent;
            for (; n4; ) {
              if (e5.isBlock(n4))
                return n4;
              n4 = n4.parent;
            }
          }(t4);
          if (!n3)
            return true;
          return !e4.containsRange(td2._createOn(n3), true);
        }
        function ud2(t4, e4) {
          return !!t4 && (!(!e4.isCollapsed && !t4.isEmpty) || !e4.start.isTouching(Kl._createAt(t4, t4.maxOffset)) && hd2(t4, e4));
        }
        function gd2(t4, e4) {
          return !!t4 && (!(!e4.isCollapsed && !t4.isEmpty) || !e4.end.isTouching(Kl._createAt(t4, 0)) && hd2(t4, e4));
        }
        ad2.prototype.is = function(t4) {
          return "selection" === t4 || "model:selection" === t4;
        };
        class md2 extends B2(td2) {
          constructor(t4, e4) {
            super(t4, e4), pd2.call(this);
          }
          detach() {
            this.stopListening();
          }
          toRange() {
            return new td2(this.start, this.end);
          }
          static fromRange(t4) {
            return new md2(t4.start, t4.end);
          }
        }
        function pd2() {
          this.listenTo(this.root.document.model, "applyOperation", (t4, e4) => {
            const n3 = e4[0];
            n3.isDocumentOperation && fd2.call(this, n3);
          }, { priority: "low" });
        }
        function fd2(t4) {
          const e4 = this.getTransformedByOperation(t4), n3 = td2._createFromRanges(e4), i3 = !n3.isEqual(this), o3 = function(t5, e5) {
            switch (e5.type) {
              case "insert":
                return t5.containsPosition(e5.position);
              case "move":
              case "remove":
              case "reinsert":
              case "merge":
                return t5.containsPosition(e5.sourcePosition) || t5.start.isEqual(e5.sourcePosition) || t5.containsPosition(e5.targetPosition);
              case "split":
                return t5.containsPosition(e5.splitPosition) || t5.containsPosition(e5.insertionPosition);
            }
            return false;
          }(this, t4);
          let r3 = null;
          if (i3) {
            "$graveyard" == n3.root.rootName && (r3 = "remove" == t4.type ? t4.sourcePosition : t4.deletionPosition);
            const e5 = this.toRange();
            this.start = n3.start, this.end = n3.end, this.fire("change:range", e5, { deletionPosition: r3 });
          } else
            o3 && this.fire("change:content", this.toRange(), { deletionPosition: r3 });
        }
        md2.prototype.is = function(t4) {
          return "liveRange" === t4 || "model:liveRange" === t4 || "range" == t4 || "model:range" === t4;
        };
        const kd2 = "selection:";
        class bd2 extends B2(Vl) {
          constructor(t4) {
            super(), this._selection = new wd2(t4), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
          }
          get isCollapsed() {
            return this._selection.isCollapsed;
          }
          get anchor() {
            return this._selection.anchor;
          }
          get focus() {
            return this._selection.focus;
          }
          get rangeCount() {
            return this._selection.rangeCount;
          }
          get hasOwnRange() {
            return this._selection.hasOwnRange;
          }
          get isBackward() {
            return this._selection.isBackward;
          }
          get isGravityOverridden() {
            return this._selection.isGravityOverridden;
          }
          get markers() {
            return this._selection.markers;
          }
          get _ranges() {
            return this._selection._ranges;
          }
          getRanges() {
            return this._selection.getRanges();
          }
          getFirstPosition() {
            return this._selection.getFirstPosition();
          }
          getLastPosition() {
            return this._selection.getLastPosition();
          }
          getFirstRange() {
            return this._selection.getFirstRange();
          }
          getLastRange() {
            return this._selection.getLastRange();
          }
          getSelectedBlocks() {
            return this._selection.getSelectedBlocks();
          }
          getSelectedElement() {
            return this._selection.getSelectedElement();
          }
          containsEntireContent(t4) {
            return this._selection.containsEntireContent(t4);
          }
          destroy() {
            this._selection.destroy();
          }
          getAttributeKeys() {
            return this._selection.getAttributeKeys();
          }
          getAttributes() {
            return this._selection.getAttributes();
          }
          getAttribute(t4) {
            return this._selection.getAttribute(t4);
          }
          hasAttribute(t4) {
            return this._selection.hasAttribute(t4);
          }
          refresh() {
            this._selection.updateMarkers(), this._selection._updateAttributes(false);
          }
          observeMarkers(t4) {
            this._selection.observeMarkers(t4);
          }
          _setFocus(t4, e4) {
            this._selection.setFocus(t4, e4);
          }
          _setTo(...t4) {
            this._selection.setTo(...t4);
          }
          _setAttribute(t4, e4) {
            this._selection.setAttribute(t4, e4);
          }
          _removeAttribute(t4) {
            this._selection.removeAttribute(t4);
          }
          _getStoredAttributes() {
            return this._selection.getStoredAttributes();
          }
          _overrideGravity() {
            return this._selection.overrideGravity();
          }
          _restoreGravity(t4) {
            this._selection.restoreGravity(t4);
          }
          static _getStoreAttributeKey(t4) {
            return kd2 + t4;
          }
          static _isStoreAttributeKey(t4) {
            return t4.startsWith(kd2);
          }
        }
        bd2.prototype.is = function(t4) {
          return "selection" === t4 || "model:selection" == t4 || "documentSelection" == t4 || "model:documentSelection" == t4;
        };
        class wd2 extends ad2 {
          constructor(t4) {
            super(), this.markers = new Do2({ idProperty: "name" }), this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = false, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this._model = t4.model, this._document = t4, this.listenTo(this._model, "applyOperation", (t5, e4) => {
              const n3 = e4[0];
              n3.isDocumentOperation && "marker" != n3.type && "rename" != n3.type && "noop" != n3.type && (0 == this._ranges.length && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = false, this.fire("change:range", { directChange: false })));
            }, { priority: "lowest" }), this.on("change:range", () => {
              this._validateSelectionRanges(this.getRanges());
            }), this.listenTo(this._model.markers, "update", (t5, e4, n3, i3) => {
              this._updateMarker(e4, i3);
            }), this.listenTo(this._document, "change", (t5, e4) => {
              !function(t6, e5) {
                const n3 = t6.document.differ;
                for (const i3 of n3.getChanges()) {
                  if ("insert" != i3.type)
                    continue;
                  const n4 = i3.position.parent;
                  i3.length === n4.maxOffset && t6.enqueueChange(e5, (t7) => {
                    const e6 = Array.from(n4.getAttributeKeys()).filter((t8) => t8.startsWith(kd2));
                    for (const i4 of e6)
                      t7.removeAttribute(i4, n4);
                  });
                }
              }(this._model, e4);
            });
          }
          get isCollapsed() {
            return 0 === this._ranges.length ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
          }
          get anchor() {
            return super.anchor || this._document._getDefaultRange().start;
          }
          get focus() {
            return super.focus || this._document._getDefaultRange().end;
          }
          get rangeCount() {
            return this._ranges.length ? this._ranges.length : 1;
          }
          get hasOwnRange() {
            return this._ranges.length > 0;
          }
          get isGravityOverridden() {
            return !!this._overriddenGravityRegister.size;
          }
          destroy() {
            for (let t4 = 0; t4 < this._ranges.length; t4++)
              this._ranges[t4].detach();
            this.stopListening();
          }
          *getRanges() {
            this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
          }
          getFirstRange() {
            return super.getFirstRange() || this._document._getDefaultRange();
          }
          getLastRange() {
            return super.getLastRange() || this._document._getDefaultRange();
          }
          setTo(...t4) {
            super.setTo(...t4), this._updateAttributes(true), this.updateMarkers();
          }
          setFocus(t4, e4) {
            super.setFocus(t4, e4), this._updateAttributes(true), this.updateMarkers();
          }
          setAttribute(t4, e4) {
            if (this._setAttribute(t4, e4)) {
              const e5 = [t4];
              this.fire("change:attribute", { attributeKeys: e5, directChange: true });
            }
          }
          removeAttribute(t4) {
            if (this._removeAttribute(t4)) {
              const e4 = [t4];
              this.fire("change:attribute", { attributeKeys: e4, directChange: true });
            }
          }
          overrideGravity() {
            const t4 = k2();
            return this._overriddenGravityRegister.add(t4), 1 === this._overriddenGravityRegister.size && this._updateAttributes(true), t4;
          }
          restoreGravity(t4) {
            if (!this._overriddenGravityRegister.has(t4))
              throw new C2("document-selection-gravity-wrong-restore", this, { uid: t4 });
            this._overriddenGravityRegister.delete(t4), this.isGravityOverridden || this._updateAttributes(true);
          }
          observeMarkers(t4) {
            this._observedMarkers.add(t4), this.updateMarkers();
          }
          _replaceAllRanges(t4) {
            this._validateSelectionRanges(t4), super._replaceAllRanges(t4);
          }
          _popRange() {
            this._ranges.pop().detach();
          }
          _pushRange(t4) {
            const e4 = this._prepareRange(t4);
            e4 && this._ranges.push(e4);
          }
          _validateSelectionRanges(t4) {
            for (const e4 of t4)
              if (!this._document._validateSelectionRange(e4))
                throw new C2("document-selection-wrong-position", this, { range: e4 });
          }
          _prepareRange(t4) {
            if (this._checkRange(t4), t4.root == this._document.graveyard)
              return;
            const e4 = md2.fromRange(t4);
            return e4.on("change:range", (t5, n3, i3) => {
              if (this._hasChangedRange = true, e4.root == this._document.graveyard) {
                this._selectionRestorePosition = i3.deletionPosition;
                const t6 = this._ranges.indexOf(e4);
                this._ranges.splice(t6, 1), e4.detach();
              }
            }), e4;
          }
          updateMarkers() {
            if (!this._observedMarkers.size)
              return;
            const t4 = [];
            let e4 = false;
            for (const e5 of this._model.markers) {
              const n4 = e5.name.split(":", 1)[0];
              if (!this._observedMarkers.has(n4))
                continue;
              const i3 = e5.getRange();
              for (const n5 of this.getRanges())
                i3.containsRange(n5, !n5.isCollapsed) && t4.push(e5);
            }
            const n3 = Array.from(this.markers);
            for (const n4 of t4)
              this.markers.has(n4) || (this.markers.add(n4), e4 = true);
            for (const n4 of Array.from(this.markers))
              t4.includes(n4) || (this.markers.remove(n4), e4 = true);
            e4 && this.fire("change:marker", { oldMarkers: n3, directChange: false });
          }
          _updateMarker(t4, e4) {
            const n3 = t4.name.split(":", 1)[0];
            if (!this._observedMarkers.has(n3))
              return;
            let i3 = false;
            const o3 = Array.from(this.markers), r3 = this.markers.has(t4);
            if (e4) {
              let n4 = false;
              for (const t5 of this.getRanges())
                if (e4.containsRange(t5, !t5.isCollapsed)) {
                  n4 = true;
                  break;
                }
              n4 && !r3 ? (this.markers.add(t4), i3 = true) : !n4 && r3 && (this.markers.remove(t4), i3 = true);
            } else
              r3 && (this.markers.remove(t4), i3 = true);
            i3 && this.fire("change:marker", { oldMarkers: o3, directChange: false });
          }
          _updateAttributes(t4) {
            const e4 = Bo2(this._getSurroundingAttributes()), n3 = Bo2(this.getAttributes());
            if (t4)
              this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
            else
              for (const [t5, e5] of this._attributePriority)
                "low" == e5 && (this._attrs.delete(t5), this._attributePriority.delete(t5));
            this._setAttributesTo(e4);
            const i3 = [];
            for (const [t5, e5] of this.getAttributes())
              n3.has(t5) && n3.get(t5) === e5 || i3.push(t5);
            for (const [t5] of n3)
              this.hasAttribute(t5) || i3.push(t5);
            i3.length > 0 && this.fire("change:attribute", { attributeKeys: i3, directChange: false });
          }
          _setAttribute(t4, e4, n3 = true) {
            const i3 = n3 ? "normal" : "low";
            if ("low" == i3 && "normal" == this._attributePriority.get(t4))
              return false;
            return super.getAttribute(t4) !== e4 && (this._attrs.set(t4, e4), this._attributePriority.set(t4, i3), true);
          }
          _removeAttribute(t4, e4 = true) {
            const n3 = e4 ? "normal" : "low";
            return ("low" != n3 || "normal" != this._attributePriority.get(t4)) && (this._attributePriority.set(t4, n3), !!super.hasAttribute(t4) && (this._attrs.delete(t4), true));
          }
          _setAttributesTo(t4) {
            const e4 = /* @__PURE__ */ new Set();
            for (const [e5, n3] of this.getAttributes())
              t4.get(e5) !== n3 && this._removeAttribute(e5, false);
            for (const [n3, i3] of t4) {
              this._setAttribute(n3, i3, false) && e4.add(n3);
            }
            return e4;
          }
          *getStoredAttributes() {
            const t4 = this.getFirstPosition().parent;
            if (this.isCollapsed && t4.isEmpty) {
              for (const e4 of t4.getAttributeKeys())
                if (e4.startsWith(kd2)) {
                  const n3 = e4.substr(10);
                  yield [n3, t4.getAttribute(e4)];
                }
            }
          }
          _getSurroundingAttributes() {
            const t4 = this.getFirstPosition(), e4 = this._model.schema;
            if ("$graveyard" == t4.root.rootName)
              return null;
            let n3 = null;
            if (this.isCollapsed) {
              const i3 = t4.textNode ? t4.textNode : t4.nodeBefore, o3 = t4.textNode ? t4.textNode : t4.nodeAfter;
              if (this.isGravityOverridden || (n3 = Ad2(i3, e4)), n3 || (n3 = Ad2(o3, e4)), !this.isGravityOverridden && !n3) {
                let t5 = i3;
                for (; t5 && !n3; )
                  t5 = t5.previousSibling, n3 = Ad2(t5, e4);
              }
              if (!n3) {
                let t5 = o3;
                for (; t5 && !n3; )
                  t5 = t5.nextSibling, n3 = Ad2(t5, e4);
              }
              n3 || (n3 = this.getStoredAttributes());
            } else {
              const t5 = this.getFirstRange();
              for (const i3 of t5) {
                if (i3.item.is("element") && e4.isObject(i3.item)) {
                  n3 = Ad2(i3.item, e4);
                  break;
                }
                if ("text" == i3.type) {
                  n3 = i3.item.getAttributes();
                  break;
                }
              }
            }
            return n3;
          }
          _fixGraveyardSelection(t4) {
            const e4 = this._model.schema.getNearestSelectionRange(t4);
            e4 && this._pushRange(e4);
          }
        }
        function Ad2(t4, e4) {
          if (!t4)
            return null;
          if (t4 instanceof Gl || t4 instanceof Ul)
            return t4.getAttributes();
          if (!e4.isInline(t4))
            return null;
          if (!e4.isObject(t4))
            return [];
          const n3 = [];
          for (const [i3, o3] of t4.getAttributes())
            e4.checkAttribute("$text", i3) && false !== e4.getAttributeProperties(i3).copyFromObject && n3.push([i3, o3]);
          return n3;
        }
        class Cd2 {
          constructor(t4) {
            this._dispatchers = t4;
          }
          add(t4) {
            for (const e4 of this._dispatchers)
              t4(e4);
            return this;
          }
        }
        class _d extends Cd2 {
          elementToElement(t4) {
            return this.add(function(t5) {
              const e4 = xd2(t5.model), n3 = Ed2(t5.view, "container");
              e4.attributes.length && (e4.children = true);
              return (i3) => {
                i3.on(`insert:${e4.name}`, function(t6, e5 = Ld2) {
                  return (n4, i4, o3) => {
                    if (!e5(i4.item, o3.consumable, { preflight: true }))
                      return;
                    const r3 = t6(i4.item, o3, i4);
                    if (!r3)
                      return;
                    e5(i4.item, o3.consumable);
                    const s3 = o3.mapper.toViewPosition(i4.range.start);
                    o3.mapper.bindElements(i4.item, r3), o3.writer.insert(s3, r3), o3.convertAttributes(i4.item), Md2(r3, i4.item.getChildren(), o3, { reconversion: i4.reconversion });
                  };
                }(n3, Bd2(e4)), { priority: t5.converterPriority || "normal" }), (e4.children || e4.attributes.length) && i3.on("reduceChanges", Id2(e4), { priority: "low" });
              };
            }(t4));
          }
          elementToStructure(t4) {
            return this.add(function(t5) {
              const e4 = xd2(t5.model), n3 = Ed2(t5.view, "container");
              return e4.children = true, (i3) => {
                if (i3._conversionApi.schema.checkChild(e4.name, "$text"))
                  throw new C2("conversion-element-to-structure-disallowed-text", i3, { elementName: e4.name });
                var o3, r3;
                i3.on(`insert:${e4.name}`, (o3 = n3, r3 = Bd2(e4), (t6, e5, n4) => {
                  if (!r3(e5.item, n4.consumable, { preflight: true }))
                    return;
                  const i4 = /* @__PURE__ */ new Map();
                  n4.writer._registerSlotFactory(function(t7, e6, n5) {
                    return (i5, o4) => {
                      const r4 = i5.createContainerElement("$slot");
                      let s4 = null;
                      if ("children" === o4)
                        s4 = Array.from(t7.getChildren());
                      else {
                        if ("function" != typeof o4)
                          throw new C2("conversion-slot-mode-unknown", n5.dispatcher, { modeOrFilter: o4 });
                        s4 = Array.from(t7.getChildren()).filter((t8) => o4(t8));
                      }
                      return e6.set(r4, s4), r4;
                    };
                  }(e5.item, i4, n4));
                  const s3 = o3(e5.item, n4, e5);
                  if (n4.writer._clearSlotFactory(), !s3)
                    return;
                  !function(t7, e6, n5) {
                    const i5 = Array.from(e6.values()).flat(), o4 = new Set(i5);
                    if (o4.size != i5.length)
                      throw new C2("conversion-slot-filter-overlap", n5.dispatcher, { element: t7 });
                    if (o4.size != t7.childCount)
                      throw new C2("conversion-slot-filter-incomplete", n5.dispatcher, { element: t7 });
                  }(e5.item, i4, n4), r3(e5.item, n4.consumable);
                  const a3 = n4.mapper.toViewPosition(e5.range.start);
                  n4.mapper.bindElements(e5.item, s3), n4.writer.insert(a3, s3), n4.convertAttributes(e5.item), function(t7, e6, n5, i5) {
                    n5.mapper.on("modelToViewPosition", s4, { priority: "highest" });
                    let o4 = null, r4 = null;
                    for ([o4, r4] of e6)
                      Md2(t7, r4, n5, i5), n5.writer.move(n5.writer.createRangeIn(o4), n5.writer.createPositionBefore(o4)), n5.writer.remove(o4);
                    function s4(t8, e7) {
                      const n6 = e7.modelPosition.nodeAfter, i6 = r4.indexOf(n6);
                      i6 < 0 || (e7.viewPosition = e7.mapper.findPositionIn(o4, i6));
                    }
                    n5.mapper.off("modelToViewPosition", s4);
                  }(s3, i4, n4, { reconversion: e5.reconversion });
                }), { priority: t5.converterPriority || "normal" }), i3.on("reduceChanges", Id2(e4), { priority: "low" });
              };
            }(t4));
          }
          attributeToElement(t4) {
            return this.add(function(t5) {
              t5 = Ol(t5);
              let e4 = t5.model;
              "string" == typeof e4 && (e4 = { key: e4 });
              let n3 = `attribute:${e4.key}`;
              e4.name && (n3 += ":" + e4.name);
              if (e4.values)
                for (const n4 of e4.values)
                  t5.view[n4] = Ed2(t5.view[n4], "attribute");
              else
                t5.view = Ed2(t5.view, "attribute");
              const i3 = Dd2(t5);
              return (e5) => {
                e5.on(n3, function(t6) {
                  return (e6, n4, i4) => {
                    if (!i4.consumable.test(n4.item, e6.name))
                      return;
                    const o3 = t6(n4.attributeOldValue, i4, n4), r3 = t6(n4.attributeNewValue, i4, n4);
                    if (!o3 && !r3)
                      return;
                    i4.consumable.consume(n4.item, e6.name);
                    const s3 = i4.writer, a3 = s3.document.selection;
                    if (n4.item instanceof ad2 || n4.item instanceof bd2)
                      s3.wrap(a3.getFirstRange(), r3);
                    else {
                      let t7 = i4.mapper.toViewRange(n4.range);
                      null !== n4.attributeOldValue && o3 && (t7 = s3.unwrap(t7, o3)), null !== n4.attributeNewValue && r3 && s3.wrap(t7, r3);
                    }
                  };
                }(i3), { priority: t5.converterPriority || "normal" });
              };
            }(t4));
          }
          attributeToAttribute(t4) {
            return this.add(function(t5) {
              t5 = Ol(t5);
              let e4 = t5.model;
              "string" == typeof e4 && (e4 = { key: e4 });
              let n3 = `attribute:${e4.key}`;
              e4.name && (n3 += ":" + e4.name);
              if (e4.values)
                for (const n4 of e4.values)
                  t5.view[n4] = Sd2(t5.view[n4]);
              else
                t5.view = Sd2(t5.view);
              const i3 = Dd2(t5);
              return (e5) => {
                var o3;
                e5.on(n3, (o3 = i3, (t6, e6, n4) => {
                  if (!n4.consumable.test(e6.item, t6.name))
                    return;
                  const i4 = o3(e6.attributeOldValue, n4, e6), r3 = o3(e6.attributeNewValue, n4, e6);
                  if (!i4 && !r3)
                    return;
                  n4.consumable.consume(e6.item, t6.name);
                  const s3 = n4.mapper.toViewElement(e6.item), a3 = n4.writer;
                  if (!s3)
                    throw new C2("conversion-attribute-to-attribute-on-text", n4.dispatcher, e6);
                  if (null !== e6.attributeOldValue && i4)
                    if ("class" == i4.key) {
                      const t7 = yo2(i4.value);
                      for (const e7 of t7)
                        a3.removeClass(e7, s3);
                    } else if ("style" == i4.key) {
                      const t7 = Object.keys(i4.value);
                      for (const e7 of t7)
                        a3.removeStyle(e7, s3);
                    } else
                      a3.removeAttribute(i4.key, s3);
                  if (null !== e6.attributeNewValue && r3)
                    if ("class" == r3.key) {
                      const t7 = yo2(r3.value);
                      for (const e7 of t7)
                        a3.addClass(e7, s3);
                    } else if ("style" == r3.key) {
                      const t7 = Object.keys(r3.value);
                      for (const e7 of t7)
                        a3.setStyle(e7, r3.value[e7], s3);
                    } else
                      a3.setAttribute(r3.key, r3.value, s3);
                }), { priority: t5.converterPriority || "normal" });
              };
            }(t4));
          }
          markerToElement(t4) {
            return this.add(function(t5) {
              const e4 = Ed2(t5.view, "ui");
              return (n3) => {
                var i3;
                n3.on(`addMarker:${t5.model}`, (i3 = e4, (t6, e5, n4) => {
                  e5.isOpening = true;
                  const o3 = i3(e5, n4);
                  e5.isOpening = false;
                  const r3 = i3(e5, n4);
                  if (!o3 || !r3)
                    return;
                  const s3 = e5.markerRange;
                  if (s3.isCollapsed && !n4.consumable.consume(s3, t6.name))
                    return;
                  for (const e6 of s3)
                    if (!n4.consumable.consume(e6.item, t6.name))
                      return;
                  const a3 = n4.mapper, c3 = n4.writer;
                  c3.insert(a3.toViewPosition(s3.start), o3), n4.mapper.bindElementToMarker(o3, e5.markerName), s3.isCollapsed || (c3.insert(a3.toViewPosition(s3.end), r3), n4.mapper.bindElementToMarker(r3, e5.markerName)), t6.stop();
                }), { priority: t5.converterPriority || "normal" }), n3.on(`removeMarker:${t5.model}`, (t6, e5, n4) => {
                  const i4 = n4.mapper.markerNameToElements(e5.markerName);
                  if (i4) {
                    for (const t7 of i4)
                      n4.mapper.unbindElementFromMarkerName(t7, e5.markerName), n4.writer.clear(n4.writer.createRangeOn(t7), t7);
                    n4.writer.clearClonedElementsGroup(e5.markerName), t6.stop();
                  }
                }, { priority: t5.converterPriority || "normal" });
              };
            }(t4));
          }
          markerToHighlight(t4) {
            return this.add(function(t5) {
              return (e4) => {
                var n3;
                e4.on(`addMarker:${t5.model}`, (n3 = t5.view, (t6, e5, i3) => {
                  if (!e5.item)
                    return;
                  if (!(e5.item instanceof ad2 || e5.item instanceof bd2 || e5.item.is("$textProxy")))
                    return;
                  const o3 = Td2(n3, e5, i3);
                  if (!o3)
                    return;
                  if (!i3.consumable.consume(e5.item, t6.name))
                    return;
                  const r3 = i3.writer, s3 = vd2(r3, o3), a3 = r3.document.selection;
                  if (e5.item instanceof ad2 || e5.item instanceof bd2)
                    r3.wrap(a3.getFirstRange(), s3);
                  else {
                    const t7 = i3.mapper.toViewRange(e5.range), n4 = r3.wrap(t7, s3);
                    for (const t8 of n4.getItems())
                      if (t8.is("attributeElement") && t8.isSimilar(s3)) {
                        i3.mapper.bindElementToMarker(t8, e5.markerName);
                        break;
                      }
                  }
                }), { priority: t5.converterPriority || "normal" }), e4.on(`addMarker:${t5.model}`, function(t6) {
                  return (e5, n4, i3) => {
                    if (!n4.item)
                      return;
                    if (!(n4.item instanceof Wl))
                      return;
                    const o3 = Td2(t6, n4, i3);
                    if (!o3)
                      return;
                    if (!i3.consumable.test(n4.item, e5.name))
                      return;
                    const r3 = i3.mapper.toViewElement(n4.item);
                    if (r3 && r3.getCustomProperty("addHighlight")) {
                      i3.consumable.consume(n4.item, e5.name);
                      for (const t7 of td2._createIn(n4.item))
                        i3.consumable.consume(t7.item, e5.name);
                      r3.getCustomProperty("addHighlight")(r3, o3, i3.writer), i3.mapper.bindElementToMarker(r3, n4.markerName);
                    }
                  };
                }(t5.view), { priority: t5.converterPriority || "normal" }), e4.on(`removeMarker:${t5.model}`, function(t6) {
                  return (e5, n4, i3) => {
                    if (n4.markerRange.isCollapsed)
                      return;
                    const o3 = Td2(t6, n4, i3);
                    if (!o3)
                      return;
                    const r3 = vd2(i3.writer, o3), s3 = i3.mapper.markerNameToElements(n4.markerName);
                    if (s3) {
                      for (const t7 of s3)
                        if (i3.mapper.unbindElementFromMarkerName(t7, n4.markerName), t7.is("attributeElement"))
                          i3.writer.unwrap(i3.writer.createRangeOn(t7), r3);
                        else {
                          t7.getCustomProperty("removeHighlight")(t7, o3.id, i3.writer);
                        }
                      i3.writer.clearClonedElementsGroup(n4.markerName), e5.stop();
                    }
                  };
                }(t5.view), { priority: t5.converterPriority || "normal" });
              };
            }(t4));
          }
          markerToData(t4) {
            return this.add(function(t5) {
              t5 = Ol(t5);
              const e4 = t5.model;
              let n3 = t5.view;
              n3 || (n3 = (n4) => ({ group: e4, name: n4.substr(t5.model.length + 1) }));
              return (i3) => {
                var o3;
                i3.on(`addMarker:${e4}`, (o3 = n3, (t6, e5, n4) => {
                  const i4 = o3(e5.markerName, n4);
                  if (!i4)
                    return;
                  const r3 = e5.markerRange;
                  n4.consumable.consume(r3, t6.name) && (yd2(r3, false, n4, e5, i4), yd2(r3, true, n4, e5, i4), t6.stop());
                }), { priority: t5.converterPriority || "normal" }), i3.on(`removeMarker:${e4}`, function(t6) {
                  return (e5, n4, i4) => {
                    const o4 = t6(n4.markerName, i4);
                    if (!o4)
                      return;
                    const r3 = i4.mapper.markerNameToElements(n4.markerName);
                    if (r3) {
                      for (const t7 of r3)
                        i4.mapper.unbindElementFromMarkerName(t7, n4.markerName), t7.is("containerElement") ? (s3(`data-${o4.group}-start-before`, t7), s3(`data-${o4.group}-start-after`, t7), s3(`data-${o4.group}-end-before`, t7), s3(`data-${o4.group}-end-after`, t7)) : i4.writer.clear(i4.writer.createRangeOn(t7), t7);
                      i4.writer.clearClonedElementsGroup(n4.markerName), e5.stop();
                    }
                    function s3(t7, e6) {
                      if (e6.hasAttribute(t7)) {
                        const n5 = new Set(e6.getAttribute(t7).split(","));
                        n5.delete(o4.name), 0 == n5.size ? i4.writer.removeAttribute(t7, e6) : i4.writer.setAttribute(t7, Array.from(n5).join(","), e6);
                      }
                    }
                  };
                }(n3), { priority: t5.converterPriority || "normal" });
              };
            }(t4));
          }
        }
        function vd2(t4, e4) {
          const n3 = t4.createAttributeElement("span", e4.attributes);
          return e4.classes && n3._addClass(e4.classes), "number" == typeof e4.priority && (n3._priority = e4.priority), n3._id = e4.id, n3;
        }
        function yd2(t4, e4, n3, i3, o3) {
          const r3 = e4 ? t4.start : t4.end, s3 = r3.nodeAfter && r3.nodeAfter.is("element") ? r3.nodeAfter : null, a3 = r3.nodeBefore && r3.nodeBefore.is("element") ? r3.nodeBefore : null;
          if (s3 || a3) {
            let t5, r4;
            e4 && s3 || !e4 && !a3 ? (t5 = s3, r4 = true) : (t5 = a3, r4 = false);
            const c3 = n3.mapper.toViewElement(t5);
            if (c3)
              return void function(t6, e5, n4, i4, o4, r5) {
                const s4 = `data-${r5.group}-${e5 ? "start" : "end"}-${n4 ? "before" : "after"}`, a4 = t6.hasAttribute(s4) ? t6.getAttribute(s4).split(",") : [];
                a4.unshift(r5.name), i4.writer.setAttribute(s4, a4.join(","), t6), i4.mapper.bindElementToMarker(t6, o4.markerName);
              }(c3, e4, r4, n3, i3, o3);
          }
          !function(t5, e5, n4, i4, o4) {
            const r4 = `${o4.group}-${e5 ? "start" : "end"}`, s4 = o4.name ? { name: o4.name } : null, a4 = n4.writer.createUIElement(r4, s4);
            n4.writer.insert(t5, a4), n4.mapper.bindElementToMarker(a4, i4.markerName);
          }(n3.mapper.toViewPosition(r3), e4, n3, i3, o3);
        }
        function xd2(t4) {
          return "string" == typeof t4 && (t4 = { name: t4 }), { name: t4.name, attributes: t4.attributes ? yo2(t4.attributes) : [], children: !!t4.children };
        }
        function Ed2(t4, e4) {
          return "function" == typeof t4 ? t4 : (n3, i3) => function(t5, e5, n4) {
            "string" == typeof t5 && (t5 = { name: t5 });
            let i4;
            const o3 = e5.writer, r3 = Object.assign({}, t5.attributes);
            if ("container" == n4)
              i4 = o3.createContainerElement(t5.name, r3);
            else if ("attribute" == n4) {
              const e6 = { priority: t5.priority || sc2.DEFAULT_PRIORITY };
              i4 = o3.createAttributeElement(t5.name, r3, e6);
            } else
              i4 = o3.createUIElement(t5.name, r3);
            if (t5.styles) {
              const e6 = Object.keys(t5.styles);
              for (const n5 of e6)
                o3.setStyle(n5, t5.styles[n5], i4);
            }
            if (t5.classes) {
              const e6 = t5.classes;
              if ("string" == typeof e6)
                o3.addClass(e6, i4);
              else
                for (const t6 of e6)
                  o3.addClass(t6, i4);
            }
            return i4;
          }(t4, i3, e4);
        }
        function Dd2(t4) {
          return t4.model.values ? (e4, n3, i3) => {
            const o3 = t4.view[e4];
            return o3 ? o3(e4, n3, i3) : null;
          } : t4.view;
        }
        function Sd2(t4) {
          return "string" == typeof t4 ? (e4) => ({ key: t4, value: e4 }) : "object" == typeof t4 ? t4.value ? () => t4 : (e4) => ({ key: t4.key, value: e4 }) : t4;
        }
        function Td2(t4, e4, n3) {
          const i3 = "function" == typeof t4 ? t4(e4, n3) : t4;
          return i3 ? (i3.priority || (i3.priority = 10), i3.id || (i3.id = e4.markerName), i3) : null;
        }
        function Id2(t4) {
          const e4 = function(t5) {
            return (e5, n3) => {
              if (!e5.is("element", t5.name))
                return false;
              if ("attribute" == n3.type) {
                if (t5.attributes.includes(n3.attributeKey))
                  return true;
              } else if (t5.children)
                return true;
              return false;
            };
          }(t4);
          return (t5, n3) => {
            const i3 = [];
            n3.reconvertedElements || (n3.reconvertedElements = /* @__PURE__ */ new Set());
            for (const t6 of n3.changes) {
              const o3 = "attribute" == t6.type ? t6.range.start.nodeAfter : t6.position.parent;
              if (o3 && e4(o3, t6)) {
                if (!n3.reconvertedElements.has(o3)) {
                  n3.reconvertedElements.add(o3);
                  const t7 = Kl._createBefore(o3);
                  let e5 = i3.length;
                  for (let n4 = i3.length - 1; n4 >= 0; n4--) {
                    const o4 = i3[n4], r3 = ("attribute" == o4.type ? o4.range.start : o4.position).compareWith(t7);
                    if ("before" == r3 || "remove" == o4.type && "same" == r3)
                      break;
                    e5 = n4;
                  }
                  i3.splice(e5, 0, { type: "remove", name: o3.name, position: t7, length: 1 }, { type: "reinsert", name: o3.name, position: t7, length: 1 });
                }
              } else
                i3.push(t6);
            }
            n3.changes = i3;
          };
        }
        function Bd2(t4) {
          return (e4, n3, i3 = {}) => {
            const o3 = ["insert"];
            for (const n4 of t4.attributes)
              e4.hasAttribute(n4) && o3.push(`attribute:${n4}`);
            return !!o3.every((t5) => n3.test(e4, t5)) && (i3.preflight || o3.forEach((t5) => n3.consume(e4, t5)), true);
          };
        }
        function Md2(t4, e4, n3, i3) {
          for (const o3 of e4)
            Nd2(t4.root, o3, n3, i3) || n3.convertItem(o3);
        }
        function Nd2(t4, e4, n3, i3) {
          const { writer: o3, mapper: r3 } = n3;
          if (!i3.reconversion)
            return false;
          const s3 = r3.toViewElement(e4);
          return !(!s3 || s3.root == t4) && (!!n3.canReuseView(s3) && (o3.move(o3.createRangeOn(s3), r3.toViewPosition(Kl._createBefore(e4))), true));
        }
        function Ld2(t4, e4, { preflight: n3 } = {}) {
          return n3 ? e4.test(t4, "insert") : e4.consume(t4, "insert");
        }
        function zd2(t4) {
          const { schema: e4, document: n3 } = t4.model;
          for (const i3 of n3.getRoots())
            if (i3.isEmpty && !e4.checkChild(i3, "$text") && e4.checkChild(i3, "paragraph"))
              return t4.insertElement("paragraph", i3), true;
          return false;
        }
        function Pd2(t4, e4, n3) {
          const i3 = n3.createContext(t4);
          return !!n3.checkChild(i3, "paragraph") && !!n3.checkChild(i3.push("paragraph"), e4);
        }
        function Rd2(t4, e4) {
          const n3 = e4.createElement("paragraph");
          return e4.insert(n3, t4), e4.createPositionAt(n3, 0);
        }
        class Od2 extends Cd2 {
          elementToElement(t4) {
            return this.add(Fd2(t4));
          }
          elementToAttribute(t4) {
            return this.add(function(t5) {
              t5 = Ol(t5), Hd2(t5);
              const e4 = Ud2(t5, false), n3 = Vd2(t5.view), i3 = n3 ? `element:${n3}` : "element";
              return (n4) => {
                n4.on(i3, e4, { priority: t5.converterPriority || "low" });
              };
            }(t4));
          }
          attributeToAttribute(t4) {
            return this.add(function(t5) {
              t5 = Ol(t5);
              let e4 = null;
              ("string" == typeof t5.view || t5.view.key) && (e4 = function(t6) {
                "string" == typeof t6.view && (t6.view = { key: t6.view });
                const e5 = t6.view.key;
                let n4;
                if ("class" == e5 || "style" == e5) {
                  n4 = { ["class" == e5 ? "classes" : "styles"]: t6.view.value };
                } else {
                  n4 = { attributes: { [e5]: void 0 === t6.view.value ? /[\s\S]*/ : t6.view.value } };
                }
                t6.view.name && (n4.name = t6.view.name);
                return t6.view = n4, e5;
              }(t5));
              Hd2(t5, e4);
              const n3 = Ud2(t5, true);
              return (e5) => {
                e5.on("element", n3, { priority: t5.converterPriority || "low" });
              };
            }(t4));
          }
          elementToMarker(t4) {
            return this.add(function(t5) {
              const e4 = function(t6) {
                return (e5, n3) => {
                  const i3 = "string" == typeof t6 ? t6 : t6(e5, n3);
                  return n3.writer.createElement("$marker", { "data-name": i3 });
                };
              }(t5.model);
              return Fd2({ ...t5, model: e4 });
            }(t4));
          }
          dataToMarker(t4) {
            return this.add(function(t5) {
              t5 = Ol(t5), t5.model || (t5.model = (e5) => e5 ? t5.view + ":" + e5 : t5.view);
              const e4 = { view: t5.view, model: t5.model }, n3 = jd2(Gd2(e4, "start")), i3 = jd2(Gd2(e4, "end"));
              return (o3) => {
                o3.on(`element:${t5.view}-start`, n3, { priority: t5.converterPriority || "normal" }), o3.on(`element:${t5.view}-end`, i3, { priority: t5.converterPriority || "normal" });
                const r3 = b2.low, s3 = b2.highest, a3 = b2.get(t5.converterPriority) / s3;
                o3.on("element", function(t6) {
                  return (e5, n4, i4) => {
                    const o4 = `data-${t6.view}`;
                    function r4(e6, o5) {
                      for (const r5 of o5) {
                        const o6 = t6.model(r5, i4), s4 = i4.writer.createElement("$marker", { "data-name": o6 });
                        i4.writer.insert(s4, e6), n4.modelCursor.isEqual(e6) ? n4.modelCursor = n4.modelCursor.getShiftedBy(1) : n4.modelCursor = n4.modelCursor._getTransformedByInsertion(e6, 1), n4.modelRange = n4.modelRange._getTransformedByInsertion(e6, 1)[0];
                      }
                    }
                    (i4.consumable.test(n4.viewItem, { attributes: o4 + "-end-after" }) || i4.consumable.test(n4.viewItem, { attributes: o4 + "-start-after" }) || i4.consumable.test(n4.viewItem, { attributes: o4 + "-end-before" }) || i4.consumable.test(n4.viewItem, { attributes: o4 + "-start-before" })) && (n4.modelRange || Object.assign(n4, i4.convertChildren(n4.viewItem, n4.modelCursor)), i4.consumable.consume(n4.viewItem, { attributes: o4 + "-end-after" }) && r4(n4.modelRange.end, n4.viewItem.getAttribute(o4 + "-end-after").split(",")), i4.consumable.consume(n4.viewItem, { attributes: o4 + "-start-after" }) && r4(n4.modelRange.end, n4.viewItem.getAttribute(o4 + "-start-after").split(",")), i4.consumable.consume(n4.viewItem, { attributes: o4 + "-end-before" }) && r4(n4.modelRange.start, n4.viewItem.getAttribute(o4 + "-end-before").split(",")), i4.consumable.consume(n4.viewItem, { attributes: o4 + "-start-before" }) && r4(n4.modelRange.start, n4.viewItem.getAttribute(o4 + "-start-before").split(",")));
                  };
                }(e4), { priority: r3 + a3 });
              };
            }(t4));
          }
        }
        function Fd2(t4) {
          const e4 = jd2(t4 = Ol(t4)), n3 = Vd2(t4.view), i3 = n3 ? `element:${n3}` : "element";
          return (n4) => {
            n4.on(i3, e4, { priority: t4.converterPriority || "normal" });
          };
        }
        function Vd2(t4) {
          return "string" == typeof t4 ? t4 : "object" == typeof t4 && "string" == typeof t4.name ? t4.name : null;
        }
        function jd2(t4) {
          const e4 = new Vs(t4.view);
          return (n3, i3, o3) => {
            const r3 = e4.match(i3.viewItem);
            if (!r3)
              return;
            const s3 = r3.match;
            if (s3.name = true, !o3.consumable.test(i3.viewItem, s3))
              return;
            const a3 = function(t5, e5, n4) {
              return t5 instanceof Function ? t5(e5, n4) : n4.writer.createElement(t5);
            }(t4.model, i3.viewItem, o3);
            a3 && o3.safeInsert(a3, i3.modelCursor) && (o3.consumable.consume(i3.viewItem, s3), o3.convertChildren(i3.viewItem, a3), o3.updateConversionResult(a3, i3));
          };
        }
        function Hd2(t4, e4 = null) {
          const n3 = null === e4 || ((t5) => t5.getAttribute(e4)), i3 = "object" != typeof t4.model ? t4.model : t4.model.key, o3 = "object" != typeof t4.model || void 0 === t4.model.value ? n3 : t4.model.value;
          t4.model = { key: i3, value: o3 };
        }
        function Ud2(t4, e4) {
          const n3 = new Vs(t4.view);
          return (i3, o3, r3) => {
            if (!o3.modelRange && e4)
              return;
            const s3 = n3.match(o3.viewItem);
            if (!s3)
              return;
            if (!function(t5, e5) {
              const n4 = "function" == typeof t5 ? t5(e5) : t5;
              if ("object" == typeof n4 && !Vd2(n4))
                return false;
              return !n4.classes && !n4.attributes && !n4.styles;
            }(t4.view, o3.viewItem) ? delete s3.match.name : s3.match.name = true, !r3.consumable.test(o3.viewItem, s3.match))
              return;
            const a3 = t4.model.key, c3 = "function" == typeof t4.model.value ? t4.model.value(o3.viewItem, r3) : t4.model.value;
            if (null === c3)
              return;
            o3.modelRange || Object.assign(o3, r3.convertChildren(o3.viewItem, o3.modelCursor));
            const l3 = function(t5, e5, n4, i4) {
              let o4 = false;
              for (const r4 of Array.from(t5.getItems({ shallow: n4 })))
                i4.schema.checkAttribute(r4, e5.key) && (o4 = true, r4.hasAttribute(e5.key) || i4.writer.setAttribute(e5.key, e5.value, r4));
              return o4;
            }(o3.modelRange, { key: a3, value: c3 }, e4, r3);
            l3 && (r3.consumable.test(o3.viewItem, { name: true }) && (s3.match.name = true), r3.consumable.consume(o3.viewItem, s3.match));
          };
        }
        function Gd2(t4, e4) {
          return { view: `${t4.view}-${e4}`, model: (e5, n3) => {
            const i3 = e5.getAttribute("name"), o3 = t4.model(i3, n3);
            return n3.writer.createElement("$marker", { "data-name": o3 });
          } };
        }
        function Wd2(t4) {
          t4.document.registerPostFixer((e4) => function(t5, e5) {
            const n3 = e5.document.selection, i3 = e5.schema, o3 = [];
            let r3 = false;
            for (const t6 of n3.getRanges()) {
              const e6 = qd2(t6, i3);
              e6 && !e6.isEqual(t6) ? (o3.push(e6), r3 = true) : o3.push(t6);
            }
            r3 && t5.setSelection(function(t6) {
              const e6 = [...t6], n4 = /* @__PURE__ */ new Set();
              let i4 = 1;
              for (; i4 < e6.length; ) {
                const t7 = e6[i4], o4 = e6.slice(0, i4);
                for (const [r4, s3] of o4.entries())
                  if (!n4.has(r4)) {
                    if (t7.isEqual(s3))
                      n4.add(r4);
                    else if (t7.isIntersecting(s3)) {
                      n4.add(r4), n4.add(i4);
                      const o5 = t7.getJoined(s3);
                      e6.push(o5);
                    }
                  }
                i4++;
              }
              return e6.filter((t7, e7) => !n4.has(e7));
            }(o3), { backward: n3.isBackward });
            return false;
          }(e4, t4));
        }
        function qd2(t4, e4) {
          return t4.isCollapsed ? function(t5, e5) {
            const n3 = t5.start, i3 = e5.getNearestSelectionRange(n3);
            if (!i3) {
              const t6 = n3.getAncestors().reverse().find((t7) => e5.isObject(t7));
              return t6 ? td2._createOn(t6) : null;
            }
            if (!i3.isCollapsed)
              return i3;
            const o3 = i3.start;
            if (n3.isEqual(o3))
              return null;
            return new td2(o3);
          }(t4, e4) : function(t5, e5) {
            const { start: n3, end: i3 } = t5, o3 = e5.checkChild(n3, "$text"), r3 = e5.checkChild(i3, "$text"), s3 = e5.getLimitElement(n3), a3 = e5.getLimitElement(i3);
            if (s3 === a3) {
              if (o3 && r3)
                return null;
              if (function(t6, e6, n4) {
                const i4 = t6.nodeAfter && !n4.isLimit(t6.nodeAfter) || n4.checkChild(t6, "$text"), o4 = e6.nodeBefore && !n4.isLimit(e6.nodeBefore) || n4.checkChild(e6, "$text");
                return i4 || o4;
              }(n3, i3, e5)) {
                const t6 = n3.nodeAfter && e5.isSelectable(n3.nodeAfter) ? null : e5.getNearestSelectionRange(n3, "forward"), o4 = i3.nodeBefore && e5.isSelectable(i3.nodeBefore) ? null : e5.getNearestSelectionRange(i3, "backward"), r4 = t6 ? t6.start : n3, s4 = o4 ? o4.end : i3;
                return new td2(r4, s4);
              }
            }
            const c3 = s3 && !s3.is("rootElement"), l3 = a3 && !a3.is("rootElement");
            if (c3 || l3) {
              const t6 = n3.nodeAfter && i3.nodeBefore && n3.nodeAfter.parent === i3.nodeBefore.parent, o4 = c3 && (!t6 || !Kd2(n3.nodeAfter, e5)), r4 = l3 && (!t6 || !Kd2(i3.nodeBefore, e5));
              let d3 = n3, h3 = i3;
              return o4 && (d3 = Kl._createBefore($d2(s3, e5))), r4 && (h3 = Kl._createAfter($d2(a3, e5))), new td2(d3, h3);
            }
            return null;
          }(t4, e4);
        }
        function $d2(t4, e4) {
          let n3 = t4, i3 = n3;
          for (; e4.isLimit(i3) && i3.parent; )
            n3 = i3, i3 = i3.parent;
          return n3;
        }
        function Kd2(t4, e4) {
          return t4 && e4.isSelectable(t4);
        }
        class Zd2 extends q2() {
          constructor(t4, e4) {
            super(), this.model = t4, this.view = new Fl(e4), this.mapper = new ed2(), this.downcastDispatcher = new od2({ mapper: this.mapper, schema: t4.schema });
            const n3 = this.model.document, i3 = n3.selection, o3 = this.model.markers;
            var r3, s3, a3;
            this.listenTo(this.model, "_beforeChanges", () => {
              this.view._disableRendering(true);
            }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
              this.view._disableRendering(false);
            }, { priority: "lowest" }), this.listenTo(n3, "change", () => {
              this.view.change((t5) => {
                this.downcastDispatcher.convertChanges(n3.differ, o3, t5), this.downcastDispatcher.convertSelection(i3, o3, t5);
              });
            }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", function(t5, e5) {
              return (n4, i4) => {
                const o4 = i4.newSelection, r4 = [];
                for (const t6 of o4.getRanges())
                  r4.push(e5.toModelRange(t6));
                const s4 = t5.createSelection(r4, { backward: o4.isBackward });
                s4.isEqual(t5.document.selection) || t5.change((t6) => {
                  t6.setSelection(s4);
                });
              };
            }(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", (r3 = this.mapper, s3 = this.model.schema, a3 = this.view, (t5, e5) => {
              if (!a3.document.isComposing || c2.isAndroid)
                for (let t6 = 0; t6 < e5.targetRanges.length; t6++) {
                  const n4 = e5.targetRanges[t6], i4 = r3.toModelRange(n4), o4 = qd2(i4, s3);
                  o4 && !o4.isEqual(i4) && (e5.targetRanges[t6] = r3.toViewRange(o4));
                }
            }), { priority: "high" }), this.downcastDispatcher.on("insert:$text", (t5, e5, n4) => {
              if (!n4.consumable.consume(e5.item, t5.name))
                return;
              const i4 = n4.writer, o4 = n4.mapper.toViewPosition(e5.range.start), r4 = i4.createText(e5.item.data);
              i4.insert(o4, r4);
            }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (t5, e5, n4) => {
              n4.convertAttributes(e5.item), e5.reconversion || !e5.item.is("element") || e5.item.isEmpty || n4.convertChildren(e5.item);
            }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (t5, e5, n4) => {
              const i4 = n4.mapper.toViewPosition(e5.position), o4 = e5.position.getShiftedBy(e5.length), r4 = n4.mapper.toViewPosition(o4, { isPhantom: true }), s4 = n4.writer.createRange(i4, r4), a4 = n4.writer.remove(s4.getTrimmed());
              for (const t6 of n4.writer.createRangeIn(a4).getItems())
                n4.mapper.unbindViewElement(t6, { defer: true });
            }, { priority: "low" }), this.downcastDispatcher.on("cleanSelection", (t5, e5, n4) => {
              const i4 = n4.writer, o4 = i4.document.selection;
              for (const t6 of o4.getRanges())
                t6.isCollapsed && t6.end.parent.isAttached() && n4.writer.mergeAttributes(t6.start);
              i4.setSelection(null);
            }), this.downcastDispatcher.on("selection", (t5, e5, n4) => {
              const i4 = e5.selection;
              if (i4.isCollapsed)
                return;
              if (!n4.consumable.consume(i4, "selection"))
                return;
              const o4 = [];
              for (const t6 of i4.getRanges())
                o4.push(n4.mapper.toViewRange(t6));
              n4.writer.setSelection(o4, { backward: i4.isBackward });
            }, { priority: "low" }), this.downcastDispatcher.on("selection", (t5, e5, n4) => {
              const i4 = e5.selection;
              if (!i4.isCollapsed)
                return;
              if (!n4.consumable.consume(i4, "selection"))
                return;
              const o4 = n4.writer, r4 = i4.getFirstPosition(), s4 = n4.mapper.toViewPosition(r4), a4 = o4.breakAttributes(s4);
              o4.setSelection(a4);
            }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((t5) => {
              if ("$graveyard" == t5.rootName)
                return null;
              const e5 = new Wa2(this.view.document, t5.name);
              return e5.rootName = t5.rootName, this.mapper.bindElements(t5, e5), e5;
            });
          }
          destroy() {
            this.view.destroy(), this.stopListening();
          }
          reconvertMarker(t4) {
            const e4 = "string" == typeof t4 ? t4 : t4.name, n3 = this.model.markers.get(e4);
            if (!n3)
              throw new C2("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: e4 });
            this.model.change(() => {
              this.model.markers._refresh(n3);
            });
          }
          reconvertItem(t4) {
            this.model.change(() => {
              this.model.document.differ._refreshItem(t4);
            });
          }
        }
        class Yd2 {
          constructor() {
            this._consumables = /* @__PURE__ */ new Map();
          }
          add(t4, e4) {
            let n3;
            t4.is("$text") || t4.is("documentFragment") ? this._consumables.set(t4, true) : (this._consumables.has(t4) ? n3 = this._consumables.get(t4) : (n3 = new Jd2(t4), this._consumables.set(t4, n3)), n3.add(e4));
          }
          test(t4, e4) {
            const n3 = this._consumables.get(t4);
            return void 0 === n3 ? null : t4.is("$text") || t4.is("documentFragment") ? n3 : n3.test(e4);
          }
          consume(t4, e4) {
            return !!this.test(t4, e4) && (t4.is("$text") || t4.is("documentFragment") ? this._consumables.set(t4, false) : this._consumables.get(t4).consume(e4), true);
          }
          revert(t4, e4) {
            const n3 = this._consumables.get(t4);
            void 0 !== n3 && (t4.is("$text") || t4.is("documentFragment") ? this._consumables.set(t4, true) : n3.revert(e4));
          }
          static consumablesFromElement(t4) {
            const e4 = { element: t4, name: true, attributes: [], classes: [], styles: [] }, n3 = t4.getAttributeKeys();
            for (const t5 of n3)
              "style" != t5 && "class" != t5 && e4.attributes.push(t5);
            const i3 = t4.getClassNames();
            for (const t5 of i3)
              e4.classes.push(t5);
            const o3 = t4.getStyleNames();
            for (const t5 of o3)
              e4.styles.push(t5);
            return e4;
          }
          static createFrom(t4, e4) {
            if (e4 || (e4 = new Yd2()), t4.is("$text"))
              return e4.add(t4), e4;
            t4.is("element") && e4.add(t4, Yd2.consumablesFromElement(t4)), t4.is("documentFragment") && e4.add(t4);
            for (const n3 of t4.getChildren())
              e4 = Yd2.createFrom(n3, e4);
            return e4;
          }
        }
        const Qd2 = ["attributes", "classes", "styles"];
        class Jd2 {
          constructor(t4) {
            this.element = t4, this._canConsumeName = null, this._consumables = { attributes: /* @__PURE__ */ new Map(), styles: /* @__PURE__ */ new Map(), classes: /* @__PURE__ */ new Map() };
          }
          add(t4) {
            t4.name && (this._canConsumeName = true);
            for (const e4 of Qd2)
              e4 in t4 && this._add(e4, t4[e4]);
          }
          test(t4) {
            if (t4.name && !this._canConsumeName)
              return this._canConsumeName;
            for (const e4 of Qd2)
              if (e4 in t4) {
                const n3 = this._test(e4, t4[e4]);
                if (true !== n3)
                  return n3;
              }
            return true;
          }
          consume(t4) {
            t4.name && (this._canConsumeName = false);
            for (const e4 of Qd2)
              e4 in t4 && this._consume(e4, t4[e4]);
          }
          revert(t4) {
            t4.name && (this._canConsumeName = true);
            for (const e4 of Qd2)
              e4 in t4 && this._revert(e4, t4[e4]);
          }
          _add(t4, e4) {
            const n3 = pt2(e4) ? e4 : [e4], i3 = this._consumables[t4];
            for (const e5 of n3) {
              if ("attributes" === t4 && ("class" === e5 || "style" === e5))
                throw new C2("viewconsumable-invalid-attribute", this);
              if (i3.set(e5, true), "styles" === t4)
                for (const t5 of this.element.document.stylesProcessor.getRelatedStyles(e5))
                  i3.set(t5, true);
            }
          }
          _test(t4, e4) {
            const n3 = pt2(e4) ? e4 : [e4], i3 = this._consumables[t4];
            for (const e5 of n3)
              if ("attributes" !== t4 || "class" !== e5 && "style" !== e5) {
                const t5 = i3.get(e5);
                if (void 0 === t5)
                  return null;
                if (!t5)
                  return false;
              } else {
                const t5 = "class" == e5 ? "classes" : "styles", n4 = this._test(t5, [...this._consumables[t5].keys()]);
                if (true !== n4)
                  return n4;
              }
            return true;
          }
          _consume(t4, e4) {
            const n3 = pt2(e4) ? e4 : [e4], i3 = this._consumables[t4];
            for (const e5 of n3)
              if ("attributes" !== t4 || "class" !== e5 && "style" !== e5) {
                if (i3.set(e5, false), "styles" == t4)
                  for (const t5 of this.element.document.stylesProcessor.getRelatedStyles(e5))
                    i3.set(t5, false);
              } else {
                const t5 = "class" == e5 ? "classes" : "styles";
                this._consume(t5, [...this._consumables[t5].keys()]);
              }
          }
          _revert(t4, e4) {
            const n3 = pt2(e4) ? e4 : [e4], i3 = this._consumables[t4];
            for (const e5 of n3)
              if ("attributes" !== t4 || "class" !== e5 && "style" !== e5) {
                false === i3.get(e5) && i3.set(e5, true);
              } else {
                const t5 = "class" == e5 ? "classes" : "styles";
                this._revert(t5, [...this._consumables[t5].keys()]);
              }
          }
        }
        class Xd2 extends q2() {
          constructor() {
            super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (t4, e4) => {
              e4[0] = new th2(e4[0]);
            }, { priority: "highest" }), this.on("checkChild", (t4, e4) => {
              e4[0] = new th2(e4[0]), e4[1] = this.getDefinition(e4[1]);
            }, { priority: "highest" });
          }
          register(t4, e4) {
            if (this._sourceDefinitions[t4])
              throw new C2("schema-cannot-register-item-twice", this, { itemName: t4 });
            this._sourceDefinitions[t4] = [Object.assign({}, e4)], this._clearCache();
          }
          extend(t4, e4) {
            if (!this._sourceDefinitions[t4])
              throw new C2("schema-cannot-extend-missing-item", this, { itemName: t4 });
            this._sourceDefinitions[t4].push(Object.assign({}, e4)), this._clearCache();
          }
          getDefinitions() {
            return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
          }
          getDefinition(t4) {
            let e4;
            return e4 = "string" == typeof t4 ? t4 : "is" in t4 && (t4.is("$text") || t4.is("$textProxy")) ? "$text" : t4.name, this.getDefinitions()[e4];
          }
          isRegistered(t4) {
            return !!this.getDefinition(t4);
          }
          isBlock(t4) {
            const e4 = this.getDefinition(t4);
            return !(!e4 || !e4.isBlock);
          }
          isLimit(t4) {
            const e4 = this.getDefinition(t4);
            return !!e4 && !(!e4.isLimit && !e4.isObject);
          }
          isObject(t4) {
            const e4 = this.getDefinition(t4);
            return !!e4 && !!(e4.isObject || e4.isLimit && e4.isSelectable && e4.isContent);
          }
          isInline(t4) {
            const e4 = this.getDefinition(t4);
            return !(!e4 || !e4.isInline);
          }
          isSelectable(t4) {
            const e4 = this.getDefinition(t4);
            return !!e4 && !(!e4.isSelectable && !e4.isObject);
          }
          isContent(t4) {
            const e4 = this.getDefinition(t4);
            return !!e4 && !(!e4.isContent && !e4.isObject);
          }
          checkChild(t4, e4) {
            return !!e4 && this._checkContextMatch(e4, t4);
          }
          checkAttribute(t4, e4) {
            const n3 = this.getDefinition(t4.last);
            return !!n3 && n3.allowAttributes.includes(e4);
          }
          checkMerge(t4, e4) {
            if (t4 instanceof Kl) {
              const e5 = t4.nodeBefore, n3 = t4.nodeAfter;
              if (!(e5 instanceof Wl))
                throw new C2("schema-check-merge-no-element-before", this);
              if (!(n3 instanceof Wl))
                throw new C2("schema-check-merge-no-element-after", this);
              return this.checkMerge(e5, n3);
            }
            for (const n3 of e4.getChildren())
              if (!this.checkChild(t4, n3))
                return false;
            return true;
          }
          addChildCheck(t4) {
            this.on("checkChild", (e4, [n3, i3]) => {
              if (!i3)
                return;
              const o3 = t4(n3, i3);
              "boolean" == typeof o3 && (e4.stop(), e4.return = o3);
            }, { priority: "high" });
          }
          addAttributeCheck(t4) {
            this.on("checkAttribute", (e4, [n3, i3]) => {
              const o3 = t4(n3, i3);
              "boolean" == typeof o3 && (e4.stop(), e4.return = o3);
            }, { priority: "high" });
          }
          setAttributeProperties(t4, e4) {
            this._attributeProperties[t4] = Object.assign(this.getAttributeProperties(t4), e4);
          }
          getAttributeProperties(t4) {
            return this._attributeProperties[t4] || {};
          }
          getLimitElement(t4) {
            let e4;
            if (t4 instanceof Kl)
              e4 = t4.parent;
            else {
              e4 = (t4 instanceof td2 ? [t4] : Array.from(t4.getRanges())).reduce((t5, e5) => {
                const n3 = e5.getCommonAncestor();
                return t5 ? t5.getCommonAncestor(n3, { includeSelf: true }) : n3;
              }, null);
            }
            for (; !this.isLimit(e4) && e4.parent; )
              e4 = e4.parent;
            return e4;
          }
          checkAttributeInSelection(t4, e4) {
            if (t4.isCollapsed) {
              const n3 = [...t4.getFirstPosition().getAncestors(), new Ul("", t4.getAttributes())];
              return this.checkAttribute(n3, e4);
            }
            {
              const n3 = t4.getRanges();
              for (const t5 of n3)
                for (const n4 of t5)
                  if (this.checkAttribute(n4.item, e4))
                    return true;
            }
            return false;
          }
          *getValidRanges(t4, e4) {
            t4 = function* (t5) {
              for (const e5 of t5)
                yield* e5.getMinimalFlatRanges();
            }(t4);
            for (const n3 of t4)
              yield* this._getValidRangesForRange(n3, e4);
          }
          getNearestSelectionRange(t4, e4 = "both") {
            if ("$graveyard" == t4.root.rootName)
              return null;
            if (this.checkChild(t4, "$text"))
              return new td2(t4);
            let n3, i3;
            const o3 = t4.getAncestors().reverse().find((t5) => this.isLimit(t5)) || t4.root;
            "both" != e4 && "backward" != e4 || (n3 = new ql2({ boundaries: td2._createIn(o3), startPosition: t4, direction: "backward" })), "both" != e4 && "forward" != e4 || (i3 = new ql2({ boundaries: td2._createIn(o3), startPosition: t4 }));
            for (const t5 of function* (t6, e5) {
              let n4 = false;
              for (; !n4; ) {
                if (n4 = true, t6) {
                  const e6 = t6.next();
                  e6.done || (n4 = false, yield { walker: t6, value: e6.value });
                }
                if (e5) {
                  const t7 = e5.next();
                  t7.done || (n4 = false, yield { walker: e5, value: t7.value });
                }
              }
            }(n3, i3)) {
              const e5 = t5.walker == n3 ? "elementEnd" : "elementStart", i4 = t5.value;
              if (i4.type == e5 && this.isObject(i4.item))
                return td2._createOn(i4.item);
              if (this.checkChild(i4.nextPosition, "$text"))
                return new td2(i4.nextPosition);
            }
            return null;
          }
          findAllowedParent(t4, e4) {
            let n3 = t4.parent;
            for (; n3; ) {
              if (this.checkChild(n3, e4))
                return n3;
              if (this.isLimit(n3))
                return null;
              n3 = n3.parent;
            }
            return null;
          }
          setAllowedAttributes(t4, e4, n3) {
            const i3 = n3.model;
            for (const [o3, r3] of Object.entries(e4))
              i3.schema.checkAttribute(t4, o3) && n3.setAttribute(o3, r3, t4);
          }
          removeDisallowedAttributes(t4, e4) {
            for (const n3 of t4)
              if (n3.is("$text"))
                gh2(this, n3, e4);
              else {
                const t5 = td2._createIn(n3).getPositions();
                for (const n4 of t5) {
                  gh2(this, n4.nodeBefore || n4.parent, e4);
                }
              }
          }
          getAttributesWithProperty(t4, e4, n3) {
            const i3 = {};
            for (const [o3, r3] of t4.getAttributes()) {
              const t5 = this.getAttributeProperties(o3);
              void 0 !== t5[e4] && (void 0 !== n3 && n3 !== t5[e4] || (i3[o3] = r3));
            }
            return i3;
          }
          createContext(t4) {
            return new th2(t4);
          }
          _clearCache() {
            this._compiledDefinitions = null;
          }
          _compile() {
            const t4 = {}, e4 = this._sourceDefinitions, n3 = Object.keys(e4);
            for (const i3 of n3)
              t4[i3] = eh2(e4[i3], i3);
            for (const e5 of n3)
              nh2(t4, e5);
            for (const e5 of n3)
              ih2(t4, e5);
            for (const e5 of n3)
              oh2(t4, e5);
            for (const e5 of n3)
              rh2(t4, e5), sh2(t4, e5);
            for (const e5 of n3)
              ah2(t4, e5), ch2(t4, e5), lh2(t4, e5);
            this._compiledDefinitions = t4;
          }
          _checkContextMatch(t4, e4, n3 = e4.length - 1) {
            const i3 = e4.getItem(n3);
            if (t4.allowIn.includes(i3.name)) {
              if (0 == n3)
                return true;
              {
                const t5 = this.getDefinition(i3);
                return this._checkContextMatch(t5, e4, n3 - 1);
              }
            }
            return false;
          }
          *_getValidRangesForRange(t4, e4) {
            let n3 = t4.start, i3 = t4.start;
            for (const o3 of t4.getItems({ shallow: true }))
              o3.is("element") && (yield* this._getValidRangesForRange(td2._createIn(o3), e4)), this.checkAttribute(o3, e4) || (n3.isEqual(i3) || (yield new td2(n3, i3)), n3 = Kl._createAfter(o3)), i3 = Kl._createAfter(o3);
            n3.isEqual(i3) || (yield new td2(n3, i3));
          }
        }
        class th2 {
          constructor(t4) {
            if (t4 instanceof th2)
              return t4;
            let e4;
            e4 = "string" == typeof t4 ? [t4] : Array.isArray(t4) ? t4 : t4.getAncestors({ includeSelf: true }), this._items = e4.map(uh2);
          }
          get length() {
            return this._items.length;
          }
          get last() {
            return this._items[this._items.length - 1];
          }
          [Symbol.iterator]() {
            return this._items[Symbol.iterator]();
          }
          push(t4) {
            const e4 = new th2([t4]);
            return e4._items = [...this._items, ...e4._items], e4;
          }
          getItem(t4) {
            return this._items[t4];
          }
          *getNames() {
            yield* this._items.map((t4) => t4.name);
          }
          endsWith(t4) {
            return Array.from(this.getNames()).join(" ").endsWith(t4);
          }
          startsWith(t4) {
            return Array.from(this.getNames()).join(" ").startsWith(t4);
          }
        }
        function eh2(t4, e4) {
          const n3 = { name: e4, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] };
          return function(t5, e5) {
            for (const n4 of t5) {
              const t6 = Object.keys(n4).filter((t7) => t7.startsWith("is"));
              for (const i3 of t6)
                e5[i3] = !!n4[i3];
            }
          }(t4, n3), dh2(t4, n3, "allowIn"), dh2(t4, n3, "allowContentOf"), dh2(t4, n3, "allowWhere"), dh2(t4, n3, "allowAttributes"), dh2(t4, n3, "allowAttributesOf"), dh2(t4, n3, "allowChildren"), dh2(t4, n3, "inheritTypesFrom"), function(t5, e5) {
            for (const n4 of t5) {
              const t6 = n4.inheritAllFrom;
              t6 && (e5.allowContentOf.push(t6), e5.allowWhere.push(t6), e5.allowAttributesOf.push(t6), e5.inheritTypesFrom.push(t6));
            }
          }(t4, n3), n3;
        }
        function nh2(t4, e4) {
          const n3 = t4[e4];
          for (const i3 of n3.allowChildren) {
            const n4 = t4[i3];
            n4 && n4.allowIn.push(e4);
          }
          n3.allowChildren.length = 0;
        }
        function ih2(t4, e4) {
          for (const n3 of t4[e4].allowContentOf)
            if (t4[n3]) {
              hh2(t4, n3).forEach((t5) => {
                t5.allowIn.push(e4);
              });
            }
          delete t4[e4].allowContentOf;
        }
        function oh2(t4, e4) {
          for (const n3 of t4[e4].allowWhere) {
            const i3 = t4[n3];
            if (i3) {
              const n4 = i3.allowIn;
              t4[e4].allowIn.push(...n4);
            }
          }
          delete t4[e4].allowWhere;
        }
        function rh2(t4, e4) {
          for (const n3 of t4[e4].allowAttributesOf) {
            const i3 = t4[n3];
            if (i3) {
              const n4 = i3.allowAttributes;
              t4[e4].allowAttributes.push(...n4);
            }
          }
          delete t4[e4].allowAttributesOf;
        }
        function sh2(t4, e4) {
          const n3 = t4[e4];
          for (const e5 of n3.inheritTypesFrom) {
            const i3 = t4[e5];
            if (i3) {
              const t5 = Object.keys(i3).filter((t6) => t6.startsWith("is"));
              for (const e6 of t5)
                e6 in n3 || (n3[e6] = i3[e6]);
            }
          }
          delete n3.inheritTypesFrom;
        }
        function ah2(t4, e4) {
          const n3 = t4[e4], i3 = n3.allowIn.filter((e5) => t4[e5]);
          n3.allowIn = Array.from(new Set(i3));
        }
        function ch2(t4, e4) {
          const n3 = t4[e4];
          for (const i3 of n3.allowIn) {
            t4[i3].allowChildren.push(e4);
          }
        }
        function lh2(t4, e4) {
          const n3 = t4[e4];
          n3.allowAttributes = Array.from(new Set(n3.allowAttributes));
        }
        function dh2(t4, e4, n3) {
          for (const i3 of t4) {
            const t5 = i3[n3];
            "string" == typeof t5 ? e4[n3].push(t5) : Array.isArray(t5) && e4[n3].push(...t5);
          }
        }
        function hh2(t4, e4) {
          const n3 = t4[e4];
          return (i3 = t4, Object.keys(i3).map((t5) => i3[t5])).filter((t5) => t5.allowIn.includes(n3.name));
          var i3;
        }
        function uh2(t4) {
          return "string" == typeof t4 || t4.is("documentFragment") ? { name: "string" == typeof t4 ? t4 : "$documentFragment", *getAttributeKeys() {
          }, getAttribute() {
          } } : { name: t4.is("element") ? t4.name : "$text", *getAttributeKeys() {
            yield* t4.getAttributeKeys();
          }, getAttribute: (e4) => t4.getAttribute(e4) };
        }
        function gh2(t4, e4, n3) {
          for (const i3 of e4.getAttributeKeys())
            t4.checkAttribute(e4, i3) || n3.removeAttribute(i3, e4);
        }
        class mh2 extends B2() {
          constructor(t4) {
            super(), this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this._emptyElementsToKeep = /* @__PURE__ */ new Set(), this.conversionApi = { ...t4, consumable: null, writer: null, store: null, convertItem: (t5, e4) => this._convertItem(t5, e4), convertChildren: (t5, e4) => this._convertChildren(t5, e4), safeInsert: (t5, e4) => this._safeInsert(t5, e4), updateConversionResult: (t5, e4) => this._updateConversionResult(t5, e4), splitToAllowedParent: (t5, e4) => this._splitToAllowedParent(t5, e4), getSplitParts: (t5) => this._getSplitParts(t5), keepEmptyElement: (t5) => this._keepEmptyElement(t5) };
          }
          convert(t4, e4, n3 = ["$root"]) {
            this.fire("viewCleanup", t4), this._modelCursor = function(t5, e5) {
              let n4;
              for (const i4 of new th2(t5)) {
                const t6 = {};
                for (const e6 of i4.getAttributeKeys())
                  t6[e6] = i4.getAttribute(e6);
                const o4 = e5.createElement(i4.name, t6);
                n4 && e5.insert(o4, n4), n4 = Kl._createAt(o4, 0);
              }
              return n4;
            }(n3, e4), this.conversionApi.writer = e4, this.conversionApi.consumable = Yd2.createFrom(t4), this.conversionApi.store = {};
            const { modelRange: i3 } = this._convertItem(t4, this._modelCursor), o3 = e4.createDocumentFragment();
            if (i3) {
              this._removeEmptyElements();
              for (const t5 of Array.from(this._modelCursor.parent.getChildren()))
                e4.append(t5, o3);
              o3.markers = function(t5, e5) {
                const n4 = /* @__PURE__ */ new Set(), i4 = /* @__PURE__ */ new Map(), o4 = td2._createIn(t5).getItems();
                for (const t6 of o4)
                  t6.is("element", "$marker") && n4.add(t6);
                for (const t6 of n4) {
                  const n5 = t6.getAttribute("data-name"), o5 = e5.createPositionBefore(t6);
                  i4.has(n5) ? i4.get(n5).end = o5.clone() : i4.set(n5, new td2(o5.clone())), e5.remove(t6);
                }
                return i4;
              }(o3, e4);
            }
            return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, o3;
          }
          _convertItem(t4, e4) {
            const n3 = { viewItem: t4, modelCursor: e4, modelRange: null };
            if (t4.is("element") ? this.fire(`element:${t4.name}`, n3, this.conversionApi) : t4.is("$text") ? this.fire("text", n3, this.conversionApi) : this.fire("documentFragment", n3, this.conversionApi), n3.modelRange && !(n3.modelRange instanceof td2))
              throw new C2("view-conversion-dispatcher-incorrect-result", this);
            return { modelRange: n3.modelRange, modelCursor: n3.modelCursor };
          }
          _convertChildren(t4, e4) {
            let n3 = e4.is("position") ? e4 : Kl._createAt(e4, 0);
            const i3 = new td2(n3);
            for (const e5 of Array.from(t4.getChildren())) {
              const t5 = this._convertItem(e5, n3);
              t5.modelRange instanceof td2 && (i3.end = t5.modelRange.end, n3 = t5.modelCursor);
            }
            return { modelRange: i3, modelCursor: n3 };
          }
          _safeInsert(t4, e4) {
            const n3 = this._splitToAllowedParent(t4, e4);
            return !!n3 && (this.conversionApi.writer.insert(t4, n3.position), true);
          }
          _updateConversionResult(t4, e4) {
            const n3 = this._getSplitParts(t4), i3 = this.conversionApi.writer;
            e4.modelRange || (e4.modelRange = i3.createRange(i3.createPositionBefore(t4), i3.createPositionAfter(n3[n3.length - 1])));
            const o3 = this._cursorParents.get(t4);
            e4.modelCursor = o3 ? i3.createPositionAt(o3, 0) : e4.modelRange.end;
          }
          _splitToAllowedParent(t4, e4) {
            const { schema: n3, writer: i3 } = this.conversionApi;
            let o3 = n3.findAllowedParent(e4, t4);
            if (o3) {
              if (o3 === e4.parent)
                return { position: e4 };
              this._modelCursor.parent.getAncestors().includes(o3) && (o3 = null);
            }
            if (!o3)
              return Pd2(e4, t4, n3) ? { position: Rd2(e4, i3) } : null;
            const r3 = this.conversionApi.writer.split(e4, o3), s3 = [];
            for (const t5 of r3.range.getWalker())
              if ("elementEnd" == t5.type)
                s3.push(t5.item);
              else {
                const e5 = s3.pop(), n4 = t5.item;
                this._registerSplitPair(e5, n4);
              }
            const a3 = r3.range.end.parent;
            return this._cursorParents.set(t4, a3), { position: r3.position, cursorParent: a3 };
          }
          _registerSplitPair(t4, e4) {
            this._splitParts.has(t4) || this._splitParts.set(t4, [t4]);
            const n3 = this._splitParts.get(t4);
            this._splitParts.set(e4, n3), n3.push(e4);
          }
          _getSplitParts(t4) {
            let e4;
            return e4 = this._splitParts.has(t4) ? this._splitParts.get(t4) : [t4], e4;
          }
          _keepEmptyElement(t4) {
            this._emptyElementsToKeep.add(t4);
          }
          _removeEmptyElements() {
            let t4 = false;
            for (const e4 of this._splitParts.keys())
              e4.isEmpty && !this._emptyElementsToKeep.has(e4) && (this.conversionApi.writer.remove(e4), this._splitParts.delete(e4), t4 = true);
            t4 && this._removeEmptyElements();
          }
        }
        class ph2 {
          getHtml(t4) {
            const e4 = Li2.document.implementation.createHTMLDocument("").createElement("div");
            return e4.appendChild(t4), e4.innerHTML;
          }
        }
        class fh2 {
          constructor(t4) {
            this.skipComments = true, this.domParser = new DOMParser(), this.domConverter = new Yc2(t4, { renderingMode: "data" }), this.htmlWriter = new ph2();
          }
          toData(t4) {
            const e4 = this.domConverter.viewToDom(t4);
            return this.htmlWriter.getHtml(e4);
          }
          toView(t4) {
            const e4 = this._toDom(t4);
            return this.domConverter.domToView(e4, { skipComments: this.skipComments });
          }
          registerRawContentMatcher(t4) {
            this.domConverter.registerRawContentMatcher(t4);
          }
          useFillerType(t4) {
            this.domConverter.blockFillerMode = "marked" == t4 ? "markedNbsp" : "nbsp";
          }
          _toDom(t4) {
            t4.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (t4 = `<body>${t4}</body>`);
            const e4 = this.domParser.parseFromString(t4, "text/html"), n3 = e4.createDocumentFragment(), i3 = e4.body.childNodes;
            for (; i3.length > 0; )
              n3.appendChild(i3[0]);
            return n3;
          }
        }
        class kh2 extends B2() {
          constructor(t4, e4) {
            super(), this.model = t4, this.mapper = new ed2(), this.downcastDispatcher = new od2({ mapper: this.mapper, schema: t4.schema }), this.downcastDispatcher.on("insert:$text", (t5, e5, n3) => {
              if (!n3.consumable.consume(e5.item, t5.name))
                return;
              const i3 = n3.writer, o3 = n3.mapper.toViewPosition(e5.range.start), r3 = i3.createText(e5.item.data);
              i3.insert(o3, r3);
            }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (t5, e5, n3) => {
              n3.convertAttributes(e5.item), e5.reconversion || !e5.item.is("element") || e5.item.isEmpty || n3.convertChildren(e5.item);
            }, { priority: "lowest" }), this.upcastDispatcher = new mh2({ schema: t4.schema }), this.viewDocument = new rc2(e4), this.stylesProcessor = e4, this.htmlProcessor = new fh2(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new kc2(this.viewDocument), this.upcastDispatcher.on("text", (t5, e5, { schema: n3, consumable: i3, writer: o3 }) => {
              let r3 = e5.modelCursor;
              if (!i3.test(e5.viewItem))
                return;
              if (!n3.checkChild(r3, "$text")) {
                if (!Pd2(r3, "$text", n3))
                  return;
                if (0 == e5.viewItem.data.trim().length)
                  return;
                const t6 = r3.nodeBefore;
                r3 = Rd2(r3, o3), t6 && t6.is("element", "$marker") && (o3.move(o3.createRangeOn(t6), r3), r3 = o3.createPositionAfter(t6));
              }
              i3.consume(e5.viewItem);
              const s3 = o3.createText(e5.viewItem.data);
              o3.insert(s3, r3), e5.modelRange = o3.createRange(r3, r3.getShiftedBy(s3.offsetSize)), e5.modelCursor = e5.modelRange.end;
            }, { priority: "lowest" }), this.upcastDispatcher.on("element", (t5, e5, n3) => {
              if (!e5.modelRange && n3.consumable.consume(e5.viewItem, { name: true })) {
                const { modelRange: t6, modelCursor: i3 } = n3.convertChildren(e5.viewItem, e5.modelCursor);
                e5.modelRange = t6, e5.modelCursor = i3;
              }
            }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (t5, e5, n3) => {
              if (!e5.modelRange && n3.consumable.consume(e5.viewItem, { name: true })) {
                const { modelRange: t6, modelCursor: i3 } = n3.convertChildren(e5.viewItem, e5.modelCursor);
                e5.modelRange = t6, e5.modelCursor = i3;
              }
            }, { priority: "lowest" }), q2().prototype.decorate.call(this, "init"), q2().prototype.decorate.call(this, "set"), q2().prototype.decorate.call(this, "get"), q2().prototype.decorate.call(this, "toView"), q2().prototype.decorate.call(this, "toModel"), this.on("init", () => {
              this.fire("ready");
            }, { priority: "lowest" }), this.on("ready", () => {
              this.model.enqueueChange({ isUndoable: false }, zd2);
            }, { priority: "lowest" });
          }
          get(t4 = {}) {
            const { rootName: e4 = "main", trim: n3 = "empty" } = t4;
            if (!this._checkIfRootsExists([e4]))
              throw new C2("datacontroller-get-non-existent-root", this);
            const i3 = this.model.document.getRoot(e4);
            return i3.isAttached() || _2("datacontroller-get-detached-root", this), "empty" !== n3 || this.model.hasContent(i3, { ignoreWhitespaces: true }) ? this.stringify(i3, t4) : "";
          }
          stringify(t4, e4 = {}) {
            const n3 = this.toView(t4, e4);
            return this.processor.toData(n3);
          }
          toView(t4, e4 = {}) {
            const n3 = this.viewDocument, i3 = this._viewWriter;
            this.mapper.clearBindings();
            const o3 = td2._createIn(t4), r3 = new fc2(n3);
            this.mapper.bindElements(t4, r3);
            const s3 = t4.is("documentFragment") ? t4.markers : function(t5) {
              const e5 = [], n4 = t5.root.document;
              if (!n4)
                return /* @__PURE__ */ new Map();
              const i4 = td2._createIn(t5);
              for (const t6 of n4.model.markers) {
                const n5 = t6.getRange(), o4 = n5.isCollapsed, r4 = n5.start.isEqual(i4.start) || n5.end.isEqual(i4.end);
                if (o4 && r4)
                  e5.push([t6.name, n5]);
                else {
                  const o5 = i4.getIntersection(n5);
                  o5 && e5.push([t6.name, o5]);
                }
              }
              return e5.sort(([t6, e6], [n5, i5]) => {
                if ("after" !== e6.end.compareWith(i5.start))
                  return 1;
                if ("before" !== e6.start.compareWith(i5.end))
                  return -1;
                switch (e6.start.compareWith(i5.start)) {
                  case "before":
                    return 1;
                  case "after":
                    return -1;
                  default:
                    switch (e6.end.compareWith(i5.end)) {
                      case "before":
                        return 1;
                      case "after":
                        return -1;
                      default:
                        return n5.localeCompare(t6);
                    }
                }
              }), new Map(e5);
            }(t4);
            return this.downcastDispatcher.convert(o3, s3, i3, e4), r3;
          }
          init(t4) {
            if (this.model.document.version)
              throw new C2("datacontroller-init-document-not-empty", this);
            let e4 = {};
            if ("string" == typeof t4 ? e4.main = t4 : e4 = t4, !this._checkIfRootsExists(Object.keys(e4)))
              throw new C2("datacontroller-init-non-existent-root", this);
            return this.model.enqueueChange({ isUndoable: false }, (t5) => {
              for (const n3 of Object.keys(e4)) {
                const i3 = this.model.document.getRoot(n3);
                t5.insert(this.parse(e4[n3], i3), i3, 0);
              }
            }), Promise.resolve();
          }
          set(t4, e4 = {}) {
            let n3 = {};
            if ("string" == typeof t4 ? n3.main = t4 : n3 = t4, !this._checkIfRootsExists(Object.keys(n3)))
              throw new C2("datacontroller-set-non-existent-root", this);
            this.model.enqueueChange(e4.batchType || {}, (t5) => {
              t5.setSelection(null), t5.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
              for (const e5 of Object.keys(n3)) {
                const i3 = this.model.document.getRoot(e5);
                t5.remove(t5.createRangeIn(i3)), t5.insert(this.parse(n3[e5], i3), i3, 0);
              }
            });
          }
          parse(t4, e4 = "$root") {
            const n3 = this.processor.toView(t4);
            return this.toModel(n3, e4);
          }
          toModel(t4, e4 = "$root") {
            return this.model.change((n3) => this.upcastDispatcher.convert(t4, n3, e4));
          }
          addStyleProcessorRules(t4) {
            t4(this.stylesProcessor);
          }
          registerRawContentMatcher(t4) {
            this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(t4), this.htmlProcessor.registerRawContentMatcher(t4);
          }
          destroy() {
            this.stopListening();
          }
          _checkIfRootsExists(t4) {
            for (const e4 of t4)
              if (!this.model.document.getRoot(e4))
                return false;
            return true;
          }
        }
        class bh2 {
          constructor(t4, e4) {
            this._helpers = /* @__PURE__ */ new Map(), this._downcast = yo2(t4), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: true }), this._upcast = yo2(e4), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: false });
          }
          addAlias(t4, e4) {
            const n3 = this._downcast.includes(e4);
            if (!this._upcast.includes(e4) && !n3)
              throw new C2("conversion-add-alias-dispatcher-not-registered", this);
            this._createConversionHelpers({ name: t4, dispatchers: [e4], isDowncast: n3 });
          }
          for(t4) {
            if (!this._helpers.has(t4))
              throw new C2("conversion-for-unknown-group", this);
            return this._helpers.get(t4);
          }
          elementToElement(t4) {
            this.for("downcast").elementToElement(t4);
            for (const { model: e4, view: n3 } of wh2(t4))
              this.for("upcast").elementToElement({ model: e4, view: n3, converterPriority: t4.converterPriority });
          }
          attributeToElement(t4) {
            this.for("downcast").attributeToElement(t4);
            for (const { model: e4, view: n3 } of wh2(t4))
              this.for("upcast").elementToAttribute({ view: n3, model: e4, converterPriority: t4.converterPriority });
          }
          attributeToAttribute(t4) {
            this.for("downcast").attributeToAttribute(t4);
            for (const { model: e4, view: n3 } of wh2(t4))
              this.for("upcast").attributeToAttribute({ view: n3, model: e4 });
          }
          _createConversionHelpers({ name: t4, dispatchers: e4, isDowncast: n3 }) {
            if (this._helpers.has(t4))
              throw new C2("conversion-group-exists", this);
            const i3 = n3 ? new _d(e4) : new Od2(e4);
            this._helpers.set(t4, i3);
          }
        }
        function* wh2(t4) {
          if (t4.model.values)
            for (const e4 of t4.model.values) {
              const n3 = { key: t4.model.key, value: e4 }, i3 = t4.view[e4], o3 = t4.upcastAlso ? t4.upcastAlso[e4] : void 0;
              yield* Ah2(n3, i3, o3);
            }
          else
            yield* Ah2(t4.model, t4.view, t4.upcastAlso);
        }
        function* Ah2(t4, e4, n3) {
          if (yield { model: t4, view: e4 }, n3)
            for (const e5 of yo2(n3))
              yield { model: t4, view: e5 };
        }
        class Ch2 {
          constructor(t4) {
            this.baseVersion = t4, this.isDocumentOperation = null !== this.baseVersion, this.batch = null;
          }
          _validate() {
          }
          toJSON() {
            const t4 = Object.assign({}, this);
            return t4.__className = this.constructor.className, delete t4.batch, delete t4.isDocumentOperation, t4;
          }
          static get className() {
            return "Operation";
          }
          static fromJSON(t4, e4) {
            return new this(t4.baseVersion);
          }
        }
        function _h(t4, e4) {
          const n3 = xh2(e4), i3 = n3.reduce((t5, e5) => t5 + e5.offsetSize, 0), o3 = t4.parent;
          Dh2(t4);
          const r3 = t4.index;
          return o3._insertChild(r3, n3), Eh2(o3, r3 + n3.length), Eh2(o3, r3), new td2(t4, t4.getShiftedBy(i3));
        }
        function vh2(t4) {
          if (!t4.isFlat)
            throw new C2("operation-utils-remove-range-not-flat", this);
          const e4 = t4.start.parent;
          Dh2(t4.start), Dh2(t4.end);
          const n3 = e4._removeChildren(t4.start.index, t4.end.index - t4.start.index);
          return Eh2(e4, t4.start.index), n3;
        }
        function yh2(t4, e4) {
          if (!t4.isFlat)
            throw new C2("operation-utils-move-range-not-flat", this);
          const n3 = vh2(t4);
          return _h(e4 = e4._getTransformedByDeletion(t4.start, t4.end.offset - t4.start.offset), n3);
        }
        function xh2(t4) {
          const e4 = [];
          !function t5(n3) {
            if ("string" == typeof n3)
              e4.push(new Ul(n3));
            else if (n3 instanceof Gl)
              e4.push(new Ul(n3.data, n3.getAttributes()));
            else if (n3 instanceof jl2)
              e4.push(n3);
            else if (et2(n3))
              for (const e5 of n3)
                t5(e5);
            else
              ;
          }(t4);
          for (let t5 = 1; t5 < e4.length; t5++) {
            const n3 = e4[t5], i3 = e4[t5 - 1];
            n3 instanceof Ul && i3 instanceof Ul && Sh2(n3, i3) && (e4.splice(t5 - 1, 2, new Ul(i3.data + n3.data, i3.getAttributes())), t5--);
          }
          return e4;
        }
        function Eh2(t4, e4) {
          const n3 = t4.getChild(e4 - 1), i3 = t4.getChild(e4);
          if (n3 && i3 && n3.is("$text") && i3.is("$text") && Sh2(n3, i3)) {
            const o3 = new Ul(n3.data + i3.data, n3.getAttributes());
            t4._removeChildren(e4 - 1, 2), t4._insertChild(e4 - 1, o3);
          }
        }
        function Dh2(t4) {
          const e4 = t4.textNode, n3 = t4.parent;
          if (e4) {
            const i3 = t4.offset - e4.startOffset, o3 = e4.index;
            n3._removeChildren(o3, 1);
            const r3 = new Ul(e4.data.substr(0, i3), e4.getAttributes()), s3 = new Ul(e4.data.substr(i3), e4.getAttributes());
            n3._insertChild(o3, [r3, s3]);
          }
        }
        function Sh2(t4, e4) {
          const n3 = t4.getAttributes(), i3 = e4.getAttributes();
          for (const t5 of n3) {
            if (t5[1] !== e4.getAttribute(t5[0]))
              return false;
            i3.next();
          }
          return i3.next().done;
        }
        class Th2 extends Ch2 {
          constructor(t4, e4, n3, i3) {
            super(i3), this.sourcePosition = t4.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = e4, this.targetPosition = n3.clone(), this.targetPosition.stickiness = "toNone";
          }
          get type() {
            return "$graveyard" == this.targetPosition.root.rootName ? "remove" : "$graveyard" == this.sourcePosition.root.rootName ? "reinsert" : "move";
          }
          get affectedSelectable() {
            return [td2._createFromPositionAndShift(this.sourcePosition, this.howMany), td2._createFromPositionAndShift(this.targetPosition, 0)];
          }
          clone() {
            return new Th2(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
          }
          getMovedRangeStart() {
            return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
          }
          getReversed() {
            const t4 = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
            return new Th2(this.getMovedRangeStart(), this.howMany, t4, this.baseVersion + 1);
          }
          _validate() {
            const t4 = this.sourcePosition.parent, e4 = this.targetPosition.parent, n3 = this.sourcePosition.offset, i3 = this.targetPosition.offset;
            if (n3 + this.howMany > t4.maxOffset)
              throw new C2("move-operation-nodes-do-not-exist", this);
            if (t4 === e4 && n3 < i3 && i3 < n3 + this.howMany)
              throw new C2("move-operation-range-into-itself", this);
            if (this.sourcePosition.root == this.targetPosition.root && "prefix" == tt2(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath())) {
              const t5 = this.sourcePosition.path.length - 1;
              if (this.targetPosition.path[t5] >= n3 && this.targetPosition.path[t5] < n3 + this.howMany)
                throw new C2("move-operation-node-into-itself", this);
            }
          }
          _execute() {
            yh2(td2._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.sourcePosition = this.sourcePosition.toJSON(), t4.targetPosition = this.targetPosition.toJSON(), t4;
          }
          static get className() {
            return "MoveOperation";
          }
          static fromJSON(t4, e4) {
            const n3 = Kl.fromJSON(t4.sourcePosition, e4), i3 = Kl.fromJSON(t4.targetPosition, e4);
            return new this(n3, t4.howMany, i3, t4.baseVersion);
          }
        }
        class Ih2 extends Ch2 {
          constructor(t4, e4, n3) {
            super(n3), this.position = t4.clone(), this.position.stickiness = "toNone", this.nodes = new Hl(xh2(e4)), this.shouldReceiveAttributes = false;
          }
          get type() {
            return "insert";
          }
          get howMany() {
            return this.nodes.maxOffset;
          }
          get affectedSelectable() {
            return this.position.clone();
          }
          clone() {
            const t4 = new Hl([...this.nodes].map((t5) => t5._clone(true))), e4 = new Ih2(this.position, t4, this.baseVersion);
            return e4.shouldReceiveAttributes = this.shouldReceiveAttributes, e4;
          }
          getReversed() {
            const t4 = this.position.root.document.graveyard, e4 = new Kl(t4, [0]);
            return new Th2(this.position, this.nodes.maxOffset, e4, this.baseVersion + 1);
          }
          _validate() {
            const t4 = this.position.parent;
            if (!t4 || t4.maxOffset < this.position.offset)
              throw new C2("insert-operation-position-invalid", this);
          }
          _execute() {
            const t4 = this.nodes;
            this.nodes = new Hl([...t4].map((t5) => t5._clone(true))), _h(this.position, t4);
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.position = this.position.toJSON(), t4.nodes = this.nodes.toJSON(), t4;
          }
          static get className() {
            return "InsertOperation";
          }
          static fromJSON(t4, e4) {
            const n3 = [];
            for (const e5 of t4.nodes)
              e5.name ? n3.push(Wl.fromJSON(e5)) : n3.push(Ul.fromJSON(e5));
            const i3 = new Ih2(Kl.fromJSON(t4.position, e4), n3, t4.baseVersion);
            return i3.shouldReceiveAttributes = t4.shouldReceiveAttributes, i3;
          }
        }
        class Bh2 extends Ch2 {
          constructor(t4, e4, n3, i3, o3) {
            super(o3), this.splitPosition = t4.clone(), this.splitPosition.stickiness = "toNext", this.howMany = e4, this.insertionPosition = n3, this.graveyardPosition = i3 ? i3.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
          }
          get type() {
            return "split";
          }
          get moveTargetPosition() {
            const t4 = this.insertionPosition.path.slice();
            return t4.push(0), new Kl(this.insertionPosition.root, t4);
          }
          get movedRange() {
            const t4 = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new td2(this.splitPosition, t4);
          }
          get affectedSelectable() {
            const t4 = [td2._createFromPositionAndShift(this.splitPosition, 0), td2._createFromPositionAndShift(this.insertionPosition, 0)];
            return this.graveyardPosition && t4.push(td2._createFromPositionAndShift(this.graveyardPosition, 0)), t4;
          }
          clone() {
            return new Bh2(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
          }
          getReversed() {
            const t4 = this.splitPosition.root.document.graveyard, e4 = new Kl(t4, [0]);
            return new Mh2(this.moveTargetPosition, this.howMany, this.splitPosition, e4, this.baseVersion + 1);
          }
          _validate() {
            const t4 = this.splitPosition.parent, e4 = this.splitPosition.offset;
            if (!t4 || t4.maxOffset < e4)
              throw new C2("split-operation-position-invalid", this);
            if (!t4.parent)
              throw new C2("split-operation-split-in-root", this);
            if (this.howMany != t4.maxOffset - this.splitPosition.offset)
              throw new C2("split-operation-how-many-invalid", this);
            if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
              throw new C2("split-operation-graveyard-position-invalid", this);
          }
          _execute() {
            const t4 = this.splitPosition.parent;
            if (this.graveyardPosition)
              yh2(td2._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
            else {
              const e4 = t4._clone();
              _h(this.insertionPosition, e4);
            }
            yh2(new td2(Kl._createAt(t4, this.splitPosition.offset), Kl._createAt(t4, t4.maxOffset)), this.moveTargetPosition);
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.splitPosition = this.splitPosition.toJSON(), t4.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (t4.graveyardPosition = this.graveyardPosition.toJSON()), t4;
          }
          static get className() {
            return "SplitOperation";
          }
          static getInsertionPosition(t4) {
            const e4 = t4.path.slice(0, -1);
            return e4[e4.length - 1]++, new Kl(t4.root, e4, "toPrevious");
          }
          static fromJSON(t4, e4) {
            const n3 = Kl.fromJSON(t4.splitPosition, e4), i3 = Kl.fromJSON(t4.insertionPosition, e4), o3 = t4.graveyardPosition ? Kl.fromJSON(t4.graveyardPosition, e4) : null;
            return new this(n3, t4.howMany, i3, o3, t4.baseVersion);
          }
        }
        class Mh2 extends Ch2 {
          constructor(t4, e4, n3, i3, o3) {
            super(o3), this.sourcePosition = t4.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = e4, this.targetPosition = n3.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = i3.clone();
          }
          get type() {
            return "merge";
          }
          get deletionPosition() {
            return new Kl(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
          }
          get movedRange() {
            const t4 = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
            return new td2(this.sourcePosition, t4);
          }
          get affectedSelectable() {
            const t4 = this.sourcePosition.parent;
            return [td2._createOn(t4), td2._createFromPositionAndShift(this.targetPosition, 0), td2._createFromPositionAndShift(this.graveyardPosition, 0)];
          }
          clone() {
            return new Mh2(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
          }
          getReversed() {
            const t4 = this.targetPosition._getTransformedByMergeOperation(this), e4 = this.sourcePosition.path.slice(0, -1), n3 = new Kl(this.sourcePosition.root, e4)._getTransformedByMergeOperation(this);
            return new Bh2(t4, this.howMany, n3, this.graveyardPosition, this.baseVersion + 1);
          }
          _validate() {
            const t4 = this.sourcePosition.parent, e4 = this.targetPosition.parent;
            if (!t4.parent)
              throw new C2("merge-operation-source-position-invalid", this);
            if (!e4.parent)
              throw new C2("merge-operation-target-position-invalid", this);
            if (this.howMany != t4.maxOffset)
              throw new C2("merge-operation-how-many-invalid", this);
          }
          _execute() {
            const t4 = this.sourcePosition.parent;
            yh2(td2._createIn(t4), this.targetPosition), yh2(td2._createOn(t4), this.graveyardPosition);
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.sourcePosition = t4.sourcePosition.toJSON(), t4.targetPosition = t4.targetPosition.toJSON(), t4.graveyardPosition = t4.graveyardPosition.toJSON(), t4;
          }
          static get className() {
            return "MergeOperation";
          }
          static fromJSON(t4, e4) {
            const n3 = Kl.fromJSON(t4.sourcePosition, e4), i3 = Kl.fromJSON(t4.targetPosition, e4), o3 = Kl.fromJSON(t4.graveyardPosition, e4);
            return new this(n3, t4.howMany, i3, o3, t4.baseVersion);
          }
        }
        class Nh2 extends Ch2 {
          constructor(t4, e4, n3, i3, o3, r3) {
            super(r3), this.name = t4, this.oldRange = e4 ? e4.clone() : null, this.newRange = n3 ? n3.clone() : null, this.affectsData = o3, this._markers = i3;
          }
          get type() {
            return "marker";
          }
          get affectedSelectable() {
            const t4 = [];
            return this.oldRange && t4.push(this.oldRange.clone()), this.newRange && (this.oldRange ? t4.push(...this.newRange.getDifference(this.oldRange)) : t4.push(this.newRange.clone())), t4;
          }
          clone() {
            return new Nh2(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
          }
          getReversed() {
            return new Nh2(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
          }
          _execute() {
            this.newRange ? this._markers._set(this.name, this.newRange, true, this.affectsData) : this._markers._remove(this.name);
          }
          toJSON() {
            const t4 = super.toJSON();
            return this.oldRange && (t4.oldRange = this.oldRange.toJSON()), this.newRange && (t4.newRange = this.newRange.toJSON()), delete t4._markers, t4;
          }
          static get className() {
            return "MarkerOperation";
          }
          static fromJSON(t4, e4) {
            return new Nh2(t4.name, t4.oldRange ? td2.fromJSON(t4.oldRange, e4) : null, t4.newRange ? td2.fromJSON(t4.newRange, e4) : null, e4.model.markers, t4.affectsData, t4.baseVersion);
          }
        }
        const Lh2 = function(t4, e4) {
          return El(t4, e4);
        };
        class zh2 extends Ch2 {
          constructor(t4, e4, n3, i3, o3) {
            super(o3), this.range = t4.clone(), this.key = e4, this.oldValue = void 0 === n3 ? null : n3, this.newValue = void 0 === i3 ? null : i3;
          }
          get type() {
            return null === this.oldValue ? "addAttribute" : null === this.newValue ? "removeAttribute" : "changeAttribute";
          }
          get affectedSelectable() {
            return this.range.clone();
          }
          clone() {
            return new zh2(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new zh2(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.range = this.range.toJSON(), t4;
          }
          _validate() {
            if (!this.range.isFlat)
              throw new C2("attribute-operation-range-not-flat", this);
            for (const t4 of this.range.getItems({ shallow: true })) {
              if (null !== this.oldValue && !Lh2(t4.getAttribute(this.key), this.oldValue))
                throw new C2("attribute-operation-wrong-old-value", this, { item: t4, key: this.key, value: this.oldValue });
              if (null === this.oldValue && null !== this.newValue && t4.hasAttribute(this.key))
                throw new C2("attribute-operation-attribute-exists", this, { node: t4, key: this.key });
            }
          }
          _execute() {
            Lh2(this.oldValue, this.newValue) || function(t4, e4, n3) {
              Dh2(t4.start), Dh2(t4.end);
              for (const i3 of t4.getItems({ shallow: true })) {
                const t5 = i3.is("$textProxy") ? i3.textNode : i3;
                null !== n3 ? t5._setAttribute(e4, n3) : t5._removeAttribute(e4), Eh2(t5.parent, t5.index);
              }
              Eh2(t4.end.parent, t4.end.index);
            }(this.range, this.key, this.newValue);
          }
          static get className() {
            return "AttributeOperation";
          }
          static fromJSON(t4, e4) {
            return new zh2(td2.fromJSON(t4.range, e4), t4.key, t4.oldValue, t4.newValue, t4.baseVersion);
          }
        }
        class Ph2 extends Ch2 {
          get type() {
            return "noop";
          }
          get affectedSelectable() {
            return null;
          }
          clone() {
            return new Ph2(this.baseVersion);
          }
          getReversed() {
            return new Ph2(this.baseVersion + 1);
          }
          _execute() {
          }
          static get className() {
            return "NoOperation";
          }
        }
        class Rh2 extends Ch2 {
          constructor(t4, e4, n3, i3) {
            super(i3), this.position = t4, this.position.stickiness = "toNext", this.oldName = e4, this.newName = n3;
          }
          get type() {
            return "rename";
          }
          get affectedSelectable() {
            return this.position.nodeAfter;
          }
          clone() {
            return new Rh2(this.position.clone(), this.oldName, this.newName, this.baseVersion);
          }
          getReversed() {
            return new Rh2(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
          }
          _validate() {
            const t4 = this.position.nodeAfter;
            if (!(t4 instanceof Wl))
              throw new C2("rename-operation-wrong-position", this);
            if (t4.name !== this.oldName)
              throw new C2("rename-operation-wrong-name", this);
          }
          _execute() {
            this.position.nodeAfter.name = this.newName;
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.position = this.position.toJSON(), t4;
          }
          static get className() {
            return "RenameOperation";
          }
          static fromJSON(t4, e4) {
            return new Rh2(Kl.fromJSON(t4.position, e4), t4.oldName, t4.newName, t4.baseVersion);
          }
        }
        class Oh2 extends Ch2 {
          constructor(t4, e4, n3, i3, o3) {
            super(o3), this.root = t4, this.key = e4, this.oldValue = void 0 === n3 ? null : n3, this.newValue = void 0 === i3 ? null : i3;
          }
          get type() {
            return null === this.oldValue ? "addRootAttribute" : null === this.newValue ? "removeRootAttribute" : "changeRootAttribute";
          }
          get affectedSelectable() {
            return this.root;
          }
          clone() {
            return new Oh2(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
          }
          getReversed() {
            return new Oh2(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
          }
          _validate() {
            if (this.root != this.root.root || this.root.is("documentFragment"))
              throw new C2("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
            if (null !== this.oldValue && this.root.getAttribute(this.key) !== this.oldValue)
              throw new C2("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
            if (null === this.oldValue && null !== this.newValue && this.root.hasAttribute(this.key))
              throw new C2("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
          }
          _execute() {
            null !== this.newValue ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.root = this.root.toJSON(), t4;
          }
          static get className() {
            return "RootAttributeOperation";
          }
          static fromJSON(t4, e4) {
            if (!e4.getRoot(t4.root))
              throw new C2("rootattribute-operation-fromjson-no-root", this, { rootName: t4.root });
            return new Oh2(e4.getRoot(t4.root), t4.key, t4.oldValue, t4.newValue, t4.baseVersion);
          }
        }
        class Fh2 extends Ch2 {
          constructor(t4, e4, n3, i3, o3) {
            if (super(o3), this.rootName = t4, this.elementName = e4, this.isAdd = n3, this._document = i3, !this._document.getRoot(this.rootName)) {
              this._document.createRoot(this.elementName, this.rootName)._isAttached = false;
            }
          }
          get type() {
            return this.isAdd ? "addRoot" : "detachRoot";
          }
          get affectedSelectable() {
            return this._document.getRoot(this.rootName);
          }
          clone() {
            return new Fh2(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
          }
          getReversed() {
            return new Fh2(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
          }
          _execute() {
            this._document.getRoot(this.rootName)._isAttached = this.isAdd;
          }
          toJSON() {
            const t4 = super.toJSON();
            return delete t4._document, t4;
          }
          static get className() {
            return "RootOperation";
          }
          static fromJSON(t4, e4) {
            return new Fh2(t4.rootName, t4.elementName, t4.isAdd, e4, t4.baseVersion);
          }
        }
        const Vh2 = {};
        Vh2[zh2.className] = zh2, Vh2[Ih2.className] = Ih2, Vh2[Nh2.className] = Nh2, Vh2[Th2.className] = Th2, Vh2[Ph2.className] = Ph2, Vh2[Ch2.className] = Ch2, Vh2[Rh2.className] = Rh2, Vh2[Oh2.className] = Oh2, Vh2[Fh2.className] = Fh2, Vh2[Bh2.className] = Bh2, Vh2[Mh2.className] = Mh2;
        class jh2 {
          static fromJSON(t4, e4) {
            return Vh2[t4.__className].fromJSON(t4, e4);
          }
        }
        const Hh2 = /* @__PURE__ */ new Map();
        function Uh2(t4, e4, n3) {
          let i3 = Hh2.get(t4);
          i3 || (i3 = /* @__PURE__ */ new Map(), Hh2.set(t4, i3)), i3.set(e4, n3);
        }
        function Gh2(t4) {
          return [t4];
        }
        function Wh2(t4, e4, n3 = {}) {
          const i3 = function(t5, e5) {
            const n4 = Hh2.get(t5);
            return n4 && n4.has(e5) ? n4.get(e5) : Gh2;
          }(t4.constructor, e4.constructor);
          try {
            return i3(t4 = t4.clone(), e4, n3);
          } catch (t5) {
            throw t5;
          }
        }
        function qh2(t4, e4, n3) {
          t4 = t4.slice(), e4 = e4.slice();
          const i3 = new $h2(n3.document, n3.useRelations, n3.forceWeakRemove);
          i3.setOriginalOperations(t4), i3.setOriginalOperations(e4);
          const o3 = i3.originalOperations;
          if (0 == t4.length || 0 == e4.length)
            return { operationsA: t4, operationsB: e4, originalOperations: o3 };
          const r3 = /* @__PURE__ */ new WeakMap();
          for (const e5 of t4)
            r3.set(e5, 0);
          const s3 = { nextBaseVersionA: t4[t4.length - 1].baseVersion + 1, nextBaseVersionB: e4[e4.length - 1].baseVersion + 1, originalOperationsACount: t4.length, originalOperationsBCount: e4.length };
          let a3 = 0;
          for (; a3 < t4.length; ) {
            const n4 = t4[a3], o4 = r3.get(n4);
            if (o4 == e4.length) {
              a3++;
              continue;
            }
            const s4 = e4[o4], c3 = Wh2(n4, s4, i3.getContext(n4, s4, true)), l3 = Wh2(s4, n4, i3.getContext(s4, n4, false));
            i3.updateRelation(n4, s4), i3.setOriginalOperations(c3, n4), i3.setOriginalOperations(l3, s4);
            for (const t5 of c3)
              r3.set(t5, o4 + l3.length);
            t4.splice(a3, 1, ...c3), e4.splice(o4, 1, ...l3);
          }
          if (n3.padWithNoOps) {
            const n4 = t4.length - s3.originalOperationsACount, i4 = e4.length - s3.originalOperationsBCount;
            Zh2(t4, i4 - n4), Zh2(e4, n4 - i4);
          }
          return Kh2(t4, s3.nextBaseVersionB), Kh2(e4, s3.nextBaseVersionA), { operationsA: t4, operationsB: e4, originalOperations: o3 };
        }
        class $h2 {
          constructor(t4, e4, n3 = false) {
            this.originalOperations = /* @__PURE__ */ new Map(), this._history = t4.history, this._useRelations = e4, this._forceWeakRemove = !!n3, this._relations = /* @__PURE__ */ new Map();
          }
          setOriginalOperations(t4, e4 = null) {
            const n3 = e4 ? this.originalOperations.get(e4) : null;
            for (const e5 of t4)
              this.originalOperations.set(e5, n3 || e5);
          }
          updateRelation(t4, e4) {
            if (t4 instanceof Th2)
              e4 instanceof Mh2 ? t4.targetPosition.isEqual(e4.sourcePosition) || e4.movedRange.containsPosition(t4.targetPosition) ? this._setRelation(t4, e4, "insertAtSource") : t4.targetPosition.isEqual(e4.deletionPosition) ? this._setRelation(t4, e4, "insertBetween") : t4.targetPosition.isAfter(e4.sourcePosition) && this._setRelation(t4, e4, "moveTargetAfter") : e4 instanceof Th2 && (t4.targetPosition.isEqual(e4.sourcePosition) || t4.targetPosition.isBefore(e4.sourcePosition) ? this._setRelation(t4, e4, "insertBefore") : this._setRelation(t4, e4, "insertAfter"));
            else if (t4 instanceof Bh2) {
              if (e4 instanceof Mh2)
                t4.splitPosition.isBefore(e4.sourcePosition) && this._setRelation(t4, e4, "splitBefore");
              else if (e4 instanceof Th2)
                if (t4.splitPosition.isEqual(e4.sourcePosition) || t4.splitPosition.isBefore(e4.sourcePosition))
                  this._setRelation(t4, e4, "splitBefore");
                else {
                  const n3 = td2._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
                  if (t4.splitPosition.hasSameParentAs(e4.sourcePosition) && n3.containsPosition(t4.splitPosition)) {
                    const i3 = n3.end.offset - t4.splitPosition.offset, o3 = t4.splitPosition.offset - n3.start.offset;
                    this._setRelation(t4, e4, { howMany: i3, offset: o3 });
                  }
                }
            } else if (t4 instanceof Mh2)
              e4 instanceof Mh2 ? (t4.targetPosition.isEqual(e4.sourcePosition) || this._setRelation(t4, e4, "mergeTargetNotMoved"), t4.sourcePosition.isEqual(e4.targetPosition) && this._setRelation(t4, e4, "mergeSourceNotMoved"), t4.sourcePosition.isEqual(e4.sourcePosition) && this._setRelation(t4, e4, "mergeSameElement")) : e4 instanceof Bh2 && t4.sourcePosition.isEqual(e4.splitPosition) && this._setRelation(t4, e4, "splitAtSource");
            else if (t4 instanceof Nh2) {
              const n3 = t4.newRange;
              if (!n3)
                return;
              if (e4 instanceof Th2) {
                const i3 = td2._createFromPositionAndShift(e4.sourcePosition, e4.howMany), o3 = i3.containsPosition(n3.start) || i3.start.isEqual(n3.start), r3 = i3.containsPosition(n3.end) || i3.end.isEqual(n3.end);
                !o3 && !r3 || i3.containsRange(n3) || this._setRelation(t4, e4, { side: o3 ? "left" : "right", path: o3 ? n3.start.path.slice() : n3.end.path.slice() });
              } else if (e4 instanceof Mh2) {
                const i3 = n3.start.isEqual(e4.targetPosition), o3 = n3.start.isEqual(e4.deletionPosition), r3 = n3.end.isEqual(e4.deletionPosition), s3 = n3.end.isEqual(e4.sourcePosition);
                (i3 || o3 || r3 || s3) && this._setRelation(t4, e4, { wasInLeftElement: i3, wasStartBeforeMergedElement: o3, wasEndBeforeMergedElement: r3, wasInRightElement: s3 });
              }
            }
          }
          getContext(t4, e4, n3) {
            return { aIsStrong: n3, aWasUndone: this._wasUndone(t4), bWasUndone: this._wasUndone(e4), abRelation: this._useRelations ? this._getRelation(t4, e4) : null, baRelation: this._useRelations ? this._getRelation(e4, t4) : null, forceWeakRemove: this._forceWeakRemove };
          }
          _wasUndone(t4) {
            const e4 = this.originalOperations.get(t4);
            return e4.wasUndone || this._history.isUndoneOperation(e4);
          }
          _getRelation(t4, e4) {
            const n3 = this.originalOperations.get(e4), i3 = this._history.getUndoneOperation(n3);
            if (!i3)
              return null;
            const o3 = this.originalOperations.get(t4), r3 = this._relations.get(o3);
            return r3 && r3.get(i3) || null;
          }
          _setRelation(t4, e4, n3) {
            const i3 = this.originalOperations.get(t4), o3 = this.originalOperations.get(e4);
            let r3 = this._relations.get(i3);
            r3 || (r3 = /* @__PURE__ */ new Map(), this._relations.set(i3, r3)), r3.set(o3, n3);
          }
        }
        function Kh2(t4, e4) {
          for (const n3 of t4)
            n3.baseVersion = e4++;
        }
        function Zh2(t4, e4) {
          for (let n3 = 0; n3 < e4; n3++)
            t4.push(new Ph2(0));
        }
        function Yh2(t4, e4, n3) {
          const i3 = t4.nodes.getNode(0).getAttribute(e4);
          if (i3 == n3)
            return null;
          const o3 = new td2(t4.position, t4.position.getShiftedBy(t4.howMany));
          return new zh2(o3, e4, i3, n3, 0);
        }
        function Qh2(t4, e4) {
          return null === t4.targetPosition._getTransformedByDeletion(e4.sourcePosition, e4.howMany);
        }
        function Jh2(t4, e4) {
          const n3 = [];
          for (let i3 = 0; i3 < t4.length; i3++) {
            const o3 = t4[i3], r3 = new Th2(o3.start, o3.end.offset - o3.start.offset, e4, 0);
            n3.push(r3);
            for (let e5 = i3 + 1; e5 < t4.length; e5++)
              t4[e5] = t4[e5]._getTransformedByMove(r3.sourcePosition, r3.targetPosition, r3.howMany)[0];
            e4 = e4._getTransformedByMove(r3.sourcePosition, r3.targetPosition, r3.howMany);
          }
          return n3;
        }
        Uh2(zh2, zh2, (t4, e4, n3) => {
          if (t4.key === e4.key && t4.range.start.hasSameParentAs(e4.range.start)) {
            const i3 = t4.range.getDifference(e4.range).map((e5) => new zh2(e5, t4.key, t4.oldValue, t4.newValue, 0)), o3 = t4.range.getIntersection(e4.range);
            return o3 && n3.aIsStrong && i3.push(new zh2(o3, e4.key, e4.newValue, t4.newValue, 0)), 0 == i3.length ? [new Ph2(0)] : i3;
          }
          return [t4];
        }), Uh2(zh2, Ih2, (t4, e4) => {
          if (t4.range.start.hasSameParentAs(e4.position) && t4.range.containsPosition(e4.position)) {
            const n3 = t4.range._getTransformedByInsertion(e4.position, e4.howMany, !e4.shouldReceiveAttributes).map((e5) => new zh2(e5, t4.key, t4.oldValue, t4.newValue, t4.baseVersion));
            if (e4.shouldReceiveAttributes) {
              const i3 = Yh2(e4, t4.key, t4.oldValue);
              i3 && n3.unshift(i3);
            }
            return n3;
          }
          return t4.range = t4.range._getTransformedByInsertion(e4.position, e4.howMany, false)[0], [t4];
        }), Uh2(zh2, Mh2, (t4, e4) => {
          const n3 = [];
          t4.range.start.hasSameParentAs(e4.deletionPosition) && (t4.range.containsPosition(e4.deletionPosition) || t4.range.start.isEqual(e4.deletionPosition)) && n3.push(td2._createFromPositionAndShift(e4.graveyardPosition, 1));
          const i3 = t4.range._getTransformedByMergeOperation(e4);
          return i3.isCollapsed || n3.push(i3), n3.map((e5) => new zh2(e5, t4.key, t4.oldValue, t4.newValue, t4.baseVersion));
        }), Uh2(zh2, Th2, (t4, e4) => {
          const n3 = function(t5, e5) {
            const n4 = td2._createFromPositionAndShift(e5.sourcePosition, e5.howMany);
            let i3 = null, o3 = [];
            n4.containsRange(t5, true) ? i3 = t5 : t5.start.hasSameParentAs(n4.start) ? (o3 = t5.getDifference(n4), i3 = t5.getIntersection(n4)) : o3 = [t5];
            const r3 = [];
            for (let t6 of o3) {
              t6 = t6._getTransformedByDeletion(e5.sourcePosition, e5.howMany);
              const n5 = e5.getMovedRangeStart(), i4 = t6.start.hasSameParentAs(n5), o4 = t6._getTransformedByInsertion(n5, e5.howMany, i4);
              r3.push(...o4);
            }
            i3 && r3.push(i3._getTransformedByMove(e5.sourcePosition, e5.targetPosition, e5.howMany, false)[0]);
            return r3;
          }(t4.range, e4);
          return n3.map((e5) => new zh2(e5, t4.key, t4.oldValue, t4.newValue, t4.baseVersion));
        }), Uh2(zh2, Bh2, (t4, e4) => {
          if (t4.range.end.isEqual(e4.insertionPosition))
            return e4.graveyardPosition || t4.range.end.offset++, [t4];
          if (t4.range.start.hasSameParentAs(e4.splitPosition) && t4.range.containsPosition(e4.splitPosition)) {
            const n3 = t4.clone();
            return n3.range = new td2(e4.moveTargetPosition.clone(), t4.range.end._getCombined(e4.splitPosition, e4.moveTargetPosition)), t4.range.end = e4.splitPosition.clone(), t4.range.end.stickiness = "toPrevious", [t4, n3];
          }
          return t4.range = t4.range._getTransformedBySplitOperation(e4), [t4];
        }), Uh2(Ih2, zh2, (t4, e4) => {
          const n3 = [t4];
          if (t4.shouldReceiveAttributes && t4.position.hasSameParentAs(e4.range.start) && e4.range.containsPosition(t4.position)) {
            const i3 = Yh2(t4, e4.key, e4.newValue);
            i3 && n3.push(i3);
          }
          return n3;
        }), Uh2(Ih2, Ih2, (t4, e4, n3) => (t4.position.isEqual(e4.position) && n3.aIsStrong || (t4.position = t4.position._getTransformedByInsertOperation(e4)), [t4])), Uh2(Ih2, Th2, (t4, e4) => (t4.position = t4.position._getTransformedByMoveOperation(e4), [t4])), Uh2(Ih2, Bh2, (t4, e4) => (t4.position = t4.position._getTransformedBySplitOperation(e4), [t4])), Uh2(Ih2, Mh2, (t4, e4) => (t4.position = t4.position._getTransformedByMergeOperation(e4), [t4])), Uh2(Nh2, Ih2, (t4, e4) => (t4.oldRange && (t4.oldRange = t4.oldRange._getTransformedByInsertOperation(e4)[0]), t4.newRange && (t4.newRange = t4.newRange._getTransformedByInsertOperation(e4)[0]), [t4])), Uh2(Nh2, Nh2, (t4, e4, n3) => {
          if (t4.name == e4.name) {
            if (!n3.aIsStrong)
              return [new Ph2(0)];
            t4.oldRange = e4.newRange ? e4.newRange.clone() : null;
          }
          return [t4];
        }), Uh2(Nh2, Mh2, (t4, e4) => (t4.oldRange && (t4.oldRange = t4.oldRange._getTransformedByMergeOperation(e4)), t4.newRange && (t4.newRange = t4.newRange._getTransformedByMergeOperation(e4)), [t4])), Uh2(Nh2, Th2, (t4, e4, n3) => {
          if (t4.oldRange && (t4.oldRange = td2._createFromRanges(t4.oldRange._getTransformedByMoveOperation(e4))), t4.newRange) {
            if (n3.abRelation) {
              const i3 = td2._createFromRanges(t4.newRange._getTransformedByMoveOperation(e4));
              if ("left" == n3.abRelation.side && e4.targetPosition.isEqual(t4.newRange.start))
                return t4.newRange.end = i3.end, t4.newRange.start.path = n3.abRelation.path, [t4];
              if ("right" == n3.abRelation.side && e4.targetPosition.isEqual(t4.newRange.end))
                return t4.newRange.start = i3.start, t4.newRange.end.path = n3.abRelation.path, [t4];
            }
            t4.newRange = td2._createFromRanges(t4.newRange._getTransformedByMoveOperation(e4));
          }
          return [t4];
        }), Uh2(Nh2, Bh2, (t4, e4, n3) => {
          if (t4.oldRange && (t4.oldRange = t4.oldRange._getTransformedBySplitOperation(e4)), t4.newRange) {
            if (n3.abRelation) {
              const i3 = t4.newRange._getTransformedBySplitOperation(e4);
              return t4.newRange.start.isEqual(e4.splitPosition) && n3.abRelation.wasStartBeforeMergedElement ? t4.newRange.start = Kl._createAt(e4.insertionPosition) : t4.newRange.start.isEqual(e4.splitPosition) && !n3.abRelation.wasInLeftElement && (t4.newRange.start = Kl._createAt(e4.moveTargetPosition)), t4.newRange.end.isEqual(e4.splitPosition) && n3.abRelation.wasInRightElement ? t4.newRange.end = Kl._createAt(e4.moveTargetPosition) : t4.newRange.end.isEqual(e4.splitPosition) && n3.abRelation.wasEndBeforeMergedElement ? t4.newRange.end = Kl._createAt(e4.insertionPosition) : t4.newRange.end = i3.end, [t4];
            }
            t4.newRange = t4.newRange._getTransformedBySplitOperation(e4);
          }
          return [t4];
        }), Uh2(Mh2, Ih2, (t4, e4) => (t4.sourcePosition.hasSameParentAs(e4.position) && (t4.howMany += e4.howMany), t4.sourcePosition = t4.sourcePosition._getTransformedByInsertOperation(e4), t4.targetPosition = t4.targetPosition._getTransformedByInsertOperation(e4), [t4])), Uh2(Mh2, Mh2, (t4, e4, n3) => {
          if (t4.sourcePosition.isEqual(e4.sourcePosition) && t4.targetPosition.isEqual(e4.targetPosition)) {
            if (n3.bWasUndone) {
              const n4 = e4.graveyardPosition.path.slice();
              return n4.push(0), t4.sourcePosition = new Kl(e4.graveyardPosition.root, n4), t4.howMany = 0, [t4];
            }
            return [new Ph2(0)];
          }
          if (t4.sourcePosition.isEqual(e4.sourcePosition) && !t4.targetPosition.isEqual(e4.targetPosition) && !n3.bWasUndone && "splitAtSource" != n3.abRelation) {
            const i3 = "$graveyard" == t4.targetPosition.root.rootName, o3 = "$graveyard" == e4.targetPosition.root.rootName;
            if (o3 && !i3 || !(i3 && !o3) && n3.aIsStrong) {
              const n4 = e4.targetPosition._getTransformedByMergeOperation(e4), i4 = t4.targetPosition._getTransformedByMergeOperation(e4);
              return [new Th2(n4, t4.howMany, i4, 0)];
            }
            return [new Ph2(0)];
          }
          return t4.sourcePosition.hasSameParentAs(e4.targetPosition) && (t4.howMany += e4.howMany), t4.sourcePosition = t4.sourcePosition._getTransformedByMergeOperation(e4), t4.targetPosition = t4.targetPosition._getTransformedByMergeOperation(e4), t4.graveyardPosition.isEqual(e4.graveyardPosition) && n3.aIsStrong || (t4.graveyardPosition = t4.graveyardPosition._getTransformedByMergeOperation(e4)), [t4];
        }), Uh2(Mh2, Th2, (t4, e4, n3) => {
          const i3 = td2._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
          return "remove" == e4.type && !n3.bWasUndone && !n3.forceWeakRemove && t4.deletionPosition.hasSameParentAs(e4.sourcePosition) && i3.containsPosition(t4.sourcePosition) ? [new Ph2(0)] : (t4.sourcePosition.hasSameParentAs(e4.targetPosition) && (t4.howMany += e4.howMany), t4.sourcePosition.hasSameParentAs(e4.sourcePosition) && (t4.howMany -= e4.howMany), t4.sourcePosition = t4.sourcePosition._getTransformedByMoveOperation(e4), t4.targetPosition = t4.targetPosition._getTransformedByMoveOperation(e4), t4.graveyardPosition.isEqual(e4.targetPosition) || (t4.graveyardPosition = t4.graveyardPosition._getTransformedByMoveOperation(e4)), [t4]);
        }), Uh2(Mh2, Bh2, (t4, e4, n3) => {
          if (e4.graveyardPosition && (t4.graveyardPosition = t4.graveyardPosition._getTransformedByDeletion(e4.graveyardPosition, 1), t4.deletionPosition.isEqual(e4.graveyardPosition) && (t4.howMany = e4.howMany)), t4.targetPosition.isEqual(e4.splitPosition)) {
            const i3 = 0 != e4.howMany, o3 = e4.graveyardPosition && t4.deletionPosition.isEqual(e4.graveyardPosition);
            if (i3 || o3 || "mergeTargetNotMoved" == n3.abRelation)
              return t4.sourcePosition = t4.sourcePosition._getTransformedBySplitOperation(e4), [t4];
          }
          if (t4.sourcePosition.isEqual(e4.splitPosition)) {
            if ("mergeSourceNotMoved" == n3.abRelation)
              return t4.howMany = 0, t4.targetPosition = t4.targetPosition._getTransformedBySplitOperation(e4), [t4];
            if ("mergeSameElement" == n3.abRelation || t4.sourcePosition.offset > 0)
              return t4.sourcePosition = e4.moveTargetPosition.clone(), t4.targetPosition = t4.targetPosition._getTransformedBySplitOperation(e4), [t4];
          }
          return t4.sourcePosition.hasSameParentAs(e4.splitPosition) && (t4.howMany = e4.splitPosition.offset), t4.sourcePosition = t4.sourcePosition._getTransformedBySplitOperation(e4), t4.targetPosition = t4.targetPosition._getTransformedBySplitOperation(e4), [t4];
        }), Uh2(Th2, Ih2, (t4, e4) => {
          const n3 = td2._createFromPositionAndShift(t4.sourcePosition, t4.howMany)._getTransformedByInsertOperation(e4, false)[0];
          return t4.sourcePosition = n3.start, t4.howMany = n3.end.offset - n3.start.offset, t4.targetPosition.isEqual(e4.position) || (t4.targetPosition = t4.targetPosition._getTransformedByInsertOperation(e4)), [t4];
        }), Uh2(Th2, Th2, (t4, e4, n3) => {
          const i3 = td2._createFromPositionAndShift(t4.sourcePosition, t4.howMany), o3 = td2._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
          let r3, s3 = n3.aIsStrong, a3 = !n3.aIsStrong;
          if ("insertBefore" == n3.abRelation || "insertAfter" == n3.baRelation ? a3 = true : "insertAfter" != n3.abRelation && "insertBefore" != n3.baRelation || (a3 = false), r3 = t4.targetPosition.isEqual(e4.targetPosition) && a3 ? t4.targetPosition._getTransformedByDeletion(e4.sourcePosition, e4.howMany) : t4.targetPosition._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), Qh2(t4, e4) && Qh2(e4, t4))
            return [e4.getReversed()];
          if (i3.containsPosition(e4.targetPosition) && i3.containsRange(o3, true))
            return i3.start = i3.start._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), i3.end = i3.end._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), Jh2([i3], r3);
          if (o3.containsPosition(t4.targetPosition) && o3.containsRange(i3, true))
            return i3.start = i3.start._getCombined(e4.sourcePosition, e4.getMovedRangeStart()), i3.end = i3.end._getCombined(e4.sourcePosition, e4.getMovedRangeStart()), Jh2([i3], r3);
          const c3 = tt2(t4.sourcePosition.getParentPath(), e4.sourcePosition.getParentPath());
          if ("prefix" == c3 || "extension" == c3)
            return i3.start = i3.start._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), i3.end = i3.end._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), Jh2([i3], r3);
          "remove" != t4.type || "remove" == e4.type || n3.aWasUndone || n3.forceWeakRemove ? "remove" == t4.type || "remove" != e4.type || n3.bWasUndone || n3.forceWeakRemove || (s3 = false) : s3 = true;
          const l3 = [], d3 = i3.getDifference(o3);
          for (const t5 of d3) {
            t5.start = t5.start._getTransformedByDeletion(e4.sourcePosition, e4.howMany), t5.end = t5.end._getTransformedByDeletion(e4.sourcePosition, e4.howMany);
            const n4 = "same" == tt2(t5.start.getParentPath(), e4.getMovedRangeStart().getParentPath()), i4 = t5._getTransformedByInsertion(e4.getMovedRangeStart(), e4.howMany, n4);
            l3.push(...i4);
          }
          const h3 = i3.getIntersection(o3);
          return null !== h3 && s3 && (h3.start = h3.start._getCombined(e4.sourcePosition, e4.getMovedRangeStart()), h3.end = h3.end._getCombined(e4.sourcePosition, e4.getMovedRangeStart()), 0 === l3.length ? l3.push(h3) : 1 == l3.length ? o3.start.isBefore(i3.start) || o3.start.isEqual(i3.start) ? l3.unshift(h3) : l3.push(h3) : l3.splice(1, 0, h3)), 0 === l3.length ? [new Ph2(t4.baseVersion)] : Jh2(l3, r3);
        }), Uh2(Th2, Bh2, (t4, e4, n3) => {
          let i3 = t4.targetPosition.clone();
          t4.targetPosition.isEqual(e4.insertionPosition) && e4.graveyardPosition && "moveTargetAfter" != n3.abRelation || (i3 = t4.targetPosition._getTransformedBySplitOperation(e4));
          const o3 = td2._createFromPositionAndShift(t4.sourcePosition, t4.howMany);
          if (o3.end.isEqual(e4.insertionPosition))
            return e4.graveyardPosition || t4.howMany++, t4.targetPosition = i3, [t4];
          if (o3.start.hasSameParentAs(e4.splitPosition) && o3.containsPosition(e4.splitPosition)) {
            let t5 = new td2(e4.splitPosition, o3.end);
            t5 = t5._getTransformedBySplitOperation(e4);
            return Jh2([new td2(o3.start, e4.splitPosition), t5], i3);
          }
          t4.targetPosition.isEqual(e4.splitPosition) && "insertAtSource" == n3.abRelation && (i3 = e4.moveTargetPosition), t4.targetPosition.isEqual(e4.insertionPosition) && "insertBetween" == n3.abRelation && (i3 = t4.targetPosition);
          const r3 = [o3._getTransformedBySplitOperation(e4)];
          if (e4.graveyardPosition) {
            const i4 = o3.start.isEqual(e4.graveyardPosition) || o3.containsPosition(e4.graveyardPosition);
            t4.howMany > 1 && i4 && !n3.aWasUndone && r3.push(td2._createFromPositionAndShift(e4.insertionPosition, 1));
          }
          return Jh2(r3, i3);
        }), Uh2(Th2, Mh2, (t4, e4, n3) => {
          const i3 = td2._createFromPositionAndShift(t4.sourcePosition, t4.howMany);
          if (e4.deletionPosition.hasSameParentAs(t4.sourcePosition) && i3.containsPosition(e4.sourcePosition)) {
            if ("remove" != t4.type || n3.forceWeakRemove) {
              if (1 == t4.howMany)
                return n3.bWasUndone ? (t4.sourcePosition = e4.graveyardPosition.clone(), t4.targetPosition = t4.targetPosition._getTransformedByMergeOperation(e4), [t4]) : [new Ph2(0)];
            } else if (!n3.aWasUndone) {
              const n4 = [];
              let i4 = e4.graveyardPosition.clone(), o4 = e4.targetPosition._getTransformedByMergeOperation(e4);
              t4.howMany > 1 && (n4.push(new Th2(t4.sourcePosition, t4.howMany - 1, t4.targetPosition, 0)), i4 = i4._getTransformedByMove(t4.sourcePosition, t4.targetPosition, t4.howMany - 1), o4 = o4._getTransformedByMove(t4.sourcePosition, t4.targetPosition, t4.howMany - 1));
              const r3 = e4.deletionPosition._getCombined(t4.sourcePosition, t4.targetPosition), s3 = new Th2(i4, 1, r3, 0), a3 = s3.getMovedRangeStart().path.slice();
              a3.push(0);
              const c3 = new Kl(s3.targetPosition.root, a3);
              o4 = o4._getTransformedByMove(i4, r3, 1);
              const l3 = new Th2(o4, e4.howMany, c3, 0);
              return n4.push(s3), n4.push(l3), n4;
            }
          }
          const o3 = td2._createFromPositionAndShift(t4.sourcePosition, t4.howMany)._getTransformedByMergeOperation(e4);
          return t4.sourcePosition = o3.start, t4.howMany = o3.end.offset - o3.start.offset, t4.targetPosition = t4.targetPosition._getTransformedByMergeOperation(e4), [t4];
        }), Uh2(Rh2, Ih2, (t4, e4) => (t4.position = t4.position._getTransformedByInsertOperation(e4), [t4])), Uh2(Rh2, Mh2, (t4, e4) => t4.position.isEqual(e4.deletionPosition) ? (t4.position = e4.graveyardPosition.clone(), t4.position.stickiness = "toNext", [t4]) : (t4.position = t4.position._getTransformedByMergeOperation(e4), [t4])), Uh2(Rh2, Th2, (t4, e4) => (t4.position = t4.position._getTransformedByMoveOperation(e4), [t4])), Uh2(Rh2, Rh2, (t4, e4, n3) => {
          if (t4.position.isEqual(e4.position)) {
            if (!n3.aIsStrong)
              return [new Ph2(0)];
            t4.oldName = e4.newName;
          }
          return [t4];
        }), Uh2(Rh2, Bh2, (t4, e4) => {
          if ("same" == tt2(t4.position.path, e4.splitPosition.getParentPath()) && !e4.graveyardPosition) {
            const e5 = new Rh2(t4.position.getShiftedBy(1), t4.oldName, t4.newName, 0);
            return [t4, e5];
          }
          return t4.position = t4.position._getTransformedBySplitOperation(e4), [t4];
        }), Uh2(Oh2, Oh2, (t4, e4, n3) => {
          if (t4.root === e4.root && t4.key === e4.key) {
            if (!n3.aIsStrong || t4.newValue === e4.newValue)
              return [new Ph2(0)];
            t4.oldValue = e4.newValue;
          }
          return [t4];
        }), Uh2(Fh2, Fh2, (t4, e4) => t4.rootName === e4.rootName && t4.isAdd === e4.isAdd ? [new Ph2(0)] : [t4]), Uh2(Bh2, Ih2, (t4, e4) => (t4.splitPosition.hasSameParentAs(e4.position) && t4.splitPosition.offset < e4.position.offset && (t4.howMany += e4.howMany), t4.splitPosition = t4.splitPosition._getTransformedByInsertOperation(e4), t4.insertionPosition = t4.insertionPosition._getTransformedByInsertOperation(e4), [t4])), Uh2(Bh2, Mh2, (t4, e4, n3) => {
          if (!t4.graveyardPosition && !n3.bWasUndone && t4.splitPosition.hasSameParentAs(e4.sourcePosition)) {
            const n4 = e4.graveyardPosition.path.slice();
            n4.push(0);
            const i3 = new Kl(e4.graveyardPosition.root, n4), o3 = Bh2.getInsertionPosition(new Kl(e4.graveyardPosition.root, n4)), r3 = new Bh2(i3, 0, o3, null, 0);
            return t4.splitPosition = t4.splitPosition._getTransformedByMergeOperation(e4), t4.insertionPosition = Bh2.getInsertionPosition(t4.splitPosition), t4.graveyardPosition = r3.insertionPosition.clone(), t4.graveyardPosition.stickiness = "toNext", [r3, t4];
          }
          return t4.splitPosition.hasSameParentAs(e4.deletionPosition) && !t4.splitPosition.isAfter(e4.deletionPosition) && t4.howMany--, t4.splitPosition.hasSameParentAs(e4.targetPosition) && (t4.howMany += e4.howMany), t4.splitPosition = t4.splitPosition._getTransformedByMergeOperation(e4), t4.insertionPosition = Bh2.getInsertionPosition(t4.splitPosition), t4.graveyardPosition && (t4.graveyardPosition = t4.graveyardPosition._getTransformedByMergeOperation(e4)), [t4];
        }), Uh2(Bh2, Th2, (t4, e4, n3) => {
          const i3 = td2._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
          if (t4.graveyardPosition) {
            const o4 = i3.start.isEqual(t4.graveyardPosition) || i3.containsPosition(t4.graveyardPosition);
            if (!n3.bWasUndone && o4) {
              const n4 = t4.splitPosition._getTransformedByMoveOperation(e4), i4 = t4.graveyardPosition._getTransformedByMoveOperation(e4), o5 = i4.path.slice();
              o5.push(0);
              const r3 = new Kl(i4.root, o5);
              return [new Th2(n4, t4.howMany, r3, 0)];
            }
            t4.graveyardPosition = t4.graveyardPosition._getTransformedByMoveOperation(e4);
          }
          const o3 = t4.splitPosition.isEqual(e4.targetPosition);
          if (o3 && ("insertAtSource" == n3.baRelation || "splitBefore" == n3.abRelation))
            return t4.howMany += e4.howMany, t4.splitPosition = t4.splitPosition._getTransformedByDeletion(e4.sourcePosition, e4.howMany), t4.insertionPosition = Bh2.getInsertionPosition(t4.splitPosition), [t4];
          if (o3 && n3.abRelation && n3.abRelation.howMany) {
            const { howMany: e5, offset: i4 } = n3.abRelation;
            return t4.howMany += e5, t4.splitPosition = t4.splitPosition.getShiftedBy(i4), [t4];
          }
          if (t4.splitPosition.hasSameParentAs(e4.sourcePosition) && i3.containsPosition(t4.splitPosition)) {
            const n4 = e4.howMany - (t4.splitPosition.offset - e4.sourcePosition.offset);
            return t4.howMany -= n4, t4.splitPosition.hasSameParentAs(e4.targetPosition) && t4.splitPosition.offset < e4.targetPosition.offset && (t4.howMany += e4.howMany), t4.splitPosition = e4.sourcePosition.clone(), t4.insertionPosition = Bh2.getInsertionPosition(t4.splitPosition), [t4];
          }
          return e4.sourcePosition.isEqual(e4.targetPosition) || (t4.splitPosition.hasSameParentAs(e4.sourcePosition) && t4.splitPosition.offset <= e4.sourcePosition.offset && (t4.howMany -= e4.howMany), t4.splitPosition.hasSameParentAs(e4.targetPosition) && t4.splitPosition.offset < e4.targetPosition.offset && (t4.howMany += e4.howMany)), t4.splitPosition.stickiness = "toNone", t4.splitPosition = t4.splitPosition._getTransformedByMoveOperation(e4), t4.splitPosition.stickiness = "toNext", t4.graveyardPosition ? t4.insertionPosition = t4.insertionPosition._getTransformedByMoveOperation(e4) : t4.insertionPosition = Bh2.getInsertionPosition(t4.splitPosition), [t4];
        }), Uh2(Bh2, Bh2, (t4, e4, n3) => {
          if (t4.splitPosition.isEqual(e4.splitPosition)) {
            if (!t4.graveyardPosition && !e4.graveyardPosition)
              return [new Ph2(0)];
            if (t4.graveyardPosition && e4.graveyardPosition && t4.graveyardPosition.isEqual(e4.graveyardPosition))
              return [new Ph2(0)];
            if ("splitBefore" == n3.abRelation)
              return t4.howMany = 0, t4.graveyardPosition = t4.graveyardPosition._getTransformedBySplitOperation(e4), [t4];
          }
          if (t4.graveyardPosition && e4.graveyardPosition && t4.graveyardPosition.isEqual(e4.graveyardPosition)) {
            const i3 = "$graveyard" == t4.splitPosition.root.rootName, o3 = "$graveyard" == e4.splitPosition.root.rootName;
            if (o3 && !i3 || !(i3 && !o3) && n3.aIsStrong) {
              const n4 = [];
              return e4.howMany && n4.push(new Th2(e4.moveTargetPosition, e4.howMany, e4.splitPosition, 0)), t4.howMany && n4.push(new Th2(t4.splitPosition, t4.howMany, t4.moveTargetPosition, 0)), n4;
            }
            return [new Ph2(0)];
          }
          if (t4.graveyardPosition && (t4.graveyardPosition = t4.graveyardPosition._getTransformedBySplitOperation(e4)), t4.splitPosition.isEqual(e4.insertionPosition) && "splitBefore" == n3.abRelation)
            return t4.howMany++, [t4];
          if (e4.splitPosition.isEqual(t4.insertionPosition) && "splitBefore" == n3.baRelation) {
            const n4 = e4.insertionPosition.path.slice();
            n4.push(0);
            const i3 = new Kl(e4.insertionPosition.root, n4);
            return [t4, new Th2(t4.insertionPosition, 1, i3, 0)];
          }
          return t4.splitPosition.hasSameParentAs(e4.splitPosition) && t4.splitPosition.offset < e4.splitPosition.offset && (t4.howMany -= e4.howMany), t4.splitPosition = t4.splitPosition._getTransformedBySplitOperation(e4), t4.insertionPosition = Bh2.getInsertionPosition(t4.splitPosition), [t4];
        });
        class Xh2 extends B2(Kl) {
          constructor(t4, e4, n3 = "toNone") {
            if (super(t4, e4, n3), !this.root.is("rootElement"))
              throw new C2("model-liveposition-root-not-rootelement", t4);
            tu.call(this);
          }
          detach() {
            this.stopListening();
          }
          toPosition() {
            return new Kl(this.root, this.path.slice(), this.stickiness);
          }
          static fromPosition(t4, e4) {
            return new this(t4.root, t4.path.slice(), e4 || t4.stickiness);
          }
        }
        function tu() {
          this.listenTo(this.root.document.model, "applyOperation", (t4, e4) => {
            const n3 = e4[0];
            n3.isDocumentOperation && eu.call(this, n3);
          }, { priority: "low" });
        }
        function eu(t4) {
          const e4 = this.getTransformedByOperation(t4);
          if (!this.isEqual(e4)) {
            const t5 = this.toPosition();
            this.path = e4.path, this.root = e4.root, this.fire("change", t5);
          }
        }
        Xh2.prototype.is = function(t4) {
          return "livePosition" === t4 || "model:livePosition" === t4 || "position" == t4 || "model:position" === t4;
        };
        class nu {
          constructor(t4 = {}) {
            "string" == typeof t4 && (t4 = "transparent" === t4 ? { isUndoable: false } : {}, _2("batch-constructor-deprecated-string-type"));
            const { isUndoable: e4 = true, isLocal: n3 = true, isUndo: i3 = false, isTyping: o3 = false } = t4;
            this.operations = [], this.isUndoable = e4, this.isLocal = n3, this.isUndo = i3, this.isTyping = o3;
          }
          get type() {
            return _2("batch-type-deprecated"), "default";
          }
          get baseVersion() {
            for (const t4 of this.operations)
              if (null !== t4.baseVersion)
                return t4.baseVersion;
            return null;
          }
          addOperation(t4) {
            return t4.batch = this, this.operations.push(t4), t4;
          }
        }
        class iu {
          constructor(t4) {
            this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changedRoots = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set(), this._markerCollection = t4;
          }
          get isEmpty() {
            return 0 == this._changesInElement.size && 0 == this._changedMarkers.size && 0 == this._changedRoots.size;
          }
          bufferOperation(t4) {
            const e4 = t4;
            switch (e4.type) {
              case "insert":
                if (this._isInInsertedElement(e4.position.parent))
                  return;
                this._markInsert(e4.position.parent, e4.position.offset, e4.nodes.maxOffset);
                break;
              case "addAttribute":
              case "removeAttribute":
              case "changeAttribute":
                for (const t5 of e4.range.getItems({ shallow: true }))
                  this._isInInsertedElement(t5.parent) || this._markAttribute(t5);
                break;
              case "remove":
              case "move":
              case "reinsert": {
                if (e4.sourcePosition.isEqual(e4.targetPosition) || e4.sourcePosition.getShiftedBy(e4.howMany).isEqual(e4.targetPosition))
                  return;
                const t5 = this._isInInsertedElement(e4.sourcePosition.parent), n3 = this._isInInsertedElement(e4.targetPosition.parent);
                t5 || this._markRemove(e4.sourcePosition.parent, e4.sourcePosition.offset, e4.howMany), n3 || this._markInsert(e4.targetPosition.parent, e4.getMovedRangeStart().offset, e4.howMany);
                break;
              }
              case "rename": {
                if (this._isInInsertedElement(e4.position.parent))
                  return;
                this._markRemove(e4.position.parent, e4.position.offset, 1), this._markInsert(e4.position.parent, e4.position.offset, 1);
                const t5 = td2._createFromPositionAndShift(e4.position, 1);
                for (const e5 of this._markerCollection.getMarkersIntersectingRange(t5)) {
                  const t6 = e5.getData();
                  this.bufferMarkerChange(e5.name, t6, t6);
                }
                break;
              }
              case "split": {
                const t5 = e4.splitPosition.parent;
                this._isInInsertedElement(t5) || this._markRemove(t5, e4.splitPosition.offset, e4.howMany), this._isInInsertedElement(e4.insertionPosition.parent) || this._markInsert(e4.insertionPosition.parent, e4.insertionPosition.offset, 1), e4.graveyardPosition && this._markRemove(e4.graveyardPosition.parent, e4.graveyardPosition.offset, 1);
                break;
              }
              case "merge": {
                const t5 = e4.sourcePosition.parent;
                this._isInInsertedElement(t5.parent) || this._markRemove(t5.parent, t5.startOffset, 1);
                const n3 = e4.graveyardPosition.parent;
                this._markInsert(n3, e4.graveyardPosition.offset, 1);
                const i3 = e4.targetPosition.parent;
                this._isInInsertedElement(i3) || this._markInsert(i3, e4.targetPosition.offset, t5.maxOffset);
                break;
              }
              case "detachRoot":
              case "addRoot": {
                const t5 = e4.affectedSelectable;
                if (!t5._isLoaded)
                  return;
                if (t5.isAttached() == e4.isAdd)
                  return;
                this._bufferRootStateChange(e4.rootName, e4.isAdd);
                break;
              }
              case "addRootAttribute":
              case "removeRootAttribute":
              case "changeRootAttribute": {
                if (!e4.root._isLoaded)
                  return;
                const t5 = e4.root.rootName;
                this._bufferRootAttributeChange(t5, e4.key, e4.oldValue, e4.newValue);
                break;
              }
            }
            this._cachedChanges = null;
          }
          bufferMarkerChange(t4, e4, n3) {
            e4.range && e4.range.root.is("rootElement") && !e4.range.root._isLoaded && (e4.range = null), n3.range && n3.range.root.is("rootElement") && !n3.range.root._isLoaded && (n3.range = null);
            let i3 = this._changedMarkers.get(t4);
            i3 ? i3.newMarkerData = n3 : (i3 = { newMarkerData: n3, oldMarkerData: e4 }, this._changedMarkers.set(t4, i3)), null == i3.oldMarkerData.range && null == n3.range && this._changedMarkers.delete(t4);
          }
          getMarkersToRemove() {
            const t4 = [];
            for (const [e4, n3] of this._changedMarkers)
              null != n3.oldMarkerData.range && t4.push({ name: e4, range: n3.oldMarkerData.range });
            return t4;
          }
          getMarkersToAdd() {
            const t4 = [];
            for (const [e4, n3] of this._changedMarkers)
              null != n3.newMarkerData.range && t4.push({ name: e4, range: n3.newMarkerData.range });
            return t4;
          }
          getChangedMarkers() {
            return Array.from(this._changedMarkers).map(([t4, e4]) => ({ name: t4, data: { oldRange: e4.oldMarkerData.range, newRange: e4.newMarkerData.range } }));
          }
          hasDataChanges() {
            if (this._changesInElement.size > 0)
              return true;
            if (this._changedRoots.size > 0)
              return true;
            for (const { newMarkerData: t4, oldMarkerData: e4 } of this._changedMarkers.values()) {
              if (t4.affectsData !== e4.affectsData)
                return true;
              if (t4.affectsData) {
                const n3 = t4.range && !e4.range, i3 = !t4.range && e4.range, o3 = t4.range && e4.range && !t4.range.isEqual(e4.range);
                if (n3 || i3 || o3)
                  return true;
              }
            }
            return false;
          }
          getChanges(t4 = {}) {
            if (this._cachedChanges)
              return t4.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
            let e4 = [];
            for (const t5 of this._changesInElement.keys()) {
              const n3 = this._changesInElement.get(t5).sort((t6, e5) => t6.offset === e5.offset ? t6.type != e5.type ? "remove" == t6.type ? -1 : 1 : 0 : t6.offset < e5.offset ? -1 : 1), i3 = this._elementSnapshots.get(t5), o3 = ou(t5.getChildren()), r3 = ru(i3.length, n3);
              let s3 = 0, a3 = 0;
              for (const n4 of r3)
                if ("i" === n4)
                  e4.push(this._getInsertDiff(t5, s3, o3[s3])), s3++;
                else if ("r" === n4)
                  e4.push(this._getRemoveDiff(t5, s3, i3[a3])), a3++;
                else if ("a" === n4) {
                  const n5 = o3[s3].attributes, r4 = i3[a3].attributes;
                  let c3;
                  if ("$text" == o3[s3].name)
                    c3 = new td2(Kl._createAt(t5, s3), Kl._createAt(t5, s3 + 1));
                  else {
                    const e5 = t5.offsetToIndex(s3);
                    c3 = new td2(Kl._createAt(t5, s3), Kl._createAt(t5.getChild(e5), 0));
                  }
                  e4.push(...this._getAttributesDiff(c3, r4, n5)), s3++, a3++;
                } else
                  s3++, a3++;
            }
            e4.sort((t5, e5) => t5.position.root != e5.position.root ? t5.position.root.rootName < e5.position.root.rootName ? -1 : 1 : t5.position.isEqual(e5.position) ? t5.changeCount - e5.changeCount : t5.position.isBefore(e5.position) ? -1 : 1);
            for (let t5 = 1, n3 = 0; t5 < e4.length; t5++) {
              const i3 = e4[n3], o3 = e4[t5], r3 = "remove" == i3.type && "remove" == o3.type && "$text" == i3.name && "$text" == o3.name && i3.position.isEqual(o3.position), s3 = "insert" == i3.type && "insert" == o3.type && "$text" == i3.name && "$text" == o3.name && i3.position.parent == o3.position.parent && i3.position.offset + i3.length == o3.position.offset, a3 = "attribute" == i3.type && "attribute" == o3.type && i3.position.parent == o3.position.parent && i3.range.isFlat && o3.range.isFlat && i3.position.offset + i3.length == o3.position.offset && i3.attributeKey == o3.attributeKey && i3.attributeOldValue == o3.attributeOldValue && i3.attributeNewValue == o3.attributeNewValue;
              r3 || s3 || a3 ? (i3.length++, a3 && (i3.range.end = i3.range.end.getShiftedBy(1)), e4[t5] = null) : n3 = t5;
            }
            e4 = e4.filter((t5) => t5);
            for (const t5 of e4)
              delete t5.changeCount, "attribute" == t5.type && (delete t5.position, delete t5.length);
            return this._changeCount = 0, this._cachedChangesWithGraveyard = e4, this._cachedChanges = e4.filter(su), t4.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
          }
          getChangedRoots() {
            return Array.from(this._changedRoots.values()).map((t4) => {
              const e4 = { ...t4 };
              return void 0 !== e4.state && delete e4.attributes, e4;
            });
          }
          getRefreshedItems() {
            return new Set(this._refreshedItems);
          }
          reset() {
            this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
          }
          _bufferRootStateChange(t4, e4) {
            if (!this._changedRoots.has(t4))
              return void this._changedRoots.set(t4, { name: t4, state: e4 ? "attached" : "detached" });
            const n3 = this._changedRoots.get(t4);
            void 0 !== n3.state ? (delete n3.state, void 0 === n3.attributes && this._changedRoots.delete(t4)) : n3.state = e4 ? "attached" : "detached";
          }
          _bufferRootAttributeChange(t4, e4, n3, i3) {
            const o3 = this._changedRoots.get(t4) || { name: t4 }, r3 = o3.attributes || {};
            if (r3[e4]) {
              const t5 = r3[e4];
              i3 === t5.oldValue ? delete r3[e4] : t5.newValue = i3;
            } else
              r3[e4] = { oldValue: n3, newValue: i3 };
            0 === Object.entries(r3).length ? (delete o3.attributes, void 0 === o3.state && this._changedRoots.delete(t4)) : (o3.attributes = r3, this._changedRoots.set(t4, o3));
          }
          _refreshItem(t4) {
            if (this._isInInsertedElement(t4.parent))
              return;
            this._markRemove(t4.parent, t4.startOffset, t4.offsetSize), this._markInsert(t4.parent, t4.startOffset, t4.offsetSize), this._refreshedItems.add(t4);
            const e4 = td2._createOn(t4);
            for (const t5 of this._markerCollection.getMarkersIntersectingRange(e4)) {
              const e5 = t5.getData();
              this.bufferMarkerChange(t5.name, e5, e5);
            }
            this._cachedChanges = null;
          }
          _bufferRootLoad(t4) {
            if (t4.isAttached()) {
              this._bufferRootStateChange(t4.rootName, true), this._markInsert(t4, 0, t4.maxOffset);
              for (const e4 of t4.getAttributeKeys())
                this._bufferRootAttributeChange(t4.rootName, e4, null, t4.getAttribute(e4));
              for (const e4 of this._markerCollection)
                if (e4.getRange().root == t4) {
                  const t5 = e4.getData();
                  this.bufferMarkerChange(e4.name, { ...t5, range: null }, t5);
                }
            }
          }
          _markInsert(t4, e4, n3) {
            if (t4.root.is("rootElement") && !t4.root._isLoaded)
              return;
            const i3 = { type: "insert", offset: e4, howMany: n3, count: this._changeCount++ };
            this._markChange(t4, i3);
          }
          _markRemove(t4, e4, n3) {
            if (t4.root.is("rootElement") && !t4.root._isLoaded)
              return;
            const i3 = { type: "remove", offset: e4, howMany: n3, count: this._changeCount++ };
            this._markChange(t4, i3), this._removeAllNestedChanges(t4, e4, n3);
          }
          _markAttribute(t4) {
            if (t4.root.is("rootElement") && !t4.root._isLoaded)
              return;
            const e4 = { type: "attribute", offset: t4.startOffset, howMany: t4.offsetSize, count: this._changeCount++ };
            this._markChange(t4.parent, e4);
          }
          _markChange(t4, e4) {
            this._makeSnapshot(t4);
            const n3 = this._getChangesForElement(t4);
            this._handleChange(e4, n3), n3.push(e4);
            for (let t5 = 0; t5 < n3.length; t5++)
              n3[t5].howMany < 1 && (n3.splice(t5, 1), t5--);
          }
          _getChangesForElement(t4) {
            let e4;
            return this._changesInElement.has(t4) ? e4 = this._changesInElement.get(t4) : (e4 = [], this._changesInElement.set(t4, e4)), e4;
          }
          _makeSnapshot(t4) {
            this._elementSnapshots.has(t4) || this._elementSnapshots.set(t4, ou(t4.getChildren()));
          }
          _handleChange(t4, e4) {
            t4.nodesToHandle = t4.howMany;
            for (const n3 of e4) {
              const i3 = t4.offset + t4.howMany, o3 = n3.offset + n3.howMany;
              if ("insert" == t4.type && ("insert" == n3.type && (t4.offset <= n3.offset ? n3.offset += t4.howMany : t4.offset < o3 && (n3.howMany += t4.nodesToHandle, t4.nodesToHandle = 0)), "remove" == n3.type && t4.offset < n3.offset && (n3.offset += t4.howMany), "attribute" == n3.type)) {
                if (t4.offset <= n3.offset)
                  n3.offset += t4.howMany;
                else if (t4.offset < o3) {
                  const o4 = n3.howMany;
                  n3.howMany = t4.offset - n3.offset, e4.unshift({ type: "attribute", offset: i3, howMany: o4 - n3.howMany, count: this._changeCount++ });
                }
              }
              if ("remove" == t4.type) {
                if ("insert" == n3.type) {
                  if (i3 <= n3.offset)
                    n3.offset -= t4.howMany;
                  else if (i3 <= o3)
                    if (t4.offset < n3.offset) {
                      const e5 = i3 - n3.offset;
                      n3.offset = t4.offset, n3.howMany -= e5, t4.nodesToHandle -= e5;
                    } else
                      n3.howMany -= t4.nodesToHandle, t4.nodesToHandle = 0;
                  else if (t4.offset <= n3.offset)
                    t4.nodesToHandle -= n3.howMany, n3.howMany = 0;
                  else if (t4.offset < o3) {
                    const e5 = o3 - t4.offset;
                    n3.howMany -= e5, t4.nodesToHandle -= e5;
                  }
                }
                if ("remove" == n3.type && (i3 <= n3.offset ? n3.offset -= t4.howMany : t4.offset < n3.offset && (t4.nodesToHandle += n3.howMany, n3.howMany = 0)), "attribute" == n3.type) {
                  if (i3 <= n3.offset)
                    n3.offset -= t4.howMany;
                  else if (t4.offset < n3.offset) {
                    const e5 = i3 - n3.offset;
                    n3.offset = t4.offset, n3.howMany -= e5;
                  } else if (t4.offset < o3)
                    if (i3 <= o3) {
                      const i4 = n3.howMany;
                      n3.howMany = t4.offset - n3.offset;
                      const o4 = i4 - n3.howMany - t4.nodesToHandle;
                      e4.unshift({ type: "attribute", offset: t4.offset, howMany: o4, count: this._changeCount++ });
                    } else
                      n3.howMany -= o3 - t4.offset;
                }
              }
              if ("attribute" == t4.type) {
                if ("insert" == n3.type)
                  if (t4.offset < n3.offset && i3 > n3.offset) {
                    if (i3 > o3) {
                      const t5 = { type: "attribute", offset: o3, howMany: i3 - o3, count: this._changeCount++ };
                      this._handleChange(t5, e4), e4.push(t5);
                    }
                    t4.nodesToHandle = n3.offset - t4.offset, t4.howMany = t4.nodesToHandle;
                  } else
                    t4.offset >= n3.offset && t4.offset < o3 && (i3 > o3 ? (t4.nodesToHandle = i3 - o3, t4.offset = o3) : t4.nodesToHandle = 0);
                if ("remove" == n3.type && t4.offset < n3.offset && i3 > n3.offset) {
                  const o4 = { type: "attribute", offset: n3.offset, howMany: i3 - n3.offset, count: this._changeCount++ };
                  this._handleChange(o4, e4), e4.push(o4), t4.nodesToHandle = n3.offset - t4.offset, t4.howMany = t4.nodesToHandle;
                }
                "attribute" == n3.type && (t4.offset >= n3.offset && i3 <= o3 ? (t4.nodesToHandle = 0, t4.howMany = 0, t4.offset = 0) : t4.offset <= n3.offset && i3 >= o3 && (n3.howMany = 0));
              }
            }
            t4.howMany = t4.nodesToHandle, delete t4.nodesToHandle;
          }
          _getInsertDiff(t4, e4, n3) {
            return { type: "insert", position: Kl._createAt(t4, e4), name: n3.name, attributes: new Map(n3.attributes), length: 1, changeCount: this._changeCount++ };
          }
          _getRemoveDiff(t4, e4, n3) {
            return { type: "remove", position: Kl._createAt(t4, e4), name: n3.name, attributes: new Map(n3.attributes), length: 1, changeCount: this._changeCount++ };
          }
          _getAttributesDiff(t4, e4, n3) {
            const i3 = [];
            n3 = new Map(n3);
            for (const [o3, r3] of e4) {
              const e5 = n3.has(o3) ? n3.get(o3) : null;
              e5 !== r3 && i3.push({ type: "attribute", position: t4.start, range: t4.clone(), length: 1, attributeKey: o3, attributeOldValue: r3, attributeNewValue: e5, changeCount: this._changeCount++ }), n3.delete(o3);
            }
            for (const [e5, o3] of n3)
              i3.push({ type: "attribute", position: t4.start, range: t4.clone(), length: 1, attributeKey: e5, attributeOldValue: null, attributeNewValue: o3, changeCount: this._changeCount++ });
            return i3;
          }
          _isInInsertedElement(t4) {
            const e4 = t4.parent;
            if (!e4)
              return false;
            const n3 = this._changesInElement.get(e4), i3 = t4.startOffset;
            if (n3) {
              for (const t5 of n3)
                if ("insert" == t5.type && i3 >= t5.offset && i3 < t5.offset + t5.howMany)
                  return true;
            }
            return this._isInInsertedElement(e4);
          }
          _removeAllNestedChanges(t4, e4, n3) {
            const i3 = new td2(Kl._createAt(t4, e4), Kl._createAt(t4, e4 + n3));
            for (const t5 of i3.getItems({ shallow: true }))
              t5.is("element") && (this._elementSnapshots.delete(t5), this._changesInElement.delete(t5), this._removeAllNestedChanges(t5, 0, t5.maxOffset));
          }
        }
        function ou(t4) {
          const e4 = [];
          for (const n3 of t4)
            if (n3.is("$text"))
              for (let t5 = 0; t5 < n3.data.length; t5++)
                e4.push({ name: "$text", attributes: new Map(n3.getAttributes()) });
            else
              e4.push({ name: n3.name, attributes: new Map(n3.getAttributes()) });
          return e4;
        }
        function ru(t4, e4) {
          const n3 = [];
          let i3 = 0, o3 = 0;
          for (const t5 of e4) {
            if (t5.offset > i3) {
              for (let e5 = 0; e5 < t5.offset - i3; e5++)
                n3.push("e");
              o3 += t5.offset - i3;
            }
            if ("insert" == t5.type) {
              for (let e5 = 0; e5 < t5.howMany; e5++)
                n3.push("i");
              i3 = t5.offset + t5.howMany;
            } else if ("remove" == t5.type) {
              for (let e5 = 0; e5 < t5.howMany; e5++)
                n3.push("r");
              i3 = t5.offset, o3 += t5.howMany;
            } else
              n3.push(..."a".repeat(t5.howMany).split("")), i3 = t5.offset + t5.howMany, o3 += t5.howMany;
          }
          if (o3 < t4)
            for (let e5 = 0; e5 < t4 - o3 - i3; e5++)
              n3.push("e");
          return n3;
        }
        function su(t4) {
          const e4 = "position" in t4 && "$graveyard" == t4.position.root.rootName, n3 = "range" in t4 && "$graveyard" == t4.range.root.rootName;
          return !e4 && !n3;
        }
        class au {
          constructor() {
            this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map(), this._version = 0, this._gaps = /* @__PURE__ */ new Map();
          }
          get version() {
            return this._version;
          }
          set version(t4) {
            this._operations.length && t4 > this._version + 1 && this._gaps.set(this._version, t4), this._version = t4;
          }
          get lastOperation() {
            return this._operations[this._operations.length - 1];
          }
          addOperation(t4) {
            if (t4.baseVersion !== this.version)
              throw new C2("model-document-history-addoperation-incorrect-version", this, { operation: t4, historyVersion: this.version });
            this._operations.push(t4), this._version++, this._baseVersionToOperationIndex.set(t4.baseVersion, this._operations.length - 1);
          }
          getOperations(t4, e4 = this.version) {
            if (!this._operations.length)
              return [];
            const n3 = this._operations[0];
            void 0 === t4 && (t4 = n3.baseVersion);
            let i3 = e4 - 1;
            for (const [e5, n4] of this._gaps)
              t4 > e5 && t4 < n4 && (t4 = n4), i3 > e5 && i3 < n4 && (i3 = e5 - 1);
            if (i3 < n3.baseVersion || t4 > this.lastOperation.baseVersion)
              return [];
            let o3 = this._baseVersionToOperationIndex.get(t4);
            void 0 === o3 && (o3 = 0);
            let r3 = this._baseVersionToOperationIndex.get(i3);
            return void 0 === r3 && (r3 = this._operations.length - 1), this._operations.slice(o3, r3 + 1);
          }
          getOperation(t4) {
            const e4 = this._baseVersionToOperationIndex.get(t4);
            if (void 0 !== e4)
              return this._operations[e4];
          }
          setOperationAsUndone(t4, e4) {
            this._undoPairs.set(e4, t4), this._undoneOperations.add(t4);
          }
          isUndoingOperation(t4) {
            return this._undoPairs.has(t4);
          }
          isUndoneOperation(t4) {
            return this._undoneOperations.has(t4);
          }
          getUndoneOperation(t4) {
            return this._undoPairs.get(t4);
          }
          reset() {
            this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
          }
        }
        class cu extends Wl {
          constructor(t4, e4, n3 = "main") {
            super(e4), this._isAttached = true, this._isLoaded = true, this._document = t4, this.rootName = n3;
          }
          get document() {
            return this._document;
          }
          isAttached() {
            return this._isAttached;
          }
          toJSON() {
            return this.rootName;
          }
        }
        cu.prototype.is = function(t4, e4) {
          return e4 ? e4 === this.name && ("rootElement" === t4 || "model:rootElement" === t4 || "element" === t4 || "model:element" === t4) : "rootElement" === t4 || "model:rootElement" === t4 || "element" === t4 || "model:element" === t4 || "node" === t4 || "model:node" === t4;
        };
        const lu = "$graveyard";
        class du extends B2() {
          constructor(t4) {
            super(), this.model = t4, this.history = new au(), this.selection = new bd2(this), this.roots = new Do2({ idProperty: "rootName" }), this.differ = new iu(t4.markers), this.isReadOnly = false, this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = false, this.createRoot("$root", lu), this.listenTo(t4, "applyOperation", (t5, e4) => {
              const n3 = e4[0];
              n3.isDocumentOperation && this.differ.bufferOperation(n3);
            }, { priority: "high" }), this.listenTo(t4, "applyOperation", (t5, e4) => {
              const n3 = e4[0];
              n3.isDocumentOperation && this.history.addOperation(n3);
            }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
              this._hasSelectionChangedFromTheLastChangeBlock = true;
            }), this.listenTo(t4.markers, "update", (t5, e4, n3, i3, o3) => {
              const r3 = { ...e4.getData(), range: i3 };
              this.differ.bufferMarkerChange(e4.name, o3, r3), null === n3 && e4.on("change", (t6, n4) => {
                const i4 = e4.getData();
                this.differ.bufferMarkerChange(e4.name, { ...i4, range: n4 }, i4);
              });
            }), this.registerPostFixer((t5) => {
              let e4 = false;
              for (const n3 of this.roots)
                n3.isAttached() || n3.isEmpty || (t5.remove(t5.createRangeIn(n3)), e4 = true);
              for (const n3 of this.model.markers)
                n3.getRange().root.isAttached() || (t5.removeMarker(n3), e4 = true);
              return e4;
            });
          }
          get version() {
            return this.history.version;
          }
          set version(t4) {
            this.history.version = t4;
          }
          get graveyard() {
            return this.getRoot(lu);
          }
          createRoot(t4 = "$root", e4 = "main") {
            if (this.roots.get(e4))
              throw new C2("model-document-createroot-name-exists", this, { name: e4 });
            const n3 = new cu(this, t4, e4);
            return this.roots.add(n3), n3;
          }
          destroy() {
            this.selection.destroy(), this.stopListening();
          }
          getRoot(t4 = "main") {
            return this.roots.get(t4);
          }
          getRootNames(t4 = false) {
            return this.getRoots(t4).map((t5) => t5.rootName);
          }
          getRoots(t4 = false) {
            return this.roots.filter((e4) => e4 != this.graveyard && (t4 || e4.isAttached()) && e4._isLoaded);
          }
          registerPostFixer(t4) {
            this._postFixers.add(t4);
          }
          toJSON() {
            const t4 = Ps(this);
            return t4.selection = "[engine.model.DocumentSelection]", t4.model = "[engine.model.Model]", t4;
          }
          _handleChangeBlock(t4) {
            this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(t4), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", t4.batch) : this.fire("change", t4.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = false;
          }
          _hasDocumentChangedFromTheLastChangeBlock() {
            return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
          }
          _getDefaultRoot() {
            const t4 = this.getRoots();
            return t4.length ? t4[0] : this.graveyard;
          }
          _getDefaultRange() {
            const t4 = this._getDefaultRoot(), e4 = this.model, n3 = e4.schema, i3 = e4.createPositionFromPath(t4, [0]);
            return n3.getNearestSelectionRange(i3) || e4.createRange(i3);
          }
          _validateSelectionRange(t4) {
            return hu(t4.start) && hu(t4.end);
          }
          _callPostFixers(t4) {
            let e4 = false;
            do {
              for (const n3 of this._postFixers)
                if (this.selection.refresh(), e4 = n3(t4), e4)
                  break;
            } while (e4);
          }
        }
        function hu(t4) {
          const e4 = t4.textNode;
          if (e4) {
            const n3 = e4.data, i3 = t4.offset - e4.startOffset;
            return !No2(n3, i3) && !Lo2(n3, i3);
          }
          return true;
        }
        class uu extends B2() {
          constructor() {
            super(...arguments), this._markers = /* @__PURE__ */ new Map();
          }
          [Symbol.iterator]() {
            return this._markers.values();
          }
          has(t4) {
            const e4 = t4 instanceof gu ? t4.name : t4;
            return this._markers.has(e4);
          }
          get(t4) {
            return this._markers.get(t4) || null;
          }
          _set(t4, e4, n3 = false, i3 = false) {
            const o3 = t4 instanceof gu ? t4.name : t4;
            if (o3.includes(","))
              throw new C2("markercollection-incorrect-marker-name", this);
            const r3 = this._markers.get(o3);
            if (r3) {
              const t5 = r3.getData(), s4 = r3.getRange();
              let a4 = false;
              return s4.isEqual(e4) || (r3._attachLiveRange(md2.fromRange(e4)), a4 = true), n3 != r3.managedUsingOperations && (r3._managedUsingOperations = n3, a4 = true), "boolean" == typeof i3 && i3 != r3.affectsData && (r3._affectsData = i3, a4 = true), a4 && this.fire(`update:${o3}`, r3, s4, e4, t5), r3;
            }
            const s3 = md2.fromRange(e4), a3 = new gu(o3, s3, n3, i3);
            return this._markers.set(o3, a3), this.fire(`update:${o3}`, a3, null, e4, { ...a3.getData(), range: null }), a3;
          }
          _remove(t4) {
            const e4 = t4 instanceof gu ? t4.name : t4, n3 = this._markers.get(e4);
            return !!n3 && (this._markers.delete(e4), this.fire(`update:${e4}`, n3, n3.getRange(), null, n3.getData()), this._destroyMarker(n3), true);
          }
          _refresh(t4) {
            const e4 = t4 instanceof gu ? t4.name : t4, n3 = this._markers.get(e4);
            if (!n3)
              throw new C2("markercollection-refresh-marker-not-exists", this);
            const i3 = n3.getRange();
            this.fire(`update:${e4}`, n3, i3, i3, n3.getData());
          }
          *getMarkersAtPosition(t4) {
            for (const e4 of this)
              e4.getRange().containsPosition(t4) && (yield e4);
          }
          *getMarkersIntersectingRange(t4) {
            for (const e4 of this)
              null !== e4.getRange().getIntersection(t4) && (yield e4);
          }
          destroy() {
            for (const t4 of this._markers.values())
              this._destroyMarker(t4);
            this._markers = null, this.stopListening();
          }
          *getMarkersGroup(t4) {
            for (const e4 of this._markers.values())
              e4.name.startsWith(t4 + ":") && (yield e4);
          }
          _destroyMarker(t4) {
            t4.stopListening(), t4._detachLiveRange();
          }
        }
        class gu extends B2(Vl) {
          constructor(t4, e4, n3, i3) {
            super(), this.name = t4, this._liveRange = this._attachLiveRange(e4), this._managedUsingOperations = n3, this._affectsData = i3;
          }
          get managedUsingOperations() {
            if (!this._liveRange)
              throw new C2("marker-destroyed", this);
            return this._managedUsingOperations;
          }
          get affectsData() {
            if (!this._liveRange)
              throw new C2("marker-destroyed", this);
            return this._affectsData;
          }
          getData() {
            return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations };
          }
          getStart() {
            if (!this._liveRange)
              throw new C2("marker-destroyed", this);
            return this._liveRange.start.clone();
          }
          getEnd() {
            if (!this._liveRange)
              throw new C2("marker-destroyed", this);
            return this._liveRange.end.clone();
          }
          getRange() {
            if (!this._liveRange)
              throw new C2("marker-destroyed", this);
            return this._liveRange.toRange();
          }
          _attachLiveRange(t4) {
            return this._liveRange && this._detachLiveRange(), t4.delegate("change:range").to(this), t4.delegate("change:content").to(this), this._liveRange = t4, t4;
          }
          _detachLiveRange() {
            this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
          }
        }
        gu.prototype.is = function(t4) {
          return "marker" === t4 || "model:marker" === t4;
        };
        class mu extends Ch2 {
          constructor(t4, e4) {
            super(null), this.sourcePosition = t4.clone(), this.howMany = e4;
          }
          get type() {
            return "detach";
          }
          get affectedSelectable() {
            return null;
          }
          toJSON() {
            const t4 = super.toJSON();
            return t4.sourcePosition = this.sourcePosition.toJSON(), t4;
          }
          _validate() {
            if (this.sourcePosition.root.document)
              throw new C2("detach-operation-on-document-node", this);
          }
          _execute() {
            vh2(td2._createFromPositionAndShift(this.sourcePosition, this.howMany));
          }
          static get className() {
            return "DetachOperation";
          }
        }
        class pu extends Vl {
          constructor(t4) {
            super(), this.markers = /* @__PURE__ */ new Map(), this._children = new Hl(), t4 && this._insertChild(0, t4);
          }
          [Symbol.iterator]() {
            return this.getChildren();
          }
          get childCount() {
            return this._children.length;
          }
          get maxOffset() {
            return this._children.maxOffset;
          }
          get isEmpty() {
            return 0 === this.childCount;
          }
          get nextSibling() {
            return null;
          }
          get previousSibling() {
            return null;
          }
          get root() {
            return this;
          }
          get parent() {
            return null;
          }
          get document() {
            return null;
          }
          isAttached() {
            return false;
          }
          getAncestors() {
            return [];
          }
          getChild(t4) {
            return this._children.getNode(t4);
          }
          getChildren() {
            return this._children[Symbol.iterator]();
          }
          getChildIndex(t4) {
            return this._children.getNodeIndex(t4);
          }
          getChildStartOffset(t4) {
            return this._children.getNodeStartOffset(t4);
          }
          getPath() {
            return [];
          }
          getNodeByPath(t4) {
            let e4 = this;
            for (const n3 of t4)
              e4 = e4.getChild(e4.offsetToIndex(n3));
            return e4;
          }
          offsetToIndex(t4) {
            return this._children.offsetToIndex(t4);
          }
          toJSON() {
            const t4 = [];
            for (const e4 of this._children)
              t4.push(e4.toJSON());
            return t4;
          }
          static fromJSON(t4) {
            const e4 = [];
            for (const n3 of t4)
              n3.name ? e4.push(Wl.fromJSON(n3)) : e4.push(Ul.fromJSON(n3));
            return new pu(e4);
          }
          _appendChild(t4) {
            this._insertChild(this.childCount, t4);
          }
          _insertChild(t4, e4) {
            const n3 = function(t5) {
              if ("string" == typeof t5)
                return [new Ul(t5)];
              et2(t5) || (t5 = [t5]);
              return Array.from(t5).map((t6) => "string" == typeof t6 ? new Ul(t6) : t6 instanceof Gl ? new Ul(t6.data, t6.getAttributes()) : t6);
            }(e4);
            for (const t5 of n3)
              null !== t5.parent && t5._remove(), t5.parent = this;
            this._children._insertNodes(t4, n3);
          }
          _removeChildren(t4, e4 = 1) {
            const n3 = this._children._removeNodes(t4, e4);
            for (const t5 of n3)
              t5.parent = null;
            return n3;
          }
        }
        pu.prototype.is = function(t4) {
          return "documentFragment" === t4 || "model:documentFragment" === t4;
        };
        class fu {
          constructor(t4, e4) {
            this.model = t4, this.batch = e4;
          }
          createText(t4, e4) {
            return new Ul(t4, e4);
          }
          createElement(t4, e4) {
            return new Wl(t4, e4);
          }
          createDocumentFragment() {
            return new pu();
          }
          cloneElement(t4, e4 = true) {
            return t4._clone(e4);
          }
          insert(t4, e4, n3 = 0) {
            if (this._assertWriterUsedCorrectly(), t4 instanceof Ul && "" == t4.data)
              return;
            const i3 = Kl._createAt(e4, n3);
            if (t4.parent) {
              if (Cu(t4.root, i3.root))
                return void this.move(td2._createOn(t4), i3);
              if (t4.root.document)
                throw new C2("model-writer-insert-forbidden-move", this);
              this.remove(t4);
            }
            const o3 = i3.root.document ? i3.root.document.version : null, r3 = new Ih2(i3, t4, o3);
            if (t4 instanceof Ul && (r3.shouldReceiveAttributes = true), this.batch.addOperation(r3), this.model.applyOperation(r3), t4 instanceof pu)
              for (const [e5, n4] of t4.markers) {
                const t5 = Kl._createAt(n4.root, 0), o4 = { range: new td2(n4.start._getCombined(t5, i3), n4.end._getCombined(t5, i3)), usingOperation: true, affectsData: true };
                this.model.markers.has(e5) ? this.updateMarker(e5, o4) : this.addMarker(e5, o4);
              }
          }
          insertText(t4, e4, n3, i3) {
            e4 instanceof pu || e4 instanceof Wl || e4 instanceof Kl ? this.insert(this.createText(t4), e4, n3) : this.insert(this.createText(t4, e4), n3, i3);
          }
          insertElement(t4, e4, n3, i3) {
            e4 instanceof pu || e4 instanceof Wl || e4 instanceof Kl ? this.insert(this.createElement(t4), e4, n3) : this.insert(this.createElement(t4, e4), n3, i3);
          }
          append(t4, e4) {
            this.insert(t4, e4, "end");
          }
          appendText(t4, e4, n3) {
            e4 instanceof pu || e4 instanceof Wl ? this.insert(this.createText(t4), e4, "end") : this.insert(this.createText(t4, e4), n3, "end");
          }
          appendElement(t4, e4, n3) {
            e4 instanceof pu || e4 instanceof Wl ? this.insert(this.createElement(t4), e4, "end") : this.insert(this.createElement(t4, e4), n3, "end");
          }
          setAttribute(t4, e4, n3) {
            if (this._assertWriterUsedCorrectly(), n3 instanceof td2) {
              const i3 = n3.getMinimalFlatRanges();
              for (const n4 of i3)
                ku(this, t4, e4, n4);
            } else
              bu(this, t4, e4, n3);
          }
          setAttributes(t4, e4) {
            for (const [n3, i3] of Bo2(t4))
              this.setAttribute(n3, i3, e4);
          }
          removeAttribute(t4, e4) {
            if (this._assertWriterUsedCorrectly(), e4 instanceof td2) {
              const n3 = e4.getMinimalFlatRanges();
              for (const e5 of n3)
                ku(this, t4, null, e5);
            } else
              bu(this, t4, null, e4);
          }
          clearAttributes(t4) {
            this._assertWriterUsedCorrectly();
            const e4 = (t5) => {
              for (const e5 of t5.getAttributeKeys())
                this.removeAttribute(e5, t5);
            };
            if (t4 instanceof td2)
              for (const n3 of t4.getItems())
                e4(n3);
            else
              e4(t4);
          }
          move(t4, e4, n3) {
            if (this._assertWriterUsedCorrectly(), !(t4 instanceof td2))
              throw new C2("writer-move-invalid-range", this);
            if (!t4.isFlat)
              throw new C2("writer-move-range-not-flat", this);
            const i3 = Kl._createAt(e4, n3);
            if (i3.isEqual(t4.start))
              return;
            if (this._addOperationForAffectedMarkers("move", t4), !Cu(t4.root, i3.root))
              throw new C2("writer-move-different-document", this);
            const o3 = t4.root.document ? t4.root.document.version : null, r3 = new Th2(t4.start, t4.end.offset - t4.start.offset, i3, o3);
            this.batch.addOperation(r3), this.model.applyOperation(r3);
          }
          remove(t4) {
            this._assertWriterUsedCorrectly();
            const e4 = (t4 instanceof td2 ? t4 : td2._createOn(t4)).getMinimalFlatRanges().reverse();
            for (const t5 of e4)
              this._addOperationForAffectedMarkers("move", t5), Au(t5.start, t5.end.offset - t5.start.offset, this.batch, this.model);
          }
          merge(t4) {
            this._assertWriterUsedCorrectly();
            const e4 = t4.nodeBefore, n3 = t4.nodeAfter;
            if (this._addOperationForAffectedMarkers("merge", t4), !(e4 instanceof Wl))
              throw new C2("writer-merge-no-element-before", this);
            if (!(n3 instanceof Wl))
              throw new C2("writer-merge-no-element-after", this);
            t4.root.document ? this._merge(t4) : this._mergeDetached(t4);
          }
          createPositionFromPath(t4, e4, n3) {
            return this.model.createPositionFromPath(t4, e4, n3);
          }
          createPositionAt(t4, e4) {
            return this.model.createPositionAt(t4, e4);
          }
          createPositionAfter(t4) {
            return this.model.createPositionAfter(t4);
          }
          createPositionBefore(t4) {
            return this.model.createPositionBefore(t4);
          }
          createRange(t4, e4) {
            return this.model.createRange(t4, e4);
          }
          createRangeIn(t4) {
            return this.model.createRangeIn(t4);
          }
          createRangeOn(t4) {
            return this.model.createRangeOn(t4);
          }
          createSelection(...t4) {
            return this.model.createSelection(...t4);
          }
          _mergeDetached(t4) {
            const e4 = t4.nodeBefore, n3 = t4.nodeAfter;
            this.move(td2._createIn(n3), Kl._createAt(e4, "end")), this.remove(n3);
          }
          _merge(t4) {
            const e4 = Kl._createAt(t4.nodeBefore, "end"), n3 = Kl._createAt(t4.nodeAfter, 0), i3 = t4.root.document.graveyard, o3 = new Kl(i3, [0]), r3 = t4.root.document.version, s3 = new Mh2(n3, t4.nodeAfter.maxOffset, e4, o3, r3);
            this.batch.addOperation(s3), this.model.applyOperation(s3);
          }
          rename(t4, e4) {
            if (this._assertWriterUsedCorrectly(), !(t4 instanceof Wl))
              throw new C2("writer-rename-not-element-instance", this);
            const n3 = t4.root.document ? t4.root.document.version : null, i3 = new Rh2(Kl._createBefore(t4), t4.name, e4, n3);
            this.batch.addOperation(i3), this.model.applyOperation(i3);
          }
          split(t4, e4) {
            this._assertWriterUsedCorrectly();
            let n3, i3, o3 = t4.parent;
            if (!o3.parent)
              throw new C2("writer-split-element-no-parent", this);
            if (e4 || (e4 = o3.parent), !t4.parent.getAncestors({ includeSelf: true }).includes(e4))
              throw new C2("writer-split-invalid-limit-element", this);
            do {
              const e5 = o3.root.document ? o3.root.document.version : null, r3 = o3.maxOffset - t4.offset, s3 = Bh2.getInsertionPosition(t4), a3 = new Bh2(t4, r3, s3, null, e5);
              this.batch.addOperation(a3), this.model.applyOperation(a3), n3 || i3 || (n3 = o3, i3 = t4.parent.nextSibling), o3 = (t4 = this.createPositionAfter(t4.parent)).parent;
            } while (o3 !== e4);
            return { position: t4, range: new td2(Kl._createAt(n3, "end"), Kl._createAt(i3, 0)) };
          }
          wrap(t4, e4) {
            if (this._assertWriterUsedCorrectly(), !t4.isFlat)
              throw new C2("writer-wrap-range-not-flat", this);
            const n3 = e4 instanceof Wl ? e4 : new Wl(e4);
            if (n3.childCount > 0)
              throw new C2("writer-wrap-element-not-empty", this);
            if (null !== n3.parent)
              throw new C2("writer-wrap-element-attached", this);
            this.insert(n3, t4.start);
            const i3 = new td2(t4.start.getShiftedBy(1), t4.end.getShiftedBy(1));
            this.move(i3, Kl._createAt(n3, 0));
          }
          unwrap(t4) {
            if (this._assertWriterUsedCorrectly(), null === t4.parent)
              throw new C2("writer-unwrap-element-no-parent", this);
            this.move(td2._createIn(t4), this.createPositionAfter(t4)), this.remove(t4);
          }
          addMarker(t4, e4) {
            if (this._assertWriterUsedCorrectly(), !e4 || "boolean" != typeof e4.usingOperation)
              throw new C2("writer-addmarker-no-usingoperation", this);
            const n3 = e4.usingOperation, i3 = e4.range, o3 = void 0 !== e4.affectsData && e4.affectsData;
            if (this.model.markers.has(t4))
              throw new C2("writer-addmarker-marker-exists", this);
            if (!i3)
              throw new C2("writer-addmarker-no-range", this);
            return n3 ? (wu(this, t4, null, i3, o3), this.model.markers.get(t4)) : this.model.markers._set(t4, i3, n3, o3);
          }
          updateMarker(t4, e4) {
            this._assertWriterUsedCorrectly();
            const n3 = "string" == typeof t4 ? t4 : t4.name, i3 = this.model.markers.get(n3);
            if (!i3)
              throw new C2("writer-updatemarker-marker-not-exists", this);
            if (!e4)
              return _2("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n3 }), void this.model.markers._refresh(i3);
            const o3 = "boolean" == typeof e4.usingOperation, r3 = "boolean" == typeof e4.affectsData, s3 = r3 ? e4.affectsData : i3.affectsData;
            if (!o3 && !e4.range && !r3)
              throw new C2("writer-updatemarker-wrong-options", this);
            const a3 = i3.getRange(), c3 = e4.range ? e4.range : a3;
            o3 && e4.usingOperation !== i3.managedUsingOperations ? e4.usingOperation ? wu(this, n3, null, c3, s3) : (wu(this, n3, a3, null, s3), this.model.markers._set(n3, c3, void 0, s3)) : i3.managedUsingOperations ? wu(this, n3, a3, c3, s3) : this.model.markers._set(n3, c3, void 0, s3);
          }
          removeMarker(t4) {
            this._assertWriterUsedCorrectly();
            const e4 = "string" == typeof t4 ? t4 : t4.name;
            if (!this.model.markers.has(e4))
              throw new C2("writer-removemarker-no-marker", this);
            const n3 = this.model.markers.get(e4);
            if (!n3.managedUsingOperations)
              return void this.model.markers._remove(e4);
            wu(this, e4, n3.getRange(), null, n3.affectsData);
          }
          addRoot(t4, e4 = "$root") {
            this._assertWriterUsedCorrectly();
            const n3 = this.model.document.getRoot(t4);
            if (n3 && n3.isAttached())
              throw new C2("writer-addroot-root-exists", this);
            const i3 = this.model.document, o3 = new Fh2(t4, e4, true, i3, i3.version);
            return this.batch.addOperation(o3), this.model.applyOperation(o3), this.model.document.getRoot(t4);
          }
          detachRoot(t4) {
            this._assertWriterUsedCorrectly();
            const e4 = "string" == typeof t4 ? this.model.document.getRoot(t4) : t4;
            if (!e4 || !e4.isAttached())
              throw new C2("writer-detachroot-no-root", this);
            for (const t5 of this.model.markers)
              t5.getRange().root === e4 && this.removeMarker(t5);
            for (const t5 of e4.getAttributeKeys())
              this.removeAttribute(t5, e4);
            this.remove(this.createRangeIn(e4));
            const n3 = this.model.document, i3 = new Fh2(e4.rootName, e4.name, false, n3, n3.version);
            this.batch.addOperation(i3), this.model.applyOperation(i3);
          }
          setSelection(...t4) {
            this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...t4);
          }
          setSelectionFocus(t4, e4) {
            this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(t4, e4);
          }
          setSelectionAttribute(t4, e4) {
            if (this._assertWriterUsedCorrectly(), "string" == typeof t4)
              this._setSelectionAttribute(t4, e4);
            else
              for (const [e5, n3] of Bo2(t4))
                this._setSelectionAttribute(e5, n3);
          }
          removeSelectionAttribute(t4) {
            if (this._assertWriterUsedCorrectly(), "string" == typeof t4)
              this._removeSelectionAttribute(t4);
            else
              for (const e4 of t4)
                this._removeSelectionAttribute(e4);
          }
          overrideSelectionGravity() {
            return this.model.document.selection._overrideGravity();
          }
          restoreSelectionGravity(t4) {
            this.model.document.selection._restoreGravity(t4);
          }
          _setSelectionAttribute(t4, e4) {
            const n3 = this.model.document.selection;
            if (n3.isCollapsed && n3.anchor.parent.isEmpty) {
              const i3 = bd2._getStoreAttributeKey(t4);
              this.setAttribute(i3, e4, n3.anchor.parent);
            }
            n3._setAttribute(t4, e4);
          }
          _removeSelectionAttribute(t4) {
            const e4 = this.model.document.selection;
            if (e4.isCollapsed && e4.anchor.parent.isEmpty) {
              const n3 = bd2._getStoreAttributeKey(t4);
              this.removeAttribute(n3, e4.anchor.parent);
            }
            e4._removeAttribute(t4);
          }
          _assertWriterUsedCorrectly() {
            if (this.model._currentWriter !== this)
              throw new C2("writer-incorrect-use", this);
          }
          _addOperationForAffectedMarkers(t4, e4) {
            for (const n3 of this.model.markers) {
              if (!n3.managedUsingOperations)
                continue;
              const i3 = n3.getRange();
              let o3 = false;
              if ("move" === t4) {
                const t5 = e4;
                o3 = t5.containsPosition(i3.start) || t5.start.isEqual(i3.start) || t5.containsPosition(i3.end) || t5.end.isEqual(i3.end);
              } else {
                const t5 = e4, n4 = t5.nodeBefore, r3 = t5.nodeAfter, s3 = i3.start.parent == n4 && i3.start.isAtEnd, a3 = i3.end.parent == r3 && 0 == i3.end.offset, c3 = i3.end.nodeAfter == r3, l3 = i3.start.nodeAfter == r3;
                o3 = s3 || a3 || c3 || l3;
              }
              o3 && this.updateMarker(n3.name, { range: i3 });
            }
          }
        }
        function ku(t4, e4, n3, i3) {
          const o3 = t4.model, r3 = o3.document;
          let s3, a3, c3, l3 = i3.start;
          for (const t5 of i3.getWalker({ shallow: true }))
            c3 = t5.item.getAttribute(e4), s3 && a3 != c3 && (a3 != n3 && d3(), l3 = s3), s3 = t5.nextPosition, a3 = c3;
          function d3() {
            const i4 = new td2(l3, s3), c4 = i4.root.document ? r3.version : null, d4 = new zh2(i4, e4, a3, n3, c4);
            t4.batch.addOperation(d4), o3.applyOperation(d4);
          }
          s3 instanceof Kl && s3 != l3 && a3 != n3 && d3();
        }
        function bu(t4, e4, n3, i3) {
          const o3 = t4.model, r3 = o3.document, s3 = i3.getAttribute(e4);
          let a3, c3;
          if (s3 != n3) {
            if (i3.root === i3) {
              const t5 = i3.document ? r3.version : null;
              c3 = new Oh2(i3, e4, s3, n3, t5);
            } else {
              a3 = new td2(Kl._createBefore(i3), t4.createPositionAfter(i3));
              const o4 = a3.root.document ? r3.version : null;
              c3 = new zh2(a3, e4, s3, n3, o4);
            }
            t4.batch.addOperation(c3), o3.applyOperation(c3);
          }
        }
        function wu(t4, e4, n3, i3, o3) {
          const r3 = t4.model, s3 = r3.document, a3 = new Nh2(e4, n3, i3, r3.markers, !!o3, s3.version);
          t4.batch.addOperation(a3), r3.applyOperation(a3);
        }
        function Au(t4, e4, n3, i3) {
          let o3;
          if (t4.root.document) {
            const n4 = i3.document, r3 = new Kl(n4.graveyard, [0]);
            o3 = new Th2(t4, e4, r3, n4.version);
          } else
            o3 = new mu(t4, e4);
          n3.addOperation(o3), i3.applyOperation(o3);
        }
        function Cu(t4, e4) {
          return t4 === e4 || t4 instanceof cu && e4 instanceof cu;
        }
        function _u(t4, e4, n3 = {}) {
          if (e4.isCollapsed)
            return;
          const i3 = e4.getFirstRange();
          if ("$graveyard" == i3.root.rootName)
            return;
          const o3 = t4.schema;
          t4.change((t5) => {
            if (!n3.doNotResetEntireContent && function(t6, e5) {
              const n4 = t6.getLimitElement(e5);
              if (!e5.containsEntireContent(n4))
                return false;
              const i4 = e5.getFirstRange();
              if (i4.start.parent == i4.end.parent)
                return false;
              return t6.checkChild(n4, "paragraph");
            }(o3, e4))
              return void function(t6, e5) {
                const n4 = t6.model.schema.getLimitElement(e5);
                t6.remove(t6.createRangeIn(n4)), Eu(t6, t6.createPositionAt(n4, 0), e5);
              }(t5, e4);
            const r3 = {};
            if (!n3.doNotAutoparagraph) {
              const t6 = e4.getSelectedElement();
              t6 && Object.assign(r3, o3.getAttributesWithProperty(t6, "copyOnReplace", true));
            }
            const [s3, a3] = function(t6) {
              const e5 = t6.root.document.model, n4 = t6.start;
              let i4 = t6.end;
              if (e5.hasContent(t6, { ignoreMarkers: true })) {
                const n5 = function(t7) {
                  const e6 = t7.parent, n6 = e6.root.document.model.schema, i5 = e6.getAncestors({ parentFirst: true, includeSelf: true });
                  for (const t8 of i5) {
                    if (n6.isLimit(t8))
                      return null;
                    if (n6.isBlock(t8))
                      return t8;
                  }
                }(i4);
                if (n5 && i4.isTouching(e5.createPositionAt(n5, 0))) {
                  const n6 = e5.createSelection(t6);
                  e5.modifySelection(n6, { direction: "backward" });
                  const o4 = n6.getLastPosition(), r4 = e5.createRange(o4, i4);
                  e5.hasContent(r4, { ignoreMarkers: true }) || (i4 = o4);
                }
              }
              return [Xh2.fromPosition(n4, "toPrevious"), Xh2.fromPosition(i4, "toNext")];
            }(i3);
            s3.isTouching(a3) || t5.remove(t5.createRange(s3, a3)), n3.leaveUnmerged || (!function(t6, e5, n4) {
              const i4 = t6.model;
              if (!xu(t6.model.schema, e5, n4))
                return;
              const [o4, r4] = function(t7, e6) {
                const n5 = t7.getAncestors(), i5 = e6.getAncestors();
                let o5 = 0;
                for (; n5[o5] && n5[o5] == i5[o5]; )
                  o5++;
                return [n5[o5], i5[o5]];
              }(e5, n4);
              if (!o4 || !r4)
                return;
              !i4.hasContent(o4, { ignoreMarkers: true }) && i4.hasContent(r4, { ignoreMarkers: true }) ? yu(t6, e5, n4, o4.parent) : vu(t6, e5, n4, o4.parent);
            }(t5, s3, a3), o3.removeDisallowedAttributes(s3.parent.getChildren(), t5)), Du(t5, e4, s3), !n3.doNotAutoparagraph && function(t6, e5) {
              const n4 = t6.checkChild(e5, "$text"), i4 = t6.checkChild(e5, "paragraph");
              return !n4 && i4;
            }(o3, s3) && Eu(t5, s3, e4, r3), s3.detach(), a3.detach();
          });
        }
        function vu(t4, e4, n3, i3) {
          const o3 = e4.parent, r3 = n3.parent;
          if (o3 != i3 && r3 != i3) {
            for (e4 = t4.createPositionAfter(o3), (n3 = t4.createPositionBefore(r3)).isEqual(e4) || t4.insert(r3, e4), t4.merge(e4); n3.parent.isEmpty; ) {
              const e5 = n3.parent;
              n3 = t4.createPositionBefore(e5), t4.remove(e5);
            }
            xu(t4.model.schema, e4, n3) && vu(t4, e4, n3, i3);
          }
        }
        function yu(t4, e4, n3, i3) {
          const o3 = e4.parent, r3 = n3.parent;
          if (o3 != i3 && r3 != i3) {
            for (e4 = t4.createPositionAfter(o3), (n3 = t4.createPositionBefore(r3)).isEqual(e4) || t4.insert(o3, n3); e4.parent.isEmpty; ) {
              const n4 = e4.parent;
              e4 = t4.createPositionBefore(n4), t4.remove(n4);
            }
            n3 = t4.createPositionBefore(r3), function(t5, e5) {
              const n4 = e5.nodeBefore, i4 = e5.nodeAfter;
              n4.name != i4.name && t5.rename(n4, i4.name);
              t5.clearAttributes(n4), t5.setAttributes(Object.fromEntries(i4.getAttributes()), n4), t5.merge(e5);
            }(t4, n3), xu(t4.model.schema, e4, n3) && yu(t4, e4, n3, i3);
          }
        }
        function xu(t4, e4, n3) {
          const i3 = e4.parent, o3 = n3.parent;
          return i3 != o3 && (!t4.isLimit(i3) && !t4.isLimit(o3) && function(t5, e5, n4) {
            const i4 = new td2(t5, e5);
            for (const t6 of i4.getWalker())
              if (n4.isLimit(t6.item))
                return false;
            return true;
          }(e4, n3, t4));
        }
        function Eu(t4, e4, n3, i3 = {}) {
          const o3 = t4.createElement("paragraph");
          t4.model.schema.setAllowedAttributes(o3, i3, t4), t4.insert(o3, e4), Du(t4, n3, t4.createPositionAt(o3, 0));
        }
        function Du(t4, e4, n3) {
          e4 instanceof bd2 ? t4.setSelection(n3) : e4.setTo(n3);
        }
        function Su(t4, e4) {
          const n3 = [];
          Array.from(t4.getItems({ direction: "backward" })).map((t5) => e4.createRangeOn(t5)).filter((e5) => (e5.start.isAfter(t4.start) || e5.start.isEqual(t4.start)) && (e5.end.isBefore(t4.end) || e5.end.isEqual(t4.end))).forEach((t5) => {
            n3.push(t5.start.parent), e4.remove(t5);
          }), n3.forEach((t5) => {
            let n4 = t5;
            for (; n4.parent && n4.isEmpty; ) {
              const t6 = e4.createRangeOn(n4);
              n4 = n4.parent, e4.remove(t6);
            }
          });
        }
        class Tu {
          constructor(t4, e4, n3) {
            this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = t4, this.writer = e4, this.position = n3, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = t4.schema, this._documentFragment = e4.createDocumentFragment(), this._documentFragmentPosition = e4.createPositionAt(this._documentFragment, 0);
          }
          handleNodes(t4) {
            for (const e4 of Array.from(t4))
              this._handleNode(e4);
            this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
          }
          _updateLastNodeFromAutoParagraph(t4) {
            const e4 = this.writer.createPositionAfter(this._lastNode), n3 = this.writer.createPositionAfter(t4);
            if (n3.isAfter(e4)) {
              if (this._lastNode = t4, this.position.parent != t4 || !this.position.isAtEnd)
                throw new C2("insertcontent-invalid-insertion-position", this);
              this.position = n3, this._setAffectedBoundaries(this.position);
            }
          }
          getSelectionRange() {
            return this._nodeToSelect ? td2._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
          }
          getAffectedRange() {
            return this._affectedStart ? new td2(this._affectedStart, this._affectedEnd) : null;
          }
          destroy() {
            this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
          }
          _handleNode(t4) {
            if (this.schema.isObject(t4))
              return void this._handleObject(t4);
            let e4 = this._checkAndAutoParagraphToAllowedPosition(t4);
            e4 || (e4 = this._checkAndSplitToAllowedPosition(t4), e4) ? (this._appendToFragment(t4), this._firstNode || (this._firstNode = t4), this._lastNode = t4) : this._handleDisallowedNode(t4);
          }
          _insertPartialFragment() {
            if (this._documentFragment.isEmpty)
              return;
            const t4 = Xh2.fromPosition(this.position, "toNext");
            this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = t4.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = t4.toPosition(), t4.detach();
          }
          _handleObject(t4) {
            this._checkAndSplitToAllowedPosition(t4) ? this._appendToFragment(t4) : this._tryAutoparagraphing(t4);
          }
          _handleDisallowedNode(t4) {
            t4.is("element") ? this.handleNodes(t4.getChildren()) : this._tryAutoparagraphing(t4);
          }
          _appendToFragment(t4) {
            if (!this.schema.checkChild(this.position, t4))
              throw new C2("insertcontent-wrong-position", this, { node: t4, position: this.position });
            this.writer.insert(t4, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t4.offsetSize), this.schema.isObject(t4) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = t4 : this._nodeToSelect = null, this._filterAttributesOf.push(t4);
          }
          _setAffectedBoundaries(t4) {
            this._affectedStart || (this._affectedStart = Xh2.fromPosition(t4, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(t4) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = Xh2.fromPosition(t4, "toNext"));
          }
          _mergeOnLeft() {
            const t4 = this._firstNode;
            if (!(t4 instanceof Wl))
              return;
            if (!this._canMergeLeft(t4))
              return;
            const e4 = Xh2._createBefore(t4);
            e4.stickiness = "toNext";
            const n3 = Xh2.fromPosition(this.position, "toNext");
            this._affectedStart.isEqual(e4) && (this._affectedStart.detach(), this._affectedStart = Xh2._createAt(e4.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = e4.nodeBefore, this._lastNode = e4.nodeBefore), this.writer.merge(e4), e4.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = Xh2._createAt(e4.nodeBefore, "end", "toNext")), this.position = n3.toPosition(), n3.detach(), this._filterAttributesOf.push(this.position.parent), e4.detach();
          }
          _mergeOnRight() {
            const t4 = this._lastNode;
            if (!(t4 instanceof Wl))
              return;
            if (!this._canMergeRight(t4))
              return;
            const e4 = Xh2._createAfter(t4);
            if (e4.stickiness = "toNext", !this.position.isEqual(e4))
              throw new C2("insertcontent-invalid-insertion-position", this);
            this.position = Kl._createAt(e4.nodeBefore, "end");
            const n3 = Xh2.fromPosition(this.position, "toPrevious");
            this._affectedEnd.isEqual(e4) && (this._affectedEnd.detach(), this._affectedEnd = Xh2._createAt(e4.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = e4.nodeBefore, this._lastNode = e4.nodeBefore), this.writer.merge(e4), e4.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = Xh2._createAt(e4.nodeBefore, 0, "toPrevious")), this.position = n3.toPosition(), n3.detach(), this._filterAttributesOf.push(this.position.parent), e4.detach();
          }
          _canMergeLeft(t4) {
            const e4 = t4.previousSibling;
            return e4 instanceof Wl && this.canMergeWith.has(e4) && this.model.schema.checkMerge(e4, t4);
          }
          _canMergeRight(t4) {
            const e4 = t4.nextSibling;
            return e4 instanceof Wl && this.canMergeWith.has(e4) && this.model.schema.checkMerge(t4, e4);
          }
          _tryAutoparagraphing(t4) {
            const e4 = this.writer.createElement("paragraph");
            this._getAllowedIn(this.position.parent, e4) && this.schema.checkChild(e4, t4) && (e4._appendChild(t4), this._handleNode(e4));
          }
          _checkAndAutoParagraphToAllowedPosition(t4) {
            if (this.schema.checkChild(this.position.parent, t4))
              return true;
            if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", t4))
              return false;
            this._insertPartialFragment();
            const e4 = this.writer.createElement("paragraph");
            return this.writer.insert(e4, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = e4, this.position = this.writer.createPositionAt(e4, 0), true;
          }
          _checkAndSplitToAllowedPosition(t4) {
            const e4 = this._getAllowedIn(this.position.parent, t4);
            if (!e4)
              return false;
            for (e4 != this.position.parent && this._insertPartialFragment(); e4 != this.position.parent; )
              if (this.position.isAtStart) {
                const t5 = this.position.parent;
                this.position = this.writer.createPositionBefore(t5), t5.isEmpty && t5.parent === e4 && this.writer.remove(t5);
              } else if (this.position.isAtEnd)
                this.position = this.writer.createPositionAfter(this.position.parent);
              else {
                const t5 = this.writer.createPositionAfter(this.position.parent);
                this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = t5, this.canMergeWith.add(this.position.nodeAfter);
              }
            return true;
          }
          _getAllowedIn(t4, e4) {
            return this.schema.checkChild(t4, e4) ? t4 : this.schema.isLimit(t4) ? null : this._getAllowedIn(t4.parent, e4);
          }
        }
        function Iu(t4, e4, n3 = "auto") {
          const i3 = t4.getSelectedElement();
          if (i3 && e4.schema.isObject(i3) && !e4.schema.isInline(i3))
            return "before" == n3 || "after" == n3 ? e4.createRange(e4.createPositionAt(i3, n3)) : e4.createRangeOn(i3);
          const o3 = So2(t4.getSelectedBlocks());
          if (!o3)
            return e4.createRange(t4.focus);
          if (o3.isEmpty)
            return e4.createRange(e4.createPositionAt(o3, 0));
          const r3 = e4.createPositionAfter(o3);
          return t4.focus.isTouching(r3) ? e4.createRange(r3) : e4.createRange(e4.createPositionBefore(o3));
        }
        function Bu(t4, e4, n3, i3 = {}) {
          if (!t4.schema.isObject(e4))
            throw new C2("insertobject-element-not-an-object", t4, { object: e4 });
          const o3 = n3 || t4.document.selection;
          let r3 = o3;
          i3.findOptimalPosition && t4.schema.isBlock(e4) && (r3 = t4.createSelection(Iu(o3, t4, i3.findOptimalPosition)));
          const s3 = So2(o3.getSelectedBlocks()), a3 = {};
          return s3 && Object.assign(a3, t4.schema.getAttributesWithProperty(s3, "copyOnReplace", true)), t4.change((n4) => {
            r3.isCollapsed || t4.deleteContent(r3, { doNotAutoparagraph: true });
            let o4 = e4;
            const s4 = r3.anchor.parent;
            !t4.schema.checkChild(s4, e4) && t4.schema.checkChild(s4, "paragraph") && t4.schema.checkChild("paragraph", e4) && (o4 = n4.createElement("paragraph"), n4.insert(e4, o4)), t4.schema.setAllowedAttributes(o4, a3, n4);
            const c3 = t4.insertContent(o4, r3);
            return c3.isCollapsed || i3.setSelection && function(t5, e5, n5, i4) {
              const o5 = t5.model;
              if ("on" == n5)
                return void t5.setSelection(e5, "on");
              if ("after" != n5)
                throw new C2("insertobject-invalid-place-parameter-value", o5);
              let r4 = e5.nextSibling;
              if (o5.schema.isInline(e5))
                return void t5.setSelection(e5, "after");
              const s5 = r4 && o5.schema.checkChild(r4, "$text");
              !s5 && o5.schema.checkChild(e5.parent, "paragraph") && (r4 = t5.createElement("paragraph"), o5.schema.setAllowedAttributes(r4, i4, t5), o5.insertContent(r4, t5.createPositionAfter(e5)));
              r4 && t5.setSelection(r4, 0);
            }(n4, e4, i3.setSelection, a3), c3;
          });
        }
        const Mu = ' ,.?!:;"-()';
        function Nu(t4, e4) {
          const { isForward: n3, walker: i3, unit: o3, schema: r3, treatEmojiAsSingleUnit: s3 } = t4, { type: a3, item: c3, nextPosition: l3 } = e4;
          if ("text" == a3)
            return "word" === t4.unit ? function(t5, e5) {
              let n4 = t5.position.textNode;
              n4 || (n4 = e5 ? t5.position.nodeAfter : t5.position.nodeBefore);
              for (; n4 && n4.is("$text"); ) {
                const i4 = t5.position.offset - n4.startOffset;
                if (Pu(n4, i4, e5))
                  n4 = e5 ? t5.position.nodeAfter : t5.position.nodeBefore;
                else {
                  if (zu(n4.data, i4, e5))
                    break;
                  t5.next();
                }
              }
              return t5.position;
            }(i3, n3) : function(t5, e5, n4) {
              const i4 = t5.position.textNode;
              if (i4) {
                const o4 = i4.data;
                let r4 = t5.position.offset - i4.startOffset;
                for (; No2(o4, r4) || "character" == e5 && Lo2(o4, r4) || n4 && Po2(o4, r4); )
                  t5.next(), r4 = t5.position.offset - i4.startOffset;
              }
              return t5.position;
            }(i3, o3, s3);
          if (a3 == (n3 ? "elementStart" : "elementEnd")) {
            if (r3.isSelectable(c3))
              return Kl._createAt(c3, n3 ? "after" : "before");
            if (r3.checkChild(l3, "$text"))
              return l3;
          } else {
            if (r3.isLimit(c3))
              return void i3.skip(() => true);
            if (r3.checkChild(l3, "$text"))
              return l3;
          }
        }
        function Lu(t4, e4) {
          const n3 = t4.root, i3 = Kl._createAt(n3, e4 ? "end" : 0);
          return e4 ? new td2(t4, i3) : new td2(i3, t4);
        }
        function zu(t4, e4, n3) {
          const i3 = e4 + (n3 ? 0 : -1);
          return Mu.includes(t4.charAt(i3));
        }
        function Pu(t4, e4, n3) {
          return e4 === (n3 ? t4.offsetSize : 0);
        }
        class Ru extends q2() {
          constructor() {
            super(), this.markers = new uu(), this.document = new du(this), this.schema = new Xd2(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t4) => this.decorate(t4)), this.on("applyOperation", (t4, e4) => {
              e4[0]._validate();
            }, { priority: "highest" }), this.schema.register("$root", { isLimit: true }), this.schema.register("$container", { allowIn: ["$root", "$container"] }), this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: true }), this.schema.register("$blockObject", { allowWhere: "$block", isBlock: true, isObject: true }), this.schema.register("$inlineObject", { allowWhere: "$text", allowAttributesOf: "$text", isInline: true, isObject: true }), this.schema.register("$text", { allowIn: "$block", isInline: true, isContent: true }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }), this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }), this.schema.register("$marker"), this.schema.addChildCheck((t4, e4) => {
              if ("$marker" === e4.name)
                return true;
            }), Wd2(this), this.document.registerPostFixer(zd2), this.on("insertContent", (t4, [e4, n3]) => {
              t4.return = function(t5, e5, n4) {
                return t5.change((i3) => {
                  const o3 = n4 || t5.document.selection;
                  o3.isCollapsed || t5.deleteContent(o3, { doNotAutoparagraph: true });
                  const r3 = new Tu(t5, i3, o3.anchor), s3 = [];
                  let a3;
                  if (e5.is("documentFragment")) {
                    if (e5.markers.size) {
                      const t6 = [];
                      for (const [n5, i4] of e5.markers) {
                        const { start: e6, end: o4 } = i4, r4 = e6.isEqual(o4);
                        t6.push({ position: e6, name: n5, isCollapsed: r4 }, { position: o4, name: n5, isCollapsed: r4 });
                      }
                      t6.sort(({ position: t7 }, { position: e6 }) => t7.isBefore(e6) ? 1 : -1);
                      for (const { position: n5, name: o4, isCollapsed: r4 } of t6) {
                        let t7 = null, a4 = null;
                        const c4 = n5.parent === e5 && n5.isAtStart, l4 = n5.parent === e5 && n5.isAtEnd;
                        c4 || l4 ? r4 && (a4 = c4 ? "start" : "end") : (t7 = i3.createElement("$marker"), i3.insert(t7, n5)), s3.push({ name: o4, element: t7, collapsed: a4 });
                      }
                    }
                    a3 = e5.getChildren();
                  } else
                    a3 = [e5];
                  r3.handleNodes(a3);
                  let c3 = r3.getSelectionRange();
                  if (e5.is("documentFragment") && s3.length) {
                    const t6 = c3 ? md2.fromRange(c3) : null, e6 = {};
                    for (let t7 = s3.length - 1; t7 >= 0; t7--) {
                      const { name: n5, element: o4, collapsed: a4 } = s3[t7], c4 = !e6[n5];
                      if (c4 && (e6[n5] = []), o4) {
                        const t8 = i3.createPositionAt(o4, "before");
                        e6[n5].push(t8), i3.remove(o4);
                      } else {
                        const t8 = r3.getAffectedRange();
                        if (!t8) {
                          a4 && e6[n5].push(r3.position);
                          continue;
                        }
                        a4 ? e6[n5].push(t8[a4]) : e6[n5].push(c4 ? t8.start : t8.end);
                      }
                    }
                    for (const [t7, [n5, o4]] of Object.entries(e6))
                      n5 && o4 && n5.root === o4.root && i3.addMarker(t7, { usingOperation: true, affectsData: true, range: new td2(n5, o4) });
                    t6 && (c3 = t6.toRange(), t6.detach());
                  }
                  c3 && (o3 instanceof bd2 ? i3.setSelection(c3) : o3.setTo(c3));
                  const l3 = r3.getAffectedRange() || t5.createRange(o3.anchor);
                  return r3.destroy(), l3;
                });
              }(this, e4, n3);
            }), this.on("insertObject", (t4, [e4, n3, i3]) => {
              t4.return = Bu(this, e4, n3, i3);
            }), this.on("canEditAt", (t4) => {
              const e4 = !this.document.isReadOnly;
              t4.return = e4, e4 || t4.stop();
            });
          }
          change(t4) {
            try {
              return 0 === this._pendingChanges.length ? (this._pendingChanges.push({ batch: new nu(), callback: t4 }), this._runPendingChanges()[0]) : t4(this._currentWriter);
            } catch (t5) {
              C2.rethrowUnexpectedError(t5, this);
            }
          }
          enqueueChange(t4, e4) {
            try {
              t4 ? "function" == typeof t4 ? (e4 = t4, t4 = new nu()) : t4 instanceof nu || (t4 = new nu(t4)) : t4 = new nu(), this._pendingChanges.push({ batch: t4, callback: e4 }), 1 == this._pendingChanges.length && this._runPendingChanges();
            } catch (t5) {
              C2.rethrowUnexpectedError(t5, this);
            }
          }
          applyOperation(t4) {
            t4._execute();
          }
          insertContent(t4, e4, n3, ...i3) {
            const o3 = Ou(e4, n3);
            return this.fire("insertContent", [t4, o3, n3, ...i3]);
          }
          insertObject(t4, e4, n3, i3, ...o3) {
            const r3 = Ou(e4, n3);
            return this.fire("insertObject", [t4, r3, i3, i3, ...o3]);
          }
          deleteContent(t4, e4) {
            _u(this, t4, e4);
          }
          modifySelection(t4, e4) {
            !function(t5, e5, n3 = {}) {
              const i3 = t5.schema, o3 = "backward" != n3.direction, r3 = n3.unit ? n3.unit : "character", s3 = !!n3.treatEmojiAsSingleUnit, a3 = e5.focus, c3 = new ql2({ boundaries: Lu(a3, o3), singleCharacters: true, direction: o3 ? "forward" : "backward" }), l3 = { walker: c3, schema: i3, isForward: o3, unit: r3, treatEmojiAsSingleUnit: s3 };
              let d3;
              for (; d3 = c3.next(); ) {
                if (d3.done)
                  return;
                const n4 = Nu(l3, d3.value);
                if (n4)
                  return void (e5 instanceof bd2 ? t5.change((t6) => {
                    t6.setSelectionFocus(n4);
                  }) : e5.setFocus(n4));
              }
            }(this, t4, e4);
          }
          getSelectedContent(t4) {
            return function(t5, e4) {
              return t5.change((t6) => {
                const n3 = t6.createDocumentFragment(), i3 = e4.getFirstRange();
                if (!i3 || i3.isCollapsed)
                  return n3;
                const o3 = i3.start.root, r3 = i3.start.getCommonPath(i3.end), s3 = o3.getNodeByPath(r3);
                let a3;
                a3 = i3.start.parent == i3.end.parent ? i3 : t6.createRange(t6.createPositionAt(s3, i3.start.path[r3.length]), t6.createPositionAt(s3, i3.end.path[r3.length] + 1));
                const c3 = a3.end.offset - a3.start.offset;
                for (const e5 of a3.getItems({ shallow: true }))
                  e5.is("$textProxy") ? t6.appendText(e5.data, e5.getAttributes(), n3) : t6.append(t6.cloneElement(e5, true), n3);
                if (a3 != i3) {
                  const e5 = i3._getTransformedByMove(a3.start, t6.createPositionAt(n3, 0), c3)[0], o4 = t6.createRange(t6.createPositionAt(n3, 0), e5.start);
                  Su(t6.createRange(e5.end, t6.createPositionAt(n3, "end")), t6), Su(o4, t6);
                }
                return n3;
              });
            }(this, t4);
          }
          hasContent(t4, e4 = {}) {
            const n3 = t4 instanceof td2 ? t4 : td2._createIn(t4);
            if (n3.isCollapsed)
              return false;
            const { ignoreWhitespaces: i3 = false, ignoreMarkers: o3 = false } = e4;
            if (!o3) {
              for (const t5 of this.markers.getMarkersIntersectingRange(n3))
                if (t5.affectsData)
                  return true;
            }
            for (const t5 of n3.getItems())
              if (this.schema.isContent(t5)) {
                if (!t5.is("$textProxy"))
                  return true;
                if (!i3)
                  return true;
                if (-1 !== t5.data.search(/\S/))
                  return true;
              }
            return false;
          }
          canEditAt(t4) {
            const e4 = Ou(t4);
            return this.fire("canEditAt", [e4]);
          }
          createPositionFromPath(t4, e4, n3) {
            return new Kl(t4, e4, n3);
          }
          createPositionAt(t4, e4) {
            return Kl._createAt(t4, e4);
          }
          createPositionAfter(t4) {
            return Kl._createAfter(t4);
          }
          createPositionBefore(t4) {
            return Kl._createBefore(t4);
          }
          createRange(t4, e4) {
            return new td2(t4, e4);
          }
          createRangeIn(t4) {
            return td2._createIn(t4);
          }
          createRangeOn(t4) {
            return td2._createOn(t4);
          }
          createSelection(...t4) {
            return new ad2(...t4);
          }
          createBatch(t4) {
            return new nu(t4);
          }
          createOperationFromJSON(t4) {
            return jh2.fromJSON(t4, this.document);
          }
          destroy() {
            this.document.destroy(), this.stopListening();
          }
          _runPendingChanges() {
            const t4 = [];
            this.fire("_beforeChanges");
            try {
              for (; this._pendingChanges.length; ) {
                const e4 = this._pendingChanges[0].batch;
                this._currentWriter = new fu(this, e4);
                const n3 = this._pendingChanges[0].callback(this._currentWriter);
                t4.push(n3), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
              }
            } finally {
              this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
            }
            return t4;
          }
        }
        function Ou(t4, e4) {
          if (t4)
            return t4 instanceof ad2 || t4 instanceof bd2 ? t4 : t4 instanceof jl2 ? e4 || 0 === e4 ? new ad2(t4, e4) : t4.is("rootElement") ? new ad2(t4, "in") : new ad2(t4, "on") : new ad2(t4);
        }
        class Fu extends ol2 {
          constructor() {
            super(...arguments), this.domEventType = "click";
          }
          onDomEvent(t4) {
            this.fire(t4.type, t4);
          }
        }
        class Vu extends ol2 {
          constructor() {
            super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
          }
          onDomEvent(t4) {
            this.fire(t4.type, t4);
          }
        }
        class ju {
          constructor(t4) {
            this.document = t4;
          }
          createDocumentFragment(t4) {
            return new fc2(this.document, t4);
          }
          createElement(t4, e4, n3) {
            return new Fa2(this.document, t4, e4, n3);
          }
          createText(t4) {
            return new Os(this.document, t4);
          }
          clone(t4, e4 = false) {
            return t4._clone(e4);
          }
          appendChild(t4, e4) {
            return e4._appendChild(t4);
          }
          insertChild(t4, e4, n3) {
            return n3._insertChild(t4, e4);
          }
          removeChildren(t4, e4, n3) {
            return n3._removeChildren(t4, e4);
          }
          remove(t4) {
            const e4 = t4.parent;
            return e4 ? this.removeChildren(e4.getChildIndex(t4), 1, e4) : [];
          }
          replace(t4, e4) {
            const n3 = t4.parent;
            if (n3) {
              const i3 = n3.getChildIndex(t4);
              return this.removeChildren(i3, 1, n3), this.insertChild(i3, e4, n3), true;
            }
            return false;
          }
          unwrapElement(t4) {
            const e4 = t4.parent;
            if (e4) {
              const n3 = e4.getChildIndex(t4);
              this.remove(t4), this.insertChild(n3, t4.getChildren(), e4);
            }
          }
          rename(t4, e4) {
            const n3 = new Fa2(this.document, t4, e4.getAttributes(), e4.getChildren());
            return this.replace(e4, n3) ? n3 : null;
          }
          setAttribute(t4, e4, n3) {
            n3._setAttribute(t4, e4);
          }
          removeAttribute(t4, e4) {
            e4._removeAttribute(t4);
          }
          addClass(t4, e4) {
            e4._addClass(t4);
          }
          removeClass(t4, e4) {
            e4._removeClass(t4);
          }
          setStyle(t4, e4, n3) {
            Et2(t4) && void 0 === n3 ? e4._setStyle(t4) : n3._setStyle(t4, e4);
          }
          removeStyle(t4, e4) {
            e4._removeStyle(t4);
          }
          setCustomProperty(t4, e4, n3) {
            n3._setCustomProperty(t4, e4);
          }
          removeCustomProperty(t4, e4) {
            return e4._removeCustomProperty(t4);
          }
          createPositionAt(t4, e4) {
            return $a._createAt(t4, e4);
          }
          createPositionAfter(t4) {
            return $a._createAfter(t4);
          }
          createPositionBefore(t4) {
            return $a._createBefore(t4);
          }
          createRange(t4, e4) {
            return new Ka2(t4, e4);
          }
          createRangeOn(t4) {
            return Ka2._createOn(t4);
          }
          createRangeIn(t4) {
            return Ka2._createIn(t4);
          }
          createSelection(...t4) {
            return new Ya2(...t4);
          }
        }
        const Hu = /^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i, Uu = /^rgb\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}[0-9]{1,3}[ %]?\)$/i, Gu = /^rgba\([ ]?([0-9]{1,3}[ %]?,[ ]?){3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i, Wu = /^hsl\([ ]?([0-9]{1,3}[ %]?[,]?[ ]*){3}(1|[0-9]+%|[0]?\.?[0-9]+)?\)$/i, qu = /^hsla\([ ]?([0-9]{1,3}[ %]?,[ ]?){2,3}(1|[0-9]+%|[0]?\.?[0-9]+)\)$/i, $u = /\w+\((?:[^()]|\([^()]*\))*\)|\S+/gi, Ku = /* @__PURE__ */ new Set(["black", "silver", "gray", "white", "maroon", "red", "purple", "fuchsia", "green", "lime", "olive", "yellow", "navy", "blue", "teal", "aqua", "orange", "aliceblue", "antiquewhite", "aquamarine", "azure", "beige", "bisque", "blanchedalmond", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkgrey", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkslategrey", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dimgrey", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "gainsboro", "ghostwhite", "gold", "goldenrod", "greenyellow", "grey", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightgrey", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightslategrey", "lightsteelblue", "lightyellow", "limegreen", "linen", "magenta", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "oldlace", "olivedrab", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "skyblue", "slateblue", "slategray", "slategrey", "snow", "springgreen", "steelblue", "tan", "thistle", "tomato", "turquoise", "violet", "wheat", "whitesmoke", "yellowgreen", "activeborder", "activecaption", "appworkspace", "background", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "captiontext", "graytext", "highlight", "highlighttext", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infobackground", "infotext", "menu", "menutext", "scrollbar", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "window", "windowframe", "windowtext", "rebeccapurple", "currentcolor", "transparent"]);
        function Zu(t4) {
          return t4.startsWith("#") ? Hu.test(t4) : t4.startsWith("rgb") ? Uu.test(t4) || Gu.test(t4) : t4.startsWith("hsl") ? Wu.test(t4) || qu.test(t4) : Ku.has(t4.toLowerCase());
        }
        const Yu = ["none", "hidden", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset"];
        function Qu(t4) {
          return Yu.includes(t4);
        }
        const Ju = /^([+-]?[0-9]*([.][0-9]+)?(px|cm|mm|in|pc|pt|ch|em|ex|rem|vh|vw|vmin|vmax)|0)$/;
        function Xu(t4) {
          return Ju.test(t4);
        }
        const tg2 = /^[+-]?[0-9]*([.][0-9]+)?%$/;
        const eg2 = ["repeat-x", "repeat-y", "repeat", "space", "round", "no-repeat"];
        function ng2(t4) {
          return eg2.includes(t4);
        }
        const ig2 = ["center", "top", "bottom", "left", "right"];
        function og2(t4) {
          return ig2.includes(t4);
        }
        const rg2 = ["fixed", "scroll", "local"];
        function sg2(t4) {
          return rg2.includes(t4);
        }
        const ag2 = /^url\(/;
        function cg2(t4) {
          return ag2.test(t4);
        }
        function lg2(t4 = "") {
          if ("" === t4)
            return { top: void 0, right: void 0, bottom: void 0, left: void 0 };
          const e4 = gg2(t4), n3 = e4[0], i3 = e4[2] || n3, o3 = e4[1] || n3;
          return { top: n3, bottom: i3, right: o3, left: e4[3] || o3 };
        }
        function dg2(t4) {
          return (e4) => {
            const { top: n3, right: i3, bottom: o3, left: r3 } = e4, s3 = [];
            return [n3, i3, r3, o3].every((t5) => !!t5) ? s3.push([t4, hg2(e4)]) : (n3 && s3.push([t4 + "-top", n3]), i3 && s3.push([t4 + "-right", i3]), o3 && s3.push([t4 + "-bottom", o3]), r3 && s3.push([t4 + "-left", r3])), s3;
          };
        }
        function hg2({ top: t4, right: e4, bottom: n3, left: i3 }) {
          const o3 = [];
          return i3 !== e4 ? o3.push(t4, e4, n3, i3) : n3 !== t4 ? o3.push(t4, e4, n3) : e4 !== t4 ? o3.push(t4, e4) : o3.push(t4), o3.join(" ");
        }
        function ug2(t4) {
          return (e4) => ({ path: t4, value: lg2(e4) });
        }
        function gg2(t4) {
          const e4 = t4.matchAll($u);
          return Array.from(e4).map((t5) => t5[0]);
        }
        function mg2(t4) {
          t4.setNormalizer("background", (t5) => {
            const e4 = {}, n3 = gg2(t5);
            for (const t6 of n3)
              ng2(t6) ? (e4.repeat = e4.repeat || [], e4.repeat.push(t6)) : og2(t6) ? (e4.position = e4.position || [], e4.position.push(t6)) : sg2(t6) ? e4.attachment = t6 : Zu(t6) ? e4.color = t6 : cg2(t6) && (e4.image = t6);
            return { path: "background", value: e4 };
          }), t4.setNormalizer("background-color", (t5) => ({ path: "background.color", value: t5 })), t4.setReducer("background", (t5) => {
            const e4 = [];
            return e4.push(["background-color", t5.color]), e4;
          }), t4.setStyleRelation("background", ["background-color"]);
        }
        function pg2(t4) {
          t4.setNormalizer("border", (t5) => {
            const { color: e4, style: n3, width: i3 } = _g(t5);
            return { path: "border", value: { color: lg2(e4), style: lg2(n3), width: lg2(i3) } };
          }), t4.setNormalizer("border-top", fg2("top")), t4.setNormalizer("border-right", fg2("right")), t4.setNormalizer("border-bottom", fg2("bottom")), t4.setNormalizer("border-left", fg2("left")), t4.setNormalizer("border-color", kg2("color")), t4.setNormalizer("border-width", kg2("width")), t4.setNormalizer("border-style", kg2("style")), t4.setNormalizer("border-top-color", wg2("color", "top")), t4.setNormalizer("border-top-style", wg2("style", "top")), t4.setNormalizer("border-top-width", wg2("width", "top")), t4.setNormalizer("border-right-color", wg2("color", "right")), t4.setNormalizer("border-right-style", wg2("style", "right")), t4.setNormalizer("border-right-width", wg2("width", "right")), t4.setNormalizer("border-bottom-color", wg2("color", "bottom")), t4.setNormalizer("border-bottom-style", wg2("style", "bottom")), t4.setNormalizer("border-bottom-width", wg2("width", "bottom")), t4.setNormalizer("border-left-color", wg2("color", "left")), t4.setNormalizer("border-left-style", wg2("style", "left")), t4.setNormalizer("border-left-width", wg2("width", "left")), t4.setExtractor("border-top", Ag2("top")), t4.setExtractor("border-right", Ag2("right")), t4.setExtractor("border-bottom", Ag2("bottom")), t4.setExtractor("border-left", Ag2("left")), t4.setExtractor("border-top-color", "border.color.top"), t4.setExtractor("border-right-color", "border.color.right"), t4.setExtractor("border-bottom-color", "border.color.bottom"), t4.setExtractor("border-left-color", "border.color.left"), t4.setExtractor("border-top-width", "border.width.top"), t4.setExtractor("border-right-width", "border.width.right"), t4.setExtractor("border-bottom-width", "border.width.bottom"), t4.setExtractor("border-left-width", "border.width.left"), t4.setExtractor("border-top-style", "border.style.top"), t4.setExtractor("border-right-style", "border.style.right"), t4.setExtractor("border-bottom-style", "border.style.bottom"), t4.setExtractor("border-left-style", "border.style.left"), t4.setReducer("border-color", dg2("border-color")), t4.setReducer("border-style", dg2("border-style")), t4.setReducer("border-width", dg2("border-width")), t4.setReducer("border-top", vg2("top")), t4.setReducer("border-right", vg2("right")), t4.setReducer("border-bottom", vg2("bottom")), t4.setReducer("border-left", vg2("left")), t4.setReducer("border", function() {
            return (e4) => {
              const n3 = Cg2(e4, "top"), i3 = Cg2(e4, "right"), o3 = Cg2(e4, "bottom"), r3 = Cg2(e4, "left"), s3 = [n3, i3, o3, r3], a3 = { width: t5(s3, "width"), style: t5(s3, "style"), color: t5(s3, "color") }, c3 = yg2(a3, "all");
              if (c3.length)
                return c3;
              const l3 = Object.entries(a3).reduce((t6, [e5, n4]) => (n4 && (t6.push([`border-${e5}`, n4]), s3.forEach((t7) => delete t7[e5])), t6), []);
              return [...l3, ...yg2(n3, "top"), ...yg2(i3, "right"), ...yg2(o3, "bottom"), ...yg2(r3, "left")];
            };
            function t5(t6, e4) {
              return t6.map((t7) => t7[e4]).reduce((t7, e5) => t7 == e5 ? t7 : null);
            }
          }()), t4.setStyleRelation("border", ["border-color", "border-style", "border-width", "border-top", "border-right", "border-bottom", "border-left", "border-top-color", "border-right-color", "border-bottom-color", "border-left-color", "border-top-style", "border-right-style", "border-bottom-style", "border-left-style", "border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]), t4.setStyleRelation("border-color", ["border-top-color", "border-right-color", "border-bottom-color", "border-left-color"]), t4.setStyleRelation("border-style", ["border-top-style", "border-right-style", "border-bottom-style", "border-left-style"]), t4.setStyleRelation("border-width", ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"]), t4.setStyleRelation("border-top", ["border-top-color", "border-top-style", "border-top-width"]), t4.setStyleRelation("border-right", ["border-right-color", "border-right-style", "border-right-width"]), t4.setStyleRelation("border-bottom", ["border-bottom-color", "border-bottom-style", "border-bottom-width"]), t4.setStyleRelation("border-left", ["border-left-color", "border-left-style", "border-left-width"]);
        }
        function fg2(t4) {
          return (e4) => {
            const { color: n3, style: i3, width: o3 } = _g(e4), r3 = {};
            return void 0 !== n3 && (r3.color = { [t4]: n3 }), void 0 !== i3 && (r3.style = { [t4]: i3 }), void 0 !== o3 && (r3.width = { [t4]: o3 }), { path: "border", value: r3 };
          };
        }
        function kg2(t4) {
          return (e4) => ({ path: "border", value: bg2(e4, t4) });
        }
        function bg2(t4, e4) {
          return { [e4]: lg2(t4) };
        }
        function wg2(t4, e4) {
          return (n3) => ({ path: "border", value: { [t4]: { [e4]: n3 } } });
        }
        function Ag2(t4) {
          return (e4, n3) => {
            if (n3.border)
              return Cg2(n3.border, t4);
          };
        }
        function Cg2(t4, e4) {
          const n3 = {};
          return t4.width && t4.width[e4] && (n3.width = t4.width[e4]), t4.style && t4.style[e4] && (n3.style = t4.style[e4]), t4.color && t4.color[e4] && (n3.color = t4.color[e4]), n3;
        }
        function _g(t4) {
          const e4 = {}, n3 = gg2(t4);
          for (const t5 of n3)
            Xu(t5) || /thin|medium|thick/.test(t5) ? e4.width = t5 : Qu(t5) ? e4.style = t5 : e4.color = t5;
          return e4;
        }
        function vg2(t4) {
          return (e4) => yg2(e4, t4);
        }
        function yg2(t4, e4) {
          const n3 = [];
          if (t4 && t4.width && n3.push("width"), t4 && t4.style && n3.push("style"), t4 && t4.color && n3.push("color"), 3 == n3.length) {
            const i3 = n3.map((e5) => t4[e5]).join(" ");
            return ["all" == e4 ? ["border", i3] : [`border-${e4}`, i3]];
          }
          return "all" == e4 ? [] : n3.map((n4) => [`border-${e4}-${n4}`, t4[n4]]);
        }
        function xg2(t4) {
          t4.setNormalizer("margin", ug2("margin")), t4.setNormalizer("margin-top", (t5) => ({ path: "margin.top", value: t5 })), t4.setNormalizer("margin-right", (t5) => ({ path: "margin.right", value: t5 })), t4.setNormalizer("margin-bottom", (t5) => ({ path: "margin.bottom", value: t5 })), t4.setNormalizer("margin-left", (t5) => ({ path: "margin.left", value: t5 })), t4.setReducer("margin", dg2("margin")), t4.setStyleRelation("margin", ["margin-top", "margin-right", "margin-bottom", "margin-left"]);
        }
        function Eg2(t4) {
          t4.setNormalizer("padding", ug2("padding")), t4.setNormalizer("padding-top", (t5) => ({ path: "padding.top", value: t5 })), t4.setNormalizer("padding-right", (t5) => ({ path: "padding.right", value: t5 })), t4.setNormalizer("padding-bottom", (t5) => ({ path: "padding.bottom", value: t5 })), t4.setNormalizer("padding-left", (t5) => ({ path: "padding.left", value: t5 })), t4.setReducer("padding", dg2("padding")), t4.setStyleRelation("padding", ["padding-top", "padding-right", "padding-bottom", "padding-left"]);
        }
        class Dg2 {
          constructor() {
            this._commands = /* @__PURE__ */ new Map();
          }
          add(t4, e4) {
            this._commands.set(t4, e4);
          }
          get(t4) {
            return this._commands.get(t4);
          }
          execute(t4, ...e4) {
            const n3 = this.get(t4);
            if (!n3)
              throw new C2("commandcollection-command-not-found", this, { commandName: t4 });
            return n3.execute(...e4);
          }
          *names() {
            yield* this._commands.keys();
          }
          *commands() {
            yield* this._commands.values();
          }
          [Symbol.iterator]() {
            return this._commands[Symbol.iterator]();
          }
          destroy() {
            for (const t4 of this.commands())
              t4.destroy();
          }
        }
        class Sg2 extends Io2 {
          constructor(t4) {
            super(), this.editor = t4;
          }
          set(t4, e4, n3 = {}) {
            if ("string" == typeof e4) {
              const t5 = e4;
              e4 = (e5, n4) => {
                this.editor.execute(t5), n4();
              };
            }
            super.set(t4, e4, n3);
          }
        }
        class Tg2 extends q2() {
          constructor(t4 = {}) {
            super();
            const e4 = this.constructor, n3 = t4.language || e4.defaultConfig && e4.defaultConfig.language;
            this._context = t4.context || new ys({ language: n3 }), this._context._addEditor(this, !t4.context);
            const i3 = Array.from(e4.builtinPlugins || []);
            this.config = new yi2(t4, e4.defaultConfig), this.config.define("plugins", i3), this.config.define(this._context._getEditorConfig()), this.plugins = new vs(this, i3, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new Dg2(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new Ru(), this.on("change:isReadOnly", () => {
              this.model.document.isReadOnly = this.isReadOnly;
            });
            const o3 = new Pa2();
            this.data = new kh2(this.model, o3), this.editing = new Zd2(this.model, o3), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new bh2([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new Sg2(this), this.keystrokes.listenTo(this.editing.view.document);
          }
          get isReadOnly() {
            return this._readOnlyLocks.size > 0;
          }
          set isReadOnly(t4) {
            throw new C2("editor-isreadonly-has-no-setter");
          }
          enableReadOnlyMode(t4) {
            if ("string" != typeof t4 && "symbol" != typeof t4)
              throw new C2("editor-read-only-lock-id-invalid", null, { lockId: t4 });
            this._readOnlyLocks.has(t4) || (this._readOnlyLocks.add(t4), 1 === this._readOnlyLocks.size && this.fire("change:isReadOnly", "isReadOnly", true, false));
          }
          disableReadOnlyMode(t4) {
            if ("string" != typeof t4 && "symbol" != typeof t4)
              throw new C2("editor-read-only-lock-id-invalid", null, { lockId: t4 });
            this._readOnlyLocks.has(t4) && (this._readOnlyLocks.delete(t4), 0 === this._readOnlyLocks.size && this.fire("change:isReadOnly", "isReadOnly", false, true));
          }
          initPlugins() {
            const t4 = this.config, e4 = t4.get("plugins"), n3 = t4.get("removePlugins") || [], i3 = t4.get("extraPlugins") || [], o3 = t4.get("substitutePlugins") || [];
            return this.plugins.init(e4.concat(i3), n3, o3);
          }
          destroy() {
            let t4 = Promise.resolve();
            return "initializing" == this.state && (t4 = new Promise((t5) => this.once("ready", t5))), t4.then(() => {
              this.fire("destroy"), this.stopListening(), this.commands.destroy();
            }).then(() => this.plugins.destroy()).then(() => {
              this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
            }).then(() => this._context._removeEditor(this));
          }
          execute(t4, ...e4) {
            try {
              return this.commands.execute(t4, ...e4);
            } catch (t5) {
              C2.rethrowUnexpectedError(t5, this);
            }
          }
          focus() {
            this.editing.view.focus();
          }
          static create(...t4) {
            throw new Error("This is an abstract method.");
          }
        }
        function Ig2(t4) {
          return class extends t4 {
            setData(t5) {
              this.data.set(t5);
            }
            getData(t5) {
              return this.data.get(t5);
            }
          };
        }
        {
          const t4 = Ig2(Object);
          Ig2.setData = t4.prototype.setData, Ig2.getData = t4.prototype.getData;
        }
        function Bg2(t4) {
          return class extends t4 {
            updateSourceElement(t5) {
              if (!this.sourceElement)
                throw new C2("editor-missing-sourceelement", this);
              const e4 = this.config.get("updateSourceElementOnDestroy"), n3 = this.sourceElement instanceof HTMLTextAreaElement;
              if (!e4 && !n3)
                return void qi2(this.sourceElement, "");
              const i3 = "string" == typeof t5 ? t5 : this.data.get();
              qi2(this.sourceElement, i3);
            }
          };
        }
        Bg2.updateSourceElement = Bg2(Object).prototype.updateSourceElement;
        class Mg2 extends xs {
          static get pluginName() {
            return "PendingActions";
          }
          init() {
            this.set("hasAny", false), this._actions = new Do2({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
          }
          add(t4) {
            if ("string" != typeof t4)
              throw new C2("pendingactions-add-invalid-message", this);
            const e4 = new (q2())();
            return e4.set("message", t4), this._actions.add(e4), this.hasAny = true, e4;
          }
          remove(t4) {
            this._actions.remove(t4), this.hasAny = !!this._actions.length;
          }
          get first() {
            return this._actions.get(0);
          }
          [Symbol.iterator]() {
            return this._actions[Symbol.iterator]();
          }
        }
        const Ng2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', Lg2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', zg2 = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', Pg2 = { bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', cancel: Ng2, caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', check: Lg2, cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', eraser: zg2, history: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>', image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', textAlternative: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M1 10.5a1 1 0 0 0-1 1v7a1 1 0 0 0 1 1h18a1 1 0 0 0 1-1v-7a1 1 0 0 0-1-1H1Zm5.006 7.25-.221-.74h-1.84l-.22.74H2l1.915-5.25h1.961l1.916 5.25H6.006Zm-1.71-1.915h1.138l-.55-1.87h-.03l-.557 1.87ZM8.772 12.5h1.686v3.907h2.694v1.343h-4.38V12.5Zm8.067 5.25v-3.907h1.717V12.5h-5.128v1.343h1.725v3.907h1.686Z"/><path d="M8.013 7.326a.577.577 0 0 0-.797-.028L5.214 9.5h5.126L8.013 7.326ZM11.778 9.5h3.098l-1.015-1.197a.58.58 0 0 0-.788 0L11.778 9.5Zm4.364 0V1.83H3.858V9.5H2.5V1.45c0-.525.444-.95.996-.95h13.017c.543 0 .987.425.987.95V9.5h-1.358Zm-4.576-4.623a1.776 1.776 0 1 0 3.522-.462 1.776 1.776 0 0 0-3.522.462Z"/></svg>\n', loupe: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>', importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>', paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>', alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>', objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>', objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>', pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>', dragIndicator: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>' };
        var Rg2 = n2(4768), Og2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Rg2.Z, Og2);
        Rg2.Z.locals;
        const { threeVerticalDots: Fg2 } = Pg2, Vg2 = { alignLeft: Pg2.alignLeft, bold: Pg2.bold, importExport: Pg2.importExport, paragraph: Pg2.paragraph, plus: Pg2.plus, text: Pg2.text, threeVerticalDots: Pg2.threeVerticalDots, pilcrow: Pg2.pilcrow, dragIndicator: Pg2.dragIndicator };
        class jg2 extends Ho2 {
          constructor(t4, e4) {
            super(t4);
            const n3 = this.bindTemplate, i3 = this.t;
            this.options = e4 || {}, this.set("ariaLabel", i3("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new To2(), this.keystrokes = new Io2(), this.set("class", void 0), this.set("isCompact", false), this.itemsView = new Hg2(t4), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
            const o3 = "rtl" === t4.uiLanguageDirection;
            this._focusCycler = new gs({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [o3 ? "arrowright" : "arrowleft", "arrowup"], focusNext: [o3 ? "arrowleft" : "arrowright", "arrowdown"] } });
            const r3 = ["ck", "ck-toolbar", n3.to("class"), n3.if("isCompact", "ck-toolbar_compact")];
            var s3;
            this.options.shouldGroupWhenFull && this.options.isFloating && r3.push("ck-toolbar_floating"), this.setTemplate({ tag: "div", attributes: { class: r3, role: "toolbar", "aria-label": n3.to("ariaLabel"), style: { maxWidth: n3.to("maxWidth") }, tabindex: -1 }, children: this.children, on: { mousedown: (s3 = this, s3.bindTemplate.to((t5) => {
              t5.target === s3.element && t5.preventDefault();
            })) } }), this._behavior = this.options.shouldGroupWhenFull ? new Gg2(this) : new Ug2(this);
          }
          render() {
            super.render(), this.focusTracker.add(this.element);
            for (const t4 of this.items)
              this.focusTracker.add(t4.element);
            this.items.on("add", (t4, e4) => {
              this.focusTracker.add(e4.element);
            }), this.items.on("remove", (t4, e4) => {
              this.focusTracker.remove(e4.element);
            }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
          }
          destroy() {
            return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          fillFromConfig(t4, e4, n3) {
            this.items.addMany(this._buildItemsFromConfig(t4, e4, n3));
          }
          _buildItemsFromConfig(t4, e4, n3) {
            const i3 = ks(t4), o3 = n3 || i3.removeItems;
            return this._cleanItemsConfiguration(i3.items, e4, o3).map((t5) => F2(t5) ? this._createNestedToolbarDropdown(t5, e4, o3) : "|" === t5 ? new ps() : "-" === t5 ? new fs() : e4.create(t5)).filter((t5) => !!t5);
          }
          _cleanItemsConfiguration(t4, e4, n3) {
            const i3 = t4.filter((t5, i4, o3) => "|" === t5 || -1 === n3.indexOf(t5) && ("-" === t5 ? !this.options.shouldGroupWhenFull || (_2("toolbarview-line-break-ignored-when-grouping-items", o3), false) : !(!F2(t5) && !e4.has(t5)) || (_2("toolbarview-item-unavailable", { item: t5 }), false)));
            return this._cleanSeparatorsAndLineBreaks(i3);
          }
          _cleanSeparatorsAndLineBreaks(t4) {
            const e4 = (t5) => "-" !== t5 && "|" !== t5, n3 = t4.length, i3 = t4.findIndex(e4);
            if (-1 === i3)
              return [];
            const o3 = n3 - t4.slice().reverse().findIndex(e4);
            return t4.slice(i3, o3).filter((t5, n4, i4) => {
              if (e4(t5))
                return true;
              return !(n4 > 0 && i4[n4 - 1] === t5);
            });
          }
          _createNestedToolbarDropdown(t4, e4, n3) {
            let { label: i3, icon: o3, items: r3, tooltip: s3 = true, withText: a3 = false } = t4;
            if (r3 = this._cleanItemsConfiguration(r3, e4, n3), !r3.length)
              return null;
            const c3 = om(this.locale);
            return i3 || _2("toolbarview-nested-toolbar-dropdown-missing-label", t4), c3.class = "ck-toolbar__nested-toolbar-dropdown", c3.buttonView.set({ label: i3, tooltip: s3, withText: !!a3 }), false !== o3 ? c3.buttonView.icon = Vg2[o3] || o3 || Fg2 : c3.buttonView.withText = true, rm(c3, () => c3.toolbarView._buildItemsFromConfig(r3, e4, n3)), c3;
          }
        }
        class Hg2 extends Ho2 {
          constructor(t4) {
            super(t4), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
          }
        }
        class Ug2 {
          constructor(t4) {
            const e4 = t4.bindTemplate;
            t4.set("isVertical", false), t4.itemsView.children.bindTo(t4.items).using((t5) => t5), t4.focusables.bindTo(t4.items).using((t5) => t5), t4.extendTemplate({ attributes: { class: [e4.if("isVertical", "ck-toolbar_vertical")] } });
          }
          render() {
          }
          destroy() {
          }
        }
        class Gg2 {
          constructor(t4) {
            this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = false, this.view = t4, this.viewChildren = t4.children, this.viewFocusables = t4.focusables, this.viewItemsView = t4.itemsView, this.viewFocusTracker = t4.focusTracker, this.viewLocale = t4.locale, this.ungroupedItems = t4.createCollection(), this.groupedItems = t4.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), t4.itemsView.children.bindTo(this.ungroupedItems).using((t5) => t5), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), t4.children.on("change", this._updateFocusCycleableItems.bind(this)), t4.items.on("change", (t5, e4) => {
              const n3 = e4.index, i3 = Array.from(e4.added);
              for (const t6 of e4.removed)
                n3 >= this.ungroupedItems.length ? this.groupedItems.remove(t6) : this.ungroupedItems.remove(t6);
              for (let t6 = n3; t6 < n3 + i3.length; t6++) {
                const e5 = i3[t6 - n3];
                t6 > this.ungroupedItems.length ? this.groupedItems.add(e5, t6 - this.ungroupedItems.length) : this.ungroupedItems.add(e5, t6);
              }
              this._updateGrouping();
            }), t4.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
          }
          render(t4) {
            this.viewElement = t4.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(t4);
          }
          destroy() {
            this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
          }
          _updateGrouping() {
            if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
              return;
            if (!Ji2(this.viewElement))
              return void (this.shouldUpdateGroupingOnNextResize = true);
            const t4 = this.groupedItems.length;
            let e4;
            for (; this._areItemsOverflowing; )
              this._groupLastItem(), e4 = true;
            if (!e4 && this.groupedItems.length) {
              for (; this.groupedItems.length && !this._areItemsOverflowing; )
                this._ungroupFirstItem();
              this._areItemsOverflowing && this._groupLastItem();
            }
            this.groupedItems.length !== t4 && this.view.fire("groupedItemsUpdate");
          }
          get _areItemsOverflowing() {
            if (!this.ungroupedItems.length)
              return false;
            const t4 = this.viewElement, e4 = this.viewLocale.uiLanguageDirection, n3 = new Vi2(t4.lastChild), i3 = new Vi2(t4);
            if (!this.cachedPadding) {
              const n4 = Li2.window.getComputedStyle(t4), i4 = "ltr" === e4 ? "paddingRight" : "paddingLeft";
              this.cachedPadding = Number.parseInt(n4[i4]);
            }
            return "ltr" === e4 ? n3.right > i3.right - this.cachedPadding : n3.left < i3.left + this.cachedPadding;
          }
          _enableGroupingOnResize() {
            let t4;
            this.resizeObserver = new Wi2(this.viewElement, (e4) => {
              t4 && t4 === e4.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = false, this._updateGrouping(), t4 = e4.contentRect.width);
            }), this._updateGrouping();
          }
          _enableGroupingOnMaxWidthChange(t4) {
            t4.on("change:maxWidth", () => {
              this._updateGrouping();
            });
          }
          _groupLastItem() {
            this.groupedItems.length || (this.viewChildren.add(new ps()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
          }
          _ungroupFirstItem() {
            this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
          }
          _createGroupedItemsDropdown() {
            const t4 = this.viewLocale, e4 = t4.t, n3 = om(t4);
            return n3.class = "ck-toolbar__grouped-dropdown", n3.panelPosition = "ltr" === t4.uiLanguageDirection ? "sw" : "se", rm(n3, this.groupedItems), n3.buttonView.set({ label: e4("Show more items"), tooltip: true, tooltipPosition: "rtl" === t4.uiLanguageDirection ? "se" : "sw", icon: Fg2 }), n3;
          }
          _updateFocusCycleableItems() {
            this.viewFocusables.clear(), this.ungroupedItems.map((t4) => {
              this.viewFocusables.add(t4);
            }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
          }
        }
        class Wg2 extends Ho2 {
          constructor(t4, e4 = new Yr()) {
            super(t4);
            const n3 = this.bindTemplate, i3 = new Kg2(t4);
            this.set({ label: "", isVisible: true }), this.labelView = e4, this.labelView.bind("text").to(this, "label"), this.children = this.createCollection(), this.children.addMany([this.labelView, i3]), i3.set({ role: "group", ariaLabelledBy: e4.id }), i3.focusTracker.destroy(), i3.keystrokes.destroy(), this.items = i3.items, this.setTemplate({ tag: "li", attributes: { role: "presentation", class: ["ck", "ck-list__group", n3.if("isVisible", "ck-hidden", (t5) => !t5)] }, children: this.children });
          }
          focus() {
            this.items.first && this.items.first.focus();
          }
        }
        var qg2 = n2(179), $g2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(qg2.Z, $g2);
        qg2.Z.locals;
        class Kg2 extends Ho2 {
          constructor(t4) {
            super(t4), this._listItemGroupToChangeListeners = /* @__PURE__ */ new WeakMap();
            const e4 = this.bindTemplate;
            this.focusables = new Ro2(), this.items = this.createCollection(), this.focusTracker = new To2(), this.keystrokes = new Io2(), this._focusCycler = new gs({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", void 0), this.set("role", void 0), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"], role: e4.to("role"), "aria-label": e4.to("ariaLabel"), "aria-labelledby": e4.to("ariaLabelledBy") }, children: this.items });
          }
          render() {
            super.render();
            for (const t4 of this.items)
              t4 instanceof Wg2 ? this._registerFocusableItemsGroup(t4) : this._registerFocusableListItem(t4);
            this.items.on("change", (t4, e4) => {
              for (const t5 of e4.removed)
                t5 instanceof Wg2 ? this._deregisterFocusableItemsGroup(t5) : this._deregisterFocusableListItem(t5);
              for (const t5 of Array.from(e4.added).reverse())
                t5 instanceof Wg2 ? this._registerFocusableItemsGroup(t5, e4.index) : this._registerFocusableListItem(t5, e4.index);
            }), this.keystrokes.listenTo(this.element);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusFirst() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          _registerFocusableListItem(t4, e4) {
            this.focusTracker.add(t4.element), this.focusables.add(t4, e4);
          }
          _deregisterFocusableListItem(t4) {
            this.focusTracker.remove(t4.element), this.focusables.remove(t4);
          }
          _getOnGroupItemsChangeCallback(t4) {
            return (e4, n3) => {
              for (const t5 of n3.removed)
                this._deregisterFocusableListItem(t5);
              for (const e5 of Array.from(n3.added).reverse())
                this._registerFocusableListItem(e5, this.items.getIndex(t4) + n3.index);
            };
          }
          _registerFocusableItemsGroup(t4, e4) {
            Array.from(t4.items).forEach((t5, n4) => {
              const i3 = void 0 !== e4 ? e4 + n4 : void 0;
              this._registerFocusableListItem(t5, i3);
            });
            const n3 = this._getOnGroupItemsChangeCallback(t4);
            this._listItemGroupToChangeListeners.set(t4, n3), t4.items.on("change", n3);
          }
          _deregisterFocusableItemsGroup(t4) {
            for (const e4 of t4.items)
              this._deregisterFocusableListItem(e4);
            t4.items.off("change", this._listItemGroupToChangeListeners.get(t4)), this._listItemGroupToChangeListeners.delete(t4);
          }
        }
        class Zg2 extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.set("isVisible", true), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item", e4.if("isVisible", "ck-hidden", (t5) => !t5)], role: "presentation" }, children: this.children });
          }
          focus() {
            this.children.first && this.children.first.focus();
          }
        }
        class Yg2 extends Ho2 {
          constructor(t4) {
            super(t4), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
          }
        }
        var Qg2 = n2(4791), Jg2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Qg2.Z, Jg2);
        Qg2.Z.locals;
        class Xg2 extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", true), this.set("isOn", false), this.set("isToggleable", false), this.set("isVisible", true), this.set("keystroke", void 0), this.set("withKeystroke", false), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", false), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new Io2(), this.focusTracker = new To2(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", e4.to("class"), e4.if("isVisible", "ck-hidden", (t5) => !t5), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
          }
          render() {
            super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (t4, e4) => {
              this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e4());
            }), this.keystrokes.set("arrowleft", (t4, e4) => {
              this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e4());
            });
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this.actionView.focus();
          }
          _createActionView() {
            const t4 = new kr();
            return t4.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t4.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), t4.delegate("execute").to(this), t4;
          }
          _createArrowView() {
            const t4 = new kr(), e4 = t4.bindTemplate;
            return t4.icon = hs, t4.extendTemplate({ attributes: { class: ["ck-splitbutton__arrow"], "data-cke-tooltip-disabled": e4.to("isOn"), "aria-haspopup": true, "aria-expanded": e4.to("isOn", (t5) => String(t5)) } }), t4.bind("isEnabled").to(this), t4.bind("label").to(this), t4.bind("tooltip").to(this), t4.delegate("execute").to(this, "open"), t4;
          }
        }
        var tm = n2(2704), em = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(tm.Z, em);
        tm.Z.locals;
        var nm = n2(1883), im = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(nm.Z, im);
        nm.Z.locals;
        function om(e4, n3 = us) {
          const i3 = new n3(e4), o3 = new as(e4), r3 = new ds(e4, i3, o3);
          return i3.bind("isEnabled").to(r3), i3 instanceof Xg2 ? i3.arrowView.bind("isOn").to(r3, "isOpen") : i3.bind("isOn").to(r3, "isOpen"), function(e5) {
            (function(e6) {
              e6.on("render", () => {
                t3({ emitter: e6, activator: () => e6.isOpen, callback: () => {
                  e6.isOpen = false;
                }, contextElements: () => [e6.element, ...e6.focusTracker._elements] });
              });
            })(e5), function(t4) {
              t4.on("execute", (e6) => {
                e6.source instanceof Ar || (t4.isOpen = false);
              });
            }(e5), function(t4) {
              t4.focusTracker.on("change:isFocused", (e6, n4, i4) => {
                t4.isOpen && !i4 && (t4.isOpen = false);
              });
            }(e5), function(t4) {
              t4.keystrokes.set("arrowdown", (e6, n4) => {
                t4.isOpen && (t4.panelView.focus(), n4());
              }), t4.keystrokes.set("arrowup", (e6, n4) => {
                t4.isOpen && (t4.panelView.focusLast(), n4());
              });
            }(e5), function(t4) {
              t4.on("change:isOpen", (e6, n4, i4) => {
                if (i4)
                  return;
                const o4 = t4.panelView.element;
                o4 && o4.contains(Li2.document.activeElement) && t4.buttonView.focus();
              });
            }(e5), function(t4) {
              t4.on("change:isOpen", (e6, n4, i4) => {
                i4 && t4.panelView.focus();
              }, { priority: "low" });
            }(e5);
          }(r3), r3;
        }
        function rm(t4, e4, n3 = {}) {
          t4.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), t4.isOpen ? sm(t4, e4, n3) : t4.once("change:isOpen", () => sm(t4, e4, n3), { priority: "highest" }), n3.enableActiveItemFocusOnDropdownOpen && lm(t4, () => t4.toolbarView.items.find((t5) => t5.isOn));
        }
        function sm(t4, e4, n3) {
          const i3 = t4.locale, o3 = i3.t, r3 = t4.toolbarView = new jg2(i3), s3 = "function" == typeof e4 ? e4() : e4;
          r3.ariaLabel = n3.ariaLabel || o3("Dropdown toolbar"), n3.maxWidth && (r3.maxWidth = n3.maxWidth), n3.class && (r3.class = n3.class), n3.isCompact && (r3.isCompact = n3.isCompact), n3.isVertical && (r3.isVertical = true), s3 instanceof Ro2 ? r3.items.bindTo(s3).using((t5) => t5) : r3.items.addMany(s3), t4.panelView.children.add(r3), r3.items.delegate("execute").to(t4);
        }
        function am(t4, e4, n3 = {}) {
          t4.isOpen ? cm(t4, e4, n3) : t4.once("change:isOpen", () => cm(t4, e4, n3), { priority: "highest" }), lm(t4, () => t4.listView.items.find((t5) => t5 instanceof Zg2 && t5.children.first.isOn));
        }
        function cm(t4, e4, n3) {
          const i3 = t4.locale, o3 = t4.listView = new Kg2(i3), r3 = "function" == typeof e4 ? e4() : e4;
          o3.ariaLabel = n3.ariaLabel, o3.role = n3.role, dm(t4, o3.items, r3, i3), t4.panelView.children.add(o3), o3.items.delegate("execute").to(t4);
        }
        function lm(t4, e4) {
          t4.on("change:isOpen", () => {
            if (!t4.isOpen)
              return;
            const n3 = e4();
            n3 && ("function" == typeof n3.focus ? n3.focus() : _2("ui-dropdown-focus-child-on-open-child-missing-focus", { view: n3 }));
          }, { priority: b2.low - 10 });
        }
        function dm(t4, e4, n3, i3) {
          e4.bindTo(n3).using((e5) => {
            if ("separator" === e5.type)
              return new Yg2(i3);
            if ("group" === e5.type) {
              const n4 = new Wg2(i3);
              return n4.set({ label: e5.label }), dm(t4, n4.items, e5.items, i3), n4.items.delegate("execute").to(t4), n4;
            }
            if ("button" === e5.type || "switchbutton" === e5.type) {
              const t5 = new Zg2(i3);
              let n4;
              return "button" === e5.type ? (n4 = new kr(i3), n4.extendTemplate({ attributes: { "aria-checked": n4.bindTemplate.to("isOn") } })) : n4 = new Ar(i3), n4.bind(...Object.keys(e5.model)).to(e5.model), n4.delegate("execute").to(t5), t5.children.add(n4), t5;
            }
            return null;
          });
        }
        const hm = (t4, e4, n3) => {
          const i3 = new os(t4.locale);
          return i3.set({ id: e4, ariaDescribedById: n3 }), i3.bind("isReadOnly").to(t4, "isEnabled", (t5) => !t5), i3.bind("hasError").to(t4, "errorText", (t5) => !!t5), i3.on("input", () => {
            t4.errorText = null;
          }), t4.bind("isEmpty", "isFocused", "placeholder").to(i3), i3;
        }, um = (t4, e4, n3) => {
          const i3 = om(t4.locale);
          return i3.set({ id: e4, ariaDescribedById: n3 }), i3.bind("isEnabled").to(t4), i3;
        }, gm = (t4, e4 = 0, n3 = 1) => t4 > n3 ? n3 : t4 < e4 ? e4 : t4, mm = (t4, e4 = 0, n3 = Math.pow(10, e4)) => Math.round(n3 * t4) / n3, pm = (t4) => ("#" === t4[0] && (t4 = t4.substring(1)), t4.length < 6 ? { r: parseInt(t4[0] + t4[0], 16), g: parseInt(t4[1] + t4[1], 16), b: parseInt(t4[2] + t4[2], 16), a: 4 === t4.length ? mm(parseInt(t4[3] + t4[3], 16) / 255, 2) : 1 } : { r: parseInt(t4.substring(0, 2), 16), g: parseInt(t4.substring(2, 4), 16), b: parseInt(t4.substring(4, 6), 16), a: 8 === t4.length ? mm(parseInt(t4.substring(6, 8), 16) / 255, 2) : 1 }), fm = ({ h: t4, s: e4, v: n3, a: i3 }) => {
          const o3 = (200 - e4) * n3 / 100;
          return { h: mm(t4), s: mm(o3 > 0 && o3 < 200 ? e4 * n3 / 100 / (o3 <= 100 ? o3 : 200 - o3) * 100 : 0), l: mm(o3 / 2), a: mm(i3, 2) };
        }, km = (t4) => {
          const { h: e4, s: n3, l: i3 } = fm(t4);
          return `hsl(${e4}, ${n3}%, ${i3}%)`;
        }, bm = ({ h: t4, s: e4, v: n3, a: i3 }) => {
          t4 = t4 / 360 * 6, e4 /= 100, n3 /= 100;
          const o3 = Math.floor(t4), r3 = n3 * (1 - e4), s3 = n3 * (1 - (t4 - o3) * e4), a3 = n3 * (1 - (1 - t4 + o3) * e4), c3 = o3 % 6;
          return { r: mm(255 * [n3, s3, r3, r3, a3, n3][c3]), g: mm(255 * [a3, n3, n3, s3, r3, r3][c3]), b: mm(255 * [r3, r3, a3, n3, n3, s3][c3]), a: mm(i3, 2) };
        }, wm = (t4) => {
          const e4 = t4.toString(16);
          return e4.length < 2 ? "0" + e4 : e4;
        }, Am = ({ r: t4, g: e4, b: n3, a: i3 }) => {
          const o3 = i3 < 1 ? wm(mm(255 * i3)) : "";
          return "#" + wm(t4) + wm(e4) + wm(n3) + o3;
        }, Cm = ({ r: t4, g: e4, b: n3, a: i3 }) => {
          const o3 = Math.max(t4, e4, n3), r3 = o3 - Math.min(t4, e4, n3), s3 = r3 ? o3 === t4 ? (e4 - n3) / r3 : o3 === e4 ? 2 + (n3 - t4) / r3 : 4 + (t4 - e4) / r3 : 0;
          return { h: mm(60 * (s3 < 0 ? s3 + 6 : s3)), s: mm(o3 ? r3 / o3 * 100 : 0), v: mm(o3 / 255 * 100), a: i3 };
        }, _m = (t4, e4) => {
          if (t4 === e4)
            return true;
          for (const n3 in t4)
            if (t4[n3] !== e4[n3])
              return false;
          return true;
        }, vm = {}, ym = (t4) => {
          let e4 = vm[t4];
          return e4 || (e4 = document.createElement("template"), e4.innerHTML = t4, vm[t4] = e4), e4;
        }, xm = (t4, e4, n3) => {
          t4.dispatchEvent(new CustomEvent(e4, { bubbles: true, detail: n3 }));
        };
        let Em = false;
        const Dm = (t4) => "touches" in t4, Sm = (t4, e4) => {
          const n3 = Dm(e4) ? e4.touches[0] : e4, i3 = t4.el.getBoundingClientRect();
          xm(t4.el, "move", t4.getMove({ x: gm((n3.pageX - (i3.left + window.pageXOffset)) / i3.width), y: gm((n3.pageY - (i3.top + window.pageYOffset)) / i3.height) }));
        };
        class Tm {
          constructor(t4, e4, n3, i3) {
            const o3 = ym(`<div role="slider" tabindex="0" part="${e4}" ${n3}><div part="${e4}-pointer"></div></div>`);
            t4.appendChild(o3.content.cloneNode(true));
            const r3 = t4.querySelector(`[part=${e4}]`);
            r3.addEventListener("mousedown", this), r3.addEventListener("touchstart", this), r3.addEventListener("keydown", this), this.el = r3, this.xy = i3, this.nodes = [r3.firstChild, r3];
          }
          set dragging(t4) {
            const e4 = t4 ? document.addEventListener : document.removeEventListener;
            e4(Em ? "touchmove" : "mousemove", this), e4(Em ? "touchend" : "mouseup", this);
          }
          handleEvent(t4) {
            switch (t4.type) {
              case "mousedown":
              case "touchstart":
                if (t4.preventDefault(), !((t5) => !(Em && !Dm(t5) || (Em || (Em = Dm(t5)), 0)))(t4) || !Em && 0 != t4.button)
                  return;
                this.el.focus(), Sm(this, t4), this.dragging = true;
                break;
              case "mousemove":
              case "touchmove":
                t4.preventDefault(), Sm(this, t4);
                break;
              case "mouseup":
              case "touchend":
                this.dragging = false;
                break;
              case "keydown":
                ((t5, e4) => {
                  const n3 = e4.keyCode;
                  n3 > 40 || t5.xy && n3 < 37 || n3 < 33 || (e4.preventDefault(), xm(t5.el, "move", t5.getMove({ x: 39 === n3 ? 0.01 : 37 === n3 ? -0.01 : 34 === n3 ? 0.05 : 33 === n3 ? -0.05 : 35 === n3 ? 1 : 36 === n3 ? -1 : 0, y: 40 === n3 ? 0.01 : 38 === n3 ? -0.01 : 0 }, true)));
                })(this, t4);
            }
          }
          style(t4) {
            t4.forEach((t5, e4) => {
              for (const n3 in t5)
                this.nodes[e4].style.setProperty(n3, t5[n3]);
            });
          }
        }
        class Im extends Tm {
          constructor(t4) {
            super(t4, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
          }
          update({ h: t4 }) {
            this.h = t4, this.style([{ left: t4 / 360 * 100 + "%", color: km({ h: t4, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuenow", `${mm(t4)}`);
          }
          getMove(t4, e4) {
            return { h: e4 ? gm(this.h + 360 * t4.x, 0, 360) : 360 * t4.x };
          }
        }
        class Bm extends Tm {
          constructor(t4) {
            super(t4, "saturation", 'aria-label="Color"', true);
          }
          update(t4) {
            this.hsva = t4, this.style([{ top: 100 - t4.v + "%", left: `${t4.s}%`, color: km(t4) }, { "background-color": km({ h: t4.h, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuetext", `Saturation ${mm(t4.s)}%, Brightness ${mm(t4.v)}%`);
          }
          getMove(t4, e4) {
            return { s: e4 ? gm(this.hsva.s + 100 * t4.x, 0, 100) : 100 * t4.x, v: e4 ? gm(this.hsva.v - 100 * t4.y, 0, 100) : Math.round(100 - 100 * t4.y) };
          }
        }
        const Mm = Symbol("same"), Nm = Symbol("color"), Lm = Symbol("hsva"), zm = Symbol("update"), Pm = Symbol("parts"), Rm = Symbol("css"), Om = Symbol("sliders");
        class Fm extends HTMLElement {
          static get observedAttributes() {
            return ["color"];
          }
          get [Rm]() {
            return [':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}"];
          }
          get [Om]() {
            return [Bm, Im];
          }
          get color() {
            return this[Nm];
          }
          set color(t4) {
            if (!this[Mm](t4)) {
              const e4 = this.colorModel.toHsva(t4);
              this[zm](e4), this[Nm] = t4;
            }
          }
          constructor() {
            super();
            const t4 = ym(`<style>${this[Rm].join("")}</style>`), e4 = this.attachShadow({ mode: "open" });
            e4.appendChild(t4.content.cloneNode(true)), e4.addEventListener("move", this), this[Pm] = this[Om].map((t5) => new t5(e4));
          }
          connectedCallback() {
            if (this.hasOwnProperty("color")) {
              const t4 = this.color;
              delete this.color, this.color = t4;
            } else
              this.color || (this.color = this.colorModel.defaultColor);
          }
          attributeChangedCallback(t4, e4, n3) {
            const i3 = this.colorModel.fromAttr(n3);
            this[Mm](i3) || (this.color = i3);
          }
          handleEvent(t4) {
            const e4 = this[Lm], n3 = { ...e4, ...t4.detail };
            let i3;
            this[zm](n3), _m(n3, e4) || this[Mm](i3 = this.colorModel.fromHsva(n3)) || (this[Nm] = i3, xm(this, "color-changed", { value: i3 }));
          }
          [Mm](t4) {
            return this.color && this.colorModel.equal(t4, this.color);
          }
          [zm](t4) {
            this[Lm] = t4, this[Pm].forEach((e4) => e4.update(t4));
          }
        }
        const Vm = { defaultColor: "#000", toHsva: (t4) => Cm(pm(t4)), fromHsva: ({ h: t4, s: e4, v: n3 }) => Am(bm({ h: t4, s: e4, v: n3, a: 1 })), equal: (t4, e4) => t4.toLowerCase() === e4.toLowerCase() || _m(pm(t4), pm(e4)), fromAttr: (t4) => t4 };
        class jm extends Fm {
          get colorModel() {
            return Vm;
          }
        }
        customElements.define("hex-color-picker", class extends jm {
        });
        var Hm = n2(4257), Um = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Hm.Z, Um);
        Hm.Z.locals;
        class Gm extends Ho2 {
          constructor(t4, e4 = {}) {
            super(t4), this.set({ color: "", _hexColor: "" }), this.hexInputRow = this._createInputRow();
            const n3 = this.createCollection();
            e4.hideInput || n3.add(this.hexInputRow), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-picker"], tabindex: -1 }, children: n3 }), this._config = e4, this._debounceColorPickerEvent = $r((t5) => {
              this.set("color", t5), this.fire("colorSelected", { color: this.color });
            }, 150, { leading: true }), this.on("set:color", (t5, e5, n4) => {
              t5.return = Mr(n4, this._config.format || "hsl");
            }), this.on("change:color", () => {
              this._hexColor = Wm(this.color);
            }), this.on("change:_hexColor", () => {
              document.activeElement !== this.picker && this.picker.setAttribute("color", this._hexColor), Wm(this.color) != Wm(this._hexColor) && (this.color = this._hexColor);
            });
          }
          render() {
            if (super.render(), this.picker = Li2.document.createElement("hex-color-picker"), this.picker.setAttribute("class", "hex-color-picker"), this.picker.setAttribute("tabindex", "-1"), this._createSlidersView(), this.element) {
              this.hexInputRow.element ? this.element.insertBefore(this.picker, this.hexInputRow.element) : this.element.appendChild(this.picker);
              const t4 = document.createElement("style");
              t4.textContent = '[role="slider"]:focus [part$="pointer"] {border: 1px solid #fff;outline: 1px solid var(--ck-color-focus-border);box-shadow: 0 0 0 2px #fff;}', this.picker.shadowRoot.appendChild(t4);
            }
            this.picker.addEventListener("color-changed", (t4) => {
              const e4 = t4.detail.value;
              this._debounceColorPickerEvent(e4);
            });
          }
          focus() {
            if (!this._config.hideInput && (c2.isGecko || c2.isiOS || c2.isSafari)) {
              this.hexInputRow.children.get(1).focus();
            }
            this.slidersView.first.focus();
          }
          _createSlidersView() {
            const t4 = [...this.picker.shadowRoot.children].filter((t5) => "slider" === t5.getAttribute("role")).map((t5) => new qm(t5));
            this.slidersView = this.createCollection(), t4.forEach((t5) => {
              this.slidersView.add(t5);
            });
          }
          _createInputRow() {
            const t4 = new $m(), e4 = this._createColorInput();
            return new Km(this.locale, [t4, e4]);
          }
          _createColorInput() {
            const t4 = new Xr(this.locale, hm), { t: e4 } = this.locale;
            return t4.set({ label: e4("HEX"), class: "color-picker-hex-input" }), t4.fieldView.bind("value").to(this, "_hexColor", (e5) => t4.isFocused ? t4.fieldView.value : e5.startsWith("#") ? e5.substring(1) : e5), t4.fieldView.on("input", () => {
              const e5 = t4.fieldView.element.value;
              if (e5) {
                const t5 = e5.trim(), n3 = t5.startsWith("#") ? t5.substring(1) : t5;
                [3, 4, 6, 8].includes(n3.length) && /(([0-9a-fA-F]{2}){3,4}|([0-9a-fA-F]){3,4})/.test(n3) && this._debounceColorPickerEvent("#" + n3);
              }
            }), t4;
          }
        }
        function Wm(t4) {
          let e4 = function(t5) {
            if (!t5)
              return "";
            const e5 = Nr(t5);
            return e5 ? "hex" === e5.space ? e5.hexValue : Mr(t5, "hex") : "#000";
          }(t4);
          return e4 || (e4 = "#000"), 4 === e4.length && (e4 = "#" + [e4[1], e4[1], e4[2], e4[2], e4[3], e4[3]].join("")), e4.toLowerCase();
        }
        class qm extends Ho2 {
          constructor(t4) {
            super(), this.element = t4;
          }
          focus() {
            this.element.focus();
          }
        }
        class $m extends Ho2 {
          constructor(t4) {
            super(t4), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-picker__hash-view"] }, children: "#" });
          }
        }
        class Km extends Ho2 {
          constructor(t4, e4) {
            super(t4), this.children = this.createCollection(e4), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-picker__row"] }, children: this.children });
          }
        }
        class Zm extends q2(Do2) {
          constructor(t4) {
            super(t4), this.set("isEmpty", true), this.on("change", () => {
              this.set("isEmpty", 0 === this.length);
            });
          }
          add(t4, e4) {
            return this.find((e5) => e5.color === t4.color) ? this : super.add(t4, e4);
          }
          hasColor(t4) {
            return !!this.find((e4) => e4.color === t4);
          }
        }
        const Ym = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.209 18.717A8.5 8.5 0 1 1 18.686 9.6h-.008l.002.12a3 3 0 0 1-2.866 2.997h-.268l-.046-.002v.002h-4.791a2 2 0 1 0 0 4 1 1 0 1 1-.128 1.992 8.665 8.665 0 0 1-.372.008Zm-3.918-7.01a1.25 1.25 0 1 0-2.415-.648 1.25 1.25 0 0 0 2.415.647ZM5.723 8.18a1.25 1.25 0 1 0 .647-2.414 1.25 1.25 0 0 0-.647 2.414ZM9.76 6.155a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Zm4.028 1.759a1.25 1.25 0 1 0 .647-2.415 1.25 1.25 0 0 0-.647 2.415Z"/></svg>';
        class Qm extends Ho2 {
          constructor(t4, { colors: e4, columns: n3, removeButtonLabel: i3, documentColorsLabel: o3, documentColorsCount: r3, colorPickerLabel: s3, focusTracker: a3, focusables: c3 }) {
            super(t4);
            const l3 = this.bindTemplate;
            this.set("isVisible", true), this.focusTracker = a3, this.items = this.createCollection(), this.colorDefinitions = e4, this.columns = n3, this.documentColors = new Zm(), this.documentColorsCount = r3, this._focusables = c3, this._removeButtonLabel = i3, this._colorPickerLabel = s3, this._documentColorsLabel = o3, this.setTemplate({ tag: "div", attributes: { class: ["ck-color-grids-fragment", l3.if("isVisible", "ck-hidden", (t5) => !t5)] }, children: this.items }), this.removeColorButtonView = this._createRemoveColorButton(), this.items.add(this.removeColorButtonView);
          }
          updateDocumentColors(t4, e4) {
            const n3 = t4.document, i3 = this.documentColorsCount;
            this.documentColors.clear();
            for (const o3 of n3.getRoots()) {
              const n4 = t4.createRangeIn(o3);
              for (const t5 of n4.getItems())
                if (t5.is("$textProxy") && t5.hasAttribute(e4) && (this._addColorToDocumentColors(t5.getAttribute(e4)), this.documentColors.length >= i3))
                  return;
            }
          }
          updateSelectedColors() {
            const t4 = this.documentColorsGrid, e4 = this.staticColorsGrid, n3 = this.selectedColor;
            e4.selectedColor = n3, t4 && (t4.selectedColor = n3);
          }
          render() {
            if (super.render(), this.staticColorsGrid = this._createStaticColorsGrid(), this.items.add(this.staticColorsGrid), this.documentColorsCount) {
              const t4 = Uo2.bind(this.documentColors, this.documentColors), e4 = new Yr(this.locale);
              e4.text = this._documentColorsLabel, e4.extendTemplate({ attributes: { class: ["ck", "ck-color-grid__label", t4.if("isEmpty", "ck-hidden")] } }), this.items.add(e4), this.documentColorsGrid = this._createDocumentColorsGrid(), this.items.add(this.documentColorsGrid);
            }
            this._createColorPickerButton(), this._addColorSelectorElementsToFocusTracker(), this.focus();
          }
          focus() {
            this.removeColorButtonView.focus();
          }
          destroy() {
            super.destroy();
          }
          addColorPickerButton() {
            this.colorPickerButtonView && (this.items.add(this.colorPickerButtonView), this.focusTracker.add(this.colorPickerButtonView.element), this._focusables.add(this.colorPickerButtonView));
          }
          _addColorSelectorElementsToFocusTracker() {
            this.focusTracker.add(this.removeColorButtonView.element), this._focusables.add(this.removeColorButtonView), this.staticColorsGrid && (this.focusTracker.add(this.staticColorsGrid.element), this._focusables.add(this.staticColorsGrid)), this.documentColorsGrid && (this.focusTracker.add(this.documentColorsGrid.element), this._focusables.add(this.documentColorsGrid));
          }
          _createColorPickerButton() {
            this.colorPickerButtonView = new kr(), this.colorPickerButtonView.set({ label: this._colorPickerLabel, withText: true, icon: Ym, class: "ck-color-selector__color-picker" }), this.colorPickerButtonView.on("execute", () => {
              this.fire("colorPicker:show");
            });
          }
          _createRemoveColorButton() {
            const t4 = new kr();
            return t4.set({ withText: true, icon: zg2, label: this._removeButtonLabel }), t4.class = "ck-color-selector__remove-color", t4.on("execute", () => {
              this.fire("execute", { value: null, source: "removeColorButton" });
            }), t4.render(), t4;
          }
          _createStaticColorsGrid() {
            const t4 = new Dr(this.locale, { colorDefinitions: this.colorDefinitions, columns: this.columns });
            return t4.on("execute", (t5, e4) => {
              this.fire("execute", { value: e4.value, source: "staticColorsGrid" });
            }), t4;
          }
          _createDocumentColorsGrid() {
            const t4 = Uo2.bind(this.documentColors, this.documentColors), e4 = new Dr(this.locale, { columns: this.columns });
            return e4.extendTemplate({ attributes: { class: t4.if("isEmpty", "ck-hidden") } }), e4.items.bindTo(this.documentColors).using((t5) => {
              const e5 = new yr();
              return e5.set({ color: t5.color, hasBorder: t5.options && t5.options.hasBorder }), t5.label && e5.set({ label: t5.label, tooltip: true }), e5.on("execute", () => {
                this.fire("execute", { value: t5.color, source: "documentColorsGrid" });
              }), e5;
            }), this.documentColors.on("change:isEmpty", (t5, n3, i3) => {
              i3 && (e4.selectedColor = null);
            }), e4;
          }
          _addColorToDocumentColors(t4) {
            const e4 = this.colorDefinitions.find((e5) => e5.color === t4);
            e4 ? this.documentColors.add(Object.assign({}, e4)) : this.documentColors.add({ color: t4, label: t4, options: { hasBorder: false } });
          }
        }
        class Jm extends Ho2 {
          constructor(t4, { focusTracker: e4, focusables: n3, keystrokes: i3, colorPickerViewConfig: o3 }) {
            super(t4), this.items = this.createCollection(), this.focusTracker = e4, this.keystrokes = i3, this.set("isVisible", false), this.set("selectedColor", void 0), this._focusables = n3, this._colorPickerViewConfig = o3;
            const r3 = this.bindTemplate, { saveButtonView: s3, cancelButtonView: a3 } = this._createActionButtons();
            this.saveButtonView = s3, this.cancelButtonView = a3, this.actionBarView = this._createActionBarView({ saveButtonView: s3, cancelButtonView: a3 }), this.setTemplate({ tag: "div", attributes: { class: ["ck-color-picker-fragment", r3.if("isVisible", "ck-hidden", (t5) => !t5)] }, children: this.items });
          }
          render() {
            super.render();
            const t4 = new Gm(this.locale, { ...this._colorPickerViewConfig });
            this.colorPickerView = t4, this.colorPickerView.render(), this.selectedColor && (t4.color = this.selectedColor), this.listenTo(this, "change:selectedColor", (e4, n3, i3) => {
              t4.color = i3;
            }), this.items.add(this.colorPickerView), this.items.add(this.actionBarView), this._addColorPickersElementsToFocusTracker(), this._stopPropagationOnArrowsKeys(), this._executeOnEnterPress(), this._executeUponColorChange();
          }
          destroy() {
            super.destroy();
          }
          focus() {
            this.colorPickerView.focus();
          }
          _executeOnEnterPress() {
            this.keystrokes.set("enter", (t4) => {
              this.isVisible && this.focusTracker.focusedElement !== this.cancelButtonView.element && (this.fire("execute", { value: this.selectedColor }), t4.stopPropagation(), t4.preventDefault());
            });
          }
          _stopPropagationOnArrowsKeys() {
            const t4 = (t5) => t5.stopPropagation();
            this.keystrokes.set("arrowright", t4), this.keystrokes.set("arrowleft", t4), this.keystrokes.set("arrowup", t4), this.keystrokes.set("arrowdown", t4);
          }
          _addColorPickersElementsToFocusTracker() {
            for (const t5 of this.colorPickerView.slidersView)
              this.focusTracker.add(t5.element), this._focusables.add(t5);
            const t4 = this.colorPickerView.hexInputRow.children.get(1);
            t4.element && (this.focusTracker.add(t4.element), this._focusables.add(t4)), this.focusTracker.add(this.saveButtonView.element), this._focusables.add(this.saveButtonView), this.focusTracker.add(this.cancelButtonView.element), this._focusables.add(this.cancelButtonView);
          }
          _createActionBarView({ saveButtonView: t4, cancelButtonView: e4 }) {
            const n3 = new Ho2(), i3 = this.createCollection();
            return i3.add(t4), i3.add(e4), n3.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-selector_action-bar"] }, children: i3 }), n3;
          }
          _createActionButtons() {
            const t4 = this.locale, e4 = t4.t, n3 = new kr(t4), i3 = new kr(t4);
            return n3.set({ icon: Lg2, class: "ck-button-save", type: "button", withText: false, label: e4("Accept") }), i3.set({ icon: Ng2, class: "ck-button-cancel", type: "button", withText: false, label: e4("Cancel") }), n3.on("execute", () => {
              this.fire("execute", { source: "colorPickerSaveButton", value: this.selectedColor });
            }), i3.on("execute", () => {
              this.fire("colorPicker:cancel");
            }), { saveButtonView: n3, cancelButtonView: i3 };
          }
          _executeUponColorChange() {
            this.colorPickerView.on("colorSelected", (t4, e4) => {
              this.fire("execute", { value: e4.color, source: "colorPicker" }), this.set("selectedColor", e4.color);
            });
          }
        }
        var Xm = n2(6306), tp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Xm.Z, tp);
        Xm.Z.locals;
        class ep extends Ho2 {
          constructor(t4, { colors: e4, columns: n3, removeButtonLabel: i3, documentColorsLabel: o3, documentColorsCount: r3, colorPickerLabel: s3, colorPickerViewConfig: a3 }) {
            super(t4), this.items = this.createCollection(), this.focusTracker = new To2(), this.keystrokes = new Io2(), this._focusables = new Ro2(), this._colorPickerViewConfig = a3, this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.colorGridsFragmentView = new Qm(t4, { colors: e4, columns: n3, removeButtonLabel: i3, documentColorsLabel: o3, documentColorsCount: r3, colorPickerLabel: s3, focusTracker: this.focusTracker, focusables: this._focusables }), this.colorPickerFragmentView = new Jm(t4, { focusables: this._focusables, focusTracker: this.focusTracker, keystrokes: this.keystrokes, colorPickerViewConfig: a3 }), this.set("_isColorGridsFragmentVisible", true), this.set("_isColorPickerFragmentVisible", false), this.set("selectedColor", void 0), this.colorGridsFragmentView.bind("isVisible").to(this, "_isColorGridsFragmentVisible"), this.colorPickerFragmentView.bind("isVisible").to(this, "_isColorPickerFragmentVisible"), this.on("change:selectedColor", (t5, e5, n4) => {
              this.colorGridsFragmentView.set("selectedColor", n4), this.colorPickerFragmentView.set("selectedColor", n4);
            }), this.colorGridsFragmentView.on("change:selectedColor", (t5, e5, n4) => {
              this.set("selectedColor", n4);
            }), this.colorPickerFragmentView.on("change:selectedColor", (t5, e5, n4) => {
              this.set("selectedColor", n4);
            }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-color-selector"] }, children: this.items });
          }
          render() {
            super.render(), this.keystrokes.listenTo(this.element);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          appendUI() {
            this._appendColorGridsFragment(), this._colorPickerViewConfig && this._appendColorPickerFragment();
          }
          showColorPickerFragment() {
            this.colorPickerFragmentView.colorPickerView && !this._isColorPickerFragmentVisible && (this._isColorPickerFragmentVisible = true, this.colorPickerFragmentView.focus(), this._isColorGridsFragmentVisible = false);
          }
          showColorGridsFragment() {
            this._isColorGridsFragmentVisible || (this._isColorGridsFragmentVisible = true, this.colorGridsFragmentView.focus(), this._isColorPickerFragmentVisible = false);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
          updateDocumentColors(t4, e4) {
            this.colorGridsFragmentView.updateDocumentColors(t4, e4);
          }
          updateSelectedColors() {
            this.colorGridsFragmentView.updateSelectedColors();
          }
          _appendColorGridsFragment() {
            this.items.length || (this.items.add(this.colorGridsFragmentView), this.colorGridsFragmentView.delegate("execute").to(this), this.colorGridsFragmentView.delegate("colorPicker:show").to(this));
          }
          _appendColorPickerFragment() {
            2 !== this.items.length && (this.items.add(this.colorPickerFragmentView), this.colorGridsFragmentView.colorPickerButtonView && this.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
              this.showColorPickerFragment();
            }), this.colorGridsFragmentView.addColorPickerButton(), this.colorPickerFragmentView.delegate("execute").to(this), this.colorPickerFragmentView.delegate("colorPicker:cancel").to(this));
          }
        }
        class np {
          constructor(t4) {
            this._components = /* @__PURE__ */ new Map(), this.editor = t4;
          }
          *names() {
            for (const t4 of this._components.values())
              yield t4.originalName;
          }
          add(t4, e4) {
            this._components.set(ip(t4), { callback: e4, originalName: t4 });
          }
          create(t4) {
            if (!this.has(t4))
              throw new C2("componentfactory-item-missing", this, { name: t4 });
            return this._components.get(ip(t4)).callback(this.editor.locale);
          }
          has(t4) {
            return this._components.has(ip(t4));
          }
        }
        function ip(t4) {
          return String(t4).toLowerCase();
        }
        var op = n2(4460), rp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(op.Z, rp);
        op.Z.locals;
        const sp = $i2("px"), ap = Li2.document.body, cp = { top: -99999, left: -99999, name: "arrowless", config: { withArrow: false } };
        class lp extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", false), this.set("withArrow", true), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e4.to("position", (t5) => `ck-balloon-panel_${t5}`), e4.if("isVisible", "ck-balloon-panel_visible"), e4.if("withArrow", "ck-balloon-panel_with-arrow"), e4.to("class")], style: { top: e4.to("top", sp), left: e4.to("left", sp) } }, children: this.content });
          }
          show() {
            this.isVisible = true;
          }
          hide() {
            this.isVisible = false;
          }
          attachTo(t4) {
            this.show();
            const e4 = lp.defaultPositions, n3 = Object.assign({}, { element: this.element, positions: [e4.southArrowNorth, e4.southArrowNorthMiddleWest, e4.southArrowNorthMiddleEast, e4.southArrowNorthWest, e4.southArrowNorthEast, e4.northArrowSouth, e4.northArrowSouthMiddleWest, e4.northArrowSouthMiddleEast, e4.northArrowSouthWest, e4.northArrowSouthEast, e4.viewportStickyNorth], limiter: ap, fitInViewport: true }, t4), i3 = lp._getOptimalPosition(n3) || cp, o3 = parseInt(i3.left), r3 = parseInt(i3.top), s3 = i3.name, a3 = i3.config || {}, { withArrow: c3 = true } = a3;
            this.top = r3, this.left = o3, this.position = s3, this.withArrow = c3;
          }
          pin(t4) {
            this.unpin(), this._pinWhenIsVisibleCallback = () => {
              this.isVisible ? this._startPinning(t4) : this._stopPinning();
            }, this._startPinning(t4), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
          }
          unpin() {
            this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
          }
          _startPinning(t4) {
            this.attachTo(t4);
            const e4 = dp(t4.target), n3 = t4.limiter ? dp(t4.limiter) : ap;
            this.listenTo(Li2.document, "scroll", (i3, o3) => {
              const r3 = o3.target, s3 = e4 && r3.contains(e4), a3 = n3 && r3.contains(n3);
              !s3 && !a3 && e4 && n3 || this.attachTo(t4);
            }, { useCapture: true }), this.listenTo(Li2.window, "resize", () => {
              this.attachTo(t4);
            });
          }
          _stopPinning() {
            this.stopListening(Li2.document, "scroll"), this.stopListening(Li2.window, "resize");
          }
        }
        function dp(t4) {
          return vi2(t4) ? t4 : Pi2(t4) ? t4.commonAncestorContainer : "function" == typeof t4 ? dp(t4()) : null;
        }
        function hp(t4 = {}) {
          const { sideOffset: e4 = lp.arrowSideOffset, heightOffset: n3 = lp.arrowHeightOffset, stickyVerticalOffset: i3 = lp.stickyVerticalOffset, config: o3 } = t4;
          return { northWestArrowSouthWest: (t5, n4) => ({ top: r3(t5, n4), left: t5.left - e4, name: "arrow_sw", ...o3 && { config: o3 } }), northWestArrowSouthMiddleWest: (t5, n4) => ({ top: r3(t5, n4), left: t5.left - 0.25 * n4.width - e4, name: "arrow_smw", ...o3 && { config: o3 } }), northWestArrowSouth: (t5, e5) => ({ top: r3(t5, e5), left: t5.left - e5.width / 2, name: "arrow_s", ...o3 && { config: o3 } }), northWestArrowSouthMiddleEast: (t5, n4) => ({ top: r3(t5, n4), left: t5.left - 0.75 * n4.width + e4, name: "arrow_sme", ...o3 && { config: o3 } }), northWestArrowSouthEast: (t5, n4) => ({ top: r3(t5, n4), left: t5.left - n4.width + e4, name: "arrow_se", ...o3 && { config: o3 } }), northArrowSouthWest: (t5, n4) => ({ top: r3(t5, n4), left: t5.left + t5.width / 2 - e4, name: "arrow_sw", ...o3 && { config: o3 } }), northArrowSouthMiddleWest: (t5, n4) => ({ top: r3(t5, n4), left: t5.left + t5.width / 2 - 0.25 * n4.width - e4, name: "arrow_smw", ...o3 && { config: o3 } }), northArrowSouth: (t5, e5) => ({ top: r3(t5, e5), left: t5.left + t5.width / 2 - e5.width / 2, name: "arrow_s", ...o3 && { config: o3 } }), northArrowSouthMiddleEast: (t5, n4) => ({ top: r3(t5, n4), left: t5.left + t5.width / 2 - 0.75 * n4.width + e4, name: "arrow_sme", ...o3 && { config: o3 } }), northArrowSouthEast: (t5, n4) => ({ top: r3(t5, n4), left: t5.left + t5.width / 2 - n4.width + e4, name: "arrow_se", ...o3 && { config: o3 } }), northEastArrowSouthWest: (t5, n4) => ({ top: r3(t5, n4), left: t5.right - e4, name: "arrow_sw", ...o3 && { config: o3 } }), northEastArrowSouthMiddleWest: (t5, n4) => ({ top: r3(t5, n4), left: t5.right - 0.25 * n4.width - e4, name: "arrow_smw", ...o3 && { config: o3 } }), northEastArrowSouth: (t5, e5) => ({ top: r3(t5, e5), left: t5.right - e5.width / 2, name: "arrow_s", ...o3 && { config: o3 } }), northEastArrowSouthMiddleEast: (t5, n4) => ({ top: r3(t5, n4), left: t5.right - 0.75 * n4.width + e4, name: "arrow_sme", ...o3 && { config: o3 } }), northEastArrowSouthEast: (t5, n4) => ({ top: r3(t5, n4), left: t5.right - n4.width + e4, name: "arrow_se", ...o3 && { config: o3 } }), southWestArrowNorthWest: (t5) => ({ top: s3(t5), left: t5.left - e4, name: "arrow_nw", ...o3 && { config: o3 } }), southWestArrowNorthMiddleWest: (t5, n4) => ({ top: s3(t5), left: t5.left - 0.25 * n4.width - e4, name: "arrow_nmw", ...o3 && { config: o3 } }), southWestArrowNorth: (t5, e5) => ({ top: s3(t5), left: t5.left - e5.width / 2, name: "arrow_n", ...o3 && { config: o3 } }), southWestArrowNorthMiddleEast: (t5, n4) => ({ top: s3(t5), left: t5.left - 0.75 * n4.width + e4, name: "arrow_nme", ...o3 && { config: o3 } }), southWestArrowNorthEast: (t5, n4) => ({ top: s3(t5), left: t5.left - n4.width + e4, name: "arrow_ne", ...o3 && { config: o3 } }), southArrowNorthWest: (t5) => ({ top: s3(t5), left: t5.left + t5.width / 2 - e4, name: "arrow_nw", ...o3 && { config: o3 } }), southArrowNorthMiddleWest: (t5, n4) => ({ top: s3(t5), left: t5.left + t5.width / 2 - 0.25 * n4.width - e4, name: "arrow_nmw", ...o3 && { config: o3 } }), southArrowNorth: (t5, e5) => ({ top: s3(t5), left: t5.left + t5.width / 2 - e5.width / 2, name: "arrow_n", ...o3 && { config: o3 } }), southArrowNorthMiddleEast: (t5, n4) => ({ top: s3(t5), left: t5.left + t5.width / 2 - 0.75 * n4.width + e4, name: "arrow_nme", ...o3 && { config: o3 } }), southArrowNorthEast: (t5, n4) => ({ top: s3(t5), left: t5.left + t5.width / 2 - n4.width + e4, name: "arrow_ne", ...o3 && { config: o3 } }), southEastArrowNorthWest: (t5) => ({ top: s3(t5), left: t5.right - e4, name: "arrow_nw", ...o3 && { config: o3 } }), southEastArrowNorthMiddleWest: (t5, n4) => ({ top: s3(t5), left: t5.right - 0.25 * n4.width - e4, name: "arrow_nmw", ...o3 && { config: o3 } }), southEastArrowNorth: (t5, e5) => ({ top: s3(t5), left: t5.right - e5.width / 2, name: "arrow_n", ...o3 && { config: o3 } }), southEastArrowNorthMiddleEast: (t5, n4) => ({ top: s3(t5), left: t5.right - 0.75 * n4.width + e4, name: "arrow_nme", ...o3 && { config: o3 } }), southEastArrowNorthEast: (t5, n4) => ({ top: s3(t5), left: t5.right - n4.width + e4, name: "arrow_ne", ...o3 && { config: o3 } }), westArrowEast: (t5, e5) => ({ top: t5.top + t5.height / 2 - e5.height / 2, left: t5.left - e5.width - n3, name: "arrow_e", ...o3 && { config: o3 } }), eastArrowWest: (t5, e5) => ({ top: t5.top + t5.height / 2 - e5.height / 2, left: t5.right + n3, name: "arrow_w", ...o3 && { config: o3 } }), viewportStickyNorth: (t5, e5, n4, r4) => {
            const s4 = r4 || n4;
            return t5.getIntersection(s4) ? s4.height - t5.height > i3 ? null : { top: s4.top + i3, left: t5.left + t5.width / 2 - e5.width / 2, name: "arrowless", config: { withArrow: false, ...o3 } } : null;
          } };
          function r3(t5, e5) {
            return t5.top - e5.height - n3;
          }
          function s3(t5) {
            return t5.bottom + n3;
          }
        }
        lp.arrowSideOffset = 25, lp.arrowHeightOffset = 10, lp.stickyVerticalOffset = 20, lp._getOptimalPosition = Xi2, lp.defaultPositions = hp();
        var up = n2(3888), gp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(up.Z, gp);
        up.Z.locals;
        const mp = "ck-tooltip";
        class pp extends Ii2() {
          constructor(t4) {
            if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, pp._editors.add(t4), pp._instance)
              return pp._instance;
            pp._instance = this, this.tooltipTextView = new Ho2(t4.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: this.tooltipTextView.bindTemplate.to("text") }] }), this.balloonPanelView = new lp(t4.locale), this.balloonPanelView.class = mp, this.balloonPanelView.content.add(this.tooltipTextView), this._pinTooltipDebounced = $r(this._pinTooltip, 600), this.listenTo(Li2.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: true }), this.listenTo(Li2.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: true }), this.listenTo(Li2.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: true }), this.listenTo(Li2.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true }), this.listenTo(Li2.document, "scroll", this._onScroll.bind(this), { useCapture: true }), this._watchdogExcluded = true;
          }
          destroy(t4) {
            const e4 = t4.ui.view && t4.ui.view.body;
            pp._editors.delete(t4), this.stopListening(t4.ui), e4 && e4.has(this.balloonPanelView) && e4.remove(this.balloonPanelView), pp._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), pp._instance = null);
          }
          static getPositioningFunctions(t4) {
            const e4 = pp.defaultBalloonPositions;
            return { s: [e4.southArrowNorth, e4.southArrowNorthEast, e4.southArrowNorthWest], n: [e4.northArrowSouth], e: [e4.eastArrowWest], w: [e4.westArrowEast], sw: [e4.southArrowNorthEast], se: [e4.southArrowNorthWest] }[t4];
          }
          _onEnterOrFocus(t4, { target: e4 }) {
            const n3 = fp(e4);
            var i3;
            n3 && (n3 !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(n3, { text: (i3 = n3).dataset.ckeTooltipText, position: i3.dataset.ckeTooltipPosition || "s", cssClass: i3.dataset.ckeTooltipClass || "" })));
          }
          _onLeaveOrBlur(t4, { target: e4, relatedTarget: n3 }) {
            if ("mouseleave" === t4.name) {
              if (!vi2(e4))
                return;
              if (this._currentElementWithTooltip && e4 !== this._currentElementWithTooltip)
                return;
              const t5 = fp(e4), i3 = fp(n3);
              t5 && t5 !== i3 && this._unpinTooltip();
            } else {
              if (this._currentElementWithTooltip && e4 !== this._currentElementWithTooltip)
                return;
              this._unpinTooltip();
            }
          }
          _onScroll(t4, { target: e4 }) {
            this._currentElementWithTooltip && (e4.contains(this.balloonPanelView.element) && e4.contains(this._currentElementWithTooltip) || this._unpinTooltip());
          }
          _pinTooltip(t4, { text: e4, position: n3, cssClass: i3 }) {
            const o3 = So2(pp._editors.values()).ui.view.body;
            o3.has(this.balloonPanelView) || o3.add(this.balloonPanelView), this.tooltipTextView.text = e4, this.balloonPanelView.pin({ target: t4, positions: pp.getPositioningFunctions(n3) }), this._resizeObserver = new Wi2(t4, () => {
              Ji2(t4) || this._unpinTooltip();
            }), this.balloonPanelView.class = [mp, i3].filter((t5) => t5).join(" ");
            for (const t5 of pp._editors)
              this.listenTo(t5.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
            this._currentElementWithTooltip = t4, this._currentTooltipPosition = n3;
          }
          _unpinTooltip() {
            this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
            for (const t4 of pp._editors)
              this.stopListening(t4.ui, "update");
            this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy();
          }
          _updateTooltipPosition() {
            Ji2(this._currentElementWithTooltip) ? this.balloonPanelView.pin({ target: this._currentElementWithTooltip, positions: pp.getPositioningFunctions(this._currentTooltipPosition) }) : this._unpinTooltip();
          }
        }
        function fp(t4) {
          return vi2(t4) ? t4.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
        }
        pp.defaultBalloonPositions = hp({ heightOffset: 5, sideOffset: 13 }), pp._editors = /* @__PURE__ */ new Set(), pp._instance = null;
        const kp = function(t4, e4, n3) {
          var i3 = true, o3 = true;
          if ("function" != typeof t4)
            throw new TypeError("Expected a function");
          return F2(n3) && (i3 = "leading" in n3 ? !!n3.leading : i3, o3 = "trailing" in n3 ? !!n3.trailing : o3), $r(t4, e4, { leading: i3, maxWait: e4, trailing: o3 });
        }, bp = 50, wp = 350, Ap = "Powered by";
        class Cp extends Ii2() {
          constructor(t4) {
            super(), this.editor = t4, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = kp(this._showBalloon.bind(this), 50, { leading: true }), t4.on("ready", this._handleEditorReady.bind(this));
          }
          destroy() {
            const t4 = this._balloonView;
            t4 && (t4.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening();
          }
          _handleEditorReady() {
            const t4 = this.editor;
            (!!t4.config.get("ui.poweredBy.forceVisible") || "VALID" !== function(t5) {
              function e4(t6) {
                return t6.length >= 40 && t6.length <= 255 ? "VALID" : "INVALID";
              }
              if (!t5)
                return "INVALID";
              let n3 = "";
              try {
                n3 = atob(t5);
              } catch (t6) {
                return "INVALID";
              }
              const i3 = n3.split("-"), o3 = i3[0], r3 = i3[1];
              if (!r3)
                return e4(t5);
              try {
                atob(r3);
              } catch (n4) {
                try {
                  if (atob(o3), !atob(o3).length)
                    return e4(t5);
                } catch (n5) {
                  return e4(t5);
                }
              }
              if (o3.length < 40 || o3.length > 255)
                return "INVALID";
              let s3 = "";
              try {
                atob(o3), s3 = atob(r3);
              } catch (t6) {
                return "INVALID";
              }
              if (8 !== s3.length)
                return "INVALID";
              const a3 = Number(s3.substring(0, 4)), c3 = Number(s3.substring(4, 6)) - 1, l3 = Number(s3.substring(6, 8)), d3 = new Date(a3, c3, l3);
              return d3 < E2 || isNaN(Number(d3)) ? "INVALID" : "VALID";
            }(t4.config.get("licenseKey"))) && t4.ui.view && (t4.ui.focusTracker.on("change:isFocused", (t5, e4, n3) => {
              this._updateLastFocusedEditableElement(), n3 ? this._showBalloon() : this._hideBalloon();
            }), t4.ui.focusTracker.on("change:focusedElement", (t5, e4, n3) => {
              this._updateLastFocusedEditableElement(), n3 && this._showBalloon();
            }), t4.ui.on("update", () => {
              this._showBalloonThrottled();
            }));
          }
          _createBalloonView() {
            const t4 = this.editor, e4 = this._balloonView = new lp(), n3 = yp(t4), i3 = new _p(t4.locale, n3.label);
            e4.content.add(i3), e4.set({ class: "ck-powered-by-balloon" }), t4.ui.view.body.add(e4), t4.ui.focusTracker.add(e4.element), this._balloonView = e4;
          }
          _showBalloon() {
            if (!this._lastFocusedEditableElement)
              return;
            const t4 = function(t5, e4) {
              const n3 = yp(t5), i3 = "right" === n3.side ? function(t6, e5) {
                return vp(t6, e5, (t7, n4) => t7.left + t7.width - n4.width - e5.horizontalOffset);
              }(e4, n3) : function(t6, e5) {
                return vp(t6, e5, (t7) => t7.left + e5.horizontalOffset);
              }(e4, n3);
              return { target: e4, positions: [i3] };
            }(this.editor, this._lastFocusedEditableElement);
            t4 && (this._balloonView || this._createBalloonView(), this._balloonView.pin(t4));
          }
          _hideBalloon() {
            this._balloonView && this._balloonView.unpin();
          }
          _updateLastFocusedEditableElement() {
            const t4 = this.editor, e4 = t4.ui.focusTracker.isFocused, n3 = t4.ui.focusTracker.focusedElement;
            if (!e4 || !n3)
              return void (this._lastFocusedEditableElement = null);
            const i3 = Array.from(t4.ui.getEditableElementsNames()).map((e5) => t4.ui.getEditableElement(e5));
            i3.includes(n3) ? this._lastFocusedEditableElement = n3 : this._lastFocusedEditableElement = i3[0];
          }
        }
        class _p extends Ho2 {
          constructor(t4, e4) {
            super(t4);
            const n3 = new gr(), i3 = this.bindTemplate;
            n3.set({ content: '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n', isColorInherited: false }), n3.extendTemplate({ attributes: { style: { width: "53px", height: "10px" } } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-powered-by"], "aria-hidden": true }, children: [{ tag: "a", attributes: { href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo", target: "_blank", tabindex: "-1" }, children: [...e4 ? [{ tag: "span", attributes: { class: ["ck", "ck-powered-by__label"] }, children: [e4] }] : [], n3], on: { dragstart: i3.to((t5) => t5.preventDefault()) } }] });
          }
        }
        function vp(t4, e4, n3) {
          return (i3, o3) => {
            const r3 = new Vi2(t4);
            if (r3.width < wp || r3.height < bp)
              return null;
            let s3;
            s3 = "inside" === e4.position ? r3.bottom - o3.height : r3.bottom - o3.height / 2, s3 -= e4.verticalOffset;
            const a3 = n3(r3, o3), c3 = i3.clone().moveTo(a3, s3).getIntersection(o3.clone().moveTo(a3, s3)).getVisible();
            return !c3 || c3.getArea() < o3.getArea() ? null : { top: s3, left: a3, name: `position_${e4.position}-side_${e4.side}`, config: { withArrow: false } };
          };
        }
        function yp(t4) {
          const e4 = t4.config.get("ui.poweredBy"), n3 = e4 && e4.position || "border";
          return { position: n3, label: Ap, verticalOffset: "inside" === n3 ? 5 : 0, horizontalOffset: 5, side: "ltr" === t4.locale.contentLanguageDirection ? "right" : "left", ...e4 };
        }
        var xp = n2(3290), Ep = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(xp.Z, Ep);
        xp.Z.locals;
        var Dp;
        !function(t4) {
          t4.POLITE = "polite", t4.ASSERTIVE = "assertive";
        }(Dp || (Dp = {}));
        class Sp {
          constructor(t4) {
            this.editor = t4;
          }
          announce(t4, e4, n3 = Dp.POLITE) {
            const i3 = this.editor;
            this.view || (this.view = new Tp(i3.locale), i3.ui.view.body.add(this.view));
            let o3 = this.view.regionViews.find((e5) => e5.regionName === t4);
            o3 || (o3 = new Ip(this.view.locale), this.view.regionViews.add(o3)), o3.set({ regionName: t4, text: e4, politeness: n3 });
          }
        }
        class Tp extends Ho2 {
          constructor(t4) {
            super(t4), this.regionViews = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-aria-live-announcer"] }, children: this.regionViews });
          }
        }
        class Ip extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.set("regionName", ""), this.set("text", ""), this.set("politeness", Dp.POLITE), this.setTemplate({ tag: "div", attributes: { role: "region", "data-region": e4.to("regionName"), "aria-live": e4.to("politeness") }, children: [{ text: e4.to("text") }] });
          }
        }
        class Bp extends q2() {
          constructor(t4) {
            super(), this.isReady = false, this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
            const e4 = t4.editing.view;
            this.editor = t4, this.componentFactory = new np(t4), this.focusTracker = new To2(), this.tooltipManager = new pp(t4), this.poweredBy = new Cp(t4), this.ariaLiveAnnouncer = new Sp(t4), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
              this.isReady = true;
            }), this.listenTo(e4.document, "layoutChanged", this.update.bind(this)), this.listenTo(e4, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)), this._initFocusTracking();
          }
          get element() {
            return null;
          }
          update() {
            this.fire("update");
          }
          destroy() {
            this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
            for (const t4 of this._editableElementsMap.values())
              t4.ckeditorInstance = null, this.editor.keystrokes.stopListening(t4);
            this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
          }
          setEditableElement(t4, e4) {
            this._editableElementsMap.set(t4, e4), e4.ckeditorInstance || (e4.ckeditorInstance = this.editor), this.focusTracker.add(e4);
            const n3 = () => {
              this.editor.editing.view.getDomRoot(t4) || this.editor.keystrokes.listenTo(e4);
            };
            this.isReady ? n3() : this.once("ready", n3);
          }
          removeEditableElement(t4) {
            const e4 = this._editableElementsMap.get(t4);
            e4 && (this._editableElementsMap.delete(t4), this.editor.keystrokes.stopListening(e4), this.focusTracker.remove(e4), e4.ckeditorInstance = null);
          }
          getEditableElement(t4 = "main") {
            return this._editableElementsMap.get(t4);
          }
          getEditableElementsNames() {
            return this._editableElementsMap.keys();
          }
          addToolbar(t4, e4 = {}) {
            t4.isRendered ? (this.focusTracker.add(t4.element), this.editor.keystrokes.listenTo(t4.element)) : t4.once("render", () => {
              this.focusTracker.add(t4.element), this.editor.keystrokes.listenTo(t4.element);
            }), this._focusableToolbarDefinitions.push({ toolbarView: t4, options: e4 });
          }
          get _editableElements() {
            return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
          }
          _readViewportOffsetFromConfig() {
            const t4 = this.editor, e4 = t4.config.get("ui.viewportOffset");
            if (e4)
              return e4;
            const n3 = t4.config.get("toolbar.viewportTopOffset");
            return n3 ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: n3 }) : { top: 0 };
          }
          _initFocusTracking() {
            const t4 = this.editor, e4 = t4.editing.view;
            let n3, i3;
            t4.keystrokes.set("Alt+F10", (t5, o3) => {
              const r3 = this.focusTracker.focusedElement;
              Array.from(this._editableElementsMap.values()).includes(r3) && !Array.from(e4.domRoots.values()).includes(r3) && (n3 = r3);
              const s3 = this._getCurrentFocusedToolbarDefinition();
              s3 && i3 || (i3 = this._getFocusableCandidateToolbarDefinitions());
              for (let t6 = 0; t6 < i3.length; t6++) {
                const t7 = i3.shift();
                if (i3.push(t7), t7 !== s3 && this._focusFocusableCandidateToolbar(t7)) {
                  s3 && s3.options.afterBlur && s3.options.afterBlur();
                  break;
                }
              }
              o3();
            }), t4.keystrokes.set("Esc", (e5, i4) => {
              const o3 = this._getCurrentFocusedToolbarDefinition();
              o3 && (n3 ? (n3.focus(), n3 = null) : t4.editing.view.focus(), o3.options.afterBlur && o3.options.afterBlur(), i4());
            });
          }
          _getFocusableCandidateToolbarDefinitions() {
            const t4 = [];
            for (const e4 of this._focusableToolbarDefinitions) {
              const { toolbarView: n3, options: i3 } = e4;
              (Ji2(n3.element) || i3.beforeFocus) && t4.push(e4);
            }
            return t4.sort((t5, e4) => Mp(t5) - Mp(e4)), t4;
          }
          _getCurrentFocusedToolbarDefinition() {
            for (const t4 of this._focusableToolbarDefinitions)
              if (t4.toolbarView.element && t4.toolbarView.element.contains(this.focusTracker.focusedElement))
                return t4;
            return null;
          }
          _focusFocusableCandidateToolbar(t4) {
            const { toolbarView: e4, options: { beforeFocus: n3 } } = t4;
            return n3 && n3(), !!Ji2(e4.element) && (e4.focus(), true);
          }
          _handleScrollToTheSelection(t4, e4) {
            const n3 = { top: 0, bottom: 0, left: 0, right: 0, ...this.viewportOffset };
            e4.viewportOffset.top += n3.top, e4.viewportOffset.bottom += n3.bottom, e4.viewportOffset.left += n3.left, e4.viewportOffset.right += n3.right;
          }
        }
        function Mp(t4) {
          const { toolbarView: e4, options: n3 } = t4;
          let i3 = 10;
          return Ji2(e4.element) && i3--, n3.isContextual && i3--, i3;
        }
        var Np = n2(9847), Lp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Np.Z, Lp);
        Np.Z.locals;
        class zp extends Ho2 {
          constructor(t4) {
            super(t4), this.body = new dr(t4);
          }
          render() {
            super.render(), this.body.attachToDom();
          }
          destroy() {
            return this.body.detachFromDom(), super.destroy();
          }
        }
        class Pp extends zp {
          constructor(t4) {
            super(t4), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: t4.uiLanguageDirection, lang: t4.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] });
          }
          _createVoiceLabel() {
            const t4 = this.t, e4 = new Yr();
            return e4.text = t4("Rich Text Editor"), e4.extendTemplate({ attributes: { class: "ck-voice-label" } }), e4;
          }
        }
        class Rp extends Ho2 {
          constructor(t4, e4, n3) {
            super(t4), this.name = null, this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: t4.contentLanguage, dir: t4.contentLanguageDirection } }), this.set("isFocused", false), this._editableElement = n3, this._hasExternalElement = !!this._editableElement, this._editingView = e4;
          }
          render() {
            super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
          }
          destroy() {
            this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
          }
          get hasExternalElement() {
            return this._hasExternalElement;
          }
          _updateIsFocusedClasses() {
            const t4 = this._editingView;
            function e4(e5) {
              t4.change((n3) => {
                const i3 = t4.document.getRoot(e5.name);
                n3.addClass(e5.isFocused ? "ck-focused" : "ck-blurred", i3), n3.removeClass(e5.isFocused ? "ck-blurred" : "ck-focused", i3);
              });
            }
            t4.isRenderingInProgress ? function n3(i3) {
              t4.once("change:isRenderingInProgress", (t5, o3, r3) => {
                r3 ? n3(i3) : e4(i3);
              });
            }(this) : e4(this);
          }
        }
        class Op extends Rp {
          constructor(t4, e4, n3, i3 = {}) {
            super(t4, e4, n3);
            const o3 = t4.t;
            this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } }), this._generateLabel = i3.label || (() => o3("Editor editing area: %0", this.name));
          }
          render() {
            super.render();
            const t4 = this._editingView;
            t4.change((e4) => {
              const n3 = t4.document.getRoot(this.name);
              e4.setAttribute("aria-label", this._generateLabel(this), n3);
            });
          }
        }
        var Fp = n2(1874), Vp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Fp.Z, Vp);
        Fp.Z.locals;
        class jp extends Ho2 {
          constructor(t4, e4 = {}) {
            super(t4);
            const n3 = this.bindTemplate;
            this.set("label", e4.label || ""), this.set("class", e4.class || null), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-form__header", n3.to("class")] }, children: this.children }), e4.icon && (this.iconView = new gr(), this.iconView.content = e4.icon, this.children.add(this.iconView));
            const i3 = new Ho2(t4);
            i3.setTemplate({ tag: "h2", attributes: { class: ["ck", "ck-form__header__label"] }, children: [{ text: n3.to("label") }] }), this.children.add(i3);
          }
        }
        class Hp extends xs {
          static get pluginName() {
            return "Notification";
          }
          init() {
            this.on("show:warning", (t4, e4) => {
              window.alert(e4.message);
            }, { priority: "lowest" });
          }
          showSuccess(t4, e4 = {}) {
            this._showNotification({ message: t4, type: "success", namespace: e4.namespace, title: e4.title });
          }
          showInfo(t4, e4 = {}) {
            this._showNotification({ message: t4, type: "info", namespace: e4.namespace, title: e4.title });
          }
          showWarning(t4, e4 = {}) {
            this._showNotification({ message: t4, type: "warning", namespace: e4.namespace, title: e4.title });
          }
          _showNotification(t4) {
            const e4 = t4.namespace ? `show:${t4.type}:${t4.namespace}` : `show:${t4.type}`;
            this.fire(e4, { message: t4.message, type: t4.type, title: t4.title || "" });
          }
        }
        class Up extends q2() {
          constructor(t4, e4) {
            super(), e4 && nl2(this, e4), t4 && this.set(t4);
          }
        }
        const Gp = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>';
        var Wp = n2(7592), qp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Wp.Z, qp);
        Wp.Z.locals;
        var $p = n2(6356), Kp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()($p.Z, Kp);
        $p.Z.locals;
        const Zp = $i2("px");
        class Yp extends bs {
          static get pluginName() {
            return "ContextualBalloon";
          }
          constructor(t4) {
            super(t4), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
              const t5 = this.editor.editing.view, e4 = t5.document.selection.editableElement;
              return e4 ? t5.domConverter.mapViewToDom(e4.root) : null;
            }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", false);
          }
          destroy() {
            super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
          }
          get view() {
            return this._view || this._createPanelView(), this._view;
          }
          hasView(t4) {
            return Array.from(this._viewToStack.keys()).includes(t4);
          }
          add(t4) {
            if (this._view || this._createPanelView(), this.hasView(t4.view))
              throw new C2("contextualballoon-add-view-exist", [this, t4]);
            const e4 = t4.stackId || "main";
            if (!this._idToStack.has(e4))
              return this._idToStack.set(e4, /* @__PURE__ */ new Map([[t4.view, t4]])), this._viewToStack.set(t4.view, this._idToStack.get(e4)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !t4.singleViewMode || this.showStack(e4));
            const n3 = this._idToStack.get(e4);
            t4.singleViewMode && this.showStack(e4), n3.set(t4.view, t4), this._viewToStack.set(t4.view, n3), n3 === this._visibleStack && this._showView(t4);
          }
          remove(t4) {
            if (!this.hasView(t4))
              throw new C2("contextualballoon-remove-view-not-exist", [this, t4]);
            const e4 = this._viewToStack.get(t4);
            this._singleViewMode && this.visibleView === t4 && (this._singleViewMode = false), this.visibleView === t4 && (1 === e4.size ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(e4.values())[e4.size - 2])), 1 === e4.size ? (this._idToStack.delete(this._getStackId(e4)), this._numberOfStacks = this._idToStack.size) : e4.delete(t4), this._viewToStack.delete(t4);
          }
          updatePosition(t4) {
            t4 && (this._visibleStack.get(this.visibleView).position = t4), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
          }
          showStack(t4) {
            this.visibleStack = t4;
            const e4 = this._idToStack.get(t4);
            if (!e4)
              throw new C2("contextualballoon-showstack-stack-not-exist", this);
            this._visibleStack !== e4 && this._showView(Array.from(e4.values()).pop());
          }
          _createPanelView() {
            this._view = new lp(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
          }
          get _visibleStack() {
            return this._viewToStack.get(this.visibleView);
          }
          _getStackId(t4) {
            return Array.from(this._idToStack.entries()).find((e4) => e4[1] === t4)[0];
          }
          _showNextStack() {
            const t4 = Array.from(this._idToStack.values());
            let e4 = t4.indexOf(this._visibleStack) + 1;
            t4[e4] || (e4 = 0), this.showStack(this._getStackId(t4[e4]));
          }
          _showPrevStack() {
            const t4 = Array.from(this._idToStack.values());
            let e4 = t4.indexOf(this._visibleStack) - 1;
            t4[e4] || (e4 = t4.length - 1), this.showStack(this._getStackId(t4[e4]));
          }
          _createRotatorView() {
            const t4 = new Qp(this.editor.locale), e4 = this.editor.locale.t;
            return this.view.content.add(t4), t4.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (t5, e5) => !e5 && t5 > 1), t4.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), t4.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (t5, n3) => {
              if (n3 < 2)
                return "";
              const i3 = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
              return e4("%0 of %1", [i3, n3]);
            }), t4.buttonNextView.on("execute", () => {
              t4.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
            }), t4.buttonPrevView.on("execute", () => {
              t4.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
            }), t4;
          }
          _createFakePanelsView() {
            const t4 = new Jp(this.editor.locale, this.view);
            return t4.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t5, e4) => !e4 && t5 >= 2 ? Math.min(t5 - 1, 2) : 0), t4.listenTo(this.view, "change:top", () => t4.updatePosition()), t4.listenTo(this.view, "change:left", () => t4.updatePosition()), this.editor.ui.view.body.add(t4), t4;
          }
          _showView({ view: t4, balloonClassName: e4 = "", withArrow: n3 = true, singleViewMode: i3 = false }) {
            this.view.class = e4, this.view.withArrow = n3, this._rotatorView.showView(t4), this.visibleView = t4, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), i3 && (this._singleViewMode = true);
          }
          _getBalloonPosition() {
            let t4 = Array.from(this._visibleStack.values()).pop().position;
            return t4 && (t4.limiter || (t4 = Object.assign({}, t4, { limiter: this.positionLimiter })), t4 = Object.assign({}, t4, { viewportOffsetConfig: this.editor.ui.viewportOffset })), t4;
          }
        }
        class Qp extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = t4.t, n3 = this.bindTemplate;
            this.set("isNavigationVisible", true), this.focusTracker = new To2(), this.buttonPrevView = this._createButtonView(e4("Previous"), Gp), this.buttonNextView = this._createButtonView(e4("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n3.to("isNavigationVisible", (t5) => t5 ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n3.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
          }
          render() {
            super.render(), this.focusTracker.add(this.element);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy();
          }
          showView(t4) {
            this.hideView(), this.content.add(t4);
          }
          hideView() {
            this.content.clear();
          }
          _createButtonView(t4, e4) {
            const n3 = new kr(this.locale);
            return n3.set({ label: t4, icon: e4, tooltip: true }), n3;
          }
        }
        class Jp extends Ho2 {
          constructor(t4, e4) {
            super(t4);
            const n3 = this.bindTemplate;
            this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = e4, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n3.to("numberOfPanels", (t5) => t5 ? "" : "ck-hidden")], style: { top: n3.to("top", Zp), left: n3.to("left", Zp), width: n3.to("width", Zp), height: n3.to("height", Zp) } }, children: this.content }), this.on("change:numberOfPanels", (t5, e5, n4, i3) => {
              n4 > i3 ? this._addPanels(n4 - i3) : this._removePanels(i3 - n4), this.updatePosition();
            });
          }
          _addPanels(t4) {
            for (; t4--; ) {
              const t5 = new Ho2();
              t5.setTemplate({ tag: "div" }), this.content.add(t5), this.registerChild(t5);
            }
          }
          _removePanels(t4) {
            for (; t4--; ) {
              const t5 = this.content.last;
              this.content.remove(t5), this.deregisterChild(t5), t5.destroy();
            }
          }
          updatePosition() {
            if (this.numberOfPanels) {
              const { top: t4, left: e4 } = this._balloonPanelView, { width: n3, height: i3 } = new Vi2(this._balloonPanelView.element);
              Object.assign(this, { top: t4, left: e4, width: n3, height: i3 });
            }
          }
        }
        var Xp = n2(3707), tf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Xp.Z, tf2);
        Xp.Z.locals;
        const ef2 = $i2("px");
        class nf2 extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.set("isActive", false), this.set("isSticky", false), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheBottomOfLimiter", false), this.set("_stickyTopOffset", null), this.set("_stickyBottomOffset", null), this.content = this.createCollection(), this._contentPanelPlaceholder = new Uo2({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: e4.to("isSticky", (t5) => t5 ? "block" : "none"), height: e4.to("isSticky", (t5) => t5 ? ef2(this._contentPanelRect.height) : null) } } }).render(), this._contentPanel = new Uo2({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", e4.if("isSticky", "ck-sticky-panel__content_sticky"), e4.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: e4.to("isSticky", (t5) => t5 ? ef2(this._contentPanelPlaceholder.getBoundingClientRect().width) : null), top: e4.to("_stickyTopOffset", (t5) => t5 ? ef2(t5) : t5), bottom: e4.to("_stickyBottomOffset", (t5) => t5 ? ef2(t5) : t5), marginLeft: e4.to("_marginLeft") } }, children: this.content }).render(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] });
          }
          render() {
            super.render(), this.checkIfShouldBeSticky(), this.listenTo(Li2.document, "scroll", () => {
              this.checkIfShouldBeSticky();
            }, { useCapture: true }), this.listenTo(this, "change:isActive", () => {
              this.checkIfShouldBeSticky();
            });
          }
          checkIfShouldBeSticky() {
            if (!this.limiterElement || !this.isActive)
              return void this._unstick();
            const t4 = new Vi2(this.limiterElement);
            let e4 = t4.getVisible();
            if (e4) {
              const t5 = new Vi2(Li2.window);
              t5.top += this.viewportTopOffset, t5.height -= this.viewportTopOffset, e4 = e4.getIntersection(t5);
            }
            if (e4 && t4.top < e4.top) {
              const n3 = e4.top;
              if (n3 + this._contentPanelRect.height + this.limiterBottomOffset > e4.bottom) {
                const n4 = Math.max(t4.bottom - e4.bottom, 0) + this.limiterBottomOffset;
                t4.bottom - n4 > t4.top + this._contentPanelRect.height ? this._stickToBottomOfLimiter(n4) : this._unstick();
              } else
                this._contentPanelRect.height + this.limiterBottomOffset < t4.height ? this._stickToTopOfAncestors(n3) : this._unstick();
            } else
              this._unstick();
          }
          _stickToTopOfAncestors(t4) {
            this.isSticky = true, this._isStickyToTheBottomOfLimiter = false, this._stickyTopOffset = t4, this._stickyBottomOffset = null, this._marginLeft = ef2(-Li2.window.scrollX);
          }
          _stickToBottomOfLimiter(t4) {
            this.isSticky = true, this._isStickyToTheBottomOfLimiter = true, this._stickyTopOffset = null, this._stickyBottomOffset = t4, this._marginLeft = ef2(-Li2.window.scrollX);
          }
          _unstick() {
            this.isSticky = false, this._isStickyToTheBottomOfLimiter = false, this._stickyTopOffset = null, this._stickyBottomOffset = null, this._marginLeft = null;
          }
          get _contentPanelRect() {
            return new Vi2(this._contentPanel);
          }
        }
        class of2 extends Xr {
          constructor(t4, e4) {
            const n3 = t4.t, i3 = Object.assign({}, { showResetButton: true, showIcon: true, creator: hm }, e4);
            super(t4, i3.creator), this.label = e4.label, this._viewConfig = i3, this._viewConfig.showIcon && (this.iconView = new gr(), this.iconView.content = Pg2.loupe, this.fieldWrapperChildren.add(this.iconView, 0), this.extendTemplate({ attributes: { class: "ck-search__query_with-icon" } })), this._viewConfig.showResetButton && (this.resetButtonView = new kr(t4), this.resetButtonView.set({ label: n3("Clear"), icon: Pg2.cancel, class: "ck-search__reset", isVisible: false, tooltip: true }), this.resetButtonView.on("execute", () => {
              this.reset(), this.focus(), this.fire("reset");
            }), this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (t5) => !t5), this.fieldWrapperChildren.add(this.resetButtonView), this.extendTemplate({ attributes: { class: "ck-search__query_with-reset" } }));
          }
          reset() {
            this.fieldView.reset(), this._viewConfig.showResetButton && (this.resetButtonView.isVisible = false);
          }
        }
        class rf2 extends Ho2 {
          constructor() {
            super();
            const t4 = this.bindTemplate;
            this.set({ isVisible: false, primaryText: "", secondaryText: "" }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search__info", t4.if("isVisible", "ck-hidden", (t5) => !t5)], tabindex: -1 }, children: [{ tag: "span", children: [{ text: [t4.to("primaryText")] }] }, { tag: "span", children: [{ text: [t4.to("secondaryText")] }] }] });
          }
          focus() {
            this.element.focus();
          }
        }
        class sf2 extends Ho2 {
          constructor(t4) {
            super(t4), this.children = this.createCollection(), this.focusTracker = new To2(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search__results"], tabindex: -1 }, children: this.children }), this._focusCycler = new gs({ focusables: this.children, focusTracker: this.focusTracker });
          }
          render() {
            super.render();
            for (const t4 of this.children)
              this.focusTracker.add(t4.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusFirst() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
        }
        var af2 = /[\\^$.*+?()[\]{}|]/g, cf2 = RegExp(af2.source);
        const lf2 = function(t4) {
          return (t4 = ia2(t4)) && cf2.test(t4) ? t4.replace(af2, "\\$&") : t4;
        };
        var df2 = n2(9332), hf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(df2.Z, hf2);
        df2.Z.locals;
        class uf2 extends Ho2 {
          constructor(t4, e4) {
            super(t4), this._config = e4, this.filteredView = e4.filteredView, this.queryView = this._createSearchTextQueryView(), this.focusTracker = new To2(), this.keystrokes = new Io2(), this.resultsView = new sf2(t4), this.children = this.createCollection(), this.focusableChildren = this.createCollection([this.queryView, this.resultsView]), this.set("isEnabled", true), this.set("resultsCount", 0), this.set("totalItemsCount", 0), e4.infoView && e4.infoView.instance ? this.infoView = e4.infoView.instance : (this.infoView = new rf2(), this._enableDefaultInfoViewBehavior(), this.on("render", () => {
              this.search("");
            })), this.resultsView.children.addMany([this.infoView, this.filteredView]), this.focusCycler = new gs({ focusables: this.focusableChildren, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.on("search", (t5, { resultsCount: e5, totalItemsCount: n3 }) => {
              this.resultsCount = e5, this.totalItemsCount = n3;
            }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search", e4.class || null], tabindex: "-1" }, children: this.children });
          }
          render() {
            super.render(), this.children.addMany([this.queryView, this.resultsView]);
            const t4 = (t5) => t5.stopPropagation();
            for (const t5 of this.focusableChildren)
              this.focusTracker.add(t5.element);
            this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", t4), this.keystrokes.set("arrowleft", t4), this.keystrokes.set("arrowup", t4), this.keystrokes.set("arrowdown", t4);
          }
          focus() {
            this.queryView.focus();
          }
          reset() {
            this.queryView.reset(), this.search("");
          }
          search(t4) {
            const e4 = t4 ? new RegExp(lf2(t4), "ig") : null, n3 = this.filteredView.filter(e4);
            this.fire("search", { query: t4, ...n3 });
          }
          _createSearchTextQueryView() {
            const t4 = new of2(this.locale, this._config.queryView);
            return this.listenTo(t4.fieldView, "input", () => {
              this.search(t4.fieldView.element.value);
            }), t4.on("reset", () => this.reset()), t4.bind("isEnabled").to(this), t4;
          }
          _enableDefaultInfoViewBehavior() {
            const t4 = this.locale.t, e4 = this.infoView;
            function n3(t5, { query: e5, resultsCount: n4, totalItemsCount: i3 }) {
              return "function" == typeof t5 ? t5(e5, n4, i3) : t5;
            }
            this.on("search", (i3, o3) => {
              if (o3.resultsCount)
                e4.set({ isVisible: false });
              else {
                const i4 = this._config.infoView && this._config.infoView.text;
                let r3, s3;
                o3.totalItemsCount ? i4 && i4.notFound ? (r3 = i4.notFound.primary, s3 = i4.notFound.secondary) : (r3 = t4("No results found"), s3 = "") : i4 && i4.noSearchableItems ? (r3 = i4.noSearchableItems.primary, s3 = i4.noSearchableItems.secondary) : (r3 = t4("No searchable items"), s3 = ""), e4.set({ primaryText: n3(r3, o3), secondaryText: n3(s3, o3), isVisible: true });
              }
            });
          }
        }
        var gf2 = n2(4029), mf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(gf2.Z, mf2);
        gf2.Z.locals;
        class pf2 extends uf2 {
          constructor(t4, e4) {
            super(t4, e4), this._config = e4;
            const n3 = $i2("px");
            this.extendTemplate({ attributes: { class: ["ck-autocomplete"] } });
            const i3 = this.resultsView.bindTemplate;
            this.resultsView.set("isVisible", false), this.resultsView.set("_position", "s"), this.resultsView.set("_width", 0), this.resultsView.extendTemplate({ attributes: { class: [i3.if("isVisible", "ck-hidden", (t5) => !t5), i3.to("_position", (t5) => `ck-search__results_${t5}`)], style: { width: i3.to("_width", n3) } } }), this.focusTracker.on("change:isFocused", (t5, n4, i4) => {
              this._updateResultsVisibility(), i4 ? this.resultsView.element.scrollTop = 0 : e4.resetOnBlur && this.queryView.reset();
            }), this.on("search", () => {
              this._updateResultsVisibility(), this._updateResultsViewWidthAndPosition();
            }), this.keystrokes.set("esc", (t5, e5) => {
              this.resultsView.isVisible && (this.queryView.focus(), this.resultsView.isVisible = false, e5());
            }), this.listenTo(Li2.document, "scroll", () => {
              this._updateResultsViewWidthAndPosition();
            }), this.on("change:isEnabled", () => {
              this._updateResultsVisibility();
            }), this.filteredView.on("execute", (t5, { value: e5 }) => {
              this.focus(), this.reset(), this.queryView.fieldView.value = this.queryView.fieldView.element.value = e5, this.resultsView.isVisible = false;
            }), this.resultsView.on("change:isVisible", () => {
              this._updateResultsViewWidthAndPosition();
            });
          }
          _updateResultsViewWidthAndPosition() {
            if (!this.resultsView.isVisible)
              return;
            this.resultsView._width = new Vi2(this.queryView.fieldView.element).width;
            const t4 = pf2._getOptimalPosition({ element: this.resultsView.element, target: this.queryView.element, fitInViewport: true, positions: pf2.defaultResultsPositions });
            this.resultsView._position = t4 ? t4.name : "s";
          }
          _updateResultsVisibility() {
            const t4 = void 0 === this._config.queryMinChars ? 0 : this._config.queryMinChars, e4 = this.queryView.fieldView.element.value.length;
            this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && e4 >= t4;
          }
        }
        pf2.defaultResultsPositions = [(t4) => ({ top: t4.bottom, left: t4.left, name: "s" }), (t4, e4) => ({ top: t4.top - e4.height, left: t4.left, name: "n" })], pf2._getOptimalPosition = Xi2;
        var ff2 = n2(4746), kf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(ff2.Z, kf2);
        ff2.Z.locals;
        var bf2 = n2(6446), wf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(bf2.Z, wf2);
        bf2.Z.locals;
        var Af2 = n2(4176), Cf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Af2.Z, Cf2);
        Af2.Z.locals;
        class _f extends Bp {
          constructor(t4, e4) {
            super(t4), this.view = e4, this._toolbarConfig = ks(t4.config.get("toolbar")), this._elementReplacer = new J2(), this.listenTo(t4.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
          }
          get element() {
            return this.view.element;
          }
          init(t4) {
            const e4 = this.editor, n3 = this.view, i3 = e4.editing.view, o3 = n3.editable, r3 = i3.document.getRoot();
            o3.name = r3.rootName, n3.render();
            const s3 = o3.element;
            this.setEditableElement(o3.name, s3), n3.editable.bind("isFocused").to(this.focusTracker), i3.attachDomRoot(s3), t4 && this._elementReplacer.replace(t4, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
          }
          destroy() {
            super.destroy();
            const t4 = this.view, e4 = this.editor.editing.view;
            this._elementReplacer.restore(), e4.detachDomRoot(t4.editable.name), t4.destroy();
          }
          _initToolbar() {
            const t4 = this.view;
            t4.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), t4.stickyPanel.limiterElement = t4.element, t4.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t5 }) => t5 || 0), t4.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(t4.toolbar);
          }
          _initPlaceholder() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document.getRoot(), i3 = t4.sourceElement;
            let o3;
            const r3 = t4.config.get("placeholder");
            r3 && (o3 = "string" == typeof r3 ? r3 : r3[this.view.editable.name]), !o3 && i3 && "textarea" === i3.tagName.toLowerCase() && (o3 = i3.getAttribute("placeholder")), o3 && (n3.placeholder = o3), Is({ view: e4, element: n3, isDirectHost: false, keepOnFocus: true });
          }
          _handleScrollToTheSelectionWithStickyPanel(t4, e4, n3) {
            const i3 = this.view.stickyPanel;
            if (i3.isSticky) {
              const t5 = new Vi2(i3.element).height;
              e4.viewportOffset.top += t5;
            } else {
              const t5 = () => {
                this.editor.editing.view.scrollToTheSelection(n3);
              };
              this.listenTo(i3, "change:isSticky", t5), setTimeout(() => {
                this.stopListening(i3, "change:isSticky", t5);
              }, 20);
            }
          }
        }
        var vf2 = n2(3624), yf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(vf2.Z, yf2);
        vf2.Z.locals;
        class xf2 extends Pp {
          constructor(t4, e4, n3 = {}) {
            super(t4), this.stickyPanel = new nf2(t4), this.toolbar = new jg2(t4, { shouldGroupWhenFull: n3.shouldToolbarGroupWhenFull }), this.editable = new Op(t4, e4);
          }
          render() {
            super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
          }
        }
        class Ef2 {
          constructor(t4) {
            if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = "number" == typeof t4.crashNumberLimit ? t4.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = "number" == typeof t4.minimumNonErrorTimePeriod ? t4.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t5) => {
              const e4 = "error" in t5 ? t5.error : t5.reason;
              e4 instanceof Error && this._handleError(e4, t5);
            }, this._listeners = {}, !this._restart)
              throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
          }
          destroy() {
            this._stopErrorHandling(), this._listeners = {};
          }
          on(t4, e4) {
            this._listeners[t4] || (this._listeners[t4] = []), this._listeners[t4].push(e4);
          }
          off(t4, e4) {
            this._listeners[t4] = this._listeners[t4].filter((t5) => t5 !== e4);
          }
          _fire(t4, ...e4) {
            const n3 = this._listeners[t4] || [];
            for (const t5 of n3)
              t5.apply(this, [null, ...e4]);
          }
          _startErrorHandling() {
            window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
          }
          _stopErrorHandling() {
            window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
          }
          _handleError(t4, e4) {
            if (this._shouldReactToError(t4)) {
              this.crashes.push({ message: t4.message, stack: t4.stack, filename: e4 instanceof ErrorEvent ? e4.filename : void 0, lineno: e4 instanceof ErrorEvent ? e4.lineno : void 0, colno: e4 instanceof ErrorEvent ? e4.colno : void 0, date: this._now() });
              const n3 = this._shouldRestart();
              this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: t4, causesRestart: n3 }), n3 ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
            }
          }
          _shouldReactToError(t4) {
            return t4.is && t4.is("CKEditorError") && void 0 !== t4.context && null !== t4.context && "ready" === this.state && this._isErrorComingFromThisItem(t4);
          }
          _shouldRestart() {
            if (this.crashes.length <= this._crashNumberLimit)
              return true;
            return (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
          }
        }
        function Df2(t4, e4 = /* @__PURE__ */ new Set()) {
          const n3 = [t4], i3 = /* @__PURE__ */ new Set();
          let o3 = 0;
          for (; n3.length > o3; ) {
            const t5 = n3[o3++];
            if (!i3.has(t5) && Sf2(t5) && !e4.has(t5))
              if (i3.add(t5), Symbol.iterator in t5)
                try {
                  for (const e5 of t5)
                    n3.push(e5);
                } catch (t6) {
                }
              else
                for (const e5 in t5)
                  "defaultValue" !== e5 && n3.push(t5[e5]);
          }
          return i3;
        }
        function Sf2(t4) {
          const e4 = Object.prototype.toString.call(t4), n3 = typeof t4;
          return !("number" === n3 || "boolean" === n3 || "string" === n3 || "symbol" === n3 || "function" === n3 || "[object Date]" === e4 || "[object RegExp]" === e4 || "[object Module]" === e4 || null == t4 || t4._watchdogExcluded || t4 instanceof EventTarget || t4 instanceof Event);
        }
        function Tf2(t4, e4, n3 = /* @__PURE__ */ new Set()) {
          if (t4 === e4 && ("object" == typeof (i3 = t4) && null !== i3))
            return true;
          var i3;
          const o3 = Df2(t4, n3), r3 = Df2(e4, n3);
          for (const t5 of o3)
            if (r3.has(t5))
              return true;
          return false;
        }
        class If2 extends Ef2 {
          constructor(t4, e4 = {}) {
            super(e4), this._editor = null, this._initUsingData = true, this._editables = {}, this._throttledSave = kp(this._save.bind(this), "number" == typeof e4.saveInterval ? e4.saveInterval : 5e3), t4 && (this._creator = (e5, n3) => t4.create(e5, n3)), this._destructor = (t5) => t5.destroy();
          }
          get editor() {
            return this._editor;
          }
          get _item() {
            return this._editor;
          }
          setCreator(t4) {
            this._creator = t4;
          }
          setDestructor(t4) {
            this._destructor = t4;
          }
          _restart() {
            return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((t4) => {
              console.error("An error happened during the editor destroying.", t4);
            }).then(() => {
              const t4 = {}, e4 = [], n3 = this._config.rootsAttributes || {}, i3 = {};
              for (const [o4, r3] of Object.entries(this._data.roots))
                r3.isLoaded ? (t4[o4] = "", i3[o4] = n3[o4] || {}) : e4.push(o4);
              const o3 = { ...this._config, extraPlugins: this._config.extraPlugins || [], lazyRoots: e4, rootsAttributes: i3, _watchdogInitialData: this._data };
              return delete o3.initialData, o3.extraPlugins.push(Bf2), this._initUsingData ? this.create(t4, o3, o3.context) : vi2(this._elementOrData) ? this.create(this._elementOrData, o3, o3.context) : this.create(this._editables, o3, o3.context);
            }).then(() => {
              this._fire("restart");
            });
          }
          create(t4 = this._elementOrData, e4 = this._config, n3) {
            return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = t4, this._initUsingData = "string" == typeof t4 || Object.keys(t4).length > 0 && "string" == typeof Object.values(t4)[0], this._config = this._cloneEditorConfiguration(e4) || {}, this._config.context = n3, this._creator(t4, this._config))).then((t5) => {
              this._editor = t5, t5.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = t5.model.document.version, this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this.state = "ready", this._fire("stateChange");
            });
          }
          destroy() {
            return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
          }
          _destroy() {
            return Promise.resolve().then(() => {
              this._stopErrorHandling(), this._throttledSave.cancel();
              const t4 = this._editor;
              return this._editor = null, t4.model.document.off("change:data", this._throttledSave), this._destructor(t4);
            });
          }
          _save() {
            const t4 = this._editor.model.document.version;
            try {
              this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this._lastDocumentVersion = t4;
            } catch (t5) {
              console.error(t5, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
            }
          }
          _setExcludedProperties(t4) {
            this._excludedProps = t4;
          }
          _getData() {
            const t4 = this._editor, e4 = t4.model.document.roots.filter((t5) => t5.isAttached() && "$graveyard" != t5.rootName), { plugins: n3 } = t4, i3 = n3.has("CommentsRepository") && n3.get("CommentsRepository"), o3 = n3.has("TrackChanges") && n3.get("TrackChanges"), r3 = { roots: {}, markers: {}, commentThreads: JSON.stringify([]), suggestions: JSON.stringify([]) };
            e4.forEach((t5) => {
              r3.roots[t5.rootName] = { content: JSON.stringify(Array.from(t5.getChildren())), attributes: JSON.stringify(Array.from(t5.getAttributes())), isLoaded: t5._isLoaded };
            });
            for (const e5 of t4.model.markers)
              e5._affectsData && (r3.markers[e5.name] = { rangeJSON: e5.getRange().toJSON(), usingOperation: e5._managedUsingOperations, affectsData: e5._affectsData });
            return i3 && (r3.commentThreads = JSON.stringify(i3.getCommentThreads({ toJSON: true, skipNotAttached: true }))), o3 && (r3.suggestions = JSON.stringify(o3.getSuggestions({ toJSON: true, skipNotAttached: true }))), r3;
          }
          _getEditables() {
            const t4 = {};
            for (const e4 of this.editor.model.document.getRootNames()) {
              const n3 = this.editor.ui.getEditableElement(e4);
              n3 && (t4[e4] = n3);
            }
            return t4;
          }
          _isErrorComingFromThisItem(t4) {
            return Tf2(this._editor, t4.context, this._excludedProps);
          }
          _cloneEditorConfiguration(t4) {
            return _i(t4, (t5, e4) => vi2(t5) || "context" === e4 ? t5 : void 0);
          }
        }
        class Bf2 {
          constructor(t4) {
            this.editor = t4, this._data = t4.config.get("_watchdogInitialData");
          }
          init() {
            this.editor.data.on("init", (t4) => {
              t4.stop(), this.editor.model.enqueueChange({ isUndoable: false }, (t5) => {
                this._restoreCollaborationData(), this._restoreEditorData(t5);
              }), this.editor.data.fire("ready");
            }, { priority: 999 });
          }
          _createNode(t4, e4) {
            if ("name" in e4) {
              const n3 = t4.createElement(e4.name, e4.attributes);
              if (e4.children)
                for (const i3 of e4.children)
                  n3._appendChild(this._createNode(t4, i3));
              return n3;
            }
            return t4.createText(e4.data, e4.attributes);
          }
          _restoreEditorData(t4) {
            const e4 = this.editor;
            Object.entries(this._data.roots).forEach(([n3, { content: i3, attributes: o3 }]) => {
              const r3 = JSON.parse(i3), s3 = JSON.parse(o3), a3 = e4.model.document.getRoot(n3);
              for (const [e5, n4] of s3)
                t4.setAttribute(e5, n4, a3);
              for (const e5 of r3) {
                const n4 = this._createNode(t4, e5);
                t4.insert(n4, a3, "end");
              }
            }), Object.entries(this._data.markers).forEach(([n3, i3]) => {
              const { document: o3 } = e4.model, { rangeJSON: { start: r3, end: s3 }, ...a3 } = i3, c3 = o3.getRoot(r3.root), l3 = t4.createPositionFromPath(c3, r3.path, r3.stickiness), d3 = t4.createPositionFromPath(c3, s3.path, s3.stickiness), h3 = t4.createRange(l3, d3);
              t4.addMarker(n3, { range: h3, ...a3 });
            });
          }
          _restoreCollaborationData() {
            const t4 = JSON.parse(this._data.commentThreads), e4 = JSON.parse(this._data.suggestions);
            t4.forEach((t5) => {
              const e5 = this.editor.config.get("collaboration.channelId"), n3 = this.editor.plugins.get("CommentsRepository");
              if (n3.hasCommentThread(t5.threadId)) {
                n3.getCommentThread(t5.threadId).remove();
              }
              n3.addCommentThread({ channelId: e5, ...t5 });
            }), e4.forEach((t5) => {
              const e5 = this.editor.plugins.get("TrackChangesEditing");
              if (e5.hasSuggestion(t5.id)) {
                e5.getSuggestion(t5.id).attributes = t5.attributes;
              } else
                e5.addSuggestionData(t5);
            });
          }
        }
        const Mf2 = Symbol("MainQueueId");
        class Nf2 {
          constructor() {
            this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
          }
          onEmpty(t4) {
            this._onEmptyCallbacks.push(t4);
          }
          enqueue(t4, e4) {
            const n3 = t4 === Mf2;
            this._activeActions++, this._queues.get(t4) || this._queues.set(t4, Promise.resolve());
            const i3 = (n3 ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Mf2), this._queues.get(t4)])).then(e4), o3 = i3.catch(() => {
            });
            return this._queues.set(t4, o3), i3.finally(() => {
              this._activeActions--, this._queues.get(t4) === o3 && 0 === this._activeActions && this._onEmptyCallbacks.forEach((t5) => t5());
            });
          }
        }
        function Lf2(t4) {
          return Array.isArray(t4) ? t4 : [t4];
        }
        class zf2 extends Ig2(Bg2(Tg2)) {
          constructor(t4, e4 = {}) {
            if (!Pf2(t4) && void 0 !== e4.initialData)
              throw new C2("editor-create-initial-data", null);
            super(e4), void 0 === this.config.get("initialData") && this.config.set("initialData", function(t5) {
              return Pf2(t5) ? (e5 = t5, e5 instanceof HTMLTextAreaElement ? e5.value : e5.innerHTML) : t5;
              var e5;
            }(t4)), Pf2(t4) && (this.sourceElement = t4), this.model.document.createRoot();
            const n3 = !this.config.get("toolbar.shouldNotGroupWhenFull"), i3 = new xf2(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n3 });
            this.ui = new _f(this, i3), function(t5) {
              if (!jt2(t5.updateSourceElement))
                throw new C2("attachtoform-missing-elementapi-interface", t5);
              const e5 = t5.sourceElement;
              if (function(t6) {
                return !!t6 && "textarea" === t6.tagName.toLowerCase();
              }(e5) && e5.form) {
                let n4;
                const i4 = e5.form, o3 = () => t5.updateSourceElement();
                jt2(i4.submit) && (n4 = i4.submit, i4.submit = () => {
                  o3(), n4.apply(i4);
                }), i4.addEventListener("submit", o3), t5.on("destroy", () => {
                  i4.removeEventListener("submit", o3), n4 && (i4.submit = n4);
                });
              }
            }(this);
          }
          destroy() {
            return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
          }
          static create(t4, e4 = {}) {
            return new Promise((n3) => {
              const i3 = new this(t4, e4);
              n3(i3.initPlugins().then(() => i3.ui.init(Pf2(t4) ? t4 : null)).then(() => i3.data.init(i3.config.get("initialData"))).then(() => i3.fire("ready")).then(() => i3));
            });
          }
        }
        function Pf2(t4) {
          return vi2(t4);
        }
        zf2.Context = ys, zf2.EditorWatchdog = If2, zf2.ContextWatchdog = class extends Ef2 {
          constructor(t4, e4 = {}) {
            super(e4), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Nf2(), this._watchdogConfig = e4, this._creator = (e5) => t4.create(e5), this._destructor = (t5) => t5.destroy(), this._actionQueues.onEmpty(() => {
              "initializing" === this.state && (this.state = "ready", this._fire("stateChange"));
            });
          }
          setCreator(t4) {
            this._creator = t4;
          }
          setDestructor(t4) {
            this._destructor = t4;
          }
          get context() {
            return this._context;
          }
          create(t4 = {}) {
            return this._actionQueues.enqueue(Mf2, () => (this._contextConfig = t4, this._create()));
          }
          getItem(t4) {
            return this._getWatchdog(t4)._item;
          }
          getItemState(t4) {
            return this._getWatchdog(t4).state;
          }
          add(t4) {
            const e4 = Lf2(t4);
            return Promise.all(e4.map((t5) => this._actionQueues.enqueue(t5.id, () => {
              if ("destroyed" === this.state)
                throw new Error("Cannot add items to destroyed watchdog.");
              if (!this._context)
                throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
              let e5;
              if (this._watchdogs.has(t5.id))
                throw new Error(`Item with the given id is already added: '${t5.id}'.`);
              if ("editor" === t5.type)
                return e5 = new If2(null, this._watchdogConfig), e5.setCreator(t5.creator), e5._setExcludedProperties(this._contextProps), t5.destructor && e5.setDestructor(t5.destructor), this._watchdogs.set(t5.id, e5), e5.on("error", (n3, { error: i3, causesRestart: o3 }) => {
                  this._fire("itemError", { itemId: t5.id, error: i3 }), o3 && this._actionQueues.enqueue(t5.id, () => new Promise((n4) => {
                    const i4 = () => {
                      e5.off("restart", i4), this._fire("itemRestart", { itemId: t5.id }), n4();
                    };
                    e5.on("restart", i4);
                  }));
                }), e5.create(t5.sourceElementOrData, t5.config, this._context);
              throw new Error(`Not supported item type: '${t5.type}'.`);
            })));
          }
          remove(t4) {
            const e4 = Lf2(t4);
            return Promise.all(e4.map((t5) => this._actionQueues.enqueue(t5, () => {
              const e5 = this._getWatchdog(t5);
              return this._watchdogs.delete(t5), e5.destroy();
            })));
          }
          destroy() {
            return this._actionQueues.enqueue(Mf2, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
          }
          _restart() {
            return this._actionQueues.enqueue(Mf2, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((t4) => {
              console.error("An error happened during destroying the context or items.", t4);
            }).then(() => this._create()).then(() => this._fire("restart"))));
          }
          _create() {
            return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((t4) => (this._context = t4, this._contextProps = Df2(this._context), Promise.all(Array.from(this._watchdogs.values()).map((t5) => (t5._setExcludedProperties(this._contextProps), t5.create(void 0, void 0, this._context))))));
          }
          _destroy() {
            return Promise.resolve().then(() => {
              this._stopErrorHandling();
              const t4 = this._context;
              return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((t5) => t5.destroy())).then(() => this._destructor(t4));
            });
          }
          _getWatchdog(t4) {
            const e4 = this._watchdogs.get(t4);
            if (!e4)
              throw new Error(`Item with the given id was not registered: ${t4}.`);
            return e4;
          }
          _isErrorComingFromThisItem(t4) {
            for (const e4 of this._watchdogs.values())
              if (e4._isErrorComingFromThisItem(t4))
                return false;
            return Tf2(this._context, t4.context);
          }
        };
        class Rf2 extends As {
          constructor(t4, e4) {
            super(t4), this.attributeKey = e4;
          }
          refresh() {
            const t4 = this.editor.model, e4 = t4.document;
            this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = t4.schema.checkAttributeInSelection(e4.selection, this.attributeKey);
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = void 0 === t4.forceValue ? !this.value : t4.forceValue;
            e4.change((t5) => {
              if (n3.isCollapsed)
                i3 ? t5.setSelectionAttribute(this.attributeKey, true) : t5.removeSelectionAttribute(this.attributeKey);
              else {
                const o3 = e4.schema.getValidRanges(n3.getRanges(), this.attributeKey);
                for (const e5 of o3)
                  i3 ? t5.setAttribute(this.attributeKey, i3, e5) : t5.removeAttribute(this.attributeKey, e5);
              }
            });
          }
          _getValueFromFirstAllowedNode() {
            const t4 = this.editor.model, e4 = t4.schema, n3 = t4.document.selection;
            if (n3.isCollapsed)
              return n3.hasAttribute(this.attributeKey);
            for (const t5 of n3.getRanges())
              for (const n4 of t5.getItems())
                if (e4.checkAttribute(n4, this.attributeKey))
                  return n4.hasAttribute(this.attributeKey);
            return false;
          }
        }
        const Of2 = "bold";
        class Ff2 extends bs {
          static get pluginName() {
            return "BoldEditing";
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: Of2 }), t4.model.schema.setAttributeProperties(Of2, { isFormatting: true, copyOnEnter: true }), t4.conversion.attributeToElement({ model: Of2, view: "strong", upcastAlso: ["b", (t5) => {
              const e4 = t5.getStyle("font-weight");
              return e4 && ("bold" == e4 || Number(e4) >= 600) ? { name: true, styles: ["font-weight"] } : null;
            }] }), t4.commands.add(Of2, new Rf2(t4, Of2)), t4.keystrokes.set("CTRL+B", Of2);
          }
        }
        const Vf2 = "bold";
        class jf2 extends bs {
          static get pluginName() {
            return "BoldUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add(Vf2, (n3) => {
              const i3 = t4.commands.get(Vf2), o3 = new kr(n3);
              return o3.set({ label: e4("Bold"), icon: Pg2.bold, keystroke: "CTRL+B", tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute(Vf2), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        class Hf2 {
          constructor(t4, e4 = 20) {
            this._batch = null, this.model = t4, this._size = 0, this.limit = e4, this._isLocked = false, this._changeCallback = (t5, e5) => {
              e5.isLocal && e5.isUndoable && e5 !== this._batch && this._reset(true);
            }, this._selectionChangeCallback = () => {
              this._reset();
            }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
          }
          get batch() {
            return this._batch || (this._batch = this.model.createBatch({ isTyping: true })), this._batch;
          }
          get size() {
            return this._size;
          }
          input(t4) {
            this._size += t4, this._size >= this.limit && this._reset(true);
          }
          get isLocked() {
            return this._isLocked;
          }
          lock() {
            this._isLocked = true;
          }
          unlock() {
            this._isLocked = false;
          }
          destroy() {
            this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
          }
          _reset(t4 = false) {
            this.isLocked && !t4 || (this._batch = null, this._size = 0);
          }
        }
        class Uf2 extends As {
          constructor(t4, e4) {
            super(t4), this._buffer = new Hf2(t4.model, e4), this._isEnabledBasedOnSelection = false;
          }
          get buffer() {
            return this._buffer;
          }
          destroy() {
            super.destroy(), this._buffer.destroy();
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document, i3 = t4.text || "", o3 = i3.length;
            let r3 = n3.selection;
            if (t4.selection ? r3 = t4.selection : t4.range && (r3 = e4.createSelection(t4.range)), !e4.canEditAt(r3))
              return;
            const s3 = t4.resultRange;
            e4.enqueueChange(this._buffer.batch, (t5) => {
              this._buffer.lock(), e4.deleteContent(r3), i3 && e4.insertContent(t5.createText(i3, n3.selection.getAttributes()), r3), s3 ? t5.setSelection(s3) : r3.is("documentSelection") || t5.setSelection(r3), this._buffer.unlock(), this._buffer.input(o3);
            });
          }
        }
        const Gf2 = ["insertText", "insertReplacementText"];
        class Wf2 extends el2 {
          constructor(t4) {
            super(t4), this.focusObserver = t4.getObserver(Il), c2.isAndroid && Gf2.push("insertCompositionText");
            const e4 = t4.document;
            e4.on("beforeinput", (n3, i3) => {
              if (!this.isEnabled)
                return;
              const { data: o3, targetRanges: r3, inputType: s3, domEvent: a3 } = i3;
              if (!Gf2.includes(s3))
                return;
              this.focusObserver.flush();
              const c3 = new p2(e4, "insertText");
              e4.fire(c3, new il2(t4, a3, { text: o3, selection: t4.createSelection(r3) })), c3.stop.called && n3.stop();
            }), e4.on("compositionend", (n3, { data: i3, domEvent: o3 }) => {
              this.isEnabled && !c2.isAndroid && i3 && e4.fire("insertText", new il2(t4, o3, { text: i3, selection: e4.selection }));
            }, { priority: "lowest" });
          }
          observe() {
          }
          stopObserving() {
          }
        }
        class qf2 extends bs {
          static get pluginName() {
            return "Input";
          }
          init() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, i3 = e4.document.selection;
            n3.addObserver(Wf2);
            const o3 = new Uf2(t4, t4.config.get("typing.undoStep") || 20);
            t4.commands.add("insertText", o3), t4.commands.add("input", o3), this.listenTo(n3.document, "insertText", (i4, o4) => {
              n3.document.isComposing || o4.preventDefault();
              const { text: r3, selection: s3, resultRange: a3 } = o4, l3 = Array.from(s3.getRanges()).map((e5) => t4.editing.mapper.toModelRange(e5));
              let d3 = r3;
              if (c2.isAndroid) {
                const t5 = Array.from(l3[0].getItems()).reduce((t6, e5) => t6 + (e5.is("$textProxy") ? e5.data : ""), "");
                t5 && (t5.length <= d3.length ? d3.startsWith(t5) && (d3 = d3.substring(t5.length), l3[0].start = l3[0].start.getShiftedBy(t5.length)) : t5.startsWith(d3) && (l3[0].start = l3[0].start.getShiftedBy(d3.length), d3 = ""));
              }
              const h3 = { text: d3, selection: e4.createSelection(l3) };
              a3 && (h3.resultRange = t4.editing.mapper.toModelRange(a3)), t4.execute("insertText", h3), n3.scrollToTheSelection();
            }), c2.isAndroid ? this.listenTo(n3.document, "keydown", (t5, r3) => {
              !i3.isCollapsed && 229 == r3.keyCode && n3.document.isComposing && $f2(e4, o3);
            }) : this.listenTo(n3.document, "compositionstart", () => {
              i3.isCollapsed || $f2(e4, o3);
            });
          }
        }
        function $f2(t4, e4) {
          if (!e4.isEnabled)
            return;
          const n3 = e4.buffer;
          n3.lock(), t4.enqueueChange(n3.batch, () => {
            t4.deleteContent(t4.document.selection);
          }), n3.unlock();
        }
        class Kf2 extends As {
          constructor(t4, e4) {
            super(t4), this.direction = e4, this._buffer = new Hf2(t4.model, t4.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = false;
          }
          get buffer() {
            return this._buffer;
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document;
            e4.enqueueChange(this._buffer.batch, (i3) => {
              this._buffer.lock();
              const o3 = i3.createSelection(t4.selection || n3.selection);
              if (!e4.canEditAt(o3))
                return;
              const r3 = t4.sequence || 1, s3 = o3.isCollapsed;
              if (o3.isCollapsed && e4.modifySelection(o3, { direction: this.direction, unit: t4.unit, treatEmojiAsSingleUnit: true }), this._shouldEntireContentBeReplacedWithParagraph(r3))
                return void this._replaceEntireContentWithParagraph(i3);
              if (this._shouldReplaceFirstBlockWithParagraph(o3, r3))
                return void this.editor.execute("paragraph", { selection: o3 });
              if (o3.isCollapsed)
                return;
              let a3 = 0;
              o3.getFirstRange().getMinimalFlatRanges().forEach((t5) => {
                a3 += X2(t5.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
              }), e4.deleteContent(o3, { doNotResetEntireContent: s3, direction: this.direction }), this._buffer.input(a3), i3.setSelection(o3), this._buffer.unlock();
            });
          }
          _shouldEntireContentBeReplacedWithParagraph(t4) {
            if (t4 > 1)
              return false;
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = e4.schema.getLimitElement(n3);
            if (!(n3.isCollapsed && n3.containsEntireContent(i3)))
              return false;
            if (!e4.schema.checkChild(i3, "paragraph"))
              return false;
            const o3 = i3.getChild(0);
            return !o3 || !o3.is("element", "paragraph");
          }
          _replaceEntireContentWithParagraph(t4) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = e4.schema.getLimitElement(n3), o3 = t4.createElement("paragraph");
            t4.remove(t4.createRangeIn(i3)), t4.insert(o3, i3), t4.setSelection(o3, 0);
          }
          _shouldReplaceFirstBlockWithParagraph(t4, e4) {
            const n3 = this.editor.model;
            if (e4 > 1 || "backward" != this.direction)
              return false;
            if (!t4.isCollapsed)
              return false;
            const i3 = t4.getFirstPosition(), o3 = n3.schema.getLimitElement(i3), r3 = o3.getChild(0);
            return i3.parent == r3 && (!!t4.containsEntireContent(r3) && (!!n3.schema.checkChild(o3, "paragraph") && "paragraph" != r3.name));
          }
        }
        const Zf2 = "word", Yf2 = "selection", Qf2 = "backward", Jf2 = "forward", Xf2 = { deleteContent: { unit: Yf2, direction: Qf2 }, deleteContentBackward: { unit: "codePoint", direction: Qf2 }, deleteWordBackward: { unit: Zf2, direction: Qf2 }, deleteHardLineBackward: { unit: Yf2, direction: Qf2 }, deleteSoftLineBackward: { unit: Yf2, direction: Qf2 }, deleteContentForward: { unit: "character", direction: Jf2 }, deleteWordForward: { unit: Zf2, direction: Jf2 }, deleteHardLineForward: { unit: Yf2, direction: Jf2 }, deleteSoftLineForward: { unit: Yf2, direction: Jf2 } };
        class tk2 extends el2 {
          constructor(t4) {
            super(t4);
            const e4 = t4.document;
            let n3 = 0;
            e4.on("keydown", () => {
              n3++;
            }), e4.on("keyup", () => {
              n3 = 0;
            }), e4.on("beforeinput", (i3, o3) => {
              if (!this.isEnabled)
                return;
              const { targetRanges: r3, domEvent: s3, inputType: a3 } = o3, l3 = Xf2[a3];
              if (!l3)
                return;
              const d3 = { direction: l3.direction, unit: l3.unit, sequence: n3 };
              d3.unit == Yf2 && (d3.selectionToRemove = t4.createSelection(r3[0])), "deleteContentBackward" === a3 && (c2.isAndroid && (d3.sequence = 1), function(t5) {
                if (1 != t5.length || t5[0].isCollapsed)
                  return false;
                const e5 = t5[0].getWalker({ direction: "backward", singleCharacters: true, ignoreElementEnd: true });
                let n4 = 0;
                for (const { nextPosition: t6 } of e5) {
                  if (t6.parent.is("$text")) {
                    const e6 = t6.parent.data, i4 = t6.offset;
                    if (No2(e6, i4) || Lo2(e6, i4) || Po2(e6, i4))
                      continue;
                    n4++;
                  } else
                    n4++;
                  if (n4 > 1)
                    return true;
                }
                return false;
              }(r3) && (d3.unit = Yf2, d3.selectionToRemove = t4.createSelection(r3)));
              const h3 = new Ja2(e4, "delete", r3[0]);
              e4.fire(h3, new il2(t4, s3, d3)), h3.stop.called && i3.stop();
            }), c2.isBlink && function(t5) {
              const e5 = t5.view, n4 = e5.document;
              let i3 = null, o3 = false;
              function r3(t6) {
                return t6 == fo2.backspace || t6 == fo2.delete;
              }
              function s3(t6) {
                return t6 == fo2.backspace ? Qf2 : Jf2;
              }
              n4.on("keydown", (t6, { keyCode: e6 }) => {
                i3 = e6, o3 = false;
              }), n4.on("keyup", (a3, { keyCode: c3, domEvent: l3 }) => {
                const d3 = n4.selection, h3 = t5.isEnabled && c3 == i3 && r3(c3) && !d3.isCollapsed && !o3;
                if (i3 = null, h3) {
                  const t6 = d3.getFirstRange(), i4 = new Ja2(n4, "delete", t6), o4 = { unit: Yf2, direction: s3(c3), selectionToRemove: d3 };
                  n4.fire(i4, new il2(e5, l3, o4));
                }
              }), n4.on("beforeinput", (t6, { inputType: e6 }) => {
                const n5 = Xf2[e6];
                r3(i3) && n5 && n5.direction == s3(i3) && (o3 = true);
              }, { priority: "high" }), n4.on("beforeinput", (t6, { inputType: e6, data: n5 }) => {
                i3 == fo2.delete && "insertText" == e6 && "" == n5 && t6.stop();
              }, { priority: "high" });
            }(this);
          }
          observe() {
          }
          stopObserving() {
          }
        }
        class ek2 extends bs {
          static get pluginName() {
            return "Delete";
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document, i3 = t4.model.document;
            e4.addObserver(tk2), this._undoOnBackspace = false;
            const o3 = new Kf2(t4, "forward");
            t4.commands.add("deleteForward", o3), t4.commands.add("forwardDelete", o3), t4.commands.add("delete", new Kf2(t4, "backward")), this.listenTo(n3, "delete", (i4, o4) => {
              n3.isComposing || o4.preventDefault();
              const { direction: r3, sequence: s3, selectionToRemove: a3, unit: c3 } = o4, l3 = "forward" === r3 ? "deleteForward" : "delete", d3 = { sequence: s3 };
              if ("selection" == c3) {
                const e5 = Array.from(a3.getRanges()).map((e6) => t4.editing.mapper.toModelRange(e6));
                d3.selection = t4.model.createSelection(e5);
              } else
                d3.unit = c3;
              t4.execute(l3, d3), e4.scrollToTheSelection();
            }, { priority: "low" }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n3, "delete", (e5, n4) => {
              this._undoOnBackspace && "backward" == n4.direction && 1 == n4.sequence && "codePoint" == n4.unit && (this._undoOnBackspace = false, t4.execute("undo"), n4.preventDefault(), e5.stop());
            }, { context: "$capture" }), this.listenTo(i3, "change", () => {
              this._undoOnBackspace = false;
            }));
          }
          requestUndoOnBackspace() {
            this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = true);
          }
        }
        class nk2 extends bs {
          static get requires() {
            return [qf2, ek2];
          }
          static get pluginName() {
            return "Typing";
          }
        }
        function ik2(t4, e4) {
          let n3 = t4.start;
          return { text: Array.from(t4.getWalker({ ignoreElementEnd: false })).reduce((t5, { item: i3 }) => i3.is("$text") || i3.is("$textProxy") ? t5 + i3.data : (n3 = e4.createPositionAfter(i3), ""), ""), range: e4.createRange(n3, t4.end) };
        }
        class ok2 extends q2() {
          constructor(t4, e4) {
            super(), this.model = t4, this.testCallback = e4, this._hasMatch = false, this.set("isEnabled", true), this.on("change:isEnabled", () => {
              this.isEnabled ? this._startListening() : (this.stopListening(t4.document.selection), this.stopListening(t4.document));
            }), this._startListening();
          }
          get hasMatch() {
            return this._hasMatch;
          }
          _startListening() {
            const t4 = this.model.document;
            this.listenTo(t4.selection, "change:range", (e4, { directChange: n3 }) => {
              n3 && (t4.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = false));
            }), this.listenTo(t4, "change:data", (t5, e4) => {
              !e4.isUndo && e4.isLocal && this._evaluateTextBeforeSelection("data", { batch: e4 });
            });
          }
          _evaluateTextBeforeSelection(t4, e4 = {}) {
            const n3 = this.model, i3 = n3.document.selection, o3 = n3.createRange(n3.createPositionAt(i3.focus.parent, 0), i3.focus), { text: r3, range: s3 } = ik2(o3, n3), a3 = this.testCallback(r3);
            if (!a3 && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!a3, a3) {
              const n4 = Object.assign(e4, { text: r3, range: s3 });
              "object" == typeof a3 && Object.assign(n4, a3), this.fire(`matched:${t4}`, n4);
            }
          }
        }
        class rk2 extends bs {
          static get pluginName() {
            return "TwoStepCaretMovement";
          }
          constructor(t4) {
            super(t4), this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
          }
          init() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, i3 = t4.locale, o3 = e4.document.selection;
            this.listenTo(n3.document, "arrowKey", (t5, e5) => {
              if (!o3.isCollapsed)
                return;
              if (e5.shiftKey || e5.altKey || e5.ctrlKey)
                return;
              const n4 = e5.keyCode == fo2.arrowright, r3 = e5.keyCode == fo2.arrowleft;
              if (!n4 && !r3)
                return;
              const s3 = i3.contentLanguageDirection;
              let a3 = false;
              a3 = "ltr" === s3 && n4 || "rtl" === s3 && r3 ? this._handleForwardMovement(e5) : this._handleBackwardMovement(e5), true === a3 && t5.stop();
            }, { context: "$text", priority: "highest" }), this._isNextGravityRestorationSkipped = false, this.listenTo(o3, "change:range", (t5, e5) => {
              this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = false : this._isGravityOverridden && (!e5.directChange && lk2(o3.getFirstPosition(), this.attributes) || this._restoreGravity());
            });
          }
          registerAttribute(t4) {
            this.attributes.add(t4);
          }
          _handleForwardMovement(t4) {
            const e4 = this.attributes, n3 = this.editor.model.document.selection, i3 = n3.getFirstPosition();
            return !this._isGravityOverridden && ((!i3.isAtStart || !sk2(n3, e4)) && (!!lk2(i3, e4) && (ck2(t4), this._overrideGravity(), true)));
          }
          _handleBackwardMovement(t4) {
            const e4 = this.attributes, n3 = this.editor.model, i3 = n3.document.selection, o3 = i3.getFirstPosition();
            return this._isGravityOverridden ? (ck2(t4), this._restoreGravity(), ak2(n3, e4, o3), true) : o3.isAtStart ? !!sk2(i3, e4) && (ck2(t4), ak2(n3, e4, o3), true) : !!function(t5, e5) {
              const n4 = t5.getShiftedBy(-1);
              return lk2(n4, e5);
            }(o3, e4) && (o3.isAtEnd && !sk2(i3, e4) && lk2(o3, e4) ? (ck2(t4), ak2(n3, e4, o3), true) : (this._isNextGravityRestorationSkipped = true, this._overrideGravity(), false));
          }
          get _isGravityOverridden() {
            return !!this._overrideUid;
          }
          _overrideGravity() {
            this._overrideUid = this.editor.model.change((t4) => t4.overrideSelectionGravity());
          }
          _restoreGravity() {
            this.editor.model.change((t4) => {
              t4.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
            });
          }
        }
        function sk2(t4, e4) {
          for (const n3 of e4)
            if (t4.hasAttribute(n3))
              return true;
          return false;
        }
        function ak2(t4, e4, n3) {
          const i3 = n3.nodeBefore;
          t4.change((n4) => {
            if (i3) {
              const e5 = [], o3 = t4.schema.isObject(i3) && t4.schema.isInline(i3);
              for (const [n5, r3] of i3.getAttributes())
                !t4.schema.checkAttribute("$text", n5) || o3 && false === t4.schema.getAttributeProperties(n5).copyFromObject || e5.push([n5, r3]);
              n4.setSelectionAttribute(e5);
            } else
              n4.removeSelectionAttribute(e4);
          });
        }
        function ck2(t4) {
          t4.preventDefault();
        }
        function lk2(t4, e4) {
          const { nodeBefore: n3, nodeAfter: i3 } = t4;
          for (const t5 of e4) {
            const e5 = n3 ? n3.getAttribute(t5) : void 0;
            if ((i3 ? i3.getAttribute(t5) : void 0) !== e5)
              return true;
          }
          return false;
        }
        const dk2 = { copyright: { from: "(c)", to: "" }, registeredTrademark: { from: "(r)", to: "" }, trademark: { from: "(tm)", to: "" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "", null] }, lessThanOrEqual: { from: "<=", to: "" }, greaterThanOrEqual: { from: ">=", to: "" }, notEqual: { from: "!=", to: "" }, arrowLeft: { from: "<-", to: "" }, arrowRight: { from: "->", to: "" }, horizontalEllipsis: { from: "...", to: "" }, enDash: { from: /(^| )(--)( )$/, to: [null, "", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "", null] }, quotesPrimary: { from: fk2('"'), to: [null, "", null, ""] }, quotesSecondary: { from: fk2("'"), to: [null, "", null, ""] }, quotesPrimaryEnGb: { from: fk2("'"), to: [null, "", null, ""] }, quotesSecondaryEnGb: { from: fk2('"'), to: [null, "", null, ""] }, quotesPrimaryPl: { from: fk2('"'), to: [null, "", null, ""] }, quotesSecondaryPl: { from: fk2("'"), to: [null, "", null, ""] } }, hk2 = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }, uk2 = ["symbols", "mathematical", "typography", "quotes"];
        function gk2(t4) {
          return "string" == typeof t4 ? new RegExp(`(${lf2(t4)})$`) : t4;
        }
        function mk2(t4) {
          return "string" == typeof t4 ? () => [t4] : t4 instanceof Array ? () => t4 : t4;
        }
        function pk2(t4) {
          return (t4.textNode ? t4.textNode : t4.nodeAfter).getAttributes();
        }
        function fk2(t4) {
          return new RegExp(`(^|\\s)(${t4})([^${t4}]*)(${t4})$`);
        }
        function kk2(t4, e4, n3, i3) {
          return i3.createRange(bk2(t4, e4, n3, true, i3), bk2(t4, e4, n3, false, i3));
        }
        function bk2(t4, e4, n3, i3, o3) {
          let r3 = t4.textNode || (i3 ? t4.nodeBefore : t4.nodeAfter), s3 = null;
          for (; r3 && r3.getAttribute(e4) == n3; )
            s3 = r3, r3 = i3 ? r3.previousSibling : r3.nextSibling;
          return s3 ? o3.createPositionAt(s3, i3 ? "before" : "after") : t4;
        }
        function wk2(t4, e4, n3, i3) {
          const o3 = t4.editing.view, r3 = /* @__PURE__ */ new Set();
          o3.document.registerPostFixer((o4) => {
            const s3 = t4.model.document.selection;
            let a3 = false;
            if (s3.hasAttribute(e4)) {
              const c3 = kk2(s3.getFirstPosition(), e4, s3.getAttribute(e4), t4.model), l3 = t4.editing.mapper.toViewRange(c3);
              for (const t5 of l3.getItems())
                t5.is("element", n3) && !t5.hasClass(i3) && (o4.addClass(i3, t5), r3.add(t5), a3 = true);
            }
            return a3;
          }), t4.conversion.for("editingDowncast").add((t5) => {
            function e5() {
              o3.change((t6) => {
                for (const e6 of r3.values())
                  t6.removeClass(i3, e6), r3.delete(e6);
              });
            }
            t5.on("insert", e5, { priority: "highest" }), t5.on("remove", e5, { priority: "highest" }), t5.on("attribute", e5, { priority: "highest" }), t5.on("selection", e5, { priority: "highest" });
          });
        }
        const Ak2 = "code";
        class Ck2 extends bs {
          static get pluginName() {
            return "CodeEditing";
          }
          static get requires() {
            return [rk2];
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: Ak2 }), t4.model.schema.setAttributeProperties(Ak2, { isFormatting: true, copyOnEnter: false }), t4.conversion.attributeToElement({ model: Ak2, view: "code", upcastAlso: { styles: { "word-wrap": "break-word" } } }), t4.commands.add(Ak2, new Rf2(t4, Ak2)), t4.plugins.get(rk2).registerAttribute(Ak2), wk2(t4, Ak2, "code", "ck-code_selected");
          }
        }
        var _k = n2(5363), vk2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(_k.Z, vk2);
        _k.Z.locals;
        const yk2 = "code";
        class xk2 extends bs {
          static get pluginName() {
            return "CodeUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add(yk2, (n3) => {
              const i3 = t4.commands.get(yk2), o3 = new kr(n3);
              return o3.set({ label: e4("Code"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 5.7 5.2 3.9v1.3l-5.6 4c-.1.2-.3.2-.5.2-.3-.1-.6-.7-.6-1l.3-.4 4.7-3.5L11.5 7l-.2-.2c-.1-.3-.1-.6 0-.8.2-.2.5-.4.8-.4a.8.8 0 0 1 .4.1zm-5.2 0L2 9.6v1.3l5.6 4c.1.2.3.2.5.2.3-.1.7-.7.6-1 0-.1 0-.3-.2-.4l-5-3.5L8.2 7l.2-.2c.1-.3.1-.6 0-.8-.2-.2-.5-.4-.8-.4a.8.8 0 0 0-.3.1z"/></svg>', tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute(yk2), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        const Ek2 = "italic";
        class Dk2 extends bs {
          static get pluginName() {
            return "ItalicEditing";
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: Ek2 }), t4.model.schema.setAttributeProperties(Ek2, { isFormatting: true, copyOnEnter: true }), t4.conversion.attributeToElement({ model: Ek2, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), t4.commands.add(Ek2, new Rf2(t4, Ek2)), t4.keystrokes.set("CTRL+I", Ek2);
          }
        }
        const Sk2 = "italic";
        class Tk2 extends bs {
          static get pluginName() {
            return "ItalicUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add(Sk2, (n3) => {
              const i3 = t4.commands.get(Sk2), o3 = new kr(n3);
              return o3.set({ label: e4("Italic"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', keystroke: "CTRL+I", tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute(Sk2), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        const Ik2 = "strikethrough";
        class Bk2 extends bs {
          static get pluginName() {
            return "StrikethroughEditing";
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: Ik2 }), t4.model.schema.setAttributeProperties(Ik2, { isFormatting: true, copyOnEnter: true }), t4.conversion.attributeToElement({ model: Ik2, view: "s", upcastAlso: ["del", "strike", { styles: { "text-decoration": "line-through" } }] }), t4.commands.add(Ik2, new Rf2(t4, Ik2)), t4.keystrokes.set("CTRL+SHIFT+X", "strikethrough");
          }
        }
        const Mk2 = "strikethrough";
        class Nk2 extends bs {
          static get pluginName() {
            return "StrikethroughUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add(Mk2, (n3) => {
              const i3 = t4.commands.get(Mk2), o3 = new kr(n3);
              return o3.set({ label: e4("Strikethrough"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 16.4c-.8-.4-1.5-.9-2.2-1.5a.6.6 0 0 1-.2-.5l.3-.6h1c1 1.2 2.1 1.7 3.7 1.7 1 0 1.8-.3 2.3-.6.6-.4.6-1.2.6-1.3.2-1.2-.9-2.1-.9-2.1h2.1c.3.7.4 1.2.4 1.7v.8l-.6 1.2c-.6.8-1.1 1-1.6 1.2a6 6 0 0 1-2.4.6c-1 0-1.8-.3-2.5-.6zM6.8 9 6 8.3c-.4-.5-.5-.8-.5-1.6 0-.7.1-1.3.5-1.8.4-.6 1-1 1.6-1.3a6.3 6.3 0 0 1 4.7 0 4 4 0 0 1 1.7 1l.3.7c0 .1.2.4-.2.7-.4.2-.9.1-1 0a3 3 0 0 0-1.2-1c-.4-.2-1-.3-2-.4-.7 0-1.4.2-2 .6-.8.6-1 .8-1 1.5 0 .8.5 1 1.2 1.5.6.4 1.1.7 1.9 1H6.8z"/><path d="M3 10.5V9h14v1.5z"/></svg>', keystroke: "CTRL+SHIFT+X", tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute(Mk2), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        const Lk2 = "subscript";
        class zk2 extends bs {
          static get pluginName() {
            return "SubscriptEditing";
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: Lk2 }), t4.model.schema.setAttributeProperties(Lk2, { isFormatting: true, copyOnEnter: true }), t4.conversion.attributeToElement({ model: Lk2, view: "sub", upcastAlso: [{ styles: { "vertical-align": "sub" } }] }), t4.commands.add(Lk2, new Rf2(t4, Lk2));
          }
        }
        const Pk2 = "subscript";
        class Rk2 extends bs {
          static get pluginName() {
            return "SubscriptUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add(Pk2, (n3) => {
              const i3 = t4.commands.get(Pk2), o3 = new kr(n3);
              return o3.set({ label: e4("Subscript"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.03 10.349 3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82zm8.147 7.829h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309z"/></svg>', tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute(Pk2), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        const Ok2 = "superscript";
        class Fk2 extends bs {
          static get pluginName() {
            return "SuperscriptEditing";
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: Ok2 }), t4.model.schema.setAttributeProperties(Ok2, { isFormatting: true, copyOnEnter: true }), t4.conversion.attributeToElement({ model: Ok2, view: "sup", upcastAlso: [{ styles: { "vertical-align": "super" } }] }), t4.commands.add(Ok2, new Rf2(t4, Ok2));
          }
        }
        const Vk2 = "superscript";
        class jk2 extends bs {
          static get pluginName() {
            return "SuperscriptUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add(Vk2, (n3) => {
              const i3 = t4.commands.get(Vk2), o3 = new kr(n3);
              return o3.set({ label: e4("Superscript"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M15.677 8.678h2.549c.254 0 .447.05.58.152a.49.49 0 0 1 .201.413.54.54 0 0 1-.159.393c-.105.108-.266.162-.48.162h-3.594c-.245 0-.435-.066-.572-.197a.621.621 0 0 1-.205-.463c0-.114.044-.265.132-.453a1.62 1.62 0 0 1 .288-.444c.433-.436.824-.81 1.172-1.122.348-.312.597-.517.747-.615.267-.183.49-.368.667-.553.177-.185.312-.375.405-.57.093-.194.139-.384.139-.57a1.008 1.008 0 0 0-.554-.917 1.197 1.197 0 0 0-.56-.133c-.426 0-.761.182-1.005.546a2.332 2.332 0 0 0-.164.39 1.609 1.609 0 0 1-.258.488c-.096.114-.237.17-.423.17a.558.558 0 0 1-.405-.156.568.568 0 0 1-.161-.427c0-.218.05-.446.151-.683.101-.238.252-.453.452-.646s.454-.349.762-.467a2.998 2.998 0 0 1 1.081-.178c.498 0 .923.076 1.274.228a1.916 1.916 0 0 1 1.004 1.032 1.984 1.984 0 0 1-.156 1.794c-.2.32-.405.572-.613.754-.208.182-.558.468-1.048.857-.49.39-.826.691-1.008.906a2.703 2.703 0 0 0-.24.309zM7.03 10.349l3.818-3.819a.8.8 0 1 1 1.132 1.132L8.16 11.48l3.819 3.818a.8.8 0 1 1-1.132 1.132L7.03 12.61l-3.818 3.82a.8.8 0 1 1-1.132-1.132L5.9 11.48 2.08 7.662A.8.8 0 1 1 3.212 6.53l3.818 3.82z"/></svg>', tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute(Vk2), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        const Hk2 = "underline";
        class Uk2 extends bs {
          static get pluginName() {
            return "UnderlineEditing";
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: Hk2 }), t4.model.schema.setAttributeProperties(Hk2, { isFormatting: true, copyOnEnter: true }), t4.conversion.attributeToElement({ model: Hk2, view: "u", upcastAlso: { styles: { "text-decoration": "underline" } } }), t4.commands.add(Hk2, new Rf2(t4, Hk2)), t4.keystrokes.set("CTRL+U", "underline");
          }
        }
        const Gk2 = "underline";
        class Wk2 extends bs {
          static get pluginName() {
            return "UnderlineUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add(Gk2, (n3) => {
              const i3 = t4.commands.get(Gk2), o3 = new kr(n3);
              return o3.set({ label: e4("Underline"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 18v-1.5h14V18zm2.2-8V3.6c0-.4.4-.6.8-.6.3 0 .7.2.7.6v6.2c0 2 1.3 2.8 3.2 2.8 1.9 0 3.4-.9 3.4-2.9V3.6c0-.3.4-.5.8-.5.3 0 .7.2.7.5V10c0 2.7-2.2 4-4.9 4-2.6 0-4.7-1.2-4.7-4z"/></svg>', keystroke: "CTRL+U", tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute(Gk2), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        function* qk2(t4, e4) {
          for (const n3 of e4)
            n3 && t4.getAttributeProperties(n3[0]).copyOnEnter && (yield n3);
        }
        class $k2 extends As {
          execute() {
            this.editor.model.change((t4) => {
              this.enterBlock(t4), this.fire("afterExecute", { writer: t4 });
            });
          }
          enterBlock(t4) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = e4.schema, o3 = n3.isCollapsed, r3 = n3.getFirstRange(), s3 = r3.start.parent, a3 = r3.end.parent;
            if (i3.isLimit(s3) || i3.isLimit(a3))
              return o3 || s3 != a3 || e4.deleteContent(n3), false;
            if (o3) {
              const e5 = qk2(t4.model.schema, n3.getAttributes());
              return Kk2(t4, r3.start), t4.setSelectionAttribute(e5), true;
            }
            {
              const i4 = !(r3.start.isAtStart && r3.end.isAtEnd), o4 = s3 == a3;
              if (e4.deleteContent(n3, { leaveUnmerged: i4 }), i4) {
                if (o4)
                  return Kk2(t4, n3.focus), true;
                t4.setSelection(a3, 0);
              }
            }
            return false;
          }
        }
        function Kk2(t4, e4) {
          t4.split(e4), t4.setSelection(e4.parent.nextSibling, 0);
        }
        const Zk2 = { insertParagraph: { isSoft: false }, insertLineBreak: { isSoft: true } };
        class Yk2 extends el2 {
          constructor(t4) {
            super(t4);
            const e4 = this.document;
            let n3 = false;
            e4.on("keydown", (t5, e5) => {
              n3 = e5.shiftKey;
            }), e4.on("beforeinput", (i3, o3) => {
              if (!this.isEnabled)
                return;
              let r3 = o3.inputType;
              c2.isSafari && n3 && "insertParagraph" == r3 && (r3 = "insertLineBreak");
              const s3 = o3.domEvent, a3 = Zk2[r3];
              if (!a3)
                return;
              const l3 = new Ja2(e4, "enter", o3.targetRanges[0]);
              e4.fire(l3, new il2(t4, s3, { isSoft: a3.isSoft })), l3.stop.called && i3.stop();
            });
          }
          observe() {
          }
          stopObserving() {
          }
        }
        class Qk2 extends bs {
          static get pluginName() {
            return "Enter";
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document;
            e4.addObserver(Yk2), t4.commands.add("enter", new $k2(t4)), this.listenTo(n3, "enter", (i3, o3) => {
              n3.isComposing || o3.preventDefault(), o3.isSoft || (t4.execute("enter"), e4.scrollToTheSelection());
            }, { priority: "low" });
          }
        }
        class Jk2 extends As {
          execute() {
            const t4 = this.editor.model, e4 = t4.document;
            t4.change((n3) => {
              !function(t5, e5, n4) {
                const i3 = n4.isCollapsed, o3 = n4.getFirstRange(), r3 = o3.start.parent, s3 = o3.end.parent, a3 = r3 == s3;
                if (i3) {
                  const i4 = qk2(t5.schema, n4.getAttributes());
                  Xk2(t5, e5, o3.end), e5.removeSelectionAttribute(n4.getAttributeKeys()), e5.setSelectionAttribute(i4);
                } else {
                  const i4 = !(o3.start.isAtStart && o3.end.isAtEnd);
                  t5.deleteContent(n4, { leaveUnmerged: i4 }), a3 ? Xk2(t5, e5, n4.focus) : i4 && e5.setSelection(s3, 0);
                }
              }(t4, n3, e4.selection), this.fire("afterExecute", { writer: n3 });
            });
          }
          refresh() {
            const t4 = this.editor.model, e4 = t4.document;
            this.isEnabled = function(t5, e5) {
              if (e5.rangeCount > 1)
                return false;
              const n3 = e5.anchor;
              if (!n3 || !t5.checkChild(n3, "softBreak"))
                return false;
              const i3 = e5.getFirstRange(), o3 = i3.start.parent, r3 = i3.end.parent;
              if ((tb2(o3, t5) || tb2(r3, t5)) && o3 !== r3)
                return false;
              return true;
            }(t4.schema, e4.selection);
          }
        }
        function Xk2(t4, e4, n3) {
          const i3 = e4.createElement("softBreak");
          t4.insertContent(i3, n3), e4.setSelection(i3, "after");
        }
        function tb2(t4, e4) {
          return !t4.is("rootElement") && (e4.isLimit(t4) || tb2(t4.parent, e4));
        }
        class eb2 extends bs {
          static get pluginName() {
            return "ShiftEnter";
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.conversion, i3 = t4.editing.view, o3 = i3.document;
            e4.register("softBreak", { allowWhere: "$text", isInline: true }), n3.for("upcast").elementToElement({ model: "softBreak", view: "br" }), n3.for("downcast").elementToElement({ model: "softBreak", view: (t5, { writer: e5 }) => e5.createEmptyElement("br") }), i3.addObserver(Yk2), t4.commands.add("shiftEnter", new Jk2(t4)), this.listenTo(o3, "enter", (e5, n4) => {
              o3.isComposing || n4.preventDefault(), n4.isSoft && (t4.execute("shiftEnter"), i3.scrollToTheSelection());
            }, { priority: "low" });
          }
        }
        class nb2 extends As {
          refresh() {
            this.value = this._getValue(), this.isEnabled = this._checkEnabled();
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.schema, i3 = e4.document.selection, o3 = Array.from(i3.getSelectedBlocks()), r3 = void 0 === t4.forceValue ? !this.value : t4.forceValue;
            e4.change((t5) => {
              if (r3) {
                const e5 = o3.filter((t6) => ib2(t6) || rb2(n3, t6));
                this._applyQuote(t5, e5);
              } else
                this._removeQuote(t5, o3.filter(ib2));
            });
          }
          _getValue() {
            const t4 = So2(this.editor.model.document.selection.getSelectedBlocks());
            return !(!t4 || !ib2(t4));
          }
          _checkEnabled() {
            if (this.value)
              return true;
            const t4 = this.editor.model.document.selection, e4 = this.editor.model.schema, n3 = So2(t4.getSelectedBlocks());
            return !!n3 && rb2(e4, n3);
          }
          _removeQuote(t4, e4) {
            ob2(t4, e4).reverse().forEach((e5) => {
              if (e5.start.isAtStart && e5.end.isAtEnd)
                return void t4.unwrap(e5.start.parent);
              if (e5.start.isAtStart) {
                const n4 = t4.createPositionBefore(e5.start.parent);
                return void t4.move(e5, n4);
              }
              e5.end.isAtEnd || t4.split(e5.end);
              const n3 = t4.createPositionAfter(e5.end.parent);
              t4.move(e5, n3);
            });
          }
          _applyQuote(t4, e4) {
            const n3 = [];
            ob2(t4, e4).reverse().forEach((e5) => {
              let i3 = ib2(e5.start);
              i3 || (i3 = t4.createElement("blockQuote"), t4.wrap(e5, i3)), n3.push(i3);
            }), n3.reverse().reduce((e5, n4) => e5.nextSibling == n4 ? (t4.merge(t4.createPositionAfter(e5)), e5) : n4);
          }
        }
        function ib2(t4) {
          return "blockQuote" == t4.parent.name ? t4.parent : null;
        }
        function ob2(t4, e4) {
          let n3, i3 = 0;
          const o3 = [];
          for (; i3 < e4.length; ) {
            const r3 = e4[i3], s3 = e4[i3 + 1];
            n3 || (n3 = t4.createPositionBefore(r3)), s3 && r3.nextSibling == s3 || (o3.push(t4.createRange(n3, t4.createPositionAfter(r3))), n3 = null), i3++;
          }
          return o3;
        }
        function rb2(t4, e4) {
          const n3 = t4.checkChild(e4.parent, "blockQuote"), i3 = t4.checkChild(["$root", "blockQuote"], e4);
          return n3 && i3;
        }
        class sb2 extends bs {
          static get pluginName() {
            return "BlockQuoteEditing";
          }
          static get requires() {
            return [Qk2, ek2];
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema;
            t4.commands.add("blockQuote", new nb2(t4)), e4.register("blockQuote", { inheritAllFrom: "$container" }), t4.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), t4.model.document.registerPostFixer((n4) => {
              const i4 = t4.model.document.differ.getChanges();
              for (const t5 of i4)
                if ("insert" == t5.type) {
                  const i5 = t5.position.nodeAfter;
                  if (!i5)
                    continue;
                  if (i5.is("element", "blockQuote") && i5.isEmpty)
                    return n4.remove(i5), true;
                  if (i5.is("element", "blockQuote") && !e4.checkChild(t5.position, i5))
                    return n4.unwrap(i5), true;
                  if (i5.is("element")) {
                    const t6 = n4.createRangeIn(i5);
                    for (const i6 of t6.getItems())
                      if (i6.is("element", "blockQuote") && !e4.checkChild(n4.createPositionBefore(i6), i6))
                        return n4.unwrap(i6), true;
                  }
                } else if ("remove" == t5.type) {
                  const e5 = t5.position.parent;
                  if (e5.is("element", "blockQuote") && e5.isEmpty)
                    return n4.remove(e5), true;
                }
              return false;
            });
            const n3 = this.editor.editing.view.document, i3 = t4.model.document.selection, o3 = t4.commands.get("blockQuote");
            this.listenTo(n3, "enter", (e5, n4) => {
              if (!i3.isCollapsed || !o3.value)
                return;
              i3.getLastPosition().parent.isEmpty && (t4.execute("blockQuote"), t4.editing.view.scrollToTheSelection(), n4.preventDefault(), e5.stop());
            }, { context: "blockquote" }), this.listenTo(n3, "delete", (e5, n4) => {
              if ("backward" != n4.direction || !i3.isCollapsed || !o3.value)
                return;
              const r3 = i3.getLastPosition().parent;
              r3.isEmpty && !r3.previousSibling && (t4.execute("blockQuote"), t4.editing.view.scrollToTheSelection(), n4.preventDefault(), e5.stop());
            }, { context: "blockquote" });
          }
        }
        var ab2 = n2(3789), cb2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(ab2.Z, cb2);
        ab2.Z.locals;
        class lb2 extends bs {
          static get pluginName() {
            return "BlockQuoteUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add("blockQuote", (n3) => {
              const i3 = t4.commands.get("blockQuote"), o3 = new kr(n3);
              return o3.set({ label: e4("Block quote"), icon: Pg2.quote, tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute("blockQuote"), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        function db2(t4) {
          const e4 = t4.t, n3 = t4.config.get("codeBlock.languages");
          for (const t5 of n3)
            "Plain text" === t5.label && (t5.label = e4("Plain text")), void 0 === t5.class && (t5.class = `language-${t5.language}`);
          return n3;
        }
        function hb2(t4, e4, n3) {
          const i3 = {};
          for (const o3 of t4)
            if ("class" === e4) {
              i3[o3[e4].split(" ").shift()] = o3[n3];
            } else
              i3[o3[e4]] = o3[n3];
          return i3;
        }
        function ub2(t4) {
          return t4.data.match(/^(\s*)/)[0];
        }
        function gb2(t4) {
          const e4 = t4.document.selection, n3 = [];
          if (e4.isCollapsed)
            return [e4.anchor];
          const i3 = e4.getFirstRange().getWalker({ ignoreElementEnd: true, direction: "backward" });
          for (const { item: e5 } of i3) {
            if (!e5.is("$textProxy"))
              continue;
            const { parent: i4, startOffset: o3 } = e5.textNode;
            if (!i4.is("element", "codeBlock"))
              continue;
            const r3 = ub2(e5.textNode), s3 = t4.createPositionAt(i4, o3 + r3.length);
            n3.push(s3);
          }
          return n3;
        }
        function mb2(t4) {
          const e4 = So2(t4.getSelectedBlocks());
          return !!e4 && e4.is("element", "codeBlock");
        }
        function pb2(t4, e4) {
          return !e4.is("rootElement") && !t4.isLimit(e4) && t4.checkChild(e4.parent, "codeBlock");
        }
        class fb2 extends As {
          constructor(t4) {
            super(t4), this._lastLanguage = null;
          }
          refresh() {
            this.value = this._getValue(), this.isEnabled = this._checkEnabled();
          }
          execute(t4 = {}) {
            const e4 = this.editor, n3 = e4.model, i3 = n3.document.selection, o3 = db2(e4)[0], r3 = Array.from(i3.getSelectedBlocks()), s3 = null == t4.forceValue ? !this.value : t4.forceValue, a3 = function(t5, e5, n4) {
              if (t5.language)
                return t5.language;
              if (t5.usePreviousLanguageChoice && e5)
                return e5;
              return n4;
            }(t4, this._lastLanguage, o3.language);
            n3.change((t5) => {
              s3 ? this._applyCodeBlock(t5, r3, a3) : this._removeCodeBlock(t5, r3);
            });
          }
          _getValue() {
            const t4 = So2(this.editor.model.document.selection.getSelectedBlocks());
            return !!!(!t4 || !t4.is("element", "codeBlock")) && t4.getAttribute("language");
          }
          _checkEnabled() {
            if (this.value)
              return true;
            const t4 = this.editor.model.document.selection, e4 = this.editor.model.schema, n3 = So2(t4.getSelectedBlocks());
            return !!n3 && pb2(e4, n3);
          }
          _applyCodeBlock(t4, e4, n3) {
            this._lastLanguage = n3;
            const i3 = this.editor.model.schema, o3 = e4.filter((t5) => pb2(i3, t5));
            for (const e5 of o3)
              t4.rename(e5, "codeBlock"), t4.setAttribute("language", n3, e5), i3.removeDisallowedAttributes([e5], t4), Array.from(e5.getChildren()).filter((t5) => !i3.checkChild(e5, t5)).forEach((e6) => t4.remove(e6));
            o3.reverse().forEach((e5, n4) => {
              const i4 = o3[n4 + 1];
              e5.previousSibling === i4 && (t4.appendElement("softBreak", i4), t4.merge(t4.createPositionBefore(e5)));
            });
          }
          _removeCodeBlock(t4, e4) {
            const n3 = e4.filter((t5) => t5.is("element", "codeBlock"));
            for (const e5 of n3) {
              const n4 = t4.createRangeOn(e5);
              for (const e6 of Array.from(n4.getItems()).reverse())
                if (e6.is("element", "softBreak") && e6.parent.is("element", "codeBlock")) {
                  const { position: n5 } = t4.split(t4.createPositionBefore(e6)), i3 = n5.nodeAfter;
                  t4.rename(i3, "paragraph"), t4.removeAttribute("language", i3), t4.remove(e6);
                }
              t4.rename(e5, "paragraph"), t4.removeAttribute("language", e5);
            }
          }
        }
        class kb2 extends As {
          constructor(t4) {
            super(t4), this._indentSequence = t4.config.get("codeBlock.indentSequence");
          }
          refresh() {
            this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t4 = this.editor.model;
            t4.change((e4) => {
              const n3 = gb2(t4);
              for (const i3 of n3) {
                const n4 = e4.createText(this._indentSequence);
                t4.insertContent(n4, i3);
              }
            });
          }
          _checkEnabled() {
            return !!this._indentSequence && mb2(this.editor.model.document.selection);
          }
        }
        class bb2 extends As {
          constructor(t4) {
            super(t4), this._indentSequence = t4.config.get("codeBlock.indentSequence");
          }
          refresh() {
            this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t4 = this.editor.model;
            t4.change(() => {
              const e4 = gb2(t4);
              for (const n3 of e4) {
                const e5 = wb2(t4, n3, this._indentSequence);
                e5 && t4.deleteContent(t4.createSelection(e5));
              }
            });
          }
          _checkEnabled() {
            if (!this._indentSequence)
              return false;
            const t4 = this.editor.model;
            return !!mb2(t4.document.selection) && gb2(t4).some((e4) => wb2(t4, e4, this._indentSequence));
          }
        }
        function wb2(t4, e4, n3) {
          const i3 = function(t5) {
            let e5 = t5.parent.getChild(t5.index);
            e5 && !e5.is("element", "softBreak") || (e5 = t5.nodeBefore);
            if (!e5 || e5.is("element", "softBreak"))
              return null;
            return e5;
          }(e4);
          if (!i3)
            return null;
          const o3 = ub2(i3), r3 = o3.lastIndexOf(n3);
          if (r3 + n3.length !== o3.length)
            return null;
          if (-1 === r3)
            return null;
          const { parent: s3, startOffset: a3 } = i3;
          return t4.createRange(t4.createPositionAt(s3, a3 + r3), t4.createPositionAt(s3, a3 + r3 + n3.length));
        }
        function Ab2(t4, e4, n3 = false) {
          const i3 = hb2(e4, "language", "class"), o3 = hb2(e4, "language", "label");
          return (e5, r3, s3) => {
            const { writer: a3, mapper: c3, consumable: l3 } = s3;
            if (!l3.consume(r3.item, "insert"))
              return;
            const d3 = r3.item.getAttribute("language"), h3 = c3.toViewPosition(t4.createPositionBefore(r3.item)), u3 = {};
            n3 && (u3["data-language"] = o3[d3], u3.spellcheck = "false");
            const g3 = i3[d3] ? { class: i3[d3] } : void 0, m3 = a3.createContainerElement("code", g3), p3 = a3.createContainerElement("pre", u3, m3);
            a3.insert(h3, p3), c3.bindElements(r3.item, m3);
          };
        }
        const Cb2 = "paragraph";
        class _b extends bs {
          static get pluginName() {
            return "CodeBlockEditing";
          }
          static get requires() {
            return [eb2];
          }
          constructor(t4) {
            super(t4), t4.config.define("codeBlock", { languages: [{ language: "plaintext", label: "Plain text" }, { language: "c", label: "C" }, { language: "cs", label: "C#" }, { language: "cpp", label: "C++" }, { language: "css", label: "CSS" }, { language: "diff", label: "Diff" }, { language: "html", label: "HTML" }, { language: "java", label: "Java" }, { language: "javascript", label: "JavaScript" }, { language: "php", label: "PHP" }, { language: "python", label: "Python" }, { language: "ruby", label: "Ruby" }, { language: "typescript", label: "TypeScript" }, { language: "xml", label: "XML" }], indentSequence: "	" });
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.model, i3 = t4.editing.view, o3 = t4.plugins.has("DocumentListEditing") ? t4.plugins.get("DocumentListEditing") : null, r3 = db2(t4);
            t4.commands.add("codeBlock", new fb2(t4)), t4.commands.add("indentCodeBlock", new kb2(t4)), t4.commands.add("outdentCodeBlock", new bb2(t4)), this.listenTo(i3.document, "tab", (e5, n4) => {
              const i4 = n4.shiftKey ? "outdentCodeBlock" : "indentCodeBlock";
              t4.commands.get(i4).isEnabled && (t4.execute(i4), n4.stopPropagation(), n4.preventDefault(), e5.stop());
            }, { context: "pre" }), e4.register("codeBlock", { allowWhere: "$block", allowChildren: "$text", isBlock: true, allowAttributes: ["language"] }), e4.addAttributeCheck((t5, e5) => !!(t5.endsWith("codeBlock") && o3 && o3.getListAttributeNames().includes(e5)) || !t5.endsWith("codeBlock $text") && void 0), t4.model.schema.addChildCheck((t5, e5) => {
              if (t5.endsWith("codeBlock") && e5.isObject)
                return false;
            }), t4.editing.downcastDispatcher.on("insert:codeBlock", Ab2(n3, r3, true)), t4.data.downcastDispatcher.on("insert:codeBlock", Ab2(n3, r3)), t4.data.downcastDispatcher.on("insert:softBreak", function(t5) {
              return (e5, n4, i4) => {
                if ("codeBlock" !== n4.item.parent.name)
                  return;
                const { writer: o4, mapper: r4, consumable: s3 } = i4;
                if (!s3.consume(n4.item, "insert"))
                  return;
                const a3 = r4.toViewPosition(t5.createPositionBefore(n4.item));
                o4.insert(a3, o4.createText("\n"));
              };
            }(n3), { priority: "high" }), t4.data.upcastDispatcher.on("element:code", function(t5, e5) {
              const n4 = hb2(e5, "class", "language"), i4 = e5[0].language;
              return (t6, e6, o4) => {
                const r4 = e6.viewItem, s3 = r4.parent;
                if (!s3 || !s3.is("element", "pre"))
                  return;
                if (e6.modelCursor.findAncestor("codeBlock"))
                  return;
                const { consumable: a3, writer: c3 } = o4;
                if (!a3.test(r4, { name: true }))
                  return;
                const l3 = c3.createElement("codeBlock"), d3 = [...r4.getClassNames()];
                d3.length || d3.push("");
                for (const t7 of d3) {
                  const e7 = n4[t7];
                  if (e7) {
                    c3.setAttribute("language", e7, l3);
                    break;
                  }
                }
                l3.hasAttribute("language") || c3.setAttribute("language", i4, l3), o4.convertChildren(r4, l3), o4.safeInsert(l3, e6.modelCursor) && (a3.consume(r4, { name: true }), o4.updateConversionResult(l3, e6));
              };
            }(0, r3)), t4.data.upcastDispatcher.on("text", (t5, e5, { consumable: n4, writer: i4 }) => {
              let o4 = e5.modelCursor;
              if (!n4.test(e5.viewItem))
                return;
              if (!o4.findAncestor("codeBlock"))
                return;
              n4.consume(e5.viewItem);
              const r4 = e5.viewItem.data.split("\n").map((t6) => i4.createText(t6)), s3 = r4[r4.length - 1];
              for (const t6 of r4)
                if (i4.insert(t6, o4), o4 = o4.getShiftedBy(t6.offsetSize), t6 !== s3) {
                  const t7 = i4.createElement("softBreak");
                  i4.insert(t7, o4), o4 = i4.createPositionAfter(t7);
                }
              e5.modelRange = i4.createRange(e5.modelCursor, o4), e5.modelCursor = o4;
            }), t4.data.upcastDispatcher.on("element:pre", (t5, e5, { consumable: n4 }) => {
              const i4 = e5.viewItem;
              if (i4.findAncestor("pre"))
                return;
              const o4 = Array.from(i4.getChildren()), r4 = o4.find((t6) => t6.is("element", "code"));
              if (r4)
                for (const t6 of o4)
                  t6 !== r4 && t6.is("$text") && n4.consume(t6, { name: true });
            }, { priority: "high" }), this.listenTo(t4.editing.view.document, "clipboardInput", (e5, i4) => {
              let o4 = n3.createRange(n3.document.selection.anchor);
              if (i4.targetRanges && (o4 = t4.editing.mapper.toModelRange(i4.targetRanges[0])), !o4.start.parent.is("element", "codeBlock"))
                return;
              const r4 = i4.dataTransfer.getData("text/plain"), s3 = new ju(t4.editing.view.document);
              i4.content = function(t5, e6) {
                const n4 = t5.createDocumentFragment(), i5 = e6.split("\n"), o5 = i5.reduce((e7, n5, o6) => (e7.push(n5), o6 < i5.length - 1 && e7.push(t5.createElement("br")), e7), []);
                return t5.appendChild(o5, n4), n4;
              }(s3, r4);
            }), this.listenTo(n3, "getSelectedContent", (t5, [i4]) => {
              const o4 = i4.anchor;
              !i4.isCollapsed && o4.parent.is("element", "codeBlock") && o4.hasSameParentAs(i4.focus) && n3.change((n4) => {
                const r4 = t5.return;
                if (o4.parent.is("element") && (r4.childCount > 1 || i4.containsEntireContent(o4.parent))) {
                  const e5 = n4.createElement("codeBlock", o4.parent.getAttributes());
                  n4.append(r4, e5);
                  const i5 = n4.createDocumentFragment();
                  return n4.append(e5, i5), void (t5.return = i5);
                }
                const s3 = r4.getChild(0);
                e4.checkAttribute(s3, "code") && n4.setAttribute("code", true, s3);
              });
            });
          }
          afterInit() {
            const t4 = this.editor, e4 = t4.commands, n3 = e4.get("indent"), i3 = e4.get("outdent");
            n3 && n3.registerChildCommand(e4.get("indentCodeBlock"), { priority: "highest" }), i3 && i3.registerChildCommand(e4.get("outdentCodeBlock")), this.listenTo(t4.editing.view.document, "enter", (e5, n4) => {
              t4.model.document.selection.getLastPosition().parent.is("element", "codeBlock") && (function(t5, e6) {
                const n5 = t5.model, i4 = n5.document, o3 = t5.editing.view, r3 = i4.selection.getLastPosition(), s3 = r3.nodeAfter;
                if (e6 || !i4.selection.isCollapsed || !r3.isAtStart)
                  return false;
                if (!yb2(s3))
                  return false;
                return t5.model.change((e7) => {
                  t5.execute("enter");
                  const n6 = i4.selection.anchor.parent.previousSibling;
                  e7.rename(n6, Cb2), e7.setSelection(n6, "in"), t5.model.schema.removeDisallowedAttributes([n6], e7), e7.remove(s3);
                }), o3.scrollToTheSelection(), true;
              }(t4, n4.isSoft) || function(t5, e6) {
                const n5 = t5.model, i4 = n5.document, o3 = t5.editing.view, r3 = i4.selection.getLastPosition(), s3 = r3.nodeBefore;
                let a3;
                if (e6 || !i4.selection.isCollapsed || !r3.isAtEnd || !s3 || !s3.previousSibling)
                  return false;
                if (yb2(s3) && yb2(s3.previousSibling))
                  a3 = n5.createRange(n5.createPositionBefore(s3.previousSibling), n5.createPositionAfter(s3));
                else if (vb2(s3) && yb2(s3.previousSibling) && yb2(s3.previousSibling.previousSibling))
                  a3 = n5.createRange(n5.createPositionBefore(s3.previousSibling.previousSibling), n5.createPositionAfter(s3));
                else {
                  if (!(vb2(s3) && yb2(s3.previousSibling) && vb2(s3.previousSibling.previousSibling) && s3.previousSibling.previousSibling && yb2(s3.previousSibling.previousSibling.previousSibling)))
                    return false;
                  a3 = n5.createRange(n5.createPositionBefore(s3.previousSibling.previousSibling.previousSibling), n5.createPositionAfter(s3));
                }
                return t5.model.change((e7) => {
                  e7.remove(a3), t5.execute("enter");
                  const n6 = i4.selection.anchor.parent;
                  e7.rename(n6, Cb2), t5.model.schema.removeDisallowedAttributes([n6], e7);
                }), o3.scrollToTheSelection(), true;
              }(t4, n4.isSoft) || function(t5) {
                const e6 = t5.model, n5 = e6.document, i4 = n5.selection.getLastPosition(), o3 = i4.nodeBefore || i4.textNode;
                let r3;
                o3 && o3.is("$text") && (r3 = ub2(o3));
                t5.model.change((e7) => {
                  t5.execute("shiftEnter"), r3 && e7.insertText(r3, n5.selection.anchor);
                });
              }(t4), n4.preventDefault(), e5.stop());
            }, { context: "pre" });
          }
        }
        function vb2(t4) {
          return t4 && t4.is("$text") && !t4.data.match(/\S/);
        }
        function yb2(t4) {
          return t4 && t4.is("element", "softBreak");
        }
        var xb2 = n2(3229), Eb2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(xb2.Z, Eb2);
        xb2.Z.locals;
        class Db2 extends bs {
          static get pluginName() {
            return "CodeBlockUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.ui.componentFactory, i3 = db2(t4);
            n3.add("codeBlock", (n4) => {
              const o3 = t4.commands.get("codeBlock"), r3 = om(n4, Xg2), s3 = r3.buttonView, a3 = e4("Insert code block");
              return s3.set({ label: a3, tooltip: true, icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.87 12.61a.75.75 0 0 1-.089.976l-.085.07-3.154 2.254 3.412 2.414a.75.75 0 0 1 .237.95l-.057.095a.75.75 0 0 1-.95.237l-.096-.058-4.272-3.022-.003-1.223 4.01-2.867a.75.75 0 0 1 1.047.174zm2.795-.231.095.057 4.011 2.867-.003 1.223-4.272 3.022-.095.058a.75.75 0 0 1-.88-.151l-.07-.086-.058-.095a.75.75 0 0 1 .15-.88l.087-.07 3.412-2.414-3.154-2.253-.085-.071a.75.75 0 0 1 .862-1.207zM16 0a2 2 0 0 1 2 2v9.354l-.663-.492-.837-.001V2a.5.5 0 0 0-.5-.5H2a.5.5 0 0 0-.5.5v15a.5.5 0 0 0 .5.5h3.118L7.156 19H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h14zM5.009 15l.003 1H3v-1h2.009zm2.188-2-1.471 1H5v-1h2.197zM10 11v.095L8.668 12H7v-1h3zm4-2v1H7V9h7zm0-2v1H7V7h7zm-4-2v1H5V5h5zM6 3v1H3V3h3z"/></svg>', isToggleable: true }), s3.bind("isOn").to(o3, "value", (t5) => !!t5), s3.on("execute", () => {
                t4.execute("codeBlock", { usePreviousLanguageChoice: true }), t4.editing.view.focus();
              }), r3.on("execute", (e5) => {
                t4.execute("codeBlock", { language: e5.source._codeBlockLanguage, forceValue: true }), t4.editing.view.focus();
              }), r3.class = "ck-code-block-dropdown", r3.bind("isEnabled").to(o3), am(r3, () => this._getLanguageListItemDefinitions(i3), { role: "menu", ariaLabel: a3 }), r3;
            });
          }
          _getLanguageListItemDefinitions(t4) {
            const e4 = this.editor.commands.get("codeBlock"), n3 = new Do2();
            for (const i3 of t4) {
              const t5 = { type: "button", model: new Up({ _codeBlockLanguage: i3.language, label: i3.label, role: "menuitemradio", withText: true }) };
              t5.model.bind("isOn").to(e4, "value", (e5) => e5 === t5.model._codeBlockLanguage), n3.add(t5);
            }
            return n3;
          }
        }
        class Sb2 extends ol2 {
          constructor(t4) {
            super(t4), this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];
            const e4 = this.document;
            function n3(t5) {
              return (n4, i3) => {
                i3.preventDefault();
                const o3 = i3.dropRange ? [i3.dropRange] : null, r3 = new p2(e4, t5);
                e4.fire(r3, { dataTransfer: i3.dataTransfer, method: n4.name, targetRanges: o3, target: i3.target, domEvent: i3.domEvent }), r3.stop.called && i3.stopPropagation();
              };
            }
            this.listenTo(e4, "paste", n3("clipboardInput"), { priority: "low" }), this.listenTo(e4, "drop", n3("clipboardInput"), { priority: "low" }), this.listenTo(e4, "dragover", n3("dragging"), { priority: "low" });
          }
          onDomEvent(t4) {
            const e4 = "clipboardData" in t4 ? t4.clipboardData : t4.dataTransfer, n3 = "drop" == t4.type || "paste" == t4.type, i3 = { dataTransfer: new Nl(e4, { cacheFiles: n3 }) };
            "drop" != t4.type && "dragover" != t4.type || (i3.dropRange = function(t5, e5) {
              const n4 = e5.target.ownerDocument, i4 = e5.clientX, o3 = e5.clientY;
              let r3;
              n4.caretRangeFromPoint && n4.caretRangeFromPoint(i4, o3) ? r3 = n4.caretRangeFromPoint(i4, o3) : e5.rangeParent && (r3 = n4.createRange(), r3.setStart(e5.rangeParent, e5.rangeOffset), r3.collapse(true));
              if (r3)
                return t5.domConverter.domRangeToView(r3);
              return null;
            }(this.view, t4)), this.fire(t4.type, t4, i3);
          }
        }
        const Tb2 = ["figcaption", "li"], Ib2 = ["ol", "ul"];
        function Bb2(t4) {
          if (t4.is("$text") || t4.is("$textProxy"))
            return t4.data;
          if (t4.is("element", "img") && t4.hasAttribute("alt"))
            return t4.getAttribute("alt");
          if (t4.is("element", "br"))
            return "\n";
          let e4 = "", n3 = null;
          for (const i3 of t4.getChildren())
            e4 += Mb2(i3, n3) + Bb2(i3), n3 = i3;
          return e4;
        }
        function Mb2(t4, e4) {
          return e4 ? t4.is("element", "li") && !t4.isEmpty && t4.getChild(0).is("containerElement") || Ib2.includes(t4.name) && Ib2.includes(e4.name) ? "\n\n" : t4.is("containerElement") || e4.is("containerElement") ? Tb2.includes(t4.name) || Tb2.includes(e4.name) ? "\n" : "\n\n" : "" : "";
        }
        class Nb2 extends bs {
          static get pluginName() {
            return "ClipboardPipeline";
          }
          init() {
            this.editor.editing.view.addObserver(Sb2), this._setupPasteDrop(), this._setupCopyCut();
          }
          _fireOutputTransformationEvent(t4, e4, n3) {
            const i3 = this.editor.model.getSelectedContent(e4);
            this.fire("outputTransformation", { dataTransfer: t4, content: i3, method: n3 });
          }
          _setupPasteDrop() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, i3 = n3.document;
            this.listenTo(i3, "clipboardInput", (e5, n4) => {
              "paste" != n4.method || t4.model.canEditAt(t4.model.document.selection) || e5.stop();
            }, { priority: "highest" }), this.listenTo(i3, "clipboardInput", (t5, e5) => {
              const i4 = e5.dataTransfer;
              let o3;
              if (e5.content)
                o3 = e5.content;
              else {
                let t6 = "";
                i4.getData("text/html") ? t6 = function(t7) {
                  return t7.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t8, e6) => 1 == e6.length ? " " : e6).replace(/<!--[\s\S]*?-->/g, "");
                }(i4.getData("text/html")) : i4.getData("text/plain") && (((r3 = (r3 = i4.getData("text/plain")).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || r3.includes("<br>")) && (r3 = `<p>${r3}</p>`), t6 = r3), o3 = this.editor.data.htmlProcessor.toView(t6);
              }
              var r3;
              const s3 = new p2(this, "inputTransformation");
              this.fire(s3, { content: o3, dataTransfer: i4, targetRanges: e5.targetRanges, method: e5.method }), s3.stop.called && t5.stop(), n3.scrollToTheSelection();
            }, { priority: "low" }), this.listenTo(this, "inputTransformation", (t5, n4) => {
              if (n4.content.isEmpty)
                return;
              const i4 = this.editor.data.toModel(n4.content, "$clipboardHolder");
              0 != i4.childCount && (t5.stop(), e4.change(() => {
                this.fire("contentInsertion", { content: i4, method: n4.method, dataTransfer: n4.dataTransfer, targetRanges: n4.targetRanges });
              }));
            }, { priority: "low" }), this.listenTo(this, "contentInsertion", (t5, n4) => {
              n4.resultRange = e4.insertContent(n4.content);
            }, { priority: "low" });
          }
          _setupCopyCut() {
            const t4 = this.editor, e4 = t4.model.document, n3 = t4.editing.view.document, i3 = (t5, n4) => {
              const i4 = n4.dataTransfer;
              n4.preventDefault(), this._fireOutputTransformationEvent(i4, e4.selection, t5.name);
            };
            this.listenTo(n3, "copy", i3, { priority: "low" }), this.listenTo(n3, "cut", (e5, n4) => {
              t4.model.canEditAt(t4.model.document.selection) ? i3(e5, n4) : n4.preventDefault();
            }, { priority: "low" }), this.listenTo(this, "outputTransformation", (e5, i4) => {
              const o3 = t4.data.toView(i4.content);
              n3.fire("clipboardOutput", { dataTransfer: i4.dataTransfer, content: o3, method: i4.method });
            }, { priority: "low" }), this.listenTo(n3, "clipboardOutput", (n4, i4) => {
              i4.content.isEmpty || (i4.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(i4.content)), i4.dataTransfer.setData("text/plain", Bb2(i4.content))), "cut" == i4.method && t4.model.deleteContent(e4.selection);
            }, { priority: "low" });
          }
        }
        class Lb2 extends B2() {
          constructor() {
            super(...arguments), this._stack = [];
          }
          add(t4, e4) {
            const n3 = this._stack, i3 = n3[0];
            this._insertDescriptor(t4);
            const o3 = n3[0];
            i3 === o3 || zb2(i3, o3) || this.fire("change:top", { oldDescriptor: i3, newDescriptor: o3, writer: e4 });
          }
          remove(t4, e4) {
            const n3 = this._stack, i3 = n3[0];
            this._removeDescriptor(t4);
            const o3 = n3[0];
            i3 === o3 || zb2(i3, o3) || this.fire("change:top", { oldDescriptor: i3, newDescriptor: o3, writer: e4 });
          }
          _insertDescriptor(t4) {
            const e4 = this._stack, n3 = e4.findIndex((e5) => e5.id === t4.id);
            if (zb2(t4, e4[n3]))
              return;
            n3 > -1 && e4.splice(n3, 1);
            let i3 = 0;
            for (; e4[i3] && Pb2(e4[i3], t4); )
              i3++;
            e4.splice(i3, 0, t4);
          }
          _removeDescriptor(t4) {
            const e4 = this._stack, n3 = e4.findIndex((e5) => e5.id === t4);
            n3 > -1 && e4.splice(n3, 1);
          }
        }
        function zb2(t4, e4) {
          return t4 && e4 && t4.priority == e4.priority && Rb2(t4.classes) == Rb2(e4.classes);
        }
        function Pb2(t4, e4) {
          return t4.priority > e4.priority || !(t4.priority < e4.priority) && Rb2(t4.classes) > Rb2(e4.classes);
        }
        function Rb2(t4) {
          return Array.isArray(t4) ? t4.sort().join(",") : t4;
        }
        const Ob2 = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>', Fb2 = "ck-widget", Vb2 = "ck-widget_selected";
        function jb2(t4) {
          return !!t4.is("element") && !!t4.getCustomProperty("widget");
        }
        function Hb2(t4, e4, n3 = {}) {
          if (!t4.is("containerElement"))
            throw new C2("widget-to-widget-wrong-element-type", null, { element: t4 });
          return e4.setAttribute("contenteditable", "false", t4), e4.addClass(Fb2, t4), e4.setCustomProperty("widget", true, t4), t4.getFillerOffset = Kb2, e4.setCustomProperty("widgetLabel", [], t4), n3.label && function(t5, e5) {
            const n4 = t5.getCustomProperty("widgetLabel");
            n4.push(e5);
          }(t4, n3.label), n3.hasSelectionHandle && function(t5, e5) {
            const n4 = e5.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(t6) {
              const e6 = this.toDomElement(t6), n5 = new gr();
              return n5.set("content", Ob2), n5.render(), e6.appendChild(n5.element), e6;
            });
            e5.insert(e5.createPositionAt(t5, 0), n4), e5.addClass(["ck-widget_with-selection-handle"], t5);
          }(t4, e4), Wb2(t4, e4), t4;
        }
        function Ub2(t4, e4, n3) {
          if (e4.classes && n3.addClass(yo2(e4.classes), t4), e4.attributes)
            for (const i3 in e4.attributes)
              n3.setAttribute(i3, e4.attributes[i3], t4);
        }
        function Gb2(t4, e4, n3) {
          if (e4.classes && n3.removeClass(yo2(e4.classes), t4), e4.attributes)
            for (const i3 in e4.attributes)
              n3.removeAttribute(i3, t4);
        }
        function Wb2(t4, e4, n3 = Ub2, i3 = Gb2) {
          const o3 = new Lb2();
          o3.on("change:top", (e5, o4) => {
            o4.oldDescriptor && i3(t4, o4.oldDescriptor, o4.writer), o4.newDescriptor && n3(t4, o4.newDescriptor, o4.writer);
          });
          e4.setCustomProperty("addHighlight", (t5, e5, n4) => o3.add(e5, n4), t4), e4.setCustomProperty("removeHighlight", (t5, e5, n4) => o3.remove(e5, n4), t4);
        }
        function qb2(t4, e4, n3 = {}) {
          return e4.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t4), e4.setAttribute("role", "textbox", t4), n3.label && e4.setAttribute("aria-label", n3.label, t4), e4.setAttribute("contenteditable", t4.isReadOnly ? "false" : "true", t4), t4.on("change:isReadOnly", (n4, i3, o3) => {
            e4.setAttribute("contenteditable", o3 ? "false" : "true", t4);
          }), t4.on("change:isFocused", (n4, i3, o3) => {
            o3 ? e4.addClass("ck-editor__nested-editable_focused", t4) : e4.removeClass("ck-editor__nested-editable_focused", t4);
          }), Wb2(t4, e4), t4;
        }
        function $b2(t4, e4) {
          const n3 = t4.getSelectedElement();
          if (n3) {
            const i3 = Qb2(t4);
            if (i3)
              return e4.createRange(e4.createPositionAt(n3, i3));
          }
          return Iu(t4, e4);
        }
        function Kb2() {
          return null;
        }
        const Zb2 = "widget-type-around";
        function Yb2(t4, e4, n3) {
          return !!t4 && jb2(t4) && !n3.isInline(e4);
        }
        function Qb2(t4) {
          return t4.getAttribute(Zb2);
        }
        var Jb2 = n2(2347), Xb2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Jb2.Z, Xb2);
        Jb2.Z.locals;
        const tw = ["before", "after"], ew = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild, nw = "ck-widget__type-around_disabled";
        class iw extends bs {
          constructor() {
            super(...arguments), this._currentFakeCaretModelElement = null;
          }
          static get pluginName() {
            return "WidgetTypeAround";
          }
          static get requires() {
            return [Qk2, ek2];
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view;
            this.on("change:isEnabled", (n3, i3, o3) => {
              e4.change((t5) => {
                for (const n4 of e4.document.roots)
                  o3 ? t5.removeClass(nw, n4) : t5.addClass(nw, n4);
              }), o3 || t4.model.change((t5) => {
                t5.removeSelectionAttribute(Zb2);
              });
            }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
          }
          destroy() {
            super.destroy(), this._currentFakeCaretModelElement = null;
          }
          _insertParagraph(t4, e4) {
            const n3 = this.editor, i3 = n3.editing.view, o3 = n3.model.schema.getAttributesWithProperty(t4, "copyOnReplace", true);
            n3.execute("insertParagraph", { position: n3.model.createPositionAt(t4, e4), attributes: o3 }), i3.focus(), i3.scrollToTheSelection();
          }
          _listenToIfEnabled(t4, e4, n3, i3) {
            this.listenTo(t4, e4, (...t5) => {
              this.isEnabled && n3(...t5);
            }, i3);
          }
          _insertParagraphAccordingToFakeCaretPosition() {
            const t4 = this.editor.model.document.selection, e4 = Qb2(t4);
            if (!e4)
              return false;
            const n3 = t4.getSelectedElement();
            return this._insertParagraph(n3, e4), true;
          }
          _enableTypeAroundUIInjection() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.locale.t, i3 = { before: n3("Insert paragraph before block"), after: n3("Insert paragraph after block") };
            t4.editing.downcastDispatcher.on("insert", (t5, o3, r3) => {
              const s3 = r3.mapper.toViewElement(o3.item);
              if (s3 && Yb2(s3, o3.item, e4)) {
                !function(t6, e5, n4) {
                  const i4 = t6.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, function(t7) {
                    const n5 = this.toDomElement(t7);
                    return function(t8, e6) {
                      for (const n6 of tw) {
                        const i5 = new Uo2({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n6}`], title: e6[n6], "aria-hidden": "true" }, children: [t8.ownerDocument.importNode(ew, true)] });
                        t8.appendChild(i5.render());
                      }
                    }(n5, e5), function(t8) {
                      const e6 = new Uo2({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } });
                      t8.appendChild(e6.render());
                    }(n5), n5;
                  });
                  t6.insert(t6.createPositionAt(n4, "end"), i4);
                }(r3.writer, i3, s3);
                s3.getCustomProperty("widgetLabel").push(() => this.isEnabled ? n3("Press Enter to type after or press Shift + Enter to type before the widget") : "");
              }
            }, { priority: "low" });
          }
          _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
            const t4 = this.editor, e4 = t4.model, n3 = e4.document.selection, i3 = e4.schema, o3 = t4.editing.view;
            function r3(t5) {
              return `ck-widget_type-around_show-fake-caret_${t5}`;
            }
            this._listenToIfEnabled(o3.document, "arrowKey", (t5, e5) => {
              this._handleArrowKeyPress(t5, e5);
            }, { context: [jb2, "$text"], priority: "high" }), this._listenToIfEnabled(n3, "change:range", (e5, n4) => {
              n4.directChange && t4.model.change((t5) => {
                t5.removeSelectionAttribute(Zb2);
              });
            }), this._listenToIfEnabled(e4.document, "change:data", () => {
              const e5 = n3.getSelectedElement();
              if (e5) {
                if (Yb2(t4.editing.mapper.toViewElement(e5), e5, i3))
                  return;
              }
              t4.model.change((t5) => {
                t5.removeSelectionAttribute(Zb2);
              });
            }), this._listenToIfEnabled(t4.editing.downcastDispatcher, "selection", (t5, e5, n4) => {
              const o4 = n4.writer;
              if (this._currentFakeCaretModelElement) {
                const t6 = n4.mapper.toViewElement(this._currentFakeCaretModelElement);
                t6 && (o4.removeClass(tw.map(r3), t6), this._currentFakeCaretModelElement = null);
              }
              const s3 = e5.selection.getSelectedElement();
              if (!s3)
                return;
              const a3 = n4.mapper.toViewElement(s3);
              if (!Yb2(a3, s3, i3))
                return;
              const c3 = Qb2(e5.selection);
              c3 && (o4.addClass(r3(c3), a3), this._currentFakeCaretModelElement = s3);
            }), this._listenToIfEnabled(t4.ui.focusTracker, "change:isFocused", (e5, n4, i4) => {
              i4 || t4.model.change((t5) => {
                t5.removeSelectionAttribute(Zb2);
              });
            });
          }
          _handleArrowKeyPress(t4, e4) {
            const n3 = this.editor, i3 = n3.model, o3 = i3.document.selection, r3 = i3.schema, s3 = n3.editing.view, a3 = function(t5, e5) {
              const n4 = Co2(t5, e5);
              return "down" === n4 || "right" === n4;
            }(e4.keyCode, n3.locale.contentLanguageDirection), c3 = s3.document.selection.getSelectedElement();
            let l3;
            Yb2(c3, n3.editing.mapper.toModelElement(c3), r3) ? l3 = this._handleArrowKeyPressOnSelectedWidget(a3) : o3.isCollapsed ? l3 = this._handleArrowKeyPressWhenSelectionNextToAWidget(a3) : e4.shiftKey || (l3 = this._handleArrowKeyPressWhenNonCollapsedSelection(a3)), l3 && (e4.preventDefault(), t4.stop());
          }
          _handleArrowKeyPressOnSelectedWidget(t4) {
            const e4 = this.editor.model, n3 = Qb2(e4.document.selection);
            return e4.change((e5) => {
              if (!n3)
                return e5.setSelectionAttribute(Zb2, t4 ? "after" : "before"), true;
              if (!(n3 === (t4 ? "after" : "before")))
                return e5.removeSelectionAttribute(Zb2), true;
              return false;
            });
          }
          _handleArrowKeyPressWhenSelectionNextToAWidget(t4) {
            const e4 = this.editor, n3 = e4.model, i3 = n3.schema, o3 = e4.plugins.get("Widget"), r3 = o3._getObjectElementNextToSelection(t4);
            return !!Yb2(e4.editing.mapper.toViewElement(r3), r3, i3) && (n3.change((e5) => {
              o3._setSelectionOverElement(r3), e5.setSelectionAttribute(Zb2, t4 ? "before" : "after");
            }), true);
          }
          _handleArrowKeyPressWhenNonCollapsedSelection(t4) {
            const e4 = this.editor, n3 = e4.model, i3 = n3.schema, o3 = e4.editing.mapper, r3 = n3.document.selection, s3 = t4 ? r3.getLastPosition().nodeBefore : r3.getFirstPosition().nodeAfter;
            return !!Yb2(o3.toViewElement(s3), s3, i3) && (n3.change((e5) => {
              e5.setSelection(s3, "on"), e5.setSelectionAttribute(Zb2, t4 ? "after" : "before");
            }), true);
          }
          _enableInsertingParagraphsOnButtonClick() {
            const t4 = this.editor, e4 = t4.editing.view;
            this._listenToIfEnabled(e4.document, "mousedown", (n3, i3) => {
              const o3 = i3.domTarget.closest(".ck-widget__type-around__button");
              if (!o3)
                return;
              const r3 = function(t5) {
                return t5.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
              }(o3), s3 = function(t5, e5) {
                const n4 = t5.closest(".ck-widget");
                return e5.mapDomToView(n4);
              }(o3, e4.domConverter), a3 = t4.editing.mapper.toModelElement(s3);
              this._insertParagraph(a3, r3), i3.preventDefault(), n3.stop();
            });
          }
          _enableInsertingParagraphsOnEnterKeypress() {
            const t4 = this.editor, e4 = t4.model.document.selection, n3 = t4.editing.view;
            this._listenToIfEnabled(n3.document, "enter", (n4, i3) => {
              if ("atTarget" != n4.eventPhase)
                return;
              const o3 = e4.getSelectedElement(), r3 = t4.editing.mapper.toViewElement(o3), s3 = t4.model.schema;
              let a3;
              this._insertParagraphAccordingToFakeCaretPosition() ? a3 = true : Yb2(r3, o3, s3) && (this._insertParagraph(o3, i3.isSoft ? "before" : "after"), a3 = true), a3 && (i3.preventDefault(), n4.stop());
            }, { context: jb2 });
          }
          _enableInsertingParagraphsOnTypingKeystroke() {
            const t4 = this.editor.editing.view.document;
            this._listenToIfEnabled(t4, "insertText", (e4, n3) => {
              this._insertParagraphAccordingToFakeCaretPosition() && (n3.selection = t4.selection);
            }, { priority: "high" }), c2.isAndroid ? this._listenToIfEnabled(t4, "keydown", (t5, e4) => {
              229 == e4.keyCode && this._insertParagraphAccordingToFakeCaretPosition();
            }) : this._listenToIfEnabled(t4, "compositionstart", () => {
              this._insertParagraphAccordingToFakeCaretPosition();
            }, { priority: "high" });
          }
          _enableDeleteIntegration() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = t4.model, i3 = n3.schema;
            this._listenToIfEnabled(e4.document, "delete", (e5, o3) => {
              if ("atTarget" != e5.eventPhase)
                return;
              const r3 = Qb2(n3.document.selection);
              if (!r3)
                return;
              const s3 = o3.direction, a3 = n3.document.selection.getSelectedElement(), c3 = "forward" == s3;
              if ("before" === r3 === c3)
                t4.execute("delete", { selection: n3.createSelection(a3, "on") });
              else {
                const e6 = i3.getNearestSelectionRange(n3.createPositionAt(a3, r3), s3);
                if (e6)
                  if (e6.isCollapsed) {
                    const o4 = n3.createSelection(e6.start);
                    if (n3.modifySelection(o4, { direction: s3 }), o4.focus.isEqual(e6.start)) {
                      const t5 = function(t6, e7) {
                        let n4 = e7;
                        for (const i4 of e7.getAncestors({ parentFirst: true })) {
                          if (i4.childCount > 1 || t6.isLimit(i4))
                            break;
                          n4 = i4;
                        }
                        return n4;
                      }(i3, e6.start.parent);
                      n3.deleteContent(n3.createSelection(t5, "on"), { doNotAutoparagraph: true });
                    } else
                      n3.change((n4) => {
                        n4.setSelection(e6), t4.execute(c3 ? "deleteForward" : "delete");
                      });
                  } else
                    n3.change((n4) => {
                      n4.setSelection(e6), t4.execute(c3 ? "deleteForward" : "delete");
                    });
              }
              o3.preventDefault(), e5.stop();
            }, { context: jb2 });
          }
          _enableInsertContentIntegration() {
            const t4 = this.editor, e4 = this.editor.model, n3 = e4.document.selection;
            this._listenToIfEnabled(t4.model, "insertContent", (t5, [i3, o3]) => {
              if (o3 && !o3.is("documentSelection"))
                return;
              const r3 = Qb2(n3);
              return r3 ? (t5.stop(), e4.change((t6) => {
                const o4 = n3.getSelectedElement(), s3 = e4.createPositionAt(o4, r3), a3 = t6.createSelection(s3), c3 = e4.insertContent(i3, a3);
                return t6.setSelection(a3), c3;
              })) : void 0;
            }, { priority: "high" });
          }
          _enableInsertObjectIntegration() {
            const t4 = this.editor, e4 = this.editor.model.document.selection;
            this._listenToIfEnabled(t4.model, "insertObject", (t5, n3) => {
              const [, i3, o3 = {}] = n3;
              if (i3 && !i3.is("documentSelection"))
                return;
              const r3 = Qb2(e4);
              r3 && (o3.findOptimalPosition = r3, n3[3] = o3);
            }, { priority: "high" });
          }
          _enableDeleteContentIntegration() {
            const t4 = this.editor, e4 = this.editor.model.document.selection;
            this._listenToIfEnabled(t4.model, "deleteContent", (t5, [n3]) => {
              if (n3 && !n3.is("documentSelection"))
                return;
              Qb2(e4) && t5.stop();
            }, { priority: "high" });
          }
        }
        function ow(t4) {
          const e4 = t4.model;
          return (n3, i3) => {
            const o3 = i3.keyCode == fo2.arrowup, r3 = i3.keyCode == fo2.arrowdown, s3 = i3.shiftKey, a3 = e4.document.selection;
            if (!o3 && !r3)
              return;
            const c3 = r3;
            if (s3 && function(t5, e5) {
              return !t5.isCollapsed && t5.isBackward == e5;
            }(a3, c3))
              return;
            const l3 = function(t5, e5, n4) {
              const i4 = t5.model;
              if (n4) {
                const t6 = e5.isCollapsed ? e5.focus : e5.getLastPosition(), n5 = rw(i4, t6, "forward");
                if (!n5)
                  return null;
                const o4 = i4.createRange(t6, n5), r4 = sw(i4.schema, o4, "backward");
                return r4 ? i4.createRange(t6, r4) : null;
              }
              {
                const t6 = e5.isCollapsed ? e5.focus : e5.getFirstPosition(), n5 = rw(i4, t6, "backward");
                if (!n5)
                  return null;
                const o4 = i4.createRange(n5, t6), r4 = sw(i4.schema, o4, "forward");
                return r4 ? i4.createRange(r4, t6) : null;
              }
            }(t4, a3, c3);
            if (l3) {
              if (l3.isCollapsed) {
                if (a3.isCollapsed)
                  return;
                if (s3)
                  return;
              }
              (l3.isCollapsed || function(t5, e5, n4) {
                const i4 = t5.model, o4 = t5.view.domConverter;
                if (n4) {
                  const t6 = i4.createSelection(e5.start);
                  i4.modifySelection(t6), t6.focus.isAtEnd || e5.start.isEqual(t6.focus) || (e5 = i4.createRange(t6.focus, e5.end));
                }
                const r4 = t5.mapper.toViewRange(e5), s4 = o4.viewRangeToDom(r4), a4 = Vi2.getDomRangeRects(s4);
                let c4;
                for (const t6 of a4)
                  if (void 0 !== c4) {
                    if (Math.round(t6.top) >= c4)
                      return false;
                    c4 = Math.max(c4, Math.round(t6.bottom));
                  } else
                    c4 = Math.round(t6.bottom);
                return true;
              }(t4, l3, c3)) && (e4.change((t5) => {
                const n4 = c3 ? l3.end : l3.start;
                if (s3) {
                  const i4 = e4.createSelection(a3.anchor);
                  i4.setFocus(n4), t5.setSelection(i4);
                } else
                  t5.setSelection(n4);
              }), n3.stop(), i3.preventDefault(), i3.stopPropagation());
            }
          };
        }
        function rw(t4, e4, n3) {
          const i3 = t4.schema, o3 = t4.createRangeIn(e4.root), r3 = "forward" == n3 ? "elementStart" : "elementEnd";
          for (const { previousPosition: t5, item: s3, type: a3 } of o3.getWalker({ startPosition: e4, direction: n3 })) {
            if (i3.isLimit(s3) && !i3.isInline(s3))
              return t5;
            if (a3 == r3 && i3.isBlock(s3))
              return null;
          }
          return null;
        }
        function sw(t4, e4, n3) {
          const i3 = "backward" == n3 ? e4.end : e4.start;
          if (t4.checkChild(i3, "$text"))
            return i3;
          for (const { nextPosition: i4 } of e4.getWalker({ direction: n3 }))
            if (t4.checkChild(i4, "$text"))
              return i4;
          return null;
        }
        var aw = n2(7153), cw = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(aw.Z, cw);
        aw.Z.locals;
        class lw extends bs {
          constructor() {
            super(...arguments), this._previouslySelected = /* @__PURE__ */ new Set();
          }
          static get pluginName() {
            return "Widget";
          }
          static get requires() {
            return [iw, ek2];
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document;
            this.editor.editing.downcastDispatcher.on("selection", (e5, n4, i3) => {
              const o3 = i3.writer, r3 = n4.selection;
              if (r3.isCollapsed)
                return;
              const s3 = r3.getSelectedElement();
              if (!s3)
                return;
              const a3 = t4.editing.mapper.toViewElement(s3);
              var c3;
              jb2(a3) && (i3.consumable.consume(r3, "selection") && o3.setSelection(o3.createRangeOn(a3), { fake: true, label: (c3 = a3, c3.getCustomProperty("widgetLabel").reduce((t5, e6) => "function" == typeof e6 ? t5 ? t5 + ". " + e6() : e6() : t5 ? t5 + ". " + e6 : e6, "")) }));
            }), this.editor.editing.downcastDispatcher.on("selection", (t5, e5, n4) => {
              this._clearPreviouslySelectedWidgets(n4.writer);
              const i3 = n4.writer, o3 = i3.document.selection;
              let r3 = null;
              for (const t6 of o3.getRanges())
                for (const e6 of t6) {
                  const t7 = e6.item;
                  jb2(t7) && !dw(t7, r3) && (i3.addClass(Vb2, t7), this._previouslySelected.add(t7), r3 = t7);
                }
            }, { priority: "low" }), e4.addObserver(Vu), this.listenTo(n3, "mousedown", (...t5) => this._onMousedown(...t5)), this.listenTo(n3, "arrowKey", (...t5) => {
              this._handleSelectionChangeOnArrowKeyPress(...t5);
            }, { context: [jb2, "$text"] }), this.listenTo(n3, "arrowKey", (...t5) => {
              this._preventDefaultOnArrowKeyPress(...t5);
            }, { context: "$root" }), this.listenTo(n3, "arrowKey", ow(this.editor.editing), { context: "$text" }), this.listenTo(n3, "delete", (t5, e5) => {
              this._handleDelete("forward" == e5.direction) && (e5.preventDefault(), t5.stop());
            }, { context: "$root" });
          }
          _onMousedown(t4, e4) {
            const n3 = this.editor, i3 = n3.editing.view, o3 = i3.document;
            let r3 = e4.target;
            if (e4.domEvent.detail >= 3)
              return void (this._selectBlockContent(r3) && e4.preventDefault());
            if (function(t5) {
              let e5 = t5;
              for (; e5; ) {
                if (e5.is("editableElement") && !e5.is("rootElement"))
                  return true;
                if (jb2(e5))
                  return false;
                e5 = e5.parent;
              }
              return false;
            }(r3))
              return;
            if (!jb2(r3) && (r3 = r3.findAncestor(jb2), !r3))
              return;
            c2.isAndroid && e4.preventDefault(), o3.isFocused || i3.focus();
            const s3 = n3.editing.mapper.toModelElement(r3);
            this._setSelectionOverElement(s3);
          }
          _selectBlockContent(t4) {
            const e4 = this.editor, n3 = e4.model, i3 = e4.editing.mapper, o3 = n3.schema, r3 = i3.findMappedViewAncestor(this.editor.editing.view.createPositionAt(t4, 0)), s3 = function(t5, e5) {
              for (const n4 of t5.getAncestors({ includeSelf: true, parentFirst: true })) {
                if (e5.checkChild(n4, "$text"))
                  return n4;
                if (e5.isLimit(n4) && !e5.isObject(n4))
                  break;
              }
              return null;
            }(i3.toModelElement(r3), n3.schema);
            return !!s3 && (n3.change((t5) => {
              const e5 = o3.isLimit(s3) ? null : function(t6, e6) {
                const n5 = new ql2({ startPosition: t6 });
                for (const { item: t7 } of n5) {
                  if (e6.isLimit(t7) || !t7.is("element"))
                    return null;
                  if (e6.checkChild(t7, "$text"))
                    return t7;
                }
                return null;
              }(t5.createPositionAfter(s3), o3), n4 = t5.createPositionAt(s3, 0), i4 = e5 ? t5.createPositionAt(e5, 0) : t5.createPositionAt(s3, "end");
              t5.setSelection(t5.createRange(n4, i4));
            }), true);
          }
          _handleSelectionChangeOnArrowKeyPress(t4, e4) {
            const n3 = e4.keyCode, i3 = this.editor.model, o3 = i3.schema, r3 = i3.document.selection, s3 = r3.getSelectedElement(), a3 = Co2(n3, this.editor.locale.contentLanguageDirection), c3 = "down" == a3 || "right" == a3, l3 = "up" == a3 || "down" == a3;
            if (s3 && o3.isObject(s3)) {
              const n4 = c3 ? r3.getLastPosition() : r3.getFirstPosition(), s4 = o3.getNearestSelectionRange(n4, c3 ? "forward" : "backward");
              return void (s4 && (i3.change((t5) => {
                t5.setSelection(s4);
              }), e4.preventDefault(), t4.stop()));
            }
            if (!r3.isCollapsed && !e4.shiftKey) {
              const n4 = r3.getFirstPosition(), s4 = r3.getLastPosition(), a4 = n4.nodeAfter, l4 = s4.nodeBefore;
              return void ((a4 && o3.isObject(a4) || l4 && o3.isObject(l4)) && (i3.change((t5) => {
                t5.setSelection(c3 ? s4 : n4);
              }), e4.preventDefault(), t4.stop()));
            }
            if (!r3.isCollapsed)
              return;
            const d3 = this._getObjectElementNextToSelection(c3);
            if (d3 && o3.isObject(d3)) {
              if (o3.isInline(d3) && l3)
                return;
              this._setSelectionOverElement(d3), e4.preventDefault(), t4.stop();
            }
          }
          _preventDefaultOnArrowKeyPress(t4, e4) {
            const n3 = this.editor.model, i3 = n3.schema, o3 = n3.document.selection.getSelectedElement();
            o3 && i3.isObject(o3) && (e4.preventDefault(), t4.stop());
          }
          _handleDelete(t4) {
            const e4 = this.editor.model.document.selection;
            if (!this.editor.model.canEditAt(e4))
              return;
            if (!e4.isCollapsed)
              return;
            const n3 = this._getObjectElementNextToSelection(t4);
            return n3 ? (this.editor.model.change((t5) => {
              let i3 = e4.anchor.parent;
              for (; i3.isEmpty; ) {
                const e5 = i3;
                i3 = e5.parent, t5.remove(e5);
              }
              this._setSelectionOverElement(n3);
            }), true) : void 0;
          }
          _setSelectionOverElement(t4) {
            this.editor.model.change((e4) => {
              e4.setSelection(e4.createRangeOn(t4));
            });
          }
          _getObjectElementNextToSelection(t4) {
            const e4 = this.editor.model, n3 = e4.schema, i3 = e4.document.selection, o3 = e4.createSelection(i3);
            if (e4.modifySelection(o3, { direction: t4 ? "forward" : "backward" }), o3.isEqual(i3))
              return null;
            const r3 = t4 ? o3.focus.nodeBefore : o3.focus.nodeAfter;
            return r3 && n3.isObject(r3) ? r3 : null;
          }
          _clearPreviouslySelectedWidgets(t4) {
            for (const e4 of this._previouslySelected)
              t4.removeClass(Vb2, e4);
            this._previouslySelected.clear();
          }
        }
        function dw(t4, e4) {
          return !!e4 && Array.from(t4.getAncestors()).includes(e4);
        }
        class hw extends bs {
          constructor() {
            super(...arguments), this._toolbarDefinitions = /* @__PURE__ */ new Map();
          }
          static get requires() {
            return [Yp];
          }
          static get pluginName() {
            return "WidgetToolbarRepository";
          }
          init() {
            const t4 = this.editor;
            if (t4.plugins.has("BalloonToolbar")) {
              const e4 = t4.plugins.get("BalloonToolbar");
              this.listenTo(e4, "show", (e5) => {
                (function(t5) {
                  const e6 = t5.getSelectedElement();
                  return !(!e6 || !jb2(e6));
                })(t4.editing.view.document.selection) && e5.stop();
              }, { priority: "high" });
            }
            this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
              this._updateToolbarsVisibility();
            }), this.listenTo(t4.ui, "update", () => {
              this._updateToolbarsVisibility();
            }), this.listenTo(t4.ui.focusTracker, "change:isFocused", () => {
              this._updateToolbarsVisibility();
            }, { priority: "low" });
          }
          destroy() {
            super.destroy();
            for (const t4 of this._toolbarDefinitions.values())
              t4.view.destroy();
          }
          register(t4, { ariaLabel: e4, items: n3, getRelatedElement: i3, balloonClassName: o3 = "ck-toolbar-container" }) {
            if (!n3.length)
              return void _2("widget-toolbar-no-items", { toolbarId: t4 });
            const r3 = this.editor, s3 = r3.t, a3 = new jg2(r3.locale);
            if (a3.ariaLabel = e4 || s3("Widget toolbar"), this._toolbarDefinitions.has(t4))
              throw new C2("widget-toolbar-duplicated", this, { toolbarId: t4 });
            const c3 = { view: a3, getRelatedElement: i3, balloonClassName: o3, itemsConfig: n3, initialized: false };
            r3.ui.addToolbar(a3, { isContextual: true, beforeFocus: () => {
              const t5 = i3(r3.editing.view.document.selection);
              t5 && this._showToolbar(c3, t5);
            }, afterBlur: () => {
              this._hideToolbar(c3);
            } }), this._toolbarDefinitions.set(t4, c3);
          }
          _updateToolbarsVisibility() {
            let t4 = 0, e4 = null, n3 = null;
            for (const i3 of this._toolbarDefinitions.values()) {
              const o3 = i3.getRelatedElement(this.editor.editing.view.document.selection);
              if (this.isEnabled && o3)
                if (this.editor.ui.focusTracker.isFocused) {
                  const r3 = o3.getAncestors().length;
                  r3 > t4 && (t4 = r3, e4 = o3, n3 = i3);
                } else
                  this._isToolbarVisible(i3) && this._hideToolbar(i3);
              else
                this._isToolbarInBalloon(i3) && this._hideToolbar(i3);
            }
            n3 && this._showToolbar(n3, e4);
          }
          _hideToolbar(t4) {
            this._balloon.remove(t4.view), this.stopListening(this._balloon, "change:visibleView");
          }
          _showToolbar(t4, e4) {
            this._isToolbarVisible(t4) ? uw(this.editor, e4) : this._isToolbarInBalloon(t4) || (t4.initialized || (t4.initialized = true, t4.view.fillFromConfig(t4.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({ view: t4.view, position: gw(this.editor, e4), balloonClassName: t4.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
              for (const t5 of this._toolbarDefinitions.values())
                if (this._isToolbarVisible(t5)) {
                  const e5 = t5.getRelatedElement(this.editor.editing.view.document.selection);
                  uw(this.editor, e5);
                }
            }));
          }
          _isToolbarVisible(t4) {
            return this._balloon.visibleView === t4.view;
          }
          _isToolbarInBalloon(t4) {
            return this._balloon.hasView(t4.view);
          }
        }
        function uw(t4, e4) {
          const n3 = t4.plugins.get("ContextualBalloon"), i3 = gw(t4, e4);
          n3.updatePosition(i3);
        }
        function gw(t4, e4) {
          const n3 = t4.editing.view, i3 = lp.defaultPositions;
          return { target: n3.domConverter.mapViewToDom(e4), positions: [i3.northArrowSouth, i3.northArrowSouthWest, i3.northArrowSouthEast, i3.southArrowNorth, i3.southArrowNorthWest, i3.southArrowNorthEast, i3.viewportStickyNorth] };
        }
        class mw extends q2() {
          constructor(t4) {
            super(), this.set("activeHandlePosition", null), this.set("proposedWidthPercents", null), this.set("proposedWidth", null), this.set("proposedHeight", null), this.set("proposedHandleHostWidth", null), this.set("proposedHandleHostHeight", null), this._options = t4, this._referenceCoordinates = null;
          }
          get originalWidth() {
            return this._originalWidth;
          }
          get originalHeight() {
            return this._originalHeight;
          }
          get originalWidthPercents() {
            return this._originalWidthPercents;
          }
          get aspectRatio() {
            return this._aspectRatio;
          }
          begin(t4, e4, n3) {
            const i3 = new Vi2(e4);
            this.activeHandlePosition = function(t5) {
              const e5 = ["top-left", "top-right", "bottom-right", "bottom-left"];
              for (const n4 of e5)
                if (t5.classList.contains(pw(n4)))
                  return n4;
            }(t4), this._referenceCoordinates = function(t5, e5) {
              const n4 = new Vi2(t5), i4 = e5.split("-"), o4 = { x: "right" == i4[1] ? n4.right : n4.left, y: "bottom" == i4[0] ? n4.bottom : n4.top };
              return o4.x += t5.ownerDocument.defaultView.scrollX, o4.y += t5.ownerDocument.defaultView.scrollY, o4;
            }(e4, function(t5) {
              const e5 = t5.split("-"), n4 = { top: "bottom", bottom: "top", left: "right", right: "left" };
              return `${n4[e5[0]]}-${n4[e5[1]]}`;
            }(this.activeHandlePosition)), this._originalWidth = i3.width, this._originalHeight = i3.height, this._aspectRatio = i3.width / i3.height;
            const o3 = n3.style.width;
            o3 && o3.match(/^\d+(\.\d*)?%$/) ? this._originalWidthPercents = parseFloat(o3) : this._originalWidthPercents = function(t5, e5) {
              const n4 = t5.parentElement;
              let i4 = parseFloat(n4.ownerDocument.defaultView.getComputedStyle(n4).width);
              const o4 = 5;
              let r3 = 0, s3 = n4;
              for (; isNaN(i4); ) {
                if (s3 = s3.parentElement, ++r3 > o4)
                  return 0;
                i4 = parseFloat(n4.ownerDocument.defaultView.getComputedStyle(s3).width);
              }
              return e5.width / i4 * 100;
            }(n3, i3);
          }
          update(t4) {
            this.proposedWidth = t4.width, this.proposedHeight = t4.height, this.proposedWidthPercents = t4.widthPercents, this.proposedHandleHostWidth = t4.handleHostWidth, this.proposedHandleHostHeight = t4.handleHostHeight;
          }
        }
        function pw(t4) {
          return `ck-widget__resizer__handle-${t4}`;
        }
        class fw extends Ho2 {
          constructor() {
            super();
            const t4 = this.bindTemplate;
            this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-size-view", t4.to("_viewPosition", (t5) => t5 ? `ck-orientation-${t5}` : "")], style: { display: t4.if("_isVisible", "none", (t5) => !t5) } }, children: [{ text: t4.to("_label") }] });
          }
          _bindToState(t4, e4) {
            this.bind("_isVisible").to(e4, "proposedWidth", e4, "proposedHeight", (t5, e5) => null !== t5 && null !== e5), this.bind("_label").to(e4, "proposedHandleHostWidth", e4, "proposedHandleHostHeight", e4, "proposedWidthPercents", (e5, n3, i3) => "px" === t4.unit ? `${e5}${n3}` : `${i3}%`), this.bind("_viewPosition").to(e4, "activeHandlePosition", e4, "proposedHandleHostWidth", e4, "proposedHandleHostHeight", (t5, e5, n3) => e5 < 50 || n3 < 50 ? "above-center" : t5);
          }
          _dismiss() {
            this.unbind(), this._isVisible = false;
          }
        }
        class kw extends q2() {
          constructor(t4) {
            super(), this._viewResizerWrapper = null, this._options = t4, this.set("isEnabled", true), this.set("isSelected", false), this.bind("isVisible").to(this, "isEnabled", this, "isSelected", (t5, e4) => t5 && e4), this.decorate("begin"), this.decorate("cancel"), this.decorate("commit"), this.decorate("updateSize"), this.on("commit", (t5) => {
              this.state.proposedWidth || this.state.proposedWidthPercents || (this._cleanup(), t5.stop());
            }, { priority: "high" });
          }
          get state() {
            return this._state;
          }
          show() {
            this._options.editor.editing.view.change((t4) => {
              t4.removeClass("ck-hidden", this._viewResizerWrapper);
            });
          }
          hide() {
            this._options.editor.editing.view.change((t4) => {
              t4.addClass("ck-hidden", this._viewResizerWrapper);
            });
          }
          attach() {
            const t4 = this, e4 = this._options.viewElement;
            this._options.editor.editing.view.change((n3) => {
              const i3 = n3.createUIElement("div", { class: "ck ck-reset_all ck-widget__resizer" }, function(e5) {
                const n4 = this.toDomElement(e5);
                return t4._appendHandles(n4), t4._appendSizeUI(n4), n4;
              });
              n3.insert(n3.createPositionAt(e4, "end"), i3), n3.addClass("ck-widget_with-resizer", e4), this._viewResizerWrapper = i3, this.isVisible || this.hide();
            }), this.on("change:isVisible", () => {
              this.isVisible ? (this.show(), this.redraw()) : this.hide();
            });
          }
          begin(t4) {
            this._state = new mw(this._options), this._sizeView._bindToState(this._options, this.state), this._initialViewWidth = this._options.viewElement.getStyle("width"), this.state.begin(t4, this._getHandleHost(), this._getResizeHost());
          }
          updateSize(t4) {
            const e4 = this._proposeNewSize(t4);
            this._options.editor.editing.view.change((t5) => {
              const n4 = this._options.unit || "%", i4 = ("%" === n4 ? e4.widthPercents : e4.width) + n4;
              t5.setStyle("width", i4, this._options.viewElement);
            });
            const n3 = this._getHandleHost(), i3 = new Vi2(n3), o3 = Math.round(i3.width), r3 = Math.round(i3.height), s3 = new Vi2(n3);
            e4.width = Math.round(s3.width), e4.height = Math.round(s3.height), this.redraw(i3), this.state.update({ ...e4, handleHostWidth: o3, handleHostHeight: r3 });
          }
          commit() {
            const t4 = this._options.unit || "%", e4 = ("%" === t4 ? this.state.proposedWidthPercents : this.state.proposedWidth) + t4;
            this._options.editor.editing.view.change(() => {
              this._cleanup(), this._options.onCommit(e4);
            });
          }
          cancel() {
            this._cleanup();
          }
          destroy() {
            this.cancel();
          }
          redraw(t4) {
            const e4 = this._domResizerWrapper;
            if (!((n3 = e4) && n3.ownerDocument && n3.ownerDocument.contains(n3)))
              return;
            var n3;
            const i3 = e4.parentElement, o3 = this._getHandleHost(), r3 = this._viewResizerWrapper, s3 = [r3.getStyle("width"), r3.getStyle("height"), r3.getStyle("left"), r3.getStyle("top")];
            let a3;
            if (i3.isSameNode(o3)) {
              const e5 = t4 || new Vi2(o3);
              a3 = [e5.width + "px", e5.height + "px", void 0, void 0];
            } else
              a3 = [o3.offsetWidth + "px", o3.offsetHeight + "px", o3.offsetLeft + "px", o3.offsetTop + "px"];
            "same" !== tt2(s3, a3) && this._options.editor.editing.view.change((t5) => {
              t5.setStyle({ width: a3[0], height: a3[1], left: a3[2], top: a3[3] }, r3);
            });
          }
          containsHandle(t4) {
            return this._domResizerWrapper.contains(t4);
          }
          static isResizeHandle(t4) {
            return t4.classList.contains("ck-widget__resizer__handle");
          }
          _cleanup() {
            this._sizeView._dismiss();
            this._options.editor.editing.view.change((t4) => {
              t4.setStyle("width", this._initialViewWidth, this._options.viewElement);
            });
          }
          _proposeNewSize(t4) {
            const e4 = this.state, n3 = { x: (i3 = t4).pageX, y: i3.pageY };
            var i3;
            const o3 = !this._options.isCentered || this._options.isCentered(this), r3 = { x: e4._referenceCoordinates.x - (n3.x + e4.originalWidth), y: n3.y - e4.originalHeight - e4._referenceCoordinates.y };
            o3 && e4.activeHandlePosition.endsWith("-right") && (r3.x = n3.x - (e4._referenceCoordinates.x + e4.originalWidth)), o3 && (r3.x *= 2);
            let s3 = Math.abs(e4.originalWidth + r3.x), a3 = Math.abs(e4.originalHeight + r3.y);
            return "width" == (s3 / e4.aspectRatio > a3 ? "width" : "height") ? a3 = s3 / e4.aspectRatio : s3 = a3 * e4.aspectRatio, { width: Math.round(s3), height: Math.round(a3), widthPercents: Math.min(Math.round(e4.originalWidthPercents / e4.originalWidth * s3 * 100) / 100, 100) };
          }
          _getResizeHost() {
            const t4 = this._domResizerWrapper.parentElement;
            return this._options.getResizeHost(t4);
          }
          _getHandleHost() {
            const t4 = this._domResizerWrapper.parentElement;
            return this._options.getHandleHost(t4);
          }
          get _domResizerWrapper() {
            return this._options.editor.editing.view.domConverter.mapViewToDom(this._viewResizerWrapper);
          }
          _appendHandles(t4) {
            const e4 = ["top-left", "top-right", "bottom-right", "bottom-left"];
            for (const i3 of e4)
              t4.appendChild(new Uo2({ tag: "div", attributes: { class: "ck-widget__resizer__handle " + (n3 = i3, `ck-widget__resizer__handle-${n3}`) } }).render());
            var n3;
          }
          _appendSizeUI(t4) {
            this._sizeView = new fw(), this._sizeView.render(), t4.appendChild(this._sizeView.element);
          }
        }
        var bw = n2(4875), ww = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(bw.Z, ww);
        bw.Z.locals;
        class Aw extends bs {
          constructor() {
            super(...arguments), this._resizers = /* @__PURE__ */ new Map();
          }
          static get pluginName() {
            return "WidgetResize";
          }
          init() {
            const t4 = this.editor.editing, e4 = Li2.window.document;
            this.set("selectedResizer", null), this.set("_activeResizer", null), t4.view.addObserver(Vu), this._observer = new (Ii2())(), this.listenTo(t4.view.document, "mousedown", this._mouseDownListener.bind(this), { priority: "high" }), this._observer.listenTo(e4, "mousemove", this._mouseMoveListener.bind(this)), this._observer.listenTo(e4, "mouseup", this._mouseUpListener.bind(this)), this._redrawSelectedResizerThrottled = kp(() => this.redrawSelectedResizer(), 200), this.editor.ui.on("update", this._redrawSelectedResizerThrottled), this.editor.model.document.on("change", () => {
              for (const [t5, e5] of this._resizers)
                t5.isAttached() || (this._resizers.delete(t5), e5.destroy());
            }, { priority: "lowest" }), this._observer.listenTo(Li2.window, "resize", this._redrawSelectedResizerThrottled);
            const n3 = this.editor.editing.view.document.selection;
            n3.on("change", () => {
              const t5 = n3.getSelectedElement(), e5 = this.getResizerByViewElement(t5) || null;
              e5 ? this.select(e5) : this.deselect();
            });
          }
          redrawSelectedResizer() {
            this.selectedResizer && this.selectedResizer.isVisible && this.selectedResizer.redraw();
          }
          destroy() {
            super.destroy(), this._observer.stopListening();
            for (const t4 of this._resizers.values())
              t4.destroy();
            this._redrawSelectedResizerThrottled.cancel();
          }
          select(t4) {
            this.deselect(), this.selectedResizer = t4, this.selectedResizer.isSelected = true;
          }
          deselect() {
            this.selectedResizer && (this.selectedResizer.isSelected = false), this.selectedResizer = null;
          }
          attachTo(t4) {
            const e4 = new kw(t4), n3 = this.editor.plugins;
            if (e4.attach(), n3.has("WidgetToolbarRepository")) {
              const t5 = n3.get("WidgetToolbarRepository");
              e4.on("begin", () => {
                t5.forceDisabled("resize");
              }, { priority: "lowest" }), e4.on("cancel", () => {
                t5.clearForceDisabled("resize");
              }, { priority: "highest" }), e4.on("commit", () => {
                t5.clearForceDisabled("resize");
              }, { priority: "highest" });
            }
            this._resizers.set(t4.viewElement, e4);
            const i3 = this.editor.editing.view.document.selection.getSelectedElement();
            return this.getResizerByViewElement(i3) == e4 && this.select(e4), e4;
          }
          getResizerByViewElement(t4) {
            return this._resizers.get(t4);
          }
          _getResizerByHandle(t4) {
            for (const e4 of this._resizers.values())
              if (e4.containsHandle(t4))
                return e4;
          }
          _mouseDownListener(t4, e4) {
            const n3 = e4.domTarget;
            kw.isResizeHandle(n3) && (this._activeResizer = this._getResizerByHandle(n3) || null, this._activeResizer && (this._activeResizer.begin(n3), t4.stop(), e4.preventDefault()));
          }
          _mouseMoveListener(t4, e4) {
            this._activeResizer && this._activeResizer.updateSize(e4);
          }
          _mouseUpListener() {
            this._activeResizer && (this._activeResizer.commit(), this._activeResizer = null);
          }
        }
        const Cw = $i2("px");
        class _w extends Ho2 {
          constructor() {
            super();
            const t4 = this.bindTemplate;
            this.set({ isVisible: false, left: null, top: null, width: null }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-clipboard-drop-target-line", t4.if("isVisible", "ck-hidden", (t5) => !t5)], style: { left: t4.to("left", (t5) => Cw(t5)), top: t4.to("top", (t5) => Cw(t5)), width: t4.to("width", (t5) => Cw(t5)) } } });
          }
        }
        class vw extends bs {
          constructor() {
            super(...arguments), this.removeDropMarkerDelayed = Mo2(() => this.removeDropMarker(), 40), this._updateDropMarkerThrottled = kp((t4) => this._updateDropMarker(t4), 40), this._reconvertMarkerThrottled = kp(() => {
              this.editor.model.markers.has("drop-target") && this.editor.editing.reconvertMarker("drop-target");
            }, 0), this._dropTargetLineView = new _w(), this._domEmitter = new (Ii2())(), this._scrollables = /* @__PURE__ */ new Map();
          }
          static get pluginName() {
            return "DragDropTarget";
          }
          init() {
            this._setupDropMarker();
          }
          destroy() {
            this._domEmitter.stopListening();
            for (const { resizeObserver: t4 } of this._scrollables.values())
              t4.destroy();
            return this._updateDropMarkerThrottled.cancel(), this.removeDropMarkerDelayed.cancel(), this._reconvertMarkerThrottled.cancel(), super.destroy();
          }
          updateDropMarker(t4, e4, n3, i3, o3, r3) {
            this.removeDropMarkerDelayed.cancel();
            const s3 = yw(this.editor, t4, e4, n3, i3, o3, r3);
            if (s3)
              return r3 && r3.containsRange(s3) ? this.removeDropMarker() : void this._updateDropMarkerThrottled(s3);
          }
          getFinalDropRange(t4, e4, n3, i3, o3, r3) {
            const s3 = yw(this.editor, t4, e4, n3, i3, o3, r3);
            return this.removeDropMarker(), s3;
          }
          removeDropMarker() {
            const t4 = this.editor.model;
            this.removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), this._dropTargetLineView.isVisible = false, t4.markers.has("drop-target") && t4.change((t5) => {
              t5.removeMarker("drop-target");
            });
          }
          _setupDropMarker() {
            const t4 = this.editor;
            t4.ui.view.body.add(this._dropTargetLineView), t4.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }), t4.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (e4, { writer: n3 }) => {
              if (t4.model.schema.checkChild(e4.markerRange.start, "$text"))
                return this._dropTargetLineView.isVisible = false, this._createDropTargetPosition(n3);
              e4.markerRange.isCollapsed ? this._updateDropTargetLine(e4.markerRange) : this._dropTargetLineView.isVisible = false;
            } });
          }
          _updateDropMarker(t4) {
            const e4 = this.editor, n3 = e4.model.markers;
            e4.model.change((e5) => {
              n3.has("drop-target") ? n3.get("drop-target").getRange().isEqual(t4) || e5.updateMarker("drop-target", { range: t4 }) : e5.addMarker("drop-target", { range: t4, usingOperation: false, affectsData: false });
            });
          }
          _createDropTargetPosition(t4) {
            return t4.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(t5) {
              const e4 = this.toDomElement(t5);
              return e4.append("", t5.createElement("span"), ""), e4;
            });
          }
          _updateDropTargetLine(t4) {
            const e4 = this.editor.editing, n3 = t4.start.nodeBefore, i3 = t4.start.nodeAfter, o3 = t4.start.parent, r3 = n3 ? e4.mapper.toViewElement(n3) : null, s3 = r3 ? e4.view.domConverter.mapViewToDom(r3) : null, a3 = i3 ? e4.mapper.toViewElement(i3) : null, c3 = a3 ? e4.view.domConverter.mapViewToDom(a3) : null, l3 = e4.mapper.toViewElement(o3), d3 = e4.view.domConverter.mapViewToDom(l3), h3 = this._getScrollableRect(l3), { scrollX: u3, scrollY: g3 } = Li2.window, m3 = s3 ? new Vi2(s3) : null, p3 = c3 ? new Vi2(c3) : null, f3 = new Vi2(d3).excludeScrollbarsAndBorders(), k3 = m3 ? m3.bottom : f3.top, b3 = p3 ? p3.top : f3.bottom, w3 = Li2.window.getComputedStyle(d3), A3 = k3 <= b3 ? (k3 + b3) / 2 : b3;
            if (h3.top < A3 && A3 < h3.bottom) {
              const t5 = f3.left + parseFloat(w3.paddingLeft), e5 = f3.right - parseFloat(w3.paddingRight), n4 = Math.max(t5 + u3, h3.left), i4 = Math.min(e5 + u3, h3.right);
              this._dropTargetLineView.set({ isVisible: true, left: n4, top: A3 + g3, width: i4 - n4 });
            } else
              this._dropTargetLineView.isVisible = false;
          }
          _getScrollableRect(t4) {
            const e4 = t4.root.rootName;
            let n3;
            if (this._scrollables.has(e4))
              n3 = this._scrollables.get(e4).domElement;
            else {
              n3 = function(t5) {
                let e5 = t5;
                do {
                  e5 = e5.parentElement;
                  const t6 = Li2.window.getComputedStyle(e5).overflowY;
                  if ("auto" == t6 || "scroll" == t6)
                    break;
                } while ("BODY" != e5.tagName);
                return e5;
              }(this.editor.editing.view.domConverter.mapViewToDom(t4)), this._domEmitter.listenTo(n3, "scroll", this._reconvertMarkerThrottled, { usePassive: true });
              const i3 = new Wi2(n3, this._reconvertMarkerThrottled);
              this._scrollables.set(e4, { domElement: n3, resizeObserver: i3 });
            }
            return new Vi2(n3).excludeScrollbarsAndBorders();
          }
        }
        function yw(t4, e4, n3, i3, o3, r3, s3) {
          const a3 = t4.model, c3 = t4.editing.mapper;
          let l3 = Sw(t4, e4);
          for (; l3; ) {
            if (!r3) {
              if (a3.schema.checkChild(l3, "$text")) {
                if (n3) {
                  const e5 = n3[0].start, r4 = c3.toModelPosition(e5);
                  if (!s3 || Array.from(s3.getItems()).every((t5) => a3.schema.checkChild(r4, t5))) {
                    if (a3.schema.checkChild(r4, "$text"))
                      return a3.createRange(r4);
                    if (e5)
                      return Ew(t4, Sw(t4, e5.parent), i3, o3);
                  }
                }
              } else if (a3.schema.isInline(l3))
                return Ew(t4, l3, i3, o3);
            }
            if (a3.schema.isBlock(l3))
              return Ew(t4, l3, i3, o3);
            if (a3.schema.checkChild(l3, "$block")) {
              const e5 = Array.from(l3.getChildren()).filter((e6) => e6.is("element") && !xw(t4, e6));
              let n4 = 0, r4 = e5.length;
              if (0 == r4)
                return a3.createRange(a3.createPositionAt(l3, "end"));
              for (; n4 < r4 - 1; ) {
                const s4 = Math.floor((n4 + r4) / 2);
                "before" == Dw(t4, e5[s4], i3, o3) ? r4 = s4 : n4 = s4;
              }
              return Ew(t4, e5[n4], i3, o3);
            }
            l3 = l3.parent;
          }
          return null;
        }
        function xw(t4, e4) {
          const n3 = t4.editing.mapper, i3 = t4.editing.view.domConverter, o3 = n3.toViewElement(e4), r3 = i3.mapViewToDom(o3);
          return "none" != Li2.window.getComputedStyle(r3).float;
        }
        function Ew(t4, e4, n3, i3) {
          const o3 = t4.model;
          return o3.createRange(o3.createPositionAt(e4, Dw(t4, e4, n3, i3)));
        }
        function Dw(t4, e4, n3, i3) {
          const o3 = t4.editing.mapper, r3 = t4.editing.view.domConverter, s3 = o3.toViewElement(e4), a3 = r3.mapViewToDom(s3), c3 = new Vi2(a3);
          return t4.model.schema.isInline(e4) ? n3 < (c3.left + c3.right) / 2 ? "before" : "after" : i3 < (c3.top + c3.bottom) / 2 ? "before" : "after";
        }
        function Sw(t4, e4) {
          const n3 = t4.editing.mapper, i3 = t4.editing.view, o3 = n3.toModelElement(e4);
          if (o3)
            return o3;
          const r3 = i3.createPositionBefore(e4), s3 = n3.findMappedViewAncestor(r3);
          return n3.toModelElement(s3);
        }
        class Tw extends bs {
          constructor() {
            super(...arguments), this._isBlockDragging = false, this._domEmitter = new (Ii2())();
          }
          static get pluginName() {
            return "DragDropBlockToolbar";
          }
          init() {
            const t4 = this.editor;
            if (this.listenTo(t4, "change:isReadOnly", (t5, e4, n3) => {
              n3 ? (this.forceDisabled("readOnlyMode"), this._isBlockDragging = false) : this.clearForceDisabled("readOnlyMode");
            }), c2.isAndroid && this.forceDisabled("noAndroidSupport"), t4.plugins.has("BlockToolbar")) {
              const e4 = t4.plugins.get("BlockToolbar").buttonView.element;
              this._domEmitter.listenTo(e4, "dragstart", (t5, e5) => this._handleBlockDragStart(e5)), this._domEmitter.listenTo(Li2.document, "dragover", (t5, e5) => this._handleBlockDragging(e5)), this._domEmitter.listenTo(Li2.document, "drop", (t5, e5) => this._handleBlockDragging(e5)), this._domEmitter.listenTo(Li2.document, "dragend", () => this._handleBlockDragEnd(), { useCapture: true }), this.isEnabled && e4.setAttribute("draggable", "true"), this.on("change:isEnabled", (t5, n3, i3) => {
                e4.setAttribute("draggable", i3 ? "true" : "false");
              });
            }
          }
          destroy() {
            return this._domEmitter.stopListening(), super.destroy();
          }
          _handleBlockDragStart(t4) {
            if (!this.isEnabled)
              return;
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = this.editor.editing.view, o3 = Array.from(n3.getSelectedBlocks()), r3 = e4.createRange(e4.createPositionBefore(o3[0]), e4.createPositionAfter(o3[o3.length - 1]));
            e4.change((t5) => t5.setSelection(r3)), this._isBlockDragging = true, i3.focus(), i3.getObserver(Sb2).onDomEvent(t4);
          }
          _handleBlockDragging(t4) {
            if (!this.isEnabled || !this._isBlockDragging)
              return;
            const e4 = t4.clientX + ("ltr" == this.editor.locale.contentLanguageDirection ? 100 : -100), n3 = t4.clientY, i3 = document.elementFromPoint(e4, n3), o3 = this.editor.editing.view;
            i3 && i3.closest(".ck-editor__editable") && o3.getObserver(Sb2).onDomEvent({ ...t4, type: t4.type, dataTransfer: t4.dataTransfer, target: i3, clientX: e4, clientY: n3, preventDefault: () => t4.preventDefault(), stopPropagation: () => t4.stopPropagation() });
          }
          _handleBlockDragEnd() {
            this._isBlockDragging = false;
          }
        }
        var Iw = n2(799), Bw = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Iw.Z, Bw);
        Iw.Z.locals;
        class Mw extends bs {
          constructor() {
            super(...arguments), this._clearDraggableAttributesDelayed = Mo2(() => this._clearDraggableAttributes(), 40), this._blockMode = false, this._domEmitter = new (Ii2())();
          }
          static get pluginName() {
            return "DragDrop";
          }
          static get requires() {
            return [Nb2, lw, vw, Tw];
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view;
            this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, e4.addObserver(Sb2), e4.addObserver(Vu), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDraggableAttributeHandling(), this.listenTo(t4, "change:isReadOnly", (t5, e5, n3) => {
              n3 ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
            }), this.on("change:isEnabled", (t5, e5, n3) => {
              n3 || this._finalizeDragging(false);
            }), c2.isAndroid && this.forceDisabled("noAndroidSupport");
          }
          destroy() {
            return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._previewContainer && this._previewContainer.remove(), this._domEmitter.stopListening(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
          }
          _setupDragging() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, i3 = n3.document, o3 = t4.plugins.get(vw);
            this.listenTo(i3, "dragstart", (t5, n4) => {
              if (n4.target && n4.target.is("editableElement"))
                return void n4.preventDefault();
              if (this._prepareDraggedRange(n4.target), !this._draggedRange)
                return void n4.preventDefault();
              this._draggingUid = k2(), n4.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", n4.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
              const i4 = e4.createSelection(this._draggedRange.toRange());
              this.editor.plugins.get("ClipboardPipeline")._fireOutputTransformationEvent(n4.dataTransfer, i4, "dragstart");
              const { dataTransfer: o4, domTarget: r3, domEvent: s3 } = n4, { clientX: a3 } = s3;
              this._updatePreview({ dataTransfer: o4, domTarget: r3, clientX: a3 }), n4.stopPropagation(), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
            }, { priority: "low" }), this.listenTo(i3, "dragend", (t5, e5) => {
              this._finalizeDragging(!e5.dataTransfer.isCanceled && "move" == e5.dataTransfer.dropEffect);
            }, { priority: "low" }), this._domEmitter.listenTo(Li2.document, "dragend", () => {
              this._blockMode = false;
            }, { useCapture: true }), this.listenTo(i3, "dragenter", () => {
              this.isEnabled && n3.focus();
            }), this.listenTo(i3, "dragleave", () => {
              o3.removeDropMarkerDelayed();
            }), this.listenTo(i3, "dragging", (t5, e5) => {
              if (!this.isEnabled)
                return void (e5.dataTransfer.dropEffect = "none");
              const { clientX: n4, clientY: i4 } = e5.domEvent;
              o3.updateDropMarker(e5.target, e5.targetRanges, n4, i4, this._blockMode, this._draggedRange), this._draggedRange || (e5.dataTransfer.dropEffect = "copy"), c2.isGecko || ("copy" == e5.dataTransfer.effectAllowed ? e5.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(e5.dataTransfer.effectAllowed) && (e5.dataTransfer.dropEffect = "move")), t5.stop();
            }, { priority: "low" });
          }
          _setupClipboardInputIntegration() {
            const t4 = this.editor, e4 = t4.editing.view.document, n3 = t4.plugins.get(vw);
            this.listenTo(e4, "clipboardInput", (e5, i3) => {
              if ("drop" != i3.method)
                return;
              const { clientX: o3, clientY: r3 } = i3.domEvent, s3 = n3.getFinalDropRange(i3.target, i3.targetRanges, o3, r3, this._blockMode, this._draggedRange);
              if (!s3)
                return this._finalizeDragging(false), void e5.stop();
              this._draggedRange && this._draggingUid != i3.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
              if ("move" == Nw(i3.dataTransfer) && this._draggedRange && this._draggedRange.containsRange(s3, true))
                return this._finalizeDragging(false), void e5.stop();
              i3.targetRanges = [t4.editing.mapper.toViewRange(s3)];
            }, { priority: "high" });
          }
          _setupContentInsertionIntegration() {
            const t4 = this.editor.plugins.get(Nb2);
            t4.on("contentInsertion", (t5, e4) => {
              if (!this.isEnabled || "drop" !== e4.method)
                return;
              const n3 = e4.targetRanges.map((t6) => this.editor.editing.mapper.toModelRange(t6));
              this.editor.model.change((t6) => t6.setSelection(n3));
            }, { priority: "high" }), t4.on("contentInsertion", (t5, e4) => {
              if (!this.isEnabled || "drop" !== e4.method)
                return;
              const n3 = "move" == Nw(e4.dataTransfer), i3 = !e4.resultRange || !e4.resultRange.isCollapsed;
              this._finalizeDragging(i3 && n3);
            }, { priority: "lowest" });
          }
          _setupDraggableAttributeHandling() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document;
            this.listenTo(n3, "mousedown", (i3, o3) => {
              if (c2.isAndroid || !o3)
                return;
              this._clearDraggableAttributesDelayed.cancel();
              let r3 = Lw(o3.target);
              if (c2.isBlink && !t4.isReadOnly && !r3 && !n3.selection.isCollapsed) {
                const t5 = n3.selection.getSelectedElement();
                t5 && jb2(t5) || (r3 = n3.selection.editableElement);
              }
              r3 && (e4.change((t5) => {
                t5.setAttribute("draggable", "true", r3);
              }), this._draggableElement = t4.editing.mapper.toModelElement(r3));
            }), this.listenTo(n3, "mouseup", () => {
              c2.isAndroid || this._clearDraggableAttributesDelayed();
            });
          }
          _clearDraggableAttributes() {
            const t4 = this.editor.editing;
            t4.view.change((e4) => {
              this._draggableElement && "$graveyard" != this._draggableElement.root.rootName && e4.removeAttribute("draggable", t4.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
            });
          }
          _finalizeDragging(t4) {
            const e4 = this.editor, n3 = e4.model;
            if (e4.plugins.get(vw).removeDropMarker(), this._clearDraggableAttributes(), e4.plugins.has("WidgetToolbarRepository")) {
              e4.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop");
            }
            this._draggingUid = "", this._previewContainer && (this._previewContainer.remove(), this._previewContainer = void 0), this._draggedRange && (t4 && this.isEnabled && n3.change((t5) => {
              const e5 = n3.createSelection(this._draggedRange);
              n3.deleteContent(e5, { doNotAutoparagraph: true });
              const i3 = e5.getFirstPosition().parent;
              i3.isEmpty && !n3.schema.checkChild(i3, "$text") && n3.schema.checkChild(i3, "paragraph") && t5.insertElement("paragraph", i3, 0);
            }), this._draggedRange.detach(), this._draggedRange = null);
          }
          _prepareDraggedRange(t4) {
            const e4 = this.editor, n3 = e4.model, i3 = n3.document.selection, o3 = t4 ? Lw(t4) : null;
            if (o3) {
              const t5 = e4.editing.mapper.toModelElement(o3);
              if (this._draggedRange = md2.fromRange(n3.createRangeOn(t5)), this._blockMode = n3.schema.isBlock(t5), e4.plugins.has("WidgetToolbarRepository")) {
                e4.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
              }
              return;
            }
            if (i3.isCollapsed && !i3.getFirstPosition().parent.isEmpty)
              return;
            const r3 = Array.from(i3.getSelectedBlocks()), s3 = i3.getFirstRange();
            if (0 == r3.length)
              return void (this._draggedRange = md2.fromRange(s3));
            const a3 = zw(n3, r3);
            if (r3.length > 1)
              this._draggedRange = md2.fromRange(a3), this._blockMode = true;
            else if (1 == r3.length) {
              const t5 = s3.start.isTouching(a3.start) && s3.end.isTouching(a3.end);
              this._draggedRange = md2.fromRange(t5 ? a3 : s3), this._blockMode = t5;
            }
            n3.change((t5) => t5.setSelection(this._draggedRange.toRange()));
          }
          _updatePreview({ dataTransfer: t4, domTarget: e4, clientX: n3 }) {
            const i3 = this.editor.editing.view, o3 = i3.document.selection.editableElement, r3 = i3.domConverter.mapViewToDom(o3), s3 = Li2.window.getComputedStyle(r3);
            this._previewContainer ? this._previewContainer.firstElementChild && this._previewContainer.removeChild(this._previewContainer.firstElementChild) : (this._previewContainer = bt2(Li2.document, "div", { style: "position: fixed; left: -999999px;" }), Li2.document.body.appendChild(this._previewContainer));
            const a3 = new Vi2(r3);
            if (r3.contains(e4))
              return;
            const l3 = parseFloat(s3.paddingLeft), d3 = bt2(Li2.document, "div");
            d3.className = "ck ck-content", d3.style.width = s3.width, d3.style.paddingLeft = `${a3.left - n3 + l3}px`, c2.isiOS && (d3.style.backgroundColor = "white"), d3.innerHTML = t4.getData("text/html"), t4.setDragImage(d3, 0, 0), this._previewContainer.appendChild(d3);
          }
        }
        function Nw(t4) {
          return c2.isGecko ? t4.dropEffect : ["all", "copyMove"].includes(t4.effectAllowed) ? "move" : "copy";
        }
        function Lw(t4) {
          if (t4.is("editableElement"))
            return null;
          if (t4.hasClass("ck-widget__selection-handle"))
            return t4.findAncestor(jb2);
          if (jb2(t4))
            return t4;
          const e4 = t4.findAncestor((t5) => jb2(t5) || t5.is("editableElement"));
          return jb2(e4) ? e4 : null;
        }
        function zw(t4, e4) {
          const n3 = e4[0], i3 = e4[e4.length - 1], o3 = n3.getCommonAncestor(i3), r3 = t4.createPositionBefore(n3), s3 = t4.createPositionAfter(i3);
          if (o3 && o3.is("element") && !t4.schema.isLimit(o3)) {
            const e5 = t4.createRangeOn(o3), n4 = r3.isTouching(e5.start), i4 = s3.isTouching(e5.end);
            if (n4 && i4)
              return zw(t4, [o3]);
          }
          return t4.createRange(r3, s3);
        }
        class Pw extends bs {
          static get pluginName() {
            return "PastePlainText";
          }
          static get requires() {
            return [Nb2];
          }
          init() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, i3 = n3.document, o3 = e4.document.selection;
            let r3 = false;
            n3.addObserver(Sb2), this.listenTo(i3, "keydown", (t5, e5) => {
              r3 = e5.shiftKey;
            }), t4.plugins.get(Nb2).on("contentInsertion", (t5, n4) => {
              (r3 || function(t6, e5) {
                if (t6.childCount > 1)
                  return false;
                const n5 = t6.getChild(0);
                if (e5.isObject(n5))
                  return false;
                return 0 == Array.from(n5.getAttributeKeys()).length;
              }(n4.content, e4.schema)) && e4.change((t6) => {
                const i4 = Array.from(o3.getAttributes()).filter(([t7]) => e4.schema.getAttributeProperties(t7).isFormatting);
                o3.isCollapsed || e4.deleteContent(o3, { doNotAutoparagraph: true }), i4.push(...o3.getAttributes());
                const r4 = t6.createRangeIn(n4.content);
                for (const e5 of r4.getItems())
                  e5.is("$textProxy") && t6.setAttributes(i4, e5);
              });
            });
          }
        }
        class Rw extends bs {
          static get pluginName() {
            return "Clipboard";
          }
          static get requires() {
            return [Nb2, Mw, Pw];
          }
        }
        class Ow extends As {
          constructor(t4) {
            super(t4), this.affectsData = false;
          }
          execute() {
            const t4 = this.editor.model, e4 = t4.document.selection;
            let n3 = t4.schema.getLimitElement(e4);
            if (e4.containsEntireContent(n3) || !Fw(t4.schema, n3))
              do {
                if (n3 = n3.parent, !n3)
                  return;
              } while (!Fw(t4.schema, n3));
            t4.change((t5) => {
              t5.setSelection(n3, "in");
            });
          }
        }
        function Fw(t4, e4) {
          return t4.isLimit(e4) && (t4.checkChild(e4, "$text") || t4.checkChild(e4, "paragraph"));
        }
        const Vw = wo2("Ctrl+A");
        class jw extends bs {
          static get pluginName() {
            return "SelectAllEditing";
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view.document;
            t4.commands.add("selectAll", new Ow(t4)), this.listenTo(e4, "keydown", (e5, n3) => {
              bo2(n3) === Vw && (t4.execute("selectAll"), n3.preventDefault());
            });
          }
        }
        class Hw extends bs {
          static get pluginName() {
            return "SelectAllUI";
          }
          init() {
            const t4 = this.editor;
            t4.ui.componentFactory.add("selectAll", (e4) => {
              const n3 = t4.commands.get("selectAll"), i3 = new kr(e4), o3 = e4.t;
              return i3.set({ label: o3("Select all"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', keystroke: "Ctrl+A", tooltip: true }), i3.bind("isEnabled").to(n3, "isEnabled"), this.listenTo(i3, "execute", () => {
                t4.execute("selectAll"), t4.editing.view.focus();
              }), i3;
            });
          }
        }
        class Uw extends bs {
          static get requires() {
            return [jw, Hw];
          }
          static get pluginName() {
            return "SelectAll";
          }
        }
        class Gw extends As {
          constructor(t4) {
            super(t4), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this._isEnabledBasedOnSelection = false, this.listenTo(t4.data, "set", (t5, e4) => {
              e4[1] = { ...e4[1] };
              const n3 = e4[1];
              n3.batchType || (n3.batchType = { isUndoable: false });
            }, { priority: "high" }), this.listenTo(t4.data, "set", (t5, e4) => {
              e4[1].batchType.isUndoable || this.clearStack();
            });
          }
          refresh() {
            this.isEnabled = this._stack.length > 0;
          }
          get createdBatches() {
            return this._createdBatches;
          }
          addBatch(t4) {
            const e4 = this.editor.model.document.selection, n3 = { ranges: e4.hasOwnRange ? Array.from(e4.getRanges()) : [], isBackward: e4.isBackward };
            this._stack.push({ batch: t4, selection: n3 }), this.refresh();
          }
          clearStack() {
            this._stack = [], this.refresh();
          }
          _restoreSelection(t4, e4, n3) {
            const i3 = this.editor.model, o3 = i3.document, r3 = [], s3 = t4.map((t5) => t5.getTransformedByOperations(n3)), a3 = s3.flat();
            for (const t5 of s3) {
              const e5 = t5.filter((t6) => t6.root != o3.graveyard).filter((t6) => !qw(t6, a3));
              e5.length && (Ww(e5), r3.push(e5[0]));
            }
            r3.length && i3.change((t5) => {
              t5.setSelection(r3, { backward: e4 });
            });
          }
          _undo(t4, e4) {
            const n3 = this.editor.model, i3 = n3.document;
            this._createdBatches.add(e4);
            const o3 = t4.operations.slice().filter((t5) => t5.isDocumentOperation);
            o3.reverse();
            for (const t5 of o3) {
              const o4 = t5.baseVersion + 1, r3 = Array.from(i3.history.getOperations(o4)), s3 = qh2([t5.getReversed()], r3, { useRelations: true, document: this.editor.model.document, padWithNoOps: false, forceWeakRemove: true }).operationsA;
              for (let o5 of s3) {
                const r4 = o5.affectedSelectable;
                r4 && !n3.canEditAt(r4) && (o5 = new Ph2(o5.baseVersion)), e4.addOperation(o5), n3.applyOperation(o5), i3.history.setOperationAsUndone(t5, o5);
              }
            }
          }
        }
        function Ww(t4) {
          t4.sort((t5, e4) => t5.start.isBefore(e4.start) ? -1 : 1);
          for (let e4 = 1; e4 < t4.length; e4++) {
            const n3 = t4[e4 - 1].getJoined(t4[e4], true);
            n3 && (e4--, t4.splice(e4, 2, n3));
          }
        }
        function qw(t4, e4) {
          return e4.some((e5) => e5 !== t4 && e5.containsRange(t4, true));
        }
        class $w extends Gw {
          execute(t4 = null) {
            const e4 = t4 ? this._stack.findIndex((e5) => e5.batch == t4) : this._stack.length - 1, n3 = this._stack.splice(e4, 1)[0], i3 = this.editor.model.createBatch({ isUndo: true });
            this.editor.model.enqueueChange(i3, () => {
              this._undo(n3.batch, i3);
              const t5 = this.editor.model.document.history.getOperations(n3.batch.baseVersion);
              this._restoreSelection(n3.selection.ranges, n3.selection.isBackward, t5);
            }), this.fire("revert", n3.batch, i3), this.refresh();
          }
        }
        class Kw extends Gw {
          execute() {
            const t4 = this._stack.pop(), e4 = this.editor.model.createBatch({ isUndo: true });
            this.editor.model.enqueueChange(e4, () => {
              const n3 = t4.batch.operations[t4.batch.operations.length - 1].baseVersion + 1, i3 = this.editor.model.document.history.getOperations(n3);
              this._restoreSelection(t4.selection.ranges, t4.selection.isBackward, i3), this._undo(t4.batch, e4);
            }), this.refresh();
          }
        }
        class Zw extends bs {
          constructor() {
            super(...arguments), this._batchRegistry = /* @__PURE__ */ new WeakSet();
          }
          static get pluginName() {
            return "UndoEditing";
          }
          init() {
            const t4 = this.editor;
            this._undoCommand = new $w(t4), this._redoCommand = new Kw(t4), t4.commands.add("undo", this._undoCommand), t4.commands.add("redo", this._redoCommand), this.listenTo(t4.model, "applyOperation", (t5, e4) => {
              const n3 = e4[0];
              if (!n3.isDocumentOperation)
                return;
              const i3 = n3.batch, o3 = this._redoCommand.createdBatches.has(i3), r3 = this._undoCommand.createdBatches.has(i3);
              this._batchRegistry.has(i3) || (this._batchRegistry.add(i3), i3.isUndoable && (o3 ? this._undoCommand.addBatch(i3) : r3 || (this._undoCommand.addBatch(i3), this._redoCommand.clearStack())));
            }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (t5, e4, n3) => {
              this._redoCommand.addBatch(n3);
            }), t4.keystrokes.set("CTRL+Z", "undo"), t4.keystrokes.set("CTRL+Y", "redo"), t4.keystrokes.set("CTRL+SHIFT+Z", "redo");
          }
        }
        const Yw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', Qw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
        class Jw extends bs {
          static get pluginName() {
            return "UndoUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.locale, n3 = t4.t, i3 = "ltr" == e4.uiLanguageDirection ? Yw : Qw, o3 = "ltr" == e4.uiLanguageDirection ? Qw : Yw;
            this._addButton("undo", n3("Undo"), "CTRL+Z", i3), this._addButton("redo", n3("Redo"), "CTRL+Y", o3);
          }
          _addButton(t4, e4, n3, i3) {
            const o3 = this.editor;
            o3.ui.componentFactory.add(t4, (r3) => {
              const s3 = o3.commands.get(t4), a3 = new kr(r3);
              return a3.set({ label: e4, icon: i3, keystroke: n3, tooltip: true }), a3.bind("isEnabled").to(s3, "isEnabled"), this.listenTo(a3, "execute", () => {
                o3.execute(t4), o3.editing.view.focus();
              }), a3;
            });
          }
        }
        class Xw extends bs {
          static get requires() {
            return [Zw, Jw];
          }
          static get pluginName() {
            return "Undo";
          }
        }
        var tA = n2(6603), eA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(tA.Z, eA);
        tA.Z.locals;
        var nA = n2(3403), iA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(nA.Z, iA);
        nA.Z.locals;
        class oA extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = t4.t;
            this.set("matchCount", 0), this.set("highlightOffset", 0), this.set("isDirty", false), this.set("_areCommandsEnabled", {}), this.set("_resultsCounterText", ""), this.set("_matchCase", false), this.set("_wholeWordsOnly", false), this.bind("_searchResultsFound").to(this, "matchCount", this, "isDirty", (t5, e5) => t5 > 0 && !e5), this._findInputView = this._createInputField(e4("Find in text")), this._replaceInputView = this._createInputField(e4("Replace with")), this._findButtonView = this._createButton({ label: e4("Find"), class: "ck-button-find ck-button-action", withText: true }), this._findPrevButtonView = this._createButton({ label: e4("Previous result"), class: "ck-button-prev", icon: Gp, keystroke: "Shift+F3", tooltip: true }), this._findNextButtonView = this._createButton({ label: e4("Next result"), class: "ck-button-next", icon: Gp, keystroke: "F3", tooltip: true }), this._optionsDropdown = this._createOptionsDropdown(), this._replaceButtonView = this._createButton({ label: e4("Replace"), class: "ck-button-replace", withText: true }), this._replaceAllButtonView = this._createButton({ label: e4("Replace all"), class: "ck-button-replaceall", withText: true }), this._findFieldsetView = this._createFindFieldset(), this._replaceFieldsetView = this._createReplaceFieldset(), this._focusTracker = new To2(), this._keystrokes = new Io2(), this._focusables = new Ro2(), this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this._focusTracker, keystrokeHandler: this._keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-find-and-replace-form"], tabindex: "-1" }, children: [new jp(t4, { label: e4("Find and replace") }), this._findFieldsetView, this._replaceFieldsetView] });
          }
          render() {
            super.render(), o2({ view: this }), this._initFocusCycling(), this._initKeystrokeHandling();
          }
          destroy() {
            super.destroy(), this._focusTracker.destroy(), this._keystrokes.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          reset() {
            this._findInputView.errorText = null, this.isDirty = true;
          }
          get _textToFind() {
            return this._findInputView.fieldView.element.value;
          }
          get _textToReplace() {
            return this._replaceInputView.fieldView.element.value;
          }
          _createFindFieldset() {
            const t4 = this.locale, e4 = new Ho2(t4);
            return this._findInputView.fieldView.on("input", () => {
              this.isDirty = true;
            }), this._findButtonView.on("execute", this._onFindButtonExecute.bind(this)), this._findPrevButtonView.delegate("execute").to(this, "findPrevious"), this._findNextButtonView.delegate("execute").to(this, "findNext"), this._findPrevButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", ({ findPrevious: t5 }) => t5), this._findNextButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", ({ findNext: t5 }) => t5), this._injectFindResultsCounter(), e4.setTemplate({ tag: "fieldset", attributes: { class: ["ck", "ck-find-and-replace-form__find"] }, children: [this._findInputView, this._findButtonView, this._findPrevButtonView, this._findNextButtonView] }), e4;
          }
          _onFindButtonExecute() {
            if (this._textToFind)
              this.isDirty = false, this.fire("findNext", { searchText: this._textToFind, matchCase: this._matchCase, wholeWords: this._wholeWordsOnly });
            else {
              const t4 = this.t;
              this._findInputView.errorText = t4("Text to find must not be empty.");
            }
          }
          _injectFindResultsCounter() {
            const t4 = this.locale, e4 = t4.t, n3 = this.bindTemplate, i3 = new Ho2(this.locale);
            this.bind("_resultsCounterText").to(this, "highlightOffset", this, "matchCount", (t5, n4) => e4("%0 of %1", [t5, n4])), i3.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-results-counter", n3.if("isDirty", "ck-hidden")] }, children: [{ text: n3.to("_resultsCounterText") }] });
            const o3 = () => {
              const e5 = this._findInputView.fieldView.element;
              if (!e5 || !Ji2(e5))
                return;
              const n4 = new Vi2(i3.element).width, o4 = "ltr" === t4.uiLanguageDirection ? "paddingRight" : "paddingLeft";
              e5.style[o4] = n4 ? `calc( 2 * var(--ck-spacing-standard) + ${n4}px )` : "";
            };
            this.on("change:_resultsCounterText", o3, { priority: "low" }), this.on("change:isDirty", o3, { priority: "low" }), this._findInputView.template.children[0].children.push(i3);
          }
          _createReplaceFieldset() {
            const t4 = this.locale.t, e4 = new Ho2(this.locale);
            return this._replaceButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({ replace: t5 }, e5) => t5 && e5), this._replaceAllButtonView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({ replaceAll: t5 }, e5) => t5 && e5), this._replaceInputView.bind("isEnabled").to(this, "_areCommandsEnabled", this, "_searchResultsFound", ({ replace: t5 }, e5) => t5 && e5), this._replaceInputView.bind("infoText").to(this._replaceInputView, "isEnabled", this._replaceInputView, "isFocused", (e5, n3) => e5 || !n3 ? "" : t4("Tip: Find some text first in order to replace it.")), this._replaceButtonView.on("execute", () => {
              this.fire("replace", { searchText: this._textToFind, replaceText: this._textToReplace });
            }), this._replaceAllButtonView.on("execute", () => {
              this.fire("replaceAll", { searchText: this._textToFind, replaceText: this._textToReplace }), this.focus();
            }), e4.setTemplate({ tag: "fieldset", attributes: { class: ["ck", "ck-find-and-replace-form__replace"] }, children: [this._replaceInputView, this._optionsDropdown, this._replaceButtonView, this._replaceAllButtonView] }), e4;
          }
          _createOptionsDropdown() {
            const t4 = this.locale.t, e4 = om(this.locale);
            e4.class = "ck-options-dropdown", e4.buttonView.set({ withText: false, label: t4("Show options"), icon: Pg2.cog, tooltip: true });
            const n3 = new Up({ withText: true, label: t4("Match case"), _isMatchCaseSwitch: true }), i3 = new Up({ withText: true, label: t4("Whole words only") });
            return n3.bind("isOn").to(this, "_matchCase"), i3.bind("isOn").to(this, "_wholeWordsOnly"), e4.on("execute", (t5) => {
              t5.source._isMatchCaseSwitch ? this._matchCase = !this._matchCase : this._wholeWordsOnly = !this._wholeWordsOnly, this.isDirty = true;
            }), am(e4, new Do2([{ type: "switchbutton", model: n3 }, { type: "switchbutton", model: i3 }])), e4;
          }
          _initFocusCycling() {
            [this._findInputView, this._findButtonView, this._findPrevButtonView, this._findNextButtonView, this._replaceInputView, this._optionsDropdown, this._replaceButtonView, this._replaceAllButtonView].forEach((t4) => {
              this._focusables.add(t4), this._focusTracker.add(t4.element);
            });
          }
          _initKeystrokeHandling() {
            const t4 = (t5) => t5.stopPropagation(), e4 = (t5) => {
              t5.stopPropagation(), t5.preventDefault();
            };
            this._keystrokes.listenTo(this.element), this._keystrokes.set("f3", (t5) => {
              e4(t5), this._findNextButtonView.fire("execute");
            }), this._keystrokes.set("shift+f3", (t5) => {
              e4(t5), this._findPrevButtonView.fire("execute");
            }), this._keystrokes.set("enter", (t5) => {
              const n3 = t5.target;
              n3 === this._findInputView.fieldView.element ? (this._areCommandsEnabled.findNext ? this._findNextButtonView.fire("execute") : this._findButtonView.fire("execute"), e4(t5)) : n3 !== this._replaceInputView.fieldView.element || this.isDirty || (this._replaceButtonView.fire("execute"), e4(t5));
            }), this._keystrokes.set("shift+enter", (t5) => {
              t5.target === this._findInputView.fieldView.element && (this._areCommandsEnabled.findPrevious ? this._findPrevButtonView.fire("execute") : this._findButtonView.fire("execute"), e4(t5));
            }), this._keystrokes.set("arrowright", t4), this._keystrokes.set("arrowleft", t4), this._keystrokes.set("arrowup", t4), this._keystrokes.set("arrowdown", t4);
          }
          _createButton(t4) {
            const e4 = new kr(this.locale);
            return e4.set(t4), e4;
          }
          _createInputField(t4) {
            const e4 = new Xr(this.locale, hm);
            return e4.label = t4, e4;
          }
        }
        class rA extends bs {
          static get pluginName() {
            return "FindAndReplaceUI";
          }
          constructor(t4) {
            super(t4), this.formView = null;
          }
          init() {
            const t4 = this.editor;
            t4.ui.componentFactory.add("findAndReplace", (n3) => {
              const i3 = om(n3), o3 = t4.commands.get("find");
              return i3.bind("isEnabled").to(o3), i3.once("change:isOpen", () => {
                this.formView = new (e3(oA))(t4.locale), i3.panelView.children.add(this.formView), this._setupFormView(this.formView);
              }), i3.on("change:isOpen", (t5, e4, n4) => {
                n4 ? (this.formView.disableCssTransitions(), this.formView.reset(), this.formView._findInputView.fieldView.select(), this.formView.enableCssTransitions()) : this.fire("searchReseted");
              }, { priority: "low" }), this._setupDropdownButton(i3), i3;
            });
          }
          _setupDropdownButton(t4) {
            const e4 = this.editor, n3 = e4.locale.t;
            t4.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.87 13.786 1.532-1.286 3.857 4.596a1 1 0 1 1-1.532 1.286l-3.857-4.596z"/><path d="M16.004 8.5a6.5 6.5 0 0 1-9.216 5.905c-1.154-.53-.863-1.415-.663-1.615.194-.194.564-.592 1.635-.141a4.5 4.5 0 0 0 5.89-5.904l-.104-.227 1.332-1.331c.045-.046.196-.041.224.007a6.47 6.47 0 0 1 .902 3.306zm-3.4-5.715c.562.305.742 1.106.354 1.494-.388.388-.995.414-1.476.178a4.5 4.5 0 0 0-6.086 5.882l.114.236-1.348 1.349c-.038.037-.17.022-.198-.023a6.5 6.5 0 0 1 5.54-9.9 6.469 6.469 0 0 1 3.1.784z"/><path d="M4.001 11.93.948 8.877a.2.2 0 0 1 .141-.341h6.106a.2.2 0 0 1 .141.341L4.283 11.93a.2.2 0 0 1-.282 0zm11.083-6.789 3.053 3.053a.2.2 0 0 1-.14.342H11.89a.2.2 0 0 1-.14-.342l3.052-3.053a.2.2 0 0 1 .282 0z"/></svg>', label: n3("Find and replace"), keystroke: "CTRL+F", tooltip: true }), e4.keystrokes.set("Ctrl+F", (e5, n4) => {
              t4.isEnabled && (t4.isOpen = true, n4());
            });
          }
          _setupFormView(t4) {
            const e4 = this.editor.commands, n3 = this.editor.plugins.get("FindAndReplaceEditing").state, i3 = { before: -1, same: 0, after: 1, different: 1 };
            t4.bind("highlightOffset").to(n3, "highlightedResult", (t5) => t5 ? Array.from(n3.results).sort((t6, e5) => i3[t6.marker.getStart().compareWith(e5.marker.getStart())]).indexOf(t5) + 1 : 0), t4.listenTo(n3.results, "change", () => {
              t4.matchCount = n3.results.length;
            });
            const o3 = e4.get("findNext"), r3 = e4.get("findPrevious"), s3 = e4.get("replace"), a3 = e4.get("replaceAll");
            t4.bind("_areCommandsEnabled").to(o3, "isEnabled", r3, "isEnabled", s3, "isEnabled", a3, "isEnabled", (t5, e5, n4, i4) => ({ findNext: t5, findPrevious: e5, replace: n4, replaceAll: i4 })), t4.delegate("findNext", "findPrevious", "replace", "replaceAll").to(this), t4.on("change:isDirty", (t5, e5, n4) => {
              n4 && this.fire("searchReseted");
            });
          }
        }
        class sA extends As {
          constructor(t4, e4) {
            super(t4), this.isEnabled = true, this.affectsData = false, this._state = e4;
          }
          execute(t4, { matchCase: e4, wholeWords: n3 } = {}) {
            const { editor: i3 } = this, { model: o3 } = i3, r3 = i3.plugins.get("FindAndReplaceUtils");
            let s3;
            "string" == typeof t4 ? (s3 = r3.findByTextCallback(t4, { matchCase: e4, wholeWords: n3 }), this._state.searchText = t4) : s3 = t4;
            const a3 = o3.document.getRootNames().reduce((t5, e5) => r3.updateFindResultFromRange(o3.createRangeIn(o3.document.getRoot(e5)), o3, s3, t5), null);
            return this._state.clear(o3), this._state.results.addMany(a3), this._state.highlightedResult = a3.get(0), "string" == typeof t4 && (this._state.searchText = t4), this._state.matchCase = !!e4, this._state.matchWholeWords = !!n3, { results: a3, findCallback: s3 };
          }
        }
        class aA extends As {
          constructor(t4, e4) {
            super(t4), this.isEnabled = true, this._state = e4, this._isEnabledBasedOnSelection = false;
          }
          _replace(t4, e4) {
            const { model: n3 } = this.editor, i3 = e4.marker.getRange();
            n3.canEditAt(i3) && n3.change((o3) => {
              if ("$graveyard" === i3.root.rootName)
                return void this._state.results.remove(e4);
              let r3 = {};
              for (const t5 of i3.getItems())
                if (t5.is("$text") || t5.is("$textProxy")) {
                  r3 = t5.getAttributes();
                  break;
                }
              n3.insertContent(o3.createText(t4, r3), i3), this._state.results.has(e4) && this._state.results.remove(e4);
            });
          }
        }
        class cA extends aA {
          execute(t4, e4) {
            this._replace(t4, e4);
          }
        }
        class lA extends aA {
          execute(t4, e4) {
            const { editor: n3 } = this, { model: i3 } = n3, o3 = n3.plugins.get("FindAndReplaceUtils"), r3 = e4 instanceof Do2 ? e4 : i3.document.getRootNames().reduce((t5, n4) => o3.updateFindResultFromRange(i3.createRangeIn(i3.document.getRoot(n4)), i3, o3.findByTextCallback(e4, this._state), t5), null);
            r3.length && i3.change(() => {
              [...r3].forEach((e5) => {
                this._replace(t4, e5);
              });
            });
          }
        }
        class dA extends As {
          constructor(t4, e4) {
            super(t4), this.affectsData = false, this._state = e4, this.isEnabled = false, this.listenTo(this._state.results, "change", () => {
              this.isEnabled = this._state.results.length > 1;
            });
          }
          refresh() {
            this.isEnabled = this._state.results.length > 1;
          }
          execute() {
            const t4 = this._state.results, e4 = t4.getIndex(this._state.highlightedResult), n3 = e4 + 1 >= t4.length ? 0 : e4 + 1;
            this._state.highlightedResult = this._state.results.get(n3);
          }
        }
        class hA extends dA {
          execute() {
            const t4 = this._state.results.getIndex(this._state.highlightedResult), e4 = t4 - 1 < 0 ? this._state.results.length - 1 : t4 - 1;
            this._state.highlightedResult = this._state.results.get(e4);
          }
        }
        class uA extends q2() {
          constructor(t4) {
            super(), this.set("results", new Do2()), this.set("highlightedResult", null), this.set("searchText", ""), this.set("replaceText", ""), this.set("matchCase", false), this.set("matchWholeWords", false), this.results.on("change", (e4, { removed: n3, index: i3 }) => {
              if (Array.from(n3).length) {
                let e5 = false;
                if (t4.change((i4) => {
                  for (const o3 of n3)
                    this.highlightedResult === o3 && (e5 = true), t4.markers.has(o3.marker.name) && i4.removeMarker(o3.marker);
                }), e5) {
                  const t5 = i3 >= this.results.length ? 0 : i3;
                  this.highlightedResult = this.results.get(t5);
                }
              }
            });
          }
          clear(t4) {
            this.searchText = "", t4.change((e4) => {
              if (this.highlightedResult) {
                const n3 = this.highlightedResult.marker.name.split(":")[1], i3 = t4.markers.get(`findResultHighlighted:${n3}`);
                i3 && e4.removeMarker(i3);
              }
              [...this.results].forEach(({ marker: t5 }) => {
                e4.removeMarker(t5);
              });
            }), this.results.clear();
          }
        }
        class gA extends bs {
          static get pluginName() {
            return "FindAndReplaceUtils";
          }
          updateFindResultFromRange(t4, e4, n3, i3) {
            const o3 = i3 || new Do2();
            return e4.change((i4) => {
              [...t4].forEach(({ type: t5, item: r3 }) => {
                if ("elementStart" === t5 && e4.schema.checkChild(r3, "$text")) {
                  const t6 = n3({ item: r3, text: this.rangeToText(e4.createRangeIn(r3)) });
                  if (!t6)
                    return;
                  t6.forEach((t7) => {
                    const e5 = `findResult:${k2()}`, n4 = i4.addMarker(e5, { usingOperation: false, affectsData: false, range: i4.createRange(i4.createPositionAt(r3, t7.start), i4.createPositionAt(r3, t7.end)) }), s3 = function(t8, e6) {
                      const n5 = t8.find(({ marker: t9 }) => e6.getStart().isBefore(t9.getStart()));
                      return n5 ? t8.getIndex(n5) : t8.length;
                    }(o3, n4);
                    o3.add({ id: e5, label: t7.label, marker: n4 }, s3);
                  });
                }
              });
            }), o3;
          }
          rangeToText(t4) {
            return Array.from(t4.getItems()).reduce((t5, e4) => e4.is("$text") || e4.is("$textProxy") ? t5 + e4.data : `${t5}
`, "");
          }
          findByTextCallback(t4, e4) {
            let n3 = "gu";
            e4.matchCase || (n3 += "i");
            let i3 = `(${lf2(t4)})`;
            if (e4.wholeWords) {
              const e5 = "[^a-zA-Z--]";
              new RegExp("^" + e5).test(t4) || (i3 = `(^|${e5}|_)${i3}`), new RegExp(e5 + "$").test(t4) || (i3 = `${i3}(?=_|${e5}|$)`);
            }
            const o3 = new RegExp(i3, n3);
            return function({ text: t5 }) {
              return [...t5.matchAll(o3)].map(mA);
            };
          }
        }
        function mA(t4) {
          const e4 = t4.length - 1;
          let n3 = t4.index;
          return 3 === t4.length && (n3 += t4[1].length), { label: t4[e4], start: n3, end: n3 + t4[e4].length };
        }
        var pA = n2(2218), fA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(pA.Z, fA);
        pA.Z.locals;
        class kA extends bs {
          static get requires() {
            return [gA];
          }
          static get pluginName() {
            return "FindAndReplaceEditing";
          }
          init() {
            this._activeResults = null, this.state = new uA(this.editor.model), this._defineConverters(), this._defineCommands(), this.listenTo(this.state, "change:highlightedResult", (t5, e4, n3, i3) => {
              const { model: o3 } = this.editor;
              o3.change((t6) => {
                if (i3) {
                  const e5 = i3.marker.name.split(":")[1], n4 = o3.markers.get(`findResultHighlighted:${e5}`);
                  n4 && t6.removeMarker(n4);
                }
                if (n3) {
                  const e5 = n3.marker.name.split(":")[1];
                  t6.addMarker(`findResultHighlighted:${e5}`, { usingOperation: false, affectsData: false, range: n3.marker.getRange() });
                }
              });
            });
            const t4 = $r(((t5, e4, n3) => {
              if (n3) {
                const t6 = this.editor.editing.view.domConverter, e5 = this.editor.editing.mapper.toViewRange(n3.marker.getRange());
                io2({ target: t6.viewRangeToDom(e5), viewportOffset: 40 });
              }
            }).bind(this), 32);
            this.listenTo(this.state, "change:highlightedResult", t4, { priority: "low" }), this.listenTo(this.editor, "destroy", t4.cancel);
          }
          find(t4) {
            const { editor: e4 } = this, { model: n3 } = e4, { findCallback: i3, results: o3 } = e4.execute("find", t4);
            return this._activeResults = o3, this.listenTo(n3.document, "change:data", () => function(t5, e5, n4) {
              const i4 = /* @__PURE__ */ new Set(), o4 = /* @__PURE__ */ new Set(), r3 = e5.model;
              r3.document.differ.getChanges().forEach((t6) => {
                "$text" === t6.name || r3.schema.isInline(t6.position.nodeAfter) ? (i4.add(t6.position.parent), [...r3.markers.getMarkersAtPosition(t6.position)].forEach((t7) => {
                  o4.add(t7.name);
                })) : "insert" === t6.type && i4.add(t6.position.nodeAfter);
              }), r3.document.differ.getChangedMarkers().forEach(({ name: t6, data: { newRange: e6 } }) => {
                e6 && "$graveyard" === e6.start.root.rootName && o4.add(t6);
              }), i4.forEach((t6) => {
                [...r3.markers.getMarkersIntersectingRange(r3.createRangeIn(t6))].forEach((t7) => o4.add(t7.name));
              }), r3.change((e6) => {
                o4.forEach((n5) => {
                  t5.has(n5) && t5.remove(n5), e6.removeMarker(n5);
                });
              }), i4.forEach((i5) => {
                e5.plugins.get("FindAndReplaceUtils").updateFindResultFromRange(r3.createRangeOn(i5), r3, n4, t5);
              });
            }(this._activeResults, e4, i3)), this._activeResults;
          }
          stop() {
            this._activeResults && (this.stopListening(this.editor.model.document), this.state.clear(this.editor.model), this._activeResults = null);
          }
          _defineCommands() {
            this.editor.commands.add("find", new sA(this.editor, this.state)), this.editor.commands.add("findNext", new dA(this.editor, this.state)), this.editor.commands.add("findPrevious", new hA(this.editor, this.state)), this.editor.commands.add("replace", new cA(this.editor, this.state)), this.editor.commands.add("replaceAll", new lA(this.editor, this.state));
          }
          _defineConverters() {
            const { editor: t4 } = this;
            t4.conversion.for("editingDowncast").markerToHighlight({ model: "findResult", view: ({ markerName: t5 }) => {
              const [, e4] = t5.split(":");
              return { name: "span", classes: ["ck-find-result"], attributes: { "data-find-result": e4 } };
            } }), t4.conversion.for("editingDowncast").markerToHighlight({ model: "findResultHighlighted", view: ({ markerName: t5 }) => {
              const [, e4] = t5.split(":");
              return { name: "span", classes: ["ck-find-result_selected"], attributes: { "data-find-result": e4 } };
            } });
          }
        }
        class bA extends As {
          constructor(t4, e4) {
            super(t4), this.attributeKey = e4;
          }
          refresh() {
            const t4 = this.editor.model, e4 = t4.document;
            this.value = e4.selection.getAttribute(this.attributeKey), this.isEnabled = t4.schema.checkAttributeInSelection(e4.selection, this.attributeKey);
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = t4.value, o3 = t4.batch, r3 = (t5) => {
              if (n3.isCollapsed)
                i3 ? t5.setSelectionAttribute(this.attributeKey, i3) : t5.removeSelectionAttribute(this.attributeKey);
              else {
                const o4 = e4.schema.getValidRanges(n3.getRanges(), this.attributeKey);
                for (const e5 of o4)
                  i3 ? t5.setAttribute(this.attributeKey, i3, e5) : t5.removeAttribute(this.attributeKey, e5);
              }
            };
            o3 ? e4.enqueueChange(o3, (t5) => {
              r3(t5);
            }) : e4.change((t5) => {
              r3(t5);
            });
          }
        }
        const wA = "fontColor", AA = "fontBackgroundColor";
        function CA(t4) {
          return (e4) => e4.getStyle(t4).replace(/\s/g, "");
        }
        function _A(t4) {
          return (e4, { writer: n3 }) => n3.createAttributeElement("span", { style: `${t4}:${e4}` }, { priority: 7 });
        }
        var vA = n2(5991), yA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(vA.Z, yA);
        vA.Z.locals;
        class xA extends bA {
          constructor(t4) {
            super(t4, wA);
          }
        }
        class EA extends bs {
          static get pluginName() {
            return "FontColorEditing";
          }
          constructor(t4) {
            super(t4), t4.config.define(wA, { colors: [{ color: "hsl(0, 0%, 0%)", label: "Black" }, { color: "hsl(0, 0%, 30%)", label: "Dim grey" }, { color: "hsl(0, 0%, 60%)", label: "Grey" }, { color: "hsl(0, 0%, 90%)", label: "Light grey" }, { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true }, { color: "hsl(0, 75%, 60%)", label: "Red" }, { color: "hsl(30, 75%, 60%)", label: "Orange" }, { color: "hsl(60, 75%, 60%)", label: "Yellow" }, { color: "hsl(90, 75%, 60%)", label: "Light green" }, { color: "hsl(120, 75%, 60%)", label: "Green" }, { color: "hsl(150, 75%, 60%)", label: "Aquamarine" }, { color: "hsl(180, 75%, 60%)", label: "Turquoise" }, { color: "hsl(210, 75%, 60%)", label: "Light blue" }, { color: "hsl(240, 75%, 60%)", label: "Blue" }, { color: "hsl(270, 75%, 60%)", label: "Purple" }], columns: 5 }), t4.conversion.for("upcast").elementToAttribute({ view: { name: "span", styles: { color: /[\s\S]+/ } }, model: { key: wA, value: CA("color") } }), t4.conversion.for("upcast").elementToAttribute({ view: { name: "font", attributes: { color: /^#?\w+$/ } }, model: { key: wA, value: (t5) => t5.getAttribute("color") } }), t4.conversion.for("downcast").attributeToElement({ model: wA, view: _A("color") }), t4.commands.add(wA, new xA(t4)), t4.model.schema.extend("$text", { allowAttributes: wA }), t4.model.schema.setAttributeProperties(wA, { isFormatting: true, copyOnEnter: true });
          }
        }
        class DA extends bs {
          constructor(t4, { commandName: e4, componentName: n3, icon: i3, dropdownLabel: o3 }) {
            super(t4), this.commandName = e4, this.componentName = n3, this.icon = i3, this.dropdownLabel = o3, this.columns = t4.config.get(`${this.componentName}.columns`), this.colorSelectorView = void 0;
          }
          init() {
            const t4 = this.editor, e4 = t4.locale, n3 = e4.t, i3 = t4.commands.get(this.commandName), o3 = t4.config.get(this.componentName), r3 = Cr(e4, _r(o3.colors)), s3 = o3.documentColors, a3 = false !== o3.colorPicker;
            t4.ui.componentFactory.add(this.componentName, (e5) => {
              const c3 = om(e5);
              let l3 = false;
              return this.colorSelectorView = function({ dropdownView: t5, colors: e6, columns: n4, removeButtonLabel: i4, colorPickerLabel: o4, documentColorsLabel: r4, documentColorsCount: s4, colorPickerViewConfig: a4 }) {
                const c4 = t5.locale, l4 = new ep(c4, { colors: e6, columns: n4, removeButtonLabel: i4, colorPickerLabel: o4, documentColorsLabel: r4, documentColorsCount: s4, colorPickerViewConfig: a4 });
                return t5.colorSelectorView = l4, t5.panelView.children.add(l4), l4;
              }({ dropdownView: c3, colors: r3.map((t5) => ({ label: t5.label, color: t5.model, options: { hasBorder: t5.hasBorder } })), columns: this.columns, removeButtonLabel: n3("Remove color"), colorPickerLabel: n3("Color picker"), documentColorsLabel: 0 !== s3 ? n3("Document colors") : "", documentColorsCount: void 0 === s3 ? this.columns : s3, colorPickerViewConfig: !!a3 && (o3.colorPicker || {}) }), this.colorSelectorView.bind("selectedColor").to(i3, "value"), c3.buttonView.set({ label: this.dropdownLabel, icon: this.icon, tooltip: true }), c3.extendTemplate({ attributes: { class: "ck-color-ui-dropdown" } }), c3.bind("isEnabled").to(i3), this.colorSelectorView.on("execute", (e6, n4) => {
                c3.isOpen && t4.execute(this.commandName, { value: n4.value, batch: this._undoStepBatch }), "colorPicker" !== n4.source && t4.editing.view.focus(), "colorPickerSaveButton" === n4.source && (c3.isOpen = false);
              }), this.colorSelectorView.on("colorPicker:show", () => {
                this._undoStepBatch = t4.model.createBatch();
              }), this.colorSelectorView.on("colorPicker:cancel", () => {
                this._undoStepBatch.operations.length && (c3.isOpen = false, t4.execute("undo", this._undoStepBatch)), t4.editing.view.focus();
              }), c3.on("change:isOpen", (e6, n4, i4) => {
                l3 || (l3 = true, c3.colorSelectorView.appendUI()), i4 && (0 !== s3 && this.colorSelectorView.updateDocumentColors(t4.model, this.componentName), this.colorSelectorView.updateSelectedColors(), this.colorSelectorView.showColorGridsFragment());
              }), lm(c3, () => c3.colorSelectorView.colorGridsFragmentView.staticColorsGrid.items.find((t5) => t5.isOn)), c3;
            });
          }
        }
        class SA extends DA {
          constructor(t4) {
            const e4 = t4.locale.t;
            super(t4, { commandName: wA, componentName: wA, icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.4 10.3 10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z"/></svg>', dropdownLabel: e4("Font Color") });
          }
          static get pluginName() {
            return "FontColorUI";
          }
        }
        class TA extends bA {
          constructor(t4) {
            super(t4, AA);
          }
        }
        class IA extends bs {
          static get pluginName() {
            return "FontBackgroundColorEditing";
          }
          constructor(t4) {
            super(t4), t4.config.define(AA, { colors: [{ color: "hsl(0, 0%, 0%)", label: "Black" }, { color: "hsl(0, 0%, 30%)", label: "Dim grey" }, { color: "hsl(0, 0%, 60%)", label: "Grey" }, { color: "hsl(0, 0%, 90%)", label: "Light grey" }, { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true }, { color: "hsl(0, 75%, 60%)", label: "Red" }, { color: "hsl(30, 75%, 60%)", label: "Orange" }, { color: "hsl(60, 75%, 60%)", label: "Yellow" }, { color: "hsl(90, 75%, 60%)", label: "Light green" }, { color: "hsl(120, 75%, 60%)", label: "Green" }, { color: "hsl(150, 75%, 60%)", label: "Aquamarine" }, { color: "hsl(180, 75%, 60%)", label: "Turquoise" }, { color: "hsl(210, 75%, 60%)", label: "Light blue" }, { color: "hsl(240, 75%, 60%)", label: "Blue" }, { color: "hsl(270, 75%, 60%)", label: "Purple" }], columns: 5 }), t4.data.addStyleProcessorRules(mg2), t4.conversion.for("upcast").elementToAttribute({ view: { name: "span", styles: { "background-color": /[\s\S]+/ } }, model: { key: AA, value: CA("background-color") } }), t4.conversion.for("downcast").attributeToElement({ model: AA, view: _A("background-color") }), t4.commands.add(AA, new TA(t4)), t4.model.schema.extend("$text", { allowAttributes: AA }), t4.model.schema.setAttributeProperties(AA, { isFormatting: true, copyOnEnter: true });
          }
        }
        class BA extends DA {
          constructor(t4) {
            const e4 = t4.locale.t;
            super(t4, { commandName: AA, componentName: AA, icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z"/></svg>', dropdownLabel: e4("Font Background Color") });
          }
          static get pluginName() {
            return "FontBackgroundColorUI";
          }
        }
        class MA extends As {
          constructor(t4) {
            super(t4), this._isEnabledBasedOnSelection = false;
          }
          refresh() {
            const t4 = this.editor.model, e4 = So2(t4.document.selection.getSelectedBlocks());
            this.value = !!e4 && e4.is("element", "paragraph"), this.isEnabled = !!e4 && NA(e4, t4.schema);
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document, i3 = t4.selection || n3.selection;
            e4.canEditAt(i3) && e4.change((t5) => {
              const n4 = i3.getSelectedBlocks();
              for (const i4 of n4)
                !i4.is("element", "paragraph") && NA(i4, e4.schema) && t5.rename(i4, "paragraph");
            });
          }
        }
        function NA(t4, e4) {
          return e4.checkChild(t4.parent, "paragraph") && !e4.isObject(t4);
        }
        class LA extends As {
          constructor(t4) {
            super(t4), this._isEnabledBasedOnSelection = false;
          }
          execute(t4) {
            const e4 = this.editor.model, n3 = t4.attributes;
            let i3 = t4.position;
            e4.canEditAt(i3) && e4.change((t5) => {
              if (i3 = this._findPositionToInsertParagraph(i3, t5), !i3)
                return;
              const o3 = t5.createElement("paragraph");
              n3 && e4.schema.setAllowedAttributes(o3, n3, t5), e4.insertContent(o3, i3), t5.setSelection(o3, "in");
            });
          }
          _findPositionToInsertParagraph(t4, e4) {
            const n3 = this.editor.model;
            if (n3.schema.checkChild(t4, "paragraph"))
              return t4;
            const i3 = n3.schema.findAllowedParent(t4, "paragraph");
            if (!i3)
              return null;
            const o3 = t4.parent, r3 = n3.schema.checkChild(o3, "$text");
            return o3.isEmpty || r3 && t4.isAtEnd ? n3.createPositionAfter(o3) : !o3.isEmpty && r3 && t4.isAtStart ? n3.createPositionBefore(o3) : e4.split(t4, i3).position;
          }
        }
        class zA extends bs {
          static get pluginName() {
            return "Paragraph";
          }
          init() {
            const t4 = this.editor, e4 = t4.model;
            t4.commands.add("paragraph", new MA(t4)), t4.commands.add("insertParagraph", new LA(t4)), e4.schema.register("paragraph", { inheritAllFrom: "$block" }), t4.conversion.elementToElement({ model: "paragraph", view: "p" }), t4.conversion.for("upcast").elementToElement({ model: (t5, { writer: e5 }) => zA.paragraphLikeElements.has(t5.name) ? t5.isEmpty ? null : e5.createElement("paragraph") : null, view: /.+/, converterPriority: "low" });
          }
        }
        zA.paragraphLikeElements = /* @__PURE__ */ new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
        class PA extends As {
          constructor(t4, e4) {
            super(t4), this.modelElements = e4;
          }
          refresh() {
            const t4 = So2(this.editor.model.document.selection.getSelectedBlocks());
            this.value = !!t4 && this.modelElements.includes(t4.name) && t4.name, this.isEnabled = !!t4 && this.modelElements.some((e4) => RA(t4, e4, this.editor.model.schema));
          }
          execute(t4) {
            const e4 = this.editor.model, n3 = e4.document, i3 = t4.value;
            e4.change((t5) => {
              const o3 = Array.from(n3.selection.getSelectedBlocks()).filter((t6) => RA(t6, i3, e4.schema));
              for (const e5 of o3)
                e5.is("element", i3) || t5.rename(e5, i3);
            });
          }
        }
        function RA(t4, e4, n3) {
          return n3.checkChild(t4.parent, e4) && !n3.isObject(t4);
        }
        const OA = "paragraph";
        class FA extends bs {
          static get pluginName() {
            return "HeadingEditing";
          }
          constructor(t4) {
            super(t4), t4.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
          }
          static get requires() {
            return [zA];
          }
          init() {
            const t4 = this.editor, e4 = t4.config.get("heading.options"), n3 = [];
            for (const i3 of e4)
              "paragraph" !== i3.model && (t4.model.schema.register(i3.model, { inheritAllFrom: "$block" }), t4.conversion.elementToElement(i3), n3.push(i3.model));
            this._addDefaultH1Conversion(t4), t4.commands.add("heading", new PA(t4, n3));
          }
          afterInit() {
            const t4 = this.editor, e4 = t4.commands.get("enter"), n3 = t4.config.get("heading.options");
            e4 && this.listenTo(e4, "afterExecute", (e5, i3) => {
              const o3 = t4.model.document.selection.getFirstPosition().parent;
              n3.some((t5) => o3.is("element", t5.model)) && !o3.is("element", OA) && 0 === o3.childCount && i3.writer.rename(o3, OA);
            });
          }
          _addDefaultH1Conversion(t4) {
            t4.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: b2.low + 1 });
          }
        }
        var VA = n2(4249), jA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(VA.Z, jA);
        VA.Z.locals;
        class HA extends bs {
          static get pluginName() {
            return "HeadingUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t, n3 = function(t5) {
              const e5 = t5.t, n4 = { Paragraph: e5("Paragraph"), "Heading 1": e5("Heading 1"), "Heading 2": e5("Heading 2"), "Heading 3": e5("Heading 3"), "Heading 4": e5("Heading 4"), "Heading 5": e5("Heading 5"), "Heading 6": e5("Heading 6") };
              return t5.config.get("heading.options").map((t6) => {
                const e6 = n4[t6.title];
                return e6 && e6 != t6.title && (t6.title = e6), t6;
              });
            }(t4), i3 = e4("Choose heading"), o3 = e4("Heading");
            t4.ui.componentFactory.add("heading", (e5) => {
              const r3 = {}, s3 = new Do2(), a3 = t4.commands.get("heading"), c3 = t4.commands.get("paragraph"), l3 = [a3];
              for (const t5 of n3) {
                const e6 = { type: "button", model: new Up({ label: t5.title, class: t5.class, role: "menuitemradio", withText: true }) };
                "paragraph" === t5.model ? (e6.model.bind("isOn").to(c3, "value"), e6.model.set("commandName", "paragraph"), l3.push(c3)) : (e6.model.bind("isOn").to(a3, "value", (e7) => e7 === t5.model), e6.model.set({ commandName: "heading", commandValue: t5.model })), s3.add(e6), r3[t5.model] = t5.title;
              }
              const d3 = om(e5);
              return am(d3, s3, { ariaLabel: o3, role: "menu" }), d3.buttonView.set({ ariaLabel: o3, ariaLabelledBy: void 0, isOn: false, withText: true, tooltip: o3 }), d3.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), d3.bind("isEnabled").toMany(l3, "isEnabled", (...t5) => t5.some((t6) => t6)), d3.buttonView.bind("label").to(a3, "value", c3, "value", (t5, e6) => {
                const n4 = t5 || e6 && "paragraph";
                return "boolean" == typeof n4 ? i3 : r3[n4] ? r3[n4] : i3;
              }), this.listenTo(d3, "execute", (e6) => {
                const { commandName: n4, commandValue: i4 } = e6.source;
                t4.execute(n4, i4 ? { value: i4 } : void 0), t4.editing.view.focus();
              }), d3;
            });
          }
        }
        class UA extends As {
          refresh() {
            const t4 = this.editor.model, e4 = t4.document;
            this.value = e4.selection.getAttribute("highlight"), this.isEnabled = t4.schema.checkAttributeInSelection(e4.selection, "highlight");
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = t4.value;
            e4.change((t5) => {
              if (n3.isCollapsed) {
                const e5 = n3.getFirstPosition();
                if (n3.hasAttribute("highlight")) {
                  const n4 = (t6) => t6.item.hasAttribute("highlight") && t6.item.getAttribute("highlight") === this.value, o3 = e5.getLastMatchingPosition(n4, { direction: "backward" }), r3 = e5.getLastMatchingPosition(n4), s3 = t5.createRange(o3, r3);
                  i3 && this.value !== i3 ? (e5.isEqual(r3) || t5.setAttribute("highlight", i3, s3), t5.setSelectionAttribute("highlight", i3)) : (e5.isEqual(r3) || t5.removeAttribute("highlight", s3), t5.removeSelectionAttribute("highlight"));
                } else
                  i3 && t5.setSelectionAttribute("highlight", i3);
              } else {
                const o3 = e4.schema.getValidRanges(n3.getRanges(), "highlight");
                for (const e5 of o3)
                  i3 ? t5.setAttribute("highlight", i3, e5) : t5.removeAttribute("highlight", e5);
              }
            });
          }
        }
        class GA extends bs {
          static get pluginName() {
            return "HighlightEditing";
          }
          constructor(t4) {
            super(t4), t4.config.define("highlight", { options: [{ model: "yellowMarker", class: "marker-yellow", title: "Yellow marker", color: "var(--ck-highlight-marker-yellow)", type: "marker" }, { model: "greenMarker", class: "marker-green", title: "Green marker", color: "var(--ck-highlight-marker-green)", type: "marker" }, { model: "pinkMarker", class: "marker-pink", title: "Pink marker", color: "var(--ck-highlight-marker-pink)", type: "marker" }, { model: "blueMarker", class: "marker-blue", title: "Blue marker", color: "var(--ck-highlight-marker-blue)", type: "marker" }, { model: "redPen", class: "pen-red", title: "Red pen", color: "var(--ck-highlight-pen-red)", type: "pen" }, { model: "greenPen", class: "pen-green", title: "Green pen", color: "var(--ck-highlight-pen-green)", type: "pen" }] });
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: "highlight" });
            const e4 = t4.config.get("highlight.options");
            t4.conversion.attributeToElement(function(t5) {
              const e5 = { model: { key: "highlight", values: [] }, view: {} };
              for (const n3 of t5)
                e5.model.values.push(n3.model), e5.view[n3.model] = { name: "mark", classes: n3.class };
              return e5;
            }(e4)), t4.commands.add("highlight", new UA(t4));
          }
        }
        var WA = n2(7263), qA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(WA.Z, qA);
        WA.Z.locals;
        class $A extends bs {
          get localizedOptionTitles() {
            const t4 = this.editor.t;
            return { "Yellow marker": t4("Yellow marker"), "Green marker": t4("Green marker"), "Pink marker": t4("Pink marker"), "Blue marker": t4("Blue marker"), "Red pen": t4("Red pen"), "Green pen": t4("Green pen") };
          }
          static get pluginName() {
            return "HighlightUI";
          }
          init() {
            const t4 = this.editor.config.get("highlight.options");
            for (const e4 of t4)
              this._addHighlighterButton(e4);
            this._addRemoveHighlightButton(), this._addDropdown(t4);
          }
          _addRemoveHighlightButton() {
            const t4 = this.editor.t, e4 = this.editor.commands.get("highlight");
            this._addButton("removeHighlight", t4("Remove highlight"), Pg2.eraser, null, (t5) => {
              t5.bind("isEnabled").to(e4, "isEnabled");
            });
          }
          _addHighlighterButton(t4) {
            const e4 = this.editor.commands.get("highlight");
            this._addButton("highlight:" + t4.model, t4.title, KA(t4.type), t4.model, function(n3) {
              n3.bind("isEnabled").to(e4, "isEnabled"), n3.bind("isOn").to(e4, "value", (e5) => e5 === t4.model), n3.iconView.fillColor = t4.color, n3.isToggleable = true;
            });
          }
          _addButton(t4, e4, n3, i3, o3) {
            const r3 = this.editor;
            r3.ui.componentFactory.add(t4, (t5) => {
              const s3 = new kr(t5), a3 = this.localizedOptionTitles[e4] ? this.localizedOptionTitles[e4] : e4;
              return s3.set({ label: a3, icon: n3, tooltip: true }), s3.on("execute", () => {
                r3.execute("highlight", { value: i3 }), r3.editing.view.focus();
              }), o3(s3), s3;
            });
          }
          _addDropdown(t4) {
            const e4 = this.editor, n3 = e4.t, i3 = e4.ui.componentFactory, o3 = t4[0], r3 = t4.reduce((t5, e5) => (t5[e5.model] = e5, t5), {});
            i3.add("highlight", (s3) => {
              const a3 = e4.commands.get("highlight"), c3 = om(s3, Xg2), l3 = c3.buttonView;
              l3.set({ label: n3("Highlight"), tooltip: true, lastExecuted: o3.model, commandValue: o3.model, isToggleable: true }), l3.bind("icon").to(a3, "value", (t5) => KA(d3(t5, "type"))), l3.bind("color").to(a3, "value", (t5) => d3(t5, "color")), l3.bind("commandValue").to(a3, "value", (t5) => d3(t5, "model")), l3.bind("isOn").to(a3, "value", (t5) => !!t5), l3.delegate("execute").to(c3);
              function d3(t5, e5) {
                const n4 = t5 && t5 !== l3.lastExecuted ? t5 : l3.lastExecuted;
                return r3[n4][e5];
              }
              return c3.bind("isEnabled").to(a3, "isEnabled"), rm(c3, () => {
                const e5 = t4.map((t5) => {
                  const e6 = i3.create("highlight:" + t5.model);
                  return this.listenTo(e6, "execute", () => {
                    c3.buttonView.set({ lastExecuted: t5.model });
                  }), e6;
                });
                return e5.push(new ps()), e5.push(i3.create("removeHighlight")), e5;
              }, { enableActiveItemFocusOnDropdownOpen: true, ariaLabel: n3("Text highlight toolbar") }), function(t5) {
                const e5 = t5.buttonView.actionView;
                e5.iconView.bind("fillColor").to(t5.buttonView, "color");
              }(c3), l3.on("execute", () => {
                e4.execute("highlight", { value: l3.commandValue });
              }), this.listenTo(c3, "execute", () => {
                e4.editing.view.focus();
              }), c3;
            });
          }
        }
        function KA(t4) {
          return "marker" === t4 ? '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.798 1.59 3.002 12.875l1.895 1.852 2.521 1.402 6.997-12.194z"/><path d="m2.556 16.727.234-.348c-.297-.151-.462-.293-.498-.426-.036-.137.002-.416.115-.837.094-.25.15-.449.169-.595a4.495 4.495 0 0 0 0-.725c-.209-.621-.303-1.041-.284-1.26.02-.218.178-.506.475-.862l6.77-9.414c.539-.91 1.605-.85 3.199.18 1.594 1.032 2.188 1.928 1.784 2.686l-5.877 10.36c-.158.412-.333.673-.526.782-.193.108-.604.179-1.232.21-.362.131-.608.237-.738.318-.13.081-.305.238-.526.47-.293.265-.504.397-.632.397-.096 0-.27-.075-.524-.226l-.31.41-1.6-1.12zm-.279.415 1.575 1.103-.392.515H1.19l1.087-1.618zm8.1-13.656-4.953 6.9L8.75 12.57l4.247-7.574c.175-.25-.188-.647-1.092-1.192-.903-.546-1.412-.652-1.528-.32zM8.244 18.5 9.59 17h9.406v1.5H8.245z"/></svg>' : '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path class="ck-icon__fill" d="M10.126 2.268 2.002 13.874l1.895 1.852 2.521 1.402L14.47 5.481l-1.543-2.568-2.801-.645z"/><path d="m4.5 18.088-2.645-1.852-.04-2.95-.006-.005.006-.008v-.025l.011.008L8.73 2.97c.165-.233.356-.417.567-.557l-1.212.308L4.604 7.9l-.83-.558 3.694-5.495 2.708-.69 1.65 1.145.046.018.85-1.216 2.16 1.512-.856 1.222c.828.967 1.144 2.141.432 3.158L7.55 17.286l.006.005-3.055.797H4.5zm-.634.166-1.976.516-.026-1.918 2.002 1.402zM9.968 3.817l-.006-.004-6.123 9.184 3.277 2.294 6.108-9.162.005.003c.317-.452-.16-1.332-1.064-1.966-.891-.624-1.865-.776-2.197-.349zM8.245 18.5 9.59 17h9.406v1.5H8.245z"/></svg>';
        }
        class ZA extends As {
          refresh() {
            const t4 = this.editor.model, e4 = t4.schema, n3 = t4.document.selection;
            this.isEnabled = function(t5, e5, n4) {
              const i3 = function(t6, e6) {
                const n5 = $b2(t6, e6), i4 = n5.start.parent;
                if (i4.isEmpty && !i4.is("element", "$root"))
                  return i4.parent;
                return i4;
              }(t5, n4);
              return e5.checkChild(i3, "horizontalLine");
            }(n3, e4, t4);
          }
          execute() {
            const t4 = this.editor.model;
            t4.change((e4) => {
              const n3 = e4.createElement("horizontalLine");
              t4.insertObject(n3, null, null, { setSelection: "after" });
            });
          }
        }
        var YA = n2(9893), QA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(YA.Z, QA);
        YA.Z.locals;
        class JA extends bs {
          static get pluginName() {
            return "HorizontalLineEditing";
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.t, i3 = t4.conversion;
            e4.register("horizontalLine", { inheritAllFrom: "$blockObject" }), i3.for("dataDowncast").elementToElement({ model: "horizontalLine", view: (t5, { writer: e5 }) => e5.createEmptyElement("hr") }), i3.for("editingDowncast").elementToStructure({ model: "horizontalLine", view: (t5, { writer: e5 }) => {
              const i4 = n3("Horizontal line"), o3 = e5.createContainerElement("div", null, e5.createEmptyElement("hr"));
              return e5.addClass("ck-horizontal-line", o3), e5.setCustomProperty("hr", true, o3), function(t6, e6, n4) {
                return e6.setCustomProperty("horizontalLine", true, t6), Hb2(t6, e6, { label: n4 });
              }(o3, e5, i4);
            } }), i3.for("upcast").elementToElement({ view: "hr", model: "horizontalLine" }), t4.commands.add("horizontalLine", new ZA(t4));
          }
        }
        class XA extends bs {
          static get pluginName() {
            return "HorizontalLineUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add("horizontalLine", (n3) => {
              const i3 = t4.commands.get("horizontalLine"), o3 = new kr(n3);
              return o3.set({ label: e4("Horizontal line"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 9h16v2H2z"/></svg>', tooltip: true }), o3.bind("isEnabled").to(i3, "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute("horizontalLine"), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        class tC extends As {
          refresh() {
            const t4 = this.editor.model, e4 = t4.schema, n3 = t4.document.selection, i3 = eC(n3);
            this.isEnabled = function(t5, e5, n4) {
              const i4 = function(t6, e6) {
                const n5 = $b2(t6, e6), i5 = n5.start.parent;
                if (i5.isEmpty && !i5.is("rootElement"))
                  return i5.parent;
                return i5;
              }(t5, n4);
              return e5.checkChild(i4, "rawHtml");
            }(n3, e4, t4), this.value = i3 ? i3.getAttribute("value") || "" : null;
          }
          execute(t4) {
            const e4 = this.editor.model, n3 = e4.document.selection;
            e4.change((i3) => {
              let o3;
              null !== this.value ? o3 = eC(n3) : (o3 = i3.createElement("rawHtml"), e4.insertObject(o3, null, null, { setSelection: "on" })), i3.setAttribute("value", t4, o3);
            });
          }
        }
        function eC(t4) {
          const e4 = t4.getSelectedElement();
          return e4 && e4.is("element", "rawHtml") ? e4 : null;
        }
        var nC = n2(7319), iC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(nC.Z, iC);
        nC.Z.locals;
        class oC extends bs {
          static get pluginName() {
            return "HtmlEmbedEditing";
          }
          constructor(t4) {
            super(t4), this._widgetButtonViewReferences = /* @__PURE__ */ new Set(), t4.config.define("htmlEmbed", { showPreviews: false, sanitizeHtml: (t5) => (_2("html-embed-provide-sanitize-function"), { html: t5, hasChanged: false }) });
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.register("rawHtml", { inheritAllFrom: "$blockObject", allowAttributes: ["value"] }), t4.commands.add("htmlEmbed", new tC(t4)), this._setupConversion();
          }
          _setupConversion() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.editing.view, i3 = this._widgetButtonViewReferences, o3 = t4.config.get("htmlEmbed");
            function r3({ editor: t5, domElement: n4, state: o4, props: r4 }) {
              n4.textContent = "";
              const a3 = n4.ownerDocument;
              let c3;
              if (o4.isEditable) {
                const t6 = { isDisabled: false, placeholder: r4.textareaPlaceholder };
                c3 = s3({ domDocument: a3, state: o4, props: t6 }), n4.append(c3);
              } else if (o4.showPreviews) {
                const i4 = { sanitizeHtml: r4.sanitizeHtml };
                n4.append(function({ editor: t6, domDocument: n5, state: i5, props: o5 }) {
                  const r5 = o5.sanitizeHtml(i5.getRawHtmlValue()), s4 = i5.getRawHtmlValue().length > 0 ? e4("No preview available") : e4("Empty snippet content"), a4 = bt2(n5, "div", { class: "ck ck-reset_all raw-html-embed__preview-placeholder" }, s4), c4 = bt2(n5, "div", { class: "raw-html-embed__preview-content", dir: t6.locale.contentLanguageDirection }), l4 = n5.createRange(), d3 = l4.createContextualFragment(r5.html);
                  c4.appendChild(d3);
                  const h3 = bt2(n5, "div", { class: "raw-html-embed__preview" }, [a4, c4]);
                  return h3;
                }({ domDocument: a3, state: o4, props: i4, editor: t5 }));
              } else {
                const t6 = { isDisabled: true, placeholder: r4.textareaPlaceholder };
                n4.append(s3({ domDocument: a3, state: o4, props: t6 }));
              }
              const l3 = { onEditClick: r4.onEditClick, onSaveClick: () => {
                r4.onSaveClick(c3.value);
              }, onCancelClick: r4.onCancelClick };
              n4.prepend(function({ editor: t6, domDocument: e5, state: n5, props: o5 }) {
                const r5 = bt2(e5, "div", { class: "raw-html-embed__buttons-wrapper" });
                if (n5.isEditable) {
                  const e6 = rC(t6, "save", o5.onSaveClick), n6 = rC(t6, "cancel", o5.onCancelClick);
                  r5.append(e6.element, n6.element), i3.add(e6).add(n6);
                } else {
                  const e6 = rC(t6, "edit", o5.onEditClick);
                  r5.append(e6.element), i3.add(e6);
                }
                return r5;
              }({ editor: t5, domDocument: a3, state: o4, props: l3 }));
            }
            function s3({ domDocument: t5, state: e5, props: n4 }) {
              const i4 = bt2(t5, "textarea", { placeholder: n4.placeholder, class: "ck ck-reset ck-input ck-input-text raw-html-embed__source" });
              return i4.disabled = n4.isDisabled, i4.value = e5.getRawHtmlValue(), i4;
            }
            this.editor.editing.view.on("render", () => {
              for (const t5 of i3) {
                if (t5.element && t5.element.isConnected)
                  return;
                t5.destroy(), i3.delete(t5);
              }
            }, { priority: "lowest" }), t4.data.registerRawContentMatcher({ name: "div", classes: "raw-html-embed" }), t4.conversion.for("upcast").elementToElement({ view: { name: "div", classes: "raw-html-embed" }, model: (t5, { writer: e5 }) => e5.createElement("rawHtml", { value: t5.getCustomProperty("$rawContent") }) }), t4.conversion.for("dataDowncast").elementToElement({ model: "rawHtml", view: (t5, { writer: e5 }) => e5.createRawElement("div", { class: "raw-html-embed" }, function(e6) {
              e6.innerHTML = t5.getAttribute("value") || "";
            }) }), t4.conversion.for("editingDowncast").elementToStructure({ model: { name: "rawHtml", attributes: ["value"] }, view: (i4, { writer: s4 }) => {
              let a3, c3, l3;
              const d3 = s4.createRawElement("div", { class: "raw-html-embed__content-wrapper" }, function(e5) {
                a3 = e5, r3({ editor: t4, domElement: e5, state: c3, props: l3 }), a3.addEventListener("mousedown", () => {
                  if (c3.isEditable) {
                    const e6 = t4.model;
                    e6.document.selection.getSelectedElement() !== i4 && e6.change((t5) => t5.setSelection(i4, "on"));
                  }
                }, true);
              }), h3 = { makeEditable() {
                c3 = Object.assign({}, c3, { isEditable: true }), r3({ domElement: a3, editor: t4, state: c3, props: l3 }), n3.change((t5) => {
                  t5.setAttribute("data-cke-ignore-events", "true", d3);
                }), a3.querySelector("textarea").focus();
              }, save(e5) {
                e5 !== c3.getRawHtmlValue() ? (t4.execute("htmlEmbed", e5), t4.editing.view.focus()) : this.cancel();
              }, cancel() {
                c3 = Object.assign({}, c3, { isEditable: false }), r3({ domElement: a3, editor: t4, state: c3, props: l3 }), t4.editing.view.focus(), n3.change((t5) => {
                  t5.removeAttribute("data-cke-ignore-events", d3);
                });
              } };
              c3 = { showPreviews: o3.showPreviews, isEditable: false, getRawHtmlValue: () => i4.getAttribute("value") || "" }, l3 = { sanitizeHtml: o3.sanitizeHtml, textareaPlaceholder: e4("Paste raw HTML here..."), onEditClick() {
                h3.makeEditable();
              }, onSaveClick(t5) {
                h3.save(t5);
              }, onCancelClick() {
                h3.cancel();
              } };
              const u3 = s4.createContainerElement("div", { class: "raw-html-embed", "data-html-embed-label": e4("HTML snippet"), dir: t4.locale.uiLanguageDirection }, d3);
              return s4.setCustomProperty("rawHtmlApi", h3, u3), s4.setCustomProperty("rawHtml", true, u3), Hb2(u3, s4, { label: e4("HTML snippet"), hasSelectionHandle: true });
            } });
          }
        }
        function rC(t4, e4, n3) {
          const { t: i3 } = t4.locale, o3 = new kr(t4.locale), r3 = t4.commands.get("htmlEmbed");
          return o3.set({ class: `raw-html-embed__${e4}-button`, icon: Pg2.pencil, tooltip: true, tooltipPosition: "rtl" === t4.locale.uiLanguageDirection ? "e" : "w" }), o3.render(), "edit" === e4 ? (o3.set({ icon: Pg2.pencil, label: i3("Edit source") }), o3.bind("isEnabled").to(r3)) : "save" === e4 ? (o3.set({ icon: Pg2.check, label: i3("Save changes") }), o3.bind("isEnabled").to(r3)) : o3.set({ icon: Pg2.cancel, label: i3("Cancel") }), o3.on("execute", n3), o3;
        }
        class sC extends bs {
          static get pluginName() {
            return "HtmlEmbedUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add("htmlEmbed", (n3) => {
              const i3 = t4.commands.get("htmlEmbed"), o3 = new kr(n3);
              return o3.set({ label: e4("Insert HTML"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M17 0a2 2 0 0 1 2 2v7a1 1 0 0 1 1 1v5a1 1 0 0 1-.883.993l-.118.006L19 17a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2l-.001-1.001-.116-.006A1 1 0 0 1 0 15v-5a1 1 0 0 1 .999-1L1 2a2 2 0 0 1 2-2h14zm.499 15.999h-15L2.5 17a.5.5 0 0 0 .5.5h14a.5.5 0 0 0 .5-.5l-.001-1.001zm-3.478-6.013-.014.014H14v.007l-1.525 1.525-1.46-1.46-.015.013V10h-1v5h1v-3.53l1.428 1.43.048.043.131-.129L14 11.421V15h1v-5h-.965l-.014-.014zM2 10H1v5h1v-2h2v2h1v-5H4v2H2v-2zm7 0H6v1h1v4h1v-4h1v-1zm8 0h-1v5h3v-1h-2v-4zm0-8.5H3a.5.5 0 0 0-.5.5l-.001 6.999h15L17.5 2a.5.5 0 0 0-.5-.5zM10 7v1H4V7h6zm3-2v1H4V5h9zm-3-2v1H4V3h6z"/></svg>', tooltip: true }), o3.bind("isEnabled").to(i3, "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute("htmlEmbed"), t4.editing.view.focus();
                t4.editing.view.document.selection.getSelectedElement().getCustomProperty("rawHtmlApi").makeEditable();
              }), o3;
            });
          }
        }
        const aC = function(t4, e4, n3, i3) {
          var o3 = -1, r3 = null == t4 ? 0 : t4.length;
          for (i3 && r3 && (n3 = t4[++o3]); ++o3 < r3; )
            n3 = e4(n3, t4[o3], o3, t4);
          return n3;
        };
        const cC = function(t4) {
          return function(e4) {
            return null == t4 ? void 0 : t4[e4];
          };
        }({ : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "Ae", : "ae", : "Th", : "th", : "ss", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "IJ", : "ij", : "Oe", : "oe", : "'n", : "s" });
        var lC = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, dC = RegExp("[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", "g");
        const hC = function(t4) {
          return (t4 = ia2(t4)) && t4.replace(lC, cC).replace(dC, "");
        };
        var uC = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        const gC = function(t4) {
          return t4.match(uC) || [];
        };
        var mC = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        const pC = function(t4) {
          return mC.test(t4);
        };
        var fC = "\\ud800-\\udfff", kC = "\\u2700-\\u27bf", bC = "a-z\\xdf-\\xf6\\xf8-\\xff", wC = "A-Z\\xc0-\\xd6\\xd8-\\xde", AC = "\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", CC = "[" + AC + "]", _C = "\\d+", vC = "[" + kC + "]", yC = "[" + bC + "]", xC = "[^" + fC + AC + _C + kC + bC + wC + "]", EC = "(?:\\ud83c[\\udde6-\\uddff]){2}", DC = "[\\ud800-\\udbff][\\udc00-\\udfff]", SC = "[" + wC + "]", TC = "(?:" + yC + "|" + xC + ")", IC = "(?:" + SC + "|" + xC + ")", BC = "(?:['](?:d|ll|m|re|s|t|ve))?", MC = "(?:['](?:D|LL|M|RE|S|T|VE))?", NC = "(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?", LC = "[\\ufe0e\\ufe0f]?", zC = LC + NC + ("(?:\\u200d(?:" + ["[^" + fC + "]", EC, DC].join("|") + ")" + LC + NC + ")*"), PC = "(?:" + [vC, EC, DC].join("|") + ")" + zC, RC = RegExp([SC + "?" + yC + "+" + BC + "(?=" + [CC, SC, "$"].join("|") + ")", IC + "+" + MC + "(?=" + [CC, SC + TC, "$"].join("|") + ")", SC + "?" + TC + "+" + BC, SC + "+" + MC, "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", _C, PC].join("|"), "g");
        const OC = function(t4) {
          return t4.match(RC) || [];
        };
        const FC = function(t4, e4, n3) {
          return t4 = ia2(t4), void 0 === (e4 = n3 ? void 0 : e4) ? pC(t4) ? OC(t4) : gC(t4) : t4.match(e4) || [];
        };
        var VC = RegExp("[']", "g");
        const jC = function(t4) {
          return function(e4) {
            return aC(FC(hC(e4).replace(VC, "")), t4, "");
          };
        };
        const HC = function(t4, e4, n3) {
          var i3 = t4.length;
          return n3 = void 0 === n3 ? i3 : n3, !e4 && n3 >= i3 ? t4 : ca2(t4, e4, n3);
        };
        var UC = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
        const GC = function(t4) {
          return UC.test(t4);
        };
        const WC = function(t4) {
          return t4.split("");
        };
        var qC = "\\ud800-\\udfff", $C = "[" + qC + "]", KC = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", ZC = "\\ud83c[\\udffb-\\udfff]", YC = "[^" + qC + "]", QC = "(?:\\ud83c[\\udde6-\\uddff]){2}", JC = "[\\ud800-\\udbff][\\udc00-\\udfff]", XC = "(?:" + KC + "|" + ZC + ")?", t_ = "[\\ufe0e\\ufe0f]?", e_ = t_ + XC + ("(?:\\u200d(?:" + [YC, QC, JC].join("|") + ")" + t_ + XC + ")*"), n_ = "(?:" + [YC + KC + "?", KC, QC, JC, $C].join("|") + ")", i_ = RegExp(ZC + "(?=" + ZC + ")|" + n_ + e_, "g");
        const o_ = function(t4) {
          return t4.match(i_) || [];
        };
        const r_ = function(t4) {
          return GC(t4) ? o_(t4) : WC(t4);
        };
        const s_ = function(t4) {
          return function(e4) {
            e4 = ia2(e4);
            var n3 = GC(e4) ? r_(e4) : void 0, i3 = n3 ? n3[0] : e4.charAt(0), o3 = n3 ? HC(n3, 1).join("") : e4.slice(1);
            return i3[t4]() + o3;
          };
        }("toUpperCase");
        const a_ = jC(function(t4, e4, n3) {
          return t4 + (n3 ? " " : "") + s_(e4);
        });
        function c_(t4, e4, n3, i3) {
          e4 && function(t5, e5, n4) {
            if (e5.attributes)
              for (const [i4] of Object.entries(e5.attributes))
                t5.removeAttribute(i4, n4);
            if (e5.styles)
              for (const i4 of Object.keys(e5.styles))
                t5.removeStyle(i4, n4);
            e5.classes && t5.removeClass(e5.classes, n4);
          }(t4, e4, i3), n3 && l_(t4, n3, i3);
        }
        function l_(t4, e4, n3) {
          if (e4.attributes)
            for (const [i3, o3] of Object.entries(e4.attributes))
              t4.setAttribute(i3, o3, n3);
          e4.styles && t4.setStyle(e4.styles, n3), e4.classes && t4.addClass(e4.classes, n3);
        }
        function d_(t4, e4, n3, i3, o3) {
          const r3 = e4.getAttribute(n3), s3 = {};
          for (const t5 of ["attributes", "styles", "classes"]) {
            if (t5 != i3) {
              r3 && r3[t5] && (s3[t5] = r3[t5]);
              continue;
            }
            if ("classes" == i3) {
              const e6 = new Set(r3 && r3.classes || []);
              o3(e6), e6.size && (s3[t5] = Array.from(e6));
              continue;
            }
            const e5 = new Map(Object.entries(r3 && r3[t5] || {}));
            o3(e5), e5.size && (s3[t5] = Object.fromEntries(e5));
          }
          Object.keys(s3).length ? e4.is("documentSelection") ? t4.setSelectionAttribute(n3, s3) : t4.setAttribute(n3, s3, e4) : r3 && (e4.is("documentSelection") ? t4.removeSelectionAttribute(n3) : t4.removeAttribute(n3, e4));
        }
        function h_(t4) {
          return `html${e4 = t4, a_(e4).replace(/ /g, "")}Attributes`;
          var e4;
        }
        function u_({ model: t4 }) {
          return (e4, n3) => n3.writer.createElement(t4, { htmlContent: e4.getCustomProperty("$rawContent") });
        }
        function g_(t4, { view: e4, isInline: n3 }) {
          const i3 = t4.t;
          return (t5, { writer: o3 }) => {
            const r3 = i3("HTML object"), s3 = m_(e4, t5, o3), a3 = t5.getAttribute(h_(e4));
            o3.addClass("html-object-embed__content", s3), a3 && l_(o3, a3, s3);
            return Hb2(o3.createContainerElement(n3 ? "span" : "div", { class: "html-object-embed", "data-html-object-embed-label": r3 }, s3), o3, { label: r3 });
          };
        }
        function m_(t4, e4, n3) {
          return n3.createRawElement(t4, null, (t5, n4) => {
            n4.setContentOf(t5, e4.getAttribute("htmlContent"));
          });
        }
        function p_({ view: t4, model: e4, allowEmpty: n3 }, i3) {
          return (e5) => {
            e5.on(`element:${t4}`, (t5, e6, r3) => {
              let s3 = i3.processViewAttributes(e6.viewItem, r3);
              if (s3 || r3.consumable.test(e6.viewItem, { name: true })) {
                if (s3 = s3 || {}, r3.consumable.consume(e6.viewItem, { name: true }), e6.modelRange || (e6 = Object.assign(e6, r3.convertChildren(e6.viewItem, e6.modelCursor))), n3 && e6.modelRange.isCollapsed && Object.keys(s3).length) {
                  const t6 = r3.writer.createElement("htmlEmptyElement");
                  if (!r3.safeInsert(t6, e6.modelCursor))
                    return;
                  const n4 = r3.getSplitParts(t6);
                  return e6.modelRange = r3.writer.createRange(e6.modelRange.start, r3.writer.createPositionAfter(n4[n4.length - 1])), r3.updateConversionResult(t6, e6), void o3(t6, s3, r3);
                }
                for (const t6 of e6.modelRange.getItems())
                  o3(t6, s3, r3);
              }
            }, { priority: "low" });
          };
          function o3(t5, n4, i4) {
            if (i4.schema.checkAttribute(t5, e4)) {
              const o4 = function(t6, e5) {
                const n5 = Ol(t6);
                let i5 = "attributes";
                for (i5 in e5)
                  n5[i5] = "classes" == i5 ? Array.from(/* @__PURE__ */ new Set([...t6[i5] || [], ...e5[i5]])) : { ...t6[i5], ...e5[i5] };
                return n5;
              }(n4, t5.getAttribute(e4) || {});
              i4.writer.setAttribute(e4, o4, t5);
            }
          }
        }
        function f_({ model: t4, view: e4 }, n3) {
          return (i3, { writer: o3, consumable: r3 }) => {
            if (!i3.hasAttribute(t4))
              return null;
            const s3 = o3.createContainerElement(e4), a3 = i3.getAttribute(t4);
            return r3.consume(i3, `attribute:${t4}`), l_(o3, a3, s3), s3.getFillerOffset = () => null, n3 ? Hb2(s3, o3) : s3;
          };
        }
        function k_({ priority: t4, view: e4 }) {
          return (n3, i3) => {
            if (!n3)
              return;
            const { writer: o3 } = i3, r3 = o3.createAttributeElement(e4, null, { priority: t4 });
            return l_(o3, n3, r3), r3;
          };
        }
        function b_({ view: t4 }, e4) {
          return (n3) => {
            n3.on(`element:${t4}`, (t5, n4, i3) => {
              if (!n4.modelRange || n4.modelRange.isCollapsed)
                return;
              const o3 = e4.processViewAttributes(n4.viewItem, i3);
              o3 && i3.writer.setAttribute(h_(n4.viewItem.name), o3, n4.modelRange);
            }, { priority: "low" });
          };
        }
        function w_({ view: t4, model: e4 }) {
          return (n3) => {
            n3.on(`attribute:${h_(t4)}:${e4}`, (t5, e5, n4) => {
              if (!n4.consumable.consume(e5.item, t5.name))
                return;
              const { attributeOldValue: i3, attributeNewValue: o3 } = e5;
              c_(n4.writer, i3, o3, n4.mapper.toViewElement(e5.item));
            });
          };
        }
        const A_ = [{ model: "codeBlock", view: "pre" }, { model: "paragraph", view: "p" }, { model: "blockQuote", view: "blockquote" }, { model: "listItem", view: "li" }, { model: "pageBreak", view: "div" }, { model: "rawHtml", view: "div" }, { model: "table", view: "table" }, { model: "tableRow", view: "tr" }, { model: "tableCell", view: "td" }, { model: "tableCell", view: "th" }, { model: "tableColumnGroup", view: "colgroup" }, { model: "tableColumn", view: "col" }, { model: "caption", view: "caption" }, { model: "caption", view: "figcaption" }, { model: "imageBlock", view: "img" }, { model: "imageInline", view: "img" }, { model: "htmlP", view: "p", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlBlockquote", view: "blockquote", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlTable", view: "table", modelSchema: { allowWhere: "$block", isBlock: true } }, { model: "htmlTbody", view: "tbody", modelSchema: { allowIn: "htmlTable", isBlock: false } }, { model: "htmlThead", view: "thead", modelSchema: { allowIn: "htmlTable", isBlock: false } }, { model: "htmlTfoot", view: "tfoot", modelSchema: { allowIn: "htmlTable", isBlock: false } }, { model: "htmlCaption", view: "caption", modelSchema: { allowIn: "htmlTable", allowChildren: "$text", isBlock: false } }, { model: "htmlColgroup", view: "colgroup", modelSchema: { allowIn: "htmlTable", allowChildren: "col", isBlock: false } }, { model: "htmlCol", view: "col", modelSchema: { allowIn: "htmlColgroup", isBlock: false } }, { model: "htmlTr", view: "tr", modelSchema: { allowIn: ["htmlTable", "htmlThead", "htmlTbody"], isLimit: true } }, { model: "htmlTd", view: "td", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: true, isBlock: false } }, { model: "htmlTh", view: "th", modelSchema: { allowIn: "htmlTr", allowContentOf: "$container", isLimit: true, isBlock: false } }, { model: "htmlFigure", view: "figure", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlFigcaption", view: "figcaption", modelSchema: { allowIn: "htmlFigure", allowChildren: "$text", isBlock: false } }, { model: "htmlAddress", view: "address", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlAside", view: "aside", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlMain", view: "main", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlDetails", view: "details", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlSummary", view: "summary", modelSchema: { allowChildren: "$text", allowIn: "htmlDetails", isBlock: false } }, { model: "htmlDiv", view: "div", paragraphLikeModel: "htmlDivParagraph", modelSchema: { inheritAllFrom: "$container" } }, { model: "htmlFieldset", view: "fieldset", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlLegend", view: "legend", modelSchema: { allowIn: "htmlFieldset", allowChildren: "$text" } }, { model: "htmlHeader", view: "header", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlFooter", view: "footer", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlForm", view: "form", modelSchema: { inheritAllFrom: "$container", isBlock: true } }, { model: "htmlHgroup", view: "hgroup", modelSchema: { allowChildren: ["htmlH1", "htmlH2", "htmlH3", "htmlH4", "htmlH5", "htmlH6"], isBlock: false } }, { model: "htmlH1", view: "h1", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH2", view: "h2", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH3", view: "h3", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH4", view: "h4", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH5", view: "h5", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlH6", view: "h6", modelSchema: { inheritAllFrom: "$block" } }, { model: "$htmlList", modelSchema: { allowWhere: "$container", allowChildren: ["$htmlList", "htmlLi"], isBlock: false } }, { model: "htmlDir", view: "dir", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlMenu", view: "menu", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlUl", view: "ul", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlOl", view: "ol", modelSchema: { inheritAllFrom: "$htmlList" } }, { model: "htmlLi", view: "li", modelSchema: { allowIn: "$htmlList", allowChildren: "$text", isBlock: false } }, { model: "htmlPre", view: "pre", modelSchema: { inheritAllFrom: "$block" } }, { model: "htmlArticle", view: "article", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlSection", view: "section", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlNav", view: "nav", modelSchema: { inheritAllFrom: "$container", isBlock: false } }, { model: "htmlDivDl", view: "div", modelSchema: { allowChildren: ["htmlDt", "htmlDd"], allowIn: "htmlDl" } }, { model: "htmlDl", view: "dl", modelSchema: { allowWhere: "$container", allowChildren: ["htmlDt", "htmlDd", "htmlDivDl"], isBlock: false } }, { model: "htmlDt", view: "dt", modelSchema: { allowChildren: "$block", isBlock: false } }, { model: "htmlDd", view: "dd", modelSchema: { allowChildren: "$block", isBlock: false } }, { model: "htmlCenter", view: "center", modelSchema: { inheritAllFrom: "$container", isBlock: false } }], C_ = [{ model: "htmlLiAttributes", view: "li", appliesToBlock: true, coupledAttribute: "listItemId" }, { model: "htmlOlAttributes", view: "ol", appliesToBlock: true, coupledAttribute: "listItemId" }, { model: "htmlUlAttributes", view: "ul", appliesToBlock: true, coupledAttribute: "listItemId" }, { model: "htmlFigureAttributes", view: "figure", appliesToBlock: "table" }, { model: "htmlTheadAttributes", view: "thead", appliesToBlock: "table" }, { model: "htmlTbodyAttributes", view: "tbody", appliesToBlock: "table" }, { model: "htmlFigureAttributes", view: "figure", appliesToBlock: "imageBlock" }, { model: "htmlAcronym", view: "acronym", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlTt", view: "tt", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlFont", view: "font", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlTime", view: "time", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlVar", view: "var", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlBig", view: "big", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlSmall", view: "small", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlSamp", view: "samp", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlQ", view: "q", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlOutput", view: "output", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlKbd", view: "kbd", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlBdi", view: "bdi", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlBdo", view: "bdo", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlAbbr", view: "abbr", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlA", view: "a", priority: 5, coupledAttribute: "linkHref" }, { model: "htmlStrong", view: "strong", coupledAttribute: "bold", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlB", view: "b", coupledAttribute: "bold", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlI", view: "i", coupledAttribute: "italic", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlEm", view: "em", coupledAttribute: "italic", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlS", view: "s", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlDel", view: "del", coupledAttribute: "strikethrough", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlIns", view: "ins", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlU", view: "u", coupledAttribute: "underline", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlSub", view: "sub", coupledAttribute: "subscript", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlSup", view: "sup", coupledAttribute: "superscript", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlCode", view: "code", coupledAttribute: "code", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlMark", view: "mark", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlSpan", view: "span", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlCite", view: "cite", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlLabel", view: "label", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlDfn", view: "dfn", attributeProperties: { copyOnEnter: true, isFormatting: true } }, { model: "htmlObject", view: "object", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlIframe", view: "iframe", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlInput", view: "input", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlButton", view: "button", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlTextarea", view: "textarea", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlSelect", view: "select", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlVideo", view: "video", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlEmbed", view: "embed", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlOembed", view: "oembed", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlAudio", view: "audio", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlImg", view: "img", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlCanvas", view: "canvas", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlMeter", view: "meter", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlProgress", view: "progress", isObject: true, modelSchema: { inheritAllFrom: "$inlineObject" } }, { model: "htmlScript", view: "script", modelSchema: { allowWhere: ["$text", "$block"], isInline: true } }, { model: "htmlStyle", view: "style", modelSchema: { allowWhere: ["$text", "$block"], isInline: true } }, { model: "htmlCustomElement", view: "$customElement", modelSchema: { allowWhere: ["$text", "$block"], allowAttributesOf: "$inlineObject", isInline: true } }];
        const __ = Ba2(function(t4, e4, n3, i3) {
          wa2(t4, e4, n3, i3);
        });
        class v_ extends bs {
          constructor() {
            super(...arguments), this._definitions = [];
          }
          static get pluginName() {
            return "DataSchema";
          }
          init() {
            for (const t4 of A_)
              this.registerBlockElement(t4);
            for (const t4 of C_)
              this.registerInlineElement(t4);
          }
          registerBlockElement(t4) {
            this._definitions.push({ ...t4, isBlock: true });
          }
          registerInlineElement(t4) {
            this._definitions.push({ ...t4, isInline: true });
          }
          extendBlockElement(t4) {
            this._extendDefinition({ ...t4, isBlock: true });
          }
          extendInlineElement(t4) {
            this._extendDefinition({ ...t4, isInline: true });
          }
          getDefinitionsForView(t4, e4 = false) {
            const n3 = /* @__PURE__ */ new Set();
            for (const i3 of this._getMatchingViewDefinitions(t4)) {
              if (e4)
                for (const t5 of this._getReferences(i3.model))
                  n3.add(t5);
              n3.add(i3);
            }
            return n3;
          }
          getDefinitionsForModel(t4) {
            return this._definitions.filter((e4) => e4.model == t4);
          }
          _getMatchingViewDefinitions(t4) {
            return this._definitions.filter((e4) => e4.view && function(t5, e5) {
              if ("string" == typeof t5)
                return t5 === e5;
              if (t5 instanceof RegExp)
                return t5.test(e5);
              return false;
            }(t4, e4.view));
          }
          *_getReferences(t4) {
            const e4 = ["inheritAllFrom", "inheritTypesFrom", "allowWhere", "allowContentOf", "allowAttributesOf"], n3 = this._definitions.filter((e5) => e5.model == t4);
            for (const { modelSchema: i3 } of n3)
              if (i3)
                for (const n4 of e4)
                  for (const e5 of yo2(i3[n4] || [])) {
                    const n5 = this._definitions.filter((t5) => t5.model == e5);
                    for (const i4 of n5)
                      e5 !== t4 && (yield* this._getReferences(i4.model), yield i4);
                  }
          }
          _extendDefinition(t4) {
            const e4 = Array.from(this._definitions.entries()).filter(([, e5]) => e5.model == t4.model);
            if (0 != e4.length)
              for (const [n3, i3] of e4)
                this._definitions[n3] = __({}, i3, t4, (t5, e5) => Array.isArray(t5) ? t5.concat(e5) : void 0);
            else
              this._definitions.push(t4);
          }
        }
        const y_ = function(t4, e4, n3, i3) {
          for (var o3 = t4.length, r3 = n3 + (i3 ? 1 : -1); i3 ? r3-- : ++r3 < o3; )
            if (e4(t4[r3], r3, t4))
              return r3;
          return -1;
        };
        const x_ = function(t4) {
          return t4 != t4;
        };
        const E_ = function(t4, e4, n3) {
          for (var i3 = n3 - 1, o3 = t4.length; ++i3 < o3; )
            if (t4[i3] === e4)
              return i3;
          return -1;
        };
        const D_ = function(t4, e4, n3) {
          return e4 == e4 ? E_(t4, e4, n3) : y_(t4, x_, n3);
        };
        const S_ = function(t4, e4, n3, i3) {
          for (var o3 = n3 - 1, r3 = t4.length; ++o3 < r3; )
            if (i3(t4[o3], e4))
              return o3;
          return -1;
        };
        var T_ = Array.prototype.splice;
        const I_ = function(t4, e4, n3, i3) {
          var o3 = i3 ? S_ : D_, r3 = -1, s3 = e4.length, a3 = t4;
          for (t4 === e4 && (e4 = Cn(e4)), n3 && (a3 = Xs(t4, $e2(n3))); ++r3 < s3; )
            for (var c3 = 0, l3 = e4[r3], d3 = n3 ? n3(l3) : l3; (c3 = o3(a3, d3, c3, i3)) > -1; )
              a3 !== t4 && T_.call(a3, c3, 1), T_.call(t4, c3, 1);
          return t4;
        };
        const B_ = Ta2(function(t4, e4) {
          return t4 && t4.length && e4 && e4.length ? I_(t4, e4) : t4;
        });
        var M_ = n2(1710), N_ = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(M_.Z, N_);
        M_.Z.locals;
        class L_ extends bs {
          constructor(t4) {
            super(t4), this._dataSchema = t4.plugins.get("DataSchema"), this._allowedAttributes = new Vs(), this._disallowedAttributes = new Vs(), this._allowedElements = /* @__PURE__ */ new Set(), this._disallowedElements = /* @__PURE__ */ new Set(), this._dataInitialized = false, this._coupledAttributes = null, this._registerElementsAfterInit(), this._registerElementHandlers(), this._registerCoupledAttributesPostFixer(), this._registerAssociatedHtmlAttributesPostFixer();
          }
          static get pluginName() {
            return "DataFilter";
          }
          static get requires() {
            return [v_, lw];
          }
          loadAllowedConfig(t4) {
            for (const e4 of t4) {
              const t5 = e4.name || /[\s\S]+/, n3 = F_(e4);
              this.allowElement(t5), n3.forEach((t6) => this.allowAttributes(t6));
            }
          }
          loadDisallowedConfig(t4) {
            for (const e4 of t4) {
              const t5 = e4.name || /[\s\S]+/, n3 = F_(e4);
              0 == n3.length ? this.disallowElement(t5) : n3.forEach((t6) => this.disallowAttributes(t6));
            }
          }
          loadAllowedEmptyElementsConfig(t4) {
            for (const e4 of t4)
              this.allowEmptyElement(e4);
          }
          allowElement(t4) {
            for (const e4 of this._dataSchema.getDefinitionsForView(t4, true))
              this._addAllowedElement(e4), this._coupledAttributes = null;
          }
          disallowElement(t4) {
            for (const e4 of this._dataSchema.getDefinitionsForView(t4, false))
              this._disallowedElements.add(e4.view);
          }
          allowEmptyElement(t4) {
            for (const e4 of this._dataSchema.getDefinitionsForView(t4, true))
              e4.isInline && this._dataSchema.extendInlineElement({ ...e4, allowEmpty: true });
          }
          allowAttributes(t4) {
            this._allowedAttributes.add(t4);
          }
          disallowAttributes(t4) {
            this._disallowedAttributes.add(t4);
          }
          processViewAttributes(t4, e4) {
            return z_(t4, e4, this._disallowedAttributes), z_(t4, e4, this._allowedAttributes);
          }
          _addAllowedElement(t4) {
            if (!this._allowedElements.has(t4)) {
              if (this._allowedElements.add(t4), "appliesToBlock" in t4 && "string" == typeof t4.appliesToBlock)
                for (const e4 of this._dataSchema.getDefinitionsForModel(t4.appliesToBlock))
                  e4.isBlock && this._addAllowedElement(e4);
              this._dataInitialized && this.editor.data.once("set", () => {
                this._fireRegisterEvent(t4);
              }, { priority: b2.highest + 1 });
            }
          }
          _registerElementsAfterInit() {
            this.editor.data.on("init", () => {
              this._dataInitialized = true;
              for (const t4 of this._allowedElements)
                this._fireRegisterEvent(t4);
            }, { priority: b2.highest + 1 });
          }
          _registerElementHandlers() {
            this.on("register", (t4, e4) => {
              const n3 = this.editor.model.schema;
              if (e4.isObject && !n3.isRegistered(e4.model))
                this._registerObjectElement(e4);
              else if (e4.isBlock)
                this._registerBlockElement(e4);
              else {
                if (!e4.isInline)
                  throw new C2("data-filter-invalid-definition", null, e4);
                this._registerInlineElement(e4);
              }
              t4.stop();
            }, { priority: "lowest" });
          }
          _registerCoupledAttributesPostFixer() {
            const t4 = this.editor.model;
            t4.document.registerPostFixer((e4) => {
              const n3 = t4.document.differ.getChanges();
              let i3 = false;
              const o3 = this._getCoupledAttributesMap();
              for (const t5 of n3) {
                if ("attribute" != t5.type || null !== t5.attributeNewValue)
                  continue;
                const n4 = o3.get(t5.attributeKey);
                if (n4)
                  for (const { item: o4 } of t5.range.getWalker({ shallow: true }))
                    for (const t6 of n4)
                      o4.hasAttribute(t6) && (e4.removeAttribute(t6, o4), i3 = true);
              }
              return i3;
            });
          }
          _registerAssociatedHtmlAttributesPostFixer() {
            const t4 = this.editor.model;
            t4.document.registerPostFixer((e4) => {
              const n3 = t4.document.differ.getChanges();
              let i3 = false;
              for (const o3 of n3)
                if ("insert" === o3.type && "$text" !== o3.name)
                  for (const n4 of o3.attributes.keys())
                    n4.startsWith("html") && n4.endsWith("Attributes") && (t4.schema.checkAttribute(o3.name, n4) || (e4.removeAttribute(n4, o3.position.nodeAfter), i3 = true));
              return i3;
            });
          }
          _getCoupledAttributesMap() {
            if (this._coupledAttributes)
              return this._coupledAttributes;
            this._coupledAttributes = /* @__PURE__ */ new Map();
            for (const t4 of this._allowedElements)
              if (t4.coupledAttribute && t4.model) {
                const e4 = this._coupledAttributes.get(t4.coupledAttribute);
                e4 ? e4.push(t4.model) : this._coupledAttributes.set(t4.coupledAttribute, [t4.model]);
              }
            return this._coupledAttributes;
          }
          _fireRegisterEvent(t4) {
            t4.view && this._disallowedElements.has(t4.view) || this.fire(t4.view ? `register:${t4.view}` : "register", t4);
          }
          _registerObjectElement(t4) {
            const e4 = this.editor, n3 = e4.model.schema, i3 = e4.conversion, { view: o3, model: r3 } = t4;
            n3.register(r3, t4.modelSchema), o3 && (n3.extend(t4.model, { allowAttributes: [h_(o3), "htmlContent"] }), e4.data.registerRawContentMatcher({ name: o3 }), i3.for("upcast").elementToElement({ view: o3, model: u_(t4), converterPriority: b2.low + 2 }), i3.for("upcast").add(b_(t4, this)), i3.for("editingDowncast").elementToStructure({ model: { name: r3, attributes: [h_(o3)] }, view: g_(e4, t4) }), i3.for("dataDowncast").elementToElement({ model: r3, view: (t5, { writer: e5 }) => m_(o3, t5, e5) }), i3.for("dataDowncast").add(w_(t4)));
          }
          _registerBlockElement(t4) {
            const e4 = this.editor, n3 = e4.model.schema, i3 = e4.conversion, { view: o3, model: r3 } = t4;
            if (!n3.isRegistered(t4.model)) {
              if (n3.register(t4.model, t4.modelSchema), !o3)
                return;
              i3.for("upcast").elementToElement({ model: r3, view: o3, converterPriority: b2.low + 2 }), i3.for("downcast").elementToElement({ model: r3, view: o3 });
            }
            o3 && (n3.extend(t4.model, { allowAttributes: h_(o3) }), i3.for("upcast").add(b_(t4, this)), i3.for("downcast").add(w_(t4)));
          }
          _registerInlineElement(t4) {
            const e4 = this.editor, n3 = e4.model.schema, i3 = e4.conversion, o3 = t4.model;
            t4.appliesToBlock || (n3.extend("$text", { allowAttributes: o3 }), t4.attributeProperties && n3.setAttributeProperties(o3, t4.attributeProperties), i3.for("upcast").add(p_(t4, this)), i3.for("downcast").attributeToElement({ model: o3, view: k_(t4) }), t4.allowEmpty && (n3.setAttributeProperties(o3, { copyFromObject: false }), n3.isRegistered("htmlEmptyElement") || n3.register("htmlEmptyElement", { inheritAllFrom: "$inlineObject" }), e4.data.htmlProcessor.domConverter.registerInlineObjectMatcher((e5) => e5.name == t4.view && e5.isEmpty && Array.from(e5.getAttributeKeys()).length ? { name: true } : null), i3.for("editingDowncast").elementToElement({ model: "htmlEmptyElement", view: f_(t4, true) }), i3.for("dataDowncast").elementToElement({ model: "htmlEmptyElement", view: f_(t4) })));
          }
        }
        function z_(t4, e4, n3) {
          const i3 = function(t5, { consumable: e5 }, n4) {
            const i4 = n4.matchAll(t5) || [], o4 = [];
            for (const n5 of i4)
              P_(e5, t5, n5), delete n5.match.name, e5.consume(t5, n5.match), o4.push(n5);
            return o4;
          }(t4, e4, n3), { attributes: o3, styles: r3, classes: s3 } = function(t5) {
            const e5 = { attributes: /* @__PURE__ */ new Set(), classes: /* @__PURE__ */ new Set(), styles: /* @__PURE__ */ new Set() };
            for (const n4 of t5)
              for (const t6 in e5) {
                (n4.match[t6] || []).forEach((n5) => e5[t6].add(n5));
              }
            return e5;
          }(i3), a3 = {};
          if (o3.size)
            for (const t5 of o3)
              Qi2(t5) || o3.delete(t5);
          return o3.size && (a3.attributes = R_(o3, (e5) => t4.getAttribute(e5))), r3.size && (a3.styles = R_(r3, (e5) => t4.getStyle(e5))), s3.size && (a3.classes = Array.from(s3)), Object.keys(a3).length ? a3 : null;
        }
        function P_(t4, e4, n3) {
          for (const i3 of ["attributes", "classes", "styles"]) {
            const o3 = n3.match[i3];
            if (o3)
              for (const n4 of Array.from(o3))
                t4.test(e4, { [i3]: [n4] }) || B_(o3, n4);
          }
        }
        function R_(t4, e4) {
          const n3 = {};
          for (const i3 of t4) {
            void 0 !== e4(i3) && (n3[i3] = e4(i3));
          }
          return n3;
        }
        function O_(t4, e4) {
          const { name: n3 } = t4, i3 = t4[e4];
          return Et2(i3) ? Object.entries(i3).map(([t5, i4]) => ({ name: n3, [e4]: { [t5]: i4 } })) : Array.isArray(i3) ? i3.map((t5) => ({ name: n3, [e4]: [t5] })) : [t4];
        }
        function F_(t4) {
          const { name: e4, attributes: n3, classes: i3, styles: o3 } = t4, r3 = [];
          return n3 && r3.push(...O_({ name: e4, attributes: n3 }, "attributes")), i3 && r3.push(...O_({ name: e4, classes: i3 }, "classes")), o3 && r3.push(...O_({ name: e4, styles: o3 }, "styles")), r3;
        }
        class V_ extends bs {
          static get requires() {
            return [L_];
          }
          static get pluginName() {
            return "CodeBlockElementSupport";
          }
          init() {
            if (!this.editor.plugins.has("CodeBlockEditing"))
              return;
            const t4 = this.editor.plugins.get(L_);
            t4.on("register:pre", (e4, n3) => {
              if ("codeBlock" !== n3.model)
                return;
              const i3 = this.editor, o3 = i3.model.schema, r3 = i3.conversion;
              o3.extend("codeBlock", { allowAttributes: ["htmlPreAttributes", "htmlContentAttributes"] }), r3.for("upcast").add(function(t5) {
                return (e5) => {
                  e5.on("element:code", (e6, n4, i4) => {
                    const o4 = n4.viewItem, r4 = o4.parent;
                    function s3(e7, o5) {
                      const r5 = t5.processViewAttributes(e7, i4);
                      r5 && i4.writer.setAttribute(o5, r5, n4.modelRange);
                    }
                    r4 && r4.is("element", "pre") && (s3(r4, "htmlPreAttributes"), s3(o4, "htmlContentAttributes"));
                  }, { priority: "low" });
                };
              }(t4)), r3.for("downcast").add((t5) => {
                t5.on("attribute:htmlPreAttributes:codeBlock", (t6, e5, n4) => {
                  if (!n4.consumable.consume(e5.item, t6.name))
                    return;
                  const { attributeOldValue: i4, attributeNewValue: o4 } = e5, r4 = n4.mapper.toViewElement(e5.item).parent;
                  c_(n4.writer, i4, o4, r4);
                }), t5.on("attribute:htmlContentAttributes:codeBlock", (t6, e5, n4) => {
                  if (!n4.consumable.consume(e5.item, t6.name))
                    return;
                  const { attributeOldValue: i4, attributeNewValue: o4 } = e5, r4 = n4.mapper.toViewElement(e5.item);
                  c_(n4.writer, i4, o4, r4);
                });
              }), e4.stop();
            });
          }
        }
        class j_ extends bs {
          static get requires() {
            return [L_];
          }
          static get pluginName() {
            return "DualContentModelElementSupport";
          }
          init() {
            this.editor.plugins.get(L_).on("register", (t4, e4) => {
              const n3 = e4, i3 = this.editor, o3 = i3.model.schema, r3 = i3.conversion;
              if (!n3.paragraphLikeModel)
                return;
              if (o3.isRegistered(n3.model) || o3.isRegistered(n3.paragraphLikeModel))
                return;
              const s3 = { model: n3.paragraphLikeModel, view: n3.view };
              o3.register(n3.model, n3.modelSchema), o3.register(s3.model, { inheritAllFrom: "$block" }), r3.for("upcast").elementToElement({ view: n3.view, model: (t5, { writer: e5 }) => this._hasBlockContent(t5) ? e5.createElement(n3.model) : e5.createElement(s3.model), converterPriority: b2.low + 0.5 }), r3.for("downcast").elementToElement({ view: n3.view, model: n3.model }), this._addAttributeConversion(n3), r3.for("downcast").elementToElement({ view: s3.view, model: s3.model }), this._addAttributeConversion(s3), t4.stop();
            });
          }
          _hasBlockContent(t4) {
            const e4 = this.editor.editing.view, n3 = e4.domConverter.blockElements;
            for (const i3 of e4.createRangeIn(t4).getItems())
              if (i3.is("element") && n3.includes(i3.name))
                return true;
            return false;
          }
          _addAttributeConversion(t4) {
            const e4 = this.editor, n3 = e4.conversion, i3 = e4.plugins.get(L_);
            e4.model.schema.extend(t4.model, { allowAttributes: h_(t4.view) }), n3.for("upcast").add(b_(t4, i3)), n3.for("downcast").add(w_(t4));
          }
        }
        class H_ extends bs {
          static get requires() {
            return [v_, Qk2];
          }
          static get pluginName() {
            return "HeadingElementSupport";
          }
          init() {
            const t4 = this.editor;
            if (!t4.plugins.has("HeadingEditing"))
              return;
            const e4 = t4.config.get("heading.options");
            this.registerHeadingElements(t4, e4);
          }
          registerHeadingElements(t4, e4) {
            const n3 = t4.plugins.get(v_), i3 = [];
            for (const t5 of e4)
              "model" in t5 && "view" in t5 && (n3.registerBlockElement({ view: t5.view, model: t5.model }), i3.push(t5.model));
            n3.extendBlockElement({ model: "htmlHgroup", modelSchema: { allowChildren: i3 } });
          }
        }
        function U_(t4, e4, n3) {
          const i3 = t4.createRangeOn(e4);
          for (const { item: t5 } of i3.getWalker())
            if (t5.is("element", n3))
              return t5;
        }
        class G_ extends bs {
          static get requires() {
            return [L_];
          }
          static get pluginName() {
            return "ImageElementSupport";
          }
          init() {
            const t4 = this.editor;
            if (!t4.plugins.has("ImageInlineEditing") && !t4.plugins.has("ImageBlockEditing"))
              return;
            const e4 = t4.model.schema, n3 = t4.conversion, i3 = t4.plugins.get(L_);
            i3.on("register:figure", () => {
              n3.for("upcast").add(function(t5) {
                return (e5) => {
                  e5.on("element:figure", (e6, n4, i4) => {
                    const o3 = n4.viewItem;
                    if (!n4.modelRange || !o3.hasClass("image"))
                      return;
                    const r3 = t5.processViewAttributes(o3, i4);
                    r3 && i4.writer.setAttribute("htmlFigureAttributes", r3, n4.modelRange);
                  }, { priority: "low" });
                };
              }(i3));
            }), i3.on("register:img", (o3, r3) => {
              "imageBlock" !== r3.model && "imageInline" !== r3.model || (e4.isRegistered("imageBlock") && e4.extend("imageBlock", { allowAttributes: ["htmlImgAttributes", "htmlFigureAttributes", "htmlLinkAttributes"] }), e4.isRegistered("imageInline") && e4.extend("imageInline", { allowAttributes: ["htmlA", "htmlImgAttributes"] }), n3.for("upcast").add(function(t5) {
                return (e5) => {
                  e5.on("element:img", (e6, n4, i4) => {
                    if (!n4.modelRange)
                      return;
                    const o4 = n4.viewItem, r4 = t5.processViewAttributes(o4, i4);
                    r4 && i4.writer.setAttribute("htmlImgAttributes", r4, n4.modelRange);
                  }, { priority: "low" });
                };
              }(i3)), n3.for("downcast").add((t5) => {
                function e5(e6) {
                  t5.on(`attribute:${e6}:imageInline`, (t6, e7, n5) => {
                    if (!n5.consumable.consume(e7.item, t6.name))
                      return;
                    const { attributeOldValue: i4, attributeNewValue: o4 } = e7, r4 = n5.mapper.toViewElement(e7.item);
                    c_(n5.writer, i4, o4, r4);
                  }, { priority: "low" });
                }
                function n4(e6, n5) {
                  t5.on(`attribute:${n5}:imageBlock`, (t6, n6, i4) => {
                    if (!i4.consumable.test(n6.item, t6.name))
                      return;
                    const { attributeOldValue: o4, attributeNewValue: r4 } = n6, s3 = i4.mapper.toViewElement(n6.item), a3 = U_(i4.writer, s3, e6);
                    a3 && (c_(i4.writer, o4, r4, a3), i4.consumable.consume(n6.item, t6.name));
                  }, { priority: "low" }), "a" === e6 && t5.on("attribute:linkHref:imageBlock", (t6, e7, n6) => {
                    if (!n6.consumable.consume(e7.item, "attribute:htmlLinkAttributes:imageBlock"))
                      return;
                    const i4 = n6.mapper.toViewElement(e7.item), o4 = U_(n6.writer, i4, "a");
                    l_(n6.writer, e7.item.getAttribute("htmlLinkAttributes"), o4);
                  }, { priority: "low" });
                }
                e5("htmlImgAttributes"), n4("img", "htmlImgAttributes"), n4("figure", "htmlFigureAttributes"), n4("a", "htmlLinkAttributes");
              }), t4.plugins.has("LinkImage") && n3.for("upcast").add(function(t5, e5) {
                const n4 = e5.plugins.get("ImageUtils");
                return (e6) => {
                  e6.on("element:a", (e7, i4, o4) => {
                    const r4 = i4.viewItem;
                    if (!n4.findViewImgElement(r4))
                      return;
                    const s3 = i4.modelCursor.parent;
                    if (!s3.is("element", "imageBlock"))
                      return;
                    const a3 = t5.processViewAttributes(r4, o4);
                    a3 && o4.writer.setAttribute("htmlLinkAttributes", a3, s3);
                  }, { priority: "low" });
                };
              }(i3, t4)), o3.stop());
            });
          }
        }
        class W_ extends bs {
          static get requires() {
            return [L_];
          }
          static get pluginName() {
            return "MediaEmbedElementSupport";
          }
          init() {
            const t4 = this.editor;
            if (!t4.plugins.has("MediaEmbed") || t4.config.get("mediaEmbed.previewsInData"))
              return;
            const e4 = t4.model.schema, n3 = t4.conversion, i3 = this.editor.plugins.get(L_), o3 = this.editor.plugins.get(v_), r3 = t4.config.get("mediaEmbed.elementName");
            o3.registerBlockElement({ model: "media", view: r3 }), i3.on("register:figure", () => {
              n3.for("upcast").add(function(t5) {
                return (e5) => {
                  e5.on("element:figure", (e6, n4, i4) => {
                    const o4 = n4.viewItem;
                    if (!n4.modelRange || !o4.hasClass("media"))
                      return;
                    const r4 = t5.processViewAttributes(o4, i4);
                    r4 && i4.writer.setAttribute("htmlFigureAttributes", r4, n4.modelRange);
                  }, { priority: "low" });
                };
              }(i3));
            }), i3.on(`register:${r3}`, (t5, o4) => {
              "media" === o4.model && (e4.extend("media", { allowAttributes: [h_(r3), "htmlFigureAttributes"] }), n3.for("upcast").add(function(t6, e5) {
                const n4 = (n5, i4, o5) => {
                  function r4(e6, n6) {
                    const r5 = t6.processViewAttributes(e6, o5);
                    r5 && o5.writer.setAttribute(n6, r5, i4.modelRange);
                  }
                  r4(i4.viewItem, h_(e5));
                };
                return (t7) => {
                  t7.on(`element:${e5}`, n4, { priority: "low" });
                };
              }(i3, r3)), n3.for("dataDowncast").add(function(t6) {
                return (e5) => {
                  function n4(t7, n5) {
                    e5.on(`attribute:${n5}:media`, (e6, n6, i4) => {
                      if (!i4.consumable.consume(n6.item, e6.name))
                        return;
                      const { attributeOldValue: o5, attributeNewValue: r4 } = n6, s3 = i4.mapper.toViewElement(n6.item), a3 = U_(i4.writer, s3, t7);
                      c_(i4.writer, o5, r4, a3);
                    });
                  }
                  n4(t6, h_(t6)), n4("figure", "htmlFigureAttributes");
                };
              }(r3)), t5.stop());
            });
          }
        }
        class q_ extends bs {
          static get requires() {
            return [L_];
          }
          static get pluginName() {
            return "ScriptElementSupport";
          }
          init() {
            const t4 = this.editor.plugins.get(L_);
            t4.on("register:script", (e4, n3) => {
              const i3 = this.editor, o3 = i3.model.schema, r3 = i3.conversion;
              o3.register("htmlScript", n3.modelSchema), o3.extend("htmlScript", { allowAttributes: ["htmlScriptAttributes", "htmlContent"], isContent: true }), i3.data.registerRawContentMatcher({ name: "script" }), r3.for("upcast").elementToElement({ view: "script", model: u_(n3) }), r3.for("upcast").add(b_(n3, t4)), r3.for("downcast").elementToElement({ model: "htmlScript", view: (t5, { writer: e5 }) => m_("script", t5, e5) }), r3.for("downcast").add(w_(n3)), e4.stop();
            });
          }
        }
        class $_ extends bs {
          static get requires() {
            return [L_];
          }
          static get pluginName() {
            return "TableElementSupport";
          }
          init() {
            const t4 = this.editor;
            if (!t4.plugins.has("TableEditing"))
              return;
            const e4 = t4.model.schema, n3 = t4.conversion, i3 = t4.plugins.get(L_), o3 = t4.plugins.get("TableUtils");
            i3.on("register:figure", () => {
              n3.for("upcast").add(function(t5) {
                return (e5) => {
                  e5.on("element:figure", (e6, n4, i4) => {
                    const o4 = n4.viewItem;
                    if (!n4.modelRange || !o4.hasClass("table"))
                      return;
                    const r3 = t5.processViewAttributes(o4, i4);
                    r3 && i4.writer.setAttribute("htmlFigureAttributes", r3, n4.modelRange);
                  }, { priority: "low" });
                };
              }(i3));
            }), i3.on("register:table", (r3, s3) => {
              "table" === s3.model && (e4.extend("table", { allowAttributes: ["htmlTableAttributes", "htmlFigureAttributes", "htmlTheadAttributes", "htmlTbodyAttributes"] }), n3.for("upcast").add(function(t5) {
                return (e5) => {
                  e5.on("element:table", (e6, n4, i4) => {
                    if (!n4.modelRange)
                      return;
                    const o4 = n4.viewItem;
                    r4(o4, "htmlTableAttributes");
                    for (const t6 of o4.getChildren())
                      t6.is("element", "thead") && r4(t6, "htmlTheadAttributes"), t6.is("element", "tbody") && r4(t6, "htmlTbodyAttributes");
                    function r4(e7, o5) {
                      const r5 = t5.processViewAttributes(e7, i4);
                      r5 && i4.writer.setAttribute(o5, r5, n4.modelRange);
                    }
                  }, { priority: "low" });
                };
              }(i3)), n3.for("downcast").add((t5) => {
                function e5(e6, n4) {
                  t5.on(`attribute:${n4}:table`, (t6, n5, i4) => {
                    if (!i4.consumable.test(n5.item, t6.name))
                      return;
                    const o4 = i4.mapper.toViewElement(n5.item), r4 = U_(i4.writer, o4, e6);
                    r4 && (i4.consumable.consume(n5.item, t6.name), c_(i4.writer, n5.attributeOldValue, n5.attributeNewValue, r4));
                  });
                }
                e5("table", "htmlTableAttributes"), e5("figure", "htmlFigureAttributes"), e5("thead", "htmlTheadAttributes"), e5("tbody", "htmlTbodyAttributes");
              }), t4.model.document.registerPostFixer(function(t5, e5) {
                return (n4) => {
                  const i4 = t5.document.differ.getChanges();
                  let o4 = false;
                  for (const t6 of i4) {
                    if ("attribute" != t6.type || "headingRows" != t6.attributeKey)
                      continue;
                    const i5 = t6.range.start.nodeAfter, r4 = i5.getAttribute("htmlTheadAttributes"), s4 = i5.getAttribute("htmlTbodyAttributes");
                    r4 && !t6.attributeNewValue ? (n4.removeAttribute("htmlTheadAttributes", i5), o4 = true) : s4 && t6.attributeNewValue == e5.getRows(i5) && (n4.removeAttribute("htmlTbodyAttributes", i5), o4 = true);
                  }
                  return o4;
                };
              }(t4.model, o3)), r3.stop());
            });
          }
        }
        class K_ extends bs {
          static get requires() {
            return [L_];
          }
          static get pluginName() {
            return "StyleElementSupport";
          }
          init() {
            const t4 = this.editor.plugins.get(L_);
            t4.on("register:style", (e4, n3) => {
              const i3 = this.editor, o3 = i3.model.schema, r3 = i3.conversion;
              o3.register("htmlStyle", n3.modelSchema), o3.extend("htmlStyle", { allowAttributes: ["htmlStyleAttributes", "htmlContent"], isContent: true }), i3.data.registerRawContentMatcher({ name: "style" }), r3.for("upcast").elementToElement({ view: "style", model: u_(n3) }), r3.for("upcast").add(b_(n3, t4)), r3.for("downcast").elementToElement({ model: "htmlStyle", view: (t5, { writer: e5 }) => m_("style", t5, e5) }), r3.for("downcast").add(w_(n3)), e4.stop();
            });
          }
        }
        class Z_ extends bs {
          static get requires() {
            return [L_];
          }
          static get pluginName() {
            return "DocumentListElementSupport";
          }
          init() {
            const t4 = this.editor;
            if (!t4.plugins.has("DocumentListEditing"))
              return;
            const e4 = t4.model.schema, n3 = t4.conversion, i3 = t4.plugins.get(L_), o3 = t4.plugins.get("DocumentListEditing"), r3 = ["ul", "ol", "li"];
            o3.registerDowncastStrategy({ scope: "item", attributeName: "htmlLiAttributes", setAttributeOnDowncast: l_ }), o3.registerDowncastStrategy({ scope: "list", attributeName: "htmlUlAttributes", setAttributeOnDowncast: l_ }), o3.registerDowncastStrategy({ scope: "list", attributeName: "htmlOlAttributes", setAttributeOnDowncast: l_ }), i3.on("register", (t5, o4) => {
              if (!r3.includes(o4.view))
                return;
              if (t5.stop(), e4.checkAttribute("$block", "htmlLiAttributes"))
                return;
              const s3 = r3.map((t6) => h_(t6));
              e4.extend("$listItem", { allowAttributes: s3 }), n3.for("upcast").add((t6) => {
                t6.on("element:ul", Y_("htmlUlAttributes", i3), { priority: "low" }), t6.on("element:ol", Y_("htmlOlAttributes", i3), { priority: "low" }), t6.on("element:li", Y_("htmlLiAttributes", i3), { priority: "low" });
              });
            }), o3.on("postFixer", (t5, { listNodes: e5, writer: n4 }) => {
              for (const { node: i4, previousNodeInList: o4 } of e5)
                if (o4) {
                  if (o4.getAttribute("listType") == i4.getAttribute("listType")) {
                    const e6 = Q_(o4.getAttribute("listType")), r4 = o4.getAttribute(e6);
                    !Lh2(i4.getAttribute(e6), r4) && n4.model.schema.checkAttribute(i4, e6) && (n4.setAttribute(e6, r4, i4), t5.return = true);
                  }
                  if (o4.getAttribute("listItemId") == i4.getAttribute("listItemId")) {
                    const e6 = o4.getAttribute("htmlLiAttributes");
                    !Lh2(i4.getAttribute("htmlLiAttributes"), e6) && n4.model.schema.checkAttribute(i4, "htmlLiAttributes") && (n4.setAttribute("htmlLiAttributes", e6, i4), t5.return = true);
                  }
                }
            }), o3.on("postFixer", (t5, { listNodes: e5, writer: n4 }) => {
              for (const { node: i4 } of e5) {
                const e6 = i4.getAttribute("listType");
                "numbered" !== e6 && i4.getAttribute("htmlOlAttributes") && (n4.removeAttribute("htmlOlAttributes", i4), t5.return = true), "numbered" === e6 && i4.getAttribute("htmlUlAttributes") && (n4.removeAttribute("htmlUlAttributes", i4), t5.return = true);
              }
            });
          }
          afterInit() {
            const t4 = this.editor;
            if (!t4.commands.get("indentList"))
              return;
            const e4 = t4.commands.get("indentList");
            this.listenTo(e4, "afterExecute", (e5, n3) => {
              t4.model.change((e6) => {
                for (const i3 of n3) {
                  const n4 = Q_(i3.getAttribute("listType"));
                  t4.model.schema.checkAttribute(i3, n4) && e6.setAttribute(n4, {}, i3);
                }
              });
            });
          }
        }
        function Y_(t4, e4) {
          return (n3, i3, o3) => {
            const r3 = i3.viewItem;
            i3.modelRange || Object.assign(i3, o3.convertChildren(i3.viewItem, i3.modelCursor));
            const s3 = e4.processViewAttributes(r3, o3);
            for (const e5 of i3.modelRange.getItems({ shallow: true }))
              e5.hasAttribute("listItemId") && (e5.hasAttribute(t4) || o3.writer.model.schema.checkAttribute(e5, t4) && o3.writer.setAttribute(t4, s3 || {}, e5));
          };
        }
        function Q_(t4) {
          return "numbered" === t4 ? "htmlOlAttributes" : "htmlUlAttributes";
        }
        class J_ extends bs {
          static get requires() {
            return [L_, v_];
          }
          static get pluginName() {
            return "CustomElementSupport";
          }
          init() {
            const t4 = this.editor.plugins.get(L_), e4 = this.editor.plugins.get(v_);
            t4.on("register:$customElement", (n3, i3) => {
              n3.stop();
              const o3 = this.editor, r3 = o3.model.schema, s3 = o3.conversion, a3 = o3.editing.view.domConverter.unsafeElements, c3 = o3.data.htmlProcessor.domConverter.preElements;
              r3.register(i3.model, i3.modelSchema), r3.extend(i3.model, { allowAttributes: ["htmlElementName", "htmlCustomElementAttributes", "htmlContent"], isContent: true }), s3.for("upcast").elementToElement({ view: /.*/, model: (n4, r4) => {
                if ("$comment" == n4.name)
                  return null;
                if (!function(t5) {
                  try {
                    document.createElement(t5);
                  } catch (t6) {
                    return false;
                  }
                  return true;
                }(n4.name))
                  return null;
                if (e4.getDefinitionsForView(n4.name).size)
                  return null;
                a3.includes(n4.name) || a3.push(n4.name), c3.includes(n4.name) || c3.push(n4.name);
                const s4 = r4.writer.createElement(i3.model, { htmlElementName: n4.name }), l3 = t4.processViewAttributes(n4, r4);
                l3 && r4.writer.setAttribute("htmlCustomElementAttributes", l3, s4);
                const d3 = new ju(n4.document).createDocumentFragment(n4), h3 = o3.data.processor.toData(d3);
                r4.writer.setAttribute("htmlContent", h3, s4);
                for (const { item: t5 } of o3.editing.view.createRangeIn(n4))
                  r4.consumable.consume(t5, { name: true });
                return s4;
              }, converterPriority: "low" }), s3.for("editingDowncast").elementToElement({ model: { name: i3.model, attributes: ["htmlElementName", "htmlCustomElementAttributes", "htmlContent"] }, view: (t5, { writer: e5 }) => {
                const n4 = t5.getAttribute("htmlElementName"), i4 = e5.createRawElement(n4);
                return t5.hasAttribute("htmlCustomElementAttributes") && l_(e5, t5.getAttribute("htmlCustomElementAttributes"), i4), i4;
              } }), s3.for("dataDowncast").elementToElement({ model: { name: i3.model, attributes: ["htmlElementName", "htmlCustomElementAttributes", "htmlContent"] }, view: (t5, { writer: e5 }) => {
                const n4 = t5.getAttribute("htmlElementName"), i4 = t5.getAttribute("htmlContent"), o4 = e5.createRawElement(n4, null, (t6, e6) => {
                  e6.setContentOf(t6, i4);
                  const n5 = t6.firstChild;
                  for (n5.remove(); n5.firstChild; )
                    t6.appendChild(n5.firstChild);
                });
                return t5.hasAttribute("htmlCustomElementAttributes") && l_(e5, t5.getAttribute("htmlCustomElementAttributes"), o4), o4;
              } });
            });
          }
        }
        function* X_(t4, e4, n3) {
          if (e4)
            if (!(Symbol.iterator in e4) && e4.is("documentSelection") && e4.isCollapsed)
              t4.schema.checkAttributeInSelection(e4, n3) && (yield e4);
            else
              for (const i3 of function(t5, e5, n4) {
                return !(Symbol.iterator in e5) && (e5.is("node") || e5.is("$text") || e5.is("$textProxy")) ? t5.schema.checkAttribute(e5, n4) ? [t5.createRangeOn(e5)] : [] : t5.schema.getValidRanges(t5.createSelection(e5).getRanges(), n4);
              }(t4, e4, n3))
                yield* i3.getItems({ shallow: true });
        }
        function tv(t4) {
          return t4.createContainerElement("figure", { class: "image" }, [t4.createEmptyElement("img"), t4.createSlot("children")]);
        }
        function ev(t4, e4) {
          const n3 = t4.plugins.get("ImageUtils"), i3 = t4.plugins.has("ImageInlineEditing") && t4.plugins.has("ImageBlockEditing");
          return (t5) => {
            if (!n3.isInlineImageView(t5))
              return null;
            if (!i3)
              return o3(t5);
            return ("block" == t5.getStyle("display") || t5.findAncestor(n3.isBlockImageView) ? "imageBlock" : "imageInline") !== e4 ? null : o3(t5);
          };
          function o3(t5) {
            const e5 = { name: true };
            return t5.hasAttribute("src") && (e5.attributes = ["src"]), e5;
          }
        }
        function nv(t4, e4) {
          const n3 = So2(e4.getSelectedBlocks());
          return !n3 || t4.isObject(n3) || n3.isEmpty && "listItem" != n3.name ? "imageBlock" : "imageInline";
        }
        function iv(t4) {
          return t4 && t4.endsWith("px") ? parseInt(t4) : null;
        }
        function ov(t4) {
          const e4 = iv(t4.getStyle("width")), n3 = iv(t4.getStyle("height"));
          return !(!e4 || !n3);
        }
        const rv = /^(image|image-inline)$/;
        class sv extends bs {
          constructor() {
            super(...arguments), this._domEmitter = new (Ii2())();
          }
          static get pluginName() {
            return "ImageUtils";
          }
          isImage(t4) {
            return this.isInlineImage(t4) || this.isBlockImage(t4);
          }
          isInlineImageView(t4) {
            return !!t4 && t4.is("element", "img");
          }
          isBlockImageView(t4) {
            return !!t4 && t4.is("element", "figure") && t4.hasClass("image");
          }
          insertImage(t4 = {}, e4 = null, n3 = null, i3 = {}) {
            const o3 = this.editor, r3 = o3.model, s3 = r3.document.selection, a3 = av(o3, e4 || s3, n3);
            t4 = { ...Object.fromEntries(s3.getAttributes()), ...t4 };
            for (const e5 in t4)
              r3.schema.checkAttribute(a3, e5) || delete t4[e5];
            return r3.change((n4) => {
              const { setImageSizes: o4 = true } = i3, s4 = n4.createElement(a3, t4);
              return r3.insertObject(s4, e4, null, { setSelection: "on", findOptimalPosition: e4 || "imageInline" == a3 ? void 0 : "auto" }), s4.parent ? (o4 && this.setImageNaturalSizeAttributes(s4), s4) : null;
            });
          }
          setImageNaturalSizeAttributes(t4) {
            const e4 = t4.getAttribute("src");
            e4 && (t4.getAttribute("width") || t4.getAttribute("height") || this.editor.model.change((n3) => {
              const i3 = new Li2.window.Image();
              this._domEmitter.listenTo(i3, "load", () => {
                t4.getAttribute("width") || t4.getAttribute("height") || this.editor.model.enqueueChange(n3.batch, (e5) => {
                  e5.setAttribute("width", i3.naturalWidth, t4), e5.setAttribute("height", i3.naturalHeight, t4);
                }), this._domEmitter.stopListening(i3, "load");
              }), i3.src = e4;
            }));
          }
          getClosestSelectedImageWidget(t4) {
            const e4 = t4.getFirstPosition();
            if (!e4)
              return null;
            const n3 = t4.getSelectedElement();
            if (n3 && this.isImageWidget(n3))
              return n3;
            let i3 = e4.parent;
            for (; i3; ) {
              if (i3.is("element") && this.isImageWidget(i3))
                return i3;
              i3 = i3.parent;
            }
            return null;
          }
          getClosestSelectedImageElement(t4) {
            const e4 = t4.getSelectedElement();
            return this.isImage(e4) ? e4 : t4.getFirstPosition().findAncestor("imageBlock");
          }
          getImageWidgetFromImageView(t4) {
            return t4.findAncestor({ classes: rv });
          }
          isImageAllowed() {
            const t4 = this.editor.model.document.selection;
            return function(t5, e4) {
              const n3 = av(t5, e4, null);
              if ("imageBlock" == n3) {
                const n4 = function(t6, e5) {
                  const n5 = $b2(t6, e5), i3 = n5.start.parent;
                  if (i3.isEmpty && !i3.is("element", "$root"))
                    return i3.parent;
                  return i3;
                }(e4, t5.model);
                if (t5.model.schema.checkChild(n4, "imageBlock"))
                  return true;
              } else if (t5.model.schema.checkChild(e4.focus, "imageInline"))
                return true;
              return false;
            }(this.editor, t4) && function(t5) {
              return [...t5.focus.getAncestors()].every((t6) => !t6.is("element", "imageBlock"));
            }(t4);
          }
          toImageWidget(t4, e4, n3) {
            e4.setCustomProperty("image", true, t4);
            return Hb2(t4, e4, { label: () => {
              const e5 = this.findViewImgElement(t4).getAttribute("alt");
              return e5 ? `${e5} ${n3}` : n3;
            } });
          }
          isImageWidget(t4) {
            return !!t4.getCustomProperty("image") && jb2(t4);
          }
          isBlockImage(t4) {
            return !!t4 && t4.is("element", "imageBlock");
          }
          isInlineImage(t4) {
            return !!t4 && t4.is("element", "imageInline");
          }
          findViewImgElement(t4) {
            if (this.isInlineImageView(t4))
              return t4;
            const e4 = this.editor.editing.view;
            for (const { item: n3 } of e4.createRangeIn(t4))
              if (this.isInlineImageView(n3))
                return n3;
          }
          destroy() {
            return this._domEmitter.stopListening(), super.destroy();
          }
        }
        function av(t4, e4, n3) {
          const i3 = t4.model.schema, o3 = t4.config.get("image.insert.type");
          return t4.plugins.has("ImageBlockEditing") ? t4.plugins.has("ImageInlineEditing") ? n3 || ("inline" === o3 ? "imageInline" : "auto" !== o3 ? "imageBlock" : e4.is("selection") ? nv(i3, e4) : i3.checkChild(e4, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
        }
        const cv = new RegExp(String(/^(http(s)?:\/\/)?[\w-]+\.[\w.~:/[\]@!$&'()*+,;=%-]+/.source + /\.(jpg|jpeg|png|gif|ico|webp|JPG|JPEG|PNG|GIF|ICO|WEBP)/.source + /(\?[\w.~:/[\]@!$&'()*+,;=%-]*)?/.source + /(#[\w.~:/[\]@!$&'()*+,;=%-]*)?$/.source));
        class lv extends As {
          refresh() {
            const t4 = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
            this.isEnabled = !!t4, this.isEnabled && t4.hasAttribute("alt") ? this.value = t4.getAttribute("alt") : this.value = false;
          }
          execute(t4) {
            const e4 = this.editor, n3 = e4.plugins.get("ImageUtils"), i3 = e4.model, o3 = n3.getClosestSelectedImageElement(i3.document.selection);
            i3.change((e5) => {
              e5.setAttribute("alt", t4.newValue, o3);
            });
          }
        }
        class dv extends bs {
          static get requires() {
            return [sv];
          }
          static get pluginName() {
            return "ImageTextAlternativeEditing";
          }
          init() {
            this.editor.commands.add("imageTextAlternative", new lv(this.editor));
          }
        }
        var hv = n2(5269), uv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(hv.Z, uv);
        hv.Z.locals;
        class gv extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.locale.t;
            this.focusTracker = new To2(), this.keystrokes = new Io2(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(e4("Save"), Pg2.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(e4("Cancel"), Pg2.cancel, "ck-button-cancel", "cancel"), this._focusables = new Ro2(), this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] });
          }
          render() {
            super.render(), this.keystrokes.listenTo(this.element), o2({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t4) => {
              this._focusables.add(t4), this.focusTracker.add(t4.element);
            });
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          _createButton(t4, e4, n3, i3) {
            const o3 = new kr(this.locale);
            return o3.set({ label: t4, icon: e4, tooltip: true }), o3.extendTemplate({ attributes: { class: n3 } }), i3 && o3.delegate("execute").to(this, i3), o3;
          }
          _createLabeledInputView() {
            const t4 = this.locale.t, e4 = new Xr(this.locale, hm);
            return e4.label = t4("Text alternative"), e4;
          }
        }
        function mv(t4) {
          const e4 = t4.editing.view, n3 = lp.defaultPositions, i3 = t4.plugins.get("ImageUtils");
          return { target: e4.domConverter.mapViewToDom(i3.getClosestSelectedImageWidget(e4.document.selection)), positions: [n3.northArrowSouth, n3.northArrowSouthWest, n3.northArrowSouthEast, n3.southArrowNorth, n3.southArrowNorthWest, n3.southArrowNorthEast, n3.viewportStickyNorth] };
        }
        class pv extends bs {
          static get requires() {
            return [Yp];
          }
          static get pluginName() {
            return "ImageTextAlternativeUI";
          }
          init() {
            this._createButton();
          }
          destroy() {
            super.destroy(), this._form && this._form.destroy();
          }
          _createButton() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add("imageTextAlternative", (n3) => {
              const i3 = t4.commands.get("imageTextAlternative"), o3 = new kr(n3);
              return o3.set({ label: e4("Change image text alternative"), icon: Pg2.textAlternative, tooltip: true }), o3.bind("isEnabled").to(i3, "isEnabled"), o3.bind("isOn").to(i3, "value", (t5) => !!t5), this.listenTo(o3, "execute", () => {
                this._showForm();
              }), o3;
            });
          }
          _createForm() {
            const n3 = this.editor, i3 = n3.editing.view.document, o3 = n3.plugins.get("ImageUtils");
            this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (e3(gv))(n3.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
              n3.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(true);
            }), this.listenTo(this._form, "cancel", () => {
              this._hideForm(true);
            }), this._form.keystrokes.set("Esc", (t4, e4) => {
              this._hideForm(true), e4();
            }), this.listenTo(n3.ui, "update", () => {
              o3.getClosestSelectedImageWidget(i3.selection) ? this._isVisible && function(t4) {
                const e4 = t4.plugins.get("ContextualBalloon");
                if (t4.plugins.get("ImageUtils").getClosestSelectedImageWidget(t4.editing.view.document.selection)) {
                  const n4 = mv(t4);
                  e4.updatePosition(n4);
                }
              }(n3) : this._hideForm(true);
            }), t3({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() });
          }
          _showForm() {
            if (this._isVisible)
              return;
            this._form || this._createForm();
            const t4 = this.editor, e4 = t4.commands.get("imageTextAlternative"), n3 = this._form.labeledInput;
            this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({ view: this._form, position: mv(t4) }), n3.fieldView.value = n3.fieldView.element.value = e4.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
          }
          _hideForm(t4 = false) {
            this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), t4 && this.editor.editing.view.focus());
          }
          get _isVisible() {
            return !!this._balloon && this._balloon.visibleView === this._form;
          }
          get _isInBalloon() {
            return !!this._balloon && this._balloon.hasView(this._form);
          }
        }
        class fv extends bs {
          static get requires() {
            return [dv, pv];
          }
          static get pluginName() {
            return "ImageTextAlternative";
          }
        }
        function kv(t4, e4) {
          const n3 = (e5, n4, i3) => {
            if (!i3.consumable.consume(n4.item, e5.name))
              return;
            const o3 = i3.writer, r3 = i3.mapper.toViewElement(n4.item), s3 = t4.findViewImgElement(r3);
            null === n4.attributeNewValue ? (o3.removeAttribute("srcset", s3), o3.removeAttribute("sizes", s3)) : n4.attributeNewValue && (o3.setAttribute("srcset", n4.attributeNewValue, s3), o3.setAttribute("sizes", "100vw", s3));
          };
          return (t5) => {
            t5.on(`attribute:srcset:${e4}`, n3);
          };
        }
        function bv(t4, e4, n3) {
          const i3 = (e5, n4, i4) => {
            if (!i4.consumable.consume(n4.item, e5.name))
              return;
            const o3 = i4.writer, r3 = i4.mapper.toViewElement(n4.item), s3 = t4.findViewImgElement(r3);
            o3.setAttribute(n4.attributeKey, n4.attributeNewValue || "", s3);
          };
          return (t5) => {
            t5.on(`attribute:${n3}:${e4}`, i3);
          };
        }
        class wv extends el2 {
          observe(t4) {
            this.listenTo(t4, "load", (t5, e4) => {
              const n3 = e4.target;
              this.checkShouldIgnoreEventFromTarget(n3) || "IMG" == n3.tagName && this._fireEvents(e4);
            }, { useCapture: true });
          }
          stopObserving(t4) {
            this.stopListening(t4);
          }
          _fireEvents(t4) {
            this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", t4));
          }
        }
        class Av extends As {
          constructor(t4) {
            super(t4);
            const e4 = t4.config.get("image.insert.type");
            t4.plugins.has("ImageBlockEditing") || "block" === e4 && _2("image-block-plugin-required"), t4.plugins.has("ImageInlineEditing") || "inline" === e4 && _2("image-inline-plugin-required");
          }
          refresh() {
            const t4 = this.editor.plugins.get("ImageUtils");
            this.isEnabled = t4.isImageAllowed();
          }
          execute(t4) {
            const e4 = yo2(t4.source), n3 = this.editor.model.document.selection, i3 = this.editor.plugins.get("ImageUtils"), o3 = Object.fromEntries(n3.getAttributes());
            e4.forEach((t5, e5) => {
              const r3 = n3.getSelectedElement();
              if ("string" == typeof t5 && (t5 = { src: t5 }), e5 && r3 && i3.isImage(r3)) {
                const e6 = this.editor.model.createPositionAfter(r3);
                i3.insertImage({ ...t5, ...o3 }, e6);
              } else
                i3.insertImage({ ...t5, ...o3 });
            });
          }
        }
        class Cv extends As {
          constructor(t4) {
            super(t4), this.decorate("cleanupImage");
          }
          refresh() {
            const t4 = this.editor.plugins.get("ImageUtils"), e4 = this.editor.model.document.selection.getSelectedElement();
            this.isEnabled = t4.isImage(e4), this.value = this.isEnabled ? e4.getAttribute("src") : null;
          }
          execute(t4) {
            const e4 = this.editor.model.document.selection.getSelectedElement(), n3 = this.editor.plugins.get("ImageUtils");
            this.editor.model.change((i3) => {
              i3.setAttribute("src", t4.source, e4), this.cleanupImage(i3, e4), n3.setImageNaturalSizeAttributes(e4);
            });
          }
          cleanupImage(t4, e4) {
            t4.removeAttribute("srcset", e4), t4.removeAttribute("sizes", e4), t4.removeAttribute("sources", e4), t4.removeAttribute("width", e4), t4.removeAttribute("height", e4), t4.removeAttribute("alt", e4);
          }
        }
        class _v extends bs {
          static get requires() {
            return [sv];
          }
          static get pluginName() {
            return "ImageEditing";
          }
          init() {
            const t4 = this.editor, e4 = t4.conversion;
            t4.editing.view.addObserver(wv), e4.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: "srcset" });
            const n3 = new Av(t4), i3 = new Cv(t4);
            t4.commands.add("insertImage", n3), t4.commands.add("replaceImageSource", i3), t4.commands.add("imageInsert", n3);
          }
        }
        class vv extends bs {
          static get requires() {
            return [sv];
          }
          static get pluginName() {
            return "ImageSizeAttributes";
          }
          afterInit() {
            this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline");
          }
          _registerSchema() {
            this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["width", "height"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["width", "height"] });
          }
          _registerConverters(t4) {
            const e4 = this.editor, n3 = e4.plugins.get("ImageUtils"), i3 = "imageBlock" === t4 ? "figure" : "img";
            function o3(e5, i4, o4, r3) {
              e5.on(`attribute:${i4}:${t4}`, (e6, i5, s3) => {
                if (!s3.consumable.consume(i5.item, e6.name))
                  return;
                const a3 = s3.writer, c3 = s3.mapper.toViewElement(i5.item), l3 = n3.findViewImgElement(c3);
                if (null !== i5.attributeNewValue ? a3.setAttribute(o4, i5.attributeNewValue, l3) : a3.removeAttribute(o4, l3), i5.item.hasAttribute("sources"))
                  return;
                const d3 = i5.item.hasAttribute("resizedWidth");
                if ("imageInline" === t4 && !d3 && !r3)
                  return;
                const h3 = i5.item.getAttribute("width"), u3 = i5.item.getAttribute("height");
                h3 && u3 && a3.setStyle("aspect-ratio", `${h3}/${u3}`, l3);
              });
            }
            e4.conversion.for("upcast").attributeToAttribute({ view: { name: i3, styles: { width: /.+/ } }, model: { key: "width", value: (t5) => ov(t5) ? iv(t5.getStyle("width")) : null } }).attributeToAttribute({ view: { name: i3, key: "width" }, model: "width" }).attributeToAttribute({ view: { name: i3, styles: { height: /.+/ } }, model: { key: "height", value: (t5) => ov(t5) ? iv(t5.getStyle("height")) : null } }).attributeToAttribute({ view: { name: i3, key: "height" }, model: "height" }), e4.conversion.for("editingDowncast").add((t5) => {
              o3(t5, "width", "width", true), o3(t5, "height", "height", true);
            }), e4.conversion.for("dataDowncast").add((t5) => {
              o3(t5, "width", "width", false), o3(t5, "height", "height", false);
            });
          }
        }
        class yv extends As {
          constructor(t4, e4) {
            super(t4), this._modelElementName = e4;
          }
          refresh() {
            const t4 = this.editor.plugins.get("ImageUtils"), e4 = t4.getClosestSelectedImageElement(this.editor.model.document.selection);
            "imageBlock" === this._modelElementName ? this.isEnabled = t4.isInlineImage(e4) : this.isEnabled = t4.isBlockImage(e4);
          }
          execute(t4 = {}) {
            const e4 = this.editor, n3 = this.editor.model, i3 = e4.plugins.get("ImageUtils"), o3 = i3.getClosestSelectedImageElement(n3.document.selection), r3 = Object.fromEntries(o3.getAttributes());
            return r3.src || r3.uploadId ? n3.change((e5) => {
              const { setImageSizes: s3 = true } = t4, a3 = Array.from(n3.markers).filter((t5) => t5.getRange().containsItem(o3)), c3 = i3.insertImage(r3, n3.createSelection(o3, "on"), this._modelElementName, { setImageSizes: s3 });
              if (!c3)
                return null;
              const l3 = e5.createRangeOn(c3);
              for (const t5 of a3) {
                const n4 = t5.getRange(), i4 = "$graveyard" != n4.root.rootName ? n4.getJoined(l3, true) : l3;
                e5.updateMarker(t5, { range: i4 });
              }
              return { oldElement: o3, newElement: c3 };
            }) : null;
          }
        }
        var xv = n2(31), Ev = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(xv.Z, Ev);
        xv.Z.locals;
        class Dv extends bs {
          static get requires() {
            return [sv];
          }
          static get pluginName() {
            return "ImagePlaceholder";
          }
          afterInit() {
            this._setupSchema(), this._setupConversion(), this._setupLoadListener();
          }
          _setupSchema() {
            const t4 = this.editor.model.schema;
            t4.isRegistered("imageBlock") && t4.extend("imageBlock", { allowAttributes: ["placeholder"] }), t4.isRegistered("imageInline") && t4.extend("imageInline", { allowAttributes: ["placeholder"] });
          }
          _setupConversion() {
            const t4 = this.editor, e4 = t4.conversion, n3 = t4.plugins.get("ImageUtils");
            e4.for("editingDowncast").add((t5) => {
              t5.on("attribute:placeholder", (t6, e5, i3) => {
                if (!i3.consumable.test(e5.item, t6.name))
                  return;
                if (!e5.item.is("element", "imageBlock") && !e5.item.is("element", "imageInline"))
                  return;
                i3.consumable.consume(e5.item, t6.name);
                const o3 = i3.writer, r3 = i3.mapper.toViewElement(e5.item), s3 = n3.findViewImgElement(r3);
                e5.attributeNewValue ? (o3.addClass("image_placeholder", s3), o3.setStyle("background-image", `url(${e5.attributeNewValue})`, s3), o3.setCustomProperty("editingPipeline:doNotReuseOnce", true, s3)) : (o3.removeClass("image_placeholder", s3), o3.removeStyle("background-image", s3));
              });
            });
          }
          _setupLoadListener() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing, i3 = n3.view, o3 = t4.plugins.get("ImageUtils");
            i3.addObserver(wv), this.listenTo(i3.document, "imageLoaded", (t5, r3) => {
              const s3 = i3.domConverter.mapDomToView(r3.target);
              if (!s3)
                return;
              const a3 = o3.getImageWidgetFromImageView(s3);
              if (!a3)
                return;
              const c3 = n3.mapper.toModelElement(a3);
              c3 && c3.hasAttribute("placeholder") && e4.enqueueChange({ isUndoable: false }, (t6) => {
                t6.removeAttribute("placeholder", c3);
              });
            });
          }
        }
        class Sv extends bs {
          static get requires() {
            return [_v, vv, sv, Dv, Nb2];
          }
          static get pluginName() {
            return "ImageBlockEditing";
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.register("imageBlock", { inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"] }), this._setupConversion(), t4.plugins.has("ImageInlineEditing") && (t4.commands.add("imageTypeBlock", new yv(this.editor, "imageBlock")), this._setupClipboardIntegration());
          }
          _setupConversion() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.conversion, i3 = t4.plugins.get("ImageUtils");
            n3.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (t5, { writer: e5 }) => tv(e5) }), n3.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (t5, { writer: n4 }) => i3.toImageWidget(tv(n4), n4, e4("image widget")) }), n3.for("downcast").add(bv(i3, "imageBlock", "src")).add(bv(i3, "imageBlock", "alt")).add(kv(i3, "imageBlock")), n3.for("upcast").elementToElement({ view: ev(t4, "imageBlock"), model: (t5, { writer: e5 }) => e5.createElement("imageBlock", t5.hasAttribute("src") ? { src: t5.getAttribute("src") } : void 0) }).add(function(t5) {
              const e5 = (e6, n4, i4) => {
                if (!i4.consumable.test(n4.viewItem, { name: true, classes: "image" }))
                  return;
                const o3 = t5.findViewImgElement(n4.viewItem);
                if (!o3 || !i4.consumable.test(o3, { name: true }))
                  return;
                i4.consumable.consume(n4.viewItem, { name: true, classes: "image" });
                const r3 = So2(i4.convertItem(o3, n4.modelCursor).modelRange.getItems());
                r3 ? (i4.convertChildren(n4.viewItem, r3), i4.updateConversionResult(r3, n4)) : i4.consumable.revert(n4.viewItem, { name: true, classes: "image" });
              };
              return (t6) => {
                t6.on("element:figure", e5);
              };
            }(i3));
          }
          _setupClipboardIntegration() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, i3 = t4.plugins.get("ImageUtils"), o3 = t4.plugins.get("ClipboardPipeline");
            this.listenTo(o3, "inputTransformation", (o4, r3) => {
              const s3 = Array.from(r3.content.getChildren());
              let a3;
              if (!s3.every(i3.isInlineImageView))
                return;
              a3 = r3.targetRanges ? t4.editing.mapper.toModelRange(r3.targetRanges[0]) : e4.document.selection.getFirstRange();
              const c3 = e4.createSelection(a3);
              if ("imageBlock" === nv(e4.schema, c3)) {
                const t5 = new ju(n3.document), e5 = s3.map((e6) => t5.createElement("figure", { class: "image" }, e6));
                r3.content = t5.createDocumentFragment(e5);
              }
            }), this.listenTo(o3, "contentInsertion", (t5, n4) => {
              "paste" === n4.method && e4.change((t6) => {
                const e5 = t6.createRangeIn(n4.content);
                for (const t7 of e5.getItems())
                  t7.is("element", "imageBlock") && i3.setImageNaturalSizeAttributes(t7);
              });
            });
          }
        }
        var Tv = n2(2430), Iv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Tv.Z, Iv);
        Tv.Z.locals;
        class Bv extends bs {
          static get requires() {
            return [Sv, lw, fv];
          }
          static get pluginName() {
            return "ImageBlock";
          }
        }
        class Mv extends bs {
          static get requires() {
            return [_v, vv, sv, Dv, Nb2];
          }
          static get pluginName() {
            return "ImageInlineEditing";
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema;
            e4.register("imageInline", { inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"] }), e4.addChildCheck((t5, e5) => {
              if (t5.endsWith("caption") && "imageInline" === e5.name)
                return false;
            }), this._setupConversion(), t4.plugins.has("ImageBlockEditing") && (t4.commands.add("imageTypeInline", new yv(this.editor, "imageInline")), this._setupClipboardIntegration());
          }
          _setupConversion() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.conversion, i3 = t4.plugins.get("ImageUtils");
            n3.for("dataDowncast").elementToElement({ model: "imageInline", view: (t5, { writer: e5 }) => e5.createEmptyElement("img") }), n3.for("editingDowncast").elementToStructure({ model: "imageInline", view: (t5, { writer: n4 }) => i3.toImageWidget(function(t6) {
              return t6.createContainerElement("span", { class: "image-inline" }, t6.createEmptyElement("img"));
            }(n4), n4, e4("image widget")) }), n3.for("downcast").add(bv(i3, "imageInline", "src")).add(bv(i3, "imageInline", "alt")).add(kv(i3, "imageInline")), n3.for("upcast").elementToElement({ view: ev(t4, "imageInline"), model: (t5, { writer: e5 }) => e5.createElement("imageInline", t5.hasAttribute("src") ? { src: t5.getAttribute("src") } : void 0) });
          }
          _setupClipboardIntegration() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, i3 = t4.plugins.get("ImageUtils"), o3 = t4.plugins.get("ClipboardPipeline");
            this.listenTo(o3, "inputTransformation", (o4, r3) => {
              const s3 = Array.from(r3.content.getChildren());
              let a3;
              if (!s3.every(i3.isBlockImageView))
                return;
              a3 = r3.targetRanges ? t4.editing.mapper.toModelRange(r3.targetRanges[0]) : e4.document.selection.getFirstRange();
              const c3 = e4.createSelection(a3);
              if ("imageInline" === nv(e4.schema, c3)) {
                const t5 = new ju(n3.document), e5 = s3.map((e6) => 1 === e6.childCount ? (Array.from(e6.getAttributes()).forEach((n4) => t5.setAttribute(...n4, i3.findViewImgElement(e6))), e6.getChild(0)) : e6);
                r3.content = t5.createDocumentFragment(e5);
              }
            }), this.listenTo(o3, "contentInsertion", (t5, n4) => {
              "paste" === n4.method && e4.change((t6) => {
                const e5 = t6.createRangeIn(n4.content);
                for (const t7 of e5.getItems())
                  t7.is("element", "imageInline") && i3.setImageNaturalSizeAttributes(t7);
              });
            });
          }
        }
        class Nv extends bs {
          static get requires() {
            return [Mv, lw, fv];
          }
          static get pluginName() {
            return "ImageInline";
          }
        }
        class Lv extends bs {
          static get pluginName() {
            return "ImageCaptionUtils";
          }
          static get requires() {
            return [sv];
          }
          getCaptionFromImageModelElement(t4) {
            for (const e4 of t4.getChildren())
              if (e4 && e4.is("element", "caption"))
                return e4;
            return null;
          }
          getCaptionFromModelSelection(t4) {
            const e4 = this.editor.plugins.get("ImageUtils"), n3 = t4.getFirstPosition().findAncestor("caption");
            return n3 && e4.isBlockImage(n3.parent) ? n3 : null;
          }
          matchImageCaptionViewElement(t4) {
            const e4 = this.editor.plugins.get("ImageUtils");
            return "figcaption" == t4.name && e4.isBlockImageView(t4.parent) ? { name: true } : null;
          }
        }
        class zv extends As {
          refresh() {
            const t4 = this.editor, e4 = t4.plugins.get("ImageCaptionUtils"), n3 = t4.plugins.get("ImageUtils");
            if (!t4.plugins.has(Sv))
              return this.isEnabled = false, void (this.value = false);
            const i3 = t4.model.document.selection, o3 = i3.getSelectedElement();
            if (!o3) {
              const t5 = e4.getCaptionFromModelSelection(i3);
              return this.isEnabled = !!t5, void (this.value = !!t5);
            }
            this.isEnabled = n3.isImage(o3), this.isEnabled ? this.value = !!e4.getCaptionFromImageModelElement(o3) : this.value = false;
          }
          execute(t4 = {}) {
            const { focusCaptionOnShow: e4 } = t4;
            this.editor.model.change((t5) => {
              this.value ? this._hideImageCaption(t5) : this._showImageCaption(t5, e4);
            });
          }
          _showImageCaption(t4, e4) {
            const n3 = this.editor.model.document.selection, i3 = this.editor.plugins.get("ImageCaptionEditing"), o3 = this.editor.plugins.get("ImageUtils");
            let r3 = n3.getSelectedElement();
            const s3 = i3._getSavedCaption(r3);
            o3.isInlineImage(r3) && (this.editor.execute("imageTypeBlock"), r3 = n3.getSelectedElement());
            const a3 = s3 || t4.createElement("caption");
            t4.append(a3, r3), e4 && t4.setSelection(a3, "in");
          }
          _hideImageCaption(t4) {
            const e4 = this.editor, n3 = e4.model.document.selection, i3 = e4.plugins.get("ImageCaptionEditing"), o3 = e4.plugins.get("ImageCaptionUtils");
            let r3, s3 = n3.getSelectedElement();
            s3 ? r3 = o3.getCaptionFromImageModelElement(s3) : (r3 = o3.getCaptionFromModelSelection(n3), s3 = r3.parent), i3._saveCaption(s3, r3), t4.setSelection(s3, "on"), t4.remove(r3);
          }
        }
        class Pv extends bs {
          static get requires() {
            return [sv, Lv];
          }
          static get pluginName() {
            return "ImageCaptionEditing";
          }
          constructor(t4) {
            super(t4), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema;
            e4.isRegistered("caption") ? e4.extend("caption", { allowIn: "imageBlock" }) : e4.register("caption", { allowIn: "imageBlock", allowContentOf: "$block", isLimit: true }), t4.commands.add("toggleImageCaption", new zv(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion();
          }
          _setupConversion() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = t4.plugins.get("ImageUtils"), i3 = t4.plugins.get("ImageCaptionUtils"), o3 = t4.t;
            t4.conversion.for("upcast").elementToElement({ view: (t5) => i3.matchImageCaptionViewElement(t5), model: "caption" }), t4.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (t5, { writer: e5 }) => n3.isBlockImage(t5.parent) ? e5.createContainerElement("figcaption") : null }), t4.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (t5, { writer: i4 }) => {
              if (!n3.isBlockImage(t5.parent))
                return null;
              const r3 = i4.createEditableElement("figcaption");
              i4.setCustomProperty("imageCaption", true, r3), r3.placeholder = o3("Enter image caption"), Is({ view: e4, element: r3, keepOnFocus: true });
              const s3 = t5.parent.getAttribute("alt");
              return qb2(r3, i4, { label: s3 ? o3("Caption for image: %0", [s3]) : o3("Caption for the image") });
            } });
          }
          _setupImageTypeCommandsIntegration() {
            const t4 = this.editor, e4 = t4.plugins.get("ImageUtils"), n3 = t4.plugins.get("ImageCaptionUtils"), i3 = t4.commands.get("imageTypeInline"), o3 = t4.commands.get("imageTypeBlock"), r3 = (t5) => {
              if (!t5.return)
                return;
              const { oldElement: i4, newElement: o4 } = t5.return;
              if (!i4)
                return;
              if (e4.isBlockImage(i4)) {
                const t6 = n3.getCaptionFromImageModelElement(i4);
                if (t6)
                  return void this._saveCaption(o4, t6);
              }
              const r4 = this._getSavedCaption(i4);
              r4 && this._saveCaption(o4, r4);
            };
            i3 && this.listenTo(i3, "execute", r3, { priority: "low" }), o3 && this.listenTo(o3, "execute", r3, { priority: "low" });
          }
          _getSavedCaption(t4) {
            const e4 = this._savedCaptionsMap.get(t4);
            return e4 ? Wl.fromJSON(e4) : null;
          }
          _saveCaption(t4, e4) {
            this._savedCaptionsMap.set(t4, e4.toJSON());
          }
          _registerCaptionReconversion() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.plugins.get("ImageUtils"), i3 = t4.plugins.get("ImageCaptionUtils");
            e4.document.on("change:data", () => {
              const o3 = e4.document.differ.getChanges();
              for (const e5 of o3) {
                if ("alt" !== e5.attributeKey)
                  continue;
                const o4 = e5.range.start.nodeAfter;
                if (n3.isBlockImage(o4)) {
                  const e6 = i3.getCaptionFromImageModelElement(o4);
                  if (!e6)
                    return;
                  t4.editing.reconvertItem(e6);
                }
              }
            });
          }
        }
        class Rv extends bs {
          static get requires() {
            return [Lv];
          }
          static get pluginName() {
            return "ImageCaptionUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = t4.plugins.get("ImageCaptionUtils"), i3 = t4.t;
            t4.ui.componentFactory.add("toggleImageCaption", (o3) => {
              const r3 = t4.commands.get("toggleImageCaption"), s3 = new kr(o3);
              return s3.set({ icon: Pg2.caption, tooltip: true, isToggleable: true }), s3.bind("isOn", "isEnabled").to(r3, "value", "isEnabled"), s3.bind("label").to(r3, "value", (t5) => i3(t5 ? "Toggle caption off" : "Toggle caption on")), this.listenTo(s3, "execute", () => {
                t4.execute("toggleImageCaption", { focusCaptionOnShow: true });
                const i4 = n3.getCaptionFromModelSelection(t4.model.document.selection);
                if (i4) {
                  const n4 = t4.editing.mapper.toViewElement(i4);
                  e4.scrollToTheSelection(), e4.change((t5) => {
                    t5.addClass("image__caption_highlighted", n4);
                  });
                }
                t4.editing.view.focus();
              }), s3;
            });
          }
        }
        var Ov = n2(2423), Fv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Ov.Z, Fv);
        Ov.Z.locals;
        class Vv extends q2() {
          constructor() {
            super();
            const t4 = new window.FileReader();
            this._reader = t4, this._data = void 0, this.set("loaded", 0), t4.onprogress = (t5) => {
              this.loaded = t5.loaded;
            };
          }
          get error() {
            return this._reader.error;
          }
          get data() {
            return this._data;
          }
          read(t4) {
            const e4 = this._reader;
            return this.total = t4.size, new Promise((n3, i3) => {
              e4.onload = () => {
                const t5 = e4.result;
                this._data = t5, n3(t5);
              }, e4.onerror = () => {
                i3("error");
              }, e4.onabort = () => {
                i3("aborted");
              }, this._reader.readAsDataURL(t4);
            });
          }
          abort() {
            this._reader.abort();
          }
        }
        class jv extends bs {
          constructor() {
            super(...arguments), this.loaders = new Do2(), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null;
          }
          static get pluginName() {
            return "FileRepository";
          }
          static get requires() {
            return [Mg2];
          }
          init() {
            this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t4, e4) => e4 ? t4 / e4 * 100 : 0);
          }
          getLoader(t4) {
            return this._loadersMap.get(t4) || null;
          }
          createLoader(t4) {
            if (!this.createUploadAdapter)
              return _2("filerepository-no-upload-adapter"), null;
            const e4 = new Hv(Promise.resolve(t4), this.createUploadAdapter);
            return this.loaders.add(e4), this._loadersMap.set(t4, e4), t4 instanceof Promise && e4.file.then((t5) => {
              this._loadersMap.set(t5, e4);
            }).catch(() => {
            }), e4.on("change:uploaded", () => {
              let t5 = 0;
              for (const e5 of this.loaders)
                t5 += e5.uploaded;
              this.uploaded = t5;
            }), e4.on("change:uploadTotal", () => {
              let t5 = 0;
              for (const e5 of this.loaders)
                e5.uploadTotal && (t5 += e5.uploadTotal);
              this.uploadTotal = t5;
            }), e4;
          }
          destroyLoader(t4) {
            const e4 = t4 instanceof Hv ? t4 : this.getLoader(t4);
            e4._destroy(), this.loaders.remove(e4), this._loadersMap.forEach((t5, n3) => {
              t5 === e4 && this._loadersMap.delete(n3);
            });
          }
          _updatePendingAction() {
            const t4 = this.editor.plugins.get(Mg2);
            if (this.loaders.length) {
              if (!this._pendingAction) {
                const e4 = this.editor.t, n3 = (t5) => `${e4("Upload in progress")} ${parseInt(t5)}%.`;
                this._pendingAction = t4.add(n3(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n3);
              }
            } else
              t4.remove(this._pendingAction), this._pendingAction = null;
          }
        }
        class Hv extends q2() {
          constructor(t4, e4) {
            super(), this.id = k2(), this._filePromiseWrapper = this._createFilePromiseWrapper(t4), this._adapter = e4(this), this._reader = new Vv(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t5, e5) => e5 ? t5 / e5 * 100 : 0), this.set("uploadResponse", null);
          }
          get file() {
            return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((t4) => this._filePromiseWrapper ? t4 : null) : Promise.resolve(null);
          }
          get data() {
            return this._reader.data;
          }
          read() {
            if ("idle" != this.status)
              throw new C2("filerepository-read-wrong-status", this);
            return this.status = "reading", this.file.then((t4) => this._reader.read(t4)).then((t4) => {
              if ("reading" !== this.status)
                throw this.status;
              return this.status = "idle", t4;
            }).catch((t4) => {
              if ("aborted" === t4)
                throw this.status = "aborted", "aborted";
              throw this.status = "error", this._reader.error ? this._reader.error : t4;
            });
          }
          upload() {
            if ("idle" != this.status)
              throw new C2("filerepository-upload-wrong-status", this);
            return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((t4) => (this.uploadResponse = t4, this.status = "idle", t4)).catch((t4) => {
              if ("aborted" === this.status)
                throw "aborted";
              throw this.status = "error", t4;
            });
          }
          abort() {
            const t4 = this.status;
            this.status = "aborted", this._filePromiseWrapper.isFulfilled ? "reading" == t4 ? this._reader.abort() : "uploading" == t4 && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
            }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
          }
          _destroy() {
            this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
          }
          _createFilePromiseWrapper(t4) {
            const e4 = {};
            return e4.promise = new Promise((n3, i3) => {
              e4.rejecter = i3, e4.isFulfilled = false, t4.then((t5) => {
                e4.isFulfilled = true, n3(t5);
              }).catch((t5) => {
                e4.isFulfilled = true, i3(t5);
              });
            }), e4;
          }
        }
        class Uv extends Ho2 {
          constructor(t4) {
            super(t4), this.buttonView = new kr(t4), this._fileInputView = new Gv(t4), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }), this.buttonView.on("execute", () => {
              this._fileInputView.open();
            });
          }
          focus() {
            this.buttonView.focus();
          }
        }
        class Gv extends Ho2 {
          constructor(t4) {
            super(t4), this.set("acceptedType", void 0), this.set("allowMultipleFiles", false);
            const e4 = this.bindTemplate;
            this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: e4.to("acceptedType"), multiple: e4.to("allowMultipleFiles") }, on: { change: e4.to(() => {
              this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
            }) } });
          }
          open() {
            this.element.click();
          }
        }
        class Wv {
          constructor(t4, e4) {
            this.loader = t4, this.options = e4;
          }
          upload() {
            return this.loader.file.then((t4) => new Promise((e4, n3) => {
              this._initRequest(), this._initListeners(e4, n3, t4), this._sendRequest(t4);
            }));
          }
          abort() {
            this.xhr && this.xhr.abort();
          }
          _initRequest() {
            const t4 = this.xhr = new XMLHttpRequest();
            t4.open("POST", this.options.uploadUrl, true), t4.responseType = "json";
          }
          _initListeners(t4, e4, n3) {
            const i3 = this.xhr, o3 = this.loader, r3 = `Couldn't upload file: ${n3.name}.`;
            i3.addEventListener("error", () => e4(r3)), i3.addEventListener("abort", () => e4()), i3.addEventListener("load", () => {
              const n4 = i3.response;
              if (!n4 || n4.error)
                return e4(n4 && n4.error && n4.error.message ? n4.error.message : r3);
              const o4 = n4.url ? { default: n4.url } : n4.urls;
              t4({ ...n4, urls: o4 });
            }), i3.upload && i3.upload.addEventListener("progress", (t5) => {
              t5.lengthComputable && (o3.uploadTotal = t5.total, o3.uploaded = t5.loaded);
            });
          }
          _sendRequest(t4) {
            const e4 = this.options.headers || {}, n3 = this.options.withCredentials || false;
            for (const t5 of Object.keys(e4))
              this.xhr.setRequestHeader(t5, e4[t5]);
            this.xhr.withCredentials = n3;
            const i3 = new FormData();
            i3.append("upload", t4), this.xhr.send(i3);
          }
        }
        function qv(t4) {
          const e4 = t4.map((t5) => t5.replace("+", "\\+"));
          return new RegExp(`^image\\/(${e4.join("|")})$`);
        }
        function $v(t4) {
          return new Promise((e4, n3) => {
            const i3 = t4.getAttribute("src");
            fetch(i3).then((t5) => t5.blob()).then((t5) => {
              const n4 = Kv(t5, i3), o3 = n4.replace("image/", ""), r3 = new File([t5], `image.${o3}`, { type: n4 });
              e4(r3);
            }).catch((t5) => t5 && "TypeError" === t5.name ? function(t6) {
              return function(t7) {
                return new Promise((e5, n4) => {
                  const i4 = Li2.document.createElement("img");
                  i4.addEventListener("load", () => {
                    const t8 = Li2.document.createElement("canvas");
                    t8.width = i4.width, t8.height = i4.height;
                    t8.getContext("2d").drawImage(i4, 0, 0), t8.toBlob((t9) => t9 ? e5(t9) : n4());
                  }), i4.addEventListener("error", () => n4()), i4.src = t7;
                });
              }(t6).then((e5) => {
                const n4 = Kv(e5, t6), i4 = n4.replace("image/", "");
                return new File([e5], `image.${i4}`, { type: n4 });
              });
            }(i3).then(e4).catch(n3) : n3(t5));
          });
        }
        function Kv(t4, e4) {
          return t4.type ? t4.type : e4.match(/data:(image\/\w+);base64/) ? e4.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
        }
        class Zv extends bs {
          static get pluginName() {
            return "ImageUploadUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t, n3 = (n4) => {
              const i3 = new Uv(n4), o3 = t4.commands.get("uploadImage"), r3 = t4.config.get("image.upload.types"), s3 = qv(r3);
              return i3.set({ acceptedType: r3.map((t5) => `image/${t5}`).join(","), allowMultipleFiles: true }), i3.buttonView.set({ label: e4("Insert image"), icon: Pg2.image, tooltip: true }), i3.buttonView.bind("isEnabled").to(o3), i3.on("done", (e5, n5) => {
                const i4 = Array.from(n5).filter((t5) => s3.test(t5.type));
                i4.length && (t4.execute("uploadImage", { file: i4 }), t4.editing.view.focus());
              }), i3;
            };
            t4.ui.componentFactory.add("uploadImage", n3), t4.ui.componentFactory.add("imageUpload", n3);
          }
        }
        var Yv = n2(2926), Qv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Yv.Z, Qv);
        Yv.Z.locals;
        var Jv = n2(1547), Xv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Jv.Z, Xv);
        Jv.Z.locals;
        var ty = n2(6618), ey = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(ty.Z, ey);
        ty.Z.locals;
        class ny extends bs {
          static get pluginName() {
            return "ImageUploadProgress";
          }
          constructor(t4) {
            super(t4), this.uploadStatusChange = (t5, e4, n3) => {
              const i3 = this.editor, o3 = e4.item, r3 = o3.getAttribute("uploadId");
              if (!n3.consumable.consume(e4.item, t5.name))
                return;
              const s3 = i3.plugins.get("ImageUtils"), a3 = i3.plugins.get(jv), c3 = r3 ? e4.attributeNewValue : null, l3 = this.placeholder, d3 = i3.editing.mapper.toViewElement(o3), h3 = n3.writer;
              if ("reading" == c3)
                return iy(d3, h3), void oy(s3, l3, d3, h3);
              if ("uploading" == c3) {
                const t6 = a3.loaders.get(r3);
                return iy(d3, h3), void (t6 ? (ry(d3, h3), function(t7, e5, n4, i4) {
                  const o4 = function(t8) {
                    const e6 = t8.createUIElement("div", { class: "ck-progress-bar" });
                    return t8.setCustomProperty("progressBar", true, e6), e6;
                  }(e5);
                  e5.insert(e5.createPositionAt(t7, "end"), o4), n4.on("change:uploadedPercent", (t8, e6, n5) => {
                    i4.change((t9) => {
                      t9.setStyle("width", n5 + "%", o4);
                    });
                  });
                }(d3, h3, t6, i3.editing.view), function(t7, e5, n4, i4) {
                  if (i4.data) {
                    const o4 = t7.findViewImgElement(e5);
                    n4.setAttribute("src", i4.data, o4);
                  }
                }(s3, d3, h3, t6)) : oy(s3, l3, d3, h3));
              }
              "complete" == c3 && a3.loaders.get(r3) && function(t6, e5, n4) {
                const i4 = e5.createUIElement("div", { class: "ck-image-upload-complete-icon" });
                e5.insert(e5.createPositionAt(t6, "end"), i4), setTimeout(() => {
                  n4.change((t7) => t7.remove(t7.createRangeOn(i4)));
                }, 3e3);
              }(d3, h3, i3.editing.view), function(t6, e5) {
                ay(t6, e5, "progressBar");
              }(d3, h3), ry(d3, h3), function(t6, e5) {
                e5.removeClass("ck-appear", t6);
              }(d3, h3);
            }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          }
          init() {
            const t4 = this.editor;
            t4.plugins.has("ImageBlockEditing") && t4.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), t4.plugins.has("ImageInlineEditing") && t4.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
          }
        }
        function iy(t4, e4) {
          t4.hasClass("ck-appear") || e4.addClass("ck-appear", t4);
        }
        function oy(t4, e4, n3, i3) {
          n3.hasClass("ck-image-upload-placeholder") || i3.addClass("ck-image-upload-placeholder", n3);
          const o3 = t4.findViewImgElement(n3);
          o3.getAttribute("src") !== e4 && i3.setAttribute("src", e4, o3), sy(n3, "placeholder") || i3.insert(i3.createPositionAfter(o3), function(t5) {
            const e5 = t5.createUIElement("div", { class: "ck-upload-placeholder-loader" });
            return t5.setCustomProperty("placeholder", true, e5), e5;
          }(i3));
        }
        function ry(t4, e4) {
          t4.hasClass("ck-image-upload-placeholder") && e4.removeClass("ck-image-upload-placeholder", t4), ay(t4, e4, "placeholder");
        }
        function sy(t4, e4) {
          for (const n3 of t4.getChildren())
            if (n3.getCustomProperty(e4))
              return n3;
        }
        function ay(t4, e4, n3) {
          const i3 = sy(t4, n3);
          i3 && e4.remove(e4.createRangeOn(i3));
        }
        class cy extends As {
          refresh() {
            const t4 = this.editor, e4 = t4.plugins.get("ImageUtils"), n3 = t4.model.document.selection.getSelectedElement();
            this.isEnabled = e4.isImageAllowed() || e4.isImage(n3);
          }
          execute(t4) {
            const e4 = yo2(t4.file), n3 = this.editor.model.document.selection, i3 = this.editor.plugins.get("ImageUtils"), o3 = Object.fromEntries(n3.getAttributes());
            e4.forEach((t5, e5) => {
              const r3 = n3.getSelectedElement();
              if (e5 && r3 && i3.isImage(r3)) {
                const e6 = this.editor.model.createPositionAfter(r3);
                this._uploadImage(t5, o3, e6);
              } else
                this._uploadImage(t5, o3);
            });
          }
          _uploadImage(t4, e4, n3) {
            const i3 = this.editor, o3 = i3.plugins.get(jv).createLoader(t4), r3 = i3.plugins.get("ImageUtils");
            o3 && r3.insertImage({ ...e4, uploadId: o3.id }, n3);
          }
        }
        class ly extends bs {
          static get requires() {
            return [jv, Hp, Nb2, sv];
          }
          static get pluginName() {
            return "ImageUploadEditing";
          }
          constructor(t4) {
            super(t4), t4.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }), this._uploadImageElements = /* @__PURE__ */ new Map();
          }
          init() {
            const t4 = this.editor, e4 = t4.model.document, n3 = t4.conversion, i3 = t4.plugins.get(jv), o3 = t4.plugins.get("ImageUtils"), r3 = t4.plugins.get("ClipboardPipeline"), s3 = qv(t4.config.get("image.upload.types")), a3 = new cy(t4);
            t4.commands.add("uploadImage", a3), t4.commands.add("imageUpload", a3), n3.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }), this.listenTo(t4.editing.view.document, "clipboardInput", (e5, n4) => {
              if (i4 = n4.dataTransfer, Array.from(i4.types).includes("text/html") && "" !== i4.getData("text/html"))
                return;
              var i4;
              const o4 = Array.from(n4.dataTransfer.files).filter((t5) => !!t5 && s3.test(t5.type));
              o4.length && (e5.stop(), t4.model.change((e6) => {
                n4.targetRanges && e6.setSelection(n4.targetRanges.map((e7) => t4.editing.mapper.toModelRange(e7))), t4.execute("uploadImage", { file: o4 });
              }));
            }), this.listenTo(r3, "inputTransformation", (e5, n4) => {
              const r4 = Array.from(t4.editing.view.createRangeIn(n4.content)).map((t5) => t5.item).filter((t5) => function(t6, e6) {
                return !(!t6.isInlineImageView(e6) || !e6.getAttribute("src") || !e6.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !e6.getAttribute("src").match(/^blob:/g));
              }(o3, t5) && !t5.getAttribute("uploadProcessed")).map((t5) => ({ promise: $v(t5), imageElement: t5 }));
              if (!r4.length)
                return;
              const s4 = new ju(t4.editing.view.document);
              for (const t5 of r4) {
                s4.setAttribute("uploadProcessed", true, t5.imageElement);
                const e6 = i3.createLoader(t5.promise);
                e6 && (s4.setAttribute("src", "", t5.imageElement), s4.setAttribute("uploadId", e6.id, t5.imageElement));
              }
            }), t4.editing.view.document.on("dragover", (t5, e5) => {
              e5.preventDefault();
            }), e4.on("change", () => {
              const n4 = e4.differ.getChanges({ includeChangesInGraveyard: true }).reverse(), o4 = /* @__PURE__ */ new Set();
              for (const e5 of n4)
                if ("insert" == e5.type && "$text" != e5.name) {
                  const n5 = e5.position.nodeAfter, r4 = "$graveyard" == e5.position.root.rootName;
                  for (const e6 of dy(t4, n5)) {
                    const t5 = e6.getAttribute("uploadId");
                    if (!t5)
                      continue;
                    const n6 = i3.loaders.get(t5);
                    n6 && (r4 ? o4.has(t5) || n6.abort() : (o4.add(t5), this._uploadImageElements.set(t5, e6), "idle" == n6.status && this._readAndUpload(n6)));
                  }
                }
            }), this.on("uploadComplete", (t5, { imageElement: e5, data: n4 }) => {
              const i4 = n4.urls ? n4.urls : n4;
              this.editor.model.change((t6) => {
                t6.setAttribute("src", i4.default, e5), this._parseAndSetSrcsetAttributeOnImage(i4, e5, t6), o3.setImageNaturalSizeAttributes(e5);
              });
            }, { priority: "low" });
          }
          afterInit() {
            const t4 = this.editor.model.schema;
            this.editor.plugins.has("ImageBlockEditing") && t4.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }), this.editor.plugins.has("ImageInlineEditing") && t4.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] });
          }
          _readAndUpload(t4) {
            const e4 = this.editor, n3 = e4.model, i3 = e4.locale.t, o3 = e4.plugins.get(jv), r3 = e4.plugins.get(Hp), s3 = e4.plugins.get("ImageUtils"), a3 = this._uploadImageElements;
            return n3.enqueueChange({ isUndoable: false }, (e5) => {
              e5.setAttribute("uploadStatus", "reading", a3.get(t4.id));
            }), t4.read().then(() => {
              const i4 = t4.upload(), o4 = a3.get(t4.id);
              if (c2.isSafari) {
                const t5 = e4.editing.mapper.toViewElement(o4), n4 = s3.findViewImgElement(t5);
                e4.editing.view.once("render", () => {
                  if (!n4.parent)
                    return;
                  const t6 = e4.editing.view.domConverter.mapViewToDom(n4.parent);
                  if (!t6)
                    return;
                  const i5 = t6.style.display;
                  t6.style.display = "none", t6._ckHack = t6.offsetHeight, t6.style.display = i5;
                });
              }
              return n3.enqueueChange({ isUndoable: false }, (t5) => {
                t5.setAttribute("uploadStatus", "uploading", o4);
              }), i4;
            }).then((e5) => {
              n3.enqueueChange({ isUndoable: false }, (n4) => {
                const i4 = a3.get(t4.id);
                n4.setAttribute("uploadStatus", "complete", i4), this.fire("uploadComplete", { data: e5, imageElement: i4 });
              }), l3();
            }).catch((e5) => {
              if ("error" !== t4.status && "aborted" !== t4.status)
                throw e5;
              "error" == t4.status && e5 && r3.showWarning(e5, { title: i3("Upload failed"), namespace: "upload" }), n3.enqueueChange({ isUndoable: false }, (e6) => {
                e6.remove(a3.get(t4.id));
              }), l3();
            });
            function l3() {
              n3.enqueueChange({ isUndoable: false }, (e5) => {
                const n4 = a3.get(t4.id);
                e5.removeAttribute("uploadId", n4), e5.removeAttribute("uploadStatus", n4), a3.delete(t4.id);
              }), o3.destroyLoader(t4);
            }
          }
          _parseAndSetSrcsetAttributeOnImage(t4, e4, n3) {
            let i3 = 0;
            const o3 = Object.keys(t4).filter((t5) => {
              const e5 = parseInt(t5, 10);
              if (!isNaN(e5))
                return i3 = Math.max(i3, e5), true;
            }).map((e5) => `${t4[e5]} ${e5}w`).join(", ");
            if ("" != o3) {
              const t5 = { srcset: o3 };
              e4.hasAttribute("width") || e4.hasAttribute("height") || (t5.width = i3), n3.setAttributes(t5, e4);
            }
          }
        }
        function dy(t4, e4) {
          const n3 = t4.plugins.get("ImageUtils");
          return Array.from(t4.model.createRangeOn(e4)).filter((t5) => n3.isImage(t5.item)).map((t5) => t5.item);
        }
        var hy = n2(8340), uy = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(hy.Z, uy);
        hy.Z.locals;
        var gy = n2(8879), my = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(gy.Z, my);
        gy.Z.locals;
        class py extends As {
          refresh() {
            const t4 = this.editor, e4 = t4.plugins.get("ImageUtils").getClosestSelectedImageElement(t4.model.document.selection);
            this.isEnabled = !!e4, e4 && e4.hasAttribute("resizedWidth") ? this.value = { width: e4.getAttribute("resizedWidth"), height: null } : this.value = null;
          }
          execute(t4) {
            const e4 = this.editor, n3 = e4.model, i3 = e4.plugins.get("ImageUtils"), o3 = i3.getClosestSelectedImageElement(n3.document.selection);
            this.value = { width: t4.width, height: null }, o3 && n3.change((e5) => {
              e5.setAttribute("resizedWidth", t4.width, o3), e5.removeAttribute("resizedHeight", o3), i3.setImageNaturalSizeAttributes(o3);
            });
          }
        }
        class fy extends bs {
          static get requires() {
            return [sv];
          }
          static get pluginName() {
            return "ImageResizeEditing";
          }
          constructor(t4) {
            super(t4), t4.config.define("image", { resizeUnit: "%", resizeOptions: [{ name: "resizeImage:original", value: null, icon: "original" }, { name: "resizeImage:25", value: "25", icon: "small" }, { name: "resizeImage:50", value: "50", icon: "medium" }, { name: "resizeImage:75", value: "75", icon: "large" }] });
          }
          init() {
            const t4 = this.editor, e4 = new py(t4);
            this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline"), t4.commands.add("resizeImage", e4), t4.commands.add("imageResize", e4);
          }
          _registerSchema() {
            this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["resizedWidth", "resizedHeight"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["resizedWidth", "resizedHeight"] });
          }
          _registerConverters(t4) {
            const e4 = this.editor, n3 = e4.plugins.get("ImageUtils");
            e4.conversion.for("downcast").add((e5) => e5.on(`attribute:resizedWidth:${t4}`, (t5, e6, n4) => {
              if (!n4.consumable.consume(e6.item, t5.name))
                return;
              const i3 = n4.writer, o3 = n4.mapper.toViewElement(e6.item);
              null !== e6.attributeNewValue ? (i3.setStyle("width", e6.attributeNewValue, o3), i3.addClass("image_resized", o3)) : (i3.removeStyle("width", o3), i3.removeClass("image_resized", o3));
            })), e4.conversion.for("dataDowncast").attributeToAttribute({ model: { name: t4, key: "resizedHeight" }, view: (t5) => ({ key: "style", value: { height: t5 } }) }), e4.conversion.for("editingDowncast").add((e5) => e5.on(`attribute:resizedHeight:${t4}`, (e6, i3, o3) => {
              if (!o3.consumable.consume(i3.item, e6.name))
                return;
              const r3 = o3.writer, s3 = o3.mapper.toViewElement(i3.item), a3 = "imageInline" === t4 ? n3.findViewImgElement(s3) : s3;
              null !== i3.attributeNewValue ? r3.setStyle("height", i3.attributeNewValue, a3) : r3.removeStyle("height", a3);
            })), e4.conversion.for("upcast").attributeToAttribute({ view: { name: "imageBlock" === t4 ? "figure" : "img", styles: { width: /.+/ } }, model: { key: "resizedWidth", value: (t5) => ov(t5) ? null : t5.getStyle("width") } }), e4.conversion.for("upcast").attributeToAttribute({ view: { name: "imageBlock" === t4 ? "figure" : "img", styles: { height: /.+/ } }, model: { key: "resizedHeight", value: (t5) => ov(t5) ? null : t5.getStyle("height") } });
          }
        }
        const ky = { small: Pg2.objectSizeSmall, medium: Pg2.objectSizeMedium, large: Pg2.objectSizeLarge, original: Pg2.objectSizeFull };
        class by extends bs {
          static get requires() {
            return [fy];
          }
          static get pluginName() {
            return "ImageResizeButtons";
          }
          constructor(t4) {
            super(t4), this._resizeUnit = t4.config.get("image.resizeUnit");
          }
          init() {
            const t4 = this.editor, e4 = t4.config.get("image.resizeOptions"), n3 = t4.commands.get("resizeImage");
            this.bind("isEnabled").to(n3);
            for (const t5 of e4)
              this._registerImageResizeButton(t5);
            this._registerImageResizeDropdown(e4);
          }
          _registerImageResizeButton(t4) {
            const e4 = this.editor, { name: n3, value: i3, icon: o3 } = t4, r3 = i3 ? i3 + this._resizeUnit : null;
            e4.ui.componentFactory.add(n3, (n4) => {
              const i4 = new kr(n4), s3 = e4.commands.get("resizeImage"), a3 = this._getOptionLabelValue(t4, true);
              if (!ky[o3])
                throw new C2("imageresizebuttons-missing-icon", e4, t4);
              return i4.set({ label: a3, icon: ky[o3], tooltip: a3, isToggleable: true }), i4.bind("isEnabled").to(this), i4.bind("isOn").to(s3, "value", wy(r3)), this.listenTo(i4, "execute", () => {
                e4.execute("resizeImage", { width: r3 });
              }), i4;
            });
          }
          _registerImageResizeDropdown(t4) {
            const e4 = this.editor, n3 = e4.t, i3 = t4.find((t5) => !t5.value), o3 = (o4) => {
              const r3 = e4.commands.get("resizeImage"), s3 = om(o4, us), a3 = s3.buttonView, c3 = n3("Resize image");
              return a3.set({ tooltip: c3, commandValue: i3.value, icon: ky.medium, isToggleable: true, label: this._getOptionLabelValue(i3), withText: true, class: "ck-resize-image-button", ariaLabel: c3, ariaLabelledBy: void 0 }), a3.bind("label").to(r3, "value", (t5) => t5 && t5.width ? t5.width : this._getOptionLabelValue(i3)), s3.bind("isEnabled").to(this), am(s3, () => this._getResizeDropdownListItemDefinitions(t4, r3), { ariaLabel: n3("Image resize list"), role: "menu" }), this.listenTo(s3, "execute", (t5) => {
                e4.execute(t5.source.commandName, { width: t5.source.commandValue }), e4.editing.view.focus();
              }), s3;
            };
            e4.ui.componentFactory.add("resizeImage", o3), e4.ui.componentFactory.add("imageResize", o3);
          }
          _getOptionLabelValue(t4, e4 = false) {
            const n3 = this.editor.t;
            return t4.label ? t4.label : e4 ? t4.value ? n3("Resize image to %0", t4.value + this._resizeUnit) : n3("Resize image to the original size") : t4.value ? t4.value + this._resizeUnit : n3("Original");
          }
          _getResizeDropdownListItemDefinitions(t4, e4) {
            const n3 = new Do2();
            return t4.map((t5) => {
              const i3 = t5.value ? t5.value + this._resizeUnit : null, o3 = { type: "button", model: new Up({ commandName: "resizeImage", commandValue: i3, label: this._getOptionLabelValue(t5), role: "menuitemradio", withText: true, icon: null }) };
              o3.model.bind("isOn").to(e4, "value", wy(i3)), n3.add(o3);
            }), n3;
          }
        }
        function wy(t4) {
          return (e4) => null === t4 && e4 === t4 || null !== e4 && e4.width === t4;
        }
        const Ay = "image_resized";
        class Cy extends bs {
          static get requires() {
            return [Aw, sv];
          }
          static get pluginName() {
            return "ImageResizeHandles";
          }
          init() {
            const t4 = this.editor.commands.get("resizeImage");
            this.bind("isEnabled").to(t4), this._setupResizerCreator();
          }
          _setupResizerCreator() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = t4.plugins.get("ImageUtils");
            e4.addObserver(wv), this.listenTo(e4.document, "imageLoaded", (i3, o3) => {
              if (!o3.target.matches("figure.image.ck-widget > img,figure.image.ck-widget > picture > img,figure.image.ck-widget > a > img,figure.image.ck-widget > a > picture > img,span.image-inline.ck-widget > img,span.image-inline.ck-widget > picture > img"))
                return;
              const r3 = t4.editing.view.domConverter, s3 = r3.domToView(o3.target), a3 = n3.getImageWidgetFromImageView(s3);
              let c3 = this.editor.plugins.get(Aw).getResizerByViewElement(a3);
              if (c3)
                return void c3.redraw();
              const l3 = t4.editing.mapper, d3 = l3.toModelElement(a3);
              c3 = t4.plugins.get(Aw).attachTo({ unit: t4.config.get("image.resizeUnit"), modelElement: d3, viewElement: a3, editor: t4, getHandleHost: (t5) => t5.querySelector("img"), getResizeHost: () => r3.mapViewToDom(l3.toViewElement(d3.parent)), isCentered() {
                const t5 = d3.getAttribute("imageStyle");
                return !t5 || "block" == t5 || "alignCenter" == t5;
              }, onCommit(n4) {
                e4.change((t5) => {
                  t5.removeClass(Ay, a3);
                }), t4.execute("resizeImage", { width: n4 });
              } }), c3.on("updateSize", () => {
                a3.hasClass(Ay) || e4.change((t6) => {
                  t6.addClass(Ay, a3);
                });
                const t5 = "imageInline" === d3.name ? s3 : a3;
                t5.getStyle("height") && e4.change((e5) => {
                  e5.removeStyle("height", t5);
                });
              }), c3.bind("isEnabled").to(this);
            });
          }
        }
        var _y = n2(2400), vy = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(_y.Z, vy);
        _y.Z.locals;
        class yy extends As {
          constructor(t4, e4) {
            super(t4), this._defaultStyles = { imageBlock: false, imageInline: false }, this._styles = new Map(e4.map((t5) => {
              if (t5.isDefault)
                for (const e5 of t5.modelElements)
                  this._defaultStyles[e5] = t5.name;
              return [t5.name, t5];
            }));
          }
          refresh() {
            const t4 = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
            this.isEnabled = !!t4, this.isEnabled ? t4.hasAttribute("imageStyle") ? this.value = t4.getAttribute("imageStyle") : this.value = this._defaultStyles[t4.name] : this.value = false;
          }
          execute(t4 = {}) {
            const e4 = this.editor, n3 = e4.model, i3 = e4.plugins.get("ImageUtils");
            n3.change((e5) => {
              const o3 = t4.value, { setImageSizes: r3 = true } = t4;
              let s3 = i3.getClosestSelectedImageElement(n3.document.selection);
              o3 && this.shouldConvertImageType(o3, s3) && (this.editor.execute(i3.isBlockImage(s3) ? "imageTypeInline" : "imageTypeBlock", { setImageSizes: r3 }), s3 = i3.getClosestSelectedImageElement(n3.document.selection)), !o3 || this._styles.get(o3).isDefault ? e5.removeAttribute("imageStyle", s3) : e5.setAttribute("imageStyle", o3, s3), r3 && i3.setImageNaturalSizeAttributes(s3);
            });
          }
          shouldConvertImageType(t4, e4) {
            return !this._styles.get(t4).modelElements.includes(e4.name);
          }
        }
        const { objectFullWidth: xy, objectInline: Ey, objectLeft: Dy, objectRight: Sy, objectCenter: Ty, objectBlockLeft: Iy, objectBlockRight: By } = Pg2, My = { get inline() {
          return { name: "inline", title: "In line", icon: Ey, modelElements: ["imageInline"], isDefault: true };
        }, get alignLeft() {
          return { name: "alignLeft", title: "Left aligned image", icon: Dy, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" };
        }, get alignBlockLeft() {
          return { name: "alignBlockLeft", title: "Left aligned image", icon: Iy, modelElements: ["imageBlock"], className: "image-style-block-align-left" };
        }, get alignCenter() {
          return { name: "alignCenter", title: "Centered image", icon: Ty, modelElements: ["imageBlock"], className: "image-style-align-center" };
        }, get alignRight() {
          return { name: "alignRight", title: "Right aligned image", icon: Sy, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" };
        }, get alignBlockRight() {
          return { name: "alignBlockRight", title: "Right aligned image", icon: By, modelElements: ["imageBlock"], className: "image-style-block-align-right" };
        }, get block() {
          return { name: "block", title: "Centered image", icon: Ty, modelElements: ["imageBlock"], isDefault: true };
        }, get side() {
          return { name: "side", title: "Side image", icon: Sy, modelElements: ["imageBlock"], className: "image-style-side" };
        } }, Ny = { full: xy, left: Iy, right: By, center: Ty, inlineLeft: Dy, inlineRight: Sy, inline: Ey }, Ly = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }];
        function zy(t4) {
          _2("image-style-configuration-definition-invalid", t4);
        }
        const Py = { normalizeStyles: function(t4) {
          const e4 = (t4.configuredStyles.options || []).map((t5) => function(t6) {
            t6 = "string" == typeof t6 ? My[t6] ? { ...My[t6] } : { name: t6 } : function(t7, e5) {
              const n3 = { ...e5 };
              for (const i3 in t7)
                Object.prototype.hasOwnProperty.call(e5, i3) || (n3[i3] = t7[i3]);
              return n3;
            }(My[t6.name], t6);
            "string" == typeof t6.icon && (t6.icon = Ny[t6.icon] || t6.icon);
            return t6;
          }(t5)).filter((e5) => function(t5, { isBlockPluginLoaded: e6, isInlinePluginLoaded: n3 }) {
            const { modelElements: i3, name: o3 } = t5;
            if (!(i3 && i3.length && o3))
              return zy({ style: t5 }), false;
            {
              const o4 = [e6 ? "imageBlock" : null, n3 ? "imageInline" : null];
              if (!i3.some((t6) => o4.includes(t6)))
                return _2("image-style-missing-dependency", { style: t5, missingPlugins: i3.map((t6) => "imageBlock" === t6 ? "ImageBlockEditing" : "ImageInlineEditing") }), false;
            }
            return true;
          }(e5, t4));
          return e4;
        }, getDefaultStylesConfiguration: function(t4, e4) {
          return t4 && e4 ? { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } : t4 ? { options: ["block", "side"] } : e4 ? { options: ["inline", "alignLeft", "alignRight"] } : {};
        }, getDefaultDropdownDefinitions: function(t4) {
          return t4.has("ImageBlockEditing") && t4.has("ImageInlineEditing") ? [...Ly] : [];
        }, warnInvalidStyle: zy, DEFAULT_OPTIONS: My, DEFAULT_ICONS: Ny, DEFAULT_DROPDOWN_DEFINITIONS: Ly };
        function Ry(t4, e4) {
          for (const n3 of e4)
            if (n3.name === t4)
              return n3;
        }
        class Oy extends bs {
          static get pluginName() {
            return "ImageStyleEditing";
          }
          static get requires() {
            return [sv];
          }
          init() {
            const { normalizeStyles: t4, getDefaultStylesConfiguration: e4 } = Py, n3 = this.editor, i3 = n3.plugins.has("ImageBlockEditing"), o3 = n3.plugins.has("ImageInlineEditing");
            n3.config.define("image.styles", e4(i3, o3)), this.normalizedStyles = t4({ configuredStyles: n3.config.get("image.styles"), isBlockPluginLoaded: i3, isInlinePluginLoaded: o3 }), this._setupConversion(i3, o3), this._setupPostFixer(), n3.commands.add("imageStyle", new yy(n3, this.normalizedStyles));
          }
          _setupConversion(t4, e4) {
            const n3 = this.editor, i3 = n3.model.schema, o3 = (r3 = this.normalizedStyles, (t5, e5, n4) => {
              if (!n4.consumable.consume(e5.item, t5.name))
                return;
              const i4 = Ry(e5.attributeNewValue, r3), o4 = Ry(e5.attributeOldValue, r3), s4 = n4.mapper.toViewElement(e5.item), a3 = n4.writer;
              o4 && a3.removeClass(o4.className, s4), i4 && a3.addClass(i4.className, s4);
            });
            var r3;
            const s3 = function(t5) {
              const e5 = { imageInline: t5.filter((t6) => !t6.isDefault && t6.modelElements.includes("imageInline")), imageBlock: t5.filter((t6) => !t6.isDefault && t6.modelElements.includes("imageBlock")) };
              return (t6, n4, i4) => {
                if (!n4.modelRange)
                  return;
                const o4 = n4.viewItem, r4 = So2(n4.modelRange.getItems());
                if (r4 && i4.schema.checkAttribute(r4, "imageStyle"))
                  for (const t7 of e5[r4.name])
                    i4.consumable.consume(o4, { classes: t7.className }) && i4.writer.setAttribute("imageStyle", t7.name, r4);
              };
            }(this.normalizedStyles);
            n3.editing.downcastDispatcher.on("attribute:imageStyle", o3), n3.data.downcastDispatcher.on("attribute:imageStyle", o3), t4 && (i3.extend("imageBlock", { allowAttributes: "imageStyle" }), n3.data.upcastDispatcher.on("element:figure", s3, { priority: "low" })), e4 && (i3.extend("imageInline", { allowAttributes: "imageStyle" }), n3.data.upcastDispatcher.on("element:img", s3, { priority: "low" }));
          }
          _setupPostFixer() {
            const t4 = this.editor, e4 = t4.model.document, n3 = t4.plugins.get(sv), i3 = new Map(this.normalizedStyles.map((t5) => [t5.name, t5]));
            e4.registerPostFixer((t5) => {
              let o3 = false;
              for (const r3 of e4.differ.getChanges())
                if ("insert" == r3.type || "attribute" == r3.type && "imageStyle" == r3.attributeKey) {
                  let e5 = "insert" == r3.type ? r3.position.nodeAfter : r3.range.start.nodeAfter;
                  if (e5 && e5.is("element", "paragraph") && e5.childCount > 0 && (e5 = e5.getChild(0)), !n3.isImage(e5))
                    continue;
                  const s3 = e5.getAttribute("imageStyle");
                  if (!s3)
                    continue;
                  const a3 = i3.get(s3);
                  a3 && a3.modelElements.includes(e5.name) || (t5.removeAttribute("imageStyle", e5), o3 = true);
                }
              return o3;
            });
          }
        }
        var Fy = n2(3534), Vy = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Fy.Z, Vy);
        Fy.Z.locals;
        class jy extends bs {
          static get requires() {
            return [Oy];
          }
          static get pluginName() {
            return "ImageStyleUI";
          }
          get localizedDefaultStylesTitles() {
            const t4 = this.editor.t;
            return { "Wrap text": t4("Wrap text"), "Break text": t4("Break text"), "In line": t4("In line"), "Full size image": t4("Full size image"), "Side image": t4("Side image"), "Left aligned image": t4("Left aligned image"), "Centered image": t4("Centered image"), "Right aligned image": t4("Right aligned image") };
          }
          init() {
            const t4 = this.editor.plugins, e4 = this.editor.config.get("image.toolbar") || [], n3 = Hy(t4.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
            for (const t5 of n3)
              this._createButton(t5);
            const i3 = Hy([...e4.filter(F2), ...Py.getDefaultDropdownDefinitions(t4)], this.localizedDefaultStylesTitles);
            for (const t5 of i3)
              this._createDropdown(t5, n3);
          }
          _createDropdown(t4, e4) {
            const n3 = this.editor.ui.componentFactory;
            n3.add(t4.name, (i3) => {
              let o3;
              const { defaultItem: r3, items: s3, title: a3 } = t4, c3 = s3.filter((t5) => e4.find(({ name: e5 }) => Uy(e5) === t5)).map((t5) => {
                const e5 = n3.create(t5);
                return t5 === r3 && (o3 = e5), e5;
              });
              s3.length !== c3.length && Py.warnInvalidStyle({ dropdown: t4 });
              const l3 = om(i3, Xg2), d3 = l3.buttonView, h3 = d3.arrowView;
              return rm(l3, c3, { enableActiveItemFocusOnDropdownOpen: true }), d3.set({ label: Gy(a3, o3.label), class: null, tooltip: true }), h3.unbind("label"), h3.set({ label: a3 }), d3.bind("icon").toMany(c3, "isOn", (...t5) => {
                const e5 = t5.findIndex(Aa2);
                return e5 < 0 ? o3.icon : c3[e5].icon;
              }), d3.bind("label").toMany(c3, "isOn", (...t5) => {
                const e5 = t5.findIndex(Aa2);
                return Gy(a3, e5 < 0 ? o3.label : c3[e5].label);
              }), d3.bind("isOn").toMany(c3, "isOn", (...t5) => t5.some(Aa2)), d3.bind("class").toMany(c3, "isOn", (...t5) => t5.some(Aa2) ? "ck-splitbutton_flatten" : void 0), d3.on("execute", () => {
                c3.some(({ isOn: t5 }) => t5) ? l3.isOpen = !l3.isOpen : o3.fire("execute");
              }), l3.bind("isEnabled").toMany(c3, "isEnabled", (...t5) => t5.some(Aa2)), this.listenTo(l3, "execute", () => {
                this.editor.editing.view.focus();
              }), l3;
            });
          }
          _createButton(t4) {
            const e4 = t4.name;
            this.editor.ui.componentFactory.add(Uy(e4), (n3) => {
              const i3 = this.editor.commands.get("imageStyle"), o3 = new kr(n3);
              return o3.set({ label: t4.title, icon: t4.icon, tooltip: true, isToggleable: true }), o3.bind("isEnabled").to(i3, "isEnabled"), o3.bind("isOn").to(i3, "value", (t5) => t5 === e4), o3.on("execute", this._executeCommand.bind(this, e4)), o3;
            });
          }
          _executeCommand(t4) {
            this.editor.execute("imageStyle", { value: t4 }), this.editor.editing.view.focus();
          }
        }
        function Hy(t4, e4) {
          for (const n3 of t4)
            e4[n3.title] && (n3.title = e4[n3.title]);
          return t4;
        }
        function Uy(t4) {
          return `imageStyle:${t4}`;
        }
        function Gy(t4, e4) {
          return (t4 ? t4 + ": " : "") + e4;
        }
        class Wy extends bs {
          static get pluginName() {
            return "IndentEditing";
          }
          init() {
            const t4 = this.editor;
            t4.commands.add("indent", new _s(t4)), t4.commands.add("outdent", new _s(t4));
          }
        }
        const qy = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', $y = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
        class Ky extends bs {
          static get pluginName() {
            return "IndentUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.locale, n3 = t4.t, i3 = "ltr" == e4.uiLanguageDirection ? qy : $y, o3 = "ltr" == e4.uiLanguageDirection ? $y : qy;
            this._defineButton("indent", n3("Increase indent"), i3), this._defineButton("outdent", n3("Decrease indent"), o3);
          }
          _defineButton(t4, e4, n3) {
            const i3 = this.editor;
            i3.ui.componentFactory.add(t4, (o3) => {
              const r3 = i3.commands.get(t4), s3 = new kr(o3);
              return s3.set({ label: e4, icon: n3, tooltip: true }), s3.bind("isEnabled").to(r3, "isEnabled"), this.listenTo(s3, "execute", () => {
                i3.execute(t4), i3.editing.view.focus();
              }), s3;
            });
          }
        }
        class Zy extends As {
          constructor(t4, e4) {
            super(t4), this._indentBehavior = e4;
          }
          refresh() {
            const t4 = So2(this.editor.model.document.selection.getSelectedBlocks());
            t4 && this._isIndentationChangeAllowed(t4) ? this.isEnabled = this._indentBehavior.checkEnabled(t4.getAttribute("blockIndent")) : this.isEnabled = false;
          }
          execute() {
            const t4 = this.editor.model, e4 = this._getBlocksToChange();
            t4.change((t5) => {
              for (const n3 of e4) {
                const e5 = n3.getAttribute("blockIndent"), i3 = this._indentBehavior.getNextIndent(e5);
                i3 ? t5.setAttribute("blockIndent", i3, n3) : t5.removeAttribute("blockIndent", n3);
              }
            });
          }
          _getBlocksToChange() {
            const t4 = this.editor.model.document.selection;
            return Array.from(t4.getSelectedBlocks()).filter((t5) => this._isIndentationChangeAllowed(t5));
          }
          _isIndentationChangeAllowed(t4) {
            const e4 = this.editor;
            if (!e4.model.schema.checkAttribute(t4, "blockIndent"))
              return false;
            if (!e4.plugins.has("DocumentListUtils"))
              return true;
            if (!this._indentBehavior.isForward)
              return true;
            return !e4.plugins.get("DocumentListUtils").isListItemBlock(t4);
          }
        }
        class Yy {
          constructor(t4) {
            this.isForward = "forward" === t4.direction, this.offset = t4.offset, this.unit = t4.unit;
          }
          checkEnabled(t4) {
            const e4 = parseFloat(t4 || "0");
            return this.isForward || e4 > 0;
          }
          getNextIndent(t4) {
            const e4 = parseFloat(t4 || "0");
            if (!(!t4 || t4.endsWith(this.unit)))
              return this.isForward ? this.offset + this.unit : void 0;
            const n3 = e4 + (this.isForward ? this.offset : -this.offset);
            return n3 > 0 ? n3 + this.unit : void 0;
          }
        }
        class Qy {
          constructor(t4) {
            this.isForward = "forward" === t4.direction, this.classes = t4.classes;
          }
          checkEnabled(t4) {
            const e4 = this.classes.indexOf(t4);
            return this.isForward ? e4 < this.classes.length - 1 : e4 >= 0;
          }
          getNextIndent(t4) {
            const e4 = this.classes.indexOf(t4), n3 = this.isForward ? 1 : -1;
            return this.classes[e4 + n3];
          }
        }
        const Jy = ["paragraph", "heading1", "heading2", "heading3", "heading4", "heading5", "heading6"];
        function Xy(t4, e4) {
          return `${t4}:${e4 = e4 || vo2(t4)}`;
        }
        class tx extends As {
          refresh() {
            const t4 = this.editor.model, e4 = t4.document;
            this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = t4.schema.checkAttributeInSelection(e4.selection, "language");
          }
          execute({ languageCode: t4, textDirection: e4 } = {}) {
            const n3 = this.editor.model, i3 = n3.document.selection, o3 = !!t4 && Xy(t4, e4);
            n3.change((t5) => {
              if (i3.isCollapsed)
                o3 ? t5.setSelectionAttribute("language", o3) : t5.removeSelectionAttribute("language");
              else {
                const e5 = n3.schema.getValidRanges(i3.getRanges(), "language");
                for (const n4 of e5)
                  o3 ? t5.setAttribute("language", o3, n4) : t5.removeAttribute("language", n4);
              }
            });
          }
          _getValueFromFirstAllowedNode() {
            const t4 = this.editor.model, e4 = t4.schema, n3 = t4.document.selection;
            if (n3.isCollapsed)
              return n3.getAttribute("language") || false;
            for (const t5 of n3.getRanges())
              for (const n4 of t5.getItems())
                if (e4.checkAttribute(n4, "language"))
                  return n4.getAttribute("language") || false;
            return false;
          }
        }
        class ex extends bs {
          static get pluginName() {
            return "TextPartLanguageEditing";
          }
          constructor(t4) {
            super(t4), t4.config.define("language", { textPartLanguage: [{ title: "Arabic", languageCode: "ar" }, { title: "French", languageCode: "fr" }, { title: "Spanish", languageCode: "es" }] });
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: "language" }), t4.model.schema.setAttributeProperties("language", { copyOnEnter: true }), this._defineConverters(), t4.commands.add("textPartLanguage", new tx(t4));
          }
          _defineConverters() {
            const t4 = this.editor.conversion;
            t4.for("upcast").elementToAttribute({ model: { key: "language", value: (t5) => Xy(t5.getAttribute("lang"), t5.getAttribute("dir")) }, view: { name: "span", attributes: { lang: /[\s\S]+/ } } }), t4.for("downcast").attributeToElement({ model: "language", view: (t5, { writer: e4 }, n3) => {
              if (!t5)
                return;
              if (!n3.item.is("$textProxy") && !n3.item.is("documentSelection"))
                return;
              const { languageCode: i3, textDirection: o3 } = function(t6) {
                const [e5, n4] = t6.split(":");
                return { languageCode: e5, textDirection: n4 };
              }(t5);
              return e4.createAttributeElement("span", { lang: i3, dir: o3 });
            } });
          }
        }
        class nx extends bs {
          static get pluginName() {
            return "TextPartLanguageUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.config.get("language.textPartLanguage"), i3 = e4("Choose language"), o3 = e4("Remove language"), r3 = e4("Language");
            t4.ui.componentFactory.add("textPartLanguage", (e5) => {
              const s3 = new Do2(), a3 = {}, c3 = t4.commands.get("textPartLanguage");
              s3.add({ type: "button", model: new Up({ label: o3, languageCode: false, withText: true }) }), s3.add({ type: "separator" });
              for (const t5 of n3) {
                const e6 = { type: "button", model: new Up({ label: t5.title, languageCode: t5.languageCode, role: "menuitemradio", textDirection: t5.textDirection, withText: true }) }, n4 = Xy(t5.languageCode, t5.textDirection);
                e6.model.bind("isOn").to(c3, "value", (t6) => t6 === n4), s3.add(e6), a3[n4] = t5.title;
              }
              const l3 = om(e5);
              return am(l3, s3, { ariaLabel: r3, role: "menu" }), l3.buttonView.set({ ariaLabel: r3, ariaLabelledBy: void 0, isOn: false, withText: true, tooltip: r3 }), l3.extendTemplate({ attributes: { class: ["ck-text-fragment-language-dropdown"] } }), l3.bind("isEnabled").to(c3, "isEnabled"), l3.buttonView.bind("label").to(c3, "value", (t5) => t5 && a3[t5] || i3), this.listenTo(l3, "execute", (e6) => {
                c3.execute({ languageCode: e6.source.languageCode, textDirection: e6.source.textDirection }), t4.editing.view.focus();
              }), l3;
            });
          }
        }
        class ix {
          constructor() {
            this._definitions = /* @__PURE__ */ new Set();
          }
          get length() {
            return this._definitions.size;
          }
          add(t4) {
            Array.isArray(t4) ? t4.forEach((t5) => this._definitions.add(t5)) : this._definitions.add(t4);
          }
          getDispatcher() {
            return (t4) => {
              t4.on("attribute:linkHref", (t5, e4, n3) => {
                if (!n3.consumable.test(e4.item, "attribute:linkHref"))
                  return;
                if (!e4.item.is("selection") && !n3.schema.isInline(e4.item))
                  return;
                const i3 = n3.writer, o3 = i3.document.selection;
                for (const t6 of this._definitions) {
                  const r3 = i3.createAttributeElement("a", t6.attributes, { priority: 5 });
                  t6.classes && i3.addClass(t6.classes, r3);
                  for (const e5 in t6.styles)
                    i3.setStyle(e5, t6.styles[e5], r3);
                  i3.setCustomProperty("link", true, r3), t6.callback(e4.attributeNewValue) ? e4.item.is("selection") ? i3.wrap(o3.getFirstRange(), r3) : i3.wrap(n3.mapper.toViewRange(e4.range), r3) : i3.unwrap(n3.mapper.toViewRange(e4.range), r3);
                }
              }, { priority: "high" });
            };
          }
          getDispatcherForLinkedImage() {
            return (t4) => {
              t4.on("attribute:linkHref:imageBlock", (t5, e4, { writer: n3, mapper: i3 }) => {
                const o3 = i3.toViewElement(e4.item), r3 = Array.from(o3.getChildren()).find((t6) => t6.is("element", "a"));
                for (const t6 of this._definitions) {
                  const i4 = Bo2(t6.attributes);
                  if (t6.callback(e4.attributeNewValue)) {
                    for (const [t7, e5] of i4)
                      "class" === t7 ? n3.addClass(e5, r3) : n3.setAttribute(t7, e5, r3);
                    t6.classes && n3.addClass(t6.classes, r3);
                    for (const e5 in t6.styles)
                      n3.setStyle(e5, t6.styles[e5], r3);
                  } else {
                    for (const [t7, e5] of i4)
                      "class" === t7 ? n3.removeClass(e5, r3) : n3.removeAttribute(t7, r3);
                    t6.classes && n3.removeClass(t6.classes, r3);
                    for (const e5 in t6.styles)
                      n3.removeStyle(e5, r3);
                  }
                }
              });
            };
          }
        }
        const ox = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, rx = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i, sx = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, ax = /^((\w+:(\/{2,})?)|(\W))/i, cx = "Ctrl+K";
        function lx(t4, { writer: e4 }) {
          const n3 = e4.createAttributeElement("a", { href: t4 }, { priority: 5 });
          return e4.setCustomProperty("link", true, n3), n3;
        }
        function dx(t4) {
          const e4 = String(t4);
          return function(t5) {
            const e5 = t5.replace(ox, "");
            return !!e5.match(rx);
          }(e4) ? e4 : "#";
        }
        function hx(t4, e4) {
          return !!t4 && e4.checkAttribute(t4.name, "linkHref");
        }
        function ux(t4, e4) {
          const n3 = (i3 = t4, sx.test(i3) ? "mailto:" : e4);
          var i3;
          const o3 = !!n3 && !gx(t4);
          return t4 && o3 ? n3 + t4 : t4;
        }
        function gx(t4) {
          return ax.test(t4);
        }
        function mx(t4) {
          window.open(t4, "_blank", "noopener");
        }
        class px extends As {
          constructor() {
            super(...arguments), this.manualDecorators = new Do2(), this.automaticDecorators = new ix();
          }
          restoreManualDecoratorStates() {
            for (const t4 of this.manualDecorators)
              t4.value = this._getDecoratorStateFromModel(t4.id);
          }
          refresh() {
            const t4 = this.editor.model, e4 = t4.document.selection, n3 = e4.getSelectedElement() || So2(e4.getSelectedBlocks());
            hx(n3, t4.schema) ? (this.value = n3.getAttribute("linkHref"), this.isEnabled = t4.schema.checkAttribute(n3, "linkHref")) : (this.value = e4.getAttribute("linkHref"), this.isEnabled = t4.schema.checkAttributeInSelection(e4, "linkHref"));
            for (const t5 of this.manualDecorators)
              t5.value = this._getDecoratorStateFromModel(t5.id);
          }
          execute(t4, e4 = {}) {
            const n3 = this.editor.model, i3 = n3.document.selection, o3 = [], r3 = [];
            for (const t5 in e4)
              e4[t5] ? o3.push(t5) : r3.push(t5);
            n3.change((e5) => {
              if (i3.isCollapsed) {
                const s3 = i3.getFirstPosition();
                if (i3.hasAttribute("linkHref")) {
                  const a3 = fx(i3);
                  let c3 = kk2(s3, "linkHref", i3.getAttribute("linkHref"), n3);
                  i3.getAttribute("linkHref") === a3 && (c3 = this._updateLinkContent(n3, e5, c3, t4)), e5.setAttribute("linkHref", t4, c3), o3.forEach((t5) => {
                    e5.setAttribute(t5, true, c3);
                  }), r3.forEach((t5) => {
                    e5.removeAttribute(t5, c3);
                  }), e5.setSelection(e5.createPositionAfter(c3.end.nodeBefore));
                } else if ("" !== t4) {
                  const r4 = Bo2(i3.getAttributes());
                  r4.set("linkHref", t4), o3.forEach((t5) => {
                    r4.set(t5, true);
                  });
                  const { end: a3 } = n3.insertContent(e5.createText(t4, r4), s3);
                  e5.setSelection(a3);
                }
                ["linkHref", ...o3, ...r3].forEach((t5) => {
                  e5.removeSelectionAttribute(t5);
                });
              } else {
                const s3 = n3.schema.getValidRanges(i3.getRanges(), "linkHref"), a3 = [];
                for (const t5 of i3.getSelectedBlocks())
                  n3.schema.checkAttribute(t5, "linkHref") && a3.push(e5.createRangeOn(t5));
                const c3 = a3.slice();
                for (const t5 of s3)
                  this._isRangeToUpdate(t5, a3) && c3.push(t5);
                for (const s4 of c3) {
                  let a4 = s4;
                  if (1 === c3.length) {
                    const o4 = fx(i3);
                    i3.getAttribute("linkHref") === o4 && (a4 = this._updateLinkContent(n3, e5, s4, t4), e5.setSelection(e5.createSelection(a4)));
                  }
                  e5.setAttribute("linkHref", t4, a4), o3.forEach((t5) => {
                    e5.setAttribute(t5, true, a4);
                  }), r3.forEach((t5) => {
                    e5.removeAttribute(t5, a4);
                  });
                }
              }
            });
          }
          _getDecoratorStateFromModel(t4) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = n3.getSelectedElement();
            return hx(i3, e4.schema) ? i3.getAttribute(t4) : n3.getAttribute(t4);
          }
          _isRangeToUpdate(t4, e4) {
            for (const n3 of e4)
              if (n3.containsRange(t4))
                return false;
            return true;
          }
          _updateLinkContent(t4, e4, n3, i3) {
            const o3 = e4.createText(i3, { linkHref: i3 });
            return t4.insertContent(o3, n3);
          }
        }
        function fx(t4) {
          if (t4.isCollapsed) {
            const e4 = t4.getFirstPosition();
            return e4.textNode && e4.textNode.data;
          }
          {
            const e4 = Array.from(t4.getFirstRange().getItems());
            if (e4.length > 1)
              return null;
            const n3 = e4[0];
            return n3.is("$text") || n3.is("$textProxy") ? n3.data : null;
          }
        }
        class kx extends As {
          refresh() {
            const t4 = this.editor.model, e4 = t4.document.selection, n3 = e4.getSelectedElement();
            hx(n3, t4.schema) ? this.isEnabled = t4.schema.checkAttribute(n3, "linkHref") : this.isEnabled = t4.schema.checkAttributeInSelection(e4, "linkHref");
          }
          execute() {
            const t4 = this.editor, e4 = this.editor.model, n3 = e4.document.selection, i3 = t4.commands.get("link");
            e4.change((t5) => {
              const o3 = n3.isCollapsed ? [kk2(n3.getFirstPosition(), "linkHref", n3.getAttribute("linkHref"), e4)] : e4.schema.getValidRanges(n3.getRanges(), "linkHref");
              for (const e5 of o3)
                if (t5.removeAttribute("linkHref", e5), i3)
                  for (const n4 of i3.manualDecorators)
                    t5.removeAttribute(n4.id, e5);
            });
          }
        }
        class bx extends q2() {
          constructor({ id: t4, label: e4, attributes: n3, classes: i3, styles: o3, defaultValue: r3 }) {
            super(), this.id = t4, this.set("value", void 0), this.defaultValue = r3, this.label = e4, this.attributes = n3, this.classes = i3, this.styles = o3;
          }
          _createPattern() {
            return { attributes: this.attributes, classes: this.classes, styles: this.styles };
          }
        }
        var wx = n2(3925), Ax = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(wx.Z, Ax);
        wx.Z.locals;
        const Cx = "automatic", _x = /^(https?:)?\/\//;
        class vx extends bs {
          static get pluginName() {
            return "LinkEditing";
          }
          static get requires() {
            return [rk2, qf2, Nb2];
          }
          constructor(t4) {
            super(t4), t4.config.define("link", { addTargetToExternalLinks: false });
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: "linkHref" }), t4.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: lx }), t4.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (t5, e5) => lx(dx(t5), e5) }), t4.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: true } }, model: { key: "linkHref", value: (t5) => t5.getAttribute("href") } }), t4.commands.add("link", new px(t4)), t4.commands.add("unlink", new kx(t4));
            const e4 = function(t5, e5) {
              const n3 = { "Open in a new tab": t5("Open in a new tab"), Downloadable: t5("Downloadable") };
              return e5.forEach((t6) => ("label" in t6 && n3[t6.label] && (t6.label = n3[t6.label]), t6)), e5;
            }(t4.t, function(t5) {
              const e5 = [];
              if (t5)
                for (const [n3, i3] of Object.entries(t5)) {
                  const t6 = Object.assign({}, i3, { id: `link${s_(n3)}` });
                  e5.push(t6);
                }
              return e5;
            }(t4.config.get("link.decorators")));
            this._enableAutomaticDecorators(e4.filter((t5) => t5.mode === Cx)), this._enableManualDecorators(e4.filter((t5) => "manual" === t5.mode));
            t4.plugins.get(rk2).registerAttribute("linkHref"), wk2(t4, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink(), this._enableClipboardIntegration();
          }
          _enableAutomaticDecorators(t4) {
            const e4 = this.editor, n3 = e4.commands.get("link").automaticDecorators;
            e4.config.get("link.addTargetToExternalLinks") && n3.add({ id: "linkIsExternal", mode: Cx, callback: (t5) => !!t5 && _x.test(t5), attributes: { target: "_blank", rel: "noopener noreferrer" } }), n3.add(t4), n3.length && e4.conversion.for("downcast").add(n3.getDispatcher());
          }
          _enableManualDecorators(t4) {
            if (!t4.length)
              return;
            const e4 = this.editor, n3 = e4.commands.get("link").manualDecorators;
            t4.forEach((t5) => {
              e4.model.schema.extend("$text", { allowAttributes: t5.id });
              const i3 = new bx(t5);
              n3.add(i3), e4.conversion.for("downcast").attributeToElement({ model: i3.id, view: (t6, { writer: e5, schema: n4 }, { item: o3 }) => {
                if ((o3.is("selection") || n4.isInline(o3)) && t6) {
                  const t7 = e5.createAttributeElement("a", i3.attributes, { priority: 5 });
                  i3.classes && e5.addClass(i3.classes, t7);
                  for (const n5 in i3.styles)
                    e5.setStyle(n5, i3.styles[n5], t7);
                  return e5.setCustomProperty("link", true, t7), t7;
                }
              } }), e4.conversion.for("upcast").elementToAttribute({ view: { name: "a", ...i3._createPattern() }, model: { key: i3.id } });
            });
          }
          _enableLinkOpen() {
            const t4 = this.editor, e4 = t4.editing.view.document;
            this.listenTo(e4, "click", (t5, e5) => {
              if (!(c2.isMac ? e5.domEvent.metaKey : e5.domEvent.ctrlKey))
                return;
              let n3 = e5.domTarget;
              if ("a" != n3.tagName.toLowerCase() && (n3 = n3.closest("a")), !n3)
                return;
              const i3 = n3.getAttribute("href");
              i3 && (t5.stop(), e5.preventDefault(), mx(i3));
            }, { context: "$capture" }), this.listenTo(e4, "keydown", (e5, n3) => {
              const i3 = t4.commands.get("link").value;
              !!i3 && n3.keyCode === fo2.enter && n3.altKey && (e5.stop(), mx(i3));
            });
          }
          _enableInsertContentSelectionAttributesFixer() {
            const t4 = this.editor.model, e4 = t4.document.selection;
            this.listenTo(t4, "insertContent", () => {
              const n3 = e4.anchor.nodeBefore, i3 = e4.anchor.nodeAfter;
              e4.hasAttribute("linkHref") && n3 && n3.hasAttribute("linkHref") && (i3 && i3.hasAttribute("linkHref") || t4.change((e5) => {
                yx(e5, Ex(t4.schema));
              }));
            }, { priority: "low" });
          }
          _enableClickingAfterLink() {
            const t4 = this.editor, e4 = t4.model;
            t4.editing.view.addObserver(Vu);
            let n3 = false;
            this.listenTo(t4.editing.view.document, "mousedown", () => {
              n3 = true;
            }), this.listenTo(t4.editing.view.document, "selectionChange", () => {
              if (!n3)
                return;
              n3 = false;
              const t5 = e4.document.selection;
              if (!t5.isCollapsed)
                return;
              if (!t5.hasAttribute("linkHref"))
                return;
              const i3 = t5.getFirstPosition(), o3 = kk2(i3, "linkHref", t5.getAttribute("linkHref"), e4);
              (i3.isTouching(o3.start) || i3.isTouching(o3.end)) && e4.change((t6) => {
                yx(t6, Ex(e4.schema));
              });
            });
          }
          _enableTypingOverLink() {
            const t4 = this.editor, e4 = t4.editing.view;
            let n3 = null, i3 = false;
            this.listenTo(e4.document, "delete", () => {
              i3 = true;
            }, { priority: "high" }), this.listenTo(t4.model, "deleteContent", () => {
              const e5 = t4.model.document.selection;
              e5.isCollapsed || (i3 ? i3 = false : xx(t4) && function(t5) {
                const e6 = t5.document.selection, n4 = e6.getFirstPosition(), i4 = e6.getLastPosition(), o3 = n4.nodeAfter;
                if (!o3)
                  return false;
                if (!o3.is("$text"))
                  return false;
                if (!o3.hasAttribute("linkHref"))
                  return false;
                const r3 = i4.textNode || i4.nodeBefore;
                if (o3 === r3)
                  return true;
                return kk2(n4, "linkHref", o3.getAttribute("linkHref"), t5).containsRange(t5.createRange(n4, i4), true);
              }(t4.model) && (n3 = e5.getAttributes()));
            }, { priority: "high" }), this.listenTo(t4.model, "insertContent", (e5, [o3]) => {
              i3 = false, xx(t4) && n3 && (t4.model.change((t5) => {
                for (const [e6, i4] of n3)
                  t5.setAttribute(e6, i4, o3);
              }), n3 = null);
            }, { priority: "high" });
          }
          _handleDeleteContentAfterLink() {
            const t4 = this.editor, e4 = t4.model, n3 = e4.document.selection, i3 = t4.editing.view;
            let o3 = false, r3 = false;
            this.listenTo(i3.document, "delete", (t5, e5) => {
              r3 = "backward" === e5.direction;
            }, { priority: "high" }), this.listenTo(e4, "deleteContent", () => {
              o3 = false;
              const t5 = n3.getFirstPosition(), i4 = n3.getAttribute("linkHref");
              if (!i4)
                return;
              const r4 = kk2(t5, "linkHref", i4, e4);
              o3 = r4.containsPosition(t5) || r4.end.isEqual(t5);
            }, { priority: "high" }), this.listenTo(e4, "deleteContent", () => {
              r3 && (r3 = false, o3 || t4.model.enqueueChange((t5) => {
                yx(t5, Ex(e4.schema));
              }));
            }, { priority: "low" });
          }
          _enableClipboardIntegration() {
            const t4 = this.editor, e4 = t4.model, n3 = this.editor.config.get("link.defaultProtocol");
            n3 && this.listenTo(t4.plugins.get("ClipboardPipeline"), "contentInsertion", (t5, i3) => {
              e4.change((t6) => {
                const e5 = t6.createRangeIn(i3.content);
                for (const i4 of e5.getItems())
                  if (i4.hasAttribute("linkHref")) {
                    const e6 = ux(i4.getAttribute("linkHref"), n3);
                    t6.setAttribute("linkHref", e6, i4);
                  }
              });
            });
          }
        }
        function yx(t4, e4) {
          t4.removeSelectionAttribute("linkHref");
          for (const n3 of e4)
            t4.removeSelectionAttribute(n3);
        }
        function xx(t4) {
          return t4.model.change((t5) => t5.batch).isTyping;
        }
        function Ex(t4) {
          return t4.getDefinition("$text").allowAttributes.filter((t5) => t5.startsWith("link"));
        }
        var Dx = n2(4874), Sx = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Dx.Z, Sx);
        Dx.Z.locals;
        class Tx extends Ho2 {
          constructor(t4, e4) {
            super(t4), this.focusTracker = new To2(), this.keystrokes = new Io2(), this._focusables = new Ro2();
            const n3 = t4.t;
            this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n3("Save"), Pg2.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n3("Cancel"), Pg2.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e4), this.children = this._createFormChildren(e4.manualDecorators), this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
            const i3 = ["ck", "ck-link-form", "ck-responsive-form"];
            e4.manualDecorators.length && i3.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({ tag: "form", attributes: { class: i3, tabindex: "-1" }, children: this.children });
          }
          getDecoratorSwitchesState() {
            return Array.from(this._manualDecoratorSwitches).reduce((t4, e4) => (t4[e4.name] = e4.isOn, t4), {});
          }
          render() {
            super.render(), o2({ view: this });
            [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((t4) => {
              this._focusables.add(t4), this.focusTracker.add(t4.element);
            }), this.keystrokes.listenTo(this.element);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createUrlInput() {
            const t4 = this.locale.t, e4 = new Xr(this.locale, hm);
            return e4.label = t4("Link URL"), e4;
          }
          _createButton(t4, e4, n3, i3) {
            const o3 = new kr(this.locale);
            return o3.set({ label: t4, icon: e4, tooltip: true }), o3.extendTemplate({ attributes: { class: n3 } }), i3 && o3.delegate("execute").to(this, i3), o3;
          }
          _createManualDecoratorSwitches(t4) {
            const e4 = this.createCollection();
            for (const n3 of t4.manualDecorators) {
              const i3 = new Ar(this.locale);
              i3.set({ name: n3.id, label: n3.label, withText: true }), i3.bind("isOn").toMany([n3, t4], "value", (t5, e5) => void 0 === e5 && void 0 === t5 ? !!n3.defaultValue : !!t5), i3.on("execute", () => {
                n3.set("value", !i3.isOn);
              }), e4.add(i3);
            }
            return e4;
          }
          _createFormChildren(t4) {
            const e4 = this.createCollection();
            if (e4.add(this.urlInputView), t4.length) {
              const t5 = new Ho2();
              t5.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((t6) => ({ tag: "li", children: [t6], attributes: { class: ["ck", "ck-list__item"] } })), attributes: { class: ["ck", "ck-reset", "ck-list"] } }), e4.add(t5);
            }
            return e4.add(this.saveButtonView), e4.add(this.cancelButtonView), e4;
          }
        }
        var Ix = n2(7536), Bx = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Ix.Z, Bx);
        Ix.Z.locals;
        class Mx extends Ho2 {
          constructor(t4) {
            super(t4), this.focusTracker = new To2(), this.keystrokes = new Io2(), this._focusables = new Ro2();
            const e4 = t4.t;
            this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(e4("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(e4("Edit link"), Pg2.pencil, "edit"), this.set("href", void 0), this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] });
          }
          render() {
            super.render();
            [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((t4) => {
              this._focusables.add(t4), this.focusTracker.add(t4.element);
            }), this.keystrokes.listenTo(this.element);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createButton(t4, e4, n3) {
            const i3 = new kr(this.locale);
            return i3.set({ label: t4, icon: e4, tooltip: true }), i3.delegate("execute").to(this, n3), i3;
          }
          _createPreviewButton() {
            const t4 = new kr(this.locale), e4 = this.bindTemplate, n3 = this.t;
            return t4.set({ withText: true, tooltip: n3("Open link in new tab") }), t4.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: e4.to("href", (t5) => t5 && dx(t5)), target: "_blank", rel: "noopener noreferrer" } }), t4.bind("label").to(this, "href", (t5) => t5 || n3("This link has no URL")), t4.bind("isEnabled").to(this, "href", (t5) => !!t5), t4.template.tag = "a", t4.template.eventListeners = {}, t4;
          }
        }
        const Nx = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', Lx = "link-ui";
        class zx extends bs {
          constructor() {
            super(...arguments), this.actionsView = null, this.formView = null;
          }
          static get requires() {
            return [Yp];
          }
          static get pluginName() {
            return "LinkUI";
          }
          init() {
            const t4 = this.editor;
            t4.editing.view.addObserver(Fu), this._balloon = t4.plugins.get(Yp), this._createToolbarLinkButton(), this._enableBalloonActivators(), t4.conversion.for("editingDowncast").markerToHighlight({ model: Lx, view: { classes: ["ck-fake-link-selection"] } }), t4.conversion.for("editingDowncast").markerToElement({ model: Lx, view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } });
          }
          destroy() {
            super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy();
          }
          _createViews() {
            this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions();
          }
          _createActionsView() {
            const t4 = this.editor, e4 = new Mx(t4.locale), n3 = t4.commands.get("link"), i3 = t4.commands.get("unlink");
            return e4.bind("href").to(n3, "value"), e4.editButtonView.bind("isEnabled").to(n3), e4.unlinkButtonView.bind("isEnabled").to(i3), this.listenTo(e4, "edit", () => {
              this._addFormView();
            }), this.listenTo(e4, "unlink", () => {
              t4.execute("unlink"), this._hideUI();
            }), e4.keystrokes.set("Esc", (t5, e5) => {
              this._hideUI(), e5();
            }), e4.keystrokes.set(cx, (t5, e5) => {
              this._addFormView(), e5();
            }), e4;
          }
          _createFormView() {
            const t4 = this.editor, n3 = t4.commands.get("link"), i3 = t4.config.get("link.defaultProtocol"), o3 = new (e3(Tx))(t4.locale, n3);
            return o3.urlInputView.fieldView.bind("value").to(n3, "value"), o3.urlInputView.bind("isEnabled").to(n3, "isEnabled"), o3.saveButtonView.bind("isEnabled").to(n3), this.listenTo(o3, "submit", () => {
              const { value: e4 } = o3.urlInputView.fieldView.element, n4 = ux(e4, i3);
              t4.execute("link", n4, o3.getDecoratorSwitchesState()), this._closeFormView();
            }), this.listenTo(o3, "cancel", () => {
              this._closeFormView();
            }), o3.keystrokes.set("Esc", (t5, e4) => {
              this._closeFormView(), e4();
            }), o3;
          }
          _createToolbarLinkButton() {
            const t4 = this.editor, e4 = t4.commands.get("link"), n3 = t4.t;
            t4.ui.componentFactory.add("link", (t5) => {
              const i3 = new kr(t5);
              return i3.isEnabled = true, i3.label = n3("Link"), i3.icon = Nx, i3.keystroke = cx, i3.tooltip = true, i3.isToggleable = true, i3.bind("isEnabled").to(e4, "isEnabled"), i3.bind("isOn").to(e4, "value", (t6) => !!t6), this.listenTo(i3, "execute", () => this._showUI(true)), i3;
            });
          }
          _enableBalloonActivators() {
            const t4 = this.editor, e4 = t4.editing.view.document;
            this.listenTo(e4, "click", () => {
              this._getSelectedLinkElement() && this._showUI();
            }), t4.keystrokes.set(cx, (e5, n3) => {
              n3(), t4.commands.get("link").isEnabled && this._showUI(true);
            });
          }
          _enableUserBalloonInteractions() {
            this.editor.keystrokes.set("Tab", (t4, e4) => {
              this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), e4());
            }, { priority: "high" }), this.editor.keystrokes.set("Esc", (t4, e4) => {
              this._isUIVisible && (this._hideUI(), e4());
            }), t3({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: () => [this._balloon.view.element], callback: () => this._hideUI() });
          }
          _addActionsView() {
            this.actionsView || this._createViews(), this._areActionsInPanel || this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
          }
          _addFormView() {
            if (this.formView || this._createViews(), this._isFormInPanel)
              return;
            const t4 = this.editor.commands.get("link");
            this.formView.disableCssTransitions(), this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = t4.value || "";
          }
          _closeFormView() {
            const t4 = this.editor.commands.get("link");
            t4.restoreManualDecoratorStates(), void 0 !== t4.value ? this._removeFormView() : this._hideUI();
          }
          _removeFormView() {
            this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
          }
          _showUI(t4 = false) {
            this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), t4 && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), t4 && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
          }
          _hideUI() {
            if (!this._isUIInPanel)
              return;
            const t4 = this.editor;
            this.stopListening(t4.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), t4.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
          }
          _startUpdatingUI() {
            const t4 = this.editor, e4 = t4.editing.view.document;
            let n3 = this._getSelectedLinkElement(), i3 = r3();
            const o3 = () => {
              const t5 = this._getSelectedLinkElement(), e5 = r3();
              n3 && !t5 || !n3 && e5 !== i3 ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n3 = t5, i3 = e5;
            };
            function r3() {
              return e4.selection.focus.getAncestors().reverse().find((t5) => t5.is("element"));
            }
            this.listenTo(t4.ui, "update", o3), this.listenTo(this._balloon, "change:visibleView", o3);
          }
          get _isFormInPanel() {
            return !!this.formView && this._balloon.hasView(this.formView);
          }
          get _areActionsInPanel() {
            return !!this.actionsView && this._balloon.hasView(this.actionsView);
          }
          get _areActionsVisible() {
            return !!this.actionsView && this._balloon.visibleView === this.actionsView;
          }
          get _isUIInPanel() {
            return this._isFormInPanel || this._areActionsInPanel;
          }
          get _isUIVisible() {
            const t4 = this._balloon.visibleView;
            return !!this.formView && t4 == this.formView || this._areActionsVisible;
          }
          _getBalloonPositionData() {
            const t4 = this.editor.editing.view, e4 = this.editor.model, n3 = t4.document;
            let i3;
            if (e4.markers.has(Lx)) {
              const e5 = Array.from(this.editor.editing.mapper.markerNameToElements(Lx)), n4 = t4.createRange(t4.createPositionBefore(e5[0]), t4.createPositionAfter(e5[e5.length - 1]));
              i3 = t4.domConverter.viewRangeToDom(n4);
            } else
              i3 = () => {
                const e5 = this._getSelectedLinkElement();
                return e5 ? t4.domConverter.mapViewToDom(e5) : t4.domConverter.viewRangeToDom(n3.selection.getFirstRange());
              };
            return { target: i3 };
          }
          _getSelectedLinkElement() {
            const t4 = this.editor.editing.view, e4 = t4.document.selection, n3 = e4.getSelectedElement();
            if (e4.isCollapsed || n3 && jb2(n3))
              return Px(e4.getFirstPosition());
            {
              const n4 = e4.getFirstRange().getTrimmed(), i3 = Px(n4.start), o3 = Px(n4.end);
              return i3 && i3 == o3 && t4.createRangeIn(i3).getTrimmed().isEqual(n4) ? i3 : null;
            }
          }
          _showFakeVisualSelection() {
            const t4 = this.editor.model;
            t4.change((e4) => {
              const n3 = t4.document.selection.getFirstRange();
              if (t4.markers.has(Lx))
                e4.updateMarker(Lx, { range: n3 });
              else if (n3.start.isAtEnd) {
                const i3 = n3.start.getLastMatchingPosition(({ item: e5 }) => !t4.schema.isContent(e5), { boundaries: n3 });
                e4.addMarker(Lx, { usingOperation: false, affectsData: false, range: e4.createRange(i3, n3.end) });
              } else
                e4.addMarker(Lx, { usingOperation: false, affectsData: false, range: n3 });
            });
          }
          _hideFakeVisualSelection() {
            const t4 = this.editor.model;
            t4.markers.has(Lx) && t4.change((t5) => {
              t5.removeMarker(Lx);
            });
          }
        }
        function Px(t4) {
          return t4.getAncestors().find((t5) => {
            return (e4 = t5).is("attributeElement") && !!e4.getCustomProperty("link");
            var e4;
          }) || null;
        }
        const Rx = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
        class Ox extends bs {
          static get requires() {
            return [ek2];
          }
          static get pluginName() {
            return "AutoLink";
          }
          init() {
            const t4 = this.editor.model.document.selection;
            t4.on("change:range", () => {
              this.isEnabled = !t4.anchor.parent.is("element", "codeBlock");
            }), this._enableTypingHandling();
          }
          afterInit() {
            this._enableEnterHandling(), this._enableShiftEnterHandling();
          }
          _enableTypingHandling() {
            const t4 = this.editor, e4 = new ok2(t4.model, (t5) => {
              if (!function(t6) {
                return t6.length > 4 && " " === t6[t6.length - 1] && " " !== t6[t6.length - 2];
              }(t5))
                return;
              const e5 = Fx(t5.substr(0, t5.length - 1));
              return e5 ? { url: e5 } : void 0;
            });
            e4.on("matched:data", (e5, n3) => {
              const { batch: i3, range: o3, url: r3 } = n3;
              if (!i3.isTyping)
                return;
              const s3 = o3.end.getShiftedBy(-1), a3 = s3.getShiftedBy(-r3.length), c3 = t4.model.createRange(a3, s3);
              this._applyAutoLink(r3, c3);
            }), e4.bind("isEnabled").to(this);
          }
          _enableEnterHandling() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.commands.get("enter");
            n3 && n3.on("execute", () => {
              const t5 = e4.document.selection.getFirstPosition();
              if (!t5.parent.previousSibling)
                return;
              const n4 = e4.createRangeIn(t5.parent.previousSibling);
              this._checkAndApplyAutoLinkOnRange(n4);
            });
          }
          _enableShiftEnterHandling() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.commands.get("shiftEnter");
            n3 && n3.on("execute", () => {
              const t5 = e4.document.selection.getFirstPosition(), n4 = e4.createRange(e4.createPositionAt(t5.parent, 0), t5.getShiftedBy(-1));
              this._checkAndApplyAutoLinkOnRange(n4);
            });
          }
          _checkAndApplyAutoLinkOnRange(t4) {
            const e4 = this.editor.model, { text: n3, range: i3 } = ik2(t4, e4), o3 = Fx(n3);
            if (o3) {
              const t5 = e4.createRange(i3.end.getShiftedBy(-o3.length), i3.end);
              this._applyAutoLink(o3, t5);
            }
          }
          _applyAutoLink(t4, e4) {
            const n3 = this.editor.model, i3 = ux(t4, this.editor.config.get("link.defaultProtocol"));
            this.isEnabled && function(t5, e5) {
              return e5.schema.checkAttributeInSelection(e5.createSelection(t5), "linkHref");
            }(e4, n3) && gx(i3) && !function(t5) {
              const e5 = t5.start.nodeAfter;
              return !!e5 && e5.hasAttribute("linkHref");
            }(e4) && this._persistAutoLink(i3, e4);
          }
          _persistAutoLink(t4, e4) {
            const n3 = this.editor.model, i3 = this.editor.plugins.get("Delete");
            n3.enqueueChange((o3) => {
              o3.setAttribute("linkHref", t4, e4), n3.enqueueChange(() => {
                i3.requestUndoOnBackspace();
              });
            });
          }
        }
        function Fx(t4) {
          const e4 = Rx.exec(t4);
          return e4 ? e4[2] : null;
        }
        class Vx extends bs {
          static get requires() {
            return ["ImageEditing", "ImageUtils", vx];
          }
          static get pluginName() {
            return "LinkImageEditing";
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema;
            t4.plugins.has("ImageBlockEditing") && e4.extend("imageBlock", { allowAttributes: ["linkHref"] }), t4.conversion.for("upcast").add(function(t5) {
              const e5 = t5.plugins.has("ImageInlineEditing"), n3 = t5.plugins.get("ImageUtils");
              return (t6) => {
                t6.on("element:a", (t7, i3, o3) => {
                  const r3 = i3.viewItem, s3 = n3.findViewImgElement(r3);
                  if (!s3)
                    return;
                  const a3 = s3.findAncestor((t8) => n3.isBlockImageView(t8));
                  if (e5 && !a3)
                    return;
                  const c3 = { attributes: ["href"] };
                  if (!o3.consumable.consume(r3, c3))
                    return;
                  const l3 = r3.getAttribute("href");
                  if (!l3)
                    return;
                  let d3 = i3.modelCursor.parent;
                  if (!d3.is("element", "imageBlock")) {
                    const t8 = o3.convertItem(s3, i3.modelCursor);
                    i3.modelRange = t8.modelRange, i3.modelCursor = t8.modelCursor, d3 = i3.modelCursor.nodeBefore;
                  }
                  d3 && d3.is("element", "imageBlock") && o3.writer.setAttribute("linkHref", l3, d3);
                }, { priority: "high" });
              };
            }(t4)), t4.conversion.for("downcast").add(function(t5) {
              const e5 = t5.plugins.get("ImageUtils");
              return (t6) => {
                t6.on("attribute:linkHref:imageBlock", (t7, n3, i3) => {
                  if (!i3.consumable.consume(n3.item, t7.name))
                    return;
                  const o3 = i3.mapper.toViewElement(n3.item), r3 = i3.writer, s3 = Array.from(o3.getChildren()).find((t8) => t8.is("element", "a")), a3 = e5.findViewImgElement(o3), c3 = a3.parent.is("element", "picture") ? a3.parent : a3;
                  if (s3)
                    n3.attributeNewValue ? r3.setAttribute("href", n3.attributeNewValue, s3) : (r3.move(r3.createRangeOn(c3), r3.createPositionAt(o3, 0)), r3.remove(s3));
                  else {
                    const t8 = r3.createContainerElement("a", { href: n3.attributeNewValue });
                    r3.insert(r3.createPositionAt(o3, 0), t8), r3.move(r3.createRangeOn(c3), r3.createPositionAt(t8, 0));
                  }
                }, { priority: "high" });
              };
            }(t4)), this._enableAutomaticDecorators(), this._enableManualDecorators();
          }
          _enableAutomaticDecorators() {
            const t4 = this.editor, e4 = t4.commands.get("link").automaticDecorators;
            e4.length && t4.conversion.for("downcast").add(e4.getDispatcherForLinkedImage());
          }
          _enableManualDecorators() {
            const t4 = this.editor, e4 = t4.commands.get("link");
            for (const n3 of e4.manualDecorators)
              t4.plugins.has("ImageBlockEditing") && t4.model.schema.extend("imageBlock", { allowAttributes: n3.id }), t4.plugins.has("ImageInlineEditing") && t4.model.schema.extend("imageInline", { allowAttributes: n3.id }), t4.conversion.for("downcast").add(jx(n3)), t4.conversion.for("upcast").add(Hx(t4, n3));
          }
        }
        function jx(t4) {
          return (e4) => {
            e4.on(`attribute:${t4.id}:imageBlock`, (e5, n3, i3) => {
              const o3 = i3.mapper.toViewElement(n3.item), r3 = Array.from(o3.getChildren()).find((t5) => t5.is("element", "a"));
              if (r3) {
                for (const [e6, n4] of Bo2(t4.attributes))
                  i3.writer.setAttribute(e6, n4, r3);
                t4.classes && i3.writer.addClass(t4.classes, r3);
                for (const e6 in t4.styles)
                  i3.writer.setStyle(e6, t4.styles[e6], r3);
              }
            });
          };
        }
        function Hx(t4, e4) {
          const n3 = t4.plugins.has("ImageInlineEditing"), i3 = t4.plugins.get("ImageUtils");
          return (t5) => {
            t5.on("element:a", (t6, o3, r3) => {
              const s3 = o3.viewItem, a3 = i3.findViewImgElement(s3);
              if (!a3)
                return;
              const c3 = a3.findAncestor((t7) => i3.isBlockImageView(t7));
              if (n3 && !c3)
                return;
              const l3 = new Vs(e4._createPattern()).match(s3);
              if (!l3)
                return;
              if (!r3.consumable.consume(s3, l3.match))
                return;
              const d3 = o3.modelCursor.nodeBefore || o3.modelCursor.parent;
              r3.writer.setAttribute(e4.id, true, d3);
            }, { priority: "high" });
          };
        }
        class Ux extends bs {
          static get requires() {
            return [vx, zx, "ImageBlockEditing"];
          }
          static get pluginName() {
            return "LinkImageUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view.document;
            this.listenTo(e4, "click", (e5, n3) => {
              this._isSelectedLinkedImage(t4.model.document.selection) && (n3.preventDefault(), e5.stop());
            }, { priority: "high" }), this._createToolbarLinkImageButton();
          }
          _createToolbarLinkImageButton() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add("linkImage", (n3) => {
              const i3 = new kr(n3), o3 = t4.plugins.get("LinkUI"), r3 = t4.commands.get("link");
              return i3.set({ isEnabled: true, label: e4("Link image"), icon: Nx, keystroke: cx, tooltip: true, isToggleable: true }), i3.bind("isEnabled").to(r3, "isEnabled"), i3.bind("isOn").to(r3, "value", (t5) => !!t5), this.listenTo(i3, "execute", () => {
                this._isSelectedLinkedImage(t4.model.document.selection) ? o3._addActionsView() : o3._showUI(true);
              }), i3;
            });
          }
          _isSelectedLinkedImage(t4) {
            const e4 = t4.getSelectedElement();
            return this.editor.plugins.get("ImageUtils").isImage(e4) && e4.hasAttribute("linkHref");
          }
        }
        var Gx = n2(4330), Wx = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Gx.Z, Wx);
        Gx.Z.locals;
        var qx = n2(3190), $x = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(qx.Z, $x);
        qx.Z.locals;
        var Kx = n2(4784), Zx = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(Kx.Z, Zx);
        Kx.Z.locals;
        function Yx(t4, e4) {
          const n3 = e4.mapper, i3 = e4.writer, o3 = "numbered" == t4.getAttribute("listType") ? "ol" : "ul", r3 = function(t5) {
            const e5 = t5.createContainerElement("li");
            return e5.getFillerOffset = rE, e5;
          }(i3), s3 = i3.createContainerElement(o3, null);
          return i3.insert(i3.createPositionAt(s3, 0), r3), n3.bindElements(t4, r3), r3;
        }
        function Qx(t4, e4, n3, i3) {
          const o3 = e4.parent, r3 = n3.mapper, s3 = n3.writer;
          let a3 = r3.toViewPosition(i3.createPositionBefore(t4));
          const c3 = tE(t4.previousSibling, { sameIndent: true, smallerIndent: true, listIndent: t4.getAttribute("listIndent") }), l3 = t4.previousSibling;
          if (c3 && c3.getAttribute("listIndent") == t4.getAttribute("listIndent")) {
            const t5 = r3.toViewElement(c3);
            a3 = s3.breakContainer(s3.createPositionAfter(t5));
          } else if (l3 && "listItem" == l3.name) {
            a3 = r3.toViewPosition(i3.createPositionAt(l3, "end"));
            const t5 = r3.findMappedViewAncestor(a3), e5 = function(t6) {
              for (const e6 of t6.getChildren())
                if ("ul" == e6.name || "ol" == e6.name)
                  return e6;
              return null;
            }(t5);
            a3 = e5 ? s3.createPositionBefore(e5) : s3.createPositionAt(t5, "end");
          } else
            a3 = r3.toViewPosition(i3.createPositionBefore(t4));
          if (a3 = Xx(a3), s3.insert(a3, o3), l3 && "listItem" == l3.name) {
            const t5 = r3.toViewElement(l3), n4 = s3.createRange(s3.createPositionAt(t5, 0), a3).getWalker({ ignoreElementEnd: true });
            for (const t6 of n4)
              if (t6.item.is("element", "li")) {
                const i4 = s3.breakContainer(s3.createPositionBefore(t6.item)), o4 = t6.item.parent, r4 = s3.createPositionAt(e4, "end");
                Jx(s3, r4.nodeBefore, r4.nodeAfter), s3.move(s3.createRangeOn(o4), r4), n4._position = i4;
              }
          } else {
            const n4 = o3.nextSibling;
            if (n4 && (n4.is("element", "ul") || n4.is("element", "ol"))) {
              let i4 = null;
              for (const e5 of n4.getChildren()) {
                const n5 = r3.toModelElement(e5);
                if (!(n5 && n5.getAttribute("listIndent") > t4.getAttribute("listIndent")))
                  break;
                i4 = e5;
              }
              i4 && (s3.breakContainer(s3.createPositionAfter(i4)), s3.move(s3.createRangeOn(i4.parent), s3.createPositionAt(e4, "end")));
            }
          }
          Jx(s3, o3, o3.nextSibling), Jx(s3, o3.previousSibling, o3);
        }
        function Jx(t4, e4, n3) {
          return !e4 || !n3 || "ul" != e4.name && "ol" != e4.name || e4.name != n3.name || e4.getAttribute("class") !== n3.getAttribute("class") ? null : t4.mergeContainers(t4.createPositionAfter(e4));
        }
        function Xx(t4) {
          return t4.getLastMatchingPosition((t5) => t5.item.is("uiElement"));
        }
        function tE(t4, e4) {
          const n3 = !!e4.sameIndent, i3 = !!e4.smallerIndent, o3 = e4.listIndent;
          let r3 = t4;
          for (; r3 && "listItem" == r3.name; ) {
            const t5 = r3.getAttribute("listIndent");
            if (n3 && o3 == t5 || i3 && o3 > t5)
              return r3;
            r3 = "forward" === e4.direction ? r3.nextSibling : r3.previousSibling;
          }
          return null;
        }
        function eE(t4, e4, n3, i3) {
          t4.ui.componentFactory.add(e4, (o3) => {
            const r3 = t4.commands.get(e4), s3 = new kr(o3);
            return s3.set({ label: n3, icon: i3, tooltip: true, isToggleable: true }), s3.bind("isOn", "isEnabled").to(r3, "value", "isEnabled"), s3.on("execute", () => {
              t4.execute(e4), t4.editing.view.focus();
            }), s3;
          });
        }
        function nE(t4, e4) {
          const n3 = [], i3 = t4.parent, o3 = { ignoreElementEnd: false, startPosition: t4, shallow: true, direction: e4 }, r3 = i3.getAttribute("listIndent"), s3 = [...new ql2(o3)].filter((t5) => t5.item.is("element")).map((t5) => t5.item);
          for (const t5 of s3) {
            if (!t5.is("element", "listItem"))
              break;
            if (t5.getAttribute("listIndent") < r3)
              break;
            if (!(t5.getAttribute("listIndent") > r3)) {
              if (t5.getAttribute("listType") !== i3.getAttribute("listType"))
                break;
              if (t5.getAttribute("listStyle") !== i3.getAttribute("listStyle"))
                break;
              if (t5.getAttribute("listReversed") !== i3.getAttribute("listReversed"))
                break;
              if (t5.getAttribute("listStart") !== i3.getAttribute("listStart"))
                break;
              "backward" === e4 ? n3.unshift(t5) : n3.push(t5);
            }
          }
          return n3;
        }
        const iE = ["disc", "circle", "square"], oE = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];
        function rE() {
          const t4 = !this.isEmpty && ("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
          return this.isEmpty || t4 ? 0 : Ha2.call(this);
        }
        class sE extends bs {
          static get pluginName() {
            return "ListUI";
          }
          init() {
            const t4 = this.editor.t;
            eE(this.editor, "numberedList", t4("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), eE(this.editor, "bulletedList", t4("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');
          }
        }
        const dE = [{ listStyle: "disc", typeAttribute: "disc", listType: "bulleted" }, { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" }, { listStyle: "square", typeAttribute: "square", listType: "bulleted" }, { listStyle: "decimal", typeAttribute: "1", listType: "numbered" }, { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" }, { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" }, { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" }, { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" }, { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }];
        for (const { listStyle: t4, typeAttribute: e4, listType: n3 } of dE)
          ;
        var hE = n2(5782), uE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(hE.Z, uE);
        hE.Z.locals;
        var gE = n2(9938), mE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(gE.Z, mE);
        gE.Z.locals;
        var pE = n2(2591), fE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(pE.Z, fE);
        pE.Z.locals;
        class kE extends As {
          constructor(t4, e4) {
            super(t4), this._indentBy = "forward" == e4 ? 1 : -1;
          }
          refresh() {
            this.isEnabled = this._checkEnabled();
          }
          execute() {
            const t4 = this.editor.model, e4 = t4.document;
            let n3 = Array.from(e4.selection.getSelectedBlocks());
            t4.change((t5) => {
              const e5 = n3[n3.length - 1];
              let i3 = e5.nextSibling;
              for (; i3 && "listItem" == i3.name && i3.getAttribute("listIndent") > e5.getAttribute("listIndent"); )
                n3.push(i3), i3 = i3.nextSibling;
              this._indentBy < 0 && (n3 = n3.reverse());
              for (const e6 of n3) {
                const n4 = e6.getAttribute("listIndent") + this._indentBy;
                n4 < 0 ? t5.rename(e6, "paragraph") : t5.setAttribute("listIndent", n4, e6);
              }
              this.fire("_executeCleanup", n3);
            });
          }
          _checkEnabled() {
            const t4 = So2(this.editor.model.document.selection.getSelectedBlocks());
            if (!t4 || !t4.is("element", "listItem"))
              return false;
            if (this._indentBy > 0) {
              const e4 = t4.getAttribute("listIndent"), n3 = t4.getAttribute("listType");
              let i3 = t4.previousSibling;
              for (; i3 && i3.is("element", "listItem") && i3.getAttribute("listIndent") >= e4; ) {
                if (i3.getAttribute("listIndent") == e4)
                  return i3.getAttribute("listType") == n3;
                i3 = i3.previousSibling;
              }
              return false;
            }
            return true;
          }
        }
        class bE extends As {
          constructor(t4, e4) {
            super(t4), this.type = e4;
          }
          refresh() {
            this.value = this._getValue(), this.isEnabled = this._checkEnabled();
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document, i3 = Array.from(n3.selection.getSelectedBlocks()).filter((t5) => AE(t5, e4.schema)), o3 = void 0 !== t4.forceValue ? !t4.forceValue : this.value;
            e4.change((t5) => {
              if (o3) {
                let e5 = i3[i3.length - 1].nextSibling, n4 = Number.POSITIVE_INFINITY, o4 = [];
                for (; e5 && "listItem" == e5.name && 0 !== e5.getAttribute("listIndent"); ) {
                  const t6 = e5.getAttribute("listIndent");
                  t6 < n4 && (n4 = t6);
                  const i4 = t6 - n4;
                  o4.push({ element: e5, listIndent: i4 }), e5 = e5.nextSibling;
                }
                o4 = o4.reverse();
                for (const e6 of o4)
                  t5.setAttribute("listIndent", e6.listIndent, e6.element);
              }
              if (!o3) {
                let t6 = Number.POSITIVE_INFINITY;
                for (const e5 of i3)
                  e5.is("element", "listItem") && e5.getAttribute("listIndent") < t6 && (t6 = e5.getAttribute("listIndent"));
                t6 = 0 === t6 ? 1 : t6, wE(i3, true, t6), wE(i3, false, t6);
              }
              for (const e5 of i3.reverse())
                o3 && "listItem" == e5.name ? t5.rename(e5, "paragraph") : o3 || "listItem" == e5.name ? o3 || "listItem" != e5.name || e5.getAttribute("listType") == this.type || t5.setAttribute("listType", this.type, e5) : (t5.setAttributes({ listType: this.type, listIndent: 0 }, e5), t5.rename(e5, "listItem"));
              this.fire("_executeCleanup", i3);
            });
          }
          _getValue() {
            const t4 = So2(this.editor.model.document.selection.getSelectedBlocks());
            return !!t4 && t4.is("element", "listItem") && t4.getAttribute("listType") == this.type;
          }
          _checkEnabled() {
            if (this.value)
              return true;
            const t4 = this.editor.model.document.selection, e4 = this.editor.model.schema, n3 = So2(t4.getSelectedBlocks());
            return !!n3 && AE(n3, e4);
          }
        }
        function wE(t4, e4, n3) {
          const i3 = e4 ? t4[0] : t4[t4.length - 1];
          if (i3.is("element", "listItem")) {
            let o3 = i3[e4 ? "previousSibling" : "nextSibling"], r3 = i3.getAttribute("listIndent");
            for (; o3 && o3.is("element", "listItem") && o3.getAttribute("listIndent") >= n3; )
              r3 > o3.getAttribute("listIndent") && (r3 = o3.getAttribute("listIndent")), o3.getAttribute("listIndent") == r3 && t4[e4 ? "unshift" : "push"](o3), o3 = o3[e4 ? "previousSibling" : "nextSibling"];
          }
        }
        function AE(t4, e4) {
          return e4.checkChild(t4.parent, "listItem") && !e4.isObject(t4);
        }
        class CE extends bs {
          static get pluginName() {
            return "ListUtils";
          }
          getListTypeFromListStyleType(t4) {
            return function(t5) {
              return iE.includes(t5) ? "bulleted" : oE.includes(t5) ? "numbered" : null;
            }(t4);
          }
          getSelectedListItems(t4) {
            return function(t5) {
              let e4 = [...t5.document.selection.getSelectedBlocks()].filter((t6) => t6.is("element", "listItem")).map((e5) => {
                const n3 = t5.change((t6) => t6.createPositionAt(e5, 0));
                return [...nE(n3, "backward"), ...nE(n3, "forward")];
              }).flat();
              return e4 = [...new Set(e4)], e4;
            }(t4);
          }
          getSiblingNodes(t4, e4) {
            return nE(t4, e4);
          }
        }
        function _E(t4) {
          return (e4, n3, i3) => {
            const o3 = i3.consumable;
            if (!o3.test(n3.item, "insert") || !o3.test(n3.item, "attribute:listType") || !o3.test(n3.item, "attribute:listIndent"))
              return;
            o3.consume(n3.item, "insert"), o3.consume(n3.item, "attribute:listType"), o3.consume(n3.item, "attribute:listIndent");
            const r3 = n3.item;
            Qx(r3, Yx(r3, i3), i3, t4);
          };
        }
        const vE = (t4, e4, n3) => {
          if (!n3.consumable.test(e4.item, t4.name))
            return;
          const i3 = n3.mapper.toViewElement(e4.item), o3 = n3.writer;
          o3.breakContainer(o3.createPositionBefore(i3)), o3.breakContainer(o3.createPositionAfter(i3));
          const r3 = i3.parent, s3 = "numbered" == e4.attributeNewValue ? "ol" : "ul";
          o3.rename(s3, r3);
        }, yE = (t4, e4, n3) => {
          n3.consumable.consume(e4.item, t4.name);
          const i3 = n3.mapper.toViewElement(e4.item).parent, o3 = n3.writer;
          Jx(o3, i3, i3.nextSibling), Jx(o3, i3.previousSibling, i3);
        };
        const xE = (t4, e4, n3) => {
          if (n3.consumable.test(e4.item, t4.name) && "listItem" != e4.item.name) {
            let t5 = n3.mapper.toViewPosition(e4.range.start);
            const i3 = n3.writer, o3 = [];
            for (; ("ul" == t5.parent.name || "ol" == t5.parent.name) && (t5 = i3.breakContainer(t5), "li" == t5.parent.name); ) {
              const e5 = t5, n4 = i3.createPositionAt(t5.parent, "end");
              if (!e5.isEqual(n4)) {
                const t6 = i3.remove(i3.createRange(e5, n4));
                o3.push(t6);
              }
              t5 = i3.createPositionAfter(t5.parent);
            }
            if (o3.length > 0) {
              for (let e5 = 0; e5 < o3.length; e5++) {
                const n4 = t5.nodeBefore;
                if (t5 = i3.insert(t5, o3[e5]).end, e5 > 0) {
                  const e6 = Jx(i3, n4, n4.nextSibling);
                  e6 && e6.parent == n4 && t5.offset--;
                }
              }
              Jx(i3, t5.nodeBefore, t5.nodeAfter);
            }
          }
        }, EE = (t4, e4, n3) => {
          const i3 = n3.mapper.toViewPosition(e4.position), o3 = i3.nodeBefore, r3 = i3.nodeAfter;
          Jx(n3.writer, o3, r3);
        }, DE = (t4, e4, n3) => {
          if (n3.consumable.consume(e4.viewItem, { name: true })) {
            const t5 = n3.writer, i3 = t5.createElement("listItem"), o3 = function(t6) {
              let e5 = 0, n4 = t6.parent;
              for (; n4; ) {
                if (n4.is("element", "li"))
                  e5++;
                else {
                  const t7 = n4.previousSibling;
                  t7 && t7.is("element", "li") && e5++;
                }
                n4 = n4.parent;
              }
              return e5;
            }(e4.viewItem);
            t5.setAttribute("listIndent", o3, i3);
            const r3 = e4.viewItem.parent && "ol" == e4.viewItem.parent.name ? "numbered" : "bulleted";
            if (t5.setAttribute("listType", r3, i3), !n3.safeInsert(i3, e4.modelCursor))
              return;
            const s3 = function(t6, e5, n4) {
              const { writer: i4, schema: o4 } = n4;
              let r4 = i4.createPositionAfter(t6);
              for (const s4 of e5)
                if ("ul" == s4.name || "ol" == s4.name)
                  r4 = n4.convertItem(s4, r4).modelCursor;
                else {
                  const e6 = n4.convertItem(s4, i4.createPositionAt(t6, "end")), a3 = e6.modelRange.start.nodeAfter;
                  a3 && a3.is("element") && !o4.checkChild(t6, a3.name) && (t6 = e6.modelCursor.parent.is("element", "listItem") ? e6.modelCursor.parent : ME(e6.modelCursor), r4 = i4.createPositionAfter(t6));
                }
              return r4;
            }(i3, e4.viewItem.getChildren(), n3);
            e4.modelRange = t5.createRange(e4.modelCursor, s3), n3.updateConversionResult(i3, e4);
          }
        }, SE = (t4, e4, n3) => {
          if (n3.consumable.test(e4.viewItem, { name: true })) {
            const t5 = Array.from(e4.viewItem.getChildren());
            for (const e5 of t5) {
              !(e5.is("element", "li") || LE(e5)) && e5._remove();
            }
          }
        }, TE = (t4, e4, n3) => {
          if (n3.consumable.test(e4.viewItem, { name: true })) {
            if (0 === e4.viewItem.childCount)
              return;
            const t5 = [...e4.viewItem.getChildren()];
            let n4 = false;
            for (const e5 of t5)
              n4 && !LE(e5) && e5._remove(), LE(e5) && (n4 = true);
          }
        };
        function IE(t4) {
          return (e4, n3) => {
            if (n3.isPhantom)
              return;
            const i3 = n3.modelPosition.nodeBefore;
            if (i3 && i3.is("element", "listItem")) {
              const e5 = n3.mapper.toViewElement(i3), o3 = e5.getAncestors().find(LE), r3 = t4.createPositionAt(e5, 0).getWalker();
              for (const t5 of r3) {
                if ("elementStart" == t5.type && t5.item.is("element", "li")) {
                  n3.viewPosition = t5.previousPosition;
                  break;
                }
                if ("elementEnd" == t5.type && t5.item == o3) {
                  n3.viewPosition = t5.nextPosition;
                  break;
                }
              }
            }
          };
        }
        const BE = function(t4, [e4, n3]) {
          const i3 = this;
          let o3, r3 = e4.is("documentFragment") ? e4.getChild(0) : e4;
          if (o3 = n3 ? i3.createSelection(n3) : i3.document.selection, r3 && r3.is("element", "listItem")) {
            const t5 = o3.getFirstPosition();
            let e5 = null;
            if (t5.parent.is("element", "listItem") ? e5 = t5.parent : t5.nodeBefore && t5.nodeBefore.is("element", "listItem") && (e5 = t5.nodeBefore), e5) {
              const t6 = e5.getAttribute("listIndent");
              if (t6 > 0)
                for (; r3 && r3.is("element", "listItem"); )
                  r3._setAttribute("listIndent", r3.getAttribute("listIndent") + t6), r3 = r3.nextSibling;
            }
          }
        };
        function ME(t4) {
          const e4 = new ql2({ startPosition: t4 });
          let n3;
          do {
            n3 = e4.next();
          } while (!n3.value.item.is("element", "listItem"));
          return n3.value.item;
        }
        function NE(t4, e4, n3, i3, o3, r3) {
          const s3 = tE(e4.nodeBefore, { sameIndent: true, smallerIndent: true, listIndent: t4 }), a3 = o3.mapper, c3 = o3.writer, l3 = s3 ? s3.getAttribute("listIndent") : null;
          let d3;
          if (s3)
            if (l3 == t4) {
              const t5 = a3.toViewElement(s3).parent;
              d3 = c3.createPositionAfter(t5);
            } else {
              const t5 = r3.createPositionAt(s3, "end");
              d3 = a3.toViewPosition(t5);
            }
          else
            d3 = n3;
          d3 = Xx(d3);
          for (const t5 of [...i3.getChildren()])
            LE(t5) && (d3 = c3.move(c3.createRangeOn(t5), d3).end, Jx(c3, t5, t5.nextSibling), Jx(c3, t5.previousSibling, t5));
        }
        function LE(t4) {
          return t4.is("element", "ol") || t4.is("element", "ul");
        }
        class zE extends bs {
          static get pluginName() {
            return "ListEditing";
          }
          static get requires() {
            return [Qk2, ek2, CE];
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] });
            const e4 = t4.data, n3 = t4.editing;
            var i3;
            t4.model.document.registerPostFixer((e5) => function(t5, e6) {
              const n4 = t5.document.differ.getChanges(), i4 = /* @__PURE__ */ new Map();
              let o4 = false;
              for (const i5 of n4)
                if ("insert" == i5.type && "listItem" == i5.name)
                  r3(i5.position);
                else if ("insert" == i5.type && "listItem" != i5.name) {
                  if ("$text" != i5.name) {
                    const n5 = i5.position.nodeAfter;
                    n5.hasAttribute("listIndent") && (e6.removeAttribute("listIndent", n5), o4 = true), n5.hasAttribute("listType") && (e6.removeAttribute("listType", n5), o4 = true), n5.hasAttribute("listStyle") && (e6.removeAttribute("listStyle", n5), o4 = true), n5.hasAttribute("listReversed") && (e6.removeAttribute("listReversed", n5), o4 = true), n5.hasAttribute("listStart") && (e6.removeAttribute("listStart", n5), o4 = true);
                    for (const e7 of Array.from(t5.createRangeIn(n5)).filter((t6) => t6.item.is("element", "listItem")))
                      r3(e7.previousPosition);
                  }
                  r3(i5.position.getShiftedBy(i5.length));
                } else
                  "remove" == i5.type && "listItem" == i5.name ? r3(i5.position) : ("attribute" == i5.type && "listIndent" == i5.attributeKey || "attribute" == i5.type && "listType" == i5.attributeKey) && r3(i5.range.start);
              for (const t6 of i4.values())
                s3(t6), a3(t6);
              return o4;
              function r3(t6) {
                const e7 = t6.nodeBefore;
                if (e7 && e7.is("element", "listItem")) {
                  let t7 = e7;
                  if (i4.has(t7))
                    return;
                  for (let e8 = t7.previousSibling; e8 && e8.is("element", "listItem"); e8 = t7.previousSibling)
                    if (t7 = e8, i4.has(t7))
                      return;
                  i4.set(e7, t7);
                } else {
                  const e8 = t6.nodeAfter;
                  e8 && e8.is("element", "listItem") && i4.set(e8, e8);
                }
              }
              function s3(t6) {
                let n5 = 0, i5 = null;
                for (; t6 && t6.is("element", "listItem"); ) {
                  const r4 = t6.getAttribute("listIndent");
                  if (r4 > n5) {
                    let s4;
                    null === i5 ? (i5 = r4 - n5, s4 = n5) : (i5 > r4 && (i5 = r4), s4 = r4 - i5), e6.setAttribute("listIndent", s4, t6), o4 = true;
                  } else
                    i5 = null, n5 = t6.getAttribute("listIndent") + 1;
                  t6 = t6.nextSibling;
                }
              }
              function a3(t6) {
                let n5 = [], i5 = null;
                for (; t6 && t6.is("element", "listItem"); ) {
                  const r4 = t6.getAttribute("listIndent");
                  if (i5 && i5.getAttribute("listIndent") > r4 && (n5 = n5.slice(0, r4 + 1)), 0 != r4)
                    if (n5[r4]) {
                      const i6 = n5[r4];
                      t6.getAttribute("listType") != i6 && (e6.setAttribute("listType", i6, t6), o4 = true);
                    } else
                      n5[r4] = t6.getAttribute("listType");
                  i5 = t6, t6 = t6.nextSibling;
                }
              }
            }(t4.model, e5)), n3.mapper.registerViewToModelLength("li", PE), e4.mapper.registerViewToModelLength("li", PE), n3.mapper.on("modelToViewPosition", IE(n3.view)), n3.mapper.on("viewToModelPosition", (i3 = t4.model, (t5, e5) => {
              const n4 = e5.viewPosition, o4 = n4.parent, r3 = e5.mapper;
              if ("ul" == o4.name || "ol" == o4.name) {
                if (n4.isAtEnd) {
                  const t6 = r3.toModelElement(n4.nodeBefore), o5 = r3.getModelLength(n4.nodeBefore);
                  e5.modelPosition = i3.createPositionBefore(t6).getShiftedBy(o5);
                } else {
                  const t6 = r3.toModelElement(n4.nodeAfter);
                  e5.modelPosition = i3.createPositionBefore(t6);
                }
                t5.stop();
              } else if ("li" == o4.name && n4.nodeBefore && ("ul" == n4.nodeBefore.name || "ol" == n4.nodeBefore.name)) {
                const s3 = r3.toModelElement(o4);
                let a3 = 1, c3 = n4.nodeBefore;
                for (; c3 && LE(c3); )
                  a3 += r3.getModelLength(c3), c3 = c3.previousSibling;
                e5.modelPosition = i3.createPositionBefore(s3).getShiftedBy(a3), t5.stop();
              }
            })), e4.mapper.on("modelToViewPosition", IE(n3.view)), t4.conversion.for("editingDowncast").add((e5) => {
              e5.on("insert", xE, { priority: "high" }), e5.on("insert:listItem", _E(t4.model)), e5.on("attribute:listType:listItem", vE, { priority: "high" }), e5.on("attribute:listType:listItem", yE, { priority: "low" }), e5.on("attribute:listIndent:listItem", function(t5) {
                return (e6, n4, i4) => {
                  if (!i4.consumable.consume(n4.item, "attribute:listIndent"))
                    return;
                  const o4 = i4.mapper.toViewElement(n4.item), r3 = i4.writer;
                  r3.breakContainer(r3.createPositionBefore(o4)), r3.breakContainer(r3.createPositionAfter(o4));
                  const s3 = o4.parent, a3 = s3.previousSibling, c3 = r3.createRangeOn(s3);
                  r3.remove(c3), a3 && a3.nextSibling && Jx(r3, a3, a3.nextSibling), NE(n4.attributeOldValue + 1, n4.range.start, c3.start, o4, i4, t5), Qx(n4.item, o4, i4, t5);
                  for (const t6 of n4.item.getChildren())
                    i4.consumable.consume(t6, "insert");
                };
              }(t4.model)), e5.on("remove:listItem", function(t5) {
                return (e6, n4, i4) => {
                  const o4 = i4.mapper.toViewPosition(n4.position).getLastMatchingPosition((t6) => !t6.item.is("element", "li")).nodeAfter, r3 = i4.writer;
                  r3.breakContainer(r3.createPositionBefore(o4)), r3.breakContainer(r3.createPositionAfter(o4));
                  const s3 = o4.parent, a3 = s3.previousSibling, c3 = r3.createRangeOn(s3), l3 = r3.remove(c3);
                  a3 && a3.nextSibling && Jx(r3, a3, a3.nextSibling), NE(i4.mapper.toModelElement(o4).getAttribute("listIndent") + 1, n4.position, c3.start, o4, i4, t5);
                  for (const t6 of r3.createRangeIn(l3).getItems())
                    i4.mapper.unbindViewElement(t6);
                  e6.stop();
                };
              }(t4.model)), e5.on("remove", EE, { priority: "low" });
            }), t4.conversion.for("dataDowncast").add((e5) => {
              e5.on("insert", xE, { priority: "high" }), e5.on("insert:listItem", _E(t4.model));
            }), t4.conversion.for("upcast").add((t5) => {
              t5.on("element:ul", SE, { priority: "high" }), t5.on("element:ol", SE, { priority: "high" }), t5.on("element:li", TE, { priority: "high" }), t5.on("element:li", DE);
            }), t4.model.on("insertContent", BE, { priority: "high" }), t4.commands.add("numberedList", new bE(t4, "numbered")), t4.commands.add("bulletedList", new bE(t4, "bulleted")), t4.commands.add("indentList", new kE(t4, "forward")), t4.commands.add("outdentList", new kE(t4, "backward"));
            const o3 = n3.view.document;
            this.listenTo(o3, "enter", (t5, e5) => {
              const n4 = this.editor.model.document, i4 = n4.selection.getLastPosition().parent;
              n4.selection.isCollapsed && "listItem" == i4.name && i4.isEmpty && (this.editor.execute("outdentList"), e5.preventDefault(), t5.stop());
            }, { context: "li" }), this.listenTo(o3, "delete", (t5, e5) => {
              if ("backward" !== e5.direction)
                return;
              const n4 = this.editor.model.document.selection;
              if (!n4.isCollapsed)
                return;
              const i4 = n4.getFirstPosition();
              if (!i4.isAtStart)
                return;
              const o4 = i4.parent;
              if ("listItem" !== o4.name)
                return;
              o4.previousSibling && "listItem" === o4.previousSibling.name || (this.editor.execute("outdentList"), e5.preventDefault(), t5.stop());
            }, { context: "li" }), this.listenTo(t4.editing.view.document, "tab", (e5, n4) => {
              const i4 = n4.shiftKey ? "outdentList" : "indentList";
              this.editor.commands.get(i4).isEnabled && (t4.execute(i4), n4.stopPropagation(), n4.preventDefault(), e5.stop());
            }, { context: "li" });
          }
          afterInit() {
            const t4 = this.editor.commands, e4 = t4.get("indent"), n3 = t4.get("outdent");
            e4 && e4.registerChildCommand(t4.get("indentList")), n3 && n3.registerChildCommand(t4.get("outdentList"));
          }
        }
        function PE(t4) {
          let e4 = 1;
          for (const n3 of t4.getChildren())
            if ("ul" == n3.name || "ol" == n3.name)
              for (const t5 of n3.getChildren())
                e4 += PE(t5);
          return e4;
        }
        wo2("Ctrl+Enter");
        var RE = n2(9292), OE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(RE.Z, OE);
        RE.Z.locals;
        wo2("Ctrl+Enter");
        function FE(t4, e4) {
          const n3 = (n4, i3, o3) => {
            if (!o3.consumable.consume(i3.item, n4.name))
              return;
            const r3 = i3.attributeNewValue, s3 = o3.writer, a3 = o3.mapper.toViewElement(i3.item), c3 = [...a3.getChildren()].find((t5) => t5.getCustomProperty("media-content"));
            s3.remove(c3);
            const l3 = t4.getMediaViewElement(s3, r3, e4);
            s3.insert(s3.createPositionAt(a3, 0), l3);
          };
          return (t5) => {
            t5.on("attribute:url:media", n3);
          };
        }
        function VE(t4, e4, n3, i3) {
          return t4.createContainerElement("figure", { class: "media" }, [e4.getMediaViewElement(t4, n3, i3), t4.createSlot()]);
        }
        function jE(t4) {
          const e4 = t4.getSelectedElement();
          return e4 && e4.is("element", "media") ? e4 : null;
        }
        function HE(t4, e4, n3, i3) {
          t4.change((o3) => {
            const r3 = o3.createElement("media", { url: e4 });
            t4.insertObject(r3, n3, null, { setSelection: "on", findOptimalPosition: i3 ? "auto" : void 0 });
          });
        }
        class UE extends As {
          refresh() {
            const t4 = this.editor.model, e4 = t4.document.selection, n3 = jE(e4);
            this.value = n3 ? n3.getAttribute("url") : void 0, this.isEnabled = function(t5) {
              const e5 = t5.getSelectedElement();
              return !!e5 && "media" === e5.name;
            }(e4) || function(t5, e5) {
              const n4 = $b2(t5, e5);
              let i3 = n4.start.parent;
              i3.isEmpty && !e5.schema.isLimit(i3) && (i3 = i3.parent);
              return e5.schema.checkChild(i3, "media");
            }(e4, t4);
          }
          execute(t4) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = jE(n3);
            i3 ? e4.change((e5) => {
              e5.setAttribute("url", t4, i3);
            }) : HE(e4, t4, n3, true);
          }
        }
        class GE {
          constructor(t4, e4) {
            const n3 = e4.providers, i3 = e4.extraProviders || [], o3 = new Set(e4.removeProviders), r3 = n3.concat(i3).filter((t5) => {
              const e5 = t5.name;
              return e5 ? !o3.has(e5) : (_2("media-embed-no-provider-name", { provider: t5 }), false);
            });
            this.locale = t4, this.providerDefinitions = r3;
          }
          hasMedia(t4) {
            return !!this._getMedia(t4);
          }
          getMediaViewElement(t4, e4, n3) {
            return this._getMedia(e4).getViewElement(t4, n3);
          }
          _getMedia(t4) {
            if (!t4)
              return new WE(this.locale);
            t4 = t4.trim();
            for (const e4 of this.providerDefinitions) {
              const n3 = e4.html, i3 = yo2(e4.url);
              for (const e5 of i3) {
                const i4 = this._getUrlMatches(t4, e5);
                if (i4)
                  return new WE(this.locale, t4, i4, n3);
              }
            }
            return null;
          }
          _getUrlMatches(t4, e4) {
            let n3 = t4.match(e4);
            if (n3)
              return n3;
            let i3 = t4.replace(/^https?:\/\//, "");
            return n3 = i3.match(e4), n3 || (i3 = i3.replace(/^www\./, ""), n3 = i3.match(e4), n3 || null);
          }
        }
        class WE {
          constructor(t4, e4, n3, i3) {
            this.url = this._getValidUrl(e4), this._locale = t4, this._match = n3, this._previewRenderer = i3;
          }
          getViewElement(t4, e4) {
            const n3 = {};
            let i3;
            if (e4.renderForEditingView || e4.renderMediaPreview && this.url && this._previewRenderer) {
              this.url && (n3["data-oembed-url"] = this.url), e4.renderForEditingView && (n3.class = "ck-media__wrapper");
              const o3 = this._getPreviewHtml(e4);
              i3 = t4.createRawElement("div", n3, (t5, e5) => {
                e5.setContentOf(t5, o3);
              });
            } else
              this.url && (n3.url = this.url), i3 = t4.createEmptyElement(e4.elementName, n3);
            return t4.setCustomProperty("media-content", true, i3), i3;
          }
          _getPreviewHtml(t4) {
            return this._previewRenderer ? this._previewRenderer(this._match) : this.url && t4.renderForEditingView ? this._getPlaceholderHtml() : "";
          }
          _getPlaceholderHtml() {
            const t4 = new gr(), e4 = this._locale.t;
            t4.content = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>', t4.viewBox = "0 0 64 42";
            return new Uo2({ tag: "div", attributes: { class: "ck ck-reset_all ck-media__placeholder" }, children: [{ tag: "div", attributes: { class: "ck-media__placeholder__icon" }, children: [t4] }, { tag: "a", attributes: { class: "ck-media__placeholder__url", target: "_blank", rel: "noopener noreferrer", href: this.url, "data-cke-tooltip-text": e4("Open media in new tab") }, children: [{ tag: "span", attributes: { class: "ck-media__placeholder__url__text" }, children: [this.url] }] }] }).render().outerHTML;
          }
          _getValidUrl(t4) {
            return t4 ? t4.match(/^https?/) ? t4 : "https://" + t4 : null;
          }
        }
        var qE = n2(1922), $E = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(qE.Z, $E);
        qE.Z.locals;
        class KE extends bs {
          static get pluginName() {
            return "MediaEmbedEditing";
          }
          constructor(t4) {
            super(t4), t4.config.define("mediaEmbed", { elementName: "oembed", providers: [{ name: "dailymotion", url: /^dailymotion\.com\/video\/(\w+)/, html: (t5) => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t5[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>` }, { name: "spotify", url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/], html: (t5) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t5[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>` }, { name: "youtube", url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/], html: (t5) => {
              const e4 = t5[1], n3 = t5[2];
              return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${e4}${n3 ? `?start=${n3}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`;
            } }, { name: "vimeo", url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/], html: (t5) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t5[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>` }, { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ }, { name: "twitter", url: /^twitter\.com/ }, { name: "googleMaps", url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/] }, { name: "flickr", url: /^flickr\.com/ }, { name: "facebook", url: /^facebook\.com/ }] }), this.registry = new GE(t4.locale, t4.config.get("mediaEmbed"));
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.t, i3 = t4.conversion, o3 = t4.config.get("mediaEmbed.previewsInData"), r3 = t4.config.get("mediaEmbed.elementName"), s3 = this.registry;
            t4.commands.add("mediaEmbed", new UE(t4)), e4.register("media", { inheritAllFrom: "$blockObject", allowAttributes: ["url"] }), i3.for("dataDowncast").elementToStructure({ model: "media", view: (t5, { writer: e5 }) => {
              const n4 = t5.getAttribute("url");
              return VE(e5, s3, n4, { elementName: r3, renderMediaPreview: !!n4 && o3 });
            } }), i3.for("dataDowncast").add(FE(s3, { elementName: r3, renderMediaPreview: o3 })), i3.for("editingDowncast").elementToStructure({ model: "media", view: (t5, { writer: e5 }) => {
              const i4 = t5.getAttribute("url");
              return function(t6, e6, n4) {
                return e6.setCustomProperty("media", true, t6), Hb2(t6, e6, { label: n4 });
              }(VE(e5, s3, i4, { elementName: r3, renderForEditingView: true }), e5, n3("media widget"));
            } }), i3.for("editingDowncast").add(FE(s3, { elementName: r3, renderForEditingView: true })), i3.for("upcast").elementToElement({ view: (t5) => ["oembed", r3].includes(t5.name) && t5.getAttribute("url") ? { name: true } : null, model: (t5, { writer: e5 }) => {
              const n4 = t5.getAttribute("url");
              return s3.hasMedia(n4) ? e5.createElement("media", { url: n4 }) : null;
            } }).elementToElement({ view: { name: "div", attributes: { "data-oembed-url": true } }, model: (t5, { writer: e5 }) => {
              const n4 = t5.getAttribute("data-oembed-url");
              return s3.hasMedia(n4) ? e5.createElement("media", { url: n4 }) : null;
            } }).add((t5) => {
              t5.on("element:figure", (t6, e5, n4) => {
                if (!n4.consumable.consume(e5.viewItem, { name: true, classes: "media" }))
                  return;
                const { modelRange: i4, modelCursor: o4 } = n4.convertChildren(e5.viewItem, e5.modelCursor);
                e5.modelRange = i4, e5.modelCursor = o4;
                So2(i4.getItems()) || n4.consumable.revert(e5.viewItem, { name: true, classes: "media" });
              });
            });
          }
        }
        const ZE = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
        class YE extends bs {
          static get requires() {
            return [Rw, ek2, Xw];
          }
          static get pluginName() {
            return "AutoMediaEmbed";
          }
          constructor(t4) {
            super(t4), this._timeoutId = null, this._positionToInsert = null;
          }
          init() {
            const t4 = this.editor, e4 = t4.model.document, n3 = t4.plugins.get("ClipboardPipeline");
            this.listenTo(n3, "inputTransformation", () => {
              const t5 = e4.selection.getFirstRange(), n4 = Xh2.fromPosition(t5.start);
              n4.stickiness = "toPrevious";
              const i3 = Xh2.fromPosition(t5.end);
              i3.stickiness = "toNext", e4.once("change:data", () => {
                this._embedMediaBetweenPositions(n4, i3), n4.detach(), i3.detach();
              }, { priority: "high" });
            });
            t4.commands.get("undo").on("execute", () => {
              this._timeoutId && (Li2.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
            }, { priority: "high" });
          }
          _embedMediaBetweenPositions(t4, e4) {
            const n3 = this.editor, i3 = n3.plugins.get(KE).registry, o3 = new md2(t4, e4), r3 = o3.getWalker({ ignoreElementEnd: true });
            let s3 = "";
            for (const t5 of r3)
              t5.item.is("$textProxy") && (s3 += t5.item.data);
            if (s3 = s3.trim(), !s3.match(ZE))
              return void o3.detach();
            if (!i3.hasMedia(s3))
              return void o3.detach();
            n3.commands.get("mediaEmbed").isEnabled ? (this._positionToInsert = Xh2.fromPosition(t4), this._timeoutId = Li2.window.setTimeout(() => {
              n3.model.change((t5) => {
                this._timeoutId = null, t5.remove(o3), o3.detach();
                let e5 = null;
                "$graveyard" !== this._positionToInsert.root.rootName && (e5 = this._positionToInsert), HE(n3.model, s3, e5, false), this._positionToInsert.detach(), this._positionToInsert = null;
              }), n3.plugins.get(ek2).requestUndoOnBackspace();
            }, 100)) : o3.detach();
          }
        }
        var QE = n2(7138), JE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(QE.Z, JE);
        QE.Z.locals;
        class XE extends Ho2 {
          constructor(t4, e4) {
            super(e4);
            const n3 = e4.t;
            this.focusTracker = new To2(), this.keystrokes = new Io2(), this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n3("Save"), Pg2.check, "ck-button-save"), this.saveButtonView.type = "submit", this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (t5) => !!t5), this.cancelButtonView = this._createButton(n3("Cancel"), Pg2.cancel, "ck-button-cancel", "cancel"), this._focusables = new Ro2(), this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this._validators = t4, this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.urlInputView, this.saveButtonView, this.cancelButtonView] });
          }
          render() {
            super.render(), o2({ view: this });
            [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach((t5) => {
              this._focusables.add(t5), this.focusTracker.add(t5.element);
            }), this.keystrokes.listenTo(this.element);
            const t4 = (t5) => t5.stopPropagation();
            this.keystrokes.set("arrowright", t4), this.keystrokes.set("arrowleft", t4), this.keystrokes.set("arrowup", t4), this.keystrokes.set("arrowdown", t4);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          get url() {
            return this.urlInputView.fieldView.element.value.trim();
          }
          set url(t4) {
            this.urlInputView.fieldView.element.value = t4.trim();
          }
          isValid() {
            this.resetFormStatus();
            for (const t4 of this._validators) {
              const e4 = t4(this);
              if (e4)
                return this.urlInputView.errorText = e4, false;
            }
            return true;
          }
          resetFormStatus() {
            this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault;
          }
          _createUrlInput() {
            const t4 = this.locale.t, e4 = new Xr(this.locale, hm), n3 = e4.fieldView;
            return this._urlInputViewInfoDefault = t4("Paste the media URL in the input."), this._urlInputViewInfoTip = t4("Tip: Paste the URL into the content to embed faster."), e4.label = t4("Media URL"), e4.infoText = this._urlInputViewInfoDefault, n3.on("input", () => {
              e4.infoText = n3.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = n3.element.value.trim();
            }), e4;
          }
          _createButton(t4, e4, n3, i3) {
            const o3 = new kr(this.locale);
            return o3.set({ label: t4, icon: e4, tooltip: true }), o3.extendTemplate({ attributes: { class: n3 } }), i3 && o3.delegate("execute").to(this, i3), o3;
          }
        }
        class tD extends bs {
          static get requires() {
            return [KE];
          }
          static get pluginName() {
            return "MediaEmbedUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.commands.get("mediaEmbed");
            t4.ui.componentFactory.add("mediaEmbed", (t5) => {
              const n3 = om(t5);
              return this._setUpDropdown(n3, e4), n3;
            });
          }
          _setUpDropdown(t4, n3) {
            const i3 = this.editor, o3 = i3.t, r3 = t4.buttonView, s3 = i3.plugins.get(KE).registry;
            t4.once("change:isOpen", () => {
              const o4 = new (e3(XE))(function(t5, e4) {
                return [(e5) => {
                  if (!e5.url.length)
                    return t5("The URL must not be empty.");
                }, (n4) => {
                  if (!e4.hasMedia(n4.url))
                    return t5("This media URL is not supported.");
                }];
              }(i3.t, s3), i3.locale);
              t4.panelView.children.add(o4), r3.on("open", () => {
                o4.disableCssTransitions(), o4.url = n3.value || "", o4.urlInputView.fieldView.select(), o4.enableCssTransitions();
              }, { priority: "low" }), t4.on("submit", () => {
                o4.isValid() && (i3.execute("mediaEmbed", o4.url), i3.editing.view.focus());
              }), t4.on("change:isOpen", () => o4.resetFormStatus()), t4.on("cancel", () => {
                i3.editing.view.focus();
              }), o4.delegate("submit", "cancel").to(t4), o4.urlInputView.fieldView.bind("value").to(n3, "value"), o4.urlInputView.bind("isEnabled").to(n3, "isEnabled");
            }), t4.bind("isEnabled").to(n3), r3.set({ label: o3("Insert media"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>', tooltip: true });
          }
        }
        var eD = n2(8705), nD = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(eD.Z, nD);
        eD.Z.locals;
        class iD extends As {
          constructor(t4) {
            super(t4), this._isEnabledBasedOnSelection = false;
          }
          refresh() {
            const t4 = this.editor.model, e4 = t4.document;
            this.isEnabled = t4.schema.checkAttributeInSelection(e4.selection, "mention");
          }
          execute(t4) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = "string" == typeof t4.mention ? { id: t4.mention } : t4.mention, o3 = i3.id, r3 = t4.range || n3.getFirstRange();
            if (!e4.canEditAt(r3))
              return;
            const s3 = t4.text || o3, a3 = rD({ _text: s3, id: o3 }, i3);
            if (1 != t4.marker.length)
              throw new C2("mentioncommand-incorrect-marker", this);
            if (o3.charAt(0) != t4.marker)
              throw new C2("mentioncommand-incorrect-id", this);
            e4.change((t5) => {
              const i4 = Bo2(n3.getAttributes()), o4 = new Map(i4.entries());
              o4.set("mention", a3), e4.insertContent(t5.createText(s3, o4), r3), e4.insertContent(t5.createText(" ", i4), r3.start.getShiftedBy(s3.length));
            });
          }
        }
        class oD extends bs {
          static get pluginName() {
            return "MentionEditing";
          }
          init() {
            const t4 = this.editor, e4 = t4.model, n3 = e4.document;
            e4.schema.extend("$text", { allowAttributes: "mention" }), t4.conversion.for("upcast").elementToAttribute({ view: { name: "span", key: "data-mention", classes: "mention" }, model: { key: "mention", value: (t5) => sD(t5) } }), t4.conversion.for("downcast").attributeToElement({ model: "mention", view: cD }), t4.conversion.for("downcast").add(aD), n3.registerPostFixer((t5) => function(t6, e5, n4) {
              const i3 = e5.differ.getChanges();
              let o3 = false;
              for (const e6 of i3) {
                if ("attribute" == e6.type)
                  continue;
                const i4 = e6.position;
                if ("$text" == e6.name) {
                  const e7 = i4.textNode && i4.textNode.nextSibling;
                  o3 = dD(i4.textNode, t6) || o3, o3 = dD(e7, t6) || o3, o3 = dD(i4.nodeBefore, t6) || o3, o3 = dD(i4.nodeAfter, t6) || o3;
                }
                if ("$text" != e6.name && "insert" == e6.type) {
                  const e7 = i4.nodeAfter;
                  for (const n5 of t6.createRangeIn(e7).getItems())
                    o3 = dD(n5, t6) || o3;
                }
                if ("insert" == e6.type && n4.isInline(e6.name)) {
                  const e7 = i4.nodeAfter && i4.nodeAfter.nextSibling;
                  o3 = dD(i4.nodeBefore, t6) || o3, o3 = dD(e7, t6) || o3;
                }
              }
              return o3;
            }(t5, n3, e4.schema)), n3.registerPostFixer((t5) => function(t6, e5) {
              const n4 = e5.differ.getChanges();
              let i3 = false;
              for (const e6 of n4)
                if ("attribute" === e6.type && "mention" != e6.attributeKey) {
                  const n5 = e6.range.start.nodeBefore, o3 = e6.range.end.nodeAfter;
                  for (const r3 of [n5, o3])
                    lD(r3) && r3.getAttribute(e6.attributeKey) != e6.attributeNewValue && (t6.setAttribute(e6.attributeKey, e6.attributeNewValue, r3), i3 = true);
                }
              return i3;
            }(t5, n3)), n3.registerPostFixer((t5) => function(t6, e5) {
              const n4 = e5.selection, i3 = n4.focus;
              if (n4.isCollapsed && n4.hasAttribute("mention") && function(t7) {
                const e6 = t7.isAtStart;
                return t7.nodeBefore && t7.nodeBefore.is("$text") || e6;
              }(i3))
                return t6.removeSelectionAttribute("mention"), true;
              return false;
            }(t5, n3)), t4.commands.add("mention", new iD(t4));
          }
        }
        function rD(t4, e4) {
          return Object.assign({ uid: k2() }, t4, e4 || {});
        }
        function sD(t4, e4) {
          const n3 = t4.getAttribute("data-mention"), i3 = t4.getChild(0);
          if (!i3)
            return;
          return rD({ id: n3, _text: i3.data }, e4);
        }
        function aD(t4) {
          t4.on("attribute:mention", (t5, e4, n3) => {
            const i3 = e4.attributeNewValue;
            if (!e4.item.is("$textProxy") || !i3)
              return;
            const o3 = e4.range.start;
            (o3.textNode || o3.nodeAfter).data != i3._text && n3.consumable.consume(e4.item, t5.name);
          }, { priority: "highest" });
        }
        function cD(t4, { writer: e4 }) {
          if (!t4)
            return;
          const n3 = { class: "mention", "data-mention": t4.id }, i3 = { id: t4.uid, priority: 20 };
          return e4.createAttributeElement("span", n3, i3);
        }
        function lD(t4) {
          if (!t4 || !t4.is("$text") && !t4.is("$textProxy") || !t4.hasAttribute("mention"))
            return false;
          return t4.data != t4.getAttribute("mention")._text;
        }
        function dD(t4, e4) {
          return !!lD(t4) && (e4.removeAttribute("mention", t4), true);
        }
        var hD = n2(9139), uD = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(hD.Z, uD);
        hD.Z.locals;
        class gD extends Kg2 {
          constructor(t4) {
            super(t4), this.extendTemplate({ attributes: { class: ["ck-mentions"], tabindex: "-1" } });
          }
          selectFirst() {
            this.select(0);
          }
          selectNext() {
            const t4 = this.selected, e4 = this.items.getIndex(t4);
            this.select(e4 + 1);
          }
          selectPrevious() {
            const t4 = this.selected, e4 = this.items.getIndex(t4);
            this.select(e4 - 1);
          }
          select(t4) {
            let e4 = 0;
            t4 > 0 && t4 < this.items.length ? e4 = t4 : t4 < 0 && (e4 = this.items.length - 1);
            const n3 = this.items.get(e4);
            this.selected !== n3 && (this.selected && this.selected.removeHighlight(), n3.highlight(), this.selected = n3, this._isItemVisibleInScrolledArea(n3) || (this.element.scrollTop = n3.element.offsetTop));
          }
          executeSelected() {
            this.selected.fire("execute");
          }
          _isItemVisibleInScrolledArea(t4) {
            return new Vi2(this.element).contains(new Vi2(t4.element));
          }
        }
        class mD extends Ho2 {
          constructor(t4, e4) {
            super(t4), this.template = void 0, this.domElement = e4, this.domElement.classList.add("ck-button"), this.set("isOn", false), this.on("change:isOn", (t5, e5, n3) => {
              n3 ? (this.domElement.classList.add("ck-on"), this.domElement.classList.remove("ck-off")) : (this.domElement.classList.add("ck-off"), this.domElement.classList.remove("ck-on"));
            }), this.listenTo(this.domElement, "click", () => {
              this.fire("execute");
            });
          }
          render() {
            super.render(), this.element = this.domElement;
          }
          focus() {
            this.domElement.focus();
          }
        }
        class pD extends Zg2 {
          highlight() {
            this.children.first.isOn = true;
          }
          removeHighlight() {
            this.children.first.isOn = false;
          }
        }
        const fD = [fo2.arrowup, fo2.arrowdown, fo2.esc], kD = [fo2.enter, fo2.tab];
        class bD extends bs {
          static get pluginName() {
            return "MentionUI";
          }
          static get requires() {
            return [Yp];
          }
          constructor(t4) {
            super(t4), this._items = new Do2(), this._mentionsView = this._createMentionView(), this._mentionsConfigurations = /* @__PURE__ */ new Map(), this._requestFeedDebounced = $r(this._requestFeed, 100), t4.config.define("mention", { feeds: [] });
          }
          init() {
            const e4 = this.editor, n3 = e4.config.get("mention.commitKeys") || kD, i3 = fD.concat(n3);
            this._balloon = e4.plugins.get(Yp), e4.editing.view.document.on("keydown", (t4, e5) => {
              var o4;
              o4 = e5.keyCode, i3.includes(o4) && this._isUIVisible && (e5.preventDefault(), t4.stop(), e5.keyCode == fo2.arrowdown && this._mentionsView.selectNext(), e5.keyCode == fo2.arrowup && this._mentionsView.selectPrevious(), n3.includes(e5.keyCode) && this._mentionsView.executeSelected(), e5.keyCode == fo2.esc && this._hideUIAndRemoveMarker());
            }, { priority: "highest" }), t3({ emitter: this._mentionsView, activator: () => this._isUIVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideUIAndRemoveMarker() });
            const o3 = e4.config.get("mention.feeds");
            for (const t4 of o3) {
              const { feed: e5, marker: n4, dropdownLimit: i4 } = t4;
              if (!vD(n4))
                throw new C2("mentionconfig-incorrect-marker", null, { marker: n4 });
              const o4 = { marker: n4, feedCallback: "function" == typeof e5 ? e5.bind(this.editor) : _D(e5), itemRenderer: t4.itemRenderer, dropdownLimit: i4 };
              this._mentionsConfigurations.set(n4, o4);
            }
            this._setupTextWatcher(o3), this.listenTo(e4, "change:isReadOnly", () => {
              this._hideUIAndRemoveMarker();
            }), this.on("requestFeed:response", (t4, e5) => this._handleFeedResponse(e5)), this.on("requestFeed:error", () => this._hideUIAndRemoveMarker());
          }
          destroy() {
            super.destroy(), this._mentionsView.destroy();
          }
          get _isUIVisible() {
            return this._balloon.visibleView === this._mentionsView;
          }
          _createMentionView() {
            const t4 = this.editor.locale, e4 = new gD(t4);
            return e4.items.bindTo(this._items).using((n3) => {
              const { item: i3, marker: o3 } = n3, { dropdownLimit: r3 } = this._mentionsConfigurations.get(o3), s3 = r3 || this.editor.config.get("mention.dropdownLimit") || 10;
              if (e4.items.length >= s3)
                return null;
              const a3 = new pD(t4), c3 = this._renderItem(i3, o3);
              return c3.delegate("execute").to(a3), a3.children.add(c3), a3.item = i3, a3.marker = o3, a3.on("execute", () => {
                e4.fire("execute", { item: i3, marker: o3 });
              }), a3;
            }), e4.on("execute", (t5, e5) => {
              const n3 = this.editor, i3 = n3.model, o3 = e5.item, r3 = e5.marker, s3 = n3.model.markers.get("mention"), a3 = i3.createPositionAt(i3.document.selection.focus), c3 = i3.createPositionAt(s3.getStart()), l3 = i3.createRange(c3, a3);
              this._hideUIAndRemoveMarker(), n3.execute("mention", { mention: o3, text: o3.text, marker: r3, range: l3 }), n3.editing.view.focus();
            }), e4;
          }
          _getItemRenderer(t4) {
            const { itemRenderer: e4 } = this._mentionsConfigurations.get(t4);
            return e4;
          }
          _requestFeed(t4, e4) {
            this._lastRequested = e4;
            const { feedCallback: n3 } = this._mentionsConfigurations.get(t4), i3 = n3(e4);
            i3 instanceof Promise ? i3.then((n4) => {
              this._lastRequested == e4 ? this.fire("requestFeed:response", { feed: n4, marker: t4, feedText: e4 }) : this.fire("requestFeed:discarded", { feed: n4, marker: t4, feedText: e4 });
            }).catch((e5) => {
              this.fire("requestFeed:error", { error: e5 }), _2("mention-feed-callback-error", { marker: t4 });
            }) : this.fire("requestFeed:response", { feed: i3, marker: t4, feedText: e4 });
          }
          _setupTextWatcher(t4) {
            const e4 = this.editor, n3 = t4.map((t5) => ({ ...t5, pattern: CD(t5.marker, t5.minimumCharacters || 0) })), i3 = new ok2(e4.model, function(t5) {
              const e5 = (e6) => {
                const n4 = AD(t5, e6);
                if (!n4)
                  return false;
                let i4 = 0;
                0 !== n4.position && (i4 = n4.position - 1);
                const o4 = e6.substring(i4);
                return n4.pattern.test(o4);
              };
              return e5;
            }(n3));
            i3.on("matched", (t5, i4) => {
              const o4 = AD(n3, i4.text), r3 = e4.model.document.selection.focus, s3 = e4.model.createPositionAt(r3.parent, o4.position);
              if (function(t6) {
                const e5 = t6.textNode && t6.textNode.hasAttribute("mention"), n4 = t6.nodeBefore;
                return e5 || n4 && n4.is("$text") && n4.hasAttribute("mention");
              }(r3) || function(t6) {
                const e5 = t6.nodeAfter;
                return e5 && e5.is("$text") && e5.hasAttribute("mention");
              }(s3))
                return void this._hideUIAndRemoveMarker();
              const a3 = function(t6, e5) {
                let n4 = 0;
                0 !== t6.position && (n4 = t6.position - 1);
                const i5 = CD(t6.marker, 0), o5 = e5.substring(n4);
                return o5.match(i5)[2];
              }(o4, i4.text), c3 = o4.marker.length + a3.length, l3 = r3.getShiftedBy(-c3), d3 = r3.getShiftedBy(-a3.length), h3 = e4.model.createRange(l3, d3);
              if (yD(e4)) {
                const t6 = e4.model.markers.get("mention");
                e4.model.change((e5) => {
                  e5.updateMarker(t6, { range: h3 });
                });
              } else
                e4.model.change((t6) => {
                  t6.addMarker("mention", { range: h3, usingOperation: false, affectsData: false });
                });
              this._requestFeedDebounced(o4.marker, a3);
            }), i3.on("unmatched", () => {
              this._hideUIAndRemoveMarker();
            });
            const o3 = e4.commands.get("mention");
            return i3.bind("isEnabled").to(o3), i3;
          }
          _handleFeedResponse(t4) {
            const { feed: e4, marker: n3 } = t4;
            if (!yD(this.editor))
              return;
            this._items.clear();
            for (const t5 of e4) {
              const e5 = "object" != typeof t5 ? { id: t5, text: t5 } : t5;
              this._items.add({ item: e5, marker: n3 });
            }
            const i3 = this.editor.model.markers.get("mention");
            this._items.length ? this._showOrUpdateUI(i3) : this._hideUIAndRemoveMarker();
          }
          _showOrUpdateUI(t4) {
            this._isUIVisible ? this._balloon.updatePosition(this._getBalloonPanelPositionData(t4, this._mentionsView.position)) : this._balloon.add({ view: this._mentionsView, position: this._getBalloonPanelPositionData(t4, this._mentionsView.position), singleViewMode: true }), this._mentionsView.position = this._balloon.view.position, this._mentionsView.selectFirst();
          }
          _hideUIAndRemoveMarker() {
            this._balloon.hasView(this._mentionsView) && this._balloon.remove(this._mentionsView), yD(this.editor) && this.editor.model.change((t4) => t4.removeMarker("mention")), this._mentionsView.position = void 0;
          }
          _renderItem(t4, e4) {
            const n3 = this.editor;
            let i3, o3 = t4.id;
            const r3 = this._getItemRenderer(e4);
            if (r3) {
              const e5 = r3(t4);
              "string" != typeof e5 ? i3 = new mD(n3.locale, e5) : o3 = e5;
            }
            if (!i3) {
              const t5 = new kr(n3.locale);
              t5.label = o3, t5.withText = true, i3 = t5;
            }
            return i3;
          }
          _getBalloonPanelPositionData(t4, e4) {
            const n3 = this.editor, i3 = n3.editing, o3 = i3.view.domConverter, r3 = i3.mapper;
            return { target: () => {
              let e5 = t4.getRange();
              "$graveyard" == e5.start.root.rootName && (e5 = n3.model.document.selection.getFirstRange());
              const i4 = r3.toViewRange(e5);
              return Vi2.getDomRangeRects(o3.viewRangeToDom(i4)).pop();
            }, limiter: () => {
              const t5 = this.editor.editing.view, e5 = t5.document.selection.editableElement;
              return e5 ? t5.domConverter.mapViewToDom(e5.root) : null;
            }, positions: wD(e4, n3.locale.uiLanguageDirection) };
          }
        }
        function wD(t4, e4) {
          const n3 = { caret_se: (t5) => ({ top: t5.bottom + 3, left: t5.right, name: "caret_se", config: { withArrow: false } }), caret_ne: (t5, e5) => ({ top: t5.top - e5.height - 3, left: t5.right, name: "caret_ne", config: { withArrow: false } }), caret_sw: (t5, e5) => ({ top: t5.bottom + 3, left: t5.right - e5.width, name: "caret_sw", config: { withArrow: false } }), caret_nw: (t5, e5) => ({ top: t5.top - e5.height - 3, left: t5.right - e5.width, name: "caret_nw", config: { withArrow: false } }) };
          return Object.prototype.hasOwnProperty.call(n3, t4) ? [n3[t4]] : "rtl" !== e4 ? [n3.caret_se, n3.caret_sw, n3.caret_ne, n3.caret_nw] : [n3.caret_sw, n3.caret_se, n3.caret_nw, n3.caret_ne];
        }
        function AD(t4, e4) {
          let n3;
          for (const i3 of t4) {
            const t5 = e4.lastIndexOf(i3.marker);
            t5 > 0 && !e4.substring(t5 - 1).match(i3.pattern) || (!n3 || t5 >= n3.position) && (n3 = { marker: i3.marker, position: t5, minimumCharacters: i3.minimumCharacters, pattern: i3.pattern });
          }
          return n3;
        }
        function CD(t4, e4) {
          const n3 = 0 == e4 ? "*" : `{${e4},}`, i3 = c2.features.isRegExpUnicodePropertySupported ? `\\p{Ps}\\p{Pi}"'` : `\\(\\[{"'`;
          return new RegExp(`(?:^|[ ${i3}])([${t4}])(.${n3})$`, "u");
        }
        function _D(t4) {
          return (e4) => t4.filter((t5) => ("string" == typeof t5 ? t5 : String(t5.id)).toLowerCase().includes(e4.toLowerCase()));
        }
        function vD(t4) {
          return t4 && 1 == t4.length;
        }
        function yD(t4) {
          return t4.model.markers.has("mention");
        }
        var xD = n2(8544), ED = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(xD.Z, ED);
        xD.Z.locals;
        function DD(t4, e4) {
          if (!t4.childCount)
            return;
          const n3 = new ju(t4.document), i3 = function(t5, e5) {
            const n4 = e5.createRangeIn(t5), i4 = new Vs({ name: /^p|h\d+$/, styles: { "mso-list": /.*/ } }), o4 = [];
            for (const t6 of n4)
              if ("elementStart" === t6.type && i4.match(t6.item)) {
                const e6 = ID(t6.item);
                o4.push({ element: t6.item, id: e6.id, order: e6.order, indent: e6.indent });
              }
            return o4;
          }(t4, n3);
          if (!i3.length)
            return;
          let o3 = null, r3 = 1;
          i3.forEach((t5, s3) => {
            const a3 = function(t6, e5) {
              if (!t6)
                return true;
              if (t6.id !== e5.id)
                return e5.indent - t6.indent != 1;
              const n4 = e5.element.previousSibling;
              if (!n4)
                return true;
              return i4 = n4, !(i4.is("element", "ol") || i4.is("element", "ul"));
              var i4;
            }(i3[s3 - 1], t5), c3 = a3 ? null : i3[s3 - 1], l3 = (h3 = t5, (d3 = c3) ? h3.indent - d3.indent : h3.indent - 1);
            var d3, h3;
            if (a3 && (o3 = null, r3 = 1), !o3 || 0 !== l3) {
              const i4 = function(t6, e5) {
                const n4 = new RegExp(`@list l${t6.id}:level${t6.indent}\\s*({[^}]*)`, "gi"), i5 = /mso-level-number-format:([^;]{0,100});/gi, o4 = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi, r4 = n4.exec(e5);
                let s4 = "decimal", a4 = "ol", c4 = null;
                if (r4 && r4[1]) {
                  const e6 = i5.exec(r4[1]);
                  if (e6 && e6[1] && (s4 = e6[1].trim(), a4 = "bullet" !== s4 && "image" !== s4 ? "ol" : "ul"), "bullet" === s4) {
                    const e7 = function(t7) {
                      const e8 = function(t8) {
                        if (t8.getChild(0).is("$text"))
                          return null;
                        for (const e9 of t8.getChildren()) {
                          if (!e9.is("element", "span"))
                            continue;
                          const t9 = e9.getChild(0);
                          if (t9)
                            return t9.is("$text") ? t9 : t9.getChild(0);
                        }
                        return null;
                      }(t7);
                      if (!e8)
                        return null;
                      const n5 = e8._data;
                      if ("o" === n5)
                        return "circle";
                      if ("" === n5)
                        return "disc";
                      if ("" === n5)
                        return "square";
                      return null;
                    }(t6.element);
                    e7 && (s4 = e7);
                  } else {
                    const t7 = o4.exec(r4[1]);
                    t7 && t7[1] && (c4 = parseInt(t7[1]));
                  }
                }
                return { type: a4, startIndex: c4, style: SD(s4) };
              }(t5, e4);
              if (o3) {
                if (t5.indent > r3) {
                  const t6 = o3.getChild(o3.childCount - 1), e5 = t6.getChild(t6.childCount - 1);
                  o3 = TD(i4, e5, n3), r3 += 1;
                } else if (t5.indent < r3) {
                  const e5 = r3 - t5.indent;
                  o3 = function(t6, e6) {
                    const n4 = t6.getAncestors({ parentFirst: true });
                    let i5 = null, o4 = 0;
                    for (const t7 of n4)
                      if ((t7.is("element", "ul") || t7.is("element", "ol")) && o4++, o4 === e6) {
                        i5 = t7;
                        break;
                      }
                    return i5;
                  }(o3, e5), r3 = t5.indent;
                }
              } else
                o3 = TD(i4, t5.element, n3);
              t5.indent <= r3 && (o3.is("element", i4.type) || (o3 = n3.rename(i4.type, o3)));
            }
            const u3 = function(t6, e5) {
              return function(t7, e6) {
                const n4 = new Vs({ name: "span", styles: { "mso-list": "Ignore" } }), i4 = e6.createRangeIn(t7);
                for (const t8 of i4)
                  "elementStart" === t8.type && n4.match(t8.item) && e6.remove(t8.item);
              }(t6, e5), e5.removeStyle("text-indent", t6), e5.rename("li", t6);
            }(t5.element, n3);
            n3.appendChild(u3, o3);
          });
        }
        function SD(t4) {
          if (t4.startsWith("arabic-leading-zero"))
            return "decimal-leading-zero";
          switch (t4) {
            case "alpha-upper":
              return "upper-alpha";
            case "alpha-lower":
              return "lower-alpha";
            case "roman-upper":
              return "upper-roman";
            case "roman-lower":
              return "lower-roman";
            case "circle":
            case "disc":
            case "square":
              return t4;
            default:
              return null;
          }
        }
        function TD(t4, e4, n3) {
          const i3 = e4.parent, o3 = n3.createElement(t4.type), r3 = i3.getChildIndex(e4) + 1;
          return n3.insertChild(r3, o3, i3), t4.style && n3.setStyle("list-style-type", t4.style, o3), t4.startIndex && t4.startIndex > 1 && n3.setAttribute("start", t4.startIndex, o3), o3;
        }
        function ID(t4) {
          const e4 = {}, n3 = t4.getStyle("mso-list");
          if (n3) {
            const t5 = n3.match(/(^|\s{1,100})l(\d+)/i), i3 = n3.match(/\s{0,100}lfo(\d+)/i), o3 = n3.match(/\s{0,100}level(\d+)/i);
            t5 && i3 && o3 && (e4.id = t5[2], e4.order = i3[1], e4.indent = parseInt(o3[1]));
          }
          return e4;
        }
        function BD(t4, e4) {
          if (!t4.childCount)
            return;
          const n3 = new ju(t4.document), i3 = function(t5, e5) {
            const n4 = e5.createRangeIn(t5), i4 = new Vs({ name: /v:(.+)/ }), o4 = [];
            for (const t6 of n4) {
              if ("elementStart" != t6.type)
                continue;
              const e6 = t6.item, n5 = e6.previousSibling, r3 = n5 && n5.is("element") ? n5.name : null;
              i4.match(e6) && e6.getAttribute("o:gfxdata") && "v:shapetype" !== r3 && o4.push(t6.item.getAttribute("id"));
            }
            return o4;
          }(t4, n3);
          !function(t5, e5, n4) {
            const i4 = n4.createRangeIn(e5), o4 = new Vs({ name: "img" }), r3 = [];
            for (const e6 of i4)
              if (e6.item.is("element") && o4.match(e6.item)) {
                const n5 = e6.item, i5 = n5.getAttribute("v:shapes") ? n5.getAttribute("v:shapes").split(" ") : [];
                i5.length && i5.every((e7) => t5.indexOf(e7) > -1) ? r3.push(n5) : n5.getAttribute("src") || r3.push(n5);
              }
            for (const t6 of r3)
              n4.remove(t6);
          }(i3, t4, n3), function(t5, e5, n4) {
            const i4 = n4.createRangeIn(e5), o4 = [];
            for (const e6 of i4)
              if ("elementStart" == e6.type && e6.item.is("element", "v:shape")) {
                const n5 = e6.item.getAttribute("id");
                if (t5.includes(n5))
                  continue;
                r3(e6.item.parent.getChildren(), n5) || o4.push(e6.item);
              }
            for (const t6 of o4) {
              const e6 = { src: s3(t6) };
              t6.hasAttribute("alt") && (e6.alt = t6.getAttribute("alt"));
              const i5 = n4.createElement("img", e6);
              n4.insertChild(t6.index + 1, i5, t6.parent);
            }
            function r3(t6, e6) {
              for (const n5 of t6)
                if (n5.is("element")) {
                  if ("img" == n5.name && n5.getAttribute("v:shapes") == e6)
                    return true;
                  if (r3(n5.getChildren(), e6))
                    return true;
                }
              return false;
            }
            function s3(t6) {
              for (const e6 of t6.getChildren())
                if (e6.is("element") && e6.getAttribute("src"))
                  return e6.getAttribute("src");
            }
          }(i3, t4, n3), function(t5, e5) {
            const n4 = e5.createRangeIn(t5), i4 = new Vs({ name: /v:(.+)/ }), o4 = [];
            for (const t6 of n4)
              "elementStart" == t6.type && i4.match(t6.item) && o4.push(t6.item);
            for (const t6 of o4)
              e5.remove(t6);
          }(t4, n3);
          const o3 = function(t5, e5) {
            const n4 = e5.createRangeIn(t5), i4 = new Vs({ name: "img" }), o4 = [];
            for (const t6 of n4)
              t6.item.is("element") && i4.match(t6.item) && t6.item.getAttribute("src").startsWith("file://") && o4.push(t6.item);
            return o4;
          }(t4, n3);
          o3.length && function(t5, e5, n4) {
            if (t5.length === e5.length)
              for (let i4 = 0; i4 < t5.length; i4++) {
                const o4 = `data:${e5[i4].type};base64,${MD(e5[i4].hex)}`;
                n4.setAttribute("src", o4, t5[i4]);
              }
          }(o3, function(t5) {
            if (!t5)
              return [];
            const e5 = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, n4 = new RegExp("(?:(" + e5.source + "))([\\da-fA-F\\s]+)\\}", "g"), i4 = t5.match(n4), o4 = [];
            if (i4)
              for (const t6 of i4) {
                let n5 = false;
                t6.includes("\\pngblip") ? n5 = "image/png" : t6.includes("\\jpegblip") && (n5 = "image/jpeg"), n5 && o4.push({ hex: t6.replace(e5, "").replace(/[^\da-fA-F]/g, ""), type: n5 });
              }
            return o4;
          }(e4), n3);
        }
        function MD(t4) {
          return btoa(t4.match(/\w{2}/g).map((t5) => String.fromCharCode(parseInt(t5, 16))).join(""));
        }
        const ND = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i, LD = /xmlns:o="urn:schemas-microsoft-com/i;
        class zD {
          constructor(t4) {
            this.document = t4;
          }
          isActive(t4) {
            return ND.test(t4) || LD.test(t4);
          }
          execute(t4) {
            const { body: e4, stylesString: n3 } = t4._parsedData;
            DD(e4, n3), BD(e4, t4.dataTransfer.getData("text/rtf")), function(t5) {
              const e5 = [], n4 = new ju(t5.document);
              for (const { item: i3 } of n4.createRangeIn(t5))
                if (i3.is("element")) {
                  for (const t6 of i3.getClassNames())
                    /\bmso/gi.exec(t6) && n4.removeClass(t6, i3);
                  for (const t6 of i3.getStyleNames())
                    /\bmso/gi.exec(t6) && n4.removeStyle(t6, i3);
                  i3.is("element", "w:sdt") && e5.push(i3);
                }
              for (const t6 of e5) {
                const e6 = t6.parent, i3 = e6.getChildIndex(t6);
                n4.insertChild(i3, t6.getChildren(), e6), n4.remove(t6);
              }
            }(e4), t4.content = e4;
          }
        }
        function PD(t4, e4, n3, { blockElements: i3, inlineObjectElements: o3 }) {
          let r3 = n3.createPositionAt(t4, "forward" == e4 ? "after" : "before");
          return r3 = r3.getLastMatchingPosition(({ item: t5 }) => t5.is("element") && !i3.includes(t5.name) && !o3.includes(t5.name), { direction: e4 }), "forward" == e4 ? r3.nodeAfter : r3.nodeBefore;
        }
        function RD(t4, e4) {
          return !!t4 && t4.is("element") && e4.includes(t4.name);
        }
        const OD = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
        class FD {
          constructor(t4) {
            this.document = t4;
          }
          isActive(t4) {
            return OD.test(t4);
          }
          execute(t4) {
            const e4 = new ju(this.document), { body: n3 } = t4._parsedData;
            !function(t5, e5) {
              for (const n4 of t5.getChildren())
                if (n4.is("element", "b") && "normal" === n4.getStyle("font-weight")) {
                  const i3 = t5.getChildIndex(n4);
                  e5.remove(n4), e5.insertChild(i3, n4.getChildren(), t5);
                }
            }(n3, e4), function(t5, e5) {
              for (const n4 of e5.createRangeIn(t5)) {
                const t6 = n4.item;
                if (t6.is("element", "li")) {
                  const n5 = t6.getChild(0);
                  n5 && n5.is("element", "p") && e5.unwrapElement(n5);
                }
              }
            }(n3, e4), function(t5, e5) {
              const n4 = new rc2(e5.document.stylesProcessor), i3 = new Yc2(n4, { renderingMode: "data" }), o3 = i3.blockElements, r3 = i3.inlineObjectElements, s3 = [];
              for (const n5 of e5.createRangeIn(t5)) {
                const t6 = n5.item;
                if (t6.is("element", "br")) {
                  const n6 = PD(t6, "forward", e5, { blockElements: o3, inlineObjectElements: r3 }), i4 = PD(t6, "backward", e5, { blockElements: o3, inlineObjectElements: r3 }), a3 = RD(n6, o3);
                  (RD(i4, o3) || a3) && s3.push(t6);
                }
              }
              for (const t6 of s3)
                t6.hasClass("Apple-interchange-newline") ? e5.remove(t6) : e5.replace(t6, e5.createElement("p"));
            }(n3, e4), t4.content = n3;
          }
        }
        const VD = /<google-sheets-html-origin/i;
        class jD {
          constructor(t4) {
            this.document = t4;
          }
          isActive(t4) {
            return VD.test(t4);
          }
          execute(t4) {
            const e4 = new ju(this.document), { body: n3 } = t4._parsedData;
            !function(t5, e5) {
              for (const n4 of t5.getChildren())
                if (n4.is("element", "google-sheets-html-origin")) {
                  const i3 = t5.getChildIndex(n4);
                  e5.remove(n4), e5.insertChild(i3, n4.getChildren(), t5);
                }
            }(n3, e4), function(t5, e5) {
              for (const n4 of t5.getChildren())
                n4.is("element", "table") && n4.hasAttribute("xmlns") && e5.removeAttribute("xmlns", n4);
            }(n3, e4), function(t5, e5) {
              for (const n4 of t5.getChildren())
                n4.is("element", "table") && "0px" === n4.getStyle("width") && e5.removeStyle("width", n4);
            }(n3, e4), function(t5, e5) {
              for (const n4 of Array.from(t5.getChildren()))
                n4.is("element", "style") && e5.remove(n4);
            }(n3, e4), t4.content = n3;
          }
        }
        function HD(t4) {
          return t4.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t5, e4) => 1 === e4.length ? " " : Array(e4.length + 1).join(" ").substr(0, e4.length));
        }
        function UD(t4, e4) {
          const n3 = new DOMParser(), i3 = function(t5) {
            return HD(HD(t5)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, "</").replace(/ <o:p><\/o:p>/g, "<o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
          }(function(t5) {
            const e5 = "</body>", n4 = "</html>", i4 = t5.indexOf(e5);
            if (i4 < 0)
              return t5;
            const o4 = t5.indexOf(n4, i4 + e5.length);
            return t5.substring(0, i4 + e5.length) + (o4 >= 0 ? t5.substring(o4) : "");
          }(t4 = t4.replace(/<!--\[if gte vml 1]>/g, ""))), o3 = n3.parseFromString(i3, "text/html");
          !function(t5) {
            t5.querySelectorAll("span[style*=spacerun]").forEach((t6) => {
              const e5 = t6, n4 = e5.innerText.length || 0;
              e5.innerText = Array(n4 + 1).join(" ").substr(0, n4);
            });
          }(o3);
          const r3 = o3.body.innerHTML, s3 = function(t5, e5) {
            const n4 = new rc2(e5), i4 = new Yc2(n4, { renderingMode: "data" }), o4 = t5.createDocumentFragment(), r4 = t5.body.childNodes;
            for (; r4.length > 0; )
              o4.appendChild(r4[0]);
            return i4.domToView(o4, { skipComments: true });
          }(o3, e4), a3 = function(t5) {
            const e5 = [], n4 = [], i4 = Array.from(t5.getElementsByTagName("style"));
            for (const t6 of i4)
              t6.sheet && t6.sheet.cssRules && t6.sheet.cssRules.length && (e5.push(t6.sheet), n4.push(t6.innerHTML));
            return { styles: e5, stylesString: n4.join(" ") };
          }(o3);
          return { body: s3, bodyString: r3, styles: a3.styles, stylesString: a3.stylesString };
        }
        const GD = "removeFormat";
        class WD extends bs {
          static get pluginName() {
            return "RemoveFormatUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add(GD, (n3) => {
              const i3 = t4.commands.get(GD), o3 = new kr(n3);
              return o3.set({ label: e4("Remove Format"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.69 14.915c.053.052.173.083.36.093a.366.366 0 0 1 .345.485l-.003.01a.738.738 0 0 1-.697.497h-2.67a.374.374 0 0 1-.353-.496l.013-.038a.681.681 0 0 1 .644-.458c.197-.012.325-.043.386-.093a.28.28 0 0 0 .072-.11L9.592 4.5H6.269c-.359-.017-.609.013-.75.09-.142.078-.289.265-.442.563-.192.29-.516.464-.864.464H4.17a.43.43 0 0 1-.407-.569L4.46 3h13.08l-.62 2.043a.81.81 0 0 1-.775.574h-.114a.486.486 0 0 1-.486-.486c.001-.284-.054-.464-.167-.54-.112-.076-.367-.106-.766-.091h-3.28l-2.68 10.257c-.006.074.007.127.038.158zM3 17h8a.5.5 0 1 1 0 1H3a.5.5 0 1 1 0-1zm11.299 1.17a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.06-1.06l1.415 1.414 1.414-1.415a.75.75 0 1 1 1.06 1.06l-1.413 1.415 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414-1.414 1.414z"/></svg>', tooltip: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), this.listenTo(o3, "execute", () => {
                t4.execute(GD), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        class qD extends As {
          refresh() {
            const t4 = this.editor.model;
            this.isEnabled = !!So2(this._getFormattingItems(t4.document.selection, t4.schema));
          }
          execute() {
            const t4 = this.editor.model, e4 = t4.schema;
            t4.change((n3) => {
              for (const i3 of this._getFormattingItems(t4.document.selection, e4))
                if (i3.is("selection"))
                  for (const t5 of this._getFormattingAttributes(i3, e4))
                    n3.removeSelectionAttribute(t5);
                else {
                  const t5 = n3.createRangeOn(i3);
                  for (const o3 of this._getFormattingAttributes(i3, e4))
                    n3.removeAttribute(o3, t5);
                }
            });
          }
          *_getFormattingItems(t4, e4) {
            const n3 = (t5) => !!So2(this._getFormattingAttributes(t5, e4));
            for (const i3 of t4.getRanges())
              for (const t5 of i3.getItems())
                !e4.isBlock(t5) && n3(t5) && (yield t5);
            for (const e5 of t4.getSelectedBlocks())
              n3(e5) && (yield e5);
            n3(t4) && (yield t4);
          }
          *_getFormattingAttributes(t4, e4) {
            for (const [n3] of t4.getAttributes()) {
              const t5 = e4.getAttributeProperties(n3);
              t5 && t5.isFormatting && (yield n3);
            }
          }
        }
        class $D extends bs {
          static get pluginName() {
            return "RemoveFormatEditing";
          }
          init() {
            const t4 = this.editor;
            t4.commands.add("removeFormat", new qD(t4));
          }
        }
        var KD = n2(9347), ZD = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(KD.Z, ZD);
        KD.Z.locals;
        class YD extends As {
          refresh() {
            const t4 = this.editor.model, e4 = t4.document;
            this.value = !!e4.selection.getAttribute("restrictedEditingException"), this.isEnabled = t4.schema.checkAttributeInSelection(e4.selection, "restrictedEditingException");
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document.selection, i3 = void 0 === t4.forceValue ? !this.value : t4.forceValue;
            e4.change((t5) => {
              const o3 = e4.schema.getValidRanges(n3.getRanges(), "restrictedEditingException");
              if (n3.isCollapsed)
                if (i3)
                  t5.setSelectionAttribute("restrictedEditingException", i3);
                else {
                  const e5 = (t6) => t6.item.getAttribute("restrictedEditingException") === this.value, i4 = n3.focus, o4 = i4.getLastMatchingPosition(e5, { direction: "backward" }), r3 = i4.getLastMatchingPosition(e5);
                  t5.removeSelectionAttribute("restrictedEditingException"), i4.isEqual(o4) || i4.isEqual(r3) || t5.removeAttribute("restrictedEditingException", t5.createRange(o4, r3));
                }
              else
                for (const e5 of o3)
                  i3 ? t5.setAttribute("restrictedEditingException", i3, e5) : t5.removeAttribute("restrictedEditingException", e5);
            });
          }
        }
        class QD extends bs {
          static get pluginName() {
            return "StandardEditingModeEditing";
          }
          init() {
            const t4 = this.editor;
            t4.model.schema.extend("$text", { allowAttributes: ["restrictedEditingException"] }), t4.conversion.for("upcast").elementToAttribute({ model: "restrictedEditingException", view: { name: "span", classes: "restricted-editing-exception" } }), t4.conversion.for("downcast").attributeToElement({ model: "restrictedEditingException", view: (t5, { writer: e4 }) => {
              if (t5)
                return e4.createAttributeElement("span", { class: "restricted-editing-exception" }, { priority: -10 });
            } }), t4.commands.add("restrictedEditingException", new YD(t4)), t4.editing.view.change((e4) => {
              for (const n3 of t4.editing.view.document.roots)
                e4.addClass("ck-restricted-editing_mode_standard", n3);
            });
          }
        }
        class JD extends bs {
          static get pluginName() {
            return "StandardEditingModeUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add("restrictedEditingException", (n3) => {
              const i3 = t4.commands.get("restrictedEditingException"), o3 = new kr(n3);
              return o3.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.25 16a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm0-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 1 1 0-1.5h5.5zm3-5a.75.75 0 0 1 0 1.5H.75a.75.75 0 0 1 0-1.5h8.5zm6-5a.75.75 0 1 1 0 1.5H.75a.75.75 0 0 1 0-1.5h14.5zm.25 5.5a3.5 3.5 0 0 1 3.143 1.959.75.75 0 0 1-1.36.636A2 2 0 0 0 13.5 10v2H19a1 1 0 0 1 1 1v5a1 1 0 0 1-1 1h-7a1 1 0 0 1-1-1v-5a1 1 0 0 1 1-1v-2l.005-.192A3.5 3.5 0 0 1 15.5 6.5zm0 7.5a.5.5 0 0 0-.492.41L15 14.5v2a.5.5 0 0 0 .992.09L16 16.5v-2a.5.5 0 0 0-.5-.5z"/></svg>', tooltip: true, isToggleable: true }), o3.bind("isOn", "isEnabled").to(i3, "value", "isEnabled"), o3.bind("label").to(i3, "value", (t5) => e4(t5 ? "Disable editing" : "Enable editing")), this.listenTo(o3, "execute", () => {
                t4.execute("restrictedEditingException"), t4.editing.view.focus();
              }), o3;
            });
          }
        }
        function XD(t4) {
          const e4 = [{ name: "address", isVoid: false }, { name: "article", isVoid: false }, { name: "aside", isVoid: false }, { name: "blockquote", isVoid: false }, { name: "details", isVoid: false }, { name: "dialog", isVoid: false }, { name: "dd", isVoid: false }, { name: "div", isVoid: false }, { name: "dl", isVoid: false }, { name: "dt", isVoid: false }, { name: "fieldset", isVoid: false }, { name: "figcaption", isVoid: false }, { name: "figure", isVoid: false }, { name: "footer", isVoid: false }, { name: "form", isVoid: false }, { name: "h1", isVoid: false }, { name: "h2", isVoid: false }, { name: "h3", isVoid: false }, { name: "h4", isVoid: false }, { name: "h5", isVoid: false }, { name: "h6", isVoid: false }, { name: "header", isVoid: false }, { name: "hgroup", isVoid: false }, { name: "hr", isVoid: true }, { name: "li", isVoid: false }, { name: "main", isVoid: false }, { name: "nav", isVoid: false }, { name: "ol", isVoid: false }, { name: "p", isVoid: false }, { name: "section", isVoid: false }, { name: "table", isVoid: false }, { name: "tbody", isVoid: false }, { name: "td", isVoid: false }, { name: "th", isVoid: false }, { name: "thead", isVoid: false }, { name: "tr", isVoid: false }, { name: "ul", isVoid: false }], n3 = e4.map((t5) => t5.name).join("|"), i3 = t4.replace(new RegExp(`</?(${n3})( .*?)?>`, "g"), "\n$&\n").replace(/<br[^>]*>/g, "$&\n").split("\n");
          let o3 = 0;
          return i3.filter((t5) => t5.length).map((t5) => function(t6, e5) {
            return e5.some((e6) => !e6.isVoid && !!new RegExp(`<${e6.name}( .*?)?>`).test(t6));
          }(t5, e4) ? tS(t5, o3++) : function(t6, e5) {
            return e5.some((e6) => new RegExp(`</${e6.name}>`).test(t6));
          }(t5, e4) ? tS(t5, --o3) : tS(t5, o3)).join("\n");
        }
        function tS(t4, e4, n3 = "    ") {
          return `${n3.repeat(Math.max(0, e4))}${t4}`;
        }
        var eS = n2(4420), nS = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(eS.Z, nS);
        eS.Z.locals;
        const iS = "SourceEditingMode";
        function oS(t4) {
          return function(t5) {
            return t5.startsWith("<");
          }(t4) ? XD(t4) : t4;
        }
        class rS extends jp {
          constructor(t4, e4) {
            super(t4);
            const n3 = t4.t;
            this.set("class", "ck-special-characters-navigation"), this.groupDropdownView = this._createGroupDropdown(e4), this.groupDropdownView.panelPosition = "rtl" === t4.uiLanguageDirection ? "se" : "sw", this.label = n3("Special characters"), this.children.add(this.groupDropdownView);
          }
          get currentGroupName() {
            return this.groupDropdownView.value;
          }
          focus() {
            this.groupDropdownView.focus();
          }
          _createGroupDropdown(t4) {
            const e4 = this.locale, n3 = e4.t, i3 = om(e4), o3 = this._getCharacterGroupListItemDefinitions(i3, t4), r3 = n3("Character categories");
            return i3.set("value", o3.first.model.name), i3.buttonView.bind("label").to(i3, "value", (e5) => t4.get(e5)), i3.buttonView.set({ isOn: false, withText: true, tooltip: r3, class: ["ck-dropdown__button_label-width_auto"], ariaLabel: r3, ariaLabelledBy: void 0 }), i3.on("execute", (t5) => {
              i3.value = t5.source.name;
            }), i3.delegate("execute").to(this), am(i3, o3, { ariaLabel: r3, role: "menu" }), i3;
          }
          _getCharacterGroupListItemDefinitions(t4, e4) {
            const n3 = new Do2();
            for (const [i3, o3] of e4) {
              const e5 = new Up({ name: i3, label: o3, withText: true, role: "menuitemradio" });
              e5.bind("isOn").to(t4, "value", (t5) => t5 === e5.name), n3.add({ type: "button", model: e5 });
            }
            return n3;
          }
        }
        var sS = n2(1550), aS = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(sS.Z, aS);
        sS.Z.locals;
        class cS extends Ho2 {
          constructor(t4) {
            super(t4), this.tiles = this.createCollection(), this.setTemplate({ tag: "div", children: [{ tag: "div", attributes: { class: ["ck", "ck-character-grid__tiles"] }, children: this.tiles }], attributes: { class: ["ck", "ck-character-grid"] } }), this.focusTracker = new To2(), this.keystrokes = new Io2(), r2({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.tiles, numberOfColumns: () => Li2.window.getComputedStyle(this.element.firstChild).getPropertyValue("grid-template-columns").split(" ").length, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
          }
          createTile(t4, e4) {
            const n3 = new kr(this.locale);
            return n3.set({ label: t4, withText: true, class: "ck-character-grid__tile" }), n3.extendTemplate({ attributes: { title: e4 }, on: { mouseover: n3.bindTemplate.to("mouseover"), focus: n3.bindTemplate.to("focus") } }), n3.on("mouseover", () => {
              this.fire("tileHover", { name: e4, character: t4 });
            }), n3.on("focus", () => {
              this.fire("tileFocus", { name: e4, character: t4 });
            }), n3.on("execute", () => {
              this.fire("execute", { name: e4, character: t4 });
            }), n3;
          }
          render() {
            super.render();
            for (const t4 of this.tiles)
              this.focusTracker.add(t4.element);
            this.tiles.on("change", (t4, { added: e4, removed: n3 }) => {
              if (e4.length > 0)
                for (const t5 of e4)
                  this.focusTracker.add(t5.element);
              if (n3.length > 0)
                for (const t5 of n3)
                  this.focusTracker.remove(t5.element);
            }), this.keystrokes.listenTo(this.element);
          }
          destroy() {
            super.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this.tiles.first.focus();
          }
        }
        var lS = n2(2234), dS = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(lS.Z, dS);
        lS.Z.locals;
        class hS extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.set("character", null), this.set("name", null), this.bind("code").to(this, "character", uS), this.setTemplate({ tag: "div", children: [{ tag: "span", attributes: { class: ["ck-character-info__name"] }, children: [{ text: e4.to("name", (t5) => t5 || "") }] }, { tag: "span", attributes: { class: ["ck-character-info__code"] }, children: [{ text: e4.to("code") }] }], attributes: { class: ["ck", "ck-character-info"] } });
          }
        }
        function uS(t4) {
          if (null === t4)
            return "";
          return "U+" + ("0000" + t4.codePointAt(0).toString(16)).slice(-4);
        }
        class gS extends Ho2 {
          constructor(t4, e4, n3, i3) {
            super(t4), this.navigationView = e4, this.gridView = n3, this.infoView = i3, this.items = this.createCollection(), this.focusTracker = new To2(), this.keystrokes = new Io2(), this._focusCycler = new gs({ focusables: this.items, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", children: [this.navigationView, this.gridView, this.infoView], attributes: { tabindex: "-1" } }), this.items.add(this.navigationView.groupDropdownView.buttonView), this.items.add(this.gridView);
          }
          render() {
            super.render(), this.focusTracker.add(this.navigationView.groupDropdownView.buttonView.element), this.focusTracker.add(this.gridView.element), this.keystrokes.listenTo(this.element);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this.navigationView.focus();
          }
        }
        var mS = n2(2538), pS = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(mS.Z, pS);
        mS.Z.locals;
        const fS = "All";
        class kS extends bs {
          static get pluginName() {
            return "SpecialCharactersArrows";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.plugins.get("SpecialCharacters").addItems("Arrows", [{ title: e4("leftwards simple arrow"), character: "" }, { title: e4("rightwards simple arrow"), character: "" }, { title: e4("upwards simple arrow"), character: "" }, { title: e4("downwards simple arrow"), character: "" }, { title: e4("leftwards double arrow"), character: "" }, { title: e4("rightwards double arrow"), character: "" }, { title: e4("upwards double arrow"), character: "" }, { title: e4("downwards double arrow"), character: "" }, { title: e4("leftwards dashed arrow"), character: "" }, { title: e4("rightwards dashed arrow"), character: "" }, { title: e4("upwards dashed arrow"), character: "" }, { title: e4("downwards dashed arrow"), character: "" }, { title: e4("leftwards arrow to bar"), character: "" }, { title: e4("rightwards arrow to bar"), character: "" }, { title: e4("upwards arrow to bar"), character: "" }, { title: e4("downwards arrow to bar"), character: "" }, { title: e4("up down arrow with base"), character: "" }, { title: e4("back with leftwards arrow above"), character: "" }, { title: e4("end with leftwards arrow above"), character: "" }, { title: e4("on with exclamation mark with left right arrow above"), character: "" }, { title: e4("soon with rightwards arrow above"), character: "" }, { title: e4("top with upwards arrow above"), character: "" }], { label: e4("Arrows") });
          }
        }
        class bS extends bs {
          static get pluginName() {
            return "SpecialCharactersText";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.plugins.get("SpecialCharacters").addItems("Text", [{ character: "", title: e4("Single left-pointing angle quotation mark") }, { character: "", title: e4("Single right-pointing angle quotation mark") }, { character: "", title: e4("Left-pointing double angle quotation mark") }, { character: "", title: e4("Right-pointing double angle quotation mark") }, { character: "", title: e4("Left single quotation mark") }, { character: "", title: e4("Right single quotation mark") }, { character: "", title: e4("Left double quotation mark") }, { character: "", title: e4("Right double quotation mark") }, { character: "", title: e4("Single low-9 quotation mark") }, { character: "", title: e4("Double low-9 quotation mark") }, { character: "", title: e4("Inverted exclamation mark") }, { character: "", title: e4("Inverted question mark") }, { character: "", title: e4("Two dot leader") }, { character: "", title: e4("Horizontal ellipsis") }, { character: "", title: e4("Double dagger") }, { character: "", title: e4("Per mille sign") }, { character: "", title: e4("Per ten thousand sign") }, { character: "", title: e4("Double exclamation mark") }, { character: "", title: e4("Question exclamation mark") }, { character: "", title: e4("Exclamation question mark") }, { character: "", title: e4("Double question mark") }, { character: "", title: e4("Copyright sign") }, { character: "", title: e4("Registered sign") }, { character: "", title: e4("Trade mark sign") }, { character: "", title: e4("Section sign") }, { character: "", title: e4("Paragraph sign") }, { character: "", title: e4("Reversed paragraph sign") }], { label: e4("Text") });
          }
        }
        class wS extends bs {
          static get pluginName() {
            return "SpecialCharactersMathematical";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.plugins.get("SpecialCharacters").addItems("Mathematical", [{ character: "<", title: e4("Less-than sign") }, { character: ">", title: e4("Greater-than sign") }, { character: "", title: e4("Less-than or equal to") }, { character: "", title: e4("Greater-than or equal to") }, { character: "", title: e4("En dash") }, { character: "", title: e4("Em dash") }, { character: "", title: e4("Macron") }, { character: "", title: e4("Overline") }, { character: "", title: e4("Degree sign") }, { character: "", title: e4("Minus sign") }, { character: "", title: e4("Plus-minus sign") }, { character: "", title: e4("Division sign") }, { character: "", title: e4("Fraction slash") }, { character: "", title: e4("Multiplication sign") }, { character: "", title: e4("Latin small letter f with hook") }, { character: "", title: e4("Integral") }, { character: "", title: e4("N-ary summation") }, { character: "", title: e4("Infinity") }, { character: "", title: e4("Square root") }, { character: "", title: e4("Tilde operator") }, { character: "", title: e4("Approximately equal to") }, { character: "", title: e4("Almost equal to") }, { character: "", title: e4("Not equal to") }, { character: "", title: e4("Identical to") }, { character: "", title: e4("Element of") }, { character: "", title: e4("Not an element of") }, { character: "", title: e4("Contains as member") }, { character: "", title: e4("N-ary product") }, { character: "", title: e4("Logical and") }, { character: "", title: e4("Logical or") }, { character: "", title: e4("Not sign") }, { character: "", title: e4("Intersection") }, { character: "", title: e4("Union") }, { character: "", title: e4("Partial differential") }, { character: "", title: e4("For all") }, { character: "", title: e4("There exists") }, { character: "", title: e4("Empty set") }, { character: "", title: e4("Nabla") }, { character: "", title: e4("Asterisk operator") }, { character: "", title: e4("Proportional to") }, { character: "", title: e4("Angle") }, { character: "", title: e4("Vulgar fraction one quarter") }, { character: "", title: e4("Vulgar fraction one half") }, { character: "", title: e4("Vulgar fraction three quarters") }], { label: e4("Mathematical") });
          }
        }
        class AS extends bs {
          static get pluginName() {
            return "SpecialCharactersLatin";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.plugins.get("SpecialCharacters").addItems("Latin", [{ character: "", title: e4("Latin capital letter a with macron") }, { character: "", title: e4("Latin small letter a with macron") }, { character: "", title: e4("Latin capital letter a with breve") }, { character: "", title: e4("Latin small letter a with breve") }, { character: "", title: e4("Latin capital letter a with ogonek") }, { character: "", title: e4("Latin small letter a with ogonek") }, { character: "", title: e4("Latin capital letter c with acute") }, { character: "", title: e4("Latin small letter c with acute") }, { character: "", title: e4("Latin capital letter c with circumflex") }, { character: "", title: e4("Latin small letter c with circumflex") }, { character: "", title: e4("Latin capital letter c with dot above") }, { character: "", title: e4("Latin small letter c with dot above") }, { character: "", title: e4("Latin capital letter c with caron") }, { character: "", title: e4("Latin small letter c with caron") }, { character: "", title: e4("Latin capital letter d with caron") }, { character: "", title: e4("Latin small letter d with caron") }, { character: "", title: e4("Latin capital letter d with stroke") }, { character: "", title: e4("Latin small letter d with stroke") }, { character: "", title: e4("Latin capital letter e with macron") }, { character: "", title: e4("Latin small letter e with macron") }, { character: "", title: e4("Latin capital letter e with breve") }, { character: "", title: e4("Latin small letter e with breve") }, { character: "", title: e4("Latin capital letter e with dot above") }, { character: "", title: e4("Latin small letter e with dot above") }, { character: "", title: e4("Latin capital letter e with ogonek") }, { character: "", title: e4("Latin small letter e with ogonek") }, { character: "", title: e4("Latin capital letter e with caron") }, { character: "", title: e4("Latin small letter e with caron") }, { character: "", title: e4("Latin capital letter g with circumflex") }, { character: "", title: e4("Latin small letter g with circumflex") }, { character: "", title: e4("Latin capital letter g with breve") }, { character: "", title: e4("Latin small letter g with breve") }, { character: "", title: e4("Latin capital letter g with dot above") }, { character: "", title: e4("Latin small letter g with dot above") }, { character: "", title: e4("Latin capital letter g with cedilla") }, { character: "", title: e4("Latin small letter g with cedilla") }, { character: "", title: e4("Latin capital letter h with circumflex") }, { character: "", title: e4("Latin small letter h with circumflex") }, { character: "", title: e4("Latin capital letter h with stroke") }, { character: "", title: e4("Latin small letter h with stroke") }, { character: "", title: e4("Latin capital letter i with tilde") }, { character: "", title: e4("Latin small letter i with tilde") }, { character: "", title: e4("Latin capital letter i with macron") }, { character: "", title: e4("Latin small letter i with macron") }, { character: "", title: e4("Latin capital letter i with breve") }, { character: "", title: e4("Latin small letter i with breve") }, { character: "", title: e4("Latin capital letter i with ogonek") }, { character: "", title: e4("Latin small letter i with ogonek") }, { character: "", title: e4("Latin capital letter i with dot above") }, { character: "", title: e4("Latin small letter dotless i") }, { character: "", title: e4("Latin capital ligature ij") }, { character: "", title: e4("Latin small ligature ij") }, { character: "", title: e4("Latin capital letter j with circumflex") }, { character: "", title: e4("Latin small letter j with circumflex") }, { character: "", title: e4("Latin capital letter k with cedilla") }, { character: "", title: e4("Latin small letter k with cedilla") }, { character: "", title: e4("Latin small letter kra") }, { character: "", title: e4("Latin capital letter l with acute") }, { character: "", title: e4("Latin small letter l with acute") }, { character: "", title: e4("Latin capital letter l with cedilla") }, { character: "", title: e4("Latin small letter l with cedilla") }, { character: "", title: e4("Latin capital letter l with caron") }, { character: "", title: e4("Latin small letter l with caron") }, { character: "", title: e4("Latin capital letter l with middle dot") }, { character: "", title: e4("Latin small letter l with middle dot") }, { character: "", title: e4("Latin capital letter l with stroke") }, { character: "", title: e4("Latin small letter l with stroke") }, { character: "", title: e4("Latin capital letter n with acute") }, { character: "", title: e4("Latin small letter n with acute") }, { character: "", title: e4("Latin capital letter n with cedilla") }, { character: "", title: e4("Latin small letter n with cedilla") }, { character: "", title: e4("Latin capital letter n with caron") }, { character: "", title: e4("Latin small letter n with caron") }, { character: "", title: e4("Latin small letter n preceded by apostrophe") }, { character: "", title: e4("Latin capital letter eng") }, { character: "", title: e4("Latin small letter eng") }, { character: "", title: e4("Latin capital letter o with macron") }, { character: "", title: e4("Latin small letter o with macron") }, { character: "", title: e4("Latin capital letter o with breve") }, { character: "", title: e4("Latin small letter o with breve") }, { character: "", title: e4("Latin capital letter o with double acute") }, { character: "", title: e4("Latin small letter o with double acute") }, { character: "", title: e4("Latin capital ligature oe") }, { character: "", title: e4("Latin small ligature oe") }, { character: "", title: e4("Latin capital letter r with acute") }, { character: "", title: e4("Latin small letter r with acute") }, { character: "", title: e4("Latin capital letter r with cedilla") }, { character: "", title: e4("Latin small letter r with cedilla") }, { character: "", title: e4("Latin capital letter r with caron") }, { character: "", title: e4("Latin small letter r with caron") }, { character: "", title: e4("Latin capital letter s with acute") }, { character: "", title: e4("Latin small letter s with acute") }, { character: "", title: e4("Latin capital letter s with circumflex") }, { character: "", title: e4("Latin small letter s with circumflex") }, { character: "", title: e4("Latin capital letter s with cedilla") }, { character: "", title: e4("Latin small letter s with cedilla") }, { character: "", title: e4("Latin capital letter s with caron") }, { character: "", title: e4("Latin small letter s with caron") }, { character: "", title: e4("Latin capital letter t with cedilla") }, { character: "", title: e4("Latin small letter t with cedilla") }, { character: "", title: e4("Latin capital letter t with caron") }, { character: "", title: e4("Latin small letter t with caron") }, { character: "", title: e4("Latin capital letter t with stroke") }, { character: "", title: e4("Latin small letter t with stroke") }, { character: "", title: e4("Latin capital letter u with tilde") }, { character: "", title: e4("Latin small letter u with tilde") }, { character: "", title: e4("Latin capital letter u with macron") }, { character: "", title: e4("Latin small letter u with macron") }, { character: "", title: e4("Latin capital letter u with breve") }, { character: "", title: e4("Latin small letter u with breve") }, { character: "", title: e4("Latin capital letter u with ring above") }, { character: "", title: e4("Latin small letter u with ring above") }, { character: "", title: e4("Latin capital letter u with double acute") }, { character: "", title: e4("Latin small letter u with double acute") }, { character: "", title: e4("Latin capital letter u with ogonek") }, { character: "", title: e4("Latin small letter u with ogonek") }, { character: "", title: e4("Latin capital letter w with circumflex") }, { character: "", title: e4("Latin small letter w with circumflex") }, { character: "", title: e4("Latin capital letter y with circumflex") }, { character: "", title: e4("Latin small letter y with circumflex") }, { character: "", title: e4("Latin capital letter y with diaeresis") }, { character: "", title: e4("Latin capital letter z with acute") }, { character: "", title: e4("Latin small letter z with acute") }, { character: "", title: e4("Latin capital letter z with dot above") }, { character: "", title: e4("Latin small letter z with dot above") }, { character: "", title: e4("Latin capital letter z with caron") }, { character: "", title: e4("Latin small letter z with caron") }, { character: "", title: e4("Latin small letter long s") }], { label: e4("Latin") });
          }
        }
        class CS extends bs {
          static get pluginName() {
            return "SpecialCharactersCurrency";
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.plugins.get("SpecialCharacters").addItems("Currency", [{ character: "$", title: e4("Dollar sign") }, { character: "", title: e4("Euro sign") }, { character: "", title: e4("Yen sign") }, { character: "", title: e4("Pound sign") }, { character: "", title: e4("Cent sign") }, { character: "", title: e4("Euro-currency sign") }, { character: "", title: e4("Colon sign") }, { character: "", title: e4("Cruzeiro sign") }, { character: "", title: e4("French franc sign") }, { character: "", title: e4("Lira sign") }, { character: "", title: e4("Currency sign") }, { character: "", title: e4("Bitcoin sign") }, { character: "", title: e4("Mill sign") }, { character: "", title: e4("Naira sign") }, { character: "", title: e4("Peseta sign") }, { character: "", title: e4("Rupee sign") }, { character: "", title: e4("Won sign") }, { character: "", title: e4("New sheqel sign") }, { character: "", title: e4("Dong sign") }, { character: "", title: e4("Kip sign") }, { character: "", title: e4("Tugrik sign") }, { character: "", title: e4("Drachma sign") }, { character: "", title: e4("German penny sign") }, { character: "", title: e4("Peso sign") }, { character: "", title: e4("Guarani sign") }, { character: "", title: e4("Austral sign") }, { character: "", title: e4("Hryvnia sign") }, { character: "", title: e4("Cedi sign") }, { character: "", title: e4("Livre tournois sign") }, { character: "", title: e4("Spesmilo sign") }, { character: "", title: e4("Tenge sign") }, { character: "", title: e4("Indian rupee sign") }, { character: "", title: e4("Turkish lira sign") }, { character: "", title: e4("Nordic mark sign") }, { character: "", title: e4("Manat sign") }, { character: "", title: e4("Ruble sign") }], { label: e4("Currency") });
          }
        }
        class _S extends kr {
          constructor(t4, e4) {
            super(t4), this.styleDefinition = e4, this.previewView = this._createPreview(), this.set({ label: e4.name, class: "ck-style-grid__button", withText: true }), this.extendTemplate({ attributes: { role: "option" } }), this.children.add(this.previewView, 0);
          }
          _createPreview() {
            const t4 = new Ho2(this.locale);
            return t4.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset_all-excluded", "ck-style-grid__button__preview", "ck-content"], "aria-hidden": "true" }, children: [this.styleDefinition.previewTemplate] }), t4;
          }
        }
        var vS = n2(7775), yS = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(vS.Z, yS);
        vS.Z.locals;
        class xS extends Ho2 {
          constructor(t4, e4) {
            super(t4), this.focusTracker = new To2(), this.keystrokes = new Io2(), this.set("activeStyles", []), this.set("enabledStyles", []), this.children = this.createCollection(), this.children.delegate("execute").to(this);
            for (const n3 of e4) {
              const e5 = new _S(t4, n3);
              this.children.add(e5);
            }
            this.on("change:activeStyles", () => {
              for (const t5 of this.children)
                t5.isOn = this.activeStyles.includes(t5.styleDefinition.name);
            }), this.on("change:enabledStyles", () => {
              for (const t5 of this.children)
                t5.isEnabled = this.enabledStyles.includes(t5.styleDefinition.name);
            }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-style-grid"], role: "listbox" }, children: this.children });
          }
          render() {
            super.render();
            for (const t4 of this.children)
              this.focusTracker.add(t4.element);
            r2({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.children, numberOfColumns: 3, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection }), this.keystrokes.listenTo(this.element);
          }
          focus() {
            this.children.first.focus();
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
        }
        var ES = n2(5634), DS = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(ES.Z, DS);
        ES.Z.locals;
        class SS extends Ho2 {
          constructor(t4, e4, n3) {
            super(t4), this.labelView = new Yr(t4), this.labelView.text = e4, this.gridView = new xS(t4, n3), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-style-panel__style-group"], role: "group", "aria-labelledby": this.labelView.id }, children: [this.labelView, this.gridView] });
          }
        }
        var TS = n2(4637), IS = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(TS.Z, IS);
        TS.Z.locals;
        class BS extends Ho2 {
          constructor(t4, e4) {
            super(t4);
            const n3 = t4.t;
            this.focusTracker = new To2(), this.keystrokes = new Io2(), this.children = this.createCollection(), this.blockStylesGroupView = new SS(t4, n3("Block styles"), e4.block), this.inlineStylesGroupView = new SS(t4, n3("Text styles"), e4.inline), this.set("activeStyles", []), this.set("enabledStyles", []), this._focusables = new Ro2(), this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: ["shift + tab"], focusNext: ["tab"] } }), e4.block.length && this.children.add(this.blockStylesGroupView), e4.inline.length && this.children.add(this.inlineStylesGroupView), this.blockStylesGroupView.gridView.delegate("execute").to(this), this.inlineStylesGroupView.gridView.delegate("execute").to(this), this.blockStylesGroupView.gridView.bind("activeStyles", "enabledStyles").to(this, "activeStyles", "enabledStyles"), this.inlineStylesGroupView.gridView.bind("activeStyles", "enabledStyles").to(this, "activeStyles", "enabledStyles"), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-style-panel"] }, children: this.children });
          }
          render() {
            super.render(), this._focusables.add(this.blockStylesGroupView.gridView), this._focusables.add(this.inlineStylesGroupView.gridView), this.focusTracker.add(this.blockStylesGroupView.gridView.element), this.focusTracker.add(this.inlineStylesGroupView.gridView.element), this.keystrokes.listenTo(this.element);
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          focusLast() {
            this._focusCycler.focusLast();
          }
        }
        const MS2 = ["caption", "colgroup", "dd", "dt", "figcaption", "legend", "li", "optgroup", "option", "rp", "rt", "summary", "tbody", "td", "tfoot", "th", "thead", "tr"];
        class NS extends bs {
          static get pluginName() {
            return "StyleUtils";
          }
          constructor(t4) {
            super(t4), this.decorate("isStyleEnabledForBlock"), this.decorate("isStyleActiveForBlock"), this.decorate("getAffectedBlocks"), this.decorate("isStyleEnabledForInlineSelection"), this.decorate("isStyleActiveForInlineSelection"), this.decorate("getAffectedInlineSelectable"), this.decorate("getStylePreview"), this.decorate("configureGHSDataFilter");
          }
          init() {
            this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport");
          }
          normalizeConfig(t4, e4 = []) {
            const n3 = { block: [], inline: [] };
            for (const i3 of e4) {
              const e5 = [], o3 = [];
              for (const n4 of t4.getDefinitionsForView(i3.element)) {
                const t5 = "appliesToBlock" in n4 && n4.appliesToBlock;
                if (n4.isBlock || t5) {
                  if ("string" == typeof t5)
                    e5.push(t5);
                  else if (n4.isBlock) {
                    const t6 = n4;
                    e5.push(n4.model), t6.paragraphLikeModel && e5.push(t6.paragraphLikeModel);
                  }
                } else
                  o3.push(n4.model);
              }
              const r3 = this.getStylePreview(i3, [{ text: "AaBbCcDdEeFfGgHhIiJj" }]);
              e5.length ? n3.block.push({ ...i3, previewTemplate: r3, modelElements: e5, isBlock: true }) : n3.inline.push({ ...i3, previewTemplate: r3, ghsAttributes: o3 });
            }
            return n3;
          }
          isStyleEnabledForBlock(t4, e4) {
            const n3 = this.editor.model, i3 = this._htmlSupport.getGhsAttributeNameForElement(t4.element);
            return !!n3.schema.checkAttribute(e4, i3) && t4.modelElements.includes(e4.name);
          }
          isStyleActiveForBlock(t4, e4) {
            const n3 = this._htmlSupport.getGhsAttributeNameForElement(t4.element), i3 = e4.getAttribute(n3);
            return this.hasAllClasses(i3, t4.classes);
          }
          getAffectedBlocks(t4, e4) {
            return t4.modelElements.includes(e4.name) ? [e4] : null;
          }
          isStyleEnabledForInlineSelection(t4, e4) {
            const n3 = this.editor.model;
            for (const i3 of t4.ghsAttributes)
              if (n3.schema.checkAttributeInSelection(e4, i3))
                return true;
            return false;
          }
          isStyleActiveForInlineSelection(t4, e4) {
            for (const n3 of t4.ghsAttributes) {
              const i3 = this._getValueFromFirstAllowedNode(e4, n3);
              if (this.hasAllClasses(i3, t4.classes))
                return true;
            }
            return false;
          }
          getAffectedInlineSelectable(t4, e4) {
            return e4;
          }
          getStylePreview(t4, e4) {
            const { element: n3, classes: i3 } = t4;
            return { tag: (o3 = n3, MS2.includes(o3) ? "div" : n3), attributes: { class: i3 }, children: e4 };
            var o3;
          }
          hasAllClasses(t4, e4) {
            return F2(t4) && (n3 = t4, Boolean(n3.classes) && Array.isArray(n3.classes)) && e4.every((e5) => t4.classes.includes(e5));
            var n3;
          }
          configureGHSDataFilter({ block: t4, inline: e4 }) {
            const n3 = this.editor.plugins.get("DataFilter");
            n3.loadAllowedConfig(t4.map(LS)), n3.loadAllowedConfig(e4.map(LS));
          }
          _getValueFromFirstAllowedNode(t4, e4) {
            const n3 = this.editor.model.schema;
            if (t4.isCollapsed)
              return t4.getAttribute(e4);
            for (const i3 of t4.getRanges())
              for (const t5 of i3.getItems())
                if (n3.checkAttribute(t5, e4))
                  return t5.getAttribute(e4);
            return null;
          }
        }
        function LS({ element: t4, classes: e4 }) {
          return { name: t4, classes: e4 };
        }
        var zS = n2(8624), PS = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(zS.Z, PS);
        zS.Z.locals;
        class RS extends bs {
          static get pluginName() {
            return "StyleUI";
          }
          static get requires() {
            return [NS];
          }
          init() {
            const t4 = this.editor, e4 = t4.plugins.get("DataSchema"), n3 = t4.plugins.get("StyleUtils"), i3 = t4.config.get("style.definitions"), o3 = n3.normalizeConfig(e4, i3);
            t4.ui.componentFactory.add("style", (e5) => {
              const n4 = e5.t, i4 = om(e5), r3 = t4.commands.get("style");
              return i4.once("change:isOpen", () => {
                const t5 = new BS(e5, o3);
                i4.panelView.children.add(t5), t5.delegate("execute").to(i4), t5.bind("activeStyles").to(r3, "value"), t5.bind("enabledStyles").to(r3, "enabledStyles");
              }), i4.bind("isEnabled").to(r3), i4.buttonView.withText = true, i4.buttonView.bind("label").to(r3, "value", (t5) => t5.length > 1 ? n4("Multiple styles") : 1 === t5.length ? t5[0] : n4("Styles")), i4.bind("class").to(r3, "value", (t5) => {
                const e6 = ["ck-style-dropdown"];
                return t5.length > 1 && e6.push("ck-style-dropdown_multiple-active"), e6.join(" ");
              }), i4.on("execute", (e6) => {
                t4.execute("style", { styleName: e6.source.styleDefinition.name }), t4.editing.view.focus();
              }), i4;
            });
          }
        }
        class OS extends As {
          constructor(t4, e4) {
            super(t4), this.set("value", []), this.set("enabledStyles", []), this._styleDefinitions = e4, this._styleUtils = this.editor.plugins.get(NS);
          }
          refresh() {
            const t4 = this.editor.model, e4 = t4.document.selection, n3 = /* @__PURE__ */ new Set(), i3 = /* @__PURE__ */ new Set();
            for (const t5 of this._styleDefinitions.inline)
              this._styleUtils.isStyleEnabledForInlineSelection(t5, e4) && i3.add(t5.name), this._styleUtils.isStyleActiveForInlineSelection(t5, e4) && n3.add(t5.name);
            const o3 = So2(e4.getSelectedBlocks()) || e4.getFirstPosition().parent;
            if (o3) {
              const e5 = o3.getAncestors({ includeSelf: true, parentFirst: true });
              for (const o4 of e5) {
                if (o4.is("rootElement"))
                  break;
                for (const t5 of this._styleDefinitions.block)
                  this._styleUtils.isStyleEnabledForBlock(t5, o4) && (i3.add(t5.name), this._styleUtils.isStyleActiveForBlock(t5, o4) && n3.add(t5.name));
                if (t4.schema.isObject(o4))
                  break;
              }
            }
            this.enabledStyles = Array.from(i3).sort(), this.isEnabled = this.enabledStyles.length > 0, this.value = this.isEnabled ? Array.from(n3).sort() : [];
          }
          execute({ styleName: t4, forceValue: e4 }) {
            if (!this.enabledStyles.includes(t4))
              return void _2("style-command-executed-with-incorrect-style-name");
            const n3 = this.editor.model, i3 = n3.document.selection, o3 = this.editor.plugins.get("GeneralHtmlSupport"), r3 = [...this._styleDefinitions.inline, ...this._styleDefinitions.block], s3 = r3.filter(({ name: t5 }) => this.value.includes(t5)), a3 = r3.find(({ name: e5 }) => e5 == t4), c3 = void 0 === e4 ? !this.value.includes(a3.name) : e4;
            n3.change(() => {
              let t5;
              t5 = function(t6) {
                return "isBlock" in t6;
              }(a3) ? this._findAffectedBlocks(function(t6) {
                const e5 = Array.from(t6.getSelectedBlocks());
                if (e5.length)
                  return e5;
                return [t6.getFirstPosition().parent];
              }(i3), a3) : [this._styleUtils.getAffectedInlineSelectable(a3, i3)];
              for (const e5 of t5)
                c3 ? o3.addModelHtmlClass(a3.element, a3.classes, e5) : o3.removeModelHtmlClass(a3.element, FS(s3, a3), e5);
            });
          }
          _findAffectedBlocks(t4, e4) {
            const n3 = /* @__PURE__ */ new Set();
            for (const i3 of t4) {
              const t5 = i3.getAncestors({ includeSelf: true, parentFirst: true });
              for (const i4 of t5) {
                if (i4.is("rootElement"))
                  break;
                const t6 = this._styleUtils.getAffectedBlocks(e4, i4);
                if (t6) {
                  for (const e5 of t6)
                    n3.add(e5);
                  break;
                }
              }
            }
            return n3;
          }
        }
        function FS(t4, e4) {
          return t4.reduce((t5, n3) => n3.name === e4.name ? t5 : t5.filter((t6) => !n3.classes.includes(t6)), e4.classes);
        }
        class VS extends bs {
          static get pluginName() {
            return "DocumentListStyleSupport";
          }
          static get requires() {
            return [NS, "GeneralHtmlSupport"];
          }
          init() {
            const t4 = this.editor;
            t4.plugins.has("DocumentListEditing") && (this._styleUtils = t4.plugins.get(NS), this._documentListUtils = this.editor.plugins.get("DocumentListUtils"), this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport"), this.listenTo(this._styleUtils, "isStyleEnabledForBlock", (t5, [e4, n3]) => {
              this._isStyleEnabledForBlock(e4, n3) && (t5.return = true, t5.stop());
            }, { priority: "high" }), this.listenTo(this._styleUtils, "isStyleActiveForBlock", (t5, [e4, n3]) => {
              this._isStyleActiveForBlock(e4, n3) && (t5.return = true, t5.stop());
            }, { priority: "high" }), this.listenTo(this._styleUtils, "getAffectedBlocks", (t5, [e4, n3]) => {
              const i3 = this._getAffectedBlocks(e4, n3);
              i3 && (t5.return = i3, t5.stop());
            }, { priority: "high" }), this.listenTo(this._styleUtils, "getStylePreview", (t5, [e4, n3]) => {
              const i3 = this._getStylePreview(e4, n3);
              i3 && (t5.return = i3, t5.stop());
            }, { priority: "high" }));
          }
          _isStyleEnabledForBlock(t4, e4) {
            const n3 = this.editor.model;
            if (!["ol", "ul", "li"].includes(t4.element))
              return false;
            if (!this._documentListUtils.isListItemBlock(e4))
              return false;
            const i3 = this._htmlSupport.getGhsAttributeNameForElement(t4.element);
            if ("ol" == t4.element || "ul" == t4.element) {
              if (!n3.schema.checkAttribute(e4, i3))
                return false;
              const o3 = "numbered" == e4.getAttribute("listType") ? "ol" : "ul";
              return t4.element == o3;
            }
            return n3.schema.checkAttribute(e4, i3);
          }
          _isStyleActiveForBlock(t4, e4) {
            const n3 = this._htmlSupport.getGhsAttributeNameForElement(t4.element), i3 = e4.getAttribute(n3);
            return this._styleUtils.hasAllClasses(i3, t4.classes);
          }
          _getAffectedBlocks(t4, e4) {
            return this._isStyleEnabledForBlock(t4, e4) ? "li" == t4.element ? this._documentListUtils.expandListBlocksToCompleteItems(e4, { withNested: false }) : this._documentListUtils.expandListBlocksToCompleteList(e4) : null;
          }
          _getStylePreview(t4, e4) {
            const { element: n3, classes: i3 } = t4;
            return "ol" == n3 || "ul" == n3 ? { tag: n3, attributes: { class: i3 }, children: [{ tag: "li", children: e4 }] } : "li" == n3 ? { tag: "ol", children: [{ tag: n3, attributes: { class: i3 }, children: e4 }] } : null;
          }
        }
        class jS extends bs {
          static get pluginName() {
            return "TableStyleSupport";
          }
          static get requires() {
            return [NS];
          }
          init() {
            const t4 = this.editor;
            t4.plugins.has("TableEditing") && (this._styleUtils = t4.plugins.get(NS), this._tableUtils = this.editor.plugins.get("TableUtils"), this.listenTo(this._styleUtils, "isStyleEnabledForBlock", (t5, [e4, n3]) => {
              this._isApplicable(e4, n3) && (t5.return = this._isStyleEnabledForBlock(e4, n3), t5.stop());
            }, { priority: "high" }), this.listenTo(this._styleUtils, "getAffectedBlocks", (t5, [e4, n3]) => {
              this._isApplicable(e4, n3) && (t5.return = this._getAffectedBlocks(e4, n3), t5.stop());
            }, { priority: "high" }), this.listenTo(this._styleUtils, "configureGHSDataFilter", (t5, [{ block: e4 }]) => {
              this.editor.plugins.get("DataFilter").loadAllowedConfig(e4.filter((t6) => "figcaption" == t6.element).map((t6) => ({ name: "caption", classes: t6.classes })));
            }));
          }
          _isApplicable(t4, e4) {
            return ["td", "th"].includes(t4.element) ? "tableCell" == e4.name : !!["thead", "tbody"].includes(t4.element) && "table" == e4.name;
          }
          _isStyleEnabledForBlock(t4, e4) {
            if (["td", "th"].includes(t4.element)) {
              const n3 = this._tableUtils.getCellLocation(e4), i3 = e4.parent.parent, o3 = i3.getAttribute("headingRows") || 0, r3 = i3.getAttribute("headingColumns") || 0, s3 = n3.row < o3 || n3.column < r3;
              return "th" == t4.element ? s3 : !s3;
            }
            if (["thead", "tbody"].includes(t4.element)) {
              const n3 = e4.getAttribute("headingRows") || 0;
              return "thead" == t4.element ? n3 > 0 : n3 < this._tableUtils.getRows(e4);
            }
            return false;
          }
          _getAffectedBlocks(t4, e4) {
            return this._isStyleEnabledForBlock(t4, e4) ? [e4] : null;
          }
        }
        class HS extends bs {
          static get pluginName() {
            return "LinkStyleSupport";
          }
          static get requires() {
            return [NS, "GeneralHtmlSupport"];
          }
          init() {
            const t4 = this.editor;
            t4.plugins.has("LinkEditing") && (this._styleUtils = t4.plugins.get(NS), this._htmlSupport = this.editor.plugins.get("GeneralHtmlSupport"), this.listenTo(this._styleUtils, "isStyleEnabledForInlineSelection", (t5, [e4, n3]) => {
              "a" == e4.element && (t5.return = this._isStyleEnabled(e4, n3), t5.stop());
            }, { priority: "high" }), this.listenTo(this._styleUtils, "isStyleActiveForInlineSelection", (t5, [e4, n3]) => {
              "a" == e4.element && (t5.return = this._isStyleActive(e4, n3), t5.stop());
            }, { priority: "high" }), this.listenTo(this._styleUtils, "getAffectedInlineSelectable", (t5, [e4, n3]) => {
              if ("a" != e4.element)
                return;
              const i3 = this._getAffectedSelectable(e4, n3);
              i3 && (t5.return = i3, t5.stop());
            }, { priority: "high" }));
          }
          _isStyleEnabled(t4, e4) {
            const n3 = this.editor.model;
            if (e4.isCollapsed)
              return e4.hasAttribute("linkHref");
            for (const t5 of e4.getRanges())
              for (const e5 of t5.getItems())
                if ((e5.is("$textProxy") || n3.schema.isInline(e5)) && e5.hasAttribute("linkHref"))
                  return true;
            return false;
          }
          _isStyleActive(t4, e4) {
            const n3 = this.editor.model, i3 = this._htmlSupport.getGhsAttributeNameForElement(t4.element);
            if (e4.isCollapsed) {
              if (e4.hasAttribute("linkHref")) {
                const n4 = e4.getAttribute(i3);
                if (this._styleUtils.hasAllClasses(n4, t4.classes))
                  return true;
              }
              return false;
            }
            for (const o3 of e4.getRanges())
              for (const e5 of o3.getItems())
                if ((e5.is("$textProxy") || n3.schema.isInline(e5)) && e5.hasAttribute("linkHref")) {
                  const n4 = e5.getAttribute(i3);
                  return this._styleUtils.hasAllClasses(n4, t4.classes);
                }
            return false;
          }
          _getAffectedSelectable(t4, e4) {
            const n3 = this.editor.model;
            if (e4.isCollapsed) {
              const t5 = e4.getAttribute("linkHref");
              return kk2(e4.getFirstPosition(), "linkHref", t5, n3);
            }
            const i3 = [];
            for (const t5 of e4.getRanges()) {
              const e5 = n3.createRange(US(t5.start, "linkHref", true, n3), US(t5.end, "linkHref", false, n3));
              for (const t6 of e5.getItems())
                (t6.is("$textProxy") || n3.schema.isInline(t6)) && t6.hasAttribute("linkHref") && i3.push(this.editor.model.createRangeOn(t6));
            }
            return function(t5) {
              for (let e5 = 1; e5 < t5.length; e5++) {
                const n4 = t5[e5 - 1].getJoined(t5[e5]);
                n4 && t5.splice(--e5, 2, n4);
              }
              return t5;
            }(i3);
          }
        }
        function US(t4, e4, n3, i3) {
          const o3 = t4.textNode || (n3 ? t4.nodeAfter : t4.nodeBefore);
          if (!o3 || !o3.hasAttribute(e4))
            return t4;
          return bk2(t4, e4, o3.getAttribute(e4), n3, i3);
        }
        class GS extends bs {
          static get pluginName() {
            return "StyleEditing";
          }
          static get requires() {
            return ["GeneralHtmlSupport", NS, VS, jS, HS];
          }
          init() {
            const t4 = this.editor, e4 = t4.plugins.get("DataSchema"), n3 = t4.plugins.get("StyleUtils"), i3 = t4.config.get("style.definitions"), o3 = n3.normalizeConfig(e4, i3);
            t4.commands.add("style", new OS(t4, o3)), n3.configureGHSDataFilter(o3);
          }
        }
        function WS(t4, e4) {
          const { modelAttribute: n3, styleName: i3, viewElement: o3, defaultValue: r3, reduceBoxSides: s3 = false, shouldUpcast: a3 = () => true } = e4;
          t4.for("upcast").attributeToAttribute({ view: { name: o3, styles: { [i3]: /[\s\S]+/ } }, model: { key: n3, value: (t5) => {
            if (!a3(t5))
              return;
            const e5 = t5.getNormalizedStyle(i3), n4 = s3 ? ZS(e5) : e5;
            return r3 !== n4 ? n4 : void 0;
          } } });
        }
        function qS(t4, e4, n3, i3) {
          t4.for("upcast").add((t5) => t5.on("element:" + e4, (t6, e5, o3) => {
            if (!e5.modelRange)
              return;
            const r3 = ["border-top-width", "border-top-color", "border-top-style", "border-bottom-width", "border-bottom-color", "border-bottom-style", "border-right-width", "border-right-color", "border-right-style", "border-left-width", "border-left-color", "border-left-style"].filter((t7) => e5.viewItem.hasStyle(t7));
            if (!r3.length)
              return;
            const s3 = { styles: r3 };
            if (!o3.consumable.test(e5.viewItem, s3))
              return;
            const a3 = [...e5.modelRange.getItems({ shallow: true })].pop();
            o3.consumable.consume(e5.viewItem, s3);
            const c3 = { style: e5.viewItem.getNormalizedStyle("border-style"), color: e5.viewItem.getNormalizedStyle("border-color"), width: e5.viewItem.getNormalizedStyle("border-width") }, l3 = { style: ZS(c3.style), color: ZS(c3.color), width: ZS(c3.width) };
            l3.style !== i3.style && o3.writer.setAttribute(n3.style, l3.style, a3), l3.color !== i3.color && o3.writer.setAttribute(n3.color, l3.color, a3), l3.width !== i3.width && o3.writer.setAttribute(n3.width, l3.width, a3);
          }));
        }
        function $S(t4, e4) {
          const { modelElement: n3, modelAttribute: i3, styleName: o3 } = e4;
          t4.for("downcast").attributeToAttribute({ model: { name: n3, key: i3 }, view: (t5) => ({ key: "style", value: { [o3]: t5 } }) });
        }
        function KS(t4, e4) {
          const { modelAttribute: n3, styleName: i3 } = e4;
          t4.for("downcast").add((t5) => t5.on(`attribute:${n3}:table`, (t6, e5, n4) => {
            const { item: o3, attributeNewValue: r3 } = e5, { mapper: s3, writer: a3 } = n4;
            if (!n4.consumable.consume(e5.item, t6.name))
              return;
            const c3 = [...s3.toViewElement(o3).getChildren()].find((t7) => t7.is("element", "table"));
            r3 ? a3.setStyle(i3, r3, c3) : a3.removeStyle(i3, c3);
          }));
        }
        function ZS(t4) {
          if (!t4)
            return;
          const e4 = ["top", "right", "bottom", "left"];
          if (!e4.every((e5) => t4[e5]))
            return t4;
          const n3 = t4.top;
          return e4.every((e5) => t4[e5] === n3) ? n3 : t4;
        }
        function YS(t4, e4, n3, i3, o3 = 1) {
          null != e4 && null != o3 && e4 > o3 ? i3.setAttribute(t4, e4, n3) : i3.removeAttribute(t4, n3);
        }
        function QS(t4, e4, n3 = {}) {
          const i3 = t4.createElement("tableCell", n3);
          return t4.insertElement("paragraph", i3), t4.insert(i3, e4), i3;
        }
        function JS(t4, e4) {
          const n3 = e4.parent.parent, i3 = parseInt(n3.getAttribute("headingColumns") || "0"), { column: o3 } = t4.getCellLocation(e4);
          return !!i3 && o3 < i3;
        }
        function XS(t4, e4, n3) {
          const { modelAttribute: i3 } = n3;
          t4.extend("tableCell", { allowAttributes: [i3] }), WS(e4, { viewElement: /^(td|th)$/, ...n3 }), $S(e4, { modelElement: "tableCell", ...n3 });
        }
        function tT(t4) {
          const e4 = t4.getSelectedElement();
          return e4 && e4.is("element", "table") ? e4 : t4.getFirstPosition().findAncestor("table");
        }
        function eT() {
          return (t4) => {
            t4.on("element:table", (t5, e4, n3) => {
              const i3 = e4.viewItem;
              if (!n3.consumable.test(i3, { name: true }))
                return;
              const { rows: o3, headingRows: r3, headingColumns: s3 } = function(t6) {
                let e5, n4 = 0;
                const i4 = [], o4 = [];
                let r4;
                for (const s4 of Array.from(t6.getChildren())) {
                  if ("tbody" !== s4.name && "thead" !== s4.name && "tfoot" !== s4.name)
                    continue;
                  "thead" !== s4.name || r4 || (r4 = s4);
                  const t7 = Array.from(s4.getChildren()).filter((t8) => t8.is("element", "tr"));
                  for (const a4 of t7)
                    if (r4 && s4 === r4 || "tbody" === s4.name && Array.from(a4.getChildren()).length && Array.from(a4.getChildren()).every((t8) => t8.is("element", "th")))
                      n4++, i4.push(a4);
                    else {
                      o4.push(a4);
                      const t8 = iT(a4);
                      (!e5 || t8 < e5) && (e5 = t8);
                    }
                }
                return { headingRows: n4, headingColumns: e5 || 0, rows: [...i4, ...o4] };
              }(i3), a3 = {};
              s3 && (a3.headingColumns = s3), r3 && (a3.headingRows = r3);
              const c3 = n3.writer.createElement("table", a3);
              if (n3.safeInsert(c3, e4.modelCursor)) {
                if (n3.consumable.consume(i3, { name: true }), o3.forEach((t6) => n3.convertItem(t6, n3.writer.createPositionAt(c3, "end"))), n3.convertChildren(i3, n3.writer.createPositionAt(c3, "end")), c3.isEmpty) {
                  const t6 = n3.writer.createElement("tableRow");
                  n3.writer.insert(t6, n3.writer.createPositionAt(c3, "end")), QS(n3.writer, n3.writer.createPositionAt(t6, "end"));
                }
                n3.updateConversionResult(c3, e4);
              }
            });
          };
        }
        function nT(t4) {
          return (e4) => {
            e4.on(`element:${t4}`, (t5, e5, { writer: n3 }) => {
              if (!e5.modelRange)
                return;
              const i3 = e5.modelRange.start.nodeAfter, o3 = n3.createPositionAt(i3, 0);
              if (e5.viewItem.isEmpty)
                return void n3.insertElement("paragraph", o3);
              const r3 = Array.from(i3.getChildren());
              if (r3.every((t6) => t6.is("element", "$marker"))) {
                const t6 = n3.createElement("paragraph");
                n3.insert(t6, n3.createPositionAt(i3, 0));
                for (const e6 of r3)
                  n3.move(n3.createRangeOn(e6), n3.createPositionAt(t6, "end"));
              }
            }, { priority: "low" });
          };
        }
        function iT(t4) {
          let e4 = 0, n3 = 0;
          const i3 = Array.from(t4.getChildren()).filter((t5) => "th" === t5.name || "td" === t5.name);
          for (; n3 < i3.length && "th" === i3[n3].name; ) {
            const t5 = i3[n3];
            e4 += parseInt(t5.getAttribute("colspan") || "1"), n3++;
          }
          return e4;
        }
        class oT {
          constructor(t4, e4 = {}) {
            this._jumpedToStartRow = false, this._table = t4, this._startRow = void 0 !== e4.row ? e4.row : e4.startRow || 0, this._endRow = void 0 !== e4.row ? e4.row : e4.endRow, this._startColumn = void 0 !== e4.column ? e4.column : e4.startColumn || 0, this._endColumn = void 0 !== e4.column ? e4.column : e4.endColumn, this._includeAllSlots = !!e4.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
          }
          [Symbol.iterator]() {
            return this;
          }
          next() {
            this._canJumpToStartRow() && this._jumpToNonSpannedRowClosestToStartRow();
            const t4 = this._table.getChild(this._rowIndex);
            if (!t4 || this._isOverEndRow())
              return { done: true, value: void 0 };
            if (!t4.is("element", "tableRow"))
              return this._rowIndex++, this.next();
            if (this._isOverEndColumn())
              return this._advanceToNextRow();
            let e4 = null;
            const n3 = this._getSpanned();
            if (n3)
              this._includeAllSlots && !this._shouldSkipSlot() && (e4 = this._formatOutValue(n3.cell, n3.row, n3.column));
            else {
              const n4 = t4.getChild(this._cellIndex);
              if (!n4)
                return this._advanceToNextRow();
              const i3 = parseInt(n4.getAttribute("colspan") || "1"), o3 = parseInt(n4.getAttribute("rowspan") || "1");
              (i3 > 1 || o3 > 1) && this._recordSpans(n4, o3, i3), this._shouldSkipSlot() || (e4 = this._formatOutValue(n4)), this._nextCellAtColumn = this._column + i3;
            }
            return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, e4 || this.next();
          }
          skipRow(t4) {
            this._skipRows.add(t4);
          }
          _advanceToNextRow() {
            return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
          }
          _isOverEndRow() {
            return void 0 !== this._endRow && this._row > this._endRow;
          }
          _isOverEndColumn() {
            return void 0 !== this._endColumn && this._column > this._endColumn;
          }
          _formatOutValue(t4, e4 = this._row, n3 = this._column) {
            return { done: false, value: new rT(this, t4, e4, n3) };
          }
          _shouldSkipSlot() {
            const t4 = this._skipRows.has(this._row), e4 = this._row < this._startRow, n3 = this._column < this._startColumn, i3 = void 0 !== this._endColumn && this._column > this._endColumn;
            return t4 || e4 || n3 || i3;
          }
          _getSpanned() {
            const t4 = this._spannedCells.get(this._row);
            return t4 && t4.get(this._column) || null;
          }
          _recordSpans(t4, e4, n3) {
            const i3 = { cell: t4, row: this._row, column: this._column };
            for (let t5 = this._row; t5 < this._row + e4; t5++)
              for (let e5 = this._column; e5 < this._column + n3; e5++)
                t5 == this._row && e5 == this._column || this._markSpannedCell(t5, e5, i3);
          }
          _markSpannedCell(t4, e4, n3) {
            this._spannedCells.has(t4) || this._spannedCells.set(t4, /* @__PURE__ */ new Map());
            this._spannedCells.get(t4).set(e4, n3);
          }
          _canJumpToStartRow() {
            return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow;
          }
          _jumpToNonSpannedRowClosestToStartRow() {
            const t4 = this._getRowLength(0);
            for (let e4 = this._startRow; !this._jumpedToStartRow; e4--)
              t4 === this._getRowLength(e4) && (this._row = e4, this._rowIndex = e4, this._jumpedToStartRow = true);
          }
          _getRowLength(t4) {
            return [...this._table.getChild(t4).getChildren()].reduce((t5, e4) => t5 + parseInt(e4.getAttribute("colspan") || "1"), 0);
          }
        }
        class rT {
          constructor(t4, e4, n3, i3) {
            this.cell = e4, this.row = t4._row, this.column = t4._column, this.cellAnchorRow = n3, this.cellAnchorColumn = i3, this._cellIndex = t4._cellIndex, this._rowIndex = t4._rowIndex, this._table = t4._table;
          }
          get isAnchor() {
            return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
          }
          get cellWidth() {
            return parseInt(this.cell.getAttribute("colspan") || "1");
          }
          get cellHeight() {
            return parseInt(this.cell.getAttribute("rowspan") || "1");
          }
          get rowIndex() {
            return this._rowIndex;
          }
          getPositionBefore() {
            return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
          }
        }
        function sT(t4, e4) {
          return (n3, { writer: i3 }) => {
            const o3 = n3.getAttribute("headingRows") || 0, r3 = i3.createContainerElement("table", null, []), s3 = i3.createContainerElement("figure", { class: "table" }, r3);
            o3 > 0 && i3.insert(i3.createPositionAt(r3, "end"), i3.createContainerElement("thead", null, i3.createSlot((t5) => t5.is("element", "tableRow") && t5.index < o3))), o3 < t4.getRows(n3) && i3.insert(i3.createPositionAt(r3, "end"), i3.createContainerElement("tbody", null, i3.createSlot((t5) => t5.is("element", "tableRow") && t5.index >= o3)));
            for (const { positionOffset: t5, filter: n4 } of e4.additionalSlots)
              i3.insert(i3.createPositionAt(r3, t5), i3.createSlot(n4));
            return i3.insert(i3.createPositionAt(r3, "after"), i3.createSlot((t5) => !t5.is("element", "tableRow") && !e4.additionalSlots.some(({ filter: e5 }) => e5(t5)))), e4.asWidget ? function(t5, e5) {
              return e5.setCustomProperty("table", true, t5), Hb2(t5, e5, { hasSelectionHandle: true });
            }(s3, i3) : s3;
          };
        }
        function aT(t4 = {}) {
          return (e4, { writer: n3 }) => {
            const i3 = e4.parent, o3 = i3.parent, r3 = o3.getChildIndex(i3), s3 = new oT(o3, { row: r3 }), a3 = o3.getAttribute("headingRows") || 0, c3 = o3.getAttribute("headingColumns") || 0;
            let l3 = null;
            for (const i4 of s3)
              if (i4.cell == e4) {
                const e5 = i4.row < a3 || i4.column < c3 ? "th" : "td";
                l3 = t4.asWidget ? qb2(n3.createEditableElement(e5), n3) : n3.createContainerElement(e5);
                break;
              }
            return l3;
          };
        }
        function cT(t4 = {}) {
          return (e4, { writer: n3 }) => {
            if (!e4.parent.is("element", "tableCell"))
              return null;
            if (!lT(e4))
              return null;
            if (t4.asWidget)
              return n3.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
            {
              const t5 = n3.createContainerElement("p");
              return n3.setCustomProperty("dataPipeline:transparentRendering", true, t5), t5;
            }
          };
        }
        function lT(t4) {
          return 1 == t4.parent.childCount && !!t4.getAttributeKeys().next().done;
        }
        class dT extends As {
          refresh() {
            const t4 = this.editor.model, e4 = t4.document.selection, n3 = t4.schema;
            this.isEnabled = function(t5, e5) {
              const n4 = t5.getFirstPosition().parent, i3 = n4 === n4.root ? n4 : n4.parent;
              return e5.checkChild(i3, "table");
            }(e4, n3);
          }
          execute(t4 = {}) {
            const e4 = this.editor, n3 = e4.model, i3 = e4.plugins.get("TableUtils"), o3 = e4.config.get("table.defaultHeadings.rows"), r3 = e4.config.get("table.defaultHeadings.columns");
            void 0 === t4.headingRows && o3 && (t4.headingRows = o3), void 0 === t4.headingColumns && r3 && (t4.headingColumns = r3), n3.change((e5) => {
              const o4 = i3.createTable(e5, t4);
              n3.insertObject(o4, null, null, { findOptimalPosition: "auto" }), e5.setSelection(e5.createPositionAt(o4.getNodeByPath([0, 0, 0]), 0));
            });
          }
        }
        class hT extends As {
          constructor(t4, e4 = {}) {
            super(t4), this.order = e4.order || "below";
          }
          refresh() {
            const t4 = this.editor.model.document.selection, e4 = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t4).length;
            this.isEnabled = e4;
          }
          execute() {
            const t4 = this.editor, e4 = t4.model.document.selection, n3 = t4.plugins.get("TableUtils"), i3 = "above" === this.order, o3 = n3.getSelectionAffectedTableCells(e4), r3 = n3.getRowIndexes(o3), s3 = i3 ? r3.first : r3.last, a3 = o3[0].findAncestor("table");
            n3.insertRows(a3, { at: i3 ? s3 : s3 + 1, copyStructureFromAbove: !i3 });
          }
        }
        class uT extends As {
          constructor(t4, e4 = {}) {
            super(t4), this.order = e4.order || "right";
          }
          refresh() {
            const t4 = this.editor.model.document.selection, e4 = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t4).length;
            this.isEnabled = e4;
          }
          execute() {
            const t4 = this.editor, e4 = t4.model.document.selection, n3 = t4.plugins.get("TableUtils"), i3 = "left" === this.order, o3 = n3.getSelectionAffectedTableCells(e4), r3 = n3.getColumnIndexes(o3), s3 = i3 ? r3.first : r3.last, a3 = o3[0].findAncestor("table");
            n3.insertColumns(a3, { columns: 1, at: i3 ? s3 : s3 + 1 });
          }
        }
        class gT2 extends As {
          constructor(t4, e4 = {}) {
            super(t4), this.direction = e4.direction || "horizontally";
          }
          refresh() {
            const t4 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
            this.isEnabled = 1 === t4.length;
          }
          execute() {
            const t4 = this.editor.plugins.get("TableUtils"), e4 = t4.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
            "horizontally" === this.direction ? t4.splitCellHorizontally(e4, 2) : t4.splitCellVertically(e4, 2);
          }
        }
        function mT(t4, e4, n3) {
          const { startRow: i3, startColumn: o3, endRow: r3, endColumn: s3 } = e4, a3 = n3.createElement("table"), c3 = r3 - i3 + 1;
          for (let t5 = 0; t5 < c3; t5++)
            n3.insertElement("tableRow", a3, "end");
          const l3 = [...new oT(t4, { startRow: i3, endRow: r3, startColumn: o3, endColumn: s3, includeAllSlots: true })];
          for (const { row: t5, column: e5, cell: c4, isAnchor: d3, cellAnchorRow: h3, cellAnchorColumn: u3 } of l3) {
            const l4 = t5 - i3, g3 = a3.getChild(l4);
            if (d3) {
              const i4 = n3.cloneElement(c4);
              n3.append(i4, g3), wT(i4, t5, e5, r3, s3, n3);
            } else
              (h3 < i3 || u3 < o3) && QS(n3, n3.createPositionAt(g3, "end"));
          }
          return function(t5, e5, n4, i4, o4) {
            const r4 = parseInt(e5.getAttribute("headingRows") || "0");
            if (r4 > 0) {
              YS("headingRows", r4 - n4, t5, o4, 0);
            }
            const s4 = parseInt(e5.getAttribute("headingColumns") || "0");
            if (s4 > 0) {
              YS("headingColumns", s4 - i4, t5, o4, 0);
            }
          }(a3, t4, i3, o3, n3), a3;
        }
        function pT(t4, e4, n3 = 0) {
          const i3 = [], o3 = new oT(t4, { startRow: n3, endRow: e4 - 1 });
          for (const t5 of o3) {
            const { row: n4, cellHeight: o4 } = t5;
            n4 < e4 && e4 <= n4 + o4 - 1 && i3.push(t5);
          }
          return i3;
        }
        function fT(t4, e4, n3) {
          const i3 = t4.parent, o3 = i3.parent, r3 = i3.index, s3 = e4 - r3, a3 = {}, c3 = parseInt(t4.getAttribute("rowspan")) - s3;
          c3 > 1 && (a3.rowspan = c3);
          const l3 = parseInt(t4.getAttribute("colspan") || "1");
          l3 > 1 && (a3.colspan = l3);
          const d3 = r3 + s3, h3 = [...new oT(o3, { startRow: r3, endRow: d3, includeAllSlots: true })];
          let u3, g3 = null;
          for (const e5 of h3) {
            const { row: i4, column: o4, cell: r4 } = e5;
            r4 === t4 && void 0 === u3 && (u3 = o4), void 0 !== u3 && u3 === o4 && i4 === d3 && (g3 = QS(n3, e5.getPositionBefore(), a3));
          }
          return YS("rowspan", s3, t4, n3), g3;
        }
        function kT(t4, e4) {
          const n3 = [], i3 = new oT(t4);
          for (const t5 of i3) {
            const { column: i4, cellWidth: o3 } = t5;
            i4 < e4 && e4 <= i4 + o3 - 1 && n3.push(t5);
          }
          return n3;
        }
        function bT(t4, e4, n3, i3) {
          const o3 = n3 - e4, r3 = {}, s3 = parseInt(t4.getAttribute("colspan")) - o3;
          s3 > 1 && (r3.colspan = s3);
          const a3 = parseInt(t4.getAttribute("rowspan") || "1");
          a3 > 1 && (r3.rowspan = a3);
          const c3 = QS(i3, i3.createPositionAfter(t4), r3);
          return YS("colspan", o3, t4, i3), c3;
        }
        function wT(t4, e4, n3, i3, o3, r3) {
          const s3 = parseInt(t4.getAttribute("colspan") || "1"), a3 = parseInt(t4.getAttribute("rowspan") || "1");
          if (n3 + s3 - 1 > o3) {
            YS("colspan", o3 - n3 + 1, t4, r3, 1);
          }
          if (e4 + a3 - 1 > i3) {
            YS("rowspan", i3 - e4 + 1, t4, r3, 1);
          }
        }
        function AT(t4, e4) {
          const n3 = e4.getColumns(t4), i3 = new Array(n3).fill(0);
          for (const { column: e5 } of new oT(t4))
            i3[e5]++;
          const o3 = i3.reduce((t5, e5, n4) => e5 ? t5 : [...t5, n4], []);
          if (o3.length > 0) {
            const n4 = o3[o3.length - 1];
            return e4.removeColumns(t4, { at: n4 }), true;
          }
          return false;
        }
        function CT(t4, e4) {
          const n3 = [], i3 = e4.getRows(t4);
          for (let e5 = 0; e5 < i3; e5++) {
            t4.getChild(e5).isEmpty && n3.push(e5);
          }
          if (n3.length > 0) {
            const i4 = n3[n3.length - 1];
            return e4.removeRows(t4, { at: i4 }), true;
          }
          return false;
        }
        function _T(t4, e4) {
          AT(t4, e4) || CT(t4, e4);
        }
        function vT(t4, e4) {
          const n3 = Array.from(new oT(t4, { startColumn: e4.firstColumn, endColumn: e4.lastColumn, row: e4.lastRow }));
          if (n3.every(({ cellHeight: t5 }) => 1 === t5))
            return e4.lastRow;
          const i3 = n3[0].cellHeight - 1;
          return e4.lastRow + i3;
        }
        function yT(t4, e4) {
          const n3 = Array.from(new oT(t4, { startRow: e4.firstRow, endRow: e4.lastRow, column: e4.lastColumn }));
          if (n3.every(({ cellWidth: t5 }) => 1 === t5))
            return e4.lastColumn;
          const i3 = n3[0].cellWidth - 1;
          return e4.lastColumn + i3;
        }
        class xT extends As {
          constructor(t4, e4) {
            super(t4), this.direction = e4.direction, this.isHorizontal = "right" == this.direction || "left" == this.direction;
          }
          refresh() {
            const t4 = this._getMergeableCell();
            this.value = t4, this.isEnabled = !!t4;
          }
          execute() {
            const t4 = this.editor.model, e4 = t4.document, n3 = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(e4.selection)[0], i3 = this.value, o3 = this.direction;
            t4.change((t5) => {
              const e5 = "right" == o3 || "down" == o3, r3 = e5 ? n3 : i3, s3 = e5 ? i3 : n3, a3 = s3.parent;
              !function(t6, e6, n4) {
                ET(t6) || (ET(e6) && n4.remove(n4.createRangeIn(e6)), n4.move(n4.createRangeIn(t6), n4.createPositionAt(e6, "end")));
                n4.remove(t6);
              }(s3, r3, t5);
              const c3 = this.isHorizontal ? "colspan" : "rowspan", l3 = parseInt(n3.getAttribute(c3) || "1"), d3 = parseInt(i3.getAttribute(c3) || "1");
              t5.setAttribute(c3, l3 + d3, r3), t5.setSelection(t5.createRangeIn(r3));
              const h3 = this.editor.plugins.get("TableUtils");
              _T(a3.findAncestor("table"), h3);
            });
          }
          _getMergeableCell() {
            const t4 = this.editor.model.document, e4 = this.editor.plugins.get("TableUtils"), n3 = e4.getTableCellsContainingSelection(t4.selection)[0];
            if (!n3)
              return;
            const i3 = this.isHorizontal ? function(t5, e5, n4) {
              const i4 = t5.parent, o4 = i4.parent, r4 = "right" == e5 ? t5.nextSibling : t5.previousSibling, s3 = (o4.getAttribute("headingColumns") || 0) > 0;
              if (!r4)
                return;
              const a3 = "right" == e5 ? t5 : r4, c3 = "right" == e5 ? r4 : t5, { column: l3 } = n4.getCellLocation(a3), { column: d3 } = n4.getCellLocation(c3), h3 = parseInt(a3.getAttribute("colspan") || "1"), u3 = JS(n4, a3), g3 = JS(n4, c3);
              if (s3 && u3 != g3)
                return;
              return l3 + h3 === d3 ? r4 : void 0;
            }(n3, this.direction, e4) : function(t5, e5, n4) {
              const i4 = t5.parent, o4 = i4.parent, r4 = o4.getChildIndex(i4);
              if ("down" == e5 && r4 === n4.getRows(o4) - 1 || "up" == e5 && 0 === r4)
                return null;
              const s3 = parseInt(t5.getAttribute("rowspan") || "1"), a3 = o4.getAttribute("headingRows") || 0, c3 = "down" == e5 && r4 + s3 === a3, l3 = "up" == e5 && r4 === a3;
              if (a3 && (c3 || l3))
                return null;
              const d3 = parseInt(t5.getAttribute("rowspan") || "1"), h3 = "down" == e5 ? r4 + d3 : r4, u3 = [...new oT(o4, { endRow: h3 })], g3 = u3.find((e6) => e6.cell === t5), m3 = g3.column, p3 = u3.find(({ row: t6, cellHeight: n5, column: i5 }) => i5 === m3 && ("down" == e5 ? t6 === h3 : h3 === t6 + n5));
              return p3 && p3.cell ? p3.cell : null;
            }(n3, this.direction, e4);
            if (!i3)
              return;
            const o3 = this.isHorizontal ? "rowspan" : "colspan", r3 = parseInt(n3.getAttribute(o3) || "1");
            return parseInt(i3.getAttribute(o3) || "1") === r3 ? i3 : void 0;
          }
        }
        function ET(t4) {
          const e4 = t4.getChild(0);
          return 1 == t4.childCount && e4.is("element", "paragraph") && e4.isEmpty;
        }
        class DT extends As {
          refresh() {
            const t4 = this.editor.plugins.get("TableUtils"), e4 = t4.getSelectionAffectedTableCells(this.editor.model.document.selection), n3 = e4[0];
            if (n3) {
              const i3 = n3.findAncestor("table"), o3 = t4.getRows(i3) - 1, r3 = t4.getRowIndexes(e4), s3 = 0 === r3.first && r3.last === o3;
              this.isEnabled = !s3;
            } else
              this.isEnabled = false;
          }
          execute() {
            const t4 = this.editor.model, e4 = this.editor.plugins.get("TableUtils"), n3 = e4.getSelectionAffectedTableCells(t4.document.selection), i3 = e4.getRowIndexes(n3), o3 = n3[0], r3 = o3.findAncestor("table"), s3 = e4.getCellLocation(o3).column;
            t4.change((t5) => {
              const n4 = i3.last - i3.first + 1;
              e4.removeRows(r3, { at: i3.first, rows: n4 });
              const o4 = function(t6, e5, n5, i4) {
                const o5 = t6.getChild(Math.min(e5, i4 - 1));
                let r4 = o5.getChild(0), s4 = 0;
                for (const t7 of o5.getChildren()) {
                  if (s4 > n5)
                    return r4;
                  r4 = t7, s4 += parseInt(t7.getAttribute("colspan") || "1");
                }
                return r4;
              }(r3, i3.first, s3, e4.getRows(r3));
              t5.setSelection(t5.createPositionAt(o4, 0));
            });
          }
        }
        class ST extends As {
          refresh() {
            const t4 = this.editor.plugins.get("TableUtils"), e4 = t4.getSelectionAffectedTableCells(this.editor.model.document.selection), n3 = e4[0];
            if (n3) {
              const i3 = n3.findAncestor("table"), o3 = t4.getColumns(i3), { first: r3, last: s3 } = t4.getColumnIndexes(e4);
              this.isEnabled = s3 - r3 < o3 - 1;
            } else
              this.isEnabled = false;
          }
          execute() {
            const t4 = this.editor.plugins.get("TableUtils"), [e4, n3] = function(t5, e5) {
              const n4 = e5.getSelectionAffectedTableCells(t5), i4 = n4[0], o4 = n4.pop(), r4 = [i4, o4];
              return i4.isBefore(o4) ? r4 : r4.reverse();
            }(this.editor.model.document.selection, t4), i3 = e4.parent.parent, o3 = [...new oT(i3)], r3 = { first: o3.find((t5) => t5.cell === e4).column, last: o3.find((t5) => t5.cell === n3).column }, s3 = function(t5, e5, n4, i4) {
              const o4 = parseInt(n4.getAttribute("colspan") || "1");
              return o4 > 1 ? n4 : e5.previousSibling || n4.nextSibling ? n4.nextSibling || e5.previousSibling : i4.first ? t5.reverse().find(({ column: t6 }) => t6 < i4.first).cell : t5.reverse().find(({ column: t6 }) => t6 > i4.last).cell;
            }(o3, e4, n3, r3);
            this.editor.model.change((e5) => {
              const n4 = r3.last - r3.first + 1;
              t4.removeColumns(i3, { at: r3.first, columns: n4 }), e5.setSelection(e5.createPositionAt(s3, 0));
            });
          }
        }
        class TT extends As {
          refresh() {
            const t4 = this.editor.plugins.get("TableUtils"), e4 = this.editor.model, n3 = t4.getSelectionAffectedTableCells(e4.document.selection), i3 = n3.length > 0;
            this.isEnabled = i3, this.value = i3 && n3.every((t5) => this._isInHeading(t5, t5.parent.parent));
          }
          execute(t4 = {}) {
            if (t4.forceValue === this.value)
              return;
            const e4 = this.editor.plugins.get("TableUtils"), n3 = this.editor.model, i3 = e4.getSelectionAffectedTableCells(n3.document.selection), o3 = i3[0].findAncestor("table"), { first: r3, last: s3 } = e4.getRowIndexes(i3), a3 = this.value ? r3 : s3 + 1, c3 = o3.getAttribute("headingRows") || 0;
            n3.change((t5) => {
              if (a3) {
                const e5 = pT(o3, a3, a3 > c3 ? c3 : 0);
                for (const { cell: n4 } of e5)
                  fT(n4, a3, t5);
              }
              YS("headingRows", a3, o3, t5, 0);
            });
          }
          _isInHeading(t4, e4) {
            const n3 = parseInt(e4.getAttribute("headingRows") || "0");
            return !!n3 && t4.parent.index < n3;
          }
        }
        class IT extends As {
          refresh() {
            const t4 = this.editor.model, e4 = this.editor.plugins.get("TableUtils"), n3 = e4.getSelectionAffectedTableCells(t4.document.selection), i3 = n3.length > 0;
            this.isEnabled = i3, this.value = i3 && n3.every((t5) => JS(e4, t5));
          }
          execute(t4 = {}) {
            if (t4.forceValue === this.value)
              return;
            const e4 = this.editor.plugins.get("TableUtils"), n3 = this.editor.model, i3 = e4.getSelectionAffectedTableCells(n3.document.selection), o3 = i3[0].findAncestor("table"), { first: r3, last: s3 } = e4.getColumnIndexes(i3), a3 = this.value ? r3 : s3 + 1;
            n3.change((t5) => {
              if (a3) {
                const e5 = kT(o3, a3);
                for (const { cell: n4, column: i4 } of e5)
                  bT(n4, i4, a3, t5);
              }
              YS("headingColumns", a3, o3, t5, 0);
            });
          }
        }
        const BT = 5, MT = 2;
        function NT(t4, e4) {
          return 4e3 / LT(t4, e4);
        }
        function LT(t4, e4) {
          const n3 = zT(t4, "tbody", e4) || zT(t4, "thead", e4);
          return PT(e4.editing.view.domConverter.mapViewToDom(n3));
        }
        function zT(t4, e4, n3) {
          return [...[...n3.editing.mapper.toViewElement(t4).getChildren()].find((t5) => t5.is("element", "table")).getChildren()].find((t5) => t5.is("element", e4));
        }
        function PT(t4) {
          const e4 = Li2.window.getComputedStyle(t4);
          return "border-box" === e4.boxSizing ? parseFloat(e4.width) - parseFloat(e4.paddingLeft) - parseFloat(e4.paddingRight) - parseFloat(e4.borderLeftWidth) - parseFloat(e4.borderRightWidth) : parseFloat(e4.width);
        }
        function RT(t4) {
          const e4 = Math.pow(10, MT), n3 = "number" == typeof t4 ? t4 : parseFloat(t4);
          return Math.round(n3 * e4) / e4;
        }
        function OT(t4) {
          return t4.map((t5) => "number" == typeof t5 ? t5 : parseFloat(t5)).filter((t5) => !Number.isNaN(t5)).reduce((t5, e4) => t5 + e4, 0);
        }
        function FT(t4) {
          let e4 = function(t5) {
            const e5 = t5.filter((t6) => "auto" === t6).length;
            if (0 === e5)
              return t5.map((t6) => RT(t6));
            const n4 = OT(t5), i3 = Math.max((100 - n4) / e5, BT);
            return t5.map((t6) => "auto" === t6 ? i3 : t6).map((t6) => RT(t6));
          }(t4.map((t5) => "auto" === t5 ? t5 : parseFloat(t5.replace("%", ""))));
          const n3 = OT(e4);
          return 100 !== n3 && (e4 = e4.map((t5) => RT(100 * t5 / n3)).map((t5, e5, n4) => {
            if (!(e5 === n4.length - 1))
              return t5;
            return RT(t5 + 100 - OT(n4));
          })), e4.map((t5) => t5 + "%");
        }
        function VT(t4) {
          const e4 = Li2.window.getComputedStyle(t4);
          return "border-box" === e4.boxSizing ? parseInt(e4.width) : parseFloat(e4.width) + parseFloat(e4.paddingLeft) + parseFloat(e4.paddingRight) + parseFloat(e4.borderWidth);
        }
        function jT(t4, e4, n3, i3) {
          for (let o3 = 0; o3 < Math.max(n3.length, t4.length); o3++) {
            const r3 = t4[o3], s3 = n3[o3];
            s3 ? r3 ? i3.setAttribute("columnWidth", s3, r3) : i3.appendElement("tableColumn", { columnWidth: s3 }, e4) : i3.remove(r3);
          }
        }
        function HT(t4) {
          if (t4.is("element", "tableColumnGroup"))
            return t4;
          const e4 = t4.getChildren();
          return Array.from(e4).find((t5) => t5.is("element", "tableColumnGroup"));
        }
        function UT(t4) {
          const e4 = HT(t4);
          return e4 ? Array.from(e4.getChildren()) : [];
        }
        class GT extends bs {
          static get pluginName() {
            return "TableUtils";
          }
          init() {
            this.decorate("insertColumns"), this.decorate("insertRows");
          }
          getCellLocation(t4) {
            const e4 = t4.parent, n3 = e4.parent, i3 = n3.getChildIndex(e4), o3 = new oT(n3, { row: i3 });
            for (const { cell: e5, row: n4, column: i4 } of o3)
              if (e5 === t4)
                return { row: n4, column: i4 };
          }
          createTable(t4, e4) {
            const n3 = t4.createElement("table"), i3 = e4.rows || 2, o3 = e4.columns || 2;
            return WT(t4, n3, 0, i3, o3), e4.headingRows && YS("headingRows", Math.min(e4.headingRows, i3), n3, t4, 0), e4.headingColumns && YS("headingColumns", Math.min(e4.headingColumns, o3), n3, t4, 0), n3;
          }
          insertRows(t4, e4 = {}) {
            const n3 = this.editor.model, i3 = e4.at || 0, o3 = e4.rows || 1, r3 = void 0 !== e4.copyStructureFromAbove, s3 = e4.copyStructureFromAbove ? i3 - 1 : i3, a3 = this.getRows(t4), c3 = this.getColumns(t4);
            if (i3 > a3)
              throw new C2("tableutils-insertrows-insert-out-of-range", this, { options: e4 });
            n3.change((e5) => {
              const n4 = t4.getAttribute("headingRows") || 0;
              if (n4 > i3 && YS("headingRows", n4 + o3, t4, e5, 0), !r3 && (0 === i3 || i3 === a3))
                return void WT(e5, t4, i3, o3, c3);
              const l3 = r3 ? Math.max(i3, s3) : i3, d3 = new oT(t4, { endRow: l3 }), h3 = new Array(c3).fill(1);
              for (const { row: t5, column: n5, cellHeight: a4, cellWidth: c4, cell: l4 } of d3) {
                const d4 = t5 + a4 - 1, u3 = t5 <= s3 && s3 <= d4;
                t5 < i3 && i3 <= d4 ? (e5.setAttribute("rowspan", a4 + o3, l4), h3[n5] = -c4) : r3 && u3 && (h3[n5] = c4);
              }
              for (let n5 = 0; n5 < o3; n5++) {
                const n6 = e5.createElement("tableRow");
                e5.insert(n6, t4, i3);
                for (let t5 = 0; t5 < h3.length; t5++) {
                  const i4 = h3[t5], o4 = e5.createPositionAt(n6, "end");
                  i4 > 0 && QS(e5, o4, i4 > 1 ? { colspan: i4 } : void 0), t5 += Math.abs(i4) - 1;
                }
              }
            });
          }
          insertColumns(t4, e4 = {}) {
            const n3 = this.editor.model, i3 = e4.at || 0, o3 = e4.columns || 1;
            n3.change((e5) => {
              const n4 = t4.getAttribute("headingColumns");
              i3 < n4 && e5.setAttribute("headingColumns", n4 + o3, t4);
              const r3 = this.getColumns(t4);
              if (0 === i3 || r3 === i3) {
                for (const n5 of t4.getChildren())
                  n5.is("element", "tableRow") && qT(o3, e5, e5.createPositionAt(n5, i3 ? "end" : 0));
                return;
              }
              const s3 = new oT(t4, { column: i3, includeAllSlots: true });
              for (const t5 of s3) {
                const { row: n5, cell: r4, cellAnchorColumn: a3, cellAnchorRow: c3, cellWidth: l3, cellHeight: d3 } = t5;
                if (a3 < i3) {
                  e5.setAttribute("colspan", l3 + o3, r4);
                  const t6 = c3 + d3 - 1;
                  for (let e6 = n5; e6 <= t6; e6++)
                    s3.skipRow(e6);
                } else
                  qT(o3, e5, t5.getPositionBefore());
              }
            });
          }
          removeRows(t4, e4) {
            const n3 = this.editor.model, i3 = e4.rows || 1, o3 = this.getRows(t4), r3 = e4.at, s3 = r3 + i3 - 1;
            if (s3 > o3 - 1)
              throw new C2("tableutils-removerows-row-index-out-of-range", this, { table: t4, options: e4 });
            n3.change((e5) => {
              const n4 = { first: r3, last: s3 }, { cellsToMove: i4, cellsToTrim: o4 } = function(t5, { first: e6, last: n5 }) {
                const i5 = /* @__PURE__ */ new Map(), o5 = [];
                for (const { row: r4, column: s4, cellHeight: a3, cell: c3 } of new oT(t5, { endRow: n5 })) {
                  const t6 = r4 + a3 - 1;
                  if (r4 >= e6 && r4 <= n5 && t6 > n5) {
                    const t7 = a3 - (n5 - r4 + 1);
                    i5.set(s4, { cell: c3, rowspan: t7 });
                  }
                  if (r4 < e6 && t6 >= e6) {
                    let i6;
                    i6 = t6 >= n5 ? n5 - e6 + 1 : t6 - e6 + 1, o5.push({ cell: c3, rowspan: a3 - i6 });
                  }
                }
                return { cellsToMove: i5, cellsToTrim: o5 };
              }(t4, n4);
              if (i4.size) {
                !function(t5, e6, n5, i5) {
                  const o5 = new oT(t5, { includeAllSlots: true, row: e6 }), r4 = [...o5], s4 = t5.getChild(e6);
                  let a3;
                  for (const { column: t6, cell: e7, isAnchor: o6 } of r4)
                    if (n5.has(t6)) {
                      const { cell: e8, rowspan: o7 } = n5.get(t6), r5 = a3 ? i5.createPositionAfter(a3) : i5.createPositionAt(s4, 0);
                      i5.move(i5.createRangeOn(e8), r5), YS("rowspan", o7, e8, i5), a3 = e8;
                    } else
                      o6 && (a3 = e7);
                }(t4, s3 + 1, i4, e5);
              }
              for (let n5 = s3; n5 >= r3; n5--)
                e5.remove(t4.getChild(n5));
              for (const { rowspan: t5, cell: n5 } of o4)
                YS("rowspan", t5, n5, e5);
              !function(t5, { first: e6, last: n5 }, i5) {
                const o5 = t5.getAttribute("headingRows") || 0;
                if (e6 < o5) {
                  YS("headingRows", n5 < o5 ? o5 - (n5 - e6 + 1) : e6, t5, i5, 0);
                }
              }(t4, n4, e5), AT(t4, this) || CT(t4, this);
            });
          }
          removeColumns(t4, e4) {
            const n3 = this.editor.model, i3 = e4.at, o3 = e4.columns || 1, r3 = e4.at + o3 - 1;
            n3.change((e5) => {
              !function(t5, e6, n5) {
                const i4 = t5.getAttribute("headingColumns") || 0;
                if (i4 && e6.first < i4) {
                  const o4 = Math.min(i4 - 1, e6.last) - e6.first + 1;
                  n5.setAttribute("headingColumns", i4 - o4, t5);
                }
              }(t4, { first: i3, last: r3 }, e5);
              const n4 = UT(t4);
              for (let o4 = r3; o4 >= i3; o4--) {
                for (const { cell: n5, column: i4, cellWidth: r4 } of [...new oT(t4)])
                  i4 <= o4 && r4 > 1 && i4 + r4 > o4 ? YS("colspan", r4 - 1, n5, e5) : i4 === o4 && e5.remove(n5);
                if (n4[o4]) {
                  const t5 = 0 === o4 ? n4[1] : n4[o4 - 1], i4 = parseFloat(n4[o4].getAttribute("columnWidth")), r4 = parseFloat(t5.getAttribute("columnWidth"));
                  e5.remove(n4[o4]), e5.setAttribute("columnWidth", i4 + r4 + "%", t5);
                }
              }
              CT(t4, this) || AT(t4, this);
            });
          }
          splitCellVertically(t4, e4 = 2) {
            const n3 = this.editor.model, i3 = t4.parent.parent, o3 = parseInt(t4.getAttribute("rowspan") || "1"), r3 = parseInt(t4.getAttribute("colspan") || "1");
            n3.change((n4) => {
              if (r3 > 1) {
                const { newCellsSpan: i4, updatedSpan: s3 } = $T(r3, e4);
                YS("colspan", s3, t4, n4);
                const a3 = {};
                i4 > 1 && (a3.colspan = i4), o3 > 1 && (a3.rowspan = o3);
                qT(r3 > e4 ? e4 - 1 : r3 - 1, n4, n4.createPositionAfter(t4), a3);
              }
              if (r3 < e4) {
                const s3 = e4 - r3, a3 = [...new oT(i3)], { column: c3 } = a3.find(({ cell: e5 }) => e5 === t4), l3 = a3.filter(({ cell: e5, cellWidth: n5, column: i4 }) => e5 !== t4 && i4 === c3 || i4 < c3 && i4 + n5 > c3);
                for (const { cell: t5, cellWidth: e5 } of l3)
                  n4.setAttribute("colspan", e5 + s3, t5);
                const d3 = {};
                o3 > 1 && (d3.rowspan = o3), qT(s3, n4, n4.createPositionAfter(t4), d3);
                const h3 = i3.getAttribute("headingColumns") || 0;
                h3 > c3 && YS("headingColumns", h3 + s3, i3, n4);
              }
            });
          }
          splitCellHorizontally(t4, e4 = 2) {
            const n3 = this.editor.model, i3 = t4.parent, o3 = i3.parent, r3 = o3.getChildIndex(i3), s3 = parseInt(t4.getAttribute("rowspan") || "1"), a3 = parseInt(t4.getAttribute("colspan") || "1");
            n3.change((n4) => {
              if (s3 > 1) {
                const i4 = [...new oT(o3, { startRow: r3, endRow: r3 + s3 - 1, includeAllSlots: true })], { newCellsSpan: c3, updatedSpan: l3 } = $T(s3, e4);
                YS("rowspan", l3, t4, n4);
                const { column: d3 } = i4.find(({ cell: e5 }) => e5 === t4), h3 = {};
                c3 > 1 && (h3.rowspan = c3), a3 > 1 && (h3.colspan = a3);
                for (const t5 of i4) {
                  const { column: e5, row: i5 } = t5;
                  i5 >= r3 + l3 && e5 === d3 && (i5 + r3 + l3) % c3 == 0 && qT(1, n4, t5.getPositionBefore(), h3);
                }
              }
              if (s3 < e4) {
                const i4 = e4 - s3, c3 = [...new oT(o3, { startRow: 0, endRow: r3 })];
                for (const { cell: e5, cellHeight: o4, row: s4 } of c3)
                  if (e5 !== t4 && s4 + o4 > r3) {
                    const t5 = o4 + i4;
                    n4.setAttribute("rowspan", t5, e5);
                  }
                const l3 = {};
                a3 > 1 && (l3.colspan = a3), WT(n4, o3, r3 + 1, i4, 1, l3);
                const d3 = o3.getAttribute("headingRows") || 0;
                d3 > r3 && YS("headingRows", d3 + i4, o3, n4);
              }
            });
          }
          getColumns(t4) {
            return [...t4.getChild(0).getChildren()].reduce((t5, e4) => t5 + parseInt(e4.getAttribute("colspan") || "1"), 0);
          }
          getRows(t4) {
            return Array.from(t4.getChildren()).reduce((t5, e4) => e4.is("element", "tableRow") ? t5 + 1 : t5, 0);
          }
          createTableWalker(t4, e4 = {}) {
            return new oT(t4, e4);
          }
          getSelectedTableCells(t4) {
            const e4 = [];
            for (const n3 of this.sortRanges(t4.getRanges())) {
              const t5 = n3.getContainedElement();
              t5 && t5.is("element", "tableCell") && e4.push(t5);
            }
            return e4;
          }
          getTableCellsContainingSelection(t4) {
            const e4 = [];
            for (const n3 of t4.getRanges()) {
              const t5 = n3.start.findAncestor("tableCell");
              t5 && e4.push(t5);
            }
            return e4;
          }
          getSelectionAffectedTableCells(t4) {
            const e4 = this.getSelectedTableCells(t4);
            return e4.length ? e4 : this.getTableCellsContainingSelection(t4);
          }
          getRowIndexes(t4) {
            const e4 = t4.map((t5) => t5.parent.index);
            return this._getFirstLastIndexesObject(e4);
          }
          getColumnIndexes(t4) {
            const e4 = t4[0].findAncestor("table"), n3 = [...new oT(e4)].filter((e5) => t4.includes(e5.cell)).map((t5) => t5.column);
            return this._getFirstLastIndexesObject(n3);
          }
          isSelectionRectangular(t4) {
            if (t4.length < 2 || !this._areCellInTheSameTableSection(t4))
              return false;
            const e4 = /* @__PURE__ */ new Set(), n3 = /* @__PURE__ */ new Set();
            let i3 = 0;
            for (const o4 of t4) {
              const { row: t5, column: r3 } = this.getCellLocation(o4), s3 = parseInt(o4.getAttribute("rowspan")) || 1, a3 = parseInt(o4.getAttribute("colspan")) || 1;
              e4.add(t5), n3.add(r3), s3 > 1 && e4.add(t5 + s3 - 1), a3 > 1 && n3.add(r3 + a3 - 1), i3 += s3 * a3;
            }
            const o3 = function(t5, e5) {
              const n4 = Array.from(t5.values()), i4 = Array.from(e5.values()), o4 = Math.max(...n4), r3 = Math.min(...n4), s3 = Math.max(...i4), a3 = Math.min(...i4);
              return (o4 - r3 + 1) * (s3 - a3 + 1);
            }(e4, n3);
            return o3 == i3;
          }
          sortRanges(t4) {
            return Array.from(t4).sort(KT);
          }
          _getFirstLastIndexesObject(t4) {
            const e4 = t4.sort((t5, e5) => t5 - e5);
            return { first: e4[0], last: e4[e4.length - 1] };
          }
          _areCellInTheSameTableSection(t4) {
            const e4 = t4[0].findAncestor("table"), n3 = this.getRowIndexes(t4), i3 = parseInt(e4.getAttribute("headingRows")) || 0;
            if (!this._areIndexesInSameSection(n3, i3))
              return false;
            const o3 = this.getColumnIndexes(t4), r3 = parseInt(e4.getAttribute("headingColumns")) || 0;
            return this._areIndexesInSameSection(o3, r3);
          }
          _areIndexesInSameSection({ first: t4, last: e4 }, n3) {
            return t4 < n3 === e4 < n3;
          }
        }
        function WT(t4, e4, n3, i3, o3, r3 = {}) {
          for (let s3 = 0; s3 < i3; s3++) {
            const i4 = t4.createElement("tableRow");
            t4.insert(i4, e4, n3), qT(o3, t4, t4.createPositionAt(i4, "end"), r3);
          }
        }
        function qT(t4, e4, n3, i3 = {}) {
          for (let o3 = 0; o3 < t4; o3++)
            QS(e4, n3, i3);
        }
        function $T(t4, e4) {
          if (t4 < e4)
            return { newCellsSpan: 1, updatedSpan: 1 };
          const n3 = Math.floor(t4 / e4);
          return { newCellsSpan: n3, updatedSpan: t4 - n3 * e4 + n3 };
        }
        function KT(t4, e4) {
          const n3 = t4.start, i3 = e4.start;
          return n3.isBefore(i3) ? -1 : 1;
        }
        class ZT extends As {
          refresh() {
            const t4 = this.editor.plugins.get(GT), e4 = t4.getSelectedTableCells(this.editor.model.document.selection);
            this.isEnabled = t4.isSelectionRectangular(e4);
          }
          execute() {
            const t4 = this.editor.model, e4 = this.editor.plugins.get(GT);
            t4.change((n3) => {
              const i3 = e4.getSelectedTableCells(t4.document.selection), o3 = i3.shift(), { mergeWidth: r3, mergeHeight: s3 } = function(t5, e5, n4) {
                let i4 = 0, o4 = 0;
                for (const t6 of e5) {
                  const { row: e6, column: r5 } = n4.getCellLocation(t6);
                  i4 = JT(t6, r5, i4, "colspan"), o4 = JT(t6, e6, o4, "rowspan");
                }
                const { row: r4, column: s4 } = n4.getCellLocation(t5), a3 = i4 - s4, c3 = o4 - r4;
                return { mergeWidth: a3, mergeHeight: c3 };
              }(o3, i3, e4);
              YS("colspan", r3, o3, n3), YS("rowspan", s3, o3, n3);
              for (const t5 of i3)
                YT(t5, o3, n3);
              _T(o3.findAncestor("table"), e4), n3.setSelection(o3, "in");
            });
          }
        }
        function YT(t4, e4, n3) {
          QT(t4) || (QT(e4) && n3.remove(n3.createRangeIn(e4)), n3.move(n3.createRangeIn(t4), n3.createPositionAt(e4, "end"))), n3.remove(t4);
        }
        function QT(t4) {
          const e4 = t4.getChild(0);
          return 1 == t4.childCount && e4.is("element", "paragraph") && e4.isEmpty;
        }
        function JT(t4, e4, n3, i3) {
          const o3 = parseInt(t4.getAttribute(i3) || "1");
          return Math.max(n3, e4 + o3);
        }
        class XT extends As {
          constructor(t4) {
            super(t4), this.affectsData = false;
          }
          refresh() {
            const t4 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
            this.isEnabled = t4.length > 0;
          }
          execute() {
            const t4 = this.editor.model, e4 = this.editor.plugins.get("TableUtils"), n3 = e4.getSelectionAffectedTableCells(t4.document.selection), i3 = e4.getRowIndexes(n3), o3 = n3[0].findAncestor("table"), r3 = [];
            for (let e5 = i3.first; e5 <= i3.last; e5++)
              for (const n4 of o3.getChild(e5).getChildren())
                r3.push(t4.createRangeOn(n4));
            t4.change((t5) => {
              t5.setSelection(r3);
            });
          }
        }
        class tI extends As {
          constructor(t4) {
            super(t4), this.affectsData = false;
          }
          refresh() {
            const t4 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
            this.isEnabled = t4.length > 0;
          }
          execute() {
            const t4 = this.editor.plugins.get("TableUtils"), e4 = this.editor.model, n3 = t4.getSelectionAffectedTableCells(e4.document.selection), i3 = n3[0], o3 = n3.pop(), r3 = i3.findAncestor("table"), s3 = t4.getCellLocation(i3), a3 = t4.getCellLocation(o3), c3 = Math.min(s3.column, a3.column), l3 = Math.max(s3.column, a3.column), d3 = [];
            for (const t5 of new oT(r3, { startColumn: c3, endColumn: l3 }))
              d3.push(e4.createRangeOn(t5.cell));
            e4.change((t5) => {
              t5.setSelection(d3);
            });
          }
        }
        function eI(t4) {
          t4.document.registerPostFixer((e4) => function(t5, e5) {
            const n3 = e5.document.differ.getChanges();
            let i3 = false;
            const o3 = /* @__PURE__ */ new Set();
            for (const e6 of n3) {
              let n4 = null;
              "insert" == e6.type && "table" == e6.name && (n4 = e6.position.nodeAfter), "insert" != e6.type && "remove" != e6.type || "tableRow" != e6.name && "tableCell" != e6.name || (n4 = e6.position.findAncestor("table")), oI(e6) && (n4 = e6.range.start.findAncestor("table")), n4 && !o3.has(n4) && (i3 = nI(n4, t5) || i3, i3 = iI(n4, t5) || i3, o3.add(n4));
            }
            return i3;
          }(e4, t4));
        }
        function nI(t4, e4) {
          let n3 = false;
          const i3 = function(t5) {
            const e5 = parseInt(t5.getAttribute("headingRows") || "0"), n4 = Array.from(t5.getChildren()).reduce((t6, e6) => e6.is("element", "tableRow") ? t6 + 1 : t6, 0), i4 = [];
            for (const { row: o3, cell: r3, cellHeight: s3 } of new oT(t5)) {
              if (s3 < 2)
                continue;
              const t6 = o3 < e5 ? e5 : n4;
              if (o3 + s3 > t6) {
                const e6 = t6 - o3;
                i4.push({ cell: r3, rowspan: e6 });
              }
            }
            return i4;
          }(t4);
          if (i3.length) {
            n3 = true;
            for (const t5 of i3)
              YS("rowspan", t5.rowspan, t5.cell, e4, 1);
          }
          return n3;
        }
        function iI(t4, e4) {
          let n3 = false;
          const i3 = function(t5) {
            const e5 = new Array(t5.childCount).fill(0);
            for (const { rowIndex: n4 } of new oT(t5, { includeAllSlots: true }))
              e5[n4]++;
            return e5;
          }(t4), o3 = [];
          for (const [e5, n4] of i3.entries())
            !n4 && t4.getChild(e5).is("element", "tableRow") && o3.push(e5);
          if (o3.length) {
            n3 = true;
            for (const n4 of o3.reverse())
              e4.remove(t4.getChild(n4)), i3.splice(n4, 1);
          }
          const r3 = i3.filter((e5, n4) => t4.getChild(n4).is("element", "tableRow")), s3 = r3[0];
          if (!r3.every((t5) => t5 === s3)) {
            const i4 = r3.reduce((t5, e5) => e5 > t5 ? e5 : t5, 0);
            for (const [o4, s4] of r3.entries()) {
              const r4 = i4 - s4;
              if (r4) {
                for (let n4 = 0; n4 < r4; n4++)
                  QS(e4, e4.createPositionAt(t4.getChild(o4), "end"));
                n3 = true;
              }
            }
          }
          return n3;
        }
        function oI(t4) {
          if ("attribute" !== t4.type)
            return false;
          const e4 = t4.attributeKey;
          return "headingRows" === e4 || "colspan" === e4 || "rowspan" === e4;
        }
        function rI(t4) {
          t4.document.registerPostFixer((e4) => function(t5, e5) {
            const n3 = e5.document.differ.getChanges();
            let i3 = false;
            for (const e6 of n3)
              "insert" == e6.type && "table" == e6.name && (i3 = sI(e6.position.nodeAfter, t5) || i3), "insert" == e6.type && "tableRow" == e6.name && (i3 = aI(e6.position.nodeAfter, t5) || i3), "insert" == e6.type && "tableCell" == e6.name && (i3 = cI(e6.position.nodeAfter, t5) || i3), "remove" != e6.type && "insert" != e6.type || !lI(e6) || (i3 = cI(e6.position.parent, t5) || i3);
            return i3;
          }(e4, t4));
        }
        function sI(t4, e4) {
          let n3 = false;
          for (const i3 of t4.getChildren())
            i3.is("element", "tableRow") && (n3 = aI(i3, e4) || n3);
          return n3;
        }
        function aI(t4, e4) {
          let n3 = false;
          for (const i3 of t4.getChildren())
            n3 = cI(i3, e4) || n3;
          return n3;
        }
        function cI(t4, e4) {
          if (0 == t4.childCount)
            return e4.insertElement("paragraph", t4), true;
          const n3 = Array.from(t4.getChildren()).filter((t5) => t5.is("$text"));
          for (const t5 of n3)
            e4.wrap(e4.createRangeOn(t5), "paragraph");
          return !!n3.length;
        }
        function lI(t4) {
          return !!t4.position.parent.is("element", "tableCell") && ("insert" == t4.type && "$text" == t4.name || "remove" == t4.type);
        }
        function dI(t4, e4) {
          if (!t4.is("element", "paragraph"))
            return false;
          const n3 = e4.toViewElement(t4);
          return !!n3 && lT(t4) !== n3.is("element", "span");
        }
        var hI = n2(8361), uI = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(hI.Z, uI);
        hI.Z.locals;
        class gI extends bs {
          static get pluginName() {
            return "TableEditing";
          }
          static get requires() {
            return [GT];
          }
          constructor(t4) {
            super(t4), this._additionalSlots = [];
          }
          init() {
            const t4 = this.editor, e4 = t4.model, n3 = e4.schema, i3 = t4.conversion, o3 = t4.plugins.get(GT);
            n3.register("table", { inheritAllFrom: "$blockObject", allowAttributes: ["headingRows", "headingColumns"] }), n3.register("tableRow", { allowIn: "table", isLimit: true }), n3.register("tableCell", { allowContentOf: "$container", allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isLimit: true, isSelectable: true }), i3.for("upcast").add((t5) => {
              t5.on("element:figure", (t6, e5, n4) => {
                if (!n4.consumable.test(e5.viewItem, { name: true, classes: "table" }))
                  return;
                const i4 = function(t7) {
                  for (const e6 of t7.getChildren())
                    if (e6.is("element", "table"))
                      return e6;
                }(e5.viewItem);
                if (!i4 || !n4.consumable.test(i4, { name: true }))
                  return;
                n4.consumable.consume(e5.viewItem, { name: true, classes: "table" });
                const o4 = So2(n4.convertItem(i4, e5.modelCursor).modelRange.getItems());
                o4 ? (n4.convertChildren(e5.viewItem, n4.writer.createPositionAt(o4, "end")), n4.updateConversionResult(o4, e5)) : n4.consumable.revert(e5.viewItem, { name: true, classes: "table" });
              });
            }), i3.for("upcast").add(eT()), i3.for("editingDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: sT(o3, { asWidget: true, additionalSlots: this._additionalSlots }) }), i3.for("dataDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: sT(o3, { additionalSlots: this._additionalSlots }) }), i3.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), i3.for("upcast").add((t5) => {
              t5.on("element:tr", (t6, e5) => {
                e5.viewItem.isEmpty && 0 == e5.modelCursor.index && t6.stop();
              }, { priority: "high" });
            }), i3.for("downcast").elementToElement({ model: "tableRow", view: (t5, { writer: e5 }) => t5.isEmpty ? e5.createEmptyElement("tr") : e5.createContainerElement("tr") }), i3.for("upcast").elementToElement({ model: "tableCell", view: "td" }), i3.for("upcast").elementToElement({ model: "tableCell", view: "th" }), i3.for("upcast").add(nT("td")), i3.for("upcast").add(nT("th")), i3.for("editingDowncast").elementToElement({ model: "tableCell", view: aT({ asWidget: true }) }), i3.for("dataDowncast").elementToElement({ model: "tableCell", view: aT() }), i3.for("editingDowncast").elementToElement({ model: "paragraph", view: cT({ asWidget: true }), converterPriority: "high" }), i3.for("dataDowncast").elementToElement({ model: "paragraph", view: cT(), converterPriority: "high" }), i3.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), i3.for("upcast").attributeToAttribute({ model: { key: "colspan", value: mI("colspan") }, view: "colspan" }), i3.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), i3.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: mI("rowspan") }, view: "rowspan" }), t4.config.define("table.defaultHeadings.rows", 0), t4.config.define("table.defaultHeadings.columns", 0), t4.commands.add("insertTable", new dT(t4)), t4.commands.add("insertTableRowAbove", new hT(t4, { order: "above" })), t4.commands.add("insertTableRowBelow", new hT(t4, { order: "below" })), t4.commands.add("insertTableColumnLeft", new uT(t4, { order: "left" })), t4.commands.add("insertTableColumnRight", new uT(t4, { order: "right" })), t4.commands.add("removeTableRow", new DT(t4)), t4.commands.add("removeTableColumn", new ST(t4)), t4.commands.add("splitTableCellVertically", new gT2(t4, { direction: "vertically" })), t4.commands.add("splitTableCellHorizontally", new gT2(t4, { direction: "horizontally" })), t4.commands.add("mergeTableCells", new ZT(t4)), t4.commands.add("mergeTableCellRight", new xT(t4, { direction: "right" })), t4.commands.add("mergeTableCellLeft", new xT(t4, { direction: "left" })), t4.commands.add("mergeTableCellDown", new xT(t4, { direction: "down" })), t4.commands.add("mergeTableCellUp", new xT(t4, { direction: "up" })), t4.commands.add("setTableColumnHeader", new IT(t4)), t4.commands.add("setTableRowHeader", new TT(t4)), t4.commands.add("selectTableRow", new XT(t4)), t4.commands.add("selectTableColumn", new tI(t4)), eI(e4), rI(e4), this.listenTo(e4.document, "change:data", () => {
              !function(t5, e5) {
                const n4 = t5.document.differ;
                for (const t6 of n4.getChanges()) {
                  let n5, i4 = false;
                  if ("attribute" == t6.type) {
                    const e6 = t6.range.start.nodeAfter;
                    if (!e6 || !e6.is("element", "table"))
                      continue;
                    if ("headingRows" != t6.attributeKey && "headingColumns" != t6.attributeKey)
                      continue;
                    n5 = e6, i4 = "headingRows" == t6.attributeKey;
                  } else
                    "tableRow" != t6.name && "tableCell" != t6.name || (n5 = t6.position.findAncestor("table"), i4 = "tableRow" == t6.name);
                  if (!n5)
                    continue;
                  const o4 = n5.getAttribute("headingRows") || 0, r3 = n5.getAttribute("headingColumns") || 0, s3 = new oT(n5);
                  for (const t7 of s3) {
                    const n6 = t7.row < o4 || t7.column < r3 ? "th" : "td", s4 = e5.mapper.toViewElement(t7.cell);
                    s4 && s4.is("element") && s4.name != n6 && e5.reconvertItem(i4 ? t7.cell.parent : t7.cell);
                  }
                }
              }(e4, t4.editing), function(t5, e5) {
                const n4 = t5.document.differ, i4 = /* @__PURE__ */ new Set();
                for (const t6 of n4.getChanges()) {
                  const e6 = "attribute" == t6.type ? t6.range.start.parent : t6.position.parent;
                  e6.is("element", "tableCell") && i4.add(e6);
                }
                for (const t6 of i4.values()) {
                  const n5 = Array.from(t6.getChildren()).filter((t7) => dI(t7, e5.mapper));
                  for (const t7 of n5)
                    e5.reconvertItem(t7);
                }
              }(e4, t4.editing);
            });
          }
          registerAdditionalSlot(t4) {
            this._additionalSlots.push(t4);
          }
        }
        function mI(t4) {
          return (e4) => {
            const n3 = parseInt(e4.getAttribute(t4));
            return Number.isNaN(n3) || n3 <= 0 ? null : n3;
          };
        }
        var pI = n2(468), fI = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(pI.Z, fI);
        pI.Z.locals;
        class kI extends Ho2 {
          constructor(t4) {
            super(t4);
            const e4 = this.bindTemplate;
            this.items = this._createGridCollection(), this.keystrokes = new Io2(), this.focusTracker = new To2(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (t5, e5) => `${e5}  ${t5}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": e4.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": true }, children: [{ text: e4.to("label") }] }], on: { mousedown: e4.to((t5) => {
              t5.preventDefault();
            }), click: e4.to(() => {
              this.fire("execute");
            }) } }), this.on("boxover", (t5, e5) => {
              const { row: n3, column: i3 } = e5.target.dataset;
              this.items.get(10 * (parseInt(n3, 10) - 1) + (parseInt(i3, 10) - 1)).focus();
            }), this.focusTracker.on("change:focusedElement", (t5, e5, n3) => {
              if (!n3)
                return;
              const { row: i3, column: o3 } = n3.dataset;
              this.set({ rows: parseInt(i3), columns: parseInt(o3) });
            }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes());
          }
          render() {
            super.render(), r2({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: 10, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
            for (const t4 of this.items)
              this.focusTracker.add(t4.element);
            this.keystrokes.listenTo(this.element);
          }
          focus() {
            this.items.get(0).focus();
          }
          focusLast() {
            this.items.get(0).focus();
          }
          _highlightGridBoxes() {
            const t4 = this.rows, e4 = this.columns;
            this.items.map((n3, i3) => {
              const o3 = Math.floor(i3 / 10) < t4 && i3 % 10 < e4;
              n3.set("isOn", o3);
            });
          }
          _createGridButton(t4, e4, n3, i3) {
            const o3 = new kr(t4);
            return o3.set({ label: i3, class: "ck-insert-table-dropdown-grid-box" }), o3.extendTemplate({ attributes: { "data-row": e4, "data-column": n3 } }), o3;
          }
          _createGridCollection() {
            const t4 = [];
            for (let e4 = 0; e4 < 100; e4++) {
              const n3 = Math.floor(e4 / 10), i3 = e4 % 10, o3 = `${n3 + 1}  ${i3 + 1}`;
              t4.push(this._createGridButton(this.locale, n3 + 1, i3 + 1, o3));
            }
            return this.createCollection(t4);
          }
        }
        class bI extends bs {
          static get pluginName() {
            return "TableUI";
          }
          init() {
            const t4 = this.editor, e4 = this.editor.t, n3 = "ltr" === t4.locale.contentLanguageDirection;
            t4.ui.componentFactory.add("insertTable", (n4) => {
              const i3 = t4.commands.get("insertTable"), o3 = om(n4);
              let r3;
              return o3.bind("isEnabled").to(i3), o3.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>', label: e4("Insert table"), tooltip: true }), o3.on("change:isOpen", () => {
                r3 || (r3 = new kI(n4), o3.panelView.children.add(r3), r3.delegate("execute").to(o3), o3.on("execute", () => {
                  t4.execute("insertTable", { rows: r3.rows, columns: r3.columns }), t4.editing.view.focus();
                }));
              }), o3;
            }), t4.ui.componentFactory.add("tableColumn", (t5) => {
              const i3 = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: e4("Header column"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: n3 ? "insertTableColumnLeft" : "insertTableColumnRight", label: e4("Insert column left") } }, { type: "button", model: { commandName: n3 ? "insertTableColumnRight" : "insertTableColumnLeft", label: e4("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: e4("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: e4("Select column") } }];
              return this._prepareDropdown(e4("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', i3, t5);
            }), t4.ui.componentFactory.add("tableRow", (t5) => {
              const n4 = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: e4("Header row"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: e4("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: e4("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: e4("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: e4("Select row") } }];
              return this._prepareDropdown(e4("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', n4, t5);
            }), t4.ui.componentFactory.add("mergeTableCells", (t5) => {
              const i3 = [{ type: "button", model: { commandName: "mergeTableCellUp", label: e4("Merge cell up") } }, { type: "button", model: { commandName: n3 ? "mergeTableCellRight" : "mergeTableCellLeft", label: e4("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: e4("Merge cell down") } }, { type: "button", model: { commandName: n3 ? "mergeTableCellLeft" : "mergeTableCellRight", label: e4("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: e4("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: e4("Split cell horizontally") } }];
              return this._prepareMergeSplitButtonDropdown(e4("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', i3, t5);
            });
          }
          _prepareDropdown(t4, e4, n3, i3) {
            const o3 = this.editor, r3 = om(i3), s3 = this._fillDropdownWithListOptions(r3, n3);
            return r3.buttonView.set({ label: t4, icon: e4, tooltip: true }), r3.bind("isEnabled").toMany(s3, "isEnabled", (...t5) => t5.some((t6) => t6)), this.listenTo(r3, "execute", (t5) => {
              o3.execute(t5.source.commandName), t5.source instanceof Ar || o3.editing.view.focus();
            }), r3;
          }
          _prepareMergeSplitButtonDropdown(t4, e4, n3, i3) {
            const o3 = this.editor, r3 = om(i3, Xg2), s3 = "mergeTableCells", a3 = o3.commands.get(s3), c3 = this._fillDropdownWithListOptions(r3, n3);
            return r3.buttonView.set({ label: t4, icon: e4, tooltip: true, isEnabled: true }), r3.bind("isEnabled").toMany([a3, ...c3], "isEnabled", (...t5) => t5.some((t6) => t6)), this.listenTo(r3.buttonView, "execute", () => {
              o3.execute(s3), o3.editing.view.focus();
            }), this.listenTo(r3, "execute", (t5) => {
              o3.execute(t5.source.commandName), o3.editing.view.focus();
            }), r3;
          }
          _fillDropdownWithListOptions(t4, e4) {
            const n3 = this.editor, i3 = [], o3 = new Do2();
            for (const t5 of e4)
              wI(t5, n3, i3, o3);
            return am(t4, o3), i3;
          }
        }
        function wI(t4, e4, n3, i3) {
          if ("button" === t4.type || "switchbutton" === t4.type) {
            const i4 = t4.model = new Up(t4.model), { commandName: o3, bindIsOn: r3 } = t4.model, s3 = e4.commands.get(o3);
            n3.push(s3), i4.set({ commandName: o3 }), i4.bind("isEnabled").to(s3), r3 && i4.bind("isOn").to(s3, "value"), i4.set({ withText: true });
          }
          i3.add(t4);
        }
        var AI = n2(1546), CI = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(AI.Z, CI);
        AI.Z.locals;
        class _I extends bs {
          static get pluginName() {
            return "TableSelection";
          }
          static get requires() {
            return [GT, GT];
          }
          init() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view;
            this.listenTo(e4, "deleteContent", (t5, e5) => this._handleDeleteContent(t5, e5), { priority: "high" }), this.listenTo(n3.document, "insertText", (t5, e5) => this._handleInsertTextEvent(t5, e5), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
          }
          getSelectedTableCells() {
            const t4 = this.editor.plugins.get(GT), e4 = this.editor.model.document.selection, n3 = t4.getSelectedTableCells(e4);
            return 0 == n3.length ? null : n3;
          }
          getSelectionAsFragment() {
            const t4 = this.editor.plugins.get(GT), e4 = this.getSelectedTableCells();
            return e4 ? this.editor.model.change((n3) => {
              const i3 = n3.createDocumentFragment(), { first: o3, last: r3 } = t4.getColumnIndexes(e4), { first: s3, last: a3 } = t4.getRowIndexes(e4), c3 = e4[0].findAncestor("table");
              let l3 = a3, d3 = r3;
              if (t4.isSelectionRectangular(e4)) {
                const t5 = { firstColumn: o3, lastColumn: r3, firstRow: s3, lastRow: a3 };
                l3 = vT(c3, t5), d3 = yT(c3, t5);
              }
              const h3 = mT(c3, { startRow: s3, startColumn: o3, endRow: l3, endColumn: d3 }, n3);
              return n3.insert(h3, i3, 0), i3;
            }) : null;
          }
          setCellSelection(t4, e4) {
            const n3 = this._getCellsToSelect(t4, e4);
            this.editor.model.change((t5) => {
              t5.setSelection(n3.cells.map((e5) => t5.createRangeOn(e5)), { backward: n3.backward });
            });
          }
          getFocusCell() {
            const t4 = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
            return t4 && t4.is("element", "tableCell") ? t4 : null;
          }
          getAnchorCell() {
            const t4 = So2(this.editor.model.document.selection.getRanges()).getContainedElement();
            return t4 && t4.is("element", "tableCell") ? t4 : null;
          }
          _defineSelectionConverter() {
            const t4 = this.editor, e4 = /* @__PURE__ */ new Set();
            t4.conversion.for("editingDowncast").add((t5) => t5.on("selection", (t6, n3, i3) => {
              const o3 = i3.writer;
              !function(t7) {
                for (const n4 of e4)
                  t7.removeClass("ck-editor__editable_selected", n4);
                e4.clear();
              }(o3);
              const r3 = this.getSelectedTableCells();
              if (!r3)
                return;
              for (const t7 of r3) {
                const n4 = i3.mapper.toViewElement(t7);
                o3.addClass("ck-editor__editable_selected", n4), e4.add(n4);
              }
              const s3 = i3.mapper.toViewElement(r3[r3.length - 1]);
              o3.setSelection(s3, 0);
            }, { priority: "lowest" }));
          }
          _enablePluginDisabling() {
            const t4 = this.editor;
            this.on("change:isEnabled", () => {
              if (!this.isEnabled) {
                const e4 = this.getSelectedTableCells();
                if (!e4)
                  return;
                t4.model.change((n3) => {
                  const i3 = n3.createPositionAt(e4[0], 0), o3 = t4.model.schema.getNearestSelectionRange(i3);
                  n3.setSelection(o3);
                });
              }
            });
          }
          _handleDeleteContent(t4, e4) {
            const n3 = this.editor.plugins.get(GT), i3 = e4[0], o3 = e4[1], r3 = this.editor.model, s3 = !o3 || "backward" == o3.direction, a3 = n3.getSelectedTableCells(i3);
            a3.length && (t4.stop(), r3.change((t5) => {
              const e5 = a3[s3 ? a3.length - 1 : 0];
              r3.change((t6) => {
                for (const e6 of a3)
                  r3.deleteContent(t6.createSelection(e6, "in"));
              });
              const n4 = r3.schema.getNearestSelectionRange(t5.createPositionAt(e5, 0));
              i3.is("documentSelection") ? t5.setSelection(n4) : i3.setTo(n4);
            }));
          }
          _handleInsertTextEvent(t4, e4) {
            const n3 = this.editor, i3 = this.getSelectedTableCells();
            if (!i3)
              return;
            const o3 = n3.editing.view, r3 = n3.editing.mapper, s3 = i3.map((t5) => o3.createRangeOn(r3.toViewElement(t5)));
            e4.selection = o3.createSelection(s3);
          }
          _getCellsToSelect(t4, e4) {
            const n3 = this.editor.plugins.get("TableUtils"), i3 = n3.getCellLocation(t4), o3 = n3.getCellLocation(e4), r3 = Math.min(i3.row, o3.row), s3 = Math.max(i3.row, o3.row), a3 = Math.min(i3.column, o3.column), c3 = Math.max(i3.column, o3.column), l3 = new Array(s3 - r3 + 1).fill(null).map(() => []), d3 = { startRow: r3, endRow: s3, startColumn: a3, endColumn: c3 };
            for (const { row: e5, cell: n4 } of new oT(t4.findAncestor("table"), d3))
              l3[e5 - r3].push(n4);
            const h3 = o3.row < i3.row, u3 = o3.column < i3.column;
            return h3 && l3.reverse(), u3 && l3.forEach((t5) => t5.reverse()), { cells: l3.flat(), backward: h3 || u3 };
          }
        }
        class vI extends bs {
          static get pluginName() {
            return "TableClipboard";
          }
          static get requires() {
            return [_I, GT];
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view.document;
            this.listenTo(e4, "copy", (t5, e5) => this._onCopyCut(t5, e5)), this.listenTo(e4, "cut", (t5, e5) => this._onCopyCut(t5, e5)), this.listenTo(t4.model, "insertContent", (t5, [e5, n3]) => this._onInsertContent(t5, e5, n3), { priority: "high" }), this.decorate("_replaceTableSlotCell");
          }
          _onCopyCut(t4, e4) {
            const n3 = this.editor.plugins.get(_I);
            if (!n3.getSelectedTableCells())
              return;
            if ("cut" == t4.name && !this.editor.model.canEditAt(this.editor.model.document.selection))
              return;
            e4.preventDefault(), t4.stop();
            const i3 = this.editor.data, o3 = this.editor.editing.view.document, r3 = i3.toView(n3.getSelectionAsFragment());
            o3.fire("clipboardOutput", { dataTransfer: e4.dataTransfer, content: r3, method: t4.name });
          }
          _onInsertContent(t4, e4, n3) {
            if (n3 && !n3.is("documentSelection"))
              return;
            const i3 = this.editor.model, o3 = this.editor.plugins.get(GT);
            let r3 = this.getTableIfOnlyTableInContent(e4, i3);
            if (!r3)
              return;
            const s3 = o3.getSelectionAffectedTableCells(i3.document.selection);
            s3.length ? (t4.stop(), i3.change((t5) => {
              const e5 = { width: o3.getColumns(r3), height: o3.getRows(r3) }, n4 = function(t6, e6, n5, i5) {
                const o4 = t6[0].findAncestor("table"), r4 = i5.getColumnIndexes(t6), s4 = i5.getRowIndexes(t6), a4 = { firstColumn: r4.first, lastColumn: r4.last, firstRow: s4.first, lastRow: s4.last }, c4 = 1 === t6.length;
                c4 && (a4.lastRow += e6.height - 1, a4.lastColumn += e6.width - 1, function(t7, e7, n6, i6) {
                  const o5 = i6.getColumns(t7), r5 = i6.getRows(t7);
                  n6 > o5 && i6.insertColumns(t7, { at: o5, columns: n6 - o5 });
                  e7 > r5 && i6.insertRows(t7, { at: r5, rows: e7 - r5 });
                }(o4, a4.lastRow + 1, a4.lastColumn + 1, i5));
                c4 || !i5.isSelectionRectangular(t6) ? function(t7, e7, n6) {
                  const { firstRow: i6, lastRow: o5, firstColumn: r5, lastColumn: s5 } = e7, a5 = { first: i6, last: o5 }, c5 = { first: r5, last: s5 };
                  xI(t7, r5, a5, n6), xI(t7, s5 + 1, a5, n6), yI(t7, i6, c5, n6), yI(t7, o5 + 1, c5, n6, i6);
                }(o4, a4, n5) : (a4.lastRow = vT(o4, a4), a4.lastColumn = yT(o4, a4));
                return a4;
              }(s3, e5, t5, o3), i4 = n4.lastRow - n4.firstRow + 1, a3 = n4.lastColumn - n4.firstColumn + 1, c3 = { startRow: 0, startColumn: 0, endRow: Math.min(i4, e5.height) - 1, endColumn: Math.min(a3, e5.width) - 1 };
              r3 = mT(r3, c3, t5);
              const l3 = s3[0].findAncestor("table"), d3 = this._replaceSelectedCellsWithPasted(r3, e5, l3, n4, t5);
              if (this.editor.plugins.get("TableSelection").isEnabled) {
                const e6 = o3.sortRanges(d3.map((e7) => t5.createRangeOn(e7)));
                t5.setSelection(e6);
              } else
                t5.setSelection(d3[0], 0);
            })) : _T(r3, o3);
          }
          _replaceSelectedCellsWithPasted(t4, e4, n3, i3, o3) {
            const { width: r3, height: s3 } = e4, a3 = function(t5, e5, n4) {
              const i4 = new Array(n4).fill(null).map(() => new Array(e5).fill(null));
              for (const { column: e6, row: n5, cell: o4 } of new oT(t5))
                i4[n5][e6] = o4;
              return i4;
            }(t4, r3, s3), c3 = [...new oT(n3, { startRow: i3.firstRow, endRow: i3.lastRow, startColumn: i3.firstColumn, endColumn: i3.lastColumn, includeAllSlots: true })], l3 = [];
            let d3;
            for (const t5 of c3) {
              const { row: e5, column: n4 } = t5;
              n4 === i3.firstColumn && (d3 = t5.getPositionBefore());
              const c4 = e5 - i3.firstRow, h4 = n4 - i3.firstColumn, u4 = a3[c4 % s3][h4 % r3], g4 = u4 ? o3.cloneElement(u4) : null, m4 = this._replaceTableSlotCell(t5, g4, d3, o3);
              m4 && (wT(m4, e5, n4, i3.lastRow, i3.lastColumn, o3), l3.push(m4), d3 = o3.createPositionAfter(m4));
            }
            const h3 = parseInt(n3.getAttribute("headingRows") || "0"), u3 = parseInt(n3.getAttribute("headingColumns") || "0"), g3 = i3.firstRow < h3 && h3 <= i3.lastRow, m3 = i3.firstColumn < u3 && u3 <= i3.lastColumn;
            if (g3) {
              const t5 = yI(n3, h3, { first: i3.firstColumn, last: i3.lastColumn }, o3, i3.firstRow);
              l3.push(...t5);
            }
            if (m3) {
              const t5 = xI(n3, u3, { first: i3.firstRow, last: i3.lastRow }, o3);
              l3.push(...t5);
            }
            return l3;
          }
          _replaceTableSlotCell(t4, e4, n3, i3) {
            const { cell: o3, isAnchor: r3 } = t4;
            return r3 && i3.remove(o3), e4 ? (i3.insert(e4, n3), e4) : null;
          }
          getTableIfOnlyTableInContent(t4, e4) {
            if (!t4.is("documentFragment") && !t4.is("element"))
              return null;
            if (t4.is("element", "table"))
              return t4;
            if (1 == t4.childCount && t4.getChild(0).is("element", "table"))
              return t4.getChild(0);
            const n3 = e4.createRangeIn(t4);
            for (const t5 of n3.getItems())
              if (t5.is("element", "table")) {
                const i3 = e4.createRange(n3.start, e4.createPositionBefore(t5));
                if (e4.hasContent(i3, { ignoreWhitespaces: true }))
                  return null;
                const o3 = e4.createRange(e4.createPositionAfter(t5), n3.end);
                return e4.hasContent(o3, { ignoreWhitespaces: true }) ? null : t5;
              }
            return null;
          }
        }
        function yI(t4, e4, n3, i3, o3 = 0) {
          if (e4 < 1)
            return;
          return pT(t4, e4, o3).filter(({ column: t5, cellWidth: e5 }) => EI(t5, e5, n3)).map(({ cell: t5 }) => fT(t5, e4, i3));
        }
        function xI(t4, e4, n3, i3) {
          if (e4 < 1)
            return;
          return kT(t4, e4).filter(({ row: t5, cellHeight: e5 }) => EI(t5, e5, n3)).map(({ cell: t5, column: n4 }) => bT(t5, n4, e4, i3));
        }
        function EI(t4, e4, n3) {
          const i3 = t4 + e4 - 1, { first: o3, last: r3 } = n3;
          return t4 >= o3 && t4 <= r3 || t4 < o3 && i3 >= o3;
        }
        class DI extends bs {
          static get pluginName() {
            return "TableKeyboard";
          }
          static get requires() {
            return [_I, GT];
          }
          init() {
            const t4 = this.editor.editing.view.document;
            this.listenTo(t4, "arrowKey", (...t5) => this._onArrowKey(...t5), { context: "table" }), this.listenTo(t4, "tab", (...t5) => this._handleTabOnSelectedTable(...t5), { context: "figure" }), this.listenTo(t4, "tab", (...t5) => this._handleTab(...t5), { context: ["th", "td"] });
          }
          _handleTabOnSelectedTable(t4, e4) {
            const n3 = this.editor, i3 = n3.model.document.selection.getSelectedElement();
            i3 && i3.is("element", "table") && (e4.preventDefault(), e4.stopPropagation(), t4.stop(), n3.model.change((t5) => {
              t5.setSelection(t5.createRangeIn(i3.getChild(0).getChild(0)));
            }));
          }
          _handleTab(t4, e4) {
            const n3 = this.editor, i3 = this.editor.plugins.get(GT), o3 = this.editor.plugins.get("TableSelection"), r3 = n3.model.document.selection, s3 = !e4.shiftKey;
            let a3 = i3.getTableCellsContainingSelection(r3)[0];
            if (a3 || (a3 = o3.getFocusCell()), !a3)
              return;
            e4.preventDefault(), e4.stopPropagation(), t4.stop();
            const c3 = a3.parent, l3 = c3.parent, d3 = l3.getChildIndex(c3), h3 = c3.getChildIndex(a3), u3 = 0 === h3;
            if (!s3 && u3 && 0 === d3)
              return void n3.model.change((t5) => {
                t5.setSelection(t5.createRangeOn(l3));
              });
            const g3 = h3 === c3.childCount - 1, m3 = d3 === i3.getRows(l3) - 1;
            if (s3 && m3 && g3 && (n3.execute("insertTableRowBelow"), d3 === i3.getRows(l3) - 1))
              return void n3.model.change((t5) => {
                t5.setSelection(t5.createRangeOn(l3));
              });
            let p3;
            if (s3 && g3) {
              const t5 = l3.getChild(d3 + 1);
              p3 = t5.getChild(0);
            } else if (!s3 && u3) {
              const t5 = l3.getChild(d3 - 1);
              p3 = t5.getChild(t5.childCount - 1);
            } else
              p3 = c3.getChild(h3 + (s3 ? 1 : -1));
            n3.model.change((t5) => {
              t5.setSelection(t5.createRangeIn(p3));
            });
          }
          _onArrowKey(t4, e4) {
            const n3 = this.editor, i3 = Co2(e4.keyCode, n3.locale.contentLanguageDirection);
            this._handleArrowKeys(i3, e4.shiftKey) && (e4.preventDefault(), e4.stopPropagation(), t4.stop());
          }
          _handleArrowKeys(t4, e4) {
            const n3 = this.editor.plugins.get(GT), i3 = this.editor.plugins.get("TableSelection"), o3 = this.editor.model, r3 = o3.document.selection, s3 = ["right", "down"].includes(t4), a3 = n3.getSelectedTableCells(r3);
            if (a3.length) {
              let n4;
              return n4 = e4 ? i3.getFocusCell() : s3 ? a3[a3.length - 1] : a3[0], this._navigateFromCellInDirection(n4, t4, e4), true;
            }
            const c3 = r3.focus.findAncestor("tableCell");
            if (!c3)
              return false;
            if (!r3.isCollapsed)
              if (e4) {
                if (r3.isBackward == s3 && !r3.containsEntireContent(c3))
                  return false;
              } else {
                const t5 = r3.getSelectedElement();
                if (!t5 || !o3.schema.isObject(t5))
                  return false;
              }
            return !!this._isSelectionAtCellEdge(r3, c3, s3) && (this._navigateFromCellInDirection(c3, t4, e4), true);
          }
          _isSelectionAtCellEdge(t4, e4, n3) {
            const i3 = this.editor.model, o3 = this.editor.model.schema, r3 = n3 ? t4.getLastPosition() : t4.getFirstPosition();
            if (!o3.getLimitElement(r3).is("element", "tableCell")) {
              return i3.createPositionAt(e4, n3 ? "end" : 0).isTouching(r3);
            }
            const s3 = i3.createSelection(r3);
            return i3.modifySelection(s3, { direction: n3 ? "forward" : "backward" }), r3.isEqual(s3.focus);
          }
          _navigateFromCellInDirection(t4, e4, n3 = false) {
            const i3 = this.editor.model, o3 = t4.findAncestor("table"), r3 = [...new oT(o3, { includeAllSlots: true })], { row: s3, column: a3 } = r3[r3.length - 1], c3 = r3.find(({ cell: e5 }) => e5 == t4);
            let { row: l3, column: d3 } = c3;
            switch (e4) {
              case "left":
                d3--;
                break;
              case "up":
                l3--;
                break;
              case "right":
                d3 += c3.cellWidth;
                break;
              case "down":
                l3 += c3.cellHeight;
            }
            if (l3 < 0 || l3 > s3 || d3 < 0 && l3 <= 0 || d3 > a3 && l3 >= s3)
              return void i3.change((t5) => {
                t5.setSelection(t5.createRangeOn(o3));
              });
            d3 < 0 ? (d3 = n3 ? 0 : a3, l3--) : d3 > a3 && (d3 = n3 ? a3 : 0, l3++);
            const h3 = r3.find((t5) => t5.row == l3 && t5.column == d3).cell, u3 = ["right", "down"].includes(e4), g3 = this.editor.plugins.get("TableSelection");
            if (n3 && g3.isEnabled) {
              const e5 = g3.getAnchorCell() || t4;
              g3.setCellSelection(e5, h3);
            } else {
              const t5 = i3.createPositionAt(h3, u3 ? 0 : "end");
              i3.change((e5) => {
                e5.setSelection(t5);
              });
            }
          }
        }
        class SI extends ol2 {
          constructor() {
            super(...arguments), this.domEventType = ["mousemove", "mouseleave"];
          }
          onDomEvent(t4) {
            this.fire(t4.type, t4);
          }
        }
        class TI extends bs {
          static get pluginName() {
            return "TableMouse";
          }
          static get requires() {
            return [_I, GT];
          }
          init() {
            this.editor.editing.view.addObserver(SI), this._enableShiftClickSelection(), this._enableMouseDragSelection();
          }
          _enableShiftClickSelection() {
            const t4 = this.editor, e4 = t4.plugins.get(GT);
            let n3 = false;
            const i3 = t4.plugins.get(_I);
            this.listenTo(t4.editing.view.document, "mousedown", (o3, r3) => {
              const s3 = t4.model.document.selection;
              if (!this.isEnabled || !i3.isEnabled)
                return;
              if (!r3.domEvent.shiftKey)
                return;
              const a3 = i3.getAnchorCell() || e4.getTableCellsContainingSelection(s3)[0];
              if (!a3)
                return;
              const c3 = this._getModelTableCellFromDomEvent(r3);
              c3 && II(a3, c3) && (n3 = true, i3.setCellSelection(a3, c3), r3.preventDefault());
            }), this.listenTo(t4.editing.view.document, "mouseup", () => {
              n3 = false;
            }), this.listenTo(t4.editing.view.document, "selectionChange", (t5) => {
              n3 && t5.stop();
            }, { priority: "highest" });
          }
          _enableMouseDragSelection() {
            const t4 = this.editor;
            let e4, n3, i3 = false, o3 = false;
            const r3 = t4.plugins.get(_I);
            this.listenTo(t4.editing.view.document, "mousedown", (t5, n4) => {
              this.isEnabled && r3.isEnabled && (n4.domEvent.shiftKey || n4.domEvent.ctrlKey || n4.domEvent.altKey || (e4 = this._getModelTableCellFromDomEvent(n4)));
            }), this.listenTo(t4.editing.view.document, "mousemove", (t5, s3) => {
              if (!s3.domEvent.buttons)
                return;
              if (!e4)
                return;
              const a3 = this._getModelTableCellFromDomEvent(s3);
              a3 && II(e4, a3) && (n3 = a3, i3 || n3 == e4 || (i3 = true)), i3 && (o3 = true, r3.setCellSelection(e4, n3), s3.preventDefault());
            }), this.listenTo(t4.editing.view.document, "mouseup", () => {
              i3 = false, o3 = false, e4 = null, n3 = null;
            }), this.listenTo(t4.editing.view.document, "selectionChange", (t5) => {
              o3 && t5.stop();
            }, { priority: "highest" });
          }
          _getModelTableCellFromDomEvent(t4) {
            const e4 = t4.target, n3 = this.editor.editing.view.createPositionAt(e4, 0);
            return this.editor.editing.mapper.toModelPosition(n3).parent.findAncestor("tableCell", { includeSelf: true });
          }
        }
        function II(t4, e4) {
          return t4.parent.parent == e4.parent.parent;
        }
        var BI = n2(2510), MI = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(BI.Z, MI);
        BI.Z.locals;
        function NI(t4) {
          const e4 = LI(t4);
          return e4 || zI(t4);
        }
        function LI(t4) {
          const e4 = t4.getSelectedElement();
          return e4 && PI(e4) ? e4 : null;
        }
        function zI(t4) {
          const e4 = t4.getFirstPosition();
          if (!e4)
            return null;
          let n3 = e4.parent;
          for (; n3; ) {
            if (n3.is("element") && PI(n3))
              return n3;
            n3 = n3.parent;
          }
          return null;
        }
        function PI(t4) {
          return !!t4.getCustomProperty("table") && jb2(t4);
        }
        var RI = n2(9953), OI = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(RI.Z, OI);
        RI.Z.locals;
        class FI extends Ho2 {
          constructor(t4, e4) {
            super(t4), this.set("value", ""), this.set("isReadOnly", false), this.set("isFocused", false), this.set("isEmpty", true), this.options = e4, this.focusTracker = new To2(), this._focusables = new Ro2(), this.dropdownView = this._createDropdownView(), this.inputView = this._createInputTextView(), this.keystrokes = new Io2(), this._stillTyping = false, this.focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-input-color"] }, children: [this.dropdownView, this.inputView] }), this.on("change:value", (t5, e5, n3) => this._setInputValue(n3));
          }
          render() {
            super.render(), [this.inputView, this.dropdownView.buttonView].forEach((t4) => {
              this.focusTracker.add(t4.element), this._focusables.add(t4);
            }), this.keystrokes.listenTo(this.element);
          }
          focus(t4) {
            -1 === t4 ? this.focusCycler.focusLast() : this.focusCycler.focusFirst();
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          _createDropdownView() {
            const t4 = this.locale, e4 = t4.t, n3 = this.bindTemplate, i3 = this._createColorSelector(t4), o3 = om(t4), r3 = new Ho2();
            return r3.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-input-color__button__preview"], style: { backgroundColor: n3.to("value") } }, children: [{ tag: "span", attributes: { class: ["ck", "ck-input-color__button__preview__no-color-indicator", n3.if("value", "ck-hidden", (t5) => "" != t5)] } }] }), o3.buttonView.extendTemplate({ attributes: { class: "ck-input-color__button" } }), o3.buttonView.children.add(r3), o3.buttonView.label = e4("Color picker"), o3.buttonView.tooltip = true, o3.panelPosition = "rtl" === t4.uiLanguageDirection ? "se" : "sw", o3.panelView.children.add(i3), o3.bind("isEnabled").to(this, "isReadOnly", (t5) => !t5), o3.on("change:isOpen", (t5, e5, n4) => {
              n4 && (i3.updateSelectedColors(), i3.showColorGridsFragment());
            }), o3;
          }
          _createInputTextView() {
            const t4 = this.locale, e4 = new os(t4);
            return e4.extendTemplate({ on: { blur: e4.bindTemplate.to("blur") } }), e4.value = this.value, e4.bind("isReadOnly", "hasError").to(this), this.bind("isFocused", "isEmpty").to(e4), e4.on("input", () => {
              const t5 = e4.element.value, n3 = this.options.colorDefinitions.find((e5) => t5 === e5.label);
              this._stillTyping = true, this.value = n3 && n3.color || t5;
            }), e4.on("blur", () => {
              this._stillTyping = false, this._setInputValue(e4.element.value);
            }), e4.delegate("input").to(this), e4;
          }
          _createColorSelector(t4) {
            const e4 = t4.t, n3 = this.options.defaultColorValue || "", i3 = e4(n3 ? "Restore default" : "Remove color"), o3 = new ep(t4, { colors: this.options.colorDefinitions, columns: this.options.columns, removeButtonLabel: i3, colorPickerLabel: e4("Color picker"), colorPickerViewConfig: false !== this.options.colorPickerConfig && { ...this.options.colorPickerConfig, hideInput: true } });
            o3.appendUI(), o3.on("execute", (t5, e5) => {
              "colorPickerSaveButton" !== e5.source ? (this.value = e5.value || n3, this.fire("input"), "colorPicker" !== e5.source && (this.dropdownView.isOpen = false)) : this.dropdownView.isOpen = false;
            });
            let r3 = this.value;
            return o3.on("colorPicker:cancel", () => {
              this.value = r3, this.fire("input"), this.dropdownView.isOpen = false;
            }), o3.colorGridsFragmentView.colorPickerButtonView.on("execute", () => {
              r3 = this.value;
            }), o3.bind("selectedColor").to(this, "value"), o3;
          }
          _setInputValue(t4) {
            if (!this._stillTyping) {
              const e4 = VI(t4), n3 = this.options.colorDefinitions.find((t5) => e4 === VI(t5.color));
              this.inputView.value = n3 ? n3.label : t4 || "";
            }
          }
        }
        function VI(t4) {
          return t4.replace(/([(,])\s+/g, "$1").replace(/^\s+|\s+(?=[),\s]|$)/g, "").replace(/,|\s/g, " ");
        }
        const jI = (t4) => "" === t4;
        function HI(t4) {
          return { none: t4("None"), solid: t4("Solid"), dotted: t4("Dotted"), dashed: t4("Dashed"), double: t4("Double"), groove: t4("Groove"), ridge: t4("Ridge"), inset: t4("Inset"), outset: t4("Outset") };
        }
        function UI(t4) {
          return t4('The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".');
        }
        function GI(t4) {
          return t4('The value is invalid. Try "10px" or "2em" or simply "2".');
        }
        function WI(t4) {
          return t4 = t4.trim().toLowerCase(), jI(t4) || Zu(t4);
        }
        function qI(t4) {
          return t4 = t4.trim(), jI(t4) || JI(t4) || Xu(t4) || (e4 = t4, tg2.test(e4));
          var e4;
        }
        function $I(t4) {
          return t4 = t4.trim(), jI(t4) || JI(t4) || Xu(t4);
        }
        function KI(t4, e4) {
          const n3 = new Do2(), i3 = HI(t4.t);
          for (const o3 in i3) {
            const r3 = { type: "button", model: new Up({ _borderStyleValue: o3, label: i3[o3], role: "menuitemradio", withText: true }) };
            "none" === o3 ? r3.model.bind("isOn").to(t4, "borderStyle", (t5) => "none" === e4 ? !t5 : t5 === o3) : r3.model.bind("isOn").to(t4, "borderStyle", (t5) => t5 === o3), n3.add(r3);
          }
          return n3;
        }
        function ZI(t4) {
          const { view: e4, icons: n3, toolbar: i3, labels: o3, propertyName: r3, nameToValue: s3, defaultValue: a3 } = t4;
          for (const t5 in o3) {
            const c3 = new kr(e4.locale);
            c3.set({ label: o3[t5], icon: n3[t5], tooltip: o3[t5] });
            const l3 = s3 ? s3(t5) : t5;
            c3.bind("isOn").to(e4, r3, (t6) => {
              let e5 = t6;
              return "" === t6 && a3 && (e5 = a3), l3 === e5;
            }), c3.on("execute", () => {
              e4[r3] = l3;
            }), i3.items.add(c3);
          }
        }
        const YI = [{ color: "hsl(0, 0%, 0%)", label: "Black" }, { color: "hsl(0, 0%, 30%)", label: "Dim grey" }, { color: "hsl(0, 0%, 60%)", label: "Grey" }, { color: "hsl(0, 0%, 90%)", label: "Light grey" }, { color: "hsl(0, 0%, 100%)", label: "White", hasBorder: true }, { color: "hsl(0, 75%, 60%)", label: "Red" }, { color: "hsl(30, 75%, 60%)", label: "Orange" }, { color: "hsl(60, 75%, 60%)", label: "Yellow" }, { color: "hsl(90, 75%, 60%)", label: "Light green" }, { color: "hsl(120, 75%, 60%)", label: "Green" }, { color: "hsl(150, 75%, 60%)", label: "Aquamarine" }, { color: "hsl(180, 75%, 60%)", label: "Turquoise" }, { color: "hsl(210, 75%, 60%)", label: "Light blue" }, { color: "hsl(240, 75%, 60%)", label: "Blue" }, { color: "hsl(270, 75%, 60%)", label: "Purple" }];
        function QI(t4) {
          return (e4, n3, i3) => {
            const o3 = new FI(e4.locale, { colorDefinitions: (r3 = t4.colorConfig, r3.map((t5) => ({ color: t5.model, label: t5.label, options: { hasBorder: t5.hasBorder } }))), columns: t4.columns, defaultColorValue: t4.defaultColorValue, colorPickerConfig: t4.colorPickerConfig });
            var r3;
            return o3.inputView.set({ id: n3, ariaDescribedById: i3 }), o3.bind("isReadOnly").to(e4, "isEnabled", (t5) => !t5), o3.bind("hasError").to(e4, "errorText", (t5) => !!t5), o3.on("input", () => {
              e4.errorText = null;
            }), e4.bind("isEmpty", "isFocused").to(o3), o3;
          };
        }
        function JI(t4) {
          const e4 = parseFloat(t4);
          return !Number.isNaN(e4) && t4 === String(e4);
        }
        var XI = n2(6908), tB = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(XI.Z, tB);
        XI.Z.locals;
        class eB extends Ho2 {
          constructor(t4, e4 = {}) {
            super(t4);
            const n3 = this.bindTemplate;
            this.set("class", e4.class || null), this.children = this.createCollection(), e4.children && e4.children.forEach((t5) => this.children.add(t5)), this.set("_role", null), this.set("_ariaLabelledBy", null), e4.labelView && this.set({ _role: "group", _ariaLabelledBy: e4.labelView.id }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-form__row", n3.to("class")], role: n3.to("_role"), "aria-labelledby": n3.to("_ariaLabelledBy") }, children: this.children });
          }
        }
        var nB = n2(7502), iB = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(nB.Z, iB);
        nB.Z.locals;
        var oB = n2(9429), rB = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(oB.Z, rB);
        oB.Z.locals;
        var sB = n2(3964), aB = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(sB.Z, aB);
        sB.Z.locals;
        const cB = { left: Pg2.alignLeft, center: Pg2.alignCenter, right: Pg2.alignRight, justify: Pg2.alignJustify, top: Pg2.alignTop, middle: Pg2.alignMiddle, bottom: Pg2.alignBottom };
        class lB extends Ho2 {
          constructor(t4, e4) {
            super(t4), this.set({ borderStyle: "", borderWidth: "", borderColor: "", padding: "", backgroundColor: "", width: "", height: "", horizontalAlignment: "", verticalAlignment: "" }), this.options = e4;
            const { borderStyleDropdown: n3, borderWidthInput: i3, borderColorInput: o3, borderRowLabel: r3 } = this._createBorderFields(), { backgroundRowLabel: s3, backgroundInput: a3 } = this._createBackgroundFields(), { widthInput: c3, operatorLabel: l3, heightInput: d3, dimensionsLabel: h3 } = this._createDimensionFields(), { horizontalAlignmentToolbar: u3, verticalAlignmentToolbar: g3, alignmentLabel: m3 } = this._createAlignmentFields();
            this.focusTracker = new To2(), this.keystrokes = new Io2(), this.children = this.createCollection(), this.borderStyleDropdown = n3, this.borderWidthInput = i3, this.borderColorInput = o3, this.backgroundInput = a3, this.paddingInput = this._createPaddingField(), this.widthInput = c3, this.heightInput = d3, this.horizontalAlignmentToolbar = u3, this.verticalAlignmentToolbar = g3;
            const { saveButtonView: p3, cancelButtonView: f3 } = this._createActionButtons();
            this.saveButtonView = p3, this.cancelButtonView = f3, this._focusables = new Ro2(), this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.children.add(new jp(t4, { label: this.t("Cell properties") })), this.children.add(new eB(t4, { labelView: r3, children: [r3, n3, o3, i3], class: "ck-table-form__border-row" })), this.children.add(new eB(t4, { labelView: s3, children: [s3, a3], class: "ck-table-form__background-row" })), this.children.add(new eB(t4, { children: [new eB(t4, { labelView: h3, children: [h3, c3, l3, d3], class: "ck-table-form__dimensions-row" }), new eB(t4, { children: [this.paddingInput], class: "ck-table-cell-properties-form__padding-row" })] })), this.children.add(new eB(t4, { labelView: m3, children: [m3, u3, g3], class: "ck-table-cell-properties-form__alignment-row" })), this.children.add(new eB(t4, { children: [this.saveButtonView, this.cancelButtonView], class: "ck-table-form__action-row" })), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-form", "ck-table-form", "ck-table-cell-properties-form"], tabindex: "-1" }, children: this.children });
          }
          render() {
            super.render(), o2({ view: this }), [this.borderColorInput, this.backgroundInput].forEach((t4) => {
              t4.fieldView.focusCycler.on("forwardCycle", (t5) => {
                this._focusCycler.focusNext(), t5.stop();
              }), t4.fieldView.focusCycler.on("backwardCycle", (t5) => {
                this._focusCycler.focusPrevious(), t5.stop();
              });
            }), [this.borderStyleDropdown, this.borderColorInput, this.borderWidthInput, this.backgroundInput, this.widthInput, this.heightInput, this.paddingInput, this.horizontalAlignmentToolbar, this.verticalAlignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t4) => {
              this._focusables.add(t4), this.focusTracker.add(t4.element);
            }), this.keystrokes.listenTo(this.element);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createBorderFields() {
            const t4 = this.options.defaultTableCellProperties, e4 = { style: t4.borderStyle, width: t4.borderWidth, color: t4.borderColor }, n3 = QI({ colorConfig: this.options.borderColors, columns: 5, defaultColorValue: e4.color, colorPickerConfig: this.options.colorPickerConfig }), i3 = this.locale, o3 = this.t, r3 = o3("Style"), s3 = new Yr(i3);
            s3.text = o3("Border");
            const a3 = HI(o3), c3 = new Xr(i3, um);
            c3.set({ label: r3, class: "ck-table-form__border-style" }), c3.fieldView.buttonView.set({ ariaLabel: r3, ariaLabelledBy: void 0, isOn: false, withText: true, tooltip: r3 }), c3.fieldView.buttonView.bind("label").to(this, "borderStyle", (t5) => a3[t5 || "none"]), c3.fieldView.on("execute", (t5) => {
              this.borderStyle = t5.source._borderStyleValue;
            }), c3.bind("isEmpty").to(this, "borderStyle", (t5) => !t5), am(c3.fieldView, KI(this, e4.style), { role: "menu", ariaLabel: r3 });
            const l3 = new Xr(i3, hm);
            l3.set({ label: o3("Width"), class: "ck-table-form__border-width" }), l3.fieldView.bind("value").to(this, "borderWidth"), l3.bind("isEnabled").to(this, "borderStyle", dB), l3.fieldView.on("input", () => {
              this.borderWidth = l3.fieldView.element.value;
            });
            const d3 = new Xr(i3, n3);
            return d3.set({ label: o3("Color"), class: "ck-table-form__border-color" }), d3.fieldView.bind("value").to(this, "borderColor"), d3.bind("isEnabled").to(this, "borderStyle", dB), d3.fieldView.on("input", () => {
              this.borderColor = d3.fieldView.value;
            }), this.on("change:borderStyle", (t5, n4, i4, o4) => {
              dB(i4) || (this.borderColor = "", this.borderWidth = ""), dB(o4) || (this.borderColor = e4.color, this.borderWidth = e4.width);
            }), { borderRowLabel: s3, borderStyleDropdown: c3, borderColorInput: d3, borderWidthInput: l3 };
          }
          _createBackgroundFields() {
            const t4 = this.locale, e4 = this.t, n3 = new Yr(t4);
            n3.text = e4("Background");
            const i3 = QI({ colorConfig: this.options.backgroundColors, columns: 5, defaultColorValue: this.options.defaultTableCellProperties.backgroundColor, colorPickerConfig: this.options.colorPickerConfig }), o3 = new Xr(t4, i3);
            return o3.set({ label: e4("Color"), class: "ck-table-cell-properties-form__background" }), o3.fieldView.bind("value").to(this, "backgroundColor"), o3.fieldView.on("input", () => {
              this.backgroundColor = o3.fieldView.value;
            }), { backgroundRowLabel: n3, backgroundInput: o3 };
          }
          _createDimensionFields() {
            const t4 = this.locale, e4 = this.t, n3 = new Yr(t4);
            n3.text = e4("Dimensions");
            const i3 = new Xr(t4, hm);
            i3.set({ label: e4("Width"), class: "ck-table-form__dimensions-row__width" }), i3.fieldView.bind("value").to(this, "width"), i3.fieldView.on("input", () => {
              this.width = i3.fieldView.element.value;
            });
            const o3 = new Ho2(t4);
            o3.setTemplate({ tag: "span", attributes: { class: ["ck-table-form__dimension-operator"] }, children: [{ text: "" }] });
            const r3 = new Xr(t4, hm);
            return r3.set({ label: e4("Height"), class: "ck-table-form__dimensions-row__height" }), r3.fieldView.bind("value").to(this, "height"), r3.fieldView.on("input", () => {
              this.height = r3.fieldView.element.value;
            }), { dimensionsLabel: n3, widthInput: i3, operatorLabel: o3, heightInput: r3 };
          }
          _createPaddingField() {
            const t4 = this.locale, e4 = this.t, n3 = new Xr(t4, hm);
            return n3.set({ label: e4("Padding"), class: "ck-table-cell-properties-form__padding" }), n3.fieldView.bind("value").to(this, "padding"), n3.fieldView.on("input", () => {
              this.padding = n3.fieldView.element.value;
            }), n3;
          }
          _createAlignmentFields() {
            const t4 = this.locale, e4 = this.t, n3 = new Yr(t4);
            n3.text = e4("Table cell text alignment");
            const i3 = new jg2(t4), o3 = "rtl" === t4.contentLanguageDirection;
            i3.set({ isCompact: true, ariaLabel: e4("Horizontal text alignment toolbar") }), ZI({ view: this, icons: cB, toolbar: i3, labels: this._horizontalAlignmentLabels, propertyName: "horizontalAlignment", nameToValue: (t5) => {
              if (o3) {
                if ("left" === t5)
                  return "right";
                if ("right" === t5)
                  return "left";
              }
              return t5;
            }, defaultValue: this.options.defaultTableCellProperties.horizontalAlignment });
            const r3 = new jg2(t4);
            return r3.set({ isCompact: true, ariaLabel: e4("Vertical text alignment toolbar") }), ZI({ view: this, icons: cB, toolbar: r3, labels: this._verticalAlignmentLabels, propertyName: "verticalAlignment", defaultValue: this.options.defaultTableCellProperties.verticalAlignment }), { horizontalAlignmentToolbar: i3, verticalAlignmentToolbar: r3, alignmentLabel: n3 };
          }
          _createActionButtons() {
            const t4 = this.locale, e4 = this.t, n3 = new kr(t4), i3 = new kr(t4), o3 = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.paddingInput];
            return n3.set({ label: e4("Save"), icon: Pg2.check, class: "ck-button-save", type: "submit", withText: true }), n3.bind("isEnabled").toMany(o3, "errorText", (...t5) => t5.every((t6) => !t6)), i3.set({ label: e4("Cancel"), icon: Pg2.cancel, class: "ck-button-cancel", withText: true }), i3.delegate("execute").to(this, "cancel"), { saveButtonView: n3, cancelButtonView: i3 };
          }
          get _horizontalAlignmentLabels() {
            const t4 = this.locale, e4 = this.t, n3 = e4("Align cell text to the left"), i3 = e4("Align cell text to the center"), o3 = e4("Align cell text to the right"), r3 = e4("Justify cell text");
            return "rtl" === t4.uiLanguageDirection ? { right: o3, center: i3, left: n3, justify: r3 } : { left: n3, center: i3, right: o3, justify: r3 };
          }
          get _verticalAlignmentLabels() {
            const t4 = this.t;
            return { top: t4("Align cell text to the top"), middle: t4("Align cell text to the middle"), bottom: t4("Align cell text to the bottom") };
          }
        }
        function dB(t4) {
          return "none" !== t4;
        }
        const hB = lp.defaultPositions, uB = [hB.northArrowSouth, hB.northArrowSouthWest, hB.northArrowSouthEast, hB.southArrowNorth, hB.southArrowNorthWest, hB.southArrowNorthEast, hB.viewportStickyNorth];
        function gB(t4, e4) {
          const n3 = t4.plugins.get("ContextualBalloon"), i3 = t4.editing.view.document.selection;
          let o3;
          "cell" === e4 ? zI(i3) && (o3 = pB(t4)) : NI(i3) && (o3 = mB(t4)), o3 && n3.updatePosition(o3);
        }
        function mB(t4) {
          const e4 = tT(t4.model.document.selection), n3 = t4.editing.mapper.toViewElement(e4);
          return { target: t4.editing.view.domConverter.mapViewToDom(n3), positions: uB };
        }
        function pB(t4) {
          const e4 = t4.editing.mapper, n3 = t4.editing.view.domConverter, i3 = t4.model.document.selection;
          if (i3.rangeCount > 1)
            return { target: () => function(t5, e5) {
              const n4 = e5.editing.mapper, i4 = e5.editing.view.domConverter, o4 = Array.from(t5).map((t6) => {
                const e6 = fB(t6.start), o5 = n4.toViewElement(e6);
                return new Vi2(i4.mapViewToDom(o5));
              });
              return Vi2.getBoundingRect(o4);
            }(i3.getRanges(), t4), positions: uB };
          const o3 = fB(i3.getFirstPosition()), r3 = e4.toViewElement(o3);
          return { target: n3.mapViewToDom(r3), positions: uB };
        }
        function fB(t4) {
          return t4.nodeAfter && t4.nodeAfter.is("element", "tableCell") ? t4.nodeAfter : t4.findAncestor("tableCell");
        }
        function kB(t4) {
          if (!t4 || !F2(t4))
            return t4;
          const { top: e4, right: n3, bottom: i3, left: o3 } = t4;
          return e4 == n3 && n3 == i3 && i3 == o3 ? e4 : void 0;
        }
        function bB(t4, e4) {
          const n3 = parseFloat(t4);
          return Number.isNaN(n3) || String(n3) !== String(t4) ? t4 : `${n3}${e4}`;
        }
        function wB(t4, e4 = {}) {
          const n3 = { borderStyle: "none", borderWidth: "", borderColor: "", backgroundColor: "", width: "", height: "", ...t4 };
          return e4.includeAlignmentProperty && !n3.alignment && (n3.alignment = "center"), e4.includePaddingProperty && !n3.padding && (n3.padding = ""), e4.includeVerticalAlignmentProperty && !n3.verticalAlignment && (n3.verticalAlignment = "middle"), e4.includeHorizontalAlignmentProperty && !n3.horizontalAlignment && (n3.horizontalAlignment = e4.isRightToLeftContent ? "right" : "left"), n3;
        }
        const AB = { borderStyle: "tableCellBorderStyle", borderColor: "tableCellBorderColor", borderWidth: "tableCellBorderWidth", height: "tableCellHeight", width: "tableCellWidth", padding: "tableCellPadding", backgroundColor: "tableCellBackgroundColor", horizontalAlignment: "tableCellHorizontalAlignment", verticalAlignment: "tableCellVerticalAlignment" };
        class CB extends bs {
          static get requires() {
            return [Yp];
          }
          static get pluginName() {
            return "TableCellPropertiesUI";
          }
          constructor(t4) {
            super(t4), t4.config.define("table.tableCellProperties", { borderColors: YI, backgroundColors: YI });
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            this._defaultTableCellProperties = wB(t4.config.get("table.tableCellProperties.defaultProperties"), { includeVerticalAlignmentProperty: true, includeHorizontalAlignmentProperty: true, includePaddingProperty: true, isRightToLeftContent: "rtl" === t4.locale.contentLanguageDirection }), this._balloon = t4.plugins.get(Yp), this.view = null, this._isReady = false, t4.ui.componentFactory.add("tableCellProperties", (n3) => {
              const i3 = new kr(n3);
              i3.set({ label: e4("Cell properties"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.105 18-.17 1H2.5A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1h15A1.5 1.5 0 0 1 19 2.5v9.975l-.85-.124-.15-.302V8h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5h3.105zM2 12h5V8H2v4zm10-4H8v4h4V8zM2 2v5h5V2H2zm0 16h5v-5H2v5zM13 7h5V2h-5v5zM8 2v5h4V2H8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM13 6a1 1 0 0 1 1 1v3.172a2.047 2.047 0 0 0-.293.443l-.858 1.736-1.916.28-.151.027A1.976 1.976 0 0 0 9.315 14H7a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h6zm-1 2H8v4h4V8z"/></svg>', tooltip: true }), this.listenTo(i3, "execute", () => this._showView());
              const o3 = Object.values(AB).map((e5) => t4.commands.get(e5));
              return i3.bind("isEnabled").toMany(o3, "isEnabled", (...t5) => t5.some((t6) => t6)), i3;
            });
          }
          destroy() {
            super.destroy(), this.view && this.view.destroy();
          }
          _createPropertiesView() {
            const e4 = this.editor, n3 = e4.config.get("table.tableCellProperties"), i3 = _r(n3.borderColors), o3 = Cr(e4.locale, i3), r3 = _r(n3.backgroundColors), s3 = Cr(e4.locale, r3), a3 = false !== n3.colorPicker, c3 = new lB(e4.locale, { borderColors: o3, backgroundColors: s3, defaultTableCellProperties: this._defaultTableCellProperties, colorPickerConfig: !!a3 && (n3.colorPicker || {}) }), l3 = e4.t;
            c3.render(), this.listenTo(c3, "submit", () => {
              this._hideView();
            }), this.listenTo(c3, "cancel", () => {
              this._undoStepBatch.operations.length && e4.execute("undo", this._undoStepBatch), this._hideView();
            }), c3.keystrokes.set("Esc", (t4, e5) => {
              this._hideView(), e5();
            }), t3({ emitter: c3, activator: () => this._isViewInBalloon, contextElements: [this._balloon.view.element], callback: () => this._hideView() });
            const d3 = UI(l3), h3 = GI(l3);
            return c3.on("change:borderStyle", this._getPropertyChangeCallback("tableCellBorderStyle")), c3.on("change:borderColor", this._getValidatedPropertyChangeCallback({ viewField: c3.borderColorInput, commandName: "tableCellBorderColor", errorText: d3, validator: WI })), c3.on("change:borderWidth", this._getValidatedPropertyChangeCallback({ viewField: c3.borderWidthInput, commandName: "tableCellBorderWidth", errorText: h3, validator: $I })), c3.on("change:padding", this._getValidatedPropertyChangeCallback({ viewField: c3.paddingInput, commandName: "tableCellPadding", errorText: h3, validator: qI })), c3.on("change:width", this._getValidatedPropertyChangeCallback({ viewField: c3.widthInput, commandName: "tableCellWidth", errorText: h3, validator: qI })), c3.on("change:height", this._getValidatedPropertyChangeCallback({ viewField: c3.heightInput, commandName: "tableCellHeight", errorText: h3, validator: qI })), c3.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({ viewField: c3.backgroundInput, commandName: "tableCellBackgroundColor", errorText: d3, validator: WI })), c3.on("change:horizontalAlignment", this._getPropertyChangeCallback("tableCellHorizontalAlignment")), c3.on("change:verticalAlignment", this._getPropertyChangeCallback("tableCellVerticalAlignment")), c3;
          }
          _fillViewFormFromCommandValues() {
            const t4 = this.editor.commands, e4 = t4.get("tableCellBorderStyle");
            Object.entries(AB).map(([e5, n3]) => {
              const i3 = this._defaultTableCellProperties[e5] || "";
              return [e5, t4.get(n3).value || i3];
            }).forEach(([t5, n3]) => {
              ("borderColor" !== t5 && "borderWidth" !== t5 || "none" !== e4.value) && this.view.set(t5, n3);
            }), this._isReady = true;
          }
          _showView() {
            const t4 = this.editor;
            this.view || (this.view = this._createPropertiesView()), this.listenTo(t4.ui, "update", () => {
              this._updateView();
            }), this._fillViewFormFromCommandValues(), this._balloon.add({ view: this.view, position: pB(t4) }), this._undoStepBatch = t4.model.createBatch(), this.view.focus();
          }
          _hideView() {
            const t4 = this.editor;
            this.stopListening(t4.ui, "update"), this._isReady = false, this.view.saveButtonView.focus(), this._balloon.remove(this.view), this.editor.editing.view.focus();
          }
          _updateView() {
            const t4 = this.editor;
            zI(t4.editing.view.document.selection) ? this._isViewVisible && gB(t4, "cell") : this._hideView();
          }
          get _isViewVisible() {
            return !!this.view && this._balloon.visibleView === this.view;
          }
          get _isViewInBalloon() {
            return !!this.view && this._balloon.hasView(this.view);
          }
          _getPropertyChangeCallback(t4) {
            return (e4, n3, i3) => {
              this._isReady && this.editor.execute(t4, { value: i3, batch: this._undoStepBatch });
            };
          }
          _getValidatedPropertyChangeCallback(t4) {
            const { commandName: e4, viewField: n3, validator: i3, errorText: o3 } = t4, r3 = $r(() => {
              n3.errorText = o3;
            }, 500);
            return (t5, o4, s3) => {
              r3.cancel(), this._isReady && (i3(s3) ? (this.editor.execute(e4, { value: s3, batch: this._undoStepBatch }), n3.errorText = null) : r3());
            };
          }
        }
        class _B extends As {
          constructor(t4, e4, n3) {
            super(t4), this.attributeName = e4, this._defaultValue = n3;
          }
          refresh() {
            const t4 = this.editor, e4 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t4.model.document.selection);
            this.isEnabled = !!e4.length, this.value = this._getSingleValue(e4);
          }
          execute(t4 = {}) {
            const { value: e4, batch: n3 } = t4, i3 = this.editor.model, o3 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(i3.document.selection), r3 = this._getValueToSet(e4);
            i3.enqueueChange(n3, (t5) => {
              r3 ? o3.forEach((e5) => t5.setAttribute(this.attributeName, r3, e5)) : o3.forEach((e5) => t5.removeAttribute(this.attributeName, e5));
            });
          }
          _getAttribute(t4) {
            if (!t4)
              return;
            const e4 = t4.getAttribute(this.attributeName);
            return e4 !== this._defaultValue ? e4 : void 0;
          }
          _getValueToSet(t4) {
            if (t4 !== this._defaultValue)
              return t4;
          }
          _getSingleValue(t4) {
            const e4 = this._getAttribute(t4[0]);
            return t4.every((t5) => this._getAttribute(t5) === e4) ? e4 : void 0;
          }
        }
        class vB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellWidth", e4);
          }
          _getValueToSet(t4) {
            if ((t4 = bB(t4, "px")) !== this._defaultValue)
              return t4;
          }
        }
        class yB extends bs {
          static get pluginName() {
            return "TableCellWidthEditing";
          }
          static get requires() {
            return [gI];
          }
          init() {
            const t4 = this.editor, e4 = wB(t4.config.get("table.tableCellProperties.defaultProperties"));
            XS(t4.model.schema, t4.conversion, { modelAttribute: "tableCellWidth", styleName: "width", defaultValue: e4.width }), t4.commands.add("tableCellWidth", new vB(t4, e4.width));
          }
        }
        class xB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellPadding", e4);
          }
          _getAttribute(t4) {
            if (!t4)
              return;
            const e4 = kB(t4.getAttribute(this.attributeName));
            return e4 !== this._defaultValue ? e4 : void 0;
          }
          _getValueToSet(t4) {
            const e4 = bB(t4, "px");
            if (e4 !== this._defaultValue)
              return e4;
          }
        }
        class EB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellHeight", e4);
          }
          _getValueToSet(t4) {
            const e4 = bB(t4, "px");
            if (e4 !== this._defaultValue)
              return e4;
          }
        }
        class DB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellBackgroundColor", e4);
          }
        }
        class SB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellVerticalAlignment", e4);
          }
        }
        class TB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellHorizontalAlignment", e4);
          }
        }
        class IB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellBorderStyle", e4);
          }
          _getAttribute(t4) {
            if (!t4)
              return;
            const e4 = kB(t4.getAttribute(this.attributeName));
            return e4 !== this._defaultValue ? e4 : void 0;
          }
        }
        class BB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellBorderColor", e4);
          }
          _getAttribute(t4) {
            if (!t4)
              return;
            const e4 = kB(t4.getAttribute(this.attributeName));
            return e4 !== this._defaultValue ? e4 : void 0;
          }
        }
        class MB extends _B {
          constructor(t4, e4) {
            super(t4, "tableCellBorderWidth", e4);
          }
          _getAttribute(t4) {
            if (!t4)
              return;
            const e4 = kB(t4.getAttribute(this.attributeName));
            return e4 !== this._defaultValue ? e4 : void 0;
          }
          _getValueToSet(t4) {
            const e4 = bB(t4, "px");
            if (e4 !== this._defaultValue)
              return e4;
          }
        }
        const NB = /^(top|middle|bottom)$/, LB = /^(left|center|right|justify)$/;
        class zB extends bs {
          static get pluginName() {
            return "TableCellPropertiesEditing";
          }
          static get requires() {
            return [gI, yB];
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.conversion;
            t4.config.define("table.tableCellProperties.defaultProperties", {});
            const i3 = wB(t4.config.get("table.tableCellProperties.defaultProperties"), { includeVerticalAlignmentProperty: true, includeHorizontalAlignmentProperty: true, includePaddingProperty: true, isRightToLeftContent: "rtl" === t4.locale.contentLanguageDirection });
            t4.data.addStyleProcessorRules(pg2), function(t5, e5, n4) {
              const i4 = { width: "tableCellBorderWidth", color: "tableCellBorderColor", style: "tableCellBorderStyle" };
              t5.extend("tableCell", { allowAttributes: Object.values(i4) }), qS(e5, "td", i4, n4), qS(e5, "th", i4, n4), $S(e5, { modelElement: "tableCell", modelAttribute: i4.style, styleName: "border-style" }), $S(e5, { modelElement: "tableCell", modelAttribute: i4.color, styleName: "border-color" }), $S(e5, { modelElement: "tableCell", modelAttribute: i4.width, styleName: "border-width" });
            }(e4, n3, { color: i3.borderColor, style: i3.borderStyle, width: i3.borderWidth }), t4.commands.add("tableCellBorderStyle", new IB(t4, i3.borderStyle)), t4.commands.add("tableCellBorderColor", new BB(t4, i3.borderColor)), t4.commands.add("tableCellBorderWidth", new MB(t4, i3.borderWidth)), XS(e4, n3, { modelAttribute: "tableCellHeight", styleName: "height", defaultValue: i3.height }), t4.commands.add("tableCellHeight", new EB(t4, i3.height)), t4.data.addStyleProcessorRules(Eg2), XS(e4, n3, { modelAttribute: "tableCellPadding", styleName: "padding", reduceBoxSides: true, defaultValue: i3.padding }), t4.commands.add("tableCellPadding", new xB(t4, i3.padding)), t4.data.addStyleProcessorRules(mg2), XS(e4, n3, { modelAttribute: "tableCellBackgroundColor", styleName: "background-color", defaultValue: i3.backgroundColor }), t4.commands.add("tableCellBackgroundColor", new DB(t4, i3.backgroundColor)), function(t5, e5, n4) {
              t5.extend("tableCell", { allowAttributes: ["tableCellHorizontalAlignment"] }), e5.for("downcast").attributeToAttribute({ model: { name: "tableCell", key: "tableCellHorizontalAlignment" }, view: (t6) => ({ key: "style", value: { "text-align": t6 } }) }), e5.for("upcast").attributeToAttribute({ view: { name: /^(td|th)$/, styles: { "text-align": LB } }, model: { key: "tableCellHorizontalAlignment", value: (t6) => {
                const e6 = t6.getStyle("text-align");
                return e6 === n4 ? null : e6;
              } } }).attributeToAttribute({ view: { name: /^(td|th)$/, attributes: { align: LB } }, model: { key: "tableCellHorizontalAlignment", value: (t6) => {
                const e6 = t6.getAttribute("align");
                return e6 === n4 ? null : e6;
              } } });
            }(e4, n3, i3.horizontalAlignment), t4.commands.add("tableCellHorizontalAlignment", new TB(t4, i3.horizontalAlignment)), function(t5, e5, n4) {
              t5.extend("tableCell", { allowAttributes: ["tableCellVerticalAlignment"] }), e5.for("downcast").attributeToAttribute({ model: { name: "tableCell", key: "tableCellVerticalAlignment" }, view: (t6) => ({ key: "style", value: { "vertical-align": t6 } }) }), e5.for("upcast").attributeToAttribute({ view: { name: /^(td|th)$/, styles: { "vertical-align": NB } }, model: { key: "tableCellVerticalAlignment", value: (t6) => {
                const e6 = t6.getStyle("vertical-align");
                return e6 === n4 ? null : e6;
              } } }).attributeToAttribute({ view: { name: /^(td|th)$/, attributes: { valign: NB } }, model: { key: "tableCellVerticalAlignment", value: (t6) => {
                const e6 = t6.getAttribute("valign");
                return e6 === n4 ? null : e6;
              } } });
            }(e4, n3, i3.verticalAlignment), t4.commands.add("tableCellVerticalAlignment", new SB(t4, i3.verticalAlignment));
          }
        }
        class PB extends As {
          constructor(t4, e4, n3) {
            super(t4), this.attributeName = e4, this._defaultValue = n3;
          }
          refresh() {
            const t4 = tT(this.editor.model.document.selection);
            this.isEnabled = !!t4, this.value = this._getValue(t4);
          }
          execute(t4 = {}) {
            const e4 = this.editor.model, n3 = e4.document.selection, { value: i3, batch: o3 } = t4, r3 = tT(n3), s3 = this._getValueToSet(i3);
            e4.enqueueChange(o3, (t5) => {
              s3 ? t5.setAttribute(this.attributeName, s3, r3) : t5.removeAttribute(this.attributeName, r3);
            });
          }
          _getValue(t4) {
            if (!t4)
              return;
            const e4 = t4.getAttribute(this.attributeName);
            return e4 !== this._defaultValue ? e4 : void 0;
          }
          _getValueToSet(t4) {
            if (t4 !== this._defaultValue)
              return t4;
          }
        }
        class RB extends PB {
          constructor(t4, e4) {
            super(t4, "tableBackgroundColor", e4);
          }
        }
        class OB extends PB {
          constructor(t4, e4) {
            super(t4, "tableBorderColor", e4);
          }
          _getValue(t4) {
            if (!t4)
              return;
            const e4 = kB(t4.getAttribute(this.attributeName));
            return e4 !== this._defaultValue ? e4 : void 0;
          }
        }
        class FB extends PB {
          constructor(t4, e4) {
            super(t4, "tableBorderStyle", e4);
          }
          _getValue(t4) {
            if (!t4)
              return;
            const e4 = kB(t4.getAttribute(this.attributeName));
            return e4 !== this._defaultValue ? e4 : void 0;
          }
        }
        class VB extends PB {
          constructor(t4, e4) {
            super(t4, "tableBorderWidth", e4);
          }
          _getValue(t4) {
            if (!t4)
              return;
            const e4 = kB(t4.getAttribute(this.attributeName));
            return e4 !== this._defaultValue ? e4 : void 0;
          }
          _getValueToSet(t4) {
            const e4 = bB(t4, "px");
            if (e4 !== this._defaultValue)
              return e4;
          }
        }
        class jB extends PB {
          constructor(t4, e4) {
            super(t4, "tableWidth", e4);
          }
          _getValueToSet(t4) {
            if ((t4 = bB(t4, "px")) !== this._defaultValue)
              return t4;
          }
        }
        class HB extends PB {
          constructor(t4, e4) {
            super(t4, "tableHeight", e4);
          }
          _getValueToSet(t4) {
            if ((t4 = bB(t4, "px")) !== this._defaultValue)
              return t4;
          }
        }
        class UB extends PB {
          constructor(t4, e4) {
            super(t4, "tableAlignment", e4);
          }
        }
        const GB = /^(left|center|right)$/, WB = /^(left|none|right)$/;
        class qB extends bs {
          static get pluginName() {
            return "TablePropertiesEditing";
          }
          static get requires() {
            return [gI];
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.conversion;
            t4.config.define("table.tableProperties.defaultProperties", {});
            const i3 = wB(t4.config.get("table.tableProperties.defaultProperties"), { includeAlignmentProperty: true });
            t4.data.addStyleProcessorRules(pg2), function(t5, e5, n4) {
              const i4 = { width: "tableBorderWidth", color: "tableBorderColor", style: "tableBorderStyle" };
              t5.extend("table", { allowAttributes: Object.values(i4) }), qS(e5, "table", i4, n4), KS(e5, { modelAttribute: i4.color, styleName: "border-color" }), KS(e5, { modelAttribute: i4.style, styleName: "border-style" }), KS(e5, { modelAttribute: i4.width, styleName: "border-width" });
            }(e4, n3, { color: i3.borderColor, style: i3.borderStyle, width: i3.borderWidth }), t4.commands.add("tableBorderColor", new OB(t4, i3.borderColor)), t4.commands.add("tableBorderStyle", new FB(t4, i3.borderStyle)), t4.commands.add("tableBorderWidth", new VB(t4, i3.borderWidth)), function(t5, e5, n4) {
              t5.extend("table", { allowAttributes: ["tableAlignment"] }), e5.for("downcast").attributeToAttribute({ model: { name: "table", key: "tableAlignment" }, view: (t6) => ({ key: "style", value: { float: "center" === t6 ? "none" : t6 } }), converterPriority: "high" }), e5.for("upcast").attributeToAttribute({ view: { name: /^(table|figure)$/, styles: { float: WB } }, model: { key: "tableAlignment", value: (t6) => {
                let e6 = t6.getStyle("float");
                return "none" === e6 && (e6 = "center"), e6 === n4 ? null : e6;
              } } }).attributeToAttribute({ view: { attributes: { align: GB } }, model: { name: "table", key: "tableAlignment", value: (t6) => {
                const e6 = t6.getAttribute("align");
                return e6 === n4 ? null : e6;
              } } });
            }(e4, n3, i3.alignment), t4.commands.add("tableAlignment", new UB(t4, i3.alignment)), $B(e4, n3, { modelAttribute: "tableWidth", styleName: "width", defaultValue: i3.width }), t4.commands.add("tableWidth", new jB(t4, i3.width)), $B(e4, n3, { modelAttribute: "tableHeight", styleName: "height", defaultValue: i3.height }), t4.commands.add("tableHeight", new HB(t4, i3.height)), t4.data.addStyleProcessorRules(mg2), function(t5, e5, n4) {
              const { modelAttribute: i4 } = n4;
              t5.extend("table", { allowAttributes: [i4] }), WS(e5, { viewElement: "table", ...n4 }), KS(e5, n4);
            }(e4, n3, { modelAttribute: "tableBackgroundColor", styleName: "background-color", defaultValue: i3.backgroundColor }), t4.commands.add("tableBackgroundColor", new RB(t4, i3.backgroundColor));
          }
        }
        function $B(t4, e4, n3) {
          const { modelAttribute: i3 } = n3;
          t4.extend("table", { allowAttributes: [i3] }), WS(e4, { viewElement: /^(table|figure)$/, shouldUpcast: (t5) => !("table" == t5.name && "figure" == t5.parent.name), ...n3 }), $S(e4, { modelElement: "table", ...n3 });
        }
        var KB = n2(6596), ZB = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(KB.Z, ZB);
        KB.Z.locals;
        const YB = { left: Pg2.objectLeft, center: Pg2.objectCenter, right: Pg2.objectRight };
        class QB extends Ho2 {
          constructor(t4, e4) {
            super(t4), this.set({ borderStyle: "", borderWidth: "", borderColor: "", backgroundColor: "", width: "", height: "", alignment: "" }), this.options = e4;
            const { borderStyleDropdown: n3, borderWidthInput: i3, borderColorInput: o3, borderRowLabel: r3 } = this._createBorderFields(), { backgroundRowLabel: s3, backgroundInput: a3 } = this._createBackgroundFields(), { widthInput: c3, operatorLabel: l3, heightInput: d3, dimensionsLabel: h3 } = this._createDimensionFields(), { alignmentToolbar: u3, alignmentLabel: g3 } = this._createAlignmentFields();
            this.focusTracker = new To2(), this.keystrokes = new Io2(), this.children = this.createCollection(), this.borderStyleDropdown = n3, this.borderWidthInput = i3, this.borderColorInput = o3, this.backgroundInput = a3, this.widthInput = c3, this.heightInput = d3, this.alignmentToolbar = u3;
            const { saveButtonView: m3, cancelButtonView: p3 } = this._createActionButtons();
            this.saveButtonView = m3, this.cancelButtonView = p3, this._focusables = new Ro2(), this._focusCycler = new gs({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.children.add(new jp(t4, { label: this.t("Table properties") })), this.children.add(new eB(t4, { labelView: r3, children: [r3, n3, o3, i3], class: "ck-table-form__border-row" })), this.children.add(new eB(t4, { labelView: s3, children: [s3, a3], class: "ck-table-form__background-row" })), this.children.add(new eB(t4, { children: [new eB(t4, { labelView: h3, children: [h3, c3, l3, d3], class: "ck-table-form__dimensions-row" }), new eB(t4, { labelView: g3, children: [g3, u3], class: "ck-table-properties-form__alignment-row" })] })), this.children.add(new eB(t4, { children: [this.saveButtonView, this.cancelButtonView], class: "ck-table-form__action-row" })), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-form", "ck-table-form", "ck-table-properties-form"], tabindex: "-1" }, children: this.children });
          }
          render() {
            super.render(), o2({ view: this }), [this.borderColorInput, this.backgroundInput].forEach((t4) => {
              t4.fieldView.focusCycler.on("forwardCycle", (t5) => {
                this._focusCycler.focusNext(), t5.stop();
              }), t4.fieldView.focusCycler.on("backwardCycle", (t5) => {
                this._focusCycler.focusPrevious(), t5.stop();
              });
            }), [this.borderStyleDropdown, this.borderColorInput, this.borderWidthInput, this.backgroundInput, this.widthInput, this.heightInput, this.alignmentToolbar, this.saveButtonView, this.cancelButtonView].forEach((t4) => {
              this._focusables.add(t4), this.focusTracker.add(t4.element);
            }), this.keystrokes.listenTo(this.element);
          }
          destroy() {
            super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
          }
          focus() {
            this._focusCycler.focusFirst();
          }
          _createBorderFields() {
            const t4 = this.options.defaultTableProperties, e4 = { style: t4.borderStyle, width: t4.borderWidth, color: t4.borderColor }, n3 = QI({ colorConfig: this.options.borderColors, columns: 5, defaultColorValue: e4.color, colorPickerConfig: this.options.colorPickerConfig }), i3 = this.locale, o3 = this.t, r3 = o3("Style"), s3 = new Yr(i3);
            s3.text = o3("Border");
            const a3 = HI(o3), c3 = new Xr(i3, um);
            c3.set({ label: r3, class: "ck-table-form__border-style" }), c3.fieldView.buttonView.set({ ariaLabel: r3, ariaLabelledBy: void 0, isOn: false, withText: true, tooltip: r3 }), c3.fieldView.buttonView.bind("label").to(this, "borderStyle", (t5) => a3[t5 || "none"]), c3.fieldView.on("execute", (t5) => {
              this.borderStyle = t5.source._borderStyleValue;
            }), c3.bind("isEmpty").to(this, "borderStyle", (t5) => !t5), am(c3.fieldView, KI(this, e4.style), { role: "menu", ariaLabel: r3 });
            const l3 = new Xr(i3, hm);
            l3.set({ label: o3("Width"), class: "ck-table-form__border-width" }), l3.fieldView.bind("value").to(this, "borderWidth"), l3.bind("isEnabled").to(this, "borderStyle", JB), l3.fieldView.on("input", () => {
              this.borderWidth = l3.fieldView.element.value;
            });
            const d3 = new Xr(i3, n3);
            return d3.set({ label: o3("Color"), class: "ck-table-form__border-color" }), d3.fieldView.bind("value").to(this, "borderColor"), d3.bind("isEnabled").to(this, "borderStyle", JB), d3.fieldView.on("input", () => {
              this.borderColor = d3.fieldView.value;
            }), this.on("change:borderStyle", (t5, n4, i4, o4) => {
              JB(i4) || (this.borderColor = "", this.borderWidth = ""), JB(o4) || (this.borderColor = e4.color, this.borderWidth = e4.width);
            }), { borderRowLabel: s3, borderStyleDropdown: c3, borderColorInput: d3, borderWidthInput: l3 };
          }
          _createBackgroundFields() {
            const t4 = this.locale, e4 = this.t, n3 = new Yr(t4);
            n3.text = e4("Background");
            const i3 = QI({ colorConfig: this.options.backgroundColors, columns: 5, defaultColorValue: this.options.defaultTableProperties.backgroundColor, colorPickerConfig: this.options.colorPickerConfig }), o3 = new Xr(t4, i3);
            return o3.set({ label: e4("Color"), class: "ck-table-properties-form__background" }), o3.fieldView.bind("value").to(this, "backgroundColor"), o3.fieldView.on("input", () => {
              this.backgroundColor = o3.fieldView.value;
            }), { backgroundRowLabel: n3, backgroundInput: o3 };
          }
          _createDimensionFields() {
            const t4 = this.locale, e4 = this.t, n3 = new Yr(t4);
            n3.text = e4("Dimensions");
            const i3 = new Xr(t4, hm);
            i3.set({ label: e4("Width"), class: "ck-table-form__dimensions-row__width" }), i3.fieldView.bind("value").to(this, "width"), i3.fieldView.on("input", () => {
              this.width = i3.fieldView.element.value;
            });
            const o3 = new Ho2(t4);
            o3.setTemplate({ tag: "span", attributes: { class: ["ck-table-form__dimension-operator"] }, children: [{ text: "" }] });
            const r3 = new Xr(t4, hm);
            return r3.set({ label: e4("Height"), class: "ck-table-form__dimensions-row__height" }), r3.fieldView.bind("value").to(this, "height"), r3.fieldView.on("input", () => {
              this.height = r3.fieldView.element.value;
            }), { dimensionsLabel: n3, widthInput: i3, operatorLabel: o3, heightInput: r3 };
          }
          _createAlignmentFields() {
            const t4 = this.locale, e4 = this.t, n3 = new Yr(t4);
            n3.text = e4("Alignment");
            const i3 = new jg2(t4);
            return i3.set({ isCompact: true, ariaLabel: e4("Table alignment toolbar") }), ZI({ view: this, icons: YB, toolbar: i3, labels: this._alignmentLabels, propertyName: "alignment", defaultValue: this.options.defaultTableProperties.alignment }), { alignmentLabel: n3, alignmentToolbar: i3 };
          }
          _createActionButtons() {
            const t4 = this.locale, e4 = this.t, n3 = new kr(t4), i3 = new kr(t4), o3 = [this.borderWidthInput, this.borderColorInput, this.backgroundInput, this.widthInput, this.heightInput];
            return n3.set({ label: e4("Save"), icon: Pg2.check, class: "ck-button-save", type: "submit", withText: true }), n3.bind("isEnabled").toMany(o3, "errorText", (...t5) => t5.every((t6) => !t6)), i3.set({ label: e4("Cancel"), icon: Pg2.cancel, class: "ck-button-cancel", withText: true }), i3.delegate("execute").to(this, "cancel"), { saveButtonView: n3, cancelButtonView: i3 };
          }
          get _alignmentLabels() {
            const t4 = this.locale, e4 = this.t, n3 = e4("Align table to the left"), i3 = e4("Center table"), o3 = e4("Align table to the right");
            return "rtl" === t4.uiLanguageDirection ? { right: o3, center: i3, left: n3 } : { left: n3, center: i3, right: o3 };
          }
        }
        function JB(t4) {
          return "none" !== t4;
        }
        const XB = { borderStyle: "tableBorderStyle", borderColor: "tableBorderColor", borderWidth: "tableBorderWidth", backgroundColor: "tableBackgroundColor", width: "tableWidth", height: "tableHeight", alignment: "tableAlignment" };
        class tM extends bs {
          static get requires() {
            return [Yp];
          }
          static get pluginName() {
            return "TablePropertiesUI";
          }
          constructor(t4) {
            super(t4), this.view = null, t4.config.define("table.tableProperties", { borderColors: YI, backgroundColors: YI });
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            this._defaultTableProperties = wB(t4.config.get("table.tableProperties.defaultProperties"), { includeAlignmentProperty: true }), this._balloon = t4.plugins.get(Yp), t4.ui.componentFactory.add("tableProperties", (n3) => {
              const i3 = new kr(n3);
              i3.set({ label: e4("Table properties"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8 2v5h4V2h1v5h5v1h-5v4h.021l-.172.351-1.916.28-.151.027c-.287.063-.54.182-.755.341L8 13v5H7v-5H2v-1h5V8H2V7h5V2h1zm4 6H8v4h4V8z" opacity=".6"/><path d="m15.5 11.5 1.323 2.68 2.957.43-2.14 2.085.505 2.946L15.5 18.25l-2.645 1.39.505-2.945-2.14-2.086 2.957-.43L15.5 11.5zM17 1a2 2 0 0 1 2 2v9.475l-.85-.124-.857-1.736a2.048 2.048 0 0 0-.292-.44L17 3H3v14h7.808l.402.392L10.935 19H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14z"/></svg>', tooltip: true }), this.listenTo(i3, "execute", () => this._showView());
              const o3 = Object.values(XB).map((e5) => t4.commands.get(e5));
              return i3.bind("isEnabled").toMany(o3, "isEnabled", (...t5) => t5.some((t6) => t6)), i3;
            });
          }
          destroy() {
            super.destroy(), this.view && this.view.destroy();
          }
          _createPropertiesView() {
            const e4 = this.editor, n3 = e4.config.get("table.tableProperties"), i3 = _r(n3.borderColors), o3 = Cr(e4.locale, i3), r3 = _r(n3.backgroundColors), s3 = Cr(e4.locale, r3), a3 = false !== n3.colorPicker, c3 = new QB(e4.locale, { borderColors: o3, backgroundColors: s3, defaultTableProperties: this._defaultTableProperties, colorPickerConfig: !!a3 && (n3.colorPicker || {}) }), l3 = e4.t;
            c3.render(), this.listenTo(c3, "submit", () => {
              this._hideView();
            }), this.listenTo(c3, "cancel", () => {
              this._undoStepBatch.operations.length && e4.execute("undo", this._undoStepBatch), this._hideView();
            }), c3.keystrokes.set("Esc", (t4, e5) => {
              this._hideView(), e5();
            }), t3({ emitter: c3, activator: () => this._isViewInBalloon, contextElements: [this._balloon.view.element], callback: () => this._hideView() });
            const d3 = UI(l3), h3 = GI(l3);
            return c3.on("change:borderStyle", this._getPropertyChangeCallback("tableBorderStyle")), c3.on("change:borderColor", this._getValidatedPropertyChangeCallback({ viewField: c3.borderColorInput, commandName: "tableBorderColor", errorText: d3, validator: WI })), c3.on("change:borderWidth", this._getValidatedPropertyChangeCallback({ viewField: c3.borderWidthInput, commandName: "tableBorderWidth", errorText: h3, validator: $I })), c3.on("change:backgroundColor", this._getValidatedPropertyChangeCallback({ viewField: c3.backgroundInput, commandName: "tableBackgroundColor", errorText: d3, validator: WI })), c3.on("change:width", this._getValidatedPropertyChangeCallback({ viewField: c3.widthInput, commandName: "tableWidth", errorText: h3, validator: qI })), c3.on("change:height", this._getValidatedPropertyChangeCallback({ viewField: c3.heightInput, commandName: "tableHeight", errorText: h3, validator: qI })), c3.on("change:alignment", this._getPropertyChangeCallback("tableAlignment")), c3;
          }
          _fillViewFormFromCommandValues() {
            const t4 = this.editor.commands, e4 = t4.get("tableBorderStyle");
            Object.entries(XB).map(([e5, n3]) => {
              const i3 = e5, o3 = this._defaultTableProperties[i3] || "";
              return [i3, t4.get(n3).value || o3];
            }).forEach(([t5, n3]) => {
              ("borderColor" !== t5 && "borderWidth" !== t5 || "none" !== e4.value) && this.view.set(t5, n3);
            }), this._isReady = true;
          }
          _showView() {
            const t4 = this.editor;
            this.view || (this.view = this._createPropertiesView()), this.listenTo(t4.ui, "update", () => {
              this._updateView();
            }), this._fillViewFormFromCommandValues(), this._balloon.add({ view: this.view, position: mB(t4) }), this._undoStepBatch = t4.model.createBatch(), this.view.focus();
          }
          _hideView() {
            const t4 = this.editor;
            this.stopListening(t4.ui, "update"), this._isReady = false, this.view.saveButtonView.focus(), this._balloon.remove(this.view), this.editor.editing.view.focus();
          }
          _updateView() {
            const t4 = this.editor;
            NI(t4.editing.view.document.selection) ? this._isViewVisible && gB(t4, "table") : this._hideView();
          }
          get _isViewVisible() {
            return !!this.view && this._balloon.visibleView === this.view;
          }
          get _isViewInBalloon() {
            return !!this.view && this._balloon.hasView(this.view);
          }
          _getPropertyChangeCallback(t4) {
            return (e4, n3, i3) => {
              this._isReady && this.editor.execute(t4, { value: i3, batch: this._undoStepBatch });
            };
          }
          _getValidatedPropertyChangeCallback(t4) {
            const { commandName: e4, viewField: n3, validator: i3, errorText: o3 } = t4, r3 = $r(() => {
              n3.errorText = o3;
            }, 500);
            return (t5, o4, s3) => {
              r3.cancel(), this._isReady && (i3(s3) ? (this.editor.execute(e4, { value: s3, batch: this._undoStepBatch }), n3.errorText = null) : r3());
            };
          }
        }
        function eM(t4) {
          t4.document.registerPostFixer((e4) => function(t5, e5) {
            const n3 = e5.document.differ.getChanges();
            let i3 = false;
            for (const e6 of n3) {
              if ("insert" != e6.type)
                continue;
              const n4 = e6.position.parent;
              if (n4.is("element", "table") || "table" == e6.name) {
                const o3 = "table" == e6.name ? e6.position.nodeAfter : n4, r3 = Array.from(o3.getChildren()).filter((t6) => t6.is("element", "caption")), s3 = r3.shift();
                if (!s3)
                  continue;
                for (const e7 of r3)
                  t5.move(t5.createRangeIn(e7), s3, "end"), t5.remove(e7);
                s3.nextSibling && (t5.move(t5.createRangeOn(s3), o3, "end"), i3 = true), i3 = !!r3.length || i3;
              }
            }
            return i3;
          }(e4, t4));
        }
        function nM(t4) {
          return !!t4 && t4.is("element", "table");
        }
        function iM(t4) {
          for (const e4 of t4.getChildren())
            if (e4.is("element", "caption"))
              return e4;
          return null;
        }
        function oM(t4) {
          const e4 = t4.parent;
          return "figcaption" == t4.name && e4 && e4.is("element", "figure") && e4.hasClass("table") || "caption" == t4.name && e4 && e4.is("element", "table") ? { name: true } : null;
        }
        class rM extends As {
          refresh() {
            const t4 = tT(this.editor.model.document.selection);
            this.isEnabled = !!t4, this.isEnabled ? this.value = !!iM(t4) : this.value = false;
          }
          execute({ focusCaptionOnShow: t4 = false } = {}) {
            this.editor.model.change((e4) => {
              this.value ? this._hideTableCaption(e4) : this._showTableCaption(e4, t4);
            });
          }
          _showTableCaption(t4, e4) {
            const n3 = this.editor.model, i3 = tT(n3.document.selection), o3 = this.editor.plugins.get("TableCaptionEditing")._getSavedCaption(i3) || t4.createElement("caption");
            n3.insertContent(o3, i3, "end"), e4 && t4.setSelection(o3, "in");
          }
          _hideTableCaption(t4) {
            const e4 = this.editor.model, n3 = tT(e4.document.selection), i3 = this.editor.plugins.get("TableCaptionEditing"), o3 = iM(n3);
            i3._saveCaption(n3, o3), e4.deleteContent(t4.createSelection(o3, "on"));
          }
        }
        class sM extends bs {
          static get pluginName() {
            return "TableCaptionEditing";
          }
          constructor(t4) {
            super(t4), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
          }
          init() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.editing.view, i3 = t4.t;
            e4.isRegistered("caption") ? e4.extend("caption", { allowIn: "table" }) : e4.register("caption", { allowIn: "table", allowContentOf: "$block", isLimit: true }), t4.commands.add("toggleTableCaption", new rM(this.editor)), t4.conversion.for("upcast").elementToElement({ view: oM, model: "caption" }), t4.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (t5, { writer: e5 }) => nM(t5.parent) ? e5.createContainerElement("figcaption") : null }), t4.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (t5, { writer: e5 }) => {
              if (!nM(t5.parent))
                return null;
              const o3 = e5.createEditableElement("figcaption");
              return e5.setCustomProperty("tableCaption", true, o3), o3.placeholder = i3("Enter table caption"), Is({ view: n3, element: o3, keepOnFocus: true }), qb2(o3, e5);
            } }), eM(t4.model);
          }
          _getSavedCaption(t4) {
            const e4 = this._savedCaptionsMap.get(t4);
            return e4 ? Wl.fromJSON(e4) : null;
          }
          _saveCaption(t4, e4) {
            this._savedCaptionsMap.set(t4, e4.toJSON());
          }
        }
        class aM extends bs {
          static get pluginName() {
            return "TableCaptionUI";
          }
          init() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = t4.t;
            t4.ui.componentFactory.add("toggleTableCaption", (i3) => {
              const o3 = t4.commands.get("toggleTableCaption"), r3 = new kr(i3);
              return r3.set({ icon: Pg2.caption, tooltip: true, isToggleable: true }), r3.bind("isOn", "isEnabled").to(o3, "value", "isEnabled"), r3.bind("label").to(o3, "value", (t5) => n3(t5 ? "Toggle caption off" : "Toggle caption on")), this.listenTo(r3, "execute", () => {
                if (t4.execute("toggleTableCaption", { focusCaptionOnShow: true }), o3.value) {
                  const n4 = function(t5) {
                    const e5 = tT(t5);
                    return e5 ? iM(e5) : null;
                  }(t4.model.document.selection), i4 = t4.editing.mapper.toViewElement(n4);
                  if (!i4)
                    return;
                  e4.scrollToTheSelection(), e4.change((t5) => {
                    t5.addClass("table__caption_highlighted", i4);
                  });
                }
                t4.editing.view.focus();
              }), r3;
            });
          }
        }
        var cM = n2(1111), lM = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(cM.Z, lM);
        cM.Z.locals;
        class dM extends As {
          refresh() {
            this.isEnabled = true;
          }
          execute(t4 = {}) {
            const { model: e4, plugins: n3 } = this.editor;
            let { table: i3 = e4.document.selection.getSelectedElement(), columnWidths: o3, tableWidth: r3 } = t4;
            o3 && (o3 = Array.isArray(o3) ? o3 : o3.split(",")), e4.change((t5) => {
              r3 ? t5.setAttribute("tableWidth", r3, i3) : t5.removeAttribute("tableWidth", i3);
              const e5 = n3.get("TableColumnResizeEditing").getColumnGroupElement(i3);
              if (!o3 && !e5)
                return;
              if (!o3)
                return t5.remove(e5);
              const s3 = FT(o3);
              if (e5)
                Array.from(e5.getChildren()).forEach((e6, n4) => t5.setAttribute("columnWidth", s3[n4], e6));
              else {
                const e6 = t5.createElement("tableColumnGroup");
                s3.forEach((n4) => t5.appendElement("tableColumn", { columnWidth: n4 }, e6)), t5.append(e6, i3);
              }
            });
          }
        }
        function hM(t4) {
          return (e4) => e4.on("element:colgroup", (e5, n3, i3) => {
            const o3 = n3.modelCursor.findAncestor("table"), r3 = HT(o3);
            if (!r3)
              return;
            const s3 = UT(r3), a3 = t4.getColumns(o3);
            let c3 = (l3 = r3, d3 = i3.writer, UT(l3).reduce((t5, e6) => {
              const n4 = e6.getAttribute("columnWidth"), i4 = e6.getAttribute("colSpan");
              if (!i4)
                return t5.push(n4), t5;
              for (let e7 = 0; e7 < i4; e7++)
                t5.push(n4);
              return d3.removeAttribute("colSpan", e6), t5;
            }, []));
            var l3, d3;
            c3 = Array.from({ length: a3 }, (t5, e6) => c3[e6] || "auto"), (c3.length != s3.length || c3.includes("auto")) && jT(s3, r3, FT(c3), i3.writer);
          }, { priority: "low" });
        }
        class uM extends bs {
          static get requires() {
            return [gI, GT];
          }
          static get pluginName() {
            return "TableColumnResizeEditing";
          }
          constructor(t4) {
            super(t4), this._isResizingActive = false, this.set("_isResizingAllowed", true), this._resizingData = null, this._domEmitter = new (Ii2())(), this._tableUtilsPlugin = t4.plugins.get("TableUtils"), this.on("change:_isResizingAllowed", (e4, n3, i3) => {
              const o3 = i3 ? "removeClass" : "addClass";
              t4.editing.view.change((e5) => {
                for (const n4 of t4.editing.view.document.roots)
                  e5[o3]("ck-column-resize_disabled", t4.editing.view.document.getRoot(n4.rootName));
              });
            });
          }
          init() {
            this._extendSchema(), this._registerPostFixer(), this._registerConverters(), this._registerResizingListeners(), this._registerResizerInserter();
            const t4 = this.editor, e4 = t4.plugins.get("TableColumnResize");
            t4.plugins.get("TableEditing").registerAdditionalSlot({ filter: (t5) => t5.is("element", "tableColumnGroup"), positionOffset: 0 });
            const n3 = new dM(t4);
            t4.commands.add("resizeTableWidth", n3), t4.commands.add("resizeColumnWidths", n3), this.bind("_isResizingAllowed").to(t4, "isReadOnly", e4, "isEnabled", n3, "isEnabled", (t5, e5, n4) => !t5 && e5 && n4);
          }
          destroy() {
            this._domEmitter.stopListening(), super.destroy();
          }
          getColumnGroupElement(t4) {
            return HT(t4);
          }
          getTableColumnElements(t4) {
            return UT(t4);
          }
          getTableColumnsWidths(t4) {
            return function(t5) {
              return UT(t5).map((t6) => t6.getAttribute("columnWidth"));
            }(t4);
          }
          _extendSchema() {
            this.editor.model.schema.extend("table", { allowAttributes: ["tableWidth"] }), this.editor.model.schema.register("tableColumnGroup", { allowIn: "table", isLimit: true }), this.editor.model.schema.register("tableColumn", { allowIn: "tableColumnGroup", allowAttributes: ["columnWidth", "colSpan"], isLimit: true });
          }
          _registerPostFixer() {
            const t4 = this.editor.model;
            function e4(t5, e5, n3) {
              const i3 = n3._tableUtilsPlugin.getColumns(e5);
              if (0 === i3 - t5.length)
                return t5;
              const o3 = t5.map((t6) => Number(t6.replace("%", ""))), r3 = function(t6, e6) {
                const n4 = /* @__PURE__ */ new Set();
                for (const i4 of t6.getChanges())
                  if ("insert" == i4.type && i4.position.nodeAfter && "tableCell" == i4.position.nodeAfter.name && i4.position.nodeAfter.getAncestors().includes(e6))
                    n4.add(i4.position.nodeAfter);
                  else if ("remove" == i4.type) {
                    const t7 = i4.position.nodeBefore || i4.position.nodeAfter;
                    "tableCell" == t7.name && t7.getAncestors().includes(e6) && n4.add(t7);
                  }
                return n4;
              }(n3.editor.model.document.differ, e5);
              for (const t6 of r3) {
                const r4 = i3 - o3.length;
                if (0 === r4)
                  continue;
                const a3 = r4 > 0, c3 = n3._tableUtilsPlugin.getCellLocation(t6).column;
                if (a3) {
                  const t7 = NT(e5, n3.editor), i4 = (s3 = t7, Array(r4).fill(s3));
                  o3.splice(c3, 0, ...i4);
                } else {
                  const t7 = o3.splice(c3, Math.abs(r4));
                  o3[c3] += OT(t7);
                }
              }
              var s3;
              return o3.map((t6) => t6 + "%");
            }
            t4.document.registerPostFixer((n3) => {
              let i3 = false;
              for (const o3 of function(t5) {
                const e5 = /* @__PURE__ */ new Set();
                for (const n4 of t5.document.differ.getChanges()) {
                  let i4 = null;
                  switch (n4.type) {
                    case "insert":
                      i4 = ["table", "tableRow", "tableCell"].includes(n4.name) ? n4.position : null;
                      break;
                    case "remove":
                      i4 = ["tableRow", "tableCell"].includes(n4.name) ? n4.position : null;
                      break;
                    case "attribute":
                      n4.range.start.nodeAfter && (i4 = ["table", "tableRow", "tableCell"].includes(n4.range.start.nodeAfter.name) ? n4.range.start : null);
                  }
                  if (!i4)
                    continue;
                  const o4 = i4.nodeAfter && i4.nodeAfter.is("element", "table") ? i4.nodeAfter : i4.findAncestor("table");
                  for (const n5 of t5.createRangeOn(o4).getItems())
                    n5.is("element", "table") && HT(n5) && e5.add(n5);
                }
                return e5;
              }(t4)) {
                const t5 = this.getColumnGroupElement(o3), r3 = this.getTableColumnElements(t5), s3 = this.getTableColumnsWidths(t5);
                let a3 = FT(s3);
                a3 = e4(a3, o3, this), Lh2(s3, a3) || (jT(r3, t5, a3, n3), i3 = true);
              }
              return i3;
            });
          }
          _registerConverters() {
            const t4 = this.editor.conversion;
            t4.for("upcast").attributeToAttribute({ view: { name: "figure", key: "style", value: { width: /[\s\S]+/ } }, model: { name: "table", key: "tableWidth", value: (t5) => t5.getStyle("width") } }), t4.for("downcast").attributeToAttribute({ model: { name: "table", key: "tableWidth" }, view: (t5) => ({ name: "figure", key: "style", value: { width: t5 } }) }), t4.elementToElement({ model: "tableColumnGroup", view: "colgroup" }), t4.elementToElement({ model: "tableColumn", view: "col" }), t4.for("downcast").add((t5) => t5.on("insert:table", (t6, e4, n3) => {
              const i3 = n3.writer, o3 = e4.item, r3 = n3.mapper.toViewElement(o3), s3 = r3.is("element", "table") ? r3 : Array.from(r3.getChildren()).find((t7) => t7.is("element", "table"));
              HT(o3) ? i3.addClass("ck-table-resized", s3) : i3.removeClass("ck-table-resized", s3);
            }, { priority: "low" })), t4.for("upcast").add(hM(this._tableUtilsPlugin)), t4.for("upcast").attributeToAttribute({ view: { name: "col", styles: { width: /.*/ } }, model: { key: "columnWidth", value: (t5) => {
              const e4 = t5.getStyle("width");
              return e4 && (e4.endsWith("%") || e4.endsWith("pt")) ? e4 : "auto";
            } } }), t4.for("upcast").attributeToAttribute({ view: { name: "col", key: "span" }, model: "colSpan" }), t4.for("downcast").attributeToAttribute({ model: { name: "tableColumn", key: "columnWidth" }, view: (t5) => ({ key: "style", value: { width: t5 } }) });
          }
          _registerResizingListeners() {
            const t4 = this.editor.editing.view;
            t4.addObserver(SI), t4.document.on("mousedown", this._onMouseDownHandler.bind(this), { priority: "high" }), this._domEmitter.listenTo(Li2.window.document, "mousemove", kp(this._onMouseMoveHandler.bind(this), 50)), this._domEmitter.listenTo(Li2.window.document, "mouseup", this._onMouseUpHandler.bind(this));
          }
          _onMouseDownHandler(t4, e4) {
            const n3 = e4.target;
            if (!n3.hasClass("ck-table-column-resizer"))
              return;
            if (!this._isResizingAllowed)
              return;
            const i3 = this.editor, o3 = i3.editing.mapper.toModelElement(n3.findAncestor("figure"));
            if (!i3.model.canEditAt(o3))
              return;
            e4.preventDefault(), t4.stop();
            const r3 = function(t5, e5, n4) {
              const i4 = Array(e5.getColumns(t5)), o4 = new oT(t5);
              for (const t6 of o4) {
                const e6 = n4.editing.mapper.toViewElement(t6.cell), o5 = VT(n4.editing.view.domConverter.mapViewToDom(e6));
                (!i4[t6.column] || o5 < i4[t6.column]) && (i4[t6.column] = RT(o5));
              }
              return i4;
            }(o3, this._tableUtilsPlugin, i3), s3 = n3.findAncestor("table"), a3 = i3.editing.view;
            Array.from(s3.getChildren()).find((t5) => t5.is("element", "colgroup")) || a3.change((t5) => {
              !function(t6, e5, n4) {
                const i4 = t6.createContainerElement("colgroup");
                for (let n5 = 0; n5 < e5.length; n5++) {
                  const o4 = t6.createEmptyElement("col"), r4 = `${RT(e5[n5] / OT(e5) * 100)}%`;
                  t6.setStyle("width", r4, o4), t6.insert(t6.createPositionAt(i4, "end"), o4);
                }
                t6.insert(t6.createPositionAt(n4, 0), i4);
              }(t5, r3, s3);
            }), this._isResizingActive = true, this._resizingData = this._getResizingData(e4, r3), a3.change((t5) => function(t6, e5, n4) {
              const i4 = n4.widths.viewFigureWidth / n4.widths.viewFigureParentWidth;
              t6.addClass("ck-table-resized", e5), t6.addClass("ck-table-column-resizer__active", n4.elements.viewResizer), t6.setStyle("width", `${RT(100 * i4)}%`, e5.findAncestor("figure"));
            }(t5, s3, this._resizingData));
          }
          _onMouseMoveHandler(t4, e4) {
            if (!this._isResizingActive)
              return;
            if (!this._isResizingAllowed)
              return void this._onMouseUpHandler();
            const { columnPosition: n3, flags: { isRightEdge: i3, isTableCentered: o3, isLtrContent: r3 }, elements: { viewFigure: s3, viewLeftColumn: a3, viewRightColumn: c3 }, widths: { viewFigureParentWidth: l3, tableWidth: d3, leftColumnWidth: h3, rightColumnWidth: u3 } } = this._resizingData, g3 = 40 - h3, m3 = i3 ? l3 - d3 : u3 - 40, p3 = (r3 ? 1 : -1) * (i3 && o3 ? 2 : 1), f3 = (k3 = (e4.clientX - n3) * p3, b3 = Math.min(g3, 0), w3 = Math.max(m3, 0), RT(k3 <= b3 ? b3 : k3 >= w3 ? w3 : k3));
            var k3, b3, w3;
            0 !== f3 && this.editor.editing.view.change((t5) => {
              const e5 = RT(100 * (h3 + f3) / d3);
              if (t5.setStyle("width", `${e5}%`, a3), i3) {
                const e6 = RT(100 * (d3 + f3) / l3);
                t5.setStyle("width", `${e6}%`, s3);
              } else {
                const e6 = RT(100 * (u3 - f3) / d3);
                t5.setStyle("width", `${e6}%`, c3);
              }
            });
          }
          _onMouseUpHandler() {
            if (!this._isResizingActive)
              return;
            const { viewResizer: t4, modelTable: e4, viewFigure: n3, viewColgroup: i3 } = this._resizingData.elements, o3 = this.editor, r3 = o3.editing.view, s3 = this.getColumnGroupElement(e4), a3 = Array.from(i3.getChildren()).filter((t5) => t5.is("view:element")), c3 = s3 ? this.getTableColumnsWidths(s3) : null, l3 = a3.map((t5) => t5.getStyle("width")), d3 = !Lh2(c3, l3), h3 = e4.getAttribute("tableWidth"), u3 = n3.getStyle("width"), g3 = h3 !== u3;
            (d3 || g3) && (this._isResizingAllowed ? o3.execute("resizeTableWidth", { table: e4, tableWidth: `${RT(u3)}%`, columnWidths: l3 }) : r3.change((t5) => {
              if (c3)
                for (const e5 of a3)
                  t5.setStyle("width", c3.shift(), e5);
              else
                t5.remove(i3);
              g3 && (h3 ? t5.setStyle("width", h3, n3) : t5.removeStyle("width", n3)), c3 || h3 || t5.removeClass("ck-table-resized", [...n3.getChildren()].find((t6) => "table" === t6.name));
            })), r3.change((e5) => {
              e5.removeClass("ck-table-column-resizer__active", t4);
            }), this._isResizingActive = false, this._resizingData = null;
          }
          _getResizingData(t4, e4) {
            const n3 = this.editor, i3 = t4.domEvent.clientX, o3 = t4.target, r3 = o3.findAncestor("td") || o3.findAncestor("th"), s3 = n3.editing.mapper.toModelElement(r3), a3 = s3.findAncestor("table"), c3 = function(t5, e5) {
              const n4 = e5.getCellLocation(t5).column;
              return { leftEdge: n4, rightEdge: n4 + (t5.getAttribute("colspan") || 1) - 1 };
            }(s3, this._tableUtilsPlugin).rightEdge, l3 = c3 === this._tableUtilsPlugin.getColumns(a3) - 1, d3 = !a3.hasAttribute("tableAlignment"), h3 = "rtl" !== n3.locale.contentLanguageDirection, u3 = r3.findAncestor("table"), g3 = u3.findAncestor("figure"), m3 = [...u3.getChildren()].find((t5) => t5.is("element", "colgroup")), p3 = m3.getChild(c3), f3 = l3 ? void 0 : m3.getChild(c3 + 1);
            return { columnPosition: i3, flags: { isRightEdge: l3, isTableCentered: d3, isLtrContent: h3 }, elements: { viewResizer: o3, modelTable: a3, viewFigure: g3, viewColgroup: m3, viewLeftColumn: p3, viewRightColumn: f3 }, widths: { viewFigureParentWidth: PT(n3.editing.view.domConverter.mapViewToDom(g3.parent)), viewFigureWidth: PT(n3.editing.view.domConverter.mapViewToDom(g3)), tableWidth: LT(a3, n3), leftColumnWidth: e4[c3], rightColumnWidth: l3 ? void 0 : e4[c3 + 1] } };
          }
          _registerResizerInserter() {
            this.editor.conversion.for("editingDowncast").add((t4) => {
              t4.on("insert:tableCell", (t5, e4, n3) => {
                const i3 = e4.item, o3 = n3.mapper.toViewElement(i3), r3 = n3.writer;
                r3.insert(r3.createPositionAt(o3, "end"), r3.createUIElement("div", { class: "ck-table-column-resizer" }));
              }, { priority: "lowest" });
            });
          }
        }
        var gM = n2(7176), mM = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
        Fo2()(gM.Z, mM);
        gM.Z.locals;
        function pM(t4) {
          if (t4.is("$text") || t4.is("$textProxy"))
            return t4.data;
          const e4 = t4;
          let n3 = "", i3 = null;
          for (const t5 of e4.getChildren()) {
            const e5 = pM(t5);
            i3 && i3.is("element") && (n3 += "\n"), n3 += e5, i3 = t5;
          }
          return n3;
        }
        class fM extends zf2 {
        }
        fM.builtinPlugins = [class extends bs {
          static get requires() {
            return [Rw, sv, Xw, ek2];
          }
          static get pluginName() {
            return "AutoImage";
          }
          constructor(t4) {
            super(t4), this._timeoutId = null, this._positionToInsert = null;
          }
          init() {
            const t4 = this.editor, e4 = t4.model.document, n3 = t4.plugins.get("ClipboardPipeline");
            this.listenTo(n3, "inputTransformation", () => {
              const t5 = e4.selection.getFirstRange(), n4 = Xh2.fromPosition(t5.start);
              n4.stickiness = "toPrevious";
              const i3 = Xh2.fromPosition(t5.end);
              i3.stickiness = "toNext", e4.once("change:data", () => {
                this._embedImageBetweenPositions(n4, i3), n4.detach(), i3.detach();
              }, { priority: "high" });
            }), t4.commands.get("undo").on("execute", () => {
              this._timeoutId && (Li2.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
            }, { priority: "high" });
          }
          _embedImageBetweenPositions(t4, e4) {
            const n3 = this.editor, i3 = new md2(t4, e4), o3 = i3.getWalker({ ignoreElementEnd: true }), r3 = Object.fromEntries(n3.model.document.selection.getAttributes()), s3 = this.editor.plugins.get("ImageUtils");
            let a3 = "";
            for (const t5 of o3)
              t5.item.is("$textProxy") && (a3 += t5.item.data);
            a3 = a3.trim(), a3.match(cv) ? (this._positionToInsert = Xh2.fromPosition(t4), this._timeoutId = setTimeout(() => {
              if (!n3.commands.get("insertImage").isEnabled)
                return void i3.detach();
              n3.model.change((t5) => {
                let e5;
                this._timeoutId = null, t5.remove(i3), i3.detach(), "$graveyard" !== this._positionToInsert.root.rootName && (e5 = this._positionToInsert.toPosition()), s3.insertImage({ ...r3, src: a3 }, e5), this._positionToInsert.detach(), this._positionToInsert = null;
              });
              n3.plugins.get("Delete").requestUndoOnBackspace();
            }, 100)) : i3.detach();
          }
        }, Ox, class extends bs {
          static get pluginName() {
            return "Autosave";
          }
          static get requires() {
            return [Mg2];
          }
          constructor(t4) {
            super(t4), this._action = null;
            const e4 = t4.config.get("autosave") || {}, n3 = e4.waitingTime || 1e3;
            this.set("state", "synchronized"), this._debouncedSave = $r(this._save.bind(this), n3), this._lastDocumentVersion = t4.model.document.version, this._savePromise = null, this._domEmitter = new (Ii2())(), this._config = e4, this._pendingActions = t4.plugins.get(Mg2), this._makeImmediateSave = false;
          }
          init() {
            const t4 = this.editor, e4 = t4.model.document;
            this.listenTo(t4, "ready", () => {
              this.listenTo(e4, "change:data", (t5, e5) => {
                this._saveCallbacks.length && e5.isLocal && ("synchronized" === this.state && (this.state = "waiting", this._setPendingAction()), "waiting" === this.state && this._debouncedSave());
              });
            }), this.listenTo(t4, "destroy", () => this._flush(), { priority: "highest" }), this._domEmitter.listenTo(window, "beforeunload", (t5, e5) => {
              this._pendingActions.hasAny && (e5.returnValue = this._pendingActions.first.message);
            });
          }
          destroy() {
            this._domEmitter.stopListening(), super.destroy();
          }
          save() {
            return this._debouncedSave.cancel(), this._save();
          }
          _flush() {
            this._debouncedSave.flush();
          }
          _save() {
            return this._savePromise ? (this._makeImmediateSave = this.editor.model.document.version > this._lastDocumentVersion, this._savePromise) : (this._setPendingAction(), this.state = "saving", this._lastDocumentVersion = this.editor.model.document.version, this._savePromise = Promise.resolve().then(() => Promise.all(this._saveCallbacks.map((t4) => t4(this.editor)))).finally(() => {
              this._savePromise = null;
            }).then(() => {
              if (this._makeImmediateSave)
                return this._makeImmediateSave = false, this._save();
              this.editor.model.document.version > this._lastDocumentVersion ? (this.state = "waiting", this._debouncedSave()) : (this.state = "synchronized", this._pendingActions.remove(this._action), this._action = null);
            }).catch((t4) => {
              throw this.state = "error", this.state = "saving", this._debouncedSave(), t4;
            }), this._savePromise);
          }
          _setPendingAction() {
            const t4 = this.editor.t;
            this._action || (this._action = this._pendingActions.add(t4("Saving changes")));
          }
          get _saveCallbacks() {
            const t4 = [];
            return this.adapter && this.adapter.save && t4.push(this.adapter.save), this._config.save && t4.push(this._config.save), t4;
          }
        }, class extends bs {
          static get requires() {
            return [sb2, lb2];
          }
          static get pluginName() {
            return "BlockQuote";
          }
        }, class extends bs {
          static get requires() {
            return [Ff2, jf2];
          }
          static get pluginName() {
            return "Bold";
          }
        }, class extends bs {
          static get requires() {
            return [Ck2, xk2];
          }
          static get pluginName() {
            return "Code";
          }
        }, class extends bs {
          static get requires() {
            return [_b, Db2];
          }
          static get pluginName() {
            return "CodeBlock";
          }
        }, L_, v_, class extends bs {
          static get requires() {
            return [Rw, Qk2, Uw, eb2, nk2, Xw];
          }
          static get pluginName() {
            return "Essentials";
          }
        }, class extends bs {
          static get requires() {
            return [kA, rA];
          }
          static get pluginName() {
            return "FindAndReplace";
          }
          init() {
            const t4 = this.editor.plugins.get("FindAndReplaceUI"), e4 = this.editor.plugins.get("FindAndReplaceEditing"), n3 = e4.state;
            t4.on("findNext", (t5, e5) => {
              e5 ? (n3.searchText = e5.searchText, this.editor.execute("find", e5.searchText, e5)) : this.editor.execute("findNext");
            }), t4.on("findPrevious", (t5, e5) => {
              e5 && n3.searchText !== e5.searchText ? this.editor.execute("find", e5.searchText) : this.editor.execute("findPrevious");
            }), t4.on("replace", (t5, e5) => {
              n3.searchText !== e5.searchText && this.editor.execute("find", e5.searchText);
              const i3 = n3.highlightedResult;
              i3 && this.editor.execute("replace", e5.replaceText, i3);
            }), t4.on("replaceAll", (t5, e5) => {
              n3.searchText !== e5.searchText && this.editor.execute("find", e5.searchText), this.editor.execute("replaceAll", e5.replaceText, n3.results);
            }), t4.on("searchReseted", () => {
              n3.clear(this.editor.model), e4.stop();
            });
          }
        }, class extends bs {
          static get requires() {
            return [IA, BA];
          }
          static get pluginName() {
            return "FontBackgroundColor";
          }
        }, class extends bs {
          static get requires() {
            return [EA, SA];
          }
          static get pluginName() {
            return "FontColor";
          }
        }, class extends bs {
          static get pluginName() {
            return "GeneralHtmlSupport";
          }
          static get requires() {
            return [L_, V_, j_, H_, G_, W_, q_, $_, K_, Z_, J_];
          }
          init() {
            const t4 = this.editor, e4 = t4.plugins.get(L_);
            e4.loadAllowedEmptyElementsConfig(t4.config.get("htmlSupport.allowEmpty") || []), e4.loadAllowedConfig(t4.config.get("htmlSupport.allow") || []), e4.loadDisallowedConfig(t4.config.get("htmlSupport.disallow") || []);
          }
          getGhsAttributeNameForElement(t4) {
            const e4 = this.editor.plugins.get("DataSchema"), n3 = Array.from(e4.getDefinitionsForView(t4, false)), i3 = n3.find((t5) => t5.isInline && !n3[0].isObject);
            return i3 ? i3.model : h_(t4);
          }
          addModelHtmlClass(t4, e4, n3) {
            const i3 = this.editor.model, o3 = this.getGhsAttributeNameForElement(t4);
            i3.change((t5) => {
              for (const r3 of X_(i3, n3, o3))
                d_(t5, r3, o3, "classes", (t6) => {
                  for (const n4 of yo2(e4))
                    t6.add(n4);
                });
            });
          }
          removeModelHtmlClass(t4, e4, n3) {
            const i3 = this.editor.model, o3 = this.getGhsAttributeNameForElement(t4);
            i3.change((t5) => {
              for (const r3 of X_(i3, n3, o3))
                d_(t5, r3, o3, "classes", (t6) => {
                  for (const n4 of yo2(e4))
                    t6.delete(n4);
                });
            });
          }
          setModelHtmlAttributes(t4, e4, n3) {
            const i3 = this.editor.model, o3 = this.getGhsAttributeNameForElement(t4);
            i3.change((t5) => {
              for (const r3 of X_(i3, n3, o3))
                d_(t5, r3, o3, "attributes", (t6) => {
                  for (const [n4, i4] of Object.entries(e4))
                    t6.set(n4, i4);
                });
            });
          }
          removeModelHtmlAttributes(t4, e4, n3) {
            const i3 = this.editor.model, o3 = this.getGhsAttributeNameForElement(t4);
            i3.change((t5) => {
              for (const r3 of X_(i3, n3, o3))
                d_(t5, r3, o3, "attributes", (t6) => {
                  for (const n4 of yo2(e4))
                    t6.delete(n4);
                });
            });
          }
          setModelHtmlStyles(t4, e4, n3) {
            const i3 = this.editor.model, o3 = this.getGhsAttributeNameForElement(t4);
            i3.change((t5) => {
              for (const r3 of X_(i3, n3, o3))
                d_(t5, r3, o3, "styles", (t6) => {
                  for (const [n4, i4] of Object.entries(e4))
                    t6.set(n4, i4);
                });
            });
          }
          removeModelHtmlStyles(t4, e4, n3) {
            const i3 = this.editor.model, o3 = this.getGhsAttributeNameForElement(t4);
            i3.change((t5) => {
              for (const r3 of X_(i3, n3, o3))
                d_(t5, r3, o3, "styles", (t6) => {
                  for (const n4 of yo2(e4))
                    t6.delete(n4);
                });
            });
          }
        }, class extends bs {
          static get requires() {
            return [FA, HA];
          }
          static get pluginName() {
            return "Heading";
          }
        }, class extends bs {
          static get requires() {
            return [GA, $A];
          }
          static get pluginName() {
            return "Highlight";
          }
        }, class extends bs {
          static get requires() {
            return [JA, XA, lw];
          }
          static get pluginName() {
            return "HorizontalLine";
          }
        }, class extends bs {
          static get pluginName() {
            return "HtmlComment";
          }
          init() {
            const t4 = this.editor, e4 = /* @__PURE__ */ new Map();
            t4.data.processor.skipComments = false, t4.model.schema.addAttributeCheck((t5, e5) => {
              if (t5.endsWith("$root") && e5.startsWith("$comment"))
                return true;
            }), t4.conversion.for("upcast").elementToMarker({ view: "$comment", model: (t5) => {
              const n3 = `$comment:${k2()}`, i3 = t5.getCustomProperty("$rawContent");
              return e4.set(n3, i3), n3;
            } }), t4.conversion.for("dataDowncast").markerToElement({ model: "$comment", view: (t5, { writer: e5 }) => {
              let n3;
              for (const e6 of this.editor.model.document.getRootNames())
                if (n3 = this.editor.model.document.getRoot(e6), n3.hasAttribute(t5.markerName))
                  break;
              const i3 = t5.markerName, o3 = n3.getAttribute(i3), r3 = e5.createUIElement("$comment");
              return e5.setCustomProperty("$rawContent", o3, r3), r3;
            } }), t4.model.document.registerPostFixer((n3) => {
              let i3 = false;
              const o3 = t4.model.document.differ.getChangedMarkers().filter((t5) => t5.name.startsWith("$comment:"));
              for (const t5 of o3) {
                const { oldRange: o4, newRange: r3 } = t5.data;
                if (!o4 || !r3 || o4.root != r3.root) {
                  if (o4) {
                    const e5 = o4.root;
                    e5.hasAttribute(t5.name) && (n3.removeAttribute(t5.name, e5), i3 = true);
                  }
                  if (r3) {
                    const o5 = r3.root;
                    "$graveyard" == o5.rootName ? (n3.removeMarker(t5.name), i3 = true) : o5.hasAttribute(t5.name) || (n3.setAttribute(t5.name, e4.get(t5.name) || "", o5), i3 = true);
                  }
                }
              }
              return i3;
            }), t4.data.on("set", () => {
              for (const e5 of t4.model.markers.getMarkersGroup("$comment"))
                this.removeHtmlComment(e5.name);
            }, { priority: "high" }), t4.model.on("deleteContent", (e5, [n3]) => {
              for (const e6 of n3.getRanges()) {
                const n4 = t4.model.schema.getLimitElement(e6), i3 = t4.model.createPositionAt(n4, 0), o3 = t4.model.createPositionAt(n4, "end");
                let r3;
                r3 = i3.isTouching(e6.start) && o3.isTouching(e6.end) ? this.getHtmlCommentsInRange(t4.model.createRange(i3, o3)) : this.getHtmlCommentsInRange(e6, { skipBoundaries: true });
                for (const t5 of r3)
                  this.removeHtmlComment(t5);
              }
            }, { priority: "high" });
          }
          createHtmlComment(t4, e4) {
            const n3 = k2(), i3 = this.editor.model, o3 = i3.document.getRoot(t4.root.rootName), r3 = `$comment:${n3}`;
            return i3.change((n4) => {
              const i4 = n4.createRange(t4);
              return n4.addMarker(r3, { usingOperation: true, affectsData: true, range: i4 }), n4.setAttribute(r3, e4, o3), r3;
            });
          }
          removeHtmlComment(t4) {
            const e4 = this.editor, n3 = e4.model.markers.get(t4);
            return !!n3 && (e4.model.change((t5) => {
              t5.removeMarker(n3);
            }), true);
          }
          getHtmlCommentData(t4) {
            const e4 = this.editor.model.markers.get(t4);
            if (!e4)
              return null;
            let n3 = "";
            for (const e5 of this.editor.model.document.getRoots())
              if (e5.hasAttribute(t4)) {
                n3 = e5.getAttribute(t4);
                break;
              }
            return { content: n3, position: e4.getStart() };
          }
          getHtmlCommentsInRange(t4, { skipBoundaries: e4 = false } = {}) {
            const n3 = !e4;
            return Array.from(this.editor.model.markers.getMarkersGroup("$comment")).filter((e5) => function(t5, e6) {
              const i3 = t5.getRange().start;
              return (i3.isAfter(e6.start) || n3 && i3.isEqual(e6.start)) && (i3.isBefore(e6.end) || n3 && i3.isEqual(e6.end));
            }(e5, t4)).map((t5) => t5.name);
          }
        }, class extends bs {
          static get requires() {
            return [oC, sC, lw];
          }
          static get pluginName() {
            return "HtmlEmbed";
          }
        }, class extends bs {
          static get requires() {
            return [Bv, Nv];
          }
          static get pluginName() {
            return "Image";
          }
        }, class extends bs {
          static get requires() {
            return [Pv, Rv];
          }
          static get pluginName() {
            return "ImageCaption";
          }
        }, class extends bs {
          static get requires() {
            return [fy, Cy, by];
          }
          static get pluginName() {
            return "ImageResize";
          }
        }, class extends bs {
          static get requires() {
            return [Oy, jy];
          }
          static get pluginName() {
            return "ImageStyle";
          }
        }, class extends bs {
          static get requires() {
            return [hw, sv];
          }
          static get pluginName() {
            return "ImageToolbar";
          }
          afterInit() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.plugins.get(hw), i3 = t4.plugins.get("ImageUtils");
            var o3;
            n3.register("image", { ariaLabel: e4("Image toolbar"), items: (o3 = t4.config.get("image.toolbar") || [], o3.map((t5) => F2(t5) ? t5.name : t5)), getRelatedElement: (t5) => i3.getClosestSelectedImageWidget(t5) });
          }
        }, class extends bs {
          static get pluginName() {
            return "ImageUpload";
          }
          static get requires() {
            return [ly, Zv, ny];
          }
        }, class extends bs {
          static get pluginName() {
            return "Indent";
          }
          static get requires() {
            return [Wy, Ky];
          }
        }, class extends bs {
          constructor(t4) {
            super(t4), t4.config.define("indentBlock", { offset: 40, unit: "px" });
          }
          static get pluginName() {
            return "IndentBlock";
          }
          init() {
            const t4 = this.editor, e4 = t4.config.get("indentBlock");
            e4.classes && e4.classes.length ? (this._setupConversionUsingClasses(e4.classes), t4.commands.add("indentBlock", new Zy(t4, new Qy({ direction: "forward", classes: e4.classes }))), t4.commands.add("outdentBlock", new Zy(t4, new Qy({ direction: "backward", classes: e4.classes })))) : (t4.data.addStyleProcessorRules(xg2), this._setupConversionUsingOffset(), t4.commands.add("indentBlock", new Zy(t4, new Yy({ direction: "forward", offset: e4.offset, unit: e4.unit }))), t4.commands.add("outdentBlock", new Zy(t4, new Yy({ direction: "backward", offset: e4.offset, unit: e4.unit }))));
          }
          afterInit() {
            const t4 = this.editor, e4 = t4.model.schema, n3 = t4.commands.get("indent"), i3 = t4.commands.get("outdent"), o3 = t4.config.get("heading.options");
            (o3 && o3.map((t5) => t5.model) || Jy).forEach((t5) => {
              e4.isRegistered(t5) && e4.extend(t5, { allowAttributes: "blockIndent" });
            }), e4.setAttributeProperties("blockIndent", { isFormatting: true }), n3.registerChildCommand(t4.commands.get("indentBlock")), i3.registerChildCommand(t4.commands.get("outdentBlock"));
          }
          _setupConversionUsingOffset() {
            const t4 = this.editor.conversion, e4 = "rtl" === this.editor.locale.contentLanguageDirection ? "margin-right" : "margin-left";
            t4.for("upcast").attributeToAttribute({ view: { styles: { [e4]: /[\s\S]+/ } }, model: { key: "blockIndent", value: (t5) => {
              if (!t5.is("element", "li"))
                return t5.getStyle(e4);
            } } }), t4.for("downcast").attributeToAttribute({ model: "blockIndent", view: (t5) => ({ key: "style", value: { [e4]: t5 } }) });
          }
          _setupConversionUsingClasses(t4) {
            const e4 = { model: { key: "blockIndent", values: [] }, view: {} };
            for (const n3 of t4)
              e4.model.values.push(n3), e4.view[n3] = { key: "class", value: [n3] };
            this.editor.conversion.attributeToAttribute(e4);
          }
        }, class extends bs {
          static get requires() {
            return [Dk2, Tk2];
          }
          static get pluginName() {
            return "Italic";
          }
        }, class extends bs {
          static get requires() {
            return [vx, zx, Ox];
          }
          static get pluginName() {
            return "Link";
          }
        }, class extends bs {
          static get requires() {
            return [Vx, Ux];
          }
          static get pluginName() {
            return "LinkImage";
          }
        }, class extends bs {
          static get requires() {
            return [zE, sE];
          }
          static get pluginName() {
            return "List";
          }
        }, class extends bs {
          static get requires() {
            return [KE, tD, YE, lw];
          }
          static get pluginName() {
            return "MediaEmbed";
          }
        }, class extends bs {
          toMentionAttribute(t4, e4) {
            return sD(t4, e4);
          }
          static get pluginName() {
            return "Mention";
          }
          static get requires() {
            return [oD, bD];
          }
        }, zA, class extends bs {
          static get pluginName() {
            return "PasteFromOffice";
          }
          static get requires() {
            return [Nb2];
          }
          init() {
            const t4 = this.editor, e4 = t4.plugins.get("ClipboardPipeline"), n3 = t4.editing.view.document, i3 = [];
            i3.push(new zD(n3)), i3.push(new FD(n3)), i3.push(new jD(n3)), e4.on("inputTransformation", (e5, o3) => {
              if (o3._isTransformedWithPasteFromOffice)
                return;
              if (t4.model.document.selection.getFirstPosition().parent.is("element", "codeBlock"))
                return;
              const r3 = o3.dataTransfer.getData("text/html"), s3 = i3.find((t5) => t5.isActive(r3));
              s3 && (o3._parsedData || (o3._parsedData = UD(r3, n3.stylesProcessor)), s3.execute(o3), o3._isTransformedWithPasteFromOffice = true);
            }, { priority: "high" });
          }
        }, class extends bs {
          static get requires() {
            return [$D, WD];
          }
          static get pluginName() {
            return "RemoveFormat";
          }
        }, Uw, class extends bs {
          static get requires() {
            return [jv];
          }
          static get pluginName() {
            return "SimpleUploadAdapter";
          }
          init() {
            const t4 = this.editor.config.get("simpleUpload");
            t4 && (t4.uploadUrl ? this.editor.plugins.get(jv).createUploadAdapter = (e4) => new Wv(e4, t4) : _2("simple-upload-adapter-missing-uploadurl"));
          }
        }, class extends bs {
          static get pluginName() {
            return "SourceEditing";
          }
          static get requires() {
            return [Mg2];
          }
          constructor(t4) {
            super(t4), this.set("isSourceEditingMode", false), this._elementReplacer = new J2(), this._replacedRoots = /* @__PURE__ */ new Map(), this._dataFromRoots = /* @__PURE__ */ new Map();
          }
          init() {
            const t4 = this.editor, e4 = t4.t;
            t4.ui.componentFactory.add("sourceEditing", (n3) => {
              const i3 = new kr(n3);
              return i3.set({ label: e4("Source"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m12.5 0 5 4.5v15.003h-16V0h11zM3 1.5v3.25l-1.497 1-.003 8 1.5 1v3.254L7.685 18l-.001 1.504H17.5V8.002L16 9.428l-.004-4.22-4.222-3.692L3 1.5z"/><path d="M4.06 6.64a.75.75 0 0 1 .958 1.15l-.085.07L2.29 9.75l2.646 1.89c.302.216.4.62.232.951l-.058.095a.75.75 0 0 1-.951.232l-.095-.058-3.5-2.5V9.14l3.496-2.5zm4.194 6.22a.75.75 0 0 1-.958-1.149l.085-.07 2.643-1.89-2.646-1.89a.75.75 0 0 1-.232-.952l.058-.095a.75.75 0 0 1 .95-.232l.096.058 3.5 2.5v1.22l-3.496 2.5zm7.644-.836 2.122 2.122-5.825 5.809-2.125-.005.003-2.116zm2.539-1.847 1.414 1.414a.5.5 0 0 1 0 .707l-1.06 1.06-2.122-2.12 1.061-1.061a.5.5 0 0 1 .707 0z"/></svg>', tooltip: true, withText: true, class: "ck-source-editing-button" }), i3.bind("isOn").to(this, "isSourceEditingMode"), i3.bind("isEnabled").to(this, "isEnabled", t4, "isReadOnly", t4.plugins.get(Mg2), "hasAny", (t5, e5, n4) => !!t5 && (!e5 && !n4)), this.listenTo(i3, "execute", () => {
                this.isSourceEditingMode = !this.isSourceEditingMode;
              }), i3;
            }), this._isAllowedToHandleSourceEditingMode() && (this.on("change:isSourceEditingMode", (t5, e5, n3) => {
              n3 ? (this._showSourceEditing(), this._disableCommands()) : (this._hideSourceEditing(), this._enableCommands());
            }), this.on("change:isEnabled", (t5, e5, n3) => this._handleReadOnlyMode(!n3)), this.listenTo(t4, "change:isReadOnly", (t5, e5, n3) => this._handleReadOnlyMode(n3))), t4.data.on("get", () => {
              this.isSourceEditingMode && this.updateEditorData();
            }, { priority: "high" });
          }
          afterInit() {
            const t4 = this.editor;
            ["RealTimeCollaborativeEditing", "CommentsEditing", "TrackChangesEditing", "RevisionHistory"].some((e4) => t4.plugins.has(e4)) && console.warn("You initialized the editor with the source editing feature and at least one of the collaboration features. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the collaboration features."), t4.plugins.has("RestrictedEditingModeEditing") && console.warn("You initialized the editor with the source editing feature and restricted editing feature. Please be advised that the source editing feature may not work, and be careful when editing document source that contains markers created by the restricted editing feature.");
          }
          updateEditorData() {
            const t4 = this.editor, e4 = {};
            for (const [t5, n3] of this._replacedRoots) {
              const i3 = this._dataFromRoots.get(t5), o3 = n3.dataset.value;
              i3 !== o3 && (e4[t5] = o3, this._dataFromRoots.set(t5, o3));
            }
            Object.keys(e4).length && t4.data.set(e4, { batchType: { isUndoable: true } });
          }
          _showSourceEditing() {
            const t4 = this.editor, e4 = t4.editing.view, n3 = t4.model;
            n3.change((t5) => {
              t5.setSelection(null), t5.removeSelectionAttribute(n3.document.selection.getAttributeKeys());
            });
            for (const [n4, i3] of e4.domRoots) {
              const o3 = oS(t4.data.get({ rootName: n4 })), r3 = bt2(i3.ownerDocument, "textarea", { rows: "1", "aria-label": "Source code editing area" }), s3 = bt2(i3.ownerDocument, "div", { class: "ck-source-editing-area", "data-value": o3 }, [r3]);
              r3.value = o3, r3.setSelectionRange(0, 0), r3.addEventListener("input", () => {
                s3.dataset.value = r3.value, t4.ui.update();
              }), e4.change((t5) => {
                const i4 = e4.document.getRoot(n4);
                t5.addClass("ck-hidden", i4);
              }), t4.ui.setEditableElement("sourceEditing:" + n4, r3), this._replacedRoots.set(n4, s3), this._elementReplacer.replace(i3, s3), this._dataFromRoots.set(n4, o3);
            }
            this._focusSourceEditing();
          }
          _hideSourceEditing() {
            const t4 = this.editor.editing.view;
            this.updateEditorData(), t4.change((e4) => {
              for (const [n3] of this._replacedRoots)
                e4.removeClass("ck-hidden", t4.document.getRoot(n3));
            }), this._elementReplacer.restore(), this._replacedRoots.clear(), this._dataFromRoots.clear(), t4.focus();
          }
          _focusSourceEditing() {
            const t4 = this.editor, [e4] = this._replacedRoots.values(), n3 = e4.querySelector("textarea");
            t4.editing.view.document.isFocused = false, n3.focus();
          }
          _disableCommands() {
            const t4 = this.editor;
            for (const e4 of t4.commands.commands())
              e4.forceDisabled(iS);
          }
          _enableCommands() {
            const t4 = this.editor;
            for (const e4 of t4.commands.commands())
              e4.clearForceDisabled(iS);
          }
          _handleReadOnlyMode(t4) {
            if (this.isSourceEditingMode)
              for (const [, e4] of this._replacedRoots)
                e4.querySelector("textarea").readOnly = t4;
          }
          _isAllowedToHandleSourceEditingMode() {
            const t4 = this.editor.ui.view.editable;
            return t4 && !t4.hasExternalElement;
          }
        }, class extends bs {
          static get requires() {
            return [nk2];
          }
          static get pluginName() {
            return "SpecialCharacters";
          }
          constructor(t4) {
            super(t4);
            const e4 = t4.t;
            this._characters = /* @__PURE__ */ new Map(), this._groups = /* @__PURE__ */ new Map(), this._allSpecialCharactersGroupLabel = e4("All");
          }
          init() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.commands.get("insertText");
            t4.ui.componentFactory.add("specialCharacters", (i3) => {
              const o3 = om(i3);
              let r3;
              return o3.buttonView.set({ label: e4("Special characters"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2.5a7.47 7.47 0 0 1 4.231 1.31 7.268 7.268 0 0 1 2.703 3.454 7.128 7.128 0 0 1 .199 4.353c-.39 1.436-1.475 2.72-2.633 3.677h2.013c0-.226.092-.443.254-.603a.876.876 0 0 1 1.229 0c.163.16.254.377.254.603v.853c0 .209-.078.41-.22.567a.873.873 0 0 1-.547.28l-.101.006h-4.695a.517.517 0 0 1-.516-.518v-1.265c0-.21.128-.398.317-.489a5.601 5.601 0 0 0 2.492-2.371 5.459 5.459 0 0 0 .552-3.693 5.53 5.53 0 0 0-1.955-3.2A5.71 5.71 0 0 0 10 4.206 5.708 5.708 0 0 0 6.419 5.46 5.527 5.527 0 0 0 4.46 8.663a5.457 5.457 0 0 0 .554 3.695 5.6 5.6 0 0 0 2.497 2.37.55.55 0 0 1 .317.49v1.264c0 .286-.23.518-.516.518H2.618a.877.877 0 0 1-.614-.25.845.845 0 0 1-.254-.603v-.853c0-.226.091-.443.254-.603a.876.876 0 0 1 1.228 0c.163.16.255.377.255.603h1.925c-1.158-.958-2.155-2.241-2.545-3.678a7.128 7.128 0 0 1 .199-4.352 7.268 7.268 0 0 1 2.703-3.455A7.475 7.475 0 0 1 10 2.5z"/></svg>', tooltip: true }), o3.bind("isEnabled").to(n3), o3.on("execute", (e5, n4) => {
                t4.execute("insertText", { text: n4.character }), t4.editing.view.focus();
              }), o3.on("change:isOpen", () => {
                if (!r3) {
                  r3 = this._createDropdownPanelContent(i3, o3);
                  const t5 = new gS(i3, r3.navigationView, r3.gridView, r3.infoView);
                  o3.panelView.children.add(t5);
                }
                r3.infoView.set({ character: null, name: null });
              }), o3;
            });
          }
          addItems(t4, e4, n3 = { label: t4 }) {
            if (t4 === fS)
              throw new C2("special-character-invalid-group-name", null);
            const i3 = this._getGroup(t4, n3.label);
            for (const t5 of e4)
              i3.items.add(t5.title), this._characters.set(t5.title, t5.character);
          }
          getGroups() {
            const t4 = Array.from(this._groups.keys()), e4 = this.editor.config.get("specialCharacters.order") || [], n3 = e4.find((e5) => !t4.includes(e5));
            if (n3)
              throw new C2("special-character-invalid-order-group-name", null, { invalidGroup: n3 });
            return /* @__PURE__ */ new Set([...e4, ...t4]);
          }
          getCharactersForGroup(t4) {
            if (t4 === fS)
              return new Set(this._characters.keys());
            const e4 = this._groups.get(t4);
            return e4 ? e4.items : void 0;
          }
          getCharacter(t4) {
            return this._characters.get(t4);
          }
          _getGroup(t4, e4) {
            return this._groups.has(t4) || this._groups.set(t4, { items: /* @__PURE__ */ new Set(), label: e4 }), this._groups.get(t4);
          }
          _updateGrid(t4, e4) {
            e4.tiles.clear();
            const n3 = this.getCharactersForGroup(t4);
            for (const t5 of n3) {
              const n4 = this.getCharacter(t5);
              e4.tiles.add(e4.createTile(n4, t5));
            }
          }
          _createDropdownPanelContent(t4, e4) {
            const n3 = Array.from(this.getGroups()).map((t5) => [t5, this._groups.get(t5).label]), i3 = new Map([[fS, this._allSpecialCharactersGroupLabel], ...n3]), o3 = new rS(t4, i3), r3 = new cS(t4), s3 = new hS(t4);
            return r3.delegate("execute").to(e4), r3.on("tileHover", (t5, e5) => {
              s3.set(e5);
            }), r3.on("tileFocus", (t5, e5) => {
              s3.set(e5);
            }), o3.on("execute", () => {
              this._updateGrid(o3.currentGroupName, r3);
            }), this._updateGrid(o3.currentGroupName, r3), { navigationView: o3, gridView: r3, infoView: s3 };
          }
        }, kS, CS, class extends bs {
          static get pluginName() {
            return "SpecialCharactersEssentials";
          }
          static get requires() {
            return [CS, bS, wS, kS, AS];
          }
        }, AS, wS, bS, class extends bs {
          static get pluginName() {
            return "StandardEditingMode";
          }
          static get requires() {
            return [QD, JD];
          }
        }, class extends bs {
          static get requires() {
            return [Bk2, Nk2];
          }
          static get pluginName() {
            return "Strikethrough";
          }
        }, class extends bs {
          static get pluginName() {
            return "Style";
          }
          static get requires() {
            return [GS, RS];
          }
        }, class extends bs {
          static get requires() {
            return [zk2, Rk2];
          }
          static get pluginName() {
            return "Subscript";
          }
        }, class extends bs {
          static get requires() {
            return [Fk2, jk2];
          }
          static get pluginName() {
            return "Superscript";
          }
        }, class extends bs {
          static get requires() {
            return [gI, bI, _I, TI, DI, vI, lw];
          }
          static get pluginName() {
            return "Table";
          }
        }, class extends bs {
          static get pluginName() {
            return "TableCaption";
          }
          static get requires() {
            return [sM, aM];
          }
        }, class extends bs {
          static get pluginName() {
            return "TableCellProperties";
          }
          static get requires() {
            return [zB, CB];
          }
        }, class extends bs {
          static get requires() {
            return [uM, yB];
          }
          static get pluginName() {
            return "TableColumnResize";
          }
        }, class extends bs {
          static get pluginName() {
            return "TableProperties";
          }
          static get requires() {
            return [qB, tM];
          }
        }, class extends bs {
          static get requires() {
            return [hw];
          }
          static get pluginName() {
            return "TableToolbar";
          }
          afterInit() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.plugins.get(hw), i3 = t4.config.get("table.contentToolbar"), o3 = t4.config.get("table.tableToolbar");
            i3 && n3.register("tableContent", { ariaLabel: e4("Table toolbar"), items: i3, getRelatedElement: zI }), o3 && n3.register("table", { ariaLabel: e4("Table toolbar"), items: o3, getRelatedElement: LI });
          }
        }, class extends bs {
          static get requires() {
            return [ex, nx];
          }
          static get pluginName() {
            return "TextPartLanguage";
          }
        }, class extends bs {
          static get requires() {
            return ["Delete", "Input"];
          }
          static get pluginName() {
            return "TextTransformation";
          }
          constructor(t4) {
            super(t4), t4.config.define("typing", { transformations: { include: uk2 } });
          }
          init() {
            const t4 = this.editor.model.document.selection;
            t4.on("change:range", () => {
              this.isEnabled = !t4.anchor.parent.is("element", "codeBlock");
            }), this._enableTransformationWatchers();
          }
          _enableTransformationWatchers() {
            const t4 = this.editor, e4 = t4.model, n3 = t4.plugins.get("Delete"), i3 = function(t5) {
              const e5 = t5.extra || [], n4 = t5.remove || [], i4 = (t6) => !n4.includes(t6);
              return function(t6) {
                const e6 = /* @__PURE__ */ new Set();
                for (const n5 of t6)
                  if ("string" == typeof n5 && hk2[n5])
                    for (const t7 of hk2[n5])
                      e6.add(t7);
                  else
                    e6.add(n5);
                return Array.from(e6);
              }(t5.include.concat(e5).filter(i4)).filter(i4).map((t6) => "string" == typeof t6 && dk2[t6] ? dk2[t6] : t6).filter((t6) => "object" == typeof t6).map((t6) => ({ from: gk2(t6.from), to: mk2(t6.to) }));
            }(t4.config.get("typing.transformations")), o3 = new ok2(t4.model, (t5) => {
              for (const e5 of i3) {
                if (e5.from.test(t5))
                  return { normalizedTransformation: e5 };
              }
            });
            o3.on("matched:data", (t5, i4) => {
              if (!i4.batch.isTyping)
                return;
              const { from: o4, to: r3 } = i4.normalizedTransformation, s3 = o4.exec(i4.text), a3 = r3(s3.slice(1)), c3 = i4.range;
              let l3 = s3.index;
              e4.enqueueChange((t6) => {
                for (let n4 = 1; n4 < s3.length; n4++) {
                  const i5 = s3[n4], o5 = a3[n4 - 1];
                  if (null == o5) {
                    l3 += i5.length;
                    continue;
                  }
                  const r4 = c3.start.getShiftedBy(l3), d3 = e4.createRange(r4, r4.getShiftedBy(i5.length)), h3 = pk2(r4);
                  e4.insertContent(t6.createText(o5, h3), d3), l3 += o5.length;
                }
                e4.enqueueChange(() => {
                  n3.requestUndoOnBackspace();
                });
              });
            }), o3.bind("isEnabled").to(this);
          }
        }, class extends bs {
          static get requires() {
            return [Uk2, Wk2];
          }
          static get pluginName() {
            return "Underline";
          }
        }, class extends bs {
          constructor(t4) {
            super(t4), this.set("characters", 0), this.set("words", 0), Object.defineProperties(this, { characters: { get() {
              return this.characters = this._getCharacters(this._getText());
            } }, words: { get() {
              return this.words = this._getWords(this._getText());
            } } }), this.set("_wordsLabel", void 0), this.set("_charactersLabel", void 0), this._config = t4.config.get("wordCount") || {}, this._outputView = void 0, this._wordsMatchRegExp = c2.features.isRegExpUnicodePropertySupported ? new RegExp("([\\p{L}\\p{N}]+\\S?)+", "gu") : /([a-zA-Z0-9-]+\S?)+/gu;
          }
          static get pluginName() {
            return "WordCount";
          }
          init() {
            this.editor.model.document.on("change:data", kp(this._refreshStats.bind(this), 250)), "function" == typeof this._config.onUpdate && this.on("update", (t4, e4) => {
              this._config.onUpdate(e4);
            }), vi2(this._config.container) && this._config.container.appendChild(this.wordCountContainer);
          }
          destroy() {
            this._outputView && (this._outputView.element.remove(), this._outputView.destroy()), super.destroy();
          }
          get wordCountContainer() {
            const t4 = this.editor, e4 = t4.t, n3 = t4.config.get("wordCount.displayWords"), i3 = t4.config.get("wordCount.displayCharacters"), o3 = Uo2.bind(this, this), r3 = [];
            return this._outputView || (this._outputView = new Ho2(), (n3 || void 0 === n3) && (this.bind("_wordsLabel").to(this, "words", (t5) => e4("Words: %0", t5)), r3.push({ tag: "div", children: [{ text: [o3.to("_wordsLabel")] }], attributes: { class: "ck-word-count__words" } })), (i3 || void 0 === i3) && (this.bind("_charactersLabel").to(this, "characters", (t5) => e4("Characters: %0", t5)), r3.push({ tag: "div", children: [{ text: [o3.to("_charactersLabel")] }], attributes: { class: "ck-word-count__characters" } })), this._outputView.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-word-count"] }, children: r3 }), this._outputView.render()), this._outputView.element;
          }
          _getText() {
            let t4 = "";
            for (const e4 of this.editor.model.document.getRoots())
              "" !== t4 && (t4 += "\n"), t4 += pM(e4);
            return t4;
          }
          _getCharacters(t4) {
            return t4.replace(/\n/g, "").length;
          }
          _getWords(t4) {
            return (t4.match(this._wordsMatchRegExp) || []).length;
          }
          _refreshStats() {
            const t4 = this._getText(), e4 = this.words = this._getWords(t4), n3 = this.characters = this._getCharacters(t4);
            this.fire("update", { words: e4, characters: n3 });
          }
        }], fM.defaultConfig = { toolbar: { items: ["undo", "redo", "|", "heading", "|", "bold", "italic", "underline", "strikethrough", "removeFormat", "link", "|", "bulletedList", "numberedList", "|", "imageUpload", "mediaEmbed", "|", "insertTable", "blockQuote", "horizontalLine", "|", "specialCharacters", "superscript", "|", "findAndReplace"] }, language: "ru", image: { toolbar: ["imageTextAlternative", "toggleImageCaption", "imageStyle:inline", "imageStyle:block", "imageStyle:side", "linkImage"] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells", "tableCellProperties", "tableProperties"] } };
        const kM = { Editor: fM, EditorWatchdog: If2 };
      })(), i2 = i2.default;
    })());
    const __CJS__export_default__ = (module.exports == null ? {} : module.exports).default || module.exports;
    (module.exports == null ? {} : module.exports).CKSource;
    const CkEditorContainer = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  margin-bottom: 25px;
`;
    function CkEditor({ onChange, data = "" }) {
      const [editor2, setEditor] = reactExports.useState(data);
      const { token: token2 } = useTypedSelector((state) => state.auth);
      reactExports.useEffect(() => {
        setEditor(data);
      }, [data]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditorContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        distExports.CKEditor,
        {
          editor: __CJS__export_default__.Editor,
          data: editor2,
          config: {
            // removePlugins: ['ImageInsert', 'AutoFormat', 'Markdown', 'MediaEmbedToolbar'],
            simpleUpload: {
              uploadUrl: "/api/course/upload-temp-image",
              headers: {
                "X-CSRF-Token": token2 || ""
              }
            },
            mediaEmbed: {
              previewsInData: true
            }
          },
          onReady: (editor22) => {
            console.log("Editor is ready to use!");
          },
          onChange: (event, editor22) => {
            setEditor(editor22.getData());
            onChange(editor22.getData());
          },
          onBlur: (event, editor22) => {
            setEditor(editor22.getData());
            onChange(editor22.getData());
          },
          onError: (error) => console.error("Error in CkEditor:", error)
        }
      ) });
    }
    let editor$1;
    function CreateLessonForm({ type }) {
      const { themeId, courseId, chapterId, lessonId } = useParams();
      const { data, isError, isFetching } = useGetLessonByIdQuery(`${lessonId}`, {
        skip: !lessonId
      });
      const tests = useTypedSelector((state) => state.lesson.tests);
      const { addEmptyTest, setTestsData, setLoaderActive, resetTestsData } = useActions();
      const [createLesson] = useCreateLessonMutation();
      const [updateLesson] = useUpdateLessonMutation();
      const [lessonName, setLessonName] = reactExports.useState("");
      const [isValidName, setValidName] = reactExports.useState(false);
      const [isChangedName, setChangedName] = reactExports.useState(false);
      const navigation = useNavigate();
      const [ckEditorData, setCkEditorData] = reactExports.useState("");
      reactExports.useEffect(() => {
        if (data) {
          setLessonName(data.data.title);
          setValidName(true);
          setChangedName(false);
          setTestsData(data.data.tests);
        }
        return () => {
          resetTestsData();
        };
      }, [data, isError, isFetching, resetTestsData, setTestsData]);
      reactExports.useEffect(() => {
        if (!editor$1 && !isFetching && !data) {
          try {
            editor$1 = new vi({
              holder: "editorjs",
              tools: EDITOR_JS_TOOLS,
              i18n: EDITOR_INTERNATIONALIZATION_CONFIG,
              inlineToolbar: true
            });
          } catch (e2) {
            console.error(e2);
          }
        }
        return () => {
          if (editor$1) {
            try {
              editor$1.destroy();
            } catch (err) {
              console.log(err);
            }
            editor$1 = void 0;
          }
        };
      }, [data, isFetching]);
      const testsDataWithoutFrontIds = reactExports.useMemo(() => {
        return tests.map((test) => {
          const { id: id2, answers, ...rest } = test;
          const clearAnswers = answers.map((answer) => {
            const { id: id22, ...rest2 } = answer;
            if (id22.length === 21 && typeof id22 === "string") {
              return rest2;
            }
            return answer;
          });
          if (id2.length === 21 && typeof id2 === "string") {
            return {
              ...rest,
              answers: clearAnswers
            };
          }
          return {
            ...rest,
            answers: clearAnswers,
            id: id2
          };
        });
      }, [tests]);
      const handleChange = (event) => {
        setValidName(event.target.value.length > 1);
        setLessonName(event.target.value);
        if (!isChangedName) {
          setChangedName(true);
        }
      };
      const handleConfirm = async () => {
        if (!isValidName) {
          setChangedName(true);
          return;
        }
        if (type === "edit") {
          updateLesson({
            id: Number(lessonId),
            theme_id: Number(data == null ? void 0 : data.data.theme_id),
            title: lessonName,
            description: ckEditorData || "",
            tests: testsDataWithoutFrontIds
          }).then((res) => {
            if ("data" in res) {
              navigation(`/courses/${courseId}/${chapterId}/${themeId}/${res.data.data.id}`);
            }
          }).catch((error) => {
            console.error(error);
          });
          setLoaderActive(true);
          return;
        }
        createLesson({
          title: lessonName,
          theme_id: Number(themeId),
          description: ckEditorData || "",
          tests: testsDataWithoutFrontIds
        }).then((res) => {
          if ("data" in res && res.data.result) {
            navigation(`/courses/${courseId}/${chapterId}/${themeId}/${res.data.data.id}`);
          }
        }).catch((error) => {
          console.error(error);
        });
        setLoaderActive(true);
      };
      const controlsData = {
        names: {
          confirm: type === "create" ? " " : "",
          cancel: ""
        },
        handlers: {
          confirm: handleConfirm,
          cancel: () => {
            navigation(`/courses/${courseId}/${chapterId}/${themeId}`);
          }
        }
      };
      const handleAddEmptyTest = () => {
        addEmptyTest();
      };
      const handleSetCkEditorData = (data2) => {
        setCkEditorData(data2);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$4, { children: type === "create" ? " " : " " }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          LessonNameInput,
          {
            $isValid: isValidName,
            $isChanged: isChangedName,
            value: lessonName,
            onChange: handleChange,
            type: "text",
            placeholder: "   ()"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditor, { onChange: handleSetCkEditorData, data: (data == null ? void 0 : data.data.description) || "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TestWrapper, { children: [
          tests.length > 0 && tests.map((test) => /* @__PURE__ */ jsxRuntimeExports.jsx(CreateTestForm, { data: test })),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(AddTest, { onClick: handleAddEmptyTest, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(AddTestIcon, {}),
            " "
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$2, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormControls,
          {
            ...controlsData,
            containerStyles: { padding: "25px 0px 25px" }
          }
        )
      ] });
    }
    const ChangeBodyBg$2 = at$1`
  body {
    background-color: ${(props) => props.theme.colors.realWhite} !important;
  }
`;
    function CreateLesson({ type }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultContainer, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ChangeBodyBg$2, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CreateLessonForm, { type })
      ] }) });
    }
    const crossCategory = "/assets/cross-category.svg";
    const Title$1 = st$1(Text$6)`
  margin-bottom: 20px;
  font-size: 92.5px;
`;
    const NewsNameInput = st$1(InputWithState)`
  margin-bottom: 15px;
`;
    st$1.div`
  width: 100%;
  min-height: 472px;
  padding: 25px;
  padding-left: 75px;
  margin-bottom: 25px;
  border: 1px solid ${(props) => props.theme.colors.greyEO};
  border-radius: ${(props) => props.theme.utils.br};
`;
    st$1.div`
  margin-bottom: 60px;
`;
    const Divider$1 = st$1.div`
  position: relative;
  width: 100%;
  height: 1px;
  &::before {
    content: "";
    position: absolute;
    top: 0;
    left: 50%;
    width: 100vw;
    height: 100%;
    background-color: ${(props) => props.theme.colors.greyF1};
    transform: translateX(-50%);
  }
`;
    st$1.div`
  position: relative;
  margin-bottom: 50px;
`;
    const AddCategory = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  width: fit-content;
  padding: 0 20px;
`;
    const AddIcon = st$1(Icon$2)`
  margin-right: 10px;
  background-image: url(${addIcon});
`;
    const AddCategoryBtn$1 = st$1(DefaultBtn)`
  width: 40px;
  min-height: 40px;
  padding: 0;
  background-image: url(${addIcon});
  background-position: center;
  background-repeat: no-repeat;
`;
    const CategoriesList$1 = st$1(FlexContainer)`
  flex-direction: row;
  flex-wrap: wrap;
  align-items: center;
  gap: 10px 10px;
  margin-bottom: 115px;
`;
    const Category$1 = st$1(FlexContainer)`
  width: unset;
  align-items: center;
  padding: 9px 18px 9px 27px;
  border-radius: 63px;
  background-color: ${(props) => props.theme.colors.greyF1};
`;
    const CategoryText = st$1(Text$6)`
  margin-right: 8px;

  color: ${(props) => props.theme.colors.grey93};
  text-align: center;
  font-size: 18px;
  font-weight: 700;
  line-height: 120%;
`;
    const CategoryImgDelete = st$1(Icon$2)`
  background-image: url(${crossCategory});
  &:hover {
    transform: rotate(180deg);
    transition: transform 0.5s ease;
    cursor: pointer;
  }
`;
    function CreateNewsForm({ type }) {
      const {
        setModalOpen,
        setModalType,
        setNewsCategories,
        setLoaderActive,
        deleteNewsCategory
        // updateNewsCategories
      } = useActions();
      const [createNews] = useCreateNewsMutation();
      const navigate = useNavigate();
      const { newsId } = useParams();
      const [NewsName, setNewsName] = reactExports.useState("");
      const [isValidName, setValidName] = reactExports.useState(false);
      const [isChangedName, setChangedName] = reactExports.useState(false);
      const categories = useTypedSelector((state) => state.news.newsCategories);
      const { data, isFetching } = useGetNewsByIdQuery(Number(newsId), {
        skip: !newsId
      });
      const [updateNews] = useUpdateNewsMutation();
      const [ckEditorData, setCkEditorData] = reactExports.useState("");
      const [isNameCategory, setNameCategory] = reactExports.useState(false);
      reactExports.useEffect(() => {
        if (type === "edit" && data) {
          setNewsName(data.data.title);
          setValidName(true);
          setChangedName(false);
          setNewsCategories(data.data.categories || []);
        }
      }, [data, setNewsCategories, type, isNameCategory]);
      const handleConfirm = async () => {
        if (!isValidName) {
          setChangedName(true);
          return;
        }
        if (type !== "edit") {
          createNews({
            title: NewsName,
            text: ckEditorData || "",
            NewsCategory: categories
          }).then((res) => {
            if ("data" in res && res.data.result) {
              navigate("/news");
            } else {
              alert("    .   !");
            }
          }).catch((err) => {
            setLoaderActive(false);
            console.error(err);
            alert("    .   !");
          });
          setLoaderActive(true);
        }
        if (type === "edit") {
          updateNews({
            id: Number(newsId),
            title: NewsName,
            text: ckEditorData || "",
            NewsCategory: categories
          }).then((res) => {
            if ("data" in res && res.data.result) {
              navigate("/news");
            }
          }).catch((err) => {
            setLoaderActive(false);
            console.error(err);
            alert(
              "    .   !"
            );
          });
          setLoaderActive(true);
        }
      };
      const handleCancel = () => {
        navigate("/news");
      };
      const handleChange = (event) => {
        setValidName(event.target.value.length > 1);
        setNewsName(event.target.value);
        if (!isChangedName) {
          setChangedName(true);
        }
      };
      const handleOpenCategoriesModal = () => {
        setModalType(MODAL_TYPES.newsCategory);
        setModalOpen(true);
      };
      const controlsData = {
        names: {
          confirm: type === "edit" ? "" : " ",
          cancel: ""
        },
        handlers: {
          confirm: handleConfirm,
          cancel: handleCancel
        }
      };
      const handleSetCkEditorData = (data2) => {
        setCkEditorData(data2);
      };
      const handleancelCategori = (category) => {
        deleteNewsCategory({ id: category });
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$1, { children: type === "create" ? " " : " " }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          NewsNameInput,
          {
            $isValid: isValidName,
            $isChanged: isChangedName,
            value: NewsName,
            onChange: handleChange,
            type: "text",
            placeholder: "   ()"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditor, { onChange: handleSetCkEditorData, data: (data == null ? void 0 : data.data.text) || "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CategoriesList$1, { children: [
          categories.length > 0 && categories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Category$1, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CategoryText, { children: category.title }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CategoryImgDelete,
              {
                onClick: () => {
                  if (category.id !== void 0)
                    handleancelCategori(category.id);
                }
              }
            )
          ] })),
          categories.length == 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(AddCategory, { onClick: handleOpenCategoriesModal, children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}),
            " "
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsx(AddCategoryBtn$1, { onClick: handleOpenCategoriesModal })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$1, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormControls,
          {
            ...controlsData,
            containerStyles: { padding: "25px 0px 25px" }
          }
        )
      ] });
    }
    const ChangeBodyBg$1 = at$1`
  body {
    background-color: ${(props) => props.theme.colors.realWhite} !important;
  }
`;
    function CreateNews({ type }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultContainer, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ChangeBodyBg$1, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CreateNewsForm, { type })
      ] });
    }
    const Overlay = st$1(FlexContainer)`
  align-items: center;
  justify-content: center;
  position: fixed;
  z-index: ${(props) => props.theme.utils.zIndex.loading};
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  opacity: ${(props) => props.$state === "exited" || props.$state === "exiting" ? 0 : 1};
  background-color: rgba(0, 0, 0, 0.5);
  transition: opacity .2s ease-in-out;
`;
    const Container$1 = st$1(FlexContainer)`
  align-items: center;
  width: fit-content;
  padding: 18px 24px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
`;
    const Logo = st$1.img`
  width: 30px;
  margin-right: 15px;
`;
    const Text$1 = st$1(Text$6)`
  font-size: 22.714px;
`;
    function Loading({ styles: styles2 = {}, state, innerRef }) {
      const modalRoot = document.getElementById("modal-root");
      if (!modalRoot)
        return;
      return ReactDOM.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Overlay,
          {
            $state: state,
            style: styles2,
            ref: innerRef,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$1, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { src: loadingLogo }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { children: "..." })
            ] })
          }
        ),
        modalRoot
      );
    }
    const bookIcon = "/assets/book.svg";
    const homeIcon = "/assets/Home.svg";
    const Header$1 = st$1.header`
  display: flex;
  align-items: center;
  padding: 3.125vw;
  border-bottom: 1px solid ${(props) => props.theme.colors.greyF1};
  background-color: ${(props) => props.theme.colors.realWhite};
`;
    const OpenNavBtn = st$1(Icon$2)`
  padding: 0;
  margin: 0;
  margin-right: auto;
  background-image: url(${bookIcon});
  background-color: transparent;
`;
    const HomeLink = st$1(Icon$2)`
  background-image: url(${homeIcon});
`;
    function Header() {
      const { setNavPopup } = useActions();
      const navigate = useNavigate();
      const handleOpenNavPopup = () => {
        setNavPopup(true);
      };
      const handleGoHome = () => {
        navigate("/courses");
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header$1, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          OpenNavBtn,
          {
            onClick: handleOpenNavPopup,
            as: "button"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(HomeLink, { onClick: handleGoHome, as: "a" })
      ] });
    }
    const bodyOverflow = at$1`
  body {
    overflow: hidden;
    background-color: ${(props) => props.theme.colors.realWhite};
  }
`;
    function CourseMob() {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(bodyOverflow, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Course, {})
      ] });
    }
    const CategoriesList = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 10px;
  margin-bottom: 20px;
`;
    const AddCategoryBtn = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  justify-content: center;
  width: fit-content;
  padding: 0 20px;
`;
    const AddCategoryIcon = st$1(Icon$2)`
  margin-right: 10px;
  background-image: url(${addIcon});
`;
    const saveIcon = "/assets/Save.svg";
    const Container = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
`;
    const Input$1 = st$1(InputWithState)`
  max-width: 80%;
`;
    const SaveBtn = st$1(Icon$2)`
  padding: 0;
  background-color: transparent;
  background-image: url(${saveIcon});
  &:hover {
    cursor: pointer;
    transform: scale(1.1);
    transition: transform 0.3s ease linear;
  }
`;
    const DeleteBtn = st$1(SaveBtn)`
  background-image: url(${deleteIcon$1});
  &:hover {
    cursor: pointer;
    transform: scale(1.2);
    transition: transform 0.3s ease linear;
  }
`;
    const checkboxIcon = "/assets/checkbox.svg";
    const checkboxIconChecked = "/assets/checkbox-checked.svg";
    const Label = st$1.label`
  display: flex;
  align-items: center;
  cursor: pointer;
`;
    const Input = st$1.input`
  display: none;
`;
    const CustomCheckbox$1 = st$1.div`
  width: 24px;
  height: 24px;
  margin-right: 11px;
  background-image: url(${(props) => props.$checked ? checkboxIconChecked : checkboxIcon});
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;

  ${(props) => {
      if (props.$isRadio) {
        return nt$1`
        position: relative;
        width: 16px;
        height: 16px;
        margin-right: 14px;
        border-radius: 50%;
        position: relative;
        border: 1px solid #333;
        background-image: unset;
      `;
      }
    }}

  &::before {
    content: '';
    display: ${(props) => props.$checked && props.$isRadio ? "block" : "none"};
    position: absolute;
    top: 50%;
    left: 50%;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background-color: #333;
    transform: translate(-50%, -50%);
  }
`;
    const CheckboxDescr = st$1(Text$6)`
line-height100%`;
    function CustomCheckbox({ descr, onChange = () => {
    }, children, checked = false, isRadio = false }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            type: "checkbox",
            onChange,
            checked
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomCheckbox$1,
          {
            $checked: checked,
            $isRadio: isRadio
          }
        ),
        children,
        descr && /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxDescr, { children: descr })
      ] });
    }
    function Category({ data, isAdded, onSave, onDelete, onToggle }) {
      const [categoryTitle, setCategoryTitle] = reactExports.useState(data.title);
      const [isValid, setValid] = reactExports.useState(false);
      const [isEdit, setEdit] = reactExports.useState(false);
      const inputRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        setValid(categoryTitle.length > 1);
      }, [categoryTitle.length]);
      const handleChange = (e2) => {
        setCategoryTitle(e2.target.value);
      };
      const handleEdit = () => {
        if (isEdit) {
          return;
        }
        const isConfirm = confirm("   ?");
        if (!isConfirm && inputRef.current) {
          inputRef.current.blur();
          return;
        }
        setEdit(true);
      };
      const handleDelete = () => {
        const isConfirm = confirm("   ?");
        if (!isConfirm) {
          return;
        }
        onDelete();
      };
      const handleSave = () => {
        onSave(data.id, categoryTitle);
        setEdit(false);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CustomCheckbox,
          {
            checked: isAdded,
            onChange: onToggle
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input$1,
          {
            ref: inputRef,
            type: "text",
            value: categoryTitle,
            onChange: handleChange,
            $isValid: isValid,
            onFocus: handleEdit
          }
        ),
        !isEdit && /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteBtn, { onClick: handleDelete }),
        isEdit && /* @__PURE__ */ jsxRuntimeExports.jsx(SaveBtn, { onClick: handleSave })
      ] });
    }
    function NewsCategoryForm() {
      const { data, isError, isFetching, isLoading } = useGetNewsCategoryQuery();
      const [createCategory] = useCreateNewsCategoryMutation();
      const [deleteCategory] = useDeleteNewsCategoryMutation();
      const [updateCategory] = useUpdateNewsCategoryMutation();
      const currentCategories = useTypedSelector(
        (state) => state.news.newsCategories
      );
      const { setLoaderActive, deleteNewsCategory, addNewsCategory, setModalOpen } = useActions();
      const handleCreateCategory = () => {
        createCategory({ title: " " }).then(() => {
          setLoaderActive(false);
        });
        setLoaderActive(true);
      };
      const handleDeleteCategory = (id2) => {
        deleteCategory({ id: id2 }).then((res) => {
          if (res.data.message === "Category has news") {
            alert("  ,    !");
          } else if (res.data.message === "Category not found") {
            alert(" Id !");
          } else if (res.data.message === "Category deleted") {
            alert("  .");
          }
          setLoaderActive(false);
        });
        setLoaderActive(true);
      };
      const handleUpdateCategory = (id2, title) => {
        updateCategory({ id: id2, title }).then(() => {
          setLoaderActive(false);
        });
        setLoaderActive(true);
      };
      const handeleToggleCategory = (isAdded, category) => {
        if (isAdded) {
          deleteNewsCategory({ id: category.id });
          return;
        }
        addNewsCategory(category);
      };
      const handleClose = () => {
        setModalOpen(false);
      };
      const handlers = {
        cancel: handleClose,
        confirm: handleClose
      };
      const names = {
        cancel: "",
        confirm: ""
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalForm, { width: "510px", handlers, names, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CategoriesList, { children: data && !isError && !isLoading && data.data.map((category) => {
          const isAdded = currentCategories.some(
            (cat) => cat.id === category.id
          );
          if (category.is_deleted) {
            return null;
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Category,
            {
              data: category,
              isAdded,
              onDelete: () => {
                handleDeleteCategory(category.id);
              },
              onSave: handleUpdateCategory,
              onToggle: () => handeleToggleCategory(isAdded, category)
            },
            category.id
          );
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(AddCategoryBtn, { onClick: handleCreateCategory, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AddCategoryIcon, {}),
          " "
        ] })
      ] });
    }
    const ChangeBodyBg = at$1`
  body {
    background-color: ${(props) => props.theme.colors.realWhite} !important;
  }
`;
    const Title = st$1(Text$6)`
  margin-bottom: 20px;
  font-size: 92.5px;
`;
    const CompetitionNameInput = st$1(InputWithState)`
  margin-bottom: 15px;
`;
    st$1.div`
  width: 100%;
  min-height: 472px;
  padding: 25px;
  padding-left: 75px;
  margin-bottom: 25px;
  border: 1px solid ${(props) => props.theme.colors.greyEO};
  border-radius: ${(props) => props.theme.utils.br};
`;
    st$1.div`
margin-bottom: 60px;
`;
    const Divider = st$1.div`
  position: relative;
  width: 100%;
  height: 1px;
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 100vw;
    height: 100%;
    background-color: ${(props) => props.theme.colors.greyF1};
    transform: translateX(-50%);
  }
`;
    st$1.div`
  position: relative;
  margin-bottom: 50px;
`;
    let editor;
    function CreateCompetitionForm({ type }) {
      const { setLoaderActive } = useActions();
      const navigate = useNavigate();
      const { competitionId } = useParams();
      const [competitionName, setCompetitionName] = reactExports.useState("");
      const [competitionLink, setCompetitionLink] = reactExports.useState("");
      const [isValidName, setValidName] = reactExports.useState(false);
      const [isChangedName, setChangedName] = reactExports.useState(false);
      const [createCompetition] = useCreateCompetitionMutation();
      const [updateCompetition] = useUpdateCompetitionMutation();
      const { data, isFetching } = useGetCompetitionByIdQuery(Number(competitionId), {
        skip: !competitionId
      });
      const [ckEditorData, setCkEditorData] = reactExports.useState("");
      reactExports.useEffect(() => {
        if (data && type === "edit") {
          setCompetitionName(data.data.title);
          setCompetitionLink(data.data.link);
          setValidName(true);
          setChangedName(false);
          setCkEditorData(data.data.text);
        }
      }, [data, type]);
      reactExports.useEffect(() => {
        if (!editor && !isFetching && !data) {
          try {
            editor = new vi({
              holder: "editorjs",
              tools: EDITOR_JS_TOOLS,
              i18n: EDITOR_INTERNATIONALIZATION_CONFIG,
              inlineToolbar: true
            });
          } catch (e2) {
            console.log(e2);
          }
        }
        return () => {
          editor = void 0;
        };
      }, [data, isFetching]);
      const handleConfirm = async () => {
        if (!isValidName) {
          setChangedName(true);
          return;
        }
        if (type !== "create") {
          updateCompetition({
            id: Number(competitionId),
            title: competitionName,
            text: ckEditorData,
            link: competitionLink
          }).then((res) => {
            setLoaderActive(false);
            if ("data" in res && res.data.result) {
              navigate("/news");
            } else {
              alert("    .   !");
            }
          }).catch((err) => {
            setLoaderActive(false);
            console.error(err);
            alert("    .   !");
          });
          setLoaderActive(true);
        } else {
          createCompetition({
            title: competitionName,
            text: ckEditorData,
            link: competitionLink
          }).then((res) => {
            setLoaderActive(false);
            if ("data" in res && res.data.result) {
              navigate("/news");
            } else {
              alert("    .   !");
            }
          }).catch((err) => {
            setLoaderActive(false);
            console.error(err);
            alert("    .   !");
          });
          setLoaderActive(true);
        }
      };
      const handleCancel = () => {
        navigate("/news");
      };
      const handleChangeName = (event) => {
        setValidName(event.target.value.length > 1);
        setCompetitionName(event.target.value);
        if (!isChangedName) {
          setChangedName(true);
        }
      };
      const handleChangeLink = (event) => {
        setCompetitionLink(event.target.value);
      };
      const controlsData = {
        names: {
          confirm: type === "create" ? " " : " ",
          cancel: ""
        },
        handlers: {
          confirm: handleConfirm,
          cancel: handleCancel
        }
      };
      const handleSetCkEditorData = (data2) => {
        setCkEditorData(data2);
      };
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { children: type === "create" ? " " : " " }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CompetitionNameInput,
          {
            $isValid: isValidName,
            $isChanged: isChangedName,
            value: competitionName,
            onChange: handleChangeName,
            type: "text",
            placeholder: type === "create" ? "   ()" : " "
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditor, { onChange: handleSetCkEditorData, data: (data == null ? void 0 : data.data.text) || "" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CompetitionNameInput,
          {
            $isValid: isValidName,
            $isChanged: isChangedName,
            value: competitionLink,
            onChange: handleChangeLink,
            type: "text",
            placeholder: type === "create" ? "    " : " "
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormControls,
          {
            ...controlsData,
            containerStyles: { padding: "25px 0px 25px" }
          }
        )
      ] });
    }
    function CreateCompetition({ type }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultContainer, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(ChangeBodyBg, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCompetitionForm, { type })
      ] });
    }
    function App() {
      const { data, isLoading } = useCheckUserQuery();
      const { setAuthToken, setLoaderActive: setActive } = useActions();
      const { isModalOpen, modalType } = useTypedSelector((state) => state.modal);
      const active = useTypedSelector((state) => state.loader.active);
      const loaderRef = reactExports.useRef(null);
      const isMobile = useMediaQuery$1(MediaQueries.mobile);
      reactExports.useEffect(() => {
        if (data && !isLoading && !data.user) {
          const base64 = btoa(window.location.href);
          const redirectLink = `https://passport.borboza.com/passport/login?returl=${base64}`;
          window.location.replace(redirectLink);
        }
      }, [data, isLoading]);
      reactExports.useEffect(() => {
        setActive(isLoading);
      }, [isLoading, setActive]);
      reactExports.useEffect(() => {
        const csrfHolder = document.querySelector('meta[name="csrf-token"]');
        if (csrfHolder) {
          const CSRF_TOKEN = csrfHolder.content;
          setAuthToken(CSRF_TOKEN);
        }
      }, [setAuthToken]);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Layout, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Route,
            {
              path: "/*",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(Main, {})
            }
          ),
          data && data.user && data.user.role === "admin" && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Route,
              {
                path: "/courses/:courseId/:chapterId/:themeId/create-lesson",
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateLesson, { type: "create" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Route,
              {
                path: "/news/edit-news/:newsId",
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateNews, { type: "edit" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Route,
              {
                path: "/news/competition/create-competition",
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCompetition, { type: "create" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Route,
              {
                path: "/news/competition/edit-competition/:competitionId",
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCompetition, { type: "edit" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Route,
              {
                path: "/courses/:courseId/:chapterId/:themeId/:lessonId/edit-lesson",
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateLesson, { type: "edit" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Route,
              {
                path: "/news/create-news",
                element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateNews, { type: "create" })
              }
            )
          ] }),
          isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
            Route,
            {
              path: "/courses/:courseId/:chapterId/:themeId?/:lessonId?",
              element: /* @__PURE__ */ jsxRuntimeExports.jsx(CourseMob, {})
            }
          )
        ] }),
        isModalOpen && data && data.user && data.user.role === "admin" && /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalLayout, { modalType, children: [
          modalType === MODAL_TYPES.createCourse && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCourseForm, {}),
          modalType === MODAL_TYPES.editCourse && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCourseForm, {}),
          modalType === MODAL_TYPES.createChapter && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateChapterForm, {}),
          modalType === MODAL_TYPES.editChapter && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateChapterForm, {}),
          modalType === MODAL_TYPES.createTheme && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateThemeForm, {}),
          modalType === MODAL_TYPES.editTheme && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateThemeForm, {}),
          modalType === MODAL_TYPES.newsCategory && /* @__PURE__ */ jsxRuntimeExports.jsx(NewsCategoryForm, {})
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Transition$1,
          {
            unmountOnExit: true,
            nodeRef: loaderRef,
            timeout: 300,
            in: active,
            children: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(
              Loading,
              {
                innerRef: loaderRef,
                state
              }
            )
          }
        )
      ] }) });
    }
    const reducer = combineReducers({
      auth: reducer$6,
      modal: reducer$7,
      course: reducer$5,
      loader: reducer$4,
      lesson: reducer$3,
      competition: reducer$2,
      news: reducer$1,
      [api.reducerPath]: api.reducer
    });
    const store = configureStore({
      reducer,
      middleware: (getDefaultMiddleware2) => getDefaultMiddleware2({
        serializableCheck: false
      }).concat(api.middleware)
    });
    const normalize = nt$1`
 html {
  line-height: 1.15;
  -webkit-text-size-adjust: 100%;
}
body {
  margin: 0;
}
main {
  display: block;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}
pre {
  font-family: monospace, monospace;
  font-size: 1em;
}
a {
  background-color: transparent;
}
abbr[title] {
  border-bottom: none;
  text-decoration: underline;
  text-decoration: underline dotted;
}
b,
strong {
  font-weight: bolder;
}
code,
kbd,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
img {
  border-style: none;
}
button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  font-size: 100%;
  line-height: 1.15;
  margin: 0;
}
button,
input {
  overflow: visible;
}
button,
select {
  text-transform: none;
}
button,
[type="button"],
[type="reset"],
[type="submit"] {
  -webkit-appearance: button;
}
button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}
button:-moz-focusring,
[type="button"]:-moz-focusring,
[type="reset"]:-moz-focusring,
[type="submit"]:-moz-focusring {
  outline: 1px dotted ButtonText;
}
fieldset {
  padding: 0.35em 0.75em 0.625em;
}
legend {
  box-sizing: border-box;
  color: inherit;
  display: table;
  max-width: 100%;
  padding: 0; /* 3 */
  white-space: normal;
}
progress {
  vertical-align: baseline;
}
textarea {
  overflow: auto;
}
[type="checkbox"],
[type="radio"] {
  box-sizing: border-box;
  padding: 0;
}
[type="number"]::-webkit-inner-spin-button,
[type="number"]::-webkit-outer-spin-button {
  height: auto;
}
[type="search"] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}
[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}
details {
  display: block;
}
summary {
  display: list-item;
}
template {
  display: none;
}
[hidden] {
  display: none;
}
`;
    const GlobalStyle = at$1`
${normalize}



html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video {
  margin: 0;
  padding: 0;
  border: 0;
  /* font-size: 100%; */
  /* font: inherit; */
  vertical-align: baseline;
  outline: none;
}

ol,
ul {
  list-style: none;
}

input {
  outline: none;
}

img {
  border: 0;
  max-width: 100%;
  height: 100%;
}

a {
  text-decoration: none;

  &:hover {
    text-decoration: underline;
  }
}

button {
  padding: 0;
  margin: 0;
  border: 0;
  cursor: pointer;
}

body {
  font-family: 'Montserrat', sans-serif;
  font-size: 14px;
  line-height: 1;
  background-color: ${(props) => props.theme.colors.greyF1};
}

*,
::after,
::before {
  box-sizing: border-box;
}

.ck-content {
  font-size: 18px;
  line-height: 170%;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.7vw;
    font-weight: 400;
  }
}

.ck-content[role='textbox']{
  min-height: 400px;
  border-radius: 0 0 15px 15px !important;
  ol{
    list-style-position: inside;
  }
  li{
    list-style-position: inside;
  }
}
.ck-toolbar[role='toolbar']{
  border-radius: 15px 15px 0 0 !important;
}

`;
    const baseTheme = {
      colors: {
        realWhite: "#fff",
        realBlack: "#000",
        dark: "#181818",
        mainBlue: "#007AFF",
        darkBlue: "#0068d6",
        lightBlue: "#4BF2FD",
        greyF1: "#f1f1f1",
        greyF5: "#f5f5f5",
        greyEO: "#E0E0E0",
        grey93: "#939393",
        grey57: "#575757",
        yRed: "#E03638",
        darkRed: "#940f0f",
        mainGreen: "#5B8930",
        mainYellow: "#F1FF0D"
      },
      utils: {
        transition: "all .2s ease-in-out",
        br: "15px",
        zIndex: {
          popup: "100",
          burgerMenu: "250",
          modalControls: "200",
          darkOverlay: "500",
          overDarkOverlay: "501",
          loading: "1000"
        }
      },
      media: {
        mobile: "(max-width: 768px)",
        desktop: "(min-width: 769px)"
      }
    };
    const typography = "";
    client.createRoot(document.getElementById("root")).render(
      /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Xe$1, { theme: baseTheme, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyle, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
      ] }) }) })
    );
  }
});
export default require_assets();
