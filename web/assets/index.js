var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node2 of mutation.addedNodes) {
        if (node2.tagName === "LINK" && node2.rel === "modulepreload")
          processPreload(node2);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(link) {
    const fetchOpts = {};
    if (link.integrity)
      fetchOpts.integrity = link.integrity;
    if (link.referrerPolicy)
      fetchOpts.referrerPolicy = link.referrerPolicy;
    if (link.crossOrigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (link.crossOrigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$5 = Symbol.for("react.element"), n$6 = Symbol.for("react.portal"), p$7 = Symbol.for("react.fragment"), q$8 = Symbol.for("react.strict_mode"), r$5 = Symbol.for("react.profiler"), t$5 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$6 = Symbol.for("react.forward_ref"), w$3 = Symbol.for("react.suspense"), x$3 = Symbol.for("react.memo"), y$3 = Symbol.for("react.lazy"), z$5 = Symbol.iterator;
function A$4(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = z$5 && a2[z$5] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$4 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$4 = {};
function E$3(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$4;
  this.updater = e2 || B$4;
}
E$3.prototype.isReactComponent = {};
E$3.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2)
    throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$3.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$3() {
}
F$3.prototype = E$3.prototype;
function G$4(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$4;
  this.updater = e2 || B$4;
}
var H$3 = G$4.prototype = new F$3();
H$3.constructor = G$4;
C$2(H$3, E$3.prototype);
H$3.isPureReactComponent = true;
var I$3 = Array.isArray, J$2 = Object.prototype.hasOwnProperty, K$3 = { current: null }, L$4 = { key: true, ref: true, __self: true, __source: true };
function M$3(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2)
    for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2)
      J$2.call(b2, d2) && !L$4.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2)
    c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++)
      f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps)
    for (d2 in g2 = a2.defaultProps, g2)
      void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$5, type: a2, key: k2, ref: h2, props: c2, _owner: K$3.current };
}
function N$3(a2, b2) {
  return { $$typeof: l$5, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$3(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$5;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$4 = /\/+/g;
function Q$4(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function R$3(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2)
    a2 = null;
  var h2 = false;
  if (null === a2)
    h2 = true;
  else
    switch (k2) {
      case "string":
      case "number":
        h2 = true;
        break;
      case "object":
        switch (a2.$$typeof) {
          case l$5:
          case n$6:
            h2 = true;
        }
    }
  if (h2)
    return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$4(h2, 0) : d2, I$3(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$4, "$&/") + "/"), R$3(c2, b2, e2, "", function(a3) {
      return a3;
    })) : null != c2 && (O$3(c2) && (c2 = N$3(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$4, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$3(a2))
    for (var g2 = 0; g2 < a2.length; g2++) {
      k2 = a2[g2];
      var f2 = d2 + Q$4(k2, g2);
      h2 += R$3(k2, b2, e2, f2, c2);
    }
  else if (f2 = A$4(a2), "function" === typeof f2)
    for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; )
      k2 = k2.value, f2 = d2 + Q$4(k2, g2++), h2 += R$3(k2, b2, e2, f2, c2);
  else if ("object" === k2)
    throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a2, b2, e2) {
  if (null == a2)
    return a2;
  var d2 = [], c2 = 0;
  R$3(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$4(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status)
        a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status)
    return a2._result.default;
  throw a2._result;
}
var U$4 = { current: null }, V$3 = { transition: null }, W$4 = { ReactCurrentDispatcher: U$4, ReactCurrentBatchConfig: V$3, ReactCurrentOwner: K$3 };
react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
  S$2(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$3(a2))
    throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$3;
react_production_min.Fragment = p$7;
react_production_min.Profiler = r$5;
react_production_min.PureComponent = G$4;
react_production_min.StrictMode = q$8;
react_production_min.Suspense = w$3;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$4;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2)
    throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$2({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$3.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps)
      var g2 = a2.type.defaultProps;
    for (f2 in b2)
      J$2.call(b2, f2) && !L$4.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2)
    d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++)
      g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$5, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$4, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$5, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a2) {
  var b2 = M$3.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$6, render: a2 };
};
react_production_min.isValidElement = O$3;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$3, _payload: { _status: -1, _result: a2 }, _init: T$4 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$3, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$3.transition;
  V$3.transition = {};
  try {
    a2();
  } finally {
    V$3.transition = b2;
  }
};
react_production_min.unstable_act = function() {
  throw Error("act(...) is not supported in production builds of React.");
};
react_production_min.useCallback = function(a2, b2) {
  return U$4.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$4.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$4.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$4.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$4.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$4.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$4.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$4.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$4.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$4.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$4.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$4.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$4.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$4.current.useTransition();
};
react_production_min.version = "18.2.0";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$4 = reactExports, k$5 = Symbol.for("react.element"), l$4 = Symbol.for("react.fragment"), m$6 = Object.prototype.hasOwnProperty, n$5 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$6 = { key: true, ref: true, __self: true, __source: true };
function q$7(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2)
    m$6.call(a2, b2) && !p$6.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$5, type: c2, key: e2, ref: h2, props: d2, _owner: n$5.current };
}
reactJsxRuntime_production_min.Fragment = l$4;
reactJsxRuntime_production_min.jsx = q$7;
reactJsxRuntime_production_min.jsxs = q$7;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a:
      for (; 0 < c2; ) {
        var d2 = c2 - 1 >>> 1, e2 = a2[d2];
        if (0 < g2(e2, b2))
          a2[d2] = b2, a2[c2] = e2, c2 = d2;
        else
          break a;
      }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length)
      return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a:
        for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
          var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
          if (0 > g2(C2, c2))
            n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
          else if (n2 < e2 && 0 > g2(x2, c2))
            a2[d2] = x2, a2[n2] = c2, d2 = n2;
          else
            break a;
        }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback)
        k2(t2);
      else if (b2.startTime <= a2)
        k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else
        break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2)
      if (null !== h2(r2))
        A2 = true, I2(J2);
      else {
        var b2 = h2(t2);
        null !== b2 && K2(H2, b2.startTime - a2);
      }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else
          k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2)
        var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else
      N2 = false;
  }
  var S2;
  if ("function" === typeof F2)
    S2 = function() {
      F2(R2);
    };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else
    S2 = function() {
      D2(R2, 0);
    };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$5(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++)
    b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++)
    da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2))
    return true;
  if (ja.call(la, a2))
    return false;
  if (ka.test(a2))
    return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type)
    return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2)
        return false;
      if (null !== c2)
        return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2))
    return true;
  if (d2)
    return false;
  if (null !== c2)
    switch (c2.type) {
      case 3:
        return !b2;
      case 4:
        return false === b2;
      case 5:
        return isNaN(b2);
      case 6:
        return isNaN(b2) || 1 > b2;
    }
  return false;
}
function v$5(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$4 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$4[a2] = new v$5(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$4[b2] = new v$5(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$4[a2] = new v$5(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$4[a2] = new v$5(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$4[a2] = new v$5(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$4[a2] = new v$5(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$4[a2] = new v$5(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$4[a2] = new v$5(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$4[a2] = new v$5(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$4[b2] = new v$5(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$4[b2] = new v$5(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$4[b2] = new v$5(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$4[a2] = new v$5(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$4.xlinkHref = new v$5("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$4[a2] = new v$5(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$4.hasOwnProperty(b2) ? z$4[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1])
    qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2)
    return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$3 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La)
    try {
      throw Error();
    } catch (c2) {
      var b2 = c2.stack.trim().match(/\n( *(at )?)/);
      La = b2 && b2[1] || "";
    }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na)
    return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2)
      if (b2 = function() {
        throw Error();
      }, Object.defineProperty(b2.prototype, "props", { set: function() {
        throw Error();
      } }), "object" === typeof Reflect && Reflect.construct) {
        try {
          Reflect.construct(b2, []);
        } catch (l2) {
          var d2 = l2;
        }
        Reflect.construct(a2, [], b2);
      } else {
        try {
          b2.call();
        } catch (l2) {
          d2 = l2;
        }
        a2.call(b2.prototype);
      }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; )
        h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--)
        if (e2[g2] !== f2[h2]) {
          if (1 !== g2 || 1 !== h2) {
            do
              if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
                var k2 = "\n" + e2[g2].replace(" at new ", " at ");
                a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
                return k2;
              }
            while (1 <= g2 && 0 <= h2);
          }
          break;
        }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2)
    return null;
  if ("function" === typeof a2)
    return a2.displayName || a2.name || null;
  if ("string" === typeof a2)
    return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2)
    switch (a2.$$typeof) {
      case Ca:
        return (a2.displayName || "Context") + ".Consumer";
      case Ba:
        return (a2._context.displayName || "Context") + ".Provider";
      case Da:
        var b2 = a2.render;
        a2 = a2.displayName;
        a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
        return a2;
      case Ga:
        return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
      case Ha:
        b2 = a2._payload;
        a2 = a2._init;
        try {
          return Qa(a2(b2));
        } catch (c2) {
        }
    }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2)
        return b2.displayName || b2.name || null;
      if ("string" === typeof b2)
        return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2)
    return false;
  var b2 = a2._valueTracker;
  if (!b2)
    return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2)
    return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$3({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2)
    if ("number" === d2) {
      if (0 === c2 && "" === a2.value || a2.value != c2)
        a2.value = "" + c2;
    } else
      a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value))
      return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2)
    null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++)
      b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++)
      e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML)
    throw Error(p$5(91));
  return A$3({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2)
        throw Error(p$5(92));
      if (eb(c2)) {
        if (1 < c2.length)
          throw Error(p$5(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2)
    a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; )
      a2.removeChild(a2.firstChild);
    for (; b2.firstChild; )
      a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2)
    if (b2.hasOwnProperty(c2)) {
      var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
      "float" === c2 && (c2 = "cssFloat");
      d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
    }
}
var tb = A$3({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML))
      throw Error(p$5(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children)
        throw Error(p$5(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML))
        throw Error(p$5(61));
    }
    if (null != b2.style && "object" !== typeof b2.style)
      throw Error(p$5(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-"))
    return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb)
      throw Error(p$5(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2)
      for (a2 = 0; a2 < b2.length; a2++)
        Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib)
    return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab)
      Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2)
    return null;
  var d2 = Db(c2);
  if (null === d2)
    return null;
  c2 = d2[b2];
  a:
    switch (b2) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
        a2 = !d2;
        break a;
      default:
        a2 = false;
    }
  if (a2)
    return null;
  if (c2 && "function" !== typeof c2)
    throw Error(p$5(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia)
  try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = true;
    } });
    window.addEventListener("test", Mb, Mb);
    window.removeEventListener("test", Mb, Mb);
  } catch (a2) {
    Lb = false;
  }
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else
      throw Error(p$5(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate)
    for (; b2.return; )
      b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2)
      return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2)
    throw Error(p$5(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2)
      throw Error(p$5(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2)
      break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2)
          return Xb(e2), a2;
        if (f2 === d2)
          return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$5(188));
    }
    if (c2.return !== d2.return)
      c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2)
          throw Error(p$5(189));
      }
    }
    if (c2.alternate !== d2)
      throw Error(p$5(190));
  }
  if (3 !== c2.tag)
    throw Error(p$5(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2)
      return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B$3 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot)
    try {
      lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
    } catch (b2) {
    }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2)
    return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else
    g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2)
    return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240)))
    return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2)
    for (a2 = a2.entanglements, b2 &= d2; 0 < b2; )
      c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2))
        e2[g2] = vc(h2, b2);
    } else
      k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++)
    b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$1 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2)
    return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn)
    return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else
      return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++)
    d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); )
    Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2)
      hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2))
      d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2)
          break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else
      hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2)
    if (b2 = Vb(a2), null === b2)
      a2 = null;
    else if (c2 = b2.tag, 13 === c2) {
      a2 = Wb(b2);
      if (null !== a2)
        return a2;
      a2 = null;
    } else if (3 === c2) {
      if (b2.stateNode.current.memoizedState.isDehydrated)
        return 3 === b2.tag ? b2.stateNode.containerInfo : null;
      a2 = null;
    } else
      b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md)
    return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++)
    ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++)
    ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2)
      a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$3(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$3({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$3({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2)
    return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$3({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$3({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$3({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$3({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$3({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$3({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2)
      return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$3({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$3({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$3({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$3({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$2 = null;
ia && "documentMode" in document && (be$2 = document.documentMode);
var ce$2 = ia && "TextEvent" in window && !be$2, de$1 = ia && (!ae$1 || be$2 && 8 < be$2 && 11 >= be$2), ee$1 = String.fromCharCode(32), fe$2 = false;
function ge$2(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$2(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie$1 = false;
function je$1(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he$2(b2);
    case "keypress":
      if (32 !== b2.which)
        return null;
      fe$2 = true;
      return ee$1;
    case "textInput":
      return a2 = b2.data, a2 === ee$1 && fe$2 ? null : a2;
    default:
      return null;
  }
}
function ke$2(a2, b2) {
  if (ie$1)
    return "compositionend" === a2 || !ae$1 && ge$2(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie$1 = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length)
          return b2.char;
        if (b2.which)
          return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$1 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$2(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le$2[a2.type] : "textarea" === b2 ? true : false;
}
function ne$2(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe$2(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe$2 = null, qe$2 = null;
function re$2(a2) {
  se$2(a2, 0);
}
function te$2(a2) {
  var b2 = ue$2(a2);
  if (Wa(b2))
    return a2;
}
function ve$2(a2, b2) {
  if ("change" === a2)
    return b2;
}
var we$2 = false;
if (ia) {
  var xe$1;
  if (ia) {
    var ye$2 = "oninput" in document;
    if (!ye$2) {
      var ze$2 = document.createElement("div");
      ze$2.setAttribute("oninput", "return;");
      ye$2 = "function" === typeof ze$2.oninput;
    }
    xe$1 = ye$2;
  } else
    xe$1 = false;
  we$2 = xe$1 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$2() {
  pe$2 && (pe$2.detachEvent("onpropertychange", Be$2), qe$2 = pe$2 = null);
}
function Be$2(a2) {
  if ("value" === a2.propertyName && te$2(qe$2)) {
    var b2 = [];
    ne$2(b2, qe$2, a2, xb(a2));
    Jb(re$2, b2);
  }
}
function Ce$1(a2, b2, c2) {
  "focusin" === a2 ? (Ae$2(), pe$2 = b2, qe$2 = c2, pe$2.attachEvent("onpropertychange", Be$2)) : "focusout" === a2 && Ae$2();
}
function De$2(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2)
    return te$2(qe$2);
}
function Ee$2(a2, b2) {
  if ("click" === a2)
    return te$2(b2);
}
function Fe$1(a2, b2) {
  if ("input" === a2 || "change" === a2)
    return te$2(b2);
}
function Ge$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He$2 = "function" === typeof Object.is ? Object.is : Ge$1;
function Ie$2(a2, b2) {
  if (He$2(a2, b2))
    return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2)
    return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length)
    return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He$2(a2[e2], b2[e2]))
      return false;
  }
  return true;
}
function Je$1(a2) {
  for (; a2 && a2.firstChild; )
    a2 = a2.firstChild;
  return a2;
}
function Ke$2(a2, b2) {
  var c2 = Je$1(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2)
        return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je$1(c2);
  }
}
function Le$2(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le$2(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me$2() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2)
      a2 = b2.contentWindow;
    else
      break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne$2(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe$2(a2) {
  var b2 = Me$2(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le$2(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne$2(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2)
        c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke$2(c2, f2);
        var g2 = Ke$2(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; )
      1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++)
      a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe$2 = ia && "documentMode" in document && 11 >= document.documentMode, Qe$2 = null, Re$2 = null, Se$2 = null, Te$2 = false;
function Ue$1(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te$2 || null == Qe$2 || Qe$2 !== Xa(d2) || (d2 = Qe$2, "selectionStart" in d2 && Ne$2(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se$2 && Ie$2(Se$2, d2) || (Se$2 = d2, d2 = oe$2(Re$2, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe$2)));
}
function Ve$2(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We$2 = { animationend: Ve$2("Animation", "AnimationEnd"), animationiteration: Ve$2("Animation", "AnimationIteration"), animationstart: Ve$2("Animation", "AnimationStart"), transitionend: Ve$2("Transition", "TransitionEnd") }, Xe$2 = {}, Ye$2 = {};
ia && (Ye$2 = document.createElement("div").style, "AnimationEvent" in window || (delete We$2.animationend.animation, delete We$2.animationiteration.animation, delete We$2.animationstart.animation), "TransitionEvent" in window || delete We$2.transitionend.transition);
function Ze$2(a2) {
  if (Xe$2[a2])
    return Xe$2[a2];
  if (!We$2[a2])
    return a2;
  var b2 = We$2[a2], c2;
  for (c2 in b2)
    if (b2.hasOwnProperty(c2) && c2 in Ye$2)
      return Xe$2[a2] = b2[c2];
  return a2;
}
var $e$2 = Ze$2("animationend"), af = Ze$2("animationiteration"), bf = Ze$2("animationstart"), cf = Ze$2("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$2, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se$2(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2)
        for (var g2 = d2.length - 1; 0 <= g2; g2--) {
          var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
      else
        for (g2 = 0; g2 < d2.length; g2++) {
          h2 = d2[g2];
          k2 = h2.instance;
          l2 = h2.currentTarget;
          h2 = h2.listener;
          if (k2 !== f2 && e2.isPropagationStopped())
            break a;
          nf(e2, h2, l2);
          f2 = k2;
        }
    }
  }
  if (Qb)
    throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$3(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2)
    a:
      for (; ; ) {
        if (null === d2)
          return;
        var g2 = d2.tag;
        if (3 === g2 || 4 === g2) {
          var h2 = d2.stateNode.containerInfo;
          if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2)
            break;
          if (4 === g2)
            for (g2 = d2.return; null !== g2; ) {
              var k2 = g2.tag;
              if (3 === k2 || 4 === k2) {
                if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2)
                  return;
              }
              g2 = g2.return;
            }
          for (; null !== h2; ) {
            g2 = Wc(h2);
            if (null === g2)
              return;
            k2 = g2.tag;
            if (5 === k2 || 6 === k2) {
              d2 = f2 = g2;
              continue a;
            }
            h2 = h2.parentNode;
          }
        }
        d2 = d2.return;
      }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2))
              break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button)
              break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e$2:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2)
            break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf]))
          break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag))
              n2 = null;
          } else
            k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2)
              t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue$2(k3);
            u2 = null == n2 ? h3 : ue$2(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2)
              b: {
                t2 = k3;
                x2 = n2;
                w2 = 0;
                for (u2 = t2; u2; u2 = vf(u2))
                  w2++;
                u2 = 0;
                for (F2 = x2; F2; F2 = vf(F2))
                  u2++;
                for (; 0 < w2 - u2; )
                  t2 = vf(t2), w2--;
                for (; 0 < u2 - w2; )
                  x2 = vf(x2), u2--;
                for (; w2--; ) {
                  if (t2 === x2 || null !== x2 && t2 === x2.alternate)
                    break b;
                  t2 = vf(t2);
                  x2 = vf(x2);
                }
                t2 = null;
              }
            else
              t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue$2(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type)
          var na = ve$2;
        else if (me$2(h3))
          if (we$2)
            na = Fe$1;
          else {
            na = De$2;
            var xa = Ce$1;
          }
        else
          (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee$2);
        if (na && (na = na(a2, d3))) {
          ne$2(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue$2(d3) : window;
      switch (a2) {
        case "focusin":
          if (me$2(xa) || "true" === xa.contentEditable)
            Qe$2 = xa, Re$2 = d3, Se$2 = null;
          break;
        case "focusout":
          Se$2 = Re$2 = Qe$2 = null;
          break;
        case "mousedown":
          Te$2 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$2 = false;
          Ue$1(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe$2)
            break;
        case "keydown":
        case "keyup":
          Ue$1(g3, c2, e3);
      }
      var $a;
      if (ae$1)
        b: {
          switch (a2) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
      else
        ie$1 ? ge$2(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de$1 && "ko" !== c2.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$2(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$2(c2), null !== $a && (ba.data = $a))));
      if ($a = ce$2 ? je$1(a2, c2) : ke$2(a2, c2))
        d3 = oe$2(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se$2(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe$2(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2)
    return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2)
      break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2)
    throw Error(p$5(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType)
      if (c2 = e2.data, "/$" === c2) {
        if (0 === d2) {
          a2.removeChild(e2);
          bd(b2);
          return;
        }
        d2--;
      } else
        "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2)
      break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2)
        break;
      if ("/$" === b2)
        return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2)
          return a2;
        b2--;
      } else
        "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2)
    return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child)
        for (a2 = Mf(a2); null !== a2; ) {
          if (c2 = a2[Of])
            return c2;
          a2 = Mf(a2);
        }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue$2(a2) {
  if (5 === a2.tag || 6 === a2.tag)
    return a2.stateNode;
  throw Error(p$5(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$2(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G$3(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H$2 = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2)
    return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2)
    return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2)
    e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$2(Wf);
  E$2(H$2);
}
function ag(a2, b2, c2) {
  if (H$2.current !== Vf)
    throw Error(p$5(168));
  G$3(H$2, b2);
  G$3(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext)
    return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2)
    if (!(e2 in b2))
      throw Error(p$5(108, Ra(a2) || "Unknown", e2));
  return A$3({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H$2.current;
  G$3(H$2, a2);
  G$3(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2)
    throw Error(p$5(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$2(Wf), E$2(H$2), G$3(H$2, a2)) : E$2(Wf);
  G$3(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$1;
    try {
      var c2 = eg;
      for (C$1 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$1 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else
    rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; )
    mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; )
    qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$2 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$2) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2))
          throw Error(p$5(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$2 = false, xg = a2);
      }
    } else {
      if (Dg(a2))
        throw Error(p$5(418));
      a2.flags = a2.flags & -4097 | 2;
      I$2 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; )
    a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg)
    return false;
  if (!I$2)
    return Fg(a2), I$2 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2))
      throw Hg(), Error(p$5(418));
    for (; b2; )
      Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2)
      throw Error(p$5(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else
            "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else
    yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; )
    a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$2 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$3({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2)
      void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
var Mg = Uf(null), Ng = null, Og = null, Pg = null;
function Qg() {
  Pg = Og = Ng = null;
}
function Rg(a2) {
  var b2 = Mg.current;
  E$2(Mg);
  a2._currentValue = b2;
}
function Sg(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2)
      break;
    a2 = a2.return;
  }
}
function Tg(a2, b2) {
  Ng = a2;
  Pg = Og = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (Ug = true), a2.firstContext = null);
}
function Vg(a2) {
  var b2 = a2._currentValue;
  if (Pg !== a2)
    if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Og) {
      if (null === Ng)
        throw Error(p$5(308));
      Og = a2;
      Ng.dependencies = { lanes: 0, firstContext: a2 };
    } else
      Og = Og.next = a2;
  return b2;
}
var Wg = null;
function Xg(a2) {
  null === Wg ? Wg = [a2] : Wg.push(a2);
}
function Yg(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, Xg(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return Zg(a2, d2);
}
function Zg(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; )
    a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var $g = false;
function ah(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function bh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function ch(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function dh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2)
    return null;
  d2 = d2.shared;
  if (0 !== (K$2 & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return Zg(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, Xg(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return Zg(a2, c2);
}
function eh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function fh(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else
      e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function gh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  $g = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2)
                break a;
              q2 = A$3({}, q2, r2);
              break a;
            case 2:
              $g = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else
        y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2)
        if (h2 = e2.shared.pending, null === h2)
          break;
        else
          r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else
      null === f2 && (e2.shared.lanes = 0);
    hh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function ih(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2)
    for (b2 = 0; b2 < a2.length; b2++) {
      var d2 = a2[b2], e2 = d2.callback;
      if (null !== e2) {
        d2.callback = null;
        d2 = c2;
        if ("function" !== typeof e2)
          throw Error(p$5(191, e2));
        e2.call(d2);
      }
    }
}
var jh = new aa.Component().refs;
function kh(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$3({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var nh = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$3(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = L$3(), e2 = lh(a2), f2 = ch(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = dh(a2, f2, e2);
  null !== b2 && (mh(b2, a2, e2, d2), eh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = L$3(), d2 = lh(a2), e2 = ch(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = dh(a2, e2, d2);
  null !== b2 && (mh(b2, a2, d2, c2), eh(b2, a2, d2));
} };
function oh(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie$2(c2, d2) || !Ie$2(e2, f2) : true;
}
function ph(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = Vg(f2) : (e2 = Zf(b2) ? Xf : H$2.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = nh;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function qh(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && nh.enqueueReplaceState(b2, b2.state, null);
}
function rh(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = jh;
  ah(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = Vg(f2) : (f2 = Zf(b2) ? Xf : H$2.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (kh(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && nh.enqueueReplaceState(e2, e2.state, null), gh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function sh(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag)
          throw Error(p$5(309));
        var d2 = c2.stateNode;
      }
      if (!d2)
        throw Error(p$5(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2)
        return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        b3 === jh && (b3 = e2.refs = {});
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2)
      throw Error(p$5(284));
    if (!c2._owner)
      throw Error(p$5(290, a2));
  }
  return a2;
}
function th(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$5(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function uh(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function vh(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2)
      return null;
    for (; null !== d3; )
      b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; )
      null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = wh(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2)
      return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3)
      return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag)
      return b3 = xh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya)
      return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && uh(f3) === b3.type))
      return d3 = e2(b3, c3.props), d3.ref = sh(a3, b3, c3), d3.return = a3, d3;
    d3 = yh(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = sh(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation)
      return b3 = zh(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag)
      return b3 = Ah(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3)
      return b3 = xh("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = yh(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = sh(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = zh(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3))
        return b3 = Ah(b3, a3.mode, c3, null), b3.return = a3, b3;
      th(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3)
      return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3))
        return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      th(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3)
      return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3))
        return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      th(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length)
      return c2(e3, u2), I$2 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++)
        u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++)
      x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3)
      throw Error(p$5(150));
    h3 = l3.call(h3);
    if (null == h3)
      throw Error(p$5(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done)
      return c2(
        e3,
        m3
      ), I$2 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next())
        n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$2 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next())
      n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$2 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && uh(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = sh(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else
                b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Ah(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = yh(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = sh(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3)
                if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                  c2(a3, d3.sibling);
                  d3 = e2(d3, f3.children || []);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                } else {
                  c2(a3, d3);
                  break;
                }
              else
                b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = zh(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3))
        return n2(a3, d3, f3, h3);
      if (Ka(f3))
        return t2(a3, d3, f3, h3);
      th(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = xh(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Bh = vh(true), Ch = vh(false), Dh = {}, Eh = Uf(Dh), Fh = Uf(Dh), Gh = Uf(Dh);
function Hh(a2) {
  if (a2 === Dh)
    throw Error(p$5(174));
  return a2;
}
function Ih(a2, b2) {
  G$3(Gh, b2);
  G$3(Fh, a2);
  G$3(Eh, Dh);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$2(Eh);
  G$3(Eh, b2);
}
function Jh() {
  E$2(Eh);
  E$2(Fh);
  E$2(Gh);
}
function Kh(a2) {
  Hh(Gh.current);
  var b2 = Hh(Eh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G$3(Fh, a2), G$3(Eh, c2));
}
function Lh(a2) {
  Fh.current === a2 && (E$2(Eh), E$2(Fh));
}
var M$2 = Uf(0);
function Mh(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data))
        return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128))
        return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2)
      break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2)
        return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Nh = [];
function Oh() {
  for (var a2 = 0; a2 < Nh.length; a2++)
    Nh[a2]._workInProgressVersionPrimary = null;
  Nh.length = 0;
}
var Ph = ua.ReactCurrentDispatcher, Qh = ua.ReactCurrentBatchConfig, Rh = 0, N$2 = null, O$2 = null, P$3 = null, Sh = false, Th = false, Uh = 0, Vh = 0;
function Q$3() {
  throw Error(p$5(321));
}
function Wh(a2, b2) {
  if (null === b2)
    return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++)
    if (!He$2(a2[c2], b2[c2]))
      return false;
  return true;
}
function Xh(a2, b2, c2, d2, e2, f2) {
  Rh = f2;
  N$2 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Ph.current = null === a2 || null === a2.memoizedState ? Yh : Zh;
  a2 = c2(d2, e2);
  if (Th) {
    f2 = 0;
    do {
      Th = false;
      Uh = 0;
      if (25 <= f2)
        throw Error(p$5(301));
      f2 += 1;
      P$3 = O$2 = null;
      b2.updateQueue = null;
      Ph.current = $h;
      a2 = c2(d2, e2);
    } while (Th);
  }
  Ph.current = ai$1;
  b2 = null !== O$2 && null !== O$2.next;
  Rh = 0;
  P$3 = O$2 = N$2 = null;
  Sh = false;
  if (b2)
    throw Error(p$5(300));
  return a2;
}
function bi$1() {
  var a2 = 0 !== Uh;
  Uh = 0;
  return a2;
}
function ci$1() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === P$3 ? N$2.memoizedState = P$3 = a2 : P$3 = P$3.next = a2;
  return P$3;
}
function di$1() {
  if (null === O$2) {
    var a2 = N$2.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else
    a2 = O$2.next;
  var b2 = null === P$3 ? N$2.memoizedState : P$3.next;
  if (null !== b2)
    P$3 = b2, O$2 = a2;
  else {
    if (null === a2)
      throw Error(p$5(310));
    O$2 = a2;
    a2 = { memoizedState: O$2.memoizedState, baseState: O$2.baseState, baseQueue: O$2.baseQueue, queue: O$2.queue, next: null };
    null === P$3 ? N$2.memoizedState = P$3 = a2 : P$3 = P$3.next = a2;
  }
  return P$3;
}
function ei$1(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function fi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = O$2, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Rh & m2) === m2)
        null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        N$2.lanes |= m2;
        hh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He$2(d2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, N$2.lanes |= f2, hh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else
    null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function gi$1(a2) {
  var b2 = di$1(), c2 = b2.queue;
  if (null === c2)
    throw Error(p$5(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He$2(f2, b2.memoizedState) || (Ug = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function hi$1() {
}
function ii$1(a2, b2) {
  var c2 = N$2, d2 = di$1(), e2 = b2(), f2 = !He$2(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, Ug = true);
  d2 = d2.queue;
  ji(ki$1.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== P$3 && P$3.memoizedState.tag & 1) {
    c2.flags |= 2048;
    li$1(9, mi$1.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === R$2)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni$1(c2, b2, e2);
  }
  return e2;
}
function ni$1(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function mi$1(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  oi$1(b2) && pi$1(a2);
}
function ki$1(a2, b2, c2) {
  return c2(function() {
    oi$1(b2) && pi$1(a2);
  });
}
function oi$1(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He$2(a2, c2);
  } catch (d2) {
    return true;
  }
}
function pi$1(a2) {
  var b2 = Zg(a2, 1);
  null !== b2 && mh(b2, a2, 1, -1);
}
function qi(a2) {
  var b2 = ci$1();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: ei$1, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ri$1.bind(null, N$2, a2);
  return [b2.memoizedState, a2];
}
function li$1(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = N$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, N$2.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function si$1() {
  return di$1().memoizedState;
}
function ti$1(a2, b2, c2, d2) {
  var e2 = ci$1();
  N$2.flags |= a2;
  e2.memoizedState = li$1(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function ui$1(a2, b2, c2, d2) {
  var e2 = di$1();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== O$2) {
    var g2 = O$2.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Wh(d2, g2.deps)) {
      e2.memoizedState = li$1(b2, c2, f2, d2);
      return;
    }
  }
  N$2.flags |= a2;
  e2.memoizedState = li$1(1 | b2, c2, f2, d2);
}
function vi$1(a2, b2) {
  return ti$1(8390656, 8, a2, b2);
}
function ji(a2, b2) {
  return ui$1(2048, 8, a2, b2);
}
function wi$1(a2, b2) {
  return ui$1(4, 2, a2, b2);
}
function xi$1(a2, b2) {
  return ui$1(4, 4, a2, b2);
}
function yi$1(a2, b2) {
  if ("function" === typeof b2)
    return a2 = a2(), b2(a2), function() {
      b2(null);
    };
  if (null !== b2 && void 0 !== b2)
    return a2 = a2(), b2.current = a2, function() {
      b2.current = null;
    };
}
function zi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ui$1(4, 4, yi$1.bind(null, b2, a2), c2);
}
function Ai() {
}
function Bi$1(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function Ci(a2, b2) {
  var c2 = di$1();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Wh(b2, d2[1]))
    return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function Di(a2, b2, c2) {
  if (0 === (Rh & 21))
    return a2.baseState && (a2.baseState = false, Ug = true), a2.memoizedState = c2;
  He$2(c2, b2) || (c2 = yc(), N$2.lanes |= c2, hh |= c2, a2.baseState = true);
  return b2;
}
function Ei$1(a2, b2) {
  var c2 = C$1;
  C$1 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Qh.transition;
  Qh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$1 = c2, Qh.transition = d2;
  }
}
function Fi() {
  return di$1().memoizedState;
}
function Gi(a2, b2, c2) {
  var d2 = lh(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, c2);
  else if (c2 = Yg(a2, b2, c2, d2), null !== c2) {
    var e2 = L$3();
    mh(c2, a2, d2, e2);
    Ji(c2, b2, d2);
  }
}
function ri$1(a2, b2, c2) {
  var d2 = lh(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (Hi(a2))
    Ii(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2))
      try {
        var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
        e2.hasEagerState = true;
        e2.eagerState = h2;
        if (He$2(h2, g2)) {
          var k2 = b2.interleaved;
          null === k2 ? (e2.next = e2, Xg(b2)) : (e2.next = k2.next, k2.next = e2);
          b2.interleaved = e2;
          return;
        }
      } catch (l2) {
      } finally {
      }
    c2 = Yg(a2, b2, e2, d2);
    null !== c2 && (e2 = L$3(), mh(c2, a2, d2, e2), Ji(c2, b2, d2));
  }
}
function Hi(a2) {
  var b2 = a2.alternate;
  return a2 === N$2 || null !== b2 && b2 === N$2;
}
function Ii(a2, b2) {
  Th = Sh = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Ji(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var ai$1 = { readContext: Vg, useCallback: Q$3, useContext: Q$3, useEffect: Q$3, useImperativeHandle: Q$3, useInsertionEffect: Q$3, useLayoutEffect: Q$3, useMemo: Q$3, useReducer: Q$3, useRef: Q$3, useState: Q$3, useDebugValue: Q$3, useDeferredValue: Q$3, useTransition: Q$3, useMutableSource: Q$3, useSyncExternalStore: Q$3, useId: Q$3, unstable_isNewReconciler: false }, Yh = { readContext: Vg, useCallback: function(a2, b2) {
  ci$1().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: Vg, useEffect: vi$1, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ti$1(
    4194308,
    4,
    yi$1.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ti$1(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ti$1(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = ci$1();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = ci$1();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = Gi.bind(null, N$2, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = ci$1();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: qi, useDebugValue: Ai, useDeferredValue: function(a2) {
  return ci$1().memoizedState = a2;
}, useTransition: function() {
  var a2 = qi(false), b2 = a2[0];
  a2 = Ei$1.bind(null, a2[1]);
  ci$1().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = N$2, e2 = ci$1();
  if (I$2) {
    if (void 0 === c2)
      throw Error(p$5(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === R$2)
      throw Error(p$5(349));
    0 !== (Rh & 30) || ni$1(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  vi$1(ki$1.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  li$1(9, mi$1.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = ci$1(), b2 = R$2.identifierPrefix;
  if (I$2) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Uh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else
    c2 = Vh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Zh = {
  readContext: Vg,
  useCallback: Bi$1,
  useContext: Vg,
  useEffect: ji,
  useImperativeHandle: zi,
  useInsertionEffect: wi$1,
  useLayoutEffect: xi$1,
  useMemo: Ci,
  useReducer: fi$1,
  useRef: si$1,
  useState: function() {
    return fi$1(ei$1);
  },
  useDebugValue: Ai,
  useDeferredValue: function(a2) {
    var b2 = di$1();
    return Di(b2, O$2.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = fi$1(ei$1)[0], b2 = di$1().memoizedState;
    return [a2, b2];
  },
  useMutableSource: hi$1,
  useSyncExternalStore: ii$1,
  useId: Fi,
  unstable_isNewReconciler: false
}, $h = { readContext: Vg, useCallback: Bi$1, useContext: Vg, useEffect: ji, useImperativeHandle: zi, useInsertionEffect: wi$1, useLayoutEffect: xi$1, useMemo: Ci, useReducer: gi$1, useRef: si$1, useState: function() {
  return gi$1(ei$1);
}, useDebugValue: Ai, useDeferredValue: function(a2) {
  var b2 = di$1();
  return null === O$2 ? b2.memoizedState = a2 : Di(b2, O$2.memoizedState, a2);
}, useTransition: function() {
  var a2 = gi$1(ei$1)[0], b2 = di$1().memoizedState;
  return [a2, b2];
}, useMutableSource: hi$1, useSyncExternalStore: ii$1, useId: Fi, unstable_isNewReconciler: false };
function Ki(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Li(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Mi(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Ni = "function" === typeof WeakMap ? WeakMap : Map;
function Oi(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Pi || (Pi = true, Qi = d2);
    Mi(a2, b2);
  };
  return c2;
}
function Ri(a2, b2, c2) {
  c2 = ch(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Mi(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Mi(a2, b2);
    "function" !== typeof d2 && (null === Si ? Si = /* @__PURE__ */ new Set([this]) : Si.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Ni();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else
    e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ui.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Vi(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag)
      b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2)
      return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Wi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1))
    return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = ch(-1, 1), b2.tag = 2, dh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Xi = ua.ReactCurrentOwner, Ug = false;
function Yi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Ch(b2, null, c2, d2) : Bh(b2, a2.child, c2, d2);
}
function Zi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  Tg(b2, e2);
  d2 = Xh(a2, b2, c2, d2, f2, e2);
  c2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$2 && c2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, d2, e2);
  return b2.child;
}
function aj(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !bj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps)
      return b2.tag = 15, b2.type = f2, cj(a2, b2, f2, d2, e2);
    a2 = yh(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie$2;
    if (c2(g2, d2) && a2.ref === b2.ref)
      return $i(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = wh(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function cj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie$2(f2, d2) && a2.ref === b2.ref)
      if (Ug = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2))
        0 !== (a2.flags & 131072) && (Ug = true);
      else
        return b2.lanes = a2.lanes, $i(a2, b2, e2);
  }
  return dj(a2, b2, c2, d2, e2);
}
function ej(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode)
    if (0 === (b2.mode & 1))
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G$3(fj, gj), gj |= c2;
    else {
      if (0 === (c2 & 1073741824))
        return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G$3(fj, gj), gj |= a2, null;
      b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
      d2 = null !== f2 ? f2.baseLanes : c2;
      G$3(fj, gj);
      gj |= d2;
    }
  else
    null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G$3(fj, gj), gj |= d2;
  Yi(a2, b2, e2, c2);
  return b2.child;
}
function hj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2)
    b2.flags |= 512, b2.flags |= 2097152;
}
function dj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H$2.current;
  f2 = Yf(b2, f2);
  Tg(b2, e2);
  c2 = Xh(a2, b2, c2, d2, f2, e2);
  d2 = bi$1();
  if (null !== a2 && !Ug)
    return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, $i(a2, b2, e2);
  I$2 && d2 && vg(b2);
  b2.flags |= 1;
  Yi(a2, b2, c2, e2);
  return b2.child;
}
function ij(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else
    f2 = false;
  Tg(b2, e2);
  if (null === b2.stateNode)
    jj(a2, b2), ph(b2, c2, d2), rh(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = Vg(l2) : (l2 = Zf(c2) ? Xf : H$2.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && qh(b2, g2, d2, l2);
    $g = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || $g ? ("function" === typeof m2 && (kh(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = $g || oh(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    bh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Lg(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = Vg(k2) : (k2 = Zf(c2) ? Xf : H$2.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && qh(b2, g2, d2, k2);
    $g = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    gh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || $g ? ("function" === typeof y2 && (kh(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = $g || oh(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return kj(a2, b2, c2, d2, f2, e2);
}
function kj(a2, b2, c2, d2, e2, f2) {
  hj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2)
    return e2 && dg(b2, c2, false), $i(a2, b2, f2);
  d2 = b2.stateNode;
  Xi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Bh(b2, a2.child, null, f2), b2.child = Bh(b2, null, h2, f2)) : Yi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function lj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  Ih(a2, b2.containerInfo);
}
function mj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Yi(a2, b2, c2, d2);
  return b2.child;
}
var nj = { dehydrated: null, treeContext: null, retryLane: 0 };
function oj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function pj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = M$2.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2)
    f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState)
    e2 |= 1;
  G$3(M$2, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2))
      return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = qj(g2, d2, 0, null), a2 = Ah(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = oj(c2), b2.memoizedState = nj, a2) : rj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2))
    return sj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = wh(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = wh(h2, f2) : (f2 = Ah(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? oj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = nj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = wh(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function rj(a2, b2) {
  b2 = qj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function tj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Bh(b2, a2.child, null, c2);
  a2 = rj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function sj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256)
      return b2.flags &= -257, d2 = Li(Error(p$5(422))), tj(a2, b2, g2, d2);
    if (null !== b2.memoizedState)
      return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = qj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Ah(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Bh(b2, a2.child, null, g2);
    b2.child.memoizedState = oj(g2);
    b2.memoizedState = nj;
    return f2;
  }
  if (0 === (b2.mode & 1))
    return tj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2)
      var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$5(419));
    d2 = Li(f2, d2, void 0);
    return tj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (Ug || h2) {
    d2 = R$2;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, Zg(a2, e2), mh(d2, a2, e2, -1));
    }
    uj();
    d2 = Li(Error(p$5(421)));
    return tj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data)
    return b2.flags |= 128, b2.child = a2.child, b2 = vj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$2 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = rj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function wj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  Sg(a2.return, b2, c2);
}
function xj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function yj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Yi(a2, b2, d2.children, c2);
  d2 = M$2.current;
  if (0 !== (d2 & 2))
    d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128))
      a:
        for (a2 = b2.child; null !== a2; ) {
          if (13 === a2.tag)
            null !== a2.memoizedState && wj(a2, c2, b2);
          else if (19 === a2.tag)
            wj(a2, c2, b2);
          else if (null !== a2.child) {
            a2.child.return = a2;
            a2 = a2.child;
            continue;
          }
          if (a2 === b2)
            break a;
          for (; null === a2.sibling; ) {
            if (null === a2.return || a2.return === b2)
              break a;
            a2 = a2.return;
          }
          a2.sibling.return = a2.return;
          a2 = a2.sibling;
        }
    d2 &= 1;
  }
  G$3(M$2, d2);
  if (0 === (b2.mode & 1))
    b2.memoizedState = null;
  else
    switch (e2) {
      case "forwards":
        c2 = b2.child;
        for (e2 = null; null !== c2; )
          a2 = c2.alternate, null !== a2 && null === Mh(a2) && (e2 = c2), c2 = c2.sibling;
        c2 = e2;
        null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
        xj(b2, false, e2, c2, f2);
        break;
      case "backwards":
        c2 = null;
        e2 = b2.child;
        for (b2.child = null; null !== e2; ) {
          a2 = e2.alternate;
          if (null !== a2 && null === Mh(a2)) {
            b2.child = e2;
            break;
          }
          a2 = e2.sibling;
          e2.sibling = c2;
          c2 = e2;
          e2 = a2;
        }
        xj(b2, true, c2, null, f2);
        break;
      case "together":
        xj(b2, false, null, null, void 0);
        break;
      default:
        b2.memoizedState = null;
    }
  return b2.child;
}
function jj(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function $i(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  hh |= b2.lanes;
  if (0 === (c2 & b2.childLanes))
    return null;
  if (null !== a2 && b2.child !== a2.child)
    throw Error(p$5(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = wh(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; )
      a2 = a2.sibling, c2 = c2.sibling = wh(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function zj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      lj(b2);
      Ig();
      break;
    case 5:
      Kh(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      Ih(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G$3(Mg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated)
          return G$3(M$2, M$2.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes))
          return pj(a2, b2, c2);
        G$3(M$2, M$2.current & 1);
        a2 = $i(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G$3(M$2, M$2.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2)
          return yj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G$3(M$2, M$2.current);
      if (d2)
        break;
      else
        return null;
    case 22:
    case 23:
      return b2.lanes = 0, ej(a2, b2, c2);
  }
  return $i(a2, b2, c2);
}
var Aj, Bj, Cj, Dj;
Aj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag)
      a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2)
      break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2)
        return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Bj = function() {
};
Cj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    Hh(Eh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$3({}, e2, { value: void 0 });
        d2 = A$3({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2)
      if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2])
        if ("style" === l2) {
          var h2 = e2[l2];
          for (g2 in h2)
            h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
        } else
          "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2))
        if ("style" === l2)
          if (h2) {
            for (g2 in h2)
              !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
            for (g2 in k2)
              k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
          } else
            c2 || (f2 || (f2 = []), f2.push(
              l2,
              c2
            )), c2 = k2;
        else
          "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$3("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2)
      b2.flags |= 4;
  }
};
Dj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Ej(a2, b2) {
  if (!I$2)
    switch (a2.tailMode) {
      case "hidden":
        b2 = a2.tail;
        for (var c2 = null; null !== b2; )
          null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
        null === c2 ? a2.tail = null : c2.sibling = null;
        break;
      case "collapsed":
        c2 = a2.tail;
        for (var d2 = null; null !== c2; )
          null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
        null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
    }
}
function S$1(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2)
    for (var e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else
    for (e2 = a2.child; null !== e2; )
      c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Fj(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d2 = b2.stateNode;
      Jh();
      E$2(Wf);
      E$2(H$2);
      Oh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child)
        Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Gj(zg), zg = null));
      Bj(a2, b2);
      S$1(b2);
      return null;
    case 5:
      Lh(b2);
      var e2 = Hh(Gh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode)
        Cj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode)
            throw Error(p$5(166));
          S$1(b2);
          return null;
        }
        a2 = Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$3("cancel", d2);
              D$3("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$3("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++)
                D$3(lf[e2], d2);
              break;
            case "source":
              D$3("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$3(
                "error",
                d2
              );
              D$3("load", d2);
              break;
            case "details":
              D$3("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$3("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$3("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$3("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2)
            if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
                d2.textContent,
                h2,
                a2
              ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$3("scroll", d2);
            }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          Aj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$3("cancel", a2);
                D$3("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$3("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++)
                  D$3(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$3("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$3(
                  "error",
                  a2
                );
                D$3("load", a2);
                e2 = d2;
                break;
              case "details":
                D$3("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$3("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$3({}, d2, { value: void 0 });
                D$3("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$3("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2)
              if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$3("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
              }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode)
        Dj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode)
          throw Error(p$5(166));
        c2 = Hh(Gh.current);
        Hh(Eh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2)
              switch (a2.tag) {
                case 3:
                  Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                  break;
                case 5:
                  true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
              }
          }
          f2 && (b2.flags |= 4);
        } else
          d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$1(b2);
      return null;
    case 13:
      E$2(M$2);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$2 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128))
          Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2)
              throw Error(p$5(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2)
              throw Error(p$5(317));
            f2[Of] = b2;
          } else
            Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else
          null !== zg && (Gj(zg), zg = null), f2 = true;
        if (!f2)
          return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128))
        return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (M$2.current & 1) ? 0 === T$3 && (T$3 = 3) : uj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return Jh(), Bj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return Rg(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E$2(M$2);
      f2 = b2.memoizedState;
      if (null === f2)
        return S$1(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2)
        if (d2)
          Ej(f2, false);
        else {
          if (0 !== T$3 || null !== a2 && 0 !== (a2.flags & 128))
            for (a2 = b2.child; null !== a2; ) {
              g2 = Mh(a2);
              if (null !== g2) {
                b2.flags |= 128;
                Ej(f2, false);
                d2 = g2.updateQueue;
                null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
                b2.subtreeFlags = 0;
                d2 = c2;
                for (c2 = b2.child; null !== c2; )
                  f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
                G$3(M$2, M$2.current & 1 | 2);
                return b2.child;
              }
              a2 = a2.sibling;
            }
          null !== f2.tail && B$3() > Hj && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        }
      else {
        if (!d2)
          if (a2 = Mh(g2), null !== a2) {
            if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Ej(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$2)
              return S$1(b2), null;
          } else
            2 * B$3() - f2.renderingStartTime > Hj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Ej(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail)
        return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B$3(), b2.sibling = null, c2 = M$2.current, G$3(M$2, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Ij(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (gj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$5(156, b2.tag));
}
function Jj(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return Jh(), E$2(Wf), E$2(H$2), Oh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Lh(b2), null;
    case 13:
      E$2(M$2);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate)
          throw Error(p$5(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$2(M$2), null;
    case 4:
      return Jh(), null;
    case 10:
      return Rg(b2.type._context), null;
    case 22:
    case 23:
      return Ij(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Kj = false, U$3 = false, Lj = "function" === typeof WeakSet ? WeakSet : Set, V$2 = null;
function Mj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2)
    if ("function" === typeof c2)
      try {
        c2(null);
      } catch (d2) {
        W$3(a2, b2, d2);
      }
    else
      c2.current = null;
}
function Nj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W$3(a2, b2, d2);
  }
}
var Oj = false;
function Pj(a2, b2) {
  Cf = dd;
  a2 = Me$2();
  if (Ne$2(a2)) {
    if ("selectionStart" in a2)
      var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else
      a: {
        c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
        var d2 = c2.getSelection && c2.getSelection();
        if (d2 && 0 !== d2.rangeCount) {
          c2 = d2.anchorNode;
          var e2 = d2.anchorOffset, f2 = d2.focusNode;
          d2 = d2.focusOffset;
          try {
            c2.nodeType, f2.nodeType;
          } catch (F2) {
            c2 = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
          b:
            for (; ; ) {
              for (var y2; ; ) {
                q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
                q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
                3 === q2.nodeType && (g2 += q2.nodeValue.length);
                if (null === (y2 = q2.firstChild))
                  break;
                r2 = q2;
                q2 = y2;
              }
              for (; ; ) {
                if (q2 === a2)
                  break b;
                r2 === c2 && ++l2 === e2 && (h2 = g2);
                r2 === f2 && ++m2 === d2 && (k2 = g2);
                if (null !== (y2 = q2.nextSibling))
                  break;
                q2 = r2;
                r2 = q2.parentNode;
              }
              q2 = y2;
            }
          c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
        } else
          c2 = null;
      }
    c2 = c2 || { start: 0, end: 0 };
  } else
    c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$2 = b2; null !== V$2; )
    if (b2 = V$2, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2)
      a2.return = b2, V$2 = a2;
    else
      for (; null !== V$2; ) {
        b2 = V$2;
        try {
          var n2 = b2.alternate;
          if (0 !== (b2.flags & 1024))
            switch (b2.tag) {
              case 0:
              case 11:
              case 15:
                break;
              case 1:
                if (null !== n2) {
                  var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Lg(b2.type, t2), J2);
                  x2.__reactInternalSnapshotBeforeUpdate = w2;
                }
                break;
              case 3:
                var u2 = b2.stateNode.containerInfo;
                1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
                break;
              case 5:
              case 6:
              case 4:
              case 17:
                break;
              default:
                throw Error(p$5(163));
            }
        } catch (F2) {
          W$3(b2, b2.return, F2);
        }
        a2 = b2.sibling;
        if (null !== a2) {
          a2.return = b2.return;
          V$2 = a2;
          break;
        }
        V$2 = b2.return;
      }
  n2 = Oj;
  Oj = false;
  return n2;
}
function Qj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Nj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Rj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Sj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Tj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Tj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Uj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Vj(a2) {
  a:
    for (; ; ) {
      for (; null === a2.sibling; ) {
        if (null === a2.return || Uj(a2.return))
          return null;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
        if (a2.flags & 2)
          continue a;
        if (null === a2.child || 4 === a2.tag)
          continue a;
        else
          a2.child.return = a2, a2 = a2.child;
      }
      if (!(a2.flags & 2))
        return a2.stateNode;
    }
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Wj(a2, b2, c2), a2 = a2.sibling;
}
function Xj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2)
    a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2))
    for (Xj(a2, b2, c2), a2 = a2.sibling; null !== a2; )
      Xj(a2, b2, c2), a2 = a2.sibling;
}
var X$3 = null, Yj = false;
function Zj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; )
    ak(a2, b2, c2), c2 = c2.sibling;
}
function ak(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount)
    try {
      lc.onCommitFiberUnmount(kc, c2);
    } catch (h2) {
    }
  switch (c2.tag) {
    case 5:
      U$3 || Mj(c2, b2);
    case 6:
      var d2 = X$3, e2 = Yj;
      X$3 = null;
      Zj(a2, b2, c2);
      X$3 = d2;
      Yj = e2;
      null !== X$3 && (Yj ? (a2 = X$3, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$3.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$3 && (Yj ? (a2 = X$3, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$3, c2.stateNode));
      break;
    case 4:
      d2 = X$3;
      e2 = Yj;
      X$3 = c2.stateNode.containerInfo;
      Yj = true;
      Zj(a2, b2, c2);
      X$3 = d2;
      Yj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$3 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Nj(c2, b2, g2) : 0 !== (f2 & 4) && Nj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Zj(a2, b2, c2);
      break;
    case 1:
      if (!U$3 && (Mj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount))
        try {
          d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
        } catch (h2) {
          W$3(c2, b2, h2);
        }
      Zj(a2, b2, c2);
      break;
    case 21:
      Zj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$3 = (d2 = U$3) || null !== c2.memoizedState, Zj(a2, b2, c2), U$3 = d2) : Zj(a2, b2, c2);
      break;
    default:
      Zj(a2, b2, c2);
  }
}
function bk(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Lj());
    b2.forEach(function(b3) {
      var d2 = ck.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function dk(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2)
    for (var d2 = 0; d2 < c2.length; d2++) {
      var e2 = c2[d2];
      try {
        var f2 = a2, g2 = b2, h2 = g2;
        a:
          for (; null !== h2; ) {
            switch (h2.tag) {
              case 5:
                X$3 = h2.stateNode;
                Yj = false;
                break a;
              case 3:
                X$3 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
              case 4:
                X$3 = h2.stateNode.containerInfo;
                Yj = true;
                break a;
            }
            h2 = h2.return;
          }
        if (null === X$3)
          throw Error(p$5(160));
        ak(f2, g2, e2);
        X$3 = null;
        Yj = false;
        var k2 = e2.alternate;
        null !== k2 && (k2.return = null);
        e2.return = null;
      } catch (l2) {
        W$3(e2, b2, l2);
      }
    }
  if (b2.subtreeFlags & 12854)
    for (b2 = b2.child; null !== b2; )
      ek(b2, a2), b2 = b2.sibling;
}
function ek(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        try {
          Qj(3, a2, a2.return), Rj(3, a2);
        } catch (t2) {
          W$3(a2, a2.return, t2);
        }
        try {
          Qj(5, a2, a2.return);
        } catch (t2) {
          W$3(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      break;
    case 5:
      dk(b2, a2);
      fk(a2);
      d2 & 512 && null !== c2 && Mj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W$3(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2)
          try {
            "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
            vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e2, f2);
                break;
              case "textarea":
                ib(e2, f2);
                break;
              case "select":
                var r2 = e2._wrapperState.wasMultiple;
                e2._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                  e2,
                  !!f2.multiple,
                  f2.defaultValue,
                  true
                ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
            }
            e2[Pf] = f2;
          } catch (t2) {
            W$3(a2, a2.return, t2);
          }
      }
      break;
    case 6:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4) {
        if (null === a2.stateNode)
          throw Error(p$5(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W$3(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      dk(b2, a2);
      fk(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated)
        try {
          bd(b2.containerInfo);
        } catch (t2) {
          W$3(a2, a2.return, t2);
        }
      break;
    case 4:
      dk(b2, a2);
      fk(a2);
      break;
    case 13:
      dk(b2, a2);
      fk(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (gk = B$3()));
      d2 & 4 && bk(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$3 = (l2 = U$3) || m2, dk(b2, a2), U$3 = l2) : dk(b2, a2);
      fk(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1))
          for (V$2 = a2, m2 = a2.child; null !== m2; ) {
            for (q2 = V$2 = m2; null !== V$2; ) {
              r2 = V$2;
              y2 = r2.child;
              switch (r2.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Qj(4, r2, r2.return);
                  break;
                case 1:
                  Mj(r2, r2.return);
                  var n2 = r2.stateNode;
                  if ("function" === typeof n2.componentWillUnmount) {
                    d2 = r2;
                    c2 = r2.return;
                    try {
                      b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                    } catch (t2) {
                      W$3(d2, c2, t2);
                    }
                  }
                  break;
                case 5:
                  Mj(r2, r2.return);
                  break;
                case 22:
                  if (null !== r2.memoizedState) {
                    hk(q2);
                    continue;
                  }
              }
              null !== y2 ? (y2.return = r2, V$2 = y2) : hk(q2);
            }
            m2 = m2.sibling;
          }
        a:
          for (m2 = null, q2 = a2; ; ) {
            if (5 === q2.tag) {
              if (null === m2) {
                m2 = q2;
                try {
                  e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t2) {
                  W$3(a2, a2.return, t2);
                }
              }
            } else if (6 === q2.tag) {
              if (null === m2)
                try {
                  q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
                } catch (t2) {
                  W$3(a2, a2.return, t2);
                }
            } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
              q2.child.return = q2;
              q2 = q2.child;
              continue;
            }
            if (q2 === a2)
              break a;
            for (; null === q2.sibling; ) {
              if (null === q2.return || q2.return === a2)
                break a;
              m2 === q2 && (m2 = null);
              q2 = q2.return;
            }
            m2 === q2 && (m2 = null);
            q2.sibling.return = q2.return;
            q2 = q2.sibling;
          }
      }
      break;
    case 19:
      dk(b2, a2);
      fk(a2);
      d2 & 4 && bk(a2);
      break;
    case 21:
      break;
    default:
      dk(
        b2,
        a2
      ), fk(a2);
  }
}
function fk(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Uj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$5(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Vj(a2);
          Xj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Vj(a2);
          Wj(a2, h2, g2);
          break;
        default:
          throw Error(p$5(161));
      }
    } catch (k2) {
      W$3(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function ik(a2, b2, c2) {
  V$2 = a2;
  jk(a2);
}
function jk(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$2; ) {
    var e2 = V$2, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Kj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$3;
        h2 = Kj;
        var l2 = U$3;
        Kj = g2;
        if ((U$3 = k2) && !l2)
          for (V$2 = e2; null !== V$2; )
            g2 = V$2, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? kk(e2) : null !== k2 ? (k2.return = g2, V$2 = k2) : kk(e2);
        for (; null !== f2; )
          V$2 = f2, jk(f2), f2 = f2.sibling;
        V$2 = e2;
        Kj = h2;
        U$3 = l2;
      }
      lk(a2);
    } else
      0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$2 = f2) : lk(a2);
  }
}
function lk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772))
          switch (b2.tag) {
            case 0:
            case 11:
            case 15:
              U$3 || Rj(5, b2);
              break;
            case 1:
              var d2 = b2.stateNode;
              if (b2.flags & 4 && !U$3)
                if (null === c2)
                  d2.componentDidMount();
                else {
                  var e2 = b2.elementType === b2.type ? c2.memoizedProps : Lg(b2.type, c2.memoizedProps);
                  d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
                }
              var f2 = b2.updateQueue;
              null !== f2 && ih(b2, f2, d2);
              break;
            case 3:
              var g2 = b2.updateQueue;
              if (null !== g2) {
                c2 = null;
                if (null !== b2.child)
                  switch (b2.child.tag) {
                    case 5:
                      c2 = b2.child.stateNode;
                      break;
                    case 1:
                      c2 = b2.child.stateNode;
                  }
                ih(b2, g2, c2);
              }
              break;
            case 5:
              var h2 = b2.stateNode;
              if (null === c2 && b2.flags & 4) {
                c2 = h2;
                var k2 = b2.memoizedProps;
                switch (b2.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c2.focus();
                    break;
                  case "img":
                    k2.src && (c2.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (null === b2.memoizedState) {
                var l2 = b2.alternate;
                if (null !== l2) {
                  var m2 = l2.memoizedState;
                  if (null !== m2) {
                    var q2 = m2.dehydrated;
                    null !== q2 && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p$5(163));
          }
        U$3 || b2.flags & 512 && Sj(b2);
      } catch (r2) {
        W$3(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
function hk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$2 = c2;
      break;
    }
    V$2 = b2.return;
  }
}
function kk(a2) {
  for (; null !== V$2; ) {
    var b2 = V$2;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Rj(4, b2);
          } catch (k2) {
            W$3(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W$3(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$3(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Sj(b2);
          } catch (k2) {
            W$3(b2, g2, k2);
          }
      }
    } catch (k2) {
      W$3(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$2 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$2 = h2;
      break;
    }
    V$2 = b2.return;
  }
}
var mk = Math.ceil, nk = ua.ReactCurrentDispatcher, ok = ua.ReactCurrentOwner, pk = ua.ReactCurrentBatchConfig, K$2 = 0, R$2 = null, Y$1 = null, Z$3 = 0, gj = 0, fj = Uf(0), T$3 = 0, qk = null, hh = 0, rk = 0, sk = 0, tk = null, uk = null, gk = 0, Hj = Infinity, vk = null, Pi = false, Qi = null, Si = null, wk = false, xk = null, yk = 0, zk = 0, Ak = null, Bk = -1, Ck = 0;
function L$3() {
  return 0 !== (K$2 & 6) ? B$3() : -1 !== Bk ? Bk : Bk = B$3();
}
function lh(a2) {
  if (0 === (a2.mode & 1))
    return 1;
  if (0 !== (K$2 & 2) && 0 !== Z$3)
    return Z$3 & -Z$3;
  if (null !== Kg.transition)
    return 0 === Ck && (Ck = yc()), Ck;
  a2 = C$1;
  if (0 !== a2)
    return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function mh(a2, b2, c2, d2) {
  if (50 < zk)
    throw zk = 0, Ak = null, Error(p$5(185));
  Ac(a2, c2, d2);
  if (0 === (K$2 & 2) || a2 !== R$2)
    a2 === R$2 && (0 === (K$2 & 2) && (rk |= c2), 4 === T$3 && Dk(a2, Z$3)), Ek(a2, d2), 1 === c2 && 0 === K$2 && 0 === (b2.mode & 1) && (Hj = B$3() + 500, fg && jg());
}
function Ek(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === R$2 ? Z$3 : 0);
  if (0 === d2)
    null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2)
      0 === a2.tag ? ig(Fk.bind(null, a2)) : hg(Fk.bind(null, a2)), Jf(function() {
        0 === (K$2 & 6) && jg();
      }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Gk(c2, Hk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Hk(a2, b2) {
  Bk = -1;
  Ck = 0;
  if (0 !== (K$2 & 6))
    throw Error(p$5(327));
  var c2 = a2.callbackNode;
  if (Ik() && a2.callbackNode !== c2)
    return null;
  var d2 = uc(a2, a2 === R$2 ? Z$3 : 0);
  if (0 === d2)
    return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2)
    b2 = Jk(a2, d2);
  else {
    b2 = d2;
    var e2 = K$2;
    K$2 |= 2;
    var f2 = Kk();
    if (R$2 !== a2 || Z$3 !== b2)
      vk = null, Hj = B$3() + 500, Lk(a2, b2);
    do
      try {
        Mk();
        break;
      } catch (h2) {
        Nk(a2, h2);
      }
    while (1);
    Qg();
    nk.current = f2;
    K$2 = e2;
    null !== Y$1 ? b2 = 0 : (R$2 = null, Z$3 = 0, b2 = T$3);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Ok(a2, e2)));
    if (1 === b2)
      throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$3()), c2;
    if (6 === b2)
      Dk(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Pk(e2) && (b2 = Jk(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Ok(a2, f2))), 1 === b2))
        throw c2 = qk, Lk(a2, 0), Dk(a2, d2), Ek(a2, B$3()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$5(345));
        case 2:
          Qk(a2, uk, vk);
          break;
        case 3:
          Dk(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = gk + 500 - B$3(), 10 < b2)) {
            if (0 !== uc(a2, 0))
              break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              L$3();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), b2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 4:
          Dk(a2, d2);
          if ((d2 & 4194240) === d2)
            break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B$3() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * mk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Qk.bind(null, a2, uk, vk), d2);
            break;
          }
          Qk(a2, uk, vk);
          break;
        case 5:
          Qk(a2, uk, vk);
          break;
        default:
          throw Error(p$5(329));
      }
    }
  }
  Ek(a2, B$3());
  return a2.callbackNode === c2 ? Hk.bind(null, a2) : null;
}
function Ok(a2, b2) {
  var c2 = tk;
  a2.current.memoizedState.isDehydrated && (Lk(a2, b2).flags |= 256);
  a2 = Jk(a2, b2);
  2 !== a2 && (b2 = uk, uk = c2, null !== b2 && Gj(b2));
  return a2;
}
function Gj(a2) {
  null === uk ? uk = a2 : uk.push.apply(uk, a2);
}
function Pk(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2))
        for (var d2 = 0; d2 < c2.length; d2++) {
          var e2 = c2[d2], f2 = e2.getSnapshot;
          e2 = e2.value;
          try {
            if (!He$2(f2(), e2))
              return false;
          } catch (g2) {
            return false;
          }
        }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2)
      c2.return = b2, b2 = c2;
    else {
      if (b2 === a2)
        break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2)
          return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Dk(a2, b2) {
  b2 &= ~sk;
  b2 &= ~rk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Fk(a2) {
  if (0 !== (K$2 & 6))
    throw Error(p$5(327));
  Ik();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1))
    return Ek(a2, B$3()), null;
  var c2 = Jk(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Ok(a2, d2));
  }
  if (1 === c2)
    throw c2 = qk, Lk(a2, 0), Dk(a2, b2), Ek(a2, B$3()), c2;
  if (6 === c2)
    throw Error(p$5(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Qk(a2, uk, vk);
  Ek(a2, B$3());
  return null;
}
function Rk(a2, b2) {
  var c2 = K$2;
  K$2 |= 1;
  try {
    return a2(b2);
  } finally {
    K$2 = c2, 0 === K$2 && (Hj = B$3() + 500, fg && jg());
  }
}
function Sk(a2) {
  null !== xk && 0 === xk.tag && 0 === (K$2 & 6) && Ik();
  var b2 = K$2;
  K$2 |= 1;
  var c2 = pk.transition, d2 = C$1;
  try {
    if (pk.transition = null, C$1 = 1, a2)
      return a2();
  } finally {
    C$1 = d2, pk.transition = c2, K$2 = b2, 0 === (K$2 & 6) && jg();
  }
}
function Ij() {
  gj = fj.current;
  E$2(fj);
}
function Lk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y$1)
    for (c2 = Y$1.return; null !== c2; ) {
      var d2 = c2;
      wg(d2);
      switch (d2.tag) {
        case 1:
          d2 = d2.type.childContextTypes;
          null !== d2 && void 0 !== d2 && $f();
          break;
        case 3:
          Jh();
          E$2(Wf);
          E$2(H$2);
          Oh();
          break;
        case 5:
          Lh(d2);
          break;
        case 4:
          Jh();
          break;
        case 13:
          E$2(M$2);
          break;
        case 19:
          E$2(M$2);
          break;
        case 10:
          Rg(d2.type._context);
          break;
        case 22:
        case 23:
          Ij();
      }
      c2 = c2.return;
    }
  R$2 = a2;
  Y$1 = a2 = wh(a2.current, null);
  Z$3 = gj = b2;
  T$3 = 0;
  qk = null;
  sk = rk = hh = 0;
  uk = tk = null;
  if (null !== Wg) {
    for (b2 = 0; b2 < Wg.length; b2++)
      if (c2 = Wg[b2], d2 = c2.interleaved, null !== d2) {
        c2.interleaved = null;
        var e2 = d2.next, f2 = c2.pending;
        if (null !== f2) {
          var g2 = f2.next;
          f2.next = e2;
          d2.next = g2;
        }
        c2.pending = d2;
      }
    Wg = null;
  }
  return a2;
}
function Nk(a2, b2) {
  do {
    var c2 = Y$1;
    try {
      Qg();
      Ph.current = ai$1;
      if (Sh) {
        for (var d2 = N$2.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Sh = false;
      }
      Rh = 0;
      P$3 = O$2 = N$2 = null;
      Th = false;
      Uh = 0;
      ok.current = null;
      if (null === c2 || null === c2.return) {
        T$3 = 1;
        qk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z$3;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Vi(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Wi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Ti(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else
              n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Ti(f2, l2, b2);
              uj();
              break a;
            }
            k2 = Error(p$5(426));
          }
        } else if (I$2 && h2.mode & 1) {
          var J2 = Vi(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Wi(J2, g2, h2, f2, b2);
            Jg(Ki(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ki(k2, h2);
        4 !== T$3 && (T$3 = 2);
        null === tk ? tk = [f2] : tk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Oi(f2, k2, b2);
              fh(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Si || !Si.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Ri(f2, h2, b2);
                fh(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Tk(c2);
    } catch (na) {
      b2 = na;
      Y$1 === c2 && null !== c2 && (Y$1 = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Kk() {
  var a2 = nk.current;
  nk.current = ai$1;
  return null === a2 ? ai$1 : a2;
}
function uj() {
  if (0 === T$3 || 3 === T$3 || 2 === T$3)
    T$3 = 4;
  null === R$2 || 0 === (hh & 268435455) && 0 === (rk & 268435455) || Dk(R$2, Z$3);
}
function Jk(a2, b2) {
  var c2 = K$2;
  K$2 |= 2;
  var d2 = Kk();
  if (R$2 !== a2 || Z$3 !== b2)
    vk = null, Lk(a2, b2);
  do
    try {
      Uk();
      break;
    } catch (e2) {
      Nk(a2, e2);
    }
  while (1);
  Qg();
  K$2 = c2;
  nk.current = d2;
  if (null !== Y$1)
    throw Error(p$5(261));
  R$2 = null;
  Z$3 = 0;
  return T$3;
}
function Uk() {
  for (; null !== Y$1; )
    Vk(Y$1);
}
function Mk() {
  for (; null !== Y$1 && !cc(); )
    Vk(Y$1);
}
function Vk(a2) {
  var b2 = Wk(a2.alternate, a2, gj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Tk(a2) : Y$1 = b2;
  ok.current = null;
}
function Tk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Fj(c2, b2, gj), null !== c2) {
        Y$1 = c2;
        return;
      }
    } else {
      c2 = Jj(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y$1 = c2;
        return;
      }
      if (null !== a2)
        a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$3 = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a2;
  } while (null !== b2);
  0 === T$3 && (T$3 = 5);
}
function Qk(a2, b2, c2) {
  var d2 = C$1, e2 = pk.transition;
  try {
    pk.transition = null, C$1 = 1, Xk(a2, b2, c2, d2);
  } finally {
    pk.transition = e2, C$1 = d2;
  }
  return null;
}
function Xk(a2, b2, c2, d2) {
  do
    Ik();
  while (null !== xk);
  if (0 !== (K$2 & 6))
    throw Error(p$5(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2)
    return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current)
    throw Error(p$5(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === R$2 && (Y$1 = R$2 = null, Z$3 = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || wk || (wk = true, Gk(hc, function() {
    Ik();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = pk.transition;
    pk.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K$2;
    K$2 |= 4;
    ok.current = null;
    Pj(a2, c2);
    ek(c2, a2);
    Oe$2(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    ik(c2);
    dc();
    K$2 = h2;
    C$1 = g2;
    pk.transition = f2;
  } else
    a2.current = c2;
  wk && (wk = false, xk = a2, yk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Si = null);
  mc(c2.stateNode);
  Ek(a2, B$3());
  if (null !== b2)
    for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++)
      e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Pi)
    throw Pi = false, a2 = Qi, Qi = null, a2;
  0 !== (yk & 1) && 0 !== a2.tag && Ik();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === Ak ? zk++ : (zk = 0, Ak = a2) : zk = 0;
  jg();
  return null;
}
function Ik() {
  if (null !== xk) {
    var a2 = Dc(yk), b2 = pk.transition, c2 = C$1;
    try {
      pk.transition = null;
      C$1 = 16 > a2 ? 16 : a2;
      if (null === xk)
        var d2 = false;
      else {
        a2 = xk;
        xk = null;
        yk = 0;
        if (0 !== (K$2 & 6))
          throw Error(p$5(331));
        var e2 = K$2;
        K$2 |= 4;
        for (V$2 = a2.current; null !== V$2; ) {
          var f2 = V$2, g2 = f2.child;
          if (0 !== (V$2.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$2 = l2; null !== V$2; ) {
                  var m2 = V$2;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2)
                    q2.return = m2, V$2 = q2;
                  else
                    for (; null !== V$2; ) {
                      m2 = V$2;
                      var r2 = m2.sibling, y2 = m2.return;
                      Tj(m2);
                      if (m2 === l2) {
                        V$2 = null;
                        break;
                      }
                      if (null !== r2) {
                        r2.return = y2;
                        V$2 = r2;
                        break;
                      }
                      V$2 = y2;
                    }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$2 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2)
            g2.return = f2, V$2 = g2;
          else
            b:
              for (; null !== V$2; ) {
                f2 = V$2;
                if (0 !== (f2.flags & 2048))
                  switch (f2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Qj(9, f2, f2.return);
                  }
                var x2 = f2.sibling;
                if (null !== x2) {
                  x2.return = f2.return;
                  V$2 = x2;
                  break b;
                }
                V$2 = f2.return;
              }
        }
        var w2 = a2.current;
        for (V$2 = w2; null !== V$2; ) {
          g2 = V$2;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2)
            u2.return = g2, V$2 = u2;
          else
            b:
              for (g2 = w2; null !== V$2; ) {
                h2 = V$2;
                if (0 !== (h2.flags & 2048))
                  try {
                    switch (h2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Rj(9, h2);
                    }
                  } catch (na) {
                    W$3(h2, h2.return, na);
                  }
                if (h2 === g2) {
                  V$2 = null;
                  break b;
                }
                var F2 = h2.sibling;
                if (null !== F2) {
                  F2.return = h2.return;
                  V$2 = F2;
                  break b;
                }
                V$2 = h2.return;
              }
        }
        K$2 = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot)
          try {
            lc.onPostCommitFiberRoot(kc, a2);
          } catch (na) {
          }
        d2 = true;
      }
      return d2;
    } finally {
      C$1 = c2, pk.transition = b2;
    }
  }
  return false;
}
function Yk(a2, b2, c2) {
  b2 = Ki(c2, b2);
  b2 = Oi(a2, b2, 1);
  a2 = dh(a2, b2, 1);
  b2 = L$3();
  null !== a2 && (Ac(a2, 1, b2), Ek(a2, b2));
}
function W$3(a2, b2, c2) {
  if (3 === a2.tag)
    Yk(a2, a2, c2);
  else
    for (; null !== b2; ) {
      if (3 === b2.tag) {
        Yk(b2, a2, c2);
        break;
      } else if (1 === b2.tag) {
        var d2 = b2.stateNode;
        if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Si || !Si.has(d2))) {
          a2 = Ki(c2, a2);
          a2 = Ri(b2, a2, 1);
          b2 = dh(b2, a2, 1);
          a2 = L$3();
          null !== b2 && (Ac(b2, 1, a2), Ek(b2, a2));
          break;
        }
      }
      b2 = b2.return;
    }
}
function Ui(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = L$3();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  R$2 === a2 && (Z$3 & c2) === c2 && (4 === T$3 || 3 === T$3 && (Z$3 & 130023424) === Z$3 && 500 > B$3() - gk ? Lk(a2, 0) : sk |= c2);
  Ek(a2, b2);
}
function Zk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = L$3();
  a2 = Zg(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Ek(a2, c2));
}
function vj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Zk(a2, c2);
}
function ck(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$5(314));
  }
  null !== d2 && d2.delete(b2);
  Zk(a2, c2);
}
var Wk;
Wk = function(a2, b2, c2) {
  if (null !== a2)
    if (a2.memoizedProps !== b2.pendingProps || Wf.current)
      Ug = true;
    else {
      if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128))
        return Ug = false, zj(a2, b2, c2);
      Ug = 0 !== (a2.flags & 131072) ? true : false;
    }
  else
    Ug = false, I$2 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      jj(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H$2.current);
      Tg(b2, c2);
      e2 = Xh(null, b2, d2, a2, e2, c2);
      var f2 = bi$1();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, ah(b2), e2.updater = nh, b2.stateNode = e2, e2._reactInternals = b2, rh(b2, d2, a2, c2), b2 = kj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$2 && f2 && vg(b2), Yi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        jj(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = $k(d2);
        a2 = Lg(d2, a2);
        switch (e2) {
          case 0:
            b2 = dj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = ij(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Zi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = aj(null, b2, d2, Lg(d2.type, a2), c2);
            break a;
        }
        throw Error(p$5(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), dj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), ij(a2, b2, d2, e2, c2);
    case 3:
      a: {
        lj(b2);
        if (null === a2)
          throw Error(p$5(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        bh(a2, b2);
        gh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated)
          if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
            e2 = Ki(Error(p$5(423)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else if (d2 !== e2) {
            e2 = Ki(Error(p$5(424)), b2);
            b2 = mj(a2, b2, d2, c2, e2);
            break a;
          } else
            for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$2 = true, zg = null, c2 = Ch(b2, null, d2, c2), b2.child = c2; c2; )
              c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = $i(a2, b2, c2);
            break a;
          }
          Yi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Kh(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), hj(a2, b2), Yi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return pj(a2, b2, c2);
    case 4:
      return Ih(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Bh(b2, null, d2, c2) : Yi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), Zi(a2, b2, d2, e2, c2);
    case 7:
      return Yi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Yi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G$3(Mg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2)
          if (He$2(f2.value, g2)) {
            if (f2.children === e2.children && !Wf.current) {
              b2 = $i(a2, b2, c2);
              break a;
            }
          } else
            for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
              var h2 = f2.dependencies;
              if (null !== h2) {
                g2 = f2.child;
                for (var k2 = h2.firstContext; null !== k2; ) {
                  if (k2.context === d2) {
                    if (1 === f2.tag) {
                      k2 = ch(-1, c2 & -c2);
                      k2.tag = 2;
                      var l2 = f2.updateQueue;
                      if (null !== l2) {
                        l2 = l2.shared;
                        var m2 = l2.pending;
                        null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                        l2.pending = k2;
                      }
                    }
                    f2.lanes |= c2;
                    k2 = f2.alternate;
                    null !== k2 && (k2.lanes |= c2);
                    Sg(
                      f2.return,
                      c2,
                      b2
                    );
                    h2.lanes |= c2;
                    break;
                  }
                  k2 = k2.next;
                }
              } else if (10 === f2.tag)
                g2 = f2.type === b2.type ? null : f2.child;
              else if (18 === f2.tag) {
                g2 = f2.return;
                if (null === g2)
                  throw Error(p$5(341));
                g2.lanes |= c2;
                h2 = g2.alternate;
                null !== h2 && (h2.lanes |= c2);
                Sg(g2, c2, b2);
                g2 = f2.sibling;
              } else
                g2 = f2.child;
              if (null !== g2)
                g2.return = f2;
              else
                for (g2 = f2; null !== g2; ) {
                  if (g2 === b2) {
                    g2 = null;
                    break;
                  }
                  f2 = g2.sibling;
                  if (null !== f2) {
                    f2.return = g2.return;
                    g2 = f2;
                    break;
                  }
                  g2 = g2.return;
                }
              f2 = g2;
            }
        Yi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, Tg(b2, c2), e2 = Vg(e2), d2 = d2(e2), b2.flags |= 1, Yi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Lg(d2, b2.pendingProps), e2 = Lg(d2.type, e2), aj(a2, b2, d2, e2, c2);
    case 15:
      return cj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Lg(d2, e2), jj(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, Tg(b2, c2), ph(b2, d2, e2), rh(b2, d2, e2, c2), kj(null, b2, d2, true, a2, c2);
    case 19:
      return yj(a2, b2, c2);
    case 22:
      return ej(a2, b2, c2);
  }
  throw Error(p$5(156, b2.tag));
};
function Gk(a2, b2) {
  return ac(a2, b2);
}
function al(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new al(a2, b2, c2, d2);
}
function bj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function $k(a2) {
  if ("function" === typeof a2)
    return bj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da)
      return 11;
    if (a2 === Ga)
      return 14;
  }
  return 2;
}
function wh(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function yh(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2)
    bj(a2) && (g2 = 1);
  else if ("string" === typeof a2)
    g2 = 5;
  else
    a:
      switch (a2) {
        case ya:
          return Ah(c2.children, e2, f2, b2);
        case za:
          g2 = 8;
          e2 |= 8;
          break;
        case Aa:
          return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
        case Ea:
          return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
        case Fa:
          return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
        case Ia:
          return qj(c2, e2, f2, b2);
        default:
          if ("object" === typeof a2 && null !== a2)
            switch (a2.$$typeof) {
              case Ba:
                g2 = 10;
                break a;
              case Ca:
                g2 = 9;
                break a;
              case Da:
                g2 = 11;
                break a;
              case Ga:
                g2 = 14;
                break a;
              case Ha:
                g2 = 16;
                d2 = null;
                break a;
            }
          throw Error(p$5(130, null == a2 ? a2 : typeof a2, ""));
      }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Ah(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function qj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function xh(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function zh(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function bl(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function cl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new bl(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  ah(f2);
  return a2;
}
function dl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function el(a2) {
  if (!a2)
    return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag)
      throw Error(p$5(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$5(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2))
      return bg(a2, c2, b2);
  }
  return b2;
}
function fl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = cl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = el(null);
  c2 = a2.current;
  d2 = L$3();
  e2 = lh(c2);
  f2 = ch(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  dh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Ek(a2, d2);
  return a2;
}
function gl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = L$3(), g2 = lh(e2);
  c2 = el(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = ch(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = dh(e2, b2, g2);
  null !== a2 && (mh(a2, e2, g2, f2), eh(a2, e2, g2));
  return g2;
}
function hl(a2) {
  a2 = a2.current;
  if (!a2.child)
    return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function il(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function jl(a2, b2) {
  il(a2, b2);
  (a2 = a2.alternate) && il(a2, b2);
}
function kl() {
  return null;
}
var ll = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ml(a2) {
  this._internalRoot = a2;
}
nl.prototype.render = ml.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2)
    throw Error(p$5(409));
  gl(a2, b2, null, null);
};
nl.prototype.unmount = ml.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Sk(function() {
      gl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function nl(a2) {
  this._internalRoot = a2;
}
nl.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++)
      ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function pl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function ql() {
}
function rl(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = hl(g2);
        f2.call(a3);
      };
    }
    var g2 = fl(b2, d2, a2, 0, null, false, false, "", ql);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Sk();
    return g2;
  }
  for (; e2 = a2.lastChild; )
    a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = hl(k2);
      h2.call(a3);
    };
  }
  var k2 = cl(a2, 0, false, null, null, false, false, "", ql);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Sk(function() {
    gl(b2, k2, c2, d2);
  });
  return k2;
}
function sl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = hl(g2);
        h2.call(a3);
      };
    }
    gl(b2, g2, a2, e2);
  } else
    g2 = rl(c2, b2, a2, e2, d2);
  return hl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Ek(b2, B$3()), 0 === (K$2 & 6) && (Hj = B$3() + 500, jg()));
      }
      break;
    case 13:
      Sk(function() {
        var b3 = Zg(a2, 1);
        if (null !== b3) {
          var c3 = L$3();
          mh(b3, a2, 1, c3);
        }
      }), jl(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = Zg(a2, 134217728);
    if (null !== b2) {
      var c2 = L$3();
      mh(b2, a2, 134217728, c2);
    }
    jl(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = lh(a2), c2 = Zg(a2, b2);
    if (null !== c2) {
      var d2 = L$3();
      mh(c2, a2, b2, d2);
    }
    jl(a2, b2);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a2, b2) {
  var c2 = C$1;
  try {
    return C$1 = a2, b2();
  } finally {
    C$1 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; )
          c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2)
              throw Error(p$5(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Rk;
Hb = Sk;
var tl = { usingClientEntryPoint: false, Events: [Cb, ue$2, Db, Eb, Fb, Rk] }, ul = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.2.0", rendererPackageName: "react-dom" };
var vl = { bundleType: ul.bundleType, version: ul.version, rendererPackageName: ul.rendererPackageName, rendererConfig: ul.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: ul.findFiberByHostInstance || kl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.2.0-next-9e3b772b8-20220608" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!wl.isDisabled && wl.supportsFiber)
    try {
      kc = wl.inject(vl), lc = wl;
    } catch (a2) {
    }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!ol(b2))
    throw Error(p$5(200));
  return dl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!ol(a2))
    throw Error(p$5(299));
  var c2 = false, d2 = "", e2 = ll;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = cl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ml(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2)
    return null;
  if (1 === a2.nodeType)
    return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render)
      throw Error(p$5(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$5(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Sk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!ol(a2))
    throw Error(p$5(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = ll;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = fl(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2)
    for (a2 = 0; a2 < d2.length; a2++)
      c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
        c2,
        e2
      );
  return new nl(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!pl(b2))
    throw Error(p$5(200));
  return sl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!pl(a2))
    throw Error(p$5(40));
  return a2._reactRootContainer ? (Sk(function() {
    sl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!pl(c2))
    throw Error(p$5(200));
  if (null == a2 || void 0 === a2._reactInternals)
    throw Error(p$5(38));
  return sl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$5 = reactDomExports;
{
  client.createRoot = m$5.createRoot;
  client.hydrateRoot = m$5.hydrateRoot;
}
/**
 * @remix-run/router v1.9.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash: hash2
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to2) {
    return typeof to2 === "string" ? to2 : createPath(to2);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index) {
  return {
    usr: location.state,
    key: location.key,
    idx: index
  };
}
function createLocation(current, to2, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends$4({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to2 === "string" ? parsePath(to2) : to2, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to2 && to2.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index = getIndex();
  if (index == null) {
    index = 0;
    globalHistory.replaceState(_extends$4({}, globalHistory.state, {
      idx: index
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index;
    index = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to2, state) {
    action = Action.Push;
    let location = createLocation(history.location, to2, state);
    if (validateLocation)
      validateLocation(location, to2);
    index = getIndex() + 1;
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace2(to2, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to2, state);
    if (validateLocation)
      validateLocation(location, to2);
    index = getIndex();
    let historyState = getHistoryState(location, index);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to2) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to2 === "string" ? to2 : createPath(to2);
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to2) {
      return createHref(window2, to2);
    },
    createURL,
    encodeLocation(to2) {
      let url = createURL(to2);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push,
    replace: replace2,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches2 = null;
  for (let i2 = 0; matches2 == null && i2 < branches.length; ++i2) {
    matches2 = matchRouteBranch(
      branches[i2],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches2;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(a2.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:\w+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s2) => s2 === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches2 = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    if (!match2)
      return null;
    Object.assign(matchedParams, match2.params);
    let route = meta.route;
    matches2.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches2;
}
function generatePath(originalPath, params) {
  if (params === void 0) {
    params = {};
  }
  let path = originalPath;
  if (path.endsWith("*") && path !== "*" && !path.endsWith("/*")) {
    warning(false, 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
    path = path.replace(/\*$/, "/*");
  }
  const prefix2 = path.startsWith("/") ? "/" : "";
  const stringify2 = (p2) => p2 == null ? "" : typeof p2 === "string" ? p2 : String(p2);
  const segments = path.split(/\/+/).map((segment, index, array) => {
    const isLastSegment = index === array.length - 1;
    if (isLastSegment && segment === "*") {
      const star2 = "*";
      return stringify2(params[star2]);
    }
    const keyMatch = segment.match(/^:(\w+)(\??)$/);
    if (keyMatch) {
      const [, key, optional] = keyMatch;
      let param = params[key];
      invariant(optional === "?" || param != null, 'Missing ":' + key + '" param');
      return stringify2(param);
    }
    return segment.replace(/\?$/g, "");
  }).filter((segment) => !!segment);
  return prefix2 + segments.join("/");
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2)
    return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = paramNames.reduce((memo, paramName, index) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || "", paramName);
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_2, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error) {
    warning(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to2, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to2 === "string" ? parsePath(to2) : to2;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char2, field, dest, path) {
  return "Cannot include a '" + char2 + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches2) {
  return matches2.filter((match2, index) => index === 0 || match2.route.path && match2.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to2;
  if (typeof toArg === "string") {
    to2 = parsePath(toArg);
  } else {
    to2 = _extends$4({}, toArg);
    invariant(!to2.pathname || !to2.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to2));
    invariant(!to2.pathname || !to2.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to2));
    invariant(!to2.search || !to2.search.includes("#"), getInvalidPathError("#", "search", "hash", to2));
  }
  let isEmptyPath = toArg === "" || to2.pathname === "";
  let toPathname = isEmptyPath ? "/" : to2.pathname;
  let from2;
  if (isPathRelative || toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to2.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to2, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.16.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to2, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to2, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$3(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: matches2
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches2).map((match2) => match2.pathnameBase));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to2 === "number") {
      navigator2.go(to2);
      return;
    }
    let path = resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useParams() {
  let {
    matches: matches2
  } = reactExports.useContext(RouteContext);
  let routeMatch = matches2[matches2.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to2, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches: matches2
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches2).map((match2) => match2.pathnameBase));
  return reactExports.useMemo(() => resolveTo(to2, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to2, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches2 = matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches2 && matches2.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$3({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error || state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches2, parentMatches, dataRouterState) {
  var _dataRouterState2;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (matches2 == null) {
    var _dataRouterState;
    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {
      matches2 = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches2;
  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m2) => m2.route.id && (errors == null ? void 0 : errors[m2.route.id]));
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match2, index) => {
    let error = match2.route.id ? errors == null ? void 0 : errors[match2.route.id] : null;
    let errorElement = null;
    if (dataRouterState) {
      errorElement = match2.route.errorElement || defaultErrorElement;
    }
    let matches3 = parentMatches.concat(renderedMatches.slice(0, index + 1));
    let getChildren2 = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches3,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren2(),
      routeContext: {
        outlet: null,
        matches: matches3,
        isDataRoute: true
      }
    }) : getChildren2();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook$1.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
  if (error) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to2, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current)
      return;
    if (typeof to2 === "number") {
      router.navigate(to2);
    } else {
      router.navigate(to2, _extends$3({
        fromRouteId: id2
      }, options));
    }
  }, [router, id2]);
  return navigate;
}
function Route(_props) {
  invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
/**
 * React Router DOM v6.16.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init2) {
  if (init2 === void 0) {
    init2 = "";
  }
  return new URLSearchParams(typeof init2 === "string" || Array.isArray(init2) || init2 instanceof URLSearchParams ? init2 : Object.keys(init2).reduce((memo, key) => {
    let value = init2[key];
    return memo.concat(Array.isArray(value) ? value.map((v2) => [key, v2]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    defaultSearchParams.forEach((_2, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach((value) => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
const _excluded$z = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"], _excluded2$3 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_ref) {
  let {
    basename,
    children,
    future,
    window: window2
  } = _ref;
  let historyRef = reactExports.useRef();
  if (historyRef.current == null) {
    historyRef.current = createBrowserHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setStateImpl] = reactExports.useState({
    action: history.action,
    location: history.location
  });
  let {
    v7_startTransition
  } = future || {};
  let setState = reactExports.useCallback((newState) => {
    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);
  }, [setStateImpl, v7_startTransition]);
  reactExports.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
const isBrowser$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link$1 = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref4, ref) {
  let {
    onClick: onClick2,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to: to2,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose$1(_ref4, _excluded$z);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to2 === "string" && ABSOLUTE_URL_REGEX.test(to2)) {
    absoluteHref = to2;
    if (isBrowser$1) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to2 = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e2) {
      }
    }
  }
  let href = useHref(to2, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to2, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick2)
      onClick2(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends$2({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick2 : handleClick,
      ref,
      target
    }))
  );
});
const NavLink = /* @__PURE__ */ reactExports.forwardRef(function NavLinkWithRef(_ref5, ref) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to: to2,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose$1(_ref5, _excluded2$3);
  let path = useResolvedPath(to2, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = reactExports.useContext(DataRouterStateContext);
  let {
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending2 = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending: isPending2
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending2 ? "pending" : null].filter(Boolean).join(" ");
  }
  let style2 = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending: isPending2
  }) : styleProp;
  return /* @__PURE__ */ reactExports.createElement(Link$1, _extends$2({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref,
    style: style2,
    to: to2
  }), typeof children === "function" ? children({
    isActive,
    isPending: isPending2
  }) : children);
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to2, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to2, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to2, {
        replace: replace2,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to2, preventScrollReset, relative]);
}
function useSearchParams(defaultInit) {
  let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = reactExports.useRef(false);
  let location = useLocation();
  let searchParams = reactExports.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
  ), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray$3(to2, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i2);
        ar[i2] = from2[i2];
      }
    }
  return to2.concat(ar || Array.prototype.slice.call(from2));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
function memoize$1(fn2) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache2[arg] === void 0)
      cache2[arg] = fn2(arg);
    return cache2[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = /* @__PURE__ */ memoize$1(
  function(prop) {
    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);
var MS$1 = "-ms-";
var MOZ$1 = "-moz-";
var WEBKIT$1 = "-webkit-";
var COMMENT$1 = "comm";
var RULESET$1 = "rule";
var DECLARATION$1 = "decl";
var IMPORT$1 = "@import";
var KEYFRAMES$1 = "@keyframes";
var LAYER$1 = "@layer";
var abs$1 = Math.abs;
var from$1 = String.fromCharCode;
var assign$1 = Object.assign;
function hash$1(value, length2) {
  return charat$1(value, 0) ^ 45 ? (((length2 << 2 ^ charat$1(value, 0)) << 2 ^ charat$1(value, 1)) << 2 ^ charat$1(value, 2)) << 2 ^ charat$1(value, 3) : 0;
}
function trim$2(value) {
  return value.trim();
}
function match$1(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace$1(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof$1(value, search) {
  return value.indexOf(search);
}
function charat$1(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr$1(value, begin, end) {
  return value.slice(begin, end);
}
function strlen$1(value) {
  return value.length;
}
function sizeof$1(value) {
  return value.length;
}
function append$1(value, array) {
  return array.push(value), value;
}
function combine$1(array, callback) {
  return array.map(callback).join("");
}
function filter(array, pattern) {
  return array.filter(function(value) {
    return !match$1(value, pattern);
  });
}
var line$1 = 1;
var column$1 = 1;
var length$1 = 0;
var position$1 = 0;
var character$1 = 0;
var characters$1 = "";
function node$1(value, root, parent, type, props, children, length2, siblings) {
  return { value, root, parent, type, props, children, line: line$1, column: column$1, length: length2, return: "", siblings };
}
function copy$1(root, props) {
  return assign$1(node$1("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy$1(root.root, { children: [root] });
  append$1(root, root.siblings);
}
function char$1() {
  return character$1;
}
function prev$1() {
  character$1 = position$1 > 0 ? charat$1(characters$1, --position$1) : 0;
  if (column$1--, character$1 === 10)
    column$1 = 1, line$1--;
  return character$1;
}
function next$1() {
  character$1 = position$1 < length$1 ? charat$1(characters$1, position$1++) : 0;
  if (column$1++, character$1 === 10)
    column$1 = 1, line$1++;
  return character$1;
}
function peek$1() {
  return charat$1(characters$1, position$1);
}
function caret$1() {
  return position$1;
}
function slice$1(begin, end) {
  return substr$1(characters$1, begin, end);
}
function token$1(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc$1(value) {
  return line$1 = column$1 = 1, length$1 = strlen$1(characters$1 = value), position$1 = 0, [];
}
function dealloc$1(value) {
  return characters$1 = "", value;
}
function delimit$1(type) {
  return trim$2(slice$1(position$1 - 1, delimiter$1(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace$1(type) {
  while (character$1 = peek$1())
    if (character$1 < 33)
      next$1();
    else
      break;
  return token$1(type) > 2 || token$1(character$1) > 3 ? "" : " ";
}
function escaping$1(index, count) {
  while (--count && next$1())
    if (character$1 < 48 || character$1 > 102 || character$1 > 57 && character$1 < 65 || character$1 > 70 && character$1 < 97)
      break;
  return slice$1(index, caret$1() + (count < 6 && peek$1() == 32 && next$1() == 32));
}
function delimiter$1(type) {
  while (next$1())
    switch (character$1) {
      case type:
        return position$1;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter$1(character$1);
        break;
      case 40:
        if (type === 41)
          delimiter$1(type);
        break;
      case 92:
        next$1();
        break;
    }
  return position$1;
}
function commenter$1(type, index) {
  while (next$1())
    if (type + character$1 === 47 + 10)
      break;
    else if (type + character$1 === 42 + 42 && peek$1() === 47)
      break;
  return "/*" + slice$1(index, position$1 - 1) + "*" + from$1(type === 47 ? type : next$1());
}
function identifier$1(index) {
  while (!token$1(peek$1()))
    next$1();
  return slice$1(index, position$1);
}
function compile$1(value) {
  return dealloc$1(parse$1("", null, null, null, [""], value = alloc$1(value), 0, [0], value));
}
function parse$1(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next$1()) {
      case 40:
        if (previous != 108 && charat$1(characters2, length2 - 1) == 58) {
          if (indexof$1(characters2 += replace$1(delimit$1(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit$1(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace$1(previous);
        break;
      case 92:
        characters2 += escaping$1(caret$1() - 1, 7);
        continue;
      case 47:
        switch (peek$1()) {
          case 42:
          case 47:
            append$1(comment$1(commenter$1(next$1(), caret$1()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen$1(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace$1(characters2, /\f/g, "");
            if (property > 0 && strlen$1(characters2) - length2)
              append$1(property > 32 ? declaration$1(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration$1(replace$1(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append$1(reference = ruleset$1(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$1(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat$1(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$1(value, reference, reference, rule && append$1(ruleset$1(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$1(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen$1(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev$1() == 125)
            continue;
        }
        switch (characters2 += from$1(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen$1(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek$1() === 45)
              characters2 += delimit$1(next$1());
            atrule = peek$1(), offset = length2 = strlen$1(type = characters2 += identifier$1(caret$1())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen$1(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset$1(value, root, parent, index, offset, rules, points, type, props, children, length2, siblings) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof$1(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
    for (var x2 = 0, y2 = substr$1(value, post + 1, post = abs$1(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim$2(j2 > 0 ? rule[x2] + " " + y2 : replace$1(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node$1(value, root, parent, offset === 0 ? RULESET$1 : type, props, children, length2, siblings);
}
function comment$1(value, root, parent, siblings) {
  return node$1(value, root, parent, COMMENT$1, from$1(char$1()), substr$1(value, 2, -2), 0, siblings);
}
function declaration$1(value, root, parent, length2, siblings) {
  return node$1(value, root, parent, DECLARATION$1, substr$1(value, 0, length2), substr$1(value, length2 + 1, -1), length2, siblings);
}
function prefix$1(value, length2, children) {
  switch (hash$1(value, length2)) {
    case 5103:
      return WEBKIT$1 + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT$1 + value + value;
    case 4789:
      return MOZ$1 + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT$1 + value + MOZ$1 + value + MS$1 + value + value;
    case 5936:
      switch (charat$1(value, length2 + 11)) {
        case 114:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT$1 + value + MS$1 + replace$1(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT$1 + value + MS$1 + value + value;
    case 6165:
      return WEBKIT$1 + value + MS$1 + "flex-" + value + value;
    case 5187:
      return WEBKIT$1 + value + replace$1(value, /(\w+).+(:[^]+)/, WEBKIT$1 + "box-$1$2" + MS$1 + "flex-$1$2") + value;
    case 5443:
      return WEBKIT$1 + value + MS$1 + "flex-item-" + replace$1(value, /flex-|-self/g, "") + (!match$1(value, /flex-|baseline/) ? MS$1 + "grid-row-" + replace$1(value, /flex-|-self/g, "") : "") + value;
    case 4675:
      return WEBKIT$1 + value + MS$1 + "flex-line-pack" + replace$1(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT$1 + value + MS$1 + replace$1(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT$1 + value + MS$1 + replace$1(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT$1 + "box-" + replace$1(value, "-grow", "") + WEBKIT$1 + value + MS$1 + replace$1(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT$1 + replace$1(value, /([^-])(transform)/g, "$1" + WEBKIT$1 + "$2") + value;
    case 6187:
      return replace$1(replace$1(replace$1(value, /(zoom-|grab)/, WEBKIT$1 + "$1"), /(image-set)/, WEBKIT$1 + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace$1(value, /(image-set\([^]*)/, WEBKIT$1 + "$1$`$1");
    case 4968:
      return replace$1(replace$1(value, /(.+:)(flex-)?(.*)/, WEBKIT$1 + "box-pack:$3" + MS$1 + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT$1 + value + value;
    case 4200:
      if (!match$1(value, /flex-|baseline/))
        return MS$1 + "grid-column-align" + substr$1(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS$1 + replace$1(value, "template-", "") + value;
    case 4384:
    case 3616:
      if (children && children.some(function(element, index) {
        return length2 = index, match$1(element.props, /grid-\w+-end/);
      })) {
        return ~indexof$1(value + (children = children[length2].value), "span") ? value : MS$1 + replace$1(value, "-start", "") + value + MS$1 + "grid-row-span:" + (~indexof$1(children, "span") ? match$1(children, /\d+/) : +match$1(children, /\d+/) - +match$1(value, /\d+/)) + ";";
      }
      return MS$1 + replace$1(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match$1(element.props, /grid-\w+-start/);
      }) ? value : MS$1 + replace$1(replace$1(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace$1(value, /(.+)-inline(.+)/, WEBKIT$1 + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen$1(value) - 1 - length2 > 6)
        switch (charat$1(value, length2 + 1)) {
          case 109:
            if (charat$1(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace$1(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT$1 + "$2-$3$1" + MOZ$1 + (charat$1(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof$1(value, "stretch") ? prefix$1(replace$1(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace$1(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a2, b2, c2, d2, e2, f2) {
        return MS$1 + a2 + ":" + b2 + f2 + (c2 ? MS$1 + a2 + "-span:" + (d2 ? e2 : +e2 - +b2) + f2 : "") + value;
      });
    case 4949:
      if (charat$1(value, length2 + 6) === 121)
        return replace$1(value, ":", ":" + WEBKIT$1) + value;
      break;
    case 6444:
      switch (charat$1(value, charat$1(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace$1(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT$1 + (charat$1(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT$1 + "$2$3$1" + MS$1 + "$2box$3") + value;
        case 100:
          return replace$1(value, ":", ":" + MS$1) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace$1(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}
function serialize$1(children, callback) {
  var output = "";
  for (var i2 = 0; i2 < children.length; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify$1(element, index, children, callback) {
  switch (element.type) {
    case LAYER$1:
      if (element.children.length)
        break;
    case IMPORT$1:
    case DECLARATION$1:
      return element.return = element.return || element.value;
    case COMMENT$1:
      return "";
    case KEYFRAMES$1:
      return element.return = element.value + "{" + serialize$1(element.children, callback) + "}";
    case RULESET$1:
      if (!strlen$1(element.value = element.props.join(",")))
        return "";
  }
  return strlen$1(children = serialize$1(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware$1(collection) {
  var length2 = sizeof$1(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet$1(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer$1(element, index, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION$1:
          element.return = prefix$1(element.value, element.length, children);
          return;
        case KEYFRAMES$1:
          return serialize$1([copy$1(element, { value: replace$1(element.value, "@", "@" + WEBKIT$1) })], callback);
        case RULESET$1:
          if (element.length)
            return combine$1(children = element.props, function(value) {
              switch (match$1(value, callback = /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  lift(copy$1(element, { props: [replace$1(value, /:(read-\w+)/, ":" + MOZ$1 + "$1")] }));
                  lift(copy$1(element, { props: [value] }));
                  assign$1(element, { props: filter(children, callback) });
                  break;
                case "::placeholder":
                  lift(copy$1(element, { props: [replace$1(value, /:(plac\w+)/, ":" + WEBKIT$1 + "input-$1")] }));
                  lift(copy$1(element, { props: [replace$1(value, /:(plac\w+)/, ":" + MOZ$1 + "$1")] }));
                  lift(copy$1(element, { props: [replace$1(value, /:(plac\w+)/, MS$1 + "input-$1")] }));
                  lift(copy$1(element, { props: [value] }));
                  assign$1(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var f$3 = "undefined" != typeof process && void 0 !== process.env && ({}.REACT_APP_SC_ATTR || {}.SC_ATTR) || "data-styled", y$2 = "undefined" != typeof window && "HTMLElement" in window, v$4 = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== {}.REACT_APP_SC_DISABLE_SPEEDY && "" !== {}.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== {}.REACT_APP_SC_DISABLE_SPEEDY && {}.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== {}.SC_DISABLE_SPEEDY && "" !== {}.SC_DISABLE_SPEEDY ? "false" !== {}.SC_DISABLE_SPEEDY && {}.SC_DISABLE_SPEEDY : false), g$3 = {}, E$1 = Object.freeze([]), N$1 = Object.freeze({});
function P$2(e2, t2, n2) {
  return void 0 === n2 && (n2 = N$1), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
}
var _$2 = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), C = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, I$1 = /(^-|-$)/g;
function A$2(e2) {
  return e2.replace(C, "-").replace(I$1, "");
}
var O$1 = /(a)(d)/gi, D$2 = function(e2) {
  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
};
function R$1(e2) {
  var t2, n2 = "";
  for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0)
    n2 = D$2(t2 % 52) + n2;
  return (D$2(t2 % 52) + n2).replace(O$1, "$1-$2");
}
var T$2, k$4 = function(e2, t2) {
  for (var n2 = t2.length; n2; )
    e2 = 33 * e2 ^ t2.charCodeAt(--n2);
  return e2;
}, j$2 = function(e2) {
  return k$4(5381, e2);
};
function x$2(e2) {
  return R$1(j$2(e2) >>> 0);
}
function V$1(e2) {
  return e2.displayName || e2.name || "Component";
}
function F$2(e2) {
  return "string" == typeof e2 && true;
}
var M$1 = "function" == typeof Symbol && Symbol.for, $$1 = M$1 ? Symbol.for("react.memo") : 60115, z$3 = M$1 ? Symbol.for("react.forward_ref") : 60112, B$2 = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true }, L$2 = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true }, G$2 = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true }, Y = ((T$2 = {})[z$3] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, T$2[$$1] = G$2, T$2);
function W$2(e2) {
  return ("type" in (t2 = e2) && t2.type.$$typeof) === $$1 ? G$2 : "$$typeof" in e2 ? Y[e2.$$typeof] : B$2;
  var t2;
}
var q$6 = Object.defineProperty, H$1 = Object.getOwnPropertyNames, U$2 = Object.getOwnPropertySymbols, J$1 = Object.getOwnPropertyDescriptor, X$2 = Object.getPrototypeOf, Z$2 = Object.prototype;
function K$1(e2, t2, n2) {
  if ("string" != typeof t2) {
    if (Z$2) {
      var o2 = X$2(t2);
      o2 && o2 !== Z$2 && K$1(e2, o2, n2);
    }
    var r2 = H$1(t2);
    U$2 && (r2 = r2.concat(U$2(t2)));
    for (var s2 = W$2(e2), i2 = W$2(t2), a2 = 0; a2 < r2.length; ++a2) {
      var c2 = r2[a2];
      if (!(c2 in L$2 || n2 && n2[c2] || i2 && c2 in i2 || s2 && c2 in s2)) {
        var l2 = J$1(t2, c2);
        try {
          q$6(e2, c2, l2);
        } catch (e3) {
        }
      }
    }
  }
  return e2;
}
function Q$2(e2) {
  return "function" == typeof e2;
}
function ee(e2) {
  return "object" == typeof e2 && "styledComponentId" in e2;
}
function te$1(e2, t2) {
  return e2 && t2 ? "".concat(e2, " ").concat(t2) : e2 || t2 || "";
}
function ne$1(e2, t2) {
  if (0 === e2.length)
    return "";
  for (var n2 = e2[0], o2 = 1; o2 < e2.length; o2++)
    n2 += t2 ? t2 + e2[o2] : e2[o2];
  return n2;
}
function oe$1(e2) {
  return null !== e2 && "object" == typeof e2 && e2.constructor.name === Object.name && !("props" in e2 && e2.$$typeof);
}
function re$1(e2, t2, n2) {
  if (void 0 === n2 && (n2 = false), !n2 && !oe$1(e2) && !Array.isArray(e2))
    return t2;
  if (Array.isArray(t2))
    for (var o2 = 0; o2 < t2.length; o2++)
      e2[o2] = re$1(e2[o2], t2[o2]);
  else if (oe$1(t2))
    for (var o2 in t2)
      e2[o2] = re$1(e2[o2], t2[o2]);
  return e2;
}
function se$1(e2, t2) {
  Object.defineProperty(e2, "toString", { value: t2 });
}
function ce$1(t2) {
  for (var n2 = [], o2 = 1; o2 < arguments.length; o2++)
    n2[o2 - 1] = arguments[o2];
  return new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t2, " for more information.").concat(n2.length > 0 ? " Args: ".concat(n2.join(", ")) : ""));
}
var le$1 = function() {
  function e2(e3) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
  }
  return e2.prototype.indexOfGroup = function(e3) {
    for (var t2 = 0, n2 = 0; n2 < e3; n2++)
      t2 += this.groupSizes[n2];
    return t2;
  }, e2.prototype.insertRules = function(e3, t2) {
    if (e3 >= this.groupSizes.length) {
      for (var n2 = this.groupSizes, o2 = n2.length, r2 = o2; e3 >= r2; )
        if ((r2 <<= 1) < 0)
          throw ce$1(16, "".concat(e3));
      this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n2), this.length = r2;
      for (var s2 = o2; s2 < r2; s2++)
        this.groupSizes[s2] = 0;
    }
    for (var i2 = this.indexOfGroup(e3 + 1), a2 = (s2 = 0, t2.length); s2 < a2; s2++)
      this.tag.insertRule(i2, t2[s2]) && (this.groupSizes[e3]++, i2++);
  }, e2.prototype.clearGroup = function(e3) {
    if (e3 < this.length) {
      var t2 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), o2 = n2 + t2;
      this.groupSizes[e3] = 0;
      for (var r2 = n2; r2 < o2; r2++)
        this.tag.deleteRule(n2);
    }
  }, e2.prototype.getGroup = function(e3) {
    var t2 = "";
    if (e3 >= this.length || 0 === this.groupSizes[e3])
      return t2;
    for (var n2 = this.groupSizes[e3], o2 = this.indexOfGroup(e3), r2 = o2 + n2, s2 = o2; s2 < r2; s2++)
      t2 += "".concat(this.tag.getRule(s2)).concat("/*!sc*/\n");
    return t2;
  }, e2;
}(), ue$1 = /* @__PURE__ */ new Map(), pe$1 = /* @__PURE__ */ new Map(), de = 1, he$1 = function(e2) {
  if (ue$1.has(e2))
    return ue$1.get(e2);
  for (; pe$1.has(de); )
    de++;
  var t2 = de++;
  return ue$1.set(e2, t2), pe$1.set(t2, e2), t2;
}, fe$1 = function(e2, t2) {
  ue$1.set(e2, t2), pe$1.set(t2, e2);
}, me$1 = "style[".concat(f$3, "][").concat("data-styled-version", '="').concat("6.1.0", '"]'), ye$1 = new RegExp("^".concat(f$3, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), ve$1 = function(e2, t2, n2) {
  for (var o2, r2 = n2.split(","), s2 = 0, i2 = r2.length; s2 < i2; s2++)
    (o2 = r2[s2]) && e2.registerName(t2, o2);
}, ge$1 = function(e2, t2) {
  for (var n2, o2 = (null !== (n2 = t2.textContent) && void 0 !== n2 ? n2 : "").split("/*!sc*/\n"), r2 = [], s2 = 0, i2 = o2.length; s2 < i2; s2++) {
    var a2 = o2[s2].trim();
    if (a2) {
      var c2 = a2.match(ye$1);
      if (c2) {
        var l2 = 0 | parseInt(c2[1], 10), u2 = c2[2];
        0 !== l2 && (fe$1(u2, l2), ve$1(e2, u2, c2[3]), e2.getTag().insertRules(l2, r2)), r2.length = 0;
      } else
        r2.push(a2);
    }
  }
};
function Se$1() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
var we$1 = function(e2) {
  var t2 = document.head, n2 = e2 || t2, o2 = document.createElement("style"), r2 = function(e3) {
    var t3 = Array.from(e3.querySelectorAll("style[".concat(f$3, "]")));
    return t3[t3.length - 1];
  }(n2), s2 = void 0 !== r2 ? r2.nextSibling : null;
  o2.setAttribute(f$3, "active"), o2.setAttribute("data-styled-version", "6.1.0");
  var i2 = Se$1();
  return i2 && o2.setAttribute("nonce", i2), n2.insertBefore(o2, s2), o2;
}, be$1 = function() {
  function e2(e3) {
    this.element = we$1(e3), this.element.appendChild(document.createTextNode("")), this.sheet = function(e4) {
      if (e4.sheet)
        return e4.sheet;
      for (var t2 = document.styleSheets, n2 = 0, o2 = t2.length; n2 < o2; n2++) {
        var r2 = t2[n2];
        if (r2.ownerNode === e4)
          return r2;
      }
      throw ce$1(17);
    }(this.element), this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    try {
      return this.sheet.insertRule(t2, e3), this.length++, true;
    } catch (e4) {
      return false;
    }
  }, e2.prototype.deleteRule = function(e3) {
    this.sheet.deleteRule(e3), this.length--;
  }, e2.prototype.getRule = function(e3) {
    var t2 = this.sheet.cssRules[e3];
    return t2 && t2.cssText ? t2.cssText : "";
  }, e2;
}(), Ee$1 = function() {
  function e2(e3) {
    this.element = we$1(e3), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    if (e3 <= this.length && e3 >= 0) {
      var n2 = document.createTextNode(t2);
      return this.element.insertBefore(n2, this.nodes[e3] || null), this.length++, true;
    }
    return false;
  }, e2.prototype.deleteRule = function(e3) {
    this.element.removeChild(this.nodes[e3]), this.length--;
  }, e2.prototype.getRule = function(e3) {
    return e3 < this.length ? this.nodes[e3].textContent : "";
  }, e2;
}(), Ne$1 = function() {
  function e2(e3) {
    this.rules = [], this.length = 0;
  }
  return e2.prototype.insertRule = function(e3, t2) {
    return e3 <= this.length && (this.rules.splice(e3, 0, t2), this.length++, true);
  }, e2.prototype.deleteRule = function(e3) {
    this.rules.splice(e3, 1), this.length--;
  }, e2.prototype.getRule = function(e3) {
    return e3 < this.length ? this.rules[e3] : "";
  }, e2;
}(), Pe$1 = y$2, _e$1 = { isServer: !y$2, useCSSOMInjection: !v$4 }, Ce = function() {
  function e2(e3, n2, o2) {
    void 0 === e3 && (e3 = N$1), void 0 === n2 && (n2 = {});
    var r2 = this;
    this.options = __assign(__assign({}, _e$1), e3), this.gs = n2, this.names = new Map(o2), this.server = !!e3.isServer, !this.server && y$2 && Pe$1 && (Pe$1 = false, function(e4) {
      for (var t2 = document.querySelectorAll(me$1), n3 = 0, o3 = t2.length; n3 < o3; n3++) {
        var r3 = t2[n3];
        r3 && "active" !== r3.getAttribute(f$3) && (ge$1(e4, r3), r3.parentNode && r3.parentNode.removeChild(r3));
      }
    }(this)), se$1(this, function() {
      return function(e4) {
        for (var t2 = e4.getTag(), n3 = t2.length, o3 = "", r3 = function(n4) {
          var r4 = function(e5) {
            return pe$1.get(e5);
          }(n4);
          if (void 0 === r4)
            return "continue";
          var s3 = e4.names.get(r4), i2 = t2.getGroup(n4);
          if (void 0 === s3 || 0 === i2.length)
            return "continue";
          var a2 = "".concat(f$3, ".g").concat(n4, '[id="').concat(r4, '"]'), c2 = "";
          void 0 !== s3 && s3.forEach(function(e5) {
            e5.length > 0 && (c2 += "".concat(e5, ","));
          }), o3 += "".concat(i2).concat(a2, '{content:"').concat(c2, '"}').concat("/*!sc*/\n");
        }, s2 = 0; s2 < n3; s2++)
          r3(s2);
        return o3;
      }(r2);
    });
  }
  return e2.registerId = function(e3) {
    return he$1(e3);
  }, e2.prototype.reconstructWithOptions = function(n2, o2) {
    return void 0 === o2 && (o2 = true), new e2(__assign(__assign({}, this.options), n2), this.gs, o2 && this.names || void 0);
  }, e2.prototype.allocateGSInstance = function(e3) {
    return this.gs[e3] = (this.gs[e3] || 0) + 1;
  }, e2.prototype.getTag = function() {
    return this.tag || (this.tag = (e3 = function(e4) {
      var t2 = e4.useCSSOMInjection, n2 = e4.target;
      return e4.isServer ? new Ne$1(n2) : t2 ? new be$1(n2) : new Ee$1(n2);
    }(this.options), new le$1(e3)));
    var e3;
  }, e2.prototype.hasNameForId = function(e3, t2) {
    return this.names.has(e3) && this.names.get(e3).has(t2);
  }, e2.prototype.registerName = function(e3, t2) {
    if (he$1(e3), this.names.has(e3))
      this.names.get(e3).add(t2);
    else {
      var n2 = /* @__PURE__ */ new Set();
      n2.add(t2), this.names.set(e3, n2);
    }
  }, e2.prototype.insertRules = function(e3, t2, n2) {
    this.registerName(e3, t2), this.getTag().insertRules(he$1(e3), n2);
  }, e2.prototype.clearNames = function(e3) {
    this.names.has(e3) && this.names.get(e3).clear();
  }, e2.prototype.clearRules = function(e3) {
    this.getTag().clearGroup(he$1(e3)), this.clearNames(e3);
  }, e2.prototype.clearTag = function() {
    this.tag = void 0;
  }, e2;
}(), Ie$1 = /&/g, Ae$1 = /^\s*\/\/.*$/gm;
function Oe$1(e2, t2) {
  return e2.map(function(e3) {
    return "rule" === e3.type && (e3.value = "".concat(t2, " ").concat(e3.value), e3.value = e3.value.replaceAll(",", ",".concat(t2, " ")), e3.props = e3.props.map(function(e4) {
      return "".concat(t2, " ").concat(e4);
    })), Array.isArray(e3.children) && "@keyframes" !== e3.type && (e3.children = Oe$1(e3.children, t2)), e3;
  });
}
function De$1(e2) {
  var t2, n2, o2, r2 = void 0 === e2 ? N$1 : e2, s2 = r2.options, i2 = void 0 === s2 ? N$1 : s2, a2 = r2.plugins, c2 = void 0 === a2 ? E$1 : a2, l2 = function(e3, o3, r3) {
    return r3 === n2 || r3.startsWith(n2) && r3.endsWith(n2) && r3.replaceAll(n2, "").length > 0 ? ".".concat(t2) : e3;
  }, u2 = c2.slice();
  u2.push(function(e3) {
    e3.type === RULESET$1 && e3.value.includes("&") && (e3.props[0] = e3.props[0].replace(Ie$1, n2).replace(o2, l2));
  }), i2.prefix && u2.push(prefixer$1), u2.push(stringify$1);
  var p2 = function(e3, r3, s3, a3) {
    void 0 === r3 && (r3 = ""), void 0 === s3 && (s3 = ""), void 0 === a3 && (a3 = "&"), t2 = a3, n2 = r3, o2 = new RegExp("\\".concat(n2, "\\b"), "g");
    var c3 = e3.replace(Ae$1, ""), l3 = compile$1(s3 || r3 ? "".concat(s3, " ").concat(r3, " { ").concat(c3, " }") : c3);
    i2.namespace && (l3 = Oe$1(l3, i2.namespace));
    var p3 = [];
    return serialize$1(l3, middleware$1(u2.concat(rulesheet$1(function(e4) {
      return p3.push(e4);
    })))), p3;
  };
  return p2.hash = c2.length ? c2.reduce(function(e3, t3) {
    return t3.name || ce$1(15), k$4(e3, t3.name);
  }, 5381).toString() : "", p2;
}
var Re$1 = new Ce(), Te$1 = De$1(), ke$1 = React.createContext({ shouldForwardProp: void 0, styleSheet: Re$1, stylis: Te$1 });
ke$1.Consumer;
React.createContext(void 0);
function Ve$1() {
  return reactExports.useContext(ke$1);
}
var Me$1 = function() {
  function e2(e3, t2) {
    var n2 = this;
    this.inject = function(e4, t3) {
      void 0 === t3 && (t3 = Te$1);
      var o2 = n2.name + t3.hash;
      e4.hasNameForId(n2.id, o2) || e4.insertRules(n2.id, o2, t3(n2.rules, o2, "@keyframes"));
    }, this.name = e3, this.id = "sc-keyframes-".concat(e3), this.rules = t2, se$1(this, function() {
      throw ce$1(12, String(n2.name));
    });
  }
  return e2.prototype.getName = function(e3) {
    return void 0 === e3 && (e3 = Te$1), this.name + e3.hash;
  }, e2;
}(), $e$1 = function(e2) {
  return e2 >= "A" && e2 <= "Z";
};
function ze$1(e2) {
  for (var t2 = "", n2 = 0; n2 < e2.length; n2++) {
    var o2 = e2[n2];
    if (1 === n2 && "-" === o2 && "-" === e2[0])
      return e2;
    $e$1(o2) ? t2 += "-" + o2.toLowerCase() : t2 += o2;
  }
  return t2.startsWith("ms-") ? "-" + t2 : t2;
}
var Be$1 = function(e2) {
  return null == e2 || false === e2 || "" === e2;
}, Le$1 = function(t2) {
  var n2, o2, r2 = [];
  for (var s2 in t2) {
    var i2 = t2[s2];
    t2.hasOwnProperty(s2) && !Be$1(i2) && (Array.isArray(i2) && i2.isCss || Q$2(i2) ? r2.push("".concat(ze$1(s2), ":"), i2, ";") : oe$1(i2) ? r2.push.apply(r2, __spreadArray$3(__spreadArray$3(["".concat(s2, " {")], Le$1(i2), false), ["}"], false)) : r2.push("".concat(ze$1(s2), ": ").concat((n2 = s2, null == (o2 = i2) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || n2 in unitlessKeys || n2.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
  }
  return r2;
};
function Ge(e2, t2, n2, o2) {
  if (Be$1(e2))
    return [];
  if (ee(e2))
    return [".".concat(e2.styledComponentId)];
  if (Q$2(e2)) {
    if (!Q$2(s2 = e2) || s2.prototype && s2.prototype.isReactComponent || !t2)
      return [e2];
    var r2 = e2(t2);
    return Ge(r2, t2, n2, o2);
  }
  var s2;
  return e2 instanceof Me$1 ? n2 ? (e2.inject(n2, o2), [e2.getName(o2)]) : [e2] : oe$1(e2) ? Le$1(e2) : Array.isArray(e2) ? Array.prototype.concat.apply(E$1, e2.map(function(e3) {
    return Ge(e3, t2, n2, o2);
  })) : [e2.toString()];
}
function Ye$1(e2) {
  for (var t2 = 0; t2 < e2.length; t2 += 1) {
    var n2 = e2[t2];
    if (Q$2(n2) && !ee(n2))
      return false;
  }
  return true;
}
var We$1 = j$2("6.1.0"), qe$1 = function() {
  function e2(e3, t2, n2) {
    this.rules = e3, this.staticRulesId = "", this.isStatic = (void 0 === n2 || n2.isStatic) && Ye$1(e3), this.componentId = t2, this.baseHash = k$4(We$1, t2), this.baseStyle = n2, Ce.registerId(t2);
  }
  return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
    var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e3, t2, n2) : "";
    if (this.isStatic && !n2.hash)
      if (this.staticRulesId && t2.hasNameForId(this.componentId, this.staticRulesId))
        o2 = te$1(o2, this.staticRulesId);
      else {
        var r2 = ne$1(Ge(this.rules, e3, t2, n2)), s2 = R$1(k$4(this.baseHash, r2) >>> 0);
        if (!t2.hasNameForId(this.componentId, s2)) {
          var i2 = n2(r2, ".".concat(s2), void 0, this.componentId);
          t2.insertRules(this.componentId, s2, i2);
        }
        o2 = te$1(o2, s2), this.staticRulesId = s2;
      }
    else {
      for (var a2 = k$4(this.baseHash, n2.hash), c2 = "", l2 = 0; l2 < this.rules.length; l2++) {
        var u2 = this.rules[l2];
        if ("string" == typeof u2)
          c2 += u2;
        else if (u2) {
          var p2 = ne$1(Ge(u2, e3, t2, n2));
          a2 = k$4(a2, p2 + l2), c2 += p2;
        }
      }
      if (c2) {
        var d2 = R$1(a2 >>> 0);
        t2.hasNameForId(this.componentId, d2) || t2.insertRules(this.componentId, d2, n2(c2, ".".concat(d2), void 0, this.componentId)), o2 = te$1(o2, d2);
      }
    }
    return o2;
  }, e2;
}(), He$1 = React.createContext(void 0);
He$1.Consumer;
function Xe$1(e2) {
  var n2 = React.useContext(He$1), r2 = reactExports.useMemo(function() {
    return function(e3, n3) {
      if (!e3)
        throw ce$1(14);
      if (Q$2(e3)) {
        var o2 = e3(n3);
        return o2;
      }
      if (Array.isArray(e3) || "object" != typeof e3)
        throw ce$1(8);
      return n3 ? __assign(__assign({}, n3), e3) : e3;
    }(e2.theme, n2);
  }, [e2.theme, n2]);
  return e2.children ? React.createElement(He$1.Provider, { value: r2 }, e2.children) : null;
}
var Ze$1 = {}, Ke$1 = /* @__PURE__ */ new Set();
function Qe$1(e2, r2, s2) {
  var i2 = ee(e2), a2 = e2, c2 = !F$2(e2), p2 = r2.attrs, d2 = void 0 === p2 ? E$1 : p2, h2 = r2.componentId, f2 = void 0 === h2 ? function(e3, t2) {
    var n2 = "string" != typeof e3 ? "sc" : A$2(e3);
    Ze$1[n2] = (Ze$1[n2] || 0) + 1;
    var o2 = "".concat(n2, "-").concat(x$2("6.1.0" + n2 + Ze$1[n2]));
    return t2 ? "".concat(t2, "-").concat(o2) : o2;
  }(r2.displayName, r2.parentComponentId) : h2, m2 = r2.displayName;
  void 0 === m2 ? function(e3) {
    return F$2(e3) ? "styled.".concat(e3) : "Styled(".concat(V$1(e3), ")");
  }(e2) : m2;
  var v2 = r2.displayName && r2.componentId ? "".concat(A$2(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2, g2 = i2 && a2.attrs ? a2.attrs.concat(d2).filter(Boolean) : d2, S2 = r2.shouldForwardProp;
  if (i2 && a2.shouldForwardProp) {
    var w2 = a2.shouldForwardProp;
    if (r2.shouldForwardProp) {
      var C2 = r2.shouldForwardProp;
      S2 = function(e3, t2) {
        return w2(e3, t2) && C2(e3, t2);
      };
    } else
      S2 = w2;
  }
  var I2 = new qe$1(s2, v2, i2 ? a2.componentStyle : void 0);
  function O2(e3, r3) {
    return function(e4, r4, s3) {
      var i3 = e4.attrs, a3 = e4.componentStyle, c3 = e4.defaultProps, p3 = e4.foldedComponentIds, d3 = e4.styledComponentId, h3 = e4.target, f3 = React.useContext(He$1), m3 = Ve$1(), y2 = e4.shouldForwardProp || m3.shouldForwardProp;
      var v3 = function(e5, n2, o2) {
        for (var r5, s4 = __assign(__assign({}, n2), { className: void 0, theme: o2 }), i4 = 0; i4 < e5.length; i4 += 1) {
          var a4 = Q$2(r5 = e5[i4]) ? r5(s4) : r5;
          for (var c4 in a4)
            s4[c4] = "className" === c4 ? te$1(s4[c4], a4[c4]) : "style" === c4 ? __assign(__assign({}, s4[c4]), a4[c4]) : a4[c4];
        }
        return n2.className && (s4.className = te$1(s4.className, n2.className)), s4;
      }(i3, r4, P$2(r4, f3, c3) || N$1), g3 = v3.as || h3, S3 = {};
      for (var w3 in v3)
        void 0 === v3[w3] || "$" === w3[0] || "as" === w3 || "theme" === w3 || ("forwardedAs" === w3 ? S3.as = v3.forwardedAs : y2 && !y2(w3, g3) || (S3[w3] = v3[w3], y2 || true));
      var b2 = function(e5, t2) {
        var n2 = Ve$1(), o2 = e5.generateAndInjectStyles(t2, n2.styleSheet, n2.stylis);
        return o2;
      }(a3, v3);
      var E2 = te$1(p3, d3);
      return b2 && (E2 += " " + b2), v3.className && (E2 += " " + v3.className), S3[F$2(g3) && !_$2.has(g3) ? "class" : "className"] = E2, S3.ref = s3, reactExports.createElement(g3, S3);
    }(D2, e3, r3);
  }
  var D2 = React.forwardRef(O2);
  return D2.attrs = g2, D2.componentStyle = I2, D2.shouldForwardProp = S2, D2.foldedComponentIds = i2 ? te$1(a2.foldedComponentIds, a2.styledComponentId) : "", D2.styledComponentId = v2, D2.target = i2 ? a2.target : e2, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e3) {
    this._foldedDefaultProps = i2 ? function(e4) {
      for (var t2 = [], n2 = 1; n2 < arguments.length; n2++)
        t2[n2 - 1] = arguments[n2];
      for (var o2 = 0, r3 = t2; o2 < r3.length; o2++)
        re$1(e4, r3[o2], true);
      return e4;
    }({}, a2.defaultProps, e3) : e3;
  } }), se$1(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c2 && K$1(D2, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
}
function et$1(e2, t2) {
  for (var n2 = [e2[0]], o2 = 0, r2 = t2.length; o2 < r2; o2 += 1)
    n2.push(t2[o2], e2[o2 + 1]);
  return n2;
}
var tt$1 = function(e2) {
  return Object.assign(e2, { isCss: true });
};
function nt$1(t2) {
  for (var n2 = [], o2 = 1; o2 < arguments.length; o2++)
    n2[o2 - 1] = arguments[o2];
  if (Q$2(t2) || oe$1(t2)) {
    var r2 = t2;
    return tt$1(Ge(et$1(E$1, __spreadArray$3([r2], n2, true))));
  }
  var s2 = t2;
  return 0 === n2.length && 1 === s2.length && "string" == typeof s2[0] ? Ge(s2) : tt$1(Ge(et$1(s2, n2)));
}
function ot$1(n2, o2, r2) {
  if (void 0 === r2 && (r2 = N$1), !o2)
    throw ce$1(1, o2);
  var s2 = function(t2) {
    for (var s3 = [], i2 = 1; i2 < arguments.length; i2++)
      s3[i2 - 1] = arguments[i2];
    return n2(o2, r2, nt$1.apply(void 0, __spreadArray$3([t2], s3, false)));
  };
  return s2.attrs = function(e2) {
    return ot$1(n2, o2, __assign(__assign({}, r2), { attrs: Array.prototype.concat(r2.attrs, e2).filter(Boolean) }));
  }, s2.withConfig = function(e2) {
    return ot$1(n2, o2, __assign(__assign({}, r2), e2));
  }, s2;
}
var rt$1 = function(e2) {
  return ot$1(Qe$1, e2);
}, st$1 = rt$1;
_$2.forEach(function(e2) {
  st$1[e2] = rt$1(e2);
});
var it$1 = function() {
  function e2(e3, t2) {
    this.rules = e3, this.componentId = t2, this.isStatic = Ye$1(e3), Ce.registerId(this.componentId + 1);
  }
  return e2.prototype.createStyles = function(e3, t2, n2, o2) {
    var r2 = o2(ne$1(Ge(this.rules, t2, n2, o2)), ""), s2 = this.componentId + e3;
    n2.insertRules(s2, s2, r2);
  }, e2.prototype.removeStyles = function(e3, t2) {
    t2.clearRules(this.componentId + e3);
  }, e2.prototype.renderStyles = function(e3, t2, n2, o2) {
    e3 > 2 && Ce.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t2, n2, o2);
  }, e2;
}();
function at$1(n2) {
  for (var r2 = [], s2 = 1; s2 < arguments.length; s2++)
    r2[s2 - 1] = arguments[s2];
  var i2 = nt$1.apply(void 0, __spreadArray$3([n2], r2, false)), a2 = "sc-global-".concat(x$2(JSON.stringify(i2))), c2 = new it$1(i2, a2);
  var l2 = function(e2) {
    var t2 = Ve$1(), n3 = React.useContext(He$1), r3 = React.useRef(t2.styleSheet.allocateGSInstance(a2)).current;
    return t2.styleSheet.server && u2(r3, e2, t2.styleSheet, n3, t2.stylis), React.useLayoutEffect(function() {
      if (!t2.styleSheet.server)
        return u2(r3, e2, t2.styleSheet, n3, t2.stylis), function() {
          return c2.removeStyles(r3, t2.styleSheet);
        };
    }, [r3, e2, t2.styleSheet, n3, t2.stylis]), null;
  };
  function u2(e2, n3, o2, r3, s3) {
    if (c2.isStatic)
      c2.renderStyles(e2, g$3, o2, s3);
    else {
      var i3 = __assign(__assign({}, n3), { theme: P$2(n3, r3, l2.defaultProps) });
      c2.renderStyles(e2, i3, o2, s3);
    }
  }
  return React.memo(l2);
}
const Layout$1 = st$1.div`
  width: ${(props) => props.$width ? props.$width : "100%"};
  /* max-width: 1920px; */
  margin: 0 auto;
  /* overflow-x: hidden; */
`;
function Layout({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Layout$1, { children });
}
const Header$3 = st$1.header`
  display: flex;
  align-items: center;
  padding: 0 15px;
  border-bottom: 1px solid ${(props) => props.theme.colors.greyF1};
  background-color: ${(props) => props.theme.colors.realWhite};
  @media ${(props) => props.theme.media.mobile} {
    padding: 3.125%;
  }
`;
const MainLogo$1 = st$1.img`
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
const mainLogo = "/assets/mainLogo.svg";
function MainLogo() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MainLogo$1,
    {
      src: mainLogo
    }
  );
}
const ADMIN_BTN_TYPES = {
  edit: "edit",
  add: "add"
};
const DEFAULT_WIDTH = "1267px";
const MODAL_TYPES = {
  createCourse: "createCourse",
  createCompetition: "createCompetition",
  createChapter: "createChapter",
  createTheme: "createTheme",
  editCourse: "editCourse",
  editChapter: "editChapter",
  editTheme: "editTheme",
  newsCategory: "newsCategory"
};
window.matchMedia("(max-width: 768px)").matches;
const USER_ROLES = {
  admin: "admin",
  user: "user"
};
const NAV_LINKS = {
  news: {
    url: "/news",
    name: "Новости",
    icon: {
      withIcon: false,
      iconUrl: ""
    }
  },
  education: {
    url: "/courses",
    name: "Курсы",
    icon: {
      withIcon: false,
      iconUrl: ""
    }
  }
  // tasks: {
  //   url: '/tasks',
  //   name: 'Задачи',
  //   icon: {
  //     withIcon: false,
  //     iconUrl: '',
  //   },
  // },
};
const APHORISMS = [
  {
    text: "Нет большей жизни, чем бороться за свои мечты.",
    author: "Хаяо Миядзаки"
  },
  {
    text: "Если вы ничего не делаете, ничего не происходит.",
    author: "Икути Кэйта"
  },
  {
    text: "Самурай должен быть вежливым, даже когда смерть близка.",
    author: "Ямамото Цунэтомо"
  },
  {
    text: "Если вы будете работать только над тем, что вам нравится, вы никогда не должны будете работать ни дня в своей жизни.",
    author: "Идзамо Томио"
  },
  {
    text: "Но, в конце концов — и я подчеркиваю это — как бы вы ни были хороши или удачливы и как бы вы ни были умны и ловки, ваше дело и его судьба находятся в руках тех людей, которых вы нанимаете.",
    author: "Акио Морита"
  },
  {
    text: "Всю свою жизнь при­леж­но учись. Каж­дый день ста­новись бо­лее ис­кусным, чем ты был за день до это­го, а на сле­ду­ющий день — бо­лее ис­кусным, чем се­год­ня. Со­вер­шенс­тво­вание не име­ет кон­ца.",
    author: "Яма­мото Цу­нэто­мо"
  },
  {
    text: "Нет ничего более постыдного для человека, чем выходить из себя.",
    author: "Сиба Есимаса"
  },
  {
    text: "Искреннее сердце — это драгоценность, которую никогда никуда не спрячешь.",
    author: "Ходзе Сигэтоки"
  },
  {
    text: "Учение для человека — все равно что ветви и листья для дерева. Без него он просто не сможет жить.",
    author: "Такэда Сингэн"
  },
  {
    text: "Даже если у человека нет особых талантов, но он упорно овладевает знанием, он не опозорится перед другими.",
    author: "Сиба Есимаса"
  },
  {
    text: "Во всем надлежит действовать терпеливо.",
    author: "Набэсима Наосигэ"
  },
  {
    text: "Там, где льются изящные стихи, не остается места суесловию",
    author: "Мурасаки Сикибу"
  }
];
var MediaQueries = /* @__PURE__ */ ((MediaQueries2) => {
  MediaQueries2["mobile"] = "(max-width: 768px)";
  MediaQueries2["desktop"] = "(min-width: 768px)";
  return MediaQueries2;
})(MediaQueries || {});
var Steps = /* @__PURE__ */ ((Steps2) => {
  Steps2["chapter"] = "chapter";
  Steps2["theme"] = "theme";
  return Steps2;
})(Steps || {});
const doneIcon = "/assets/done.svg";
const selectIcon = "/assets/accordionIcon.svg";
const TextStyles = nt$1`
  font-size: 18px;
  font-weight: 700;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realBlack};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 5.625vw;
  }
`;
const DarkOverlay = st$1.div`
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0, 0, 0, 0.5);
`;
st$1.div`
  width: 100%;
  max-width: ${(props) => props.$maxWidth};
  height: 100%;
  backdrop-filter: blur(${(props) => props.$blurValue});
`;
const DefaultBtn = st$1.button`
  min-height: 60px;
  padding: 0 3%;
  font-size: 18px;
  font-weight: 700;
  line-height: 100%;
  color: ${(props) => props.theme.colors.realWhite};
  background-color: ${(props) => props.theme.colors.mainBlue};
  border-radius: ${(props) => props.theme.utils.br};
  transition: ${(props) => props.theme.utils.transition};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.6875vw;
  }

  &:hover {
    background-color: ${(props) => props.theme.colors.darkBlue};
  }
`;
st$1.table``;
const Text$6 = st$1.p`
  font-size: 18px;
  font-weight: 700;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realBlack};
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};

  @media ${(props) => props.theme.media.mobile} {
    font-size: 5.625vw;
  }
`;
const Input$4 = st$1.input`
  width: 100%;
  min-height: 60px;
  padding: 19px 29px;
  border: 1px solid ${(props) => props.theme.colors.greyEO};
  font-size: 18px;
  font-weight: 700;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realBlack};
  border-radius: ${(props) => props.theme.utils.br};
  @media ${(props) => props.theme.media.mobile} {
    min-height: 12.5vw;
    padding: 4.0625vw 5.3125vw;
    font-size: 3.75vw;
  }

  &::placeholder {
    color: ${(props) => props.theme.colors.grey93};
  }

  &:focus {
    color: ${(props) => props.theme.colors.realBlack};
    background-color: transparent;
  }
`;
const SvgIcon$2 = st$1.svg.attrs({
  width: "24",
  height: "24",
  viewBox: "0 0 24 24",
  fill: "none"
})`
  path {
    transition: ${(props) => props.theme.utils.transition};
  }
`;
const InputWithState = st$1(Input$4)`
  ${(props) => {
  if (props.$isChanged && props.$isValid) {
    return nt$1`
        color: ${props.theme.colors.grey93};
        background-color: ${props.theme.colors.greyF1};
      `;
  } else if (props.$isChanged) {
    return nt$1`
        border-color: ${props.theme.colors.yRed};
      `;
  }
}}
`;
st$1.button`
  font-size: 18px;
  font-weight: 400;
  line-height: 120%;
  color: ${(props) => props.theme.colors.mainBlue};
  text-decoration: underline;
  background-color: transparent;
  transition: ${(props) => props.theme.utils.transition};

  &:hover {
    text-decoration: unset;
    color: ${(props) => props.theme.colors.darkBlue};
  }
`;
const DefaultContainer = st$1.div`
  width: 100%;
  max-width: ${DEFAULT_WIDTH};
  margin: 0 auto;
`;
const FlexContainer = st$1.div`
  display: flex;
  width: 100%;
`;
const ProgressBar$1 = st$1(FlexContainer)`
  position: relative;
  height: 10px;
  border-radius: 5px;
  background-color: ${(props) => props.theme.colors.greyF1};
  @media ${(props) => props.theme.media.mobile} {
    height: 1.5625vw;
    border-radius: 2.532px;
  }

  &::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: ${(props) => props.$progress + "%"};
    height: 100%;
    border-radius: inherit;
    background-color: ${(props) => props.theme.colors.realBlack};
    transition: width .2s linear;
  }
`;
const Icon$2 = st$1.div`
  display: block;
  width: 24px;
  height: 24px;
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;
  @media ${(props) => props.theme.media.mobile} {
    width: 7.5vw;
    height: 7.5vw;
  }
`;
const DoneIcon$2 = st$1(Icon$2)`
  margin-right: 26px;
  /* margin-left: auto; */
  background-image: url(${doneIcon});
`;
const AccordionIcon = st$1(Icon$2)`
  display: block;
  width: 24px;
  height: 24px;
  margin-right: 5px;
  transition: ${(props) => props.theme.utils.transition};
  transform: ${(props) => props.$active ? "rotate(-180deg)" : "none"};
  background-image: url(${selectIcon});
`;
st$1(Text$6)`
  margin-bottom: 30px;
  font-weight: 400;
  line-height: 150%;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.6875vw;
    padding: 0 3.125vw;
    margin-bottom: 10%;
  }
`;
st$1(FlexContainer)`
  width: 310px;
  height: 400px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.grey93};
  animation: pulse 0.5s ease-in-out infinite alternate;

  @keyframes pulse {
    100% {
      background-color: ${(props) => props.theme.colors.greyEO};
    }
  }
`;
st$1.ol`
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin-bottom: 30px;
  list-style: decimal inside;
`;
st$1.ul`
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin-bottom: 30px;
  list-style: disc inside;
  @media ${(props) => props.theme.media.mobile} {
    gap: 6.25vw;
    padding: 0 3.125vw;
    margin-bottom: 10%;
  }
`;
st$1.li`
  display: list-item;
  ${TextStyles}
  font-weight: 400;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.6875vw;
  }
`;
st$1.img`
  width: 100%;
  margin-bottom: 30px;
  border-radius: ${(props) => props.theme.utils.br};
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 10%;
    border-radius: unset;
  }
`;
st$1(FlexContainer)`
  flex-direction: column;
`;
const LinkContent = st$1(Text$6)`
  display: flex;
  align-items: center;
  position: relative;
  height: 100%;
  padding: 15px 0;
  color: ${(props) => props.$isActive ? props.theme.colors.dark : props.theme.colors.mainBlue};
  transition: color .2s ease-in-out;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0;
    font-weight: ${(props) => props.$isActive ? "700" : "600"};
  }

  &:hover {
    color: ${(props) => props.theme.colors.dark};
  }

  &::before {
    display: ${(props) => props.$isActive ? "block" : "none"};
    position: absolute;
    left: 50%;
    bottom: 0;
    width: 100%;
    height: 0;
    content: '';
    transform: translateX(-50%);
    background-color: ${(props) => props.theme.colors.mainBlue};
    animation: elastic .2s ease-in-out forwards;
    @media ${(props) => props.theme.media.mobile} {
      display: none;
    }
  }

  @keyframes elastic {
    100% {
      height: 4px;
    }
  }
`;
const Icon$1 = st$1(SvgIcon$2)`
  margin-right: 5px;
  path {
    fill: ${(props) => props.$isActive ? props.theme.colors.mainBlue : props.theme.colors.dark};
  }
`;
function CustomNavLink({ url, name, icon, onClick: onClick2 = () => {
} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    NavLink,
    {
      to: url,
      style: () => {
        return { textDecoration: "unset", height: "100%" };
      },
      children: ({ isActive }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(LinkContent, { $isActive: isActive, onClick: onClick2, children: [
        icon.withIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { $isActive: isActive }),
        name
      ] })
    }
  );
}
const Container$M = st$1(FlexContainer)`
  max-width: min(1360px, 73%);
  margin: 0 auto;
  width: 100%;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
const NavBar$1 = st$1.ul`
  display: flex;
  align-items: center;
  gap: 80px;
  height: 1px;
  min-height: 60px;
`;
function Nav$1() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$M, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(NavBar$1, { children: Object.values(NAV_LINKS).map((navLink, index) => /* @__PURE__ */ reactExports.createElement(
    CustomNavLink,
    {
      ...navLink,
      key: index
    }
  )) }) });
}
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$3 = reactExports;
function h$4(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k$3 = "function" === typeof Object.is ? Object.is : h$4, l$3 = e$3.useState, m$4 = e$3.useEffect, n$4 = e$3.useLayoutEffect, p$4 = e$3.useDebugValue;
function q$5(a2, b2) {
  var d2 = b2(), f2 = l$3({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$4(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$4(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$4(function() {
    r$4(c2) && g2({ inst: c2 });
    return a2(function() {
      r$4(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$4(d2);
  return d2;
}
function r$4(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k$3(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$4(a2, b2) {
  return b2();
}
var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$4 : q$5;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$3.useSyncExternalStore ? e$3.useSyncExternalStore : u$3;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
var withSelector = { exports: {} };
var withSelector_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$3 = reactExports, n$3 = shimExports;
function p$3(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$4 = "function" === typeof Object.is ? Object.is : p$3, r$3 = n$3.useSyncExternalStore, t$3 = h$3.useRef, u$2 = h$3.useEffect, v$3 = h$3.useMemo, w$2 = h$3.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t$3(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else
    f2 = c2.current;
  c2 = v$3(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4))
            return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$4(d3, a4))
        return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3))
        return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$3(a2, c2[0], c2[1]);
  u$2(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$2(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
function defaultNoopBatch(callback) {
  callback();
}
let batch = defaultNoopBatch;
const setBatch = (newBatch) => batch = newBatch;
const getBatch = () => batch;
const ContextKey = Symbol.for(`react-redux-context`);
const gT = typeof globalThis !== "undefined" ? globalThis : (
  /* fall back to a per-module scope (pre-8.1 behaviour) if `globalThis` is not available */
  {}
);
function getContext() {
  var _gT$ContextKey;
  if (!reactExports.createContext)
    return {};
  const contextMap = (_gT$ContextKey = gT[ContextKey]) != null ? _gT$ContextKey : gT[ContextKey] = /* @__PURE__ */ new Map();
  let realContext = contextMap.get(reactExports.createContext);
  if (!realContext) {
    realContext = reactExports.createContext(null);
    contextMap.set(reactExports.createContext, realContext);
  }
  return realContext;
}
const ReactReduxContext = /* @__PURE__ */ getContext();
function createReduxContextHook(context = ReactReduxContext) {
  return function useReduxContext2() {
    const contextValue = reactExports.useContext(context);
    return contextValue;
  };
}
const useReduxContext = /* @__PURE__ */ createReduxContextHook();
const notInitialized = () => {
  throw new Error("uSES not initialized!");
};
let useSyncExternalStoreWithSelector = notInitialized;
const initializeUseSelector = (fn2) => {
  useSyncExternalStoreWithSelector = fn2;
};
const refEquality = (a2, b2) => a2 === b2;
function createSelectorHook(context = ReactReduxContext) {
  const useReduxContext$1 = context === ReactReduxContext ? useReduxContext : createReduxContextHook(context);
  return function useSelector2(selector, equalityFnOrOptions = {}) {
    const {
      equalityFn = refEquality,
      stabilityCheck = void 0,
      noopCheck = void 0
    } = typeof equalityFnOrOptions === "function" ? {
      equalityFn: equalityFnOrOptions
    } : equalityFnOrOptions;
    const {
      store: store2,
      subscription,
      getServerState,
      stabilityCheck: globalStabilityCheck,
      noopCheck: globalNoopCheck
    } = useReduxContext$1();
    reactExports.useRef(true);
    const wrappedSelector = reactExports.useCallback({
      [selector.name](state) {
        const selected = selector(state);
        return selected;
      }
    }[selector.name], [selector, globalStabilityCheck, stabilityCheck]);
    const selectedState = useSyncExternalStoreWithSelector(subscription.addNestedSub, store2.getState, getServerState || store2.getState, wrappedSelector, equalityFn);
    reactExports.useDebugValue(selectedState);
    return selectedState;
  };
}
const useSelector = /* @__PURE__ */ createSelectorHook();
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var reactIs$1 = { exports: {} };
var reactIs_production_min$1 = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$2 = "function" === typeof Symbol && Symbol.for, c$2 = b$2 ? Symbol.for("react.element") : 60103, d$3 = b$2 ? Symbol.for("react.portal") : 60106, e$2 = b$2 ? Symbol.for("react.fragment") : 60107, f$2 = b$2 ? Symbol.for("react.strict_mode") : 60108, g$2 = b$2 ? Symbol.for("react.profiler") : 60114, h$2 = b$2 ? Symbol.for("react.provider") : 60109, k$2 = b$2 ? Symbol.for("react.context") : 60110, l$2 = b$2 ? Symbol.for("react.async_mode") : 60111, m$3 = b$2 ? Symbol.for("react.concurrent_mode") : 60111, n$2 = b$2 ? Symbol.for("react.forward_ref") : 60112, p$2 = b$2 ? Symbol.for("react.suspense") : 60113, q$3 = b$2 ? Symbol.for("react.suspense_list") : 60120, r$2 = b$2 ? Symbol.for("react.memo") : 60115, t$2 = b$2 ? Symbol.for("react.lazy") : 60116, v$2 = b$2 ? Symbol.for("react.block") : 60121, w$1 = b$2 ? Symbol.for("react.fundamental") : 60117, x$1 = b$2 ? Symbol.for("react.responder") : 60118, y$1 = b$2 ? Symbol.for("react.scope") : 60119;
function z$2(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c$2:
        switch (a2 = a2.type, a2) {
          case l$2:
          case m$3:
          case e$2:
          case g$2:
          case f$2:
          case p$2:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$2:
              case n$2:
              case t$2:
              case r$2:
              case h$2:
                return a2;
              default:
                return u2;
            }
        }
      case d$3:
        return u2;
    }
  }
}
function A$1(a2) {
  return z$2(a2) === m$3;
}
reactIs_production_min$1.AsyncMode = l$2;
reactIs_production_min$1.ConcurrentMode = m$3;
reactIs_production_min$1.ContextConsumer = k$2;
reactIs_production_min$1.ContextProvider = h$2;
reactIs_production_min$1.Element = c$2;
reactIs_production_min$1.ForwardRef = n$2;
reactIs_production_min$1.Fragment = e$2;
reactIs_production_min$1.Lazy = t$2;
reactIs_production_min$1.Memo = r$2;
reactIs_production_min$1.Portal = d$3;
reactIs_production_min$1.Profiler = g$2;
reactIs_production_min$1.StrictMode = f$2;
reactIs_production_min$1.Suspense = p$2;
reactIs_production_min$1.isAsyncMode = function(a2) {
  return A$1(a2) || z$2(a2) === l$2;
};
reactIs_production_min$1.isConcurrentMode = A$1;
reactIs_production_min$1.isContextConsumer = function(a2) {
  return z$2(a2) === k$2;
};
reactIs_production_min$1.isContextProvider = function(a2) {
  return z$2(a2) === h$2;
};
reactIs_production_min$1.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$2;
};
reactIs_production_min$1.isForwardRef = function(a2) {
  return z$2(a2) === n$2;
};
reactIs_production_min$1.isFragment = function(a2) {
  return z$2(a2) === e$2;
};
reactIs_production_min$1.isLazy = function(a2) {
  return z$2(a2) === t$2;
};
reactIs_production_min$1.isMemo = function(a2) {
  return z$2(a2) === r$2;
};
reactIs_production_min$1.isPortal = function(a2) {
  return z$2(a2) === d$3;
};
reactIs_production_min$1.isProfiler = function(a2) {
  return z$2(a2) === g$2;
};
reactIs_production_min$1.isStrictMode = function(a2) {
  return z$2(a2) === f$2;
};
reactIs_production_min$1.isSuspense = function(a2) {
  return z$2(a2) === p$2;
};
reactIs_production_min$1.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e$2 || a2 === m$3 || a2 === g$2 || a2 === f$2 || a2 === p$2 || a2 === q$3 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t$2 || a2.$$typeof === r$2 || a2.$$typeof === h$2 || a2.$$typeof === k$2 || a2.$$typeof === n$2 || a2.$$typeof === w$1 || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v$2);
};
reactIs_production_min$1.typeOf = z$2;
{
  reactIs$1.exports = reactIs_production_min$1;
}
var reactIsExports = reactIs$1.exports;
var reactIs = reactIsExports;
var FORWARD_REF_STATICS = {
  "$$typeof": true,
  render: true,
  defaultProps: true,
  displayName: true,
  propTypes: true
};
var MEMO_STATICS = {
  "$$typeof": true,
  compare: true,
  defaultProps: true,
  displayName: true,
  propTypes: true,
  type: true
};
var TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var reactIs_production_min = {};
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b$1 = Symbol.for("react.element"), c$1 = Symbol.for("react.portal"), d$2 = Symbol.for("react.fragment"), e$1 = Symbol.for("react.strict_mode"), f$1 = Symbol.for("react.profiler"), g$1 = Symbol.for("react.provider"), h$1 = Symbol.for("react.context"), k$1 = Symbol.for("react.server_context"), l$1 = Symbol.for("react.forward_ref"), m$2 = Symbol.for("react.suspense"), n$1 = Symbol.for("react.suspense_list"), p$1 = Symbol.for("react.memo"), q$2 = Symbol.for("react.lazy"), t$1 = Symbol.for("react.offscreen"), u$1;
u$1 = Symbol.for("react.module.reference");
function v$1(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var r2 = a2.$$typeof;
    switch (r2) {
      case b$1:
        switch (a2 = a2.type, a2) {
          case d$2:
          case f$1:
          case e$1:
          case m$2:
          case n$1:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case h$1:
              case l$1:
              case q$2:
              case p$1:
              case g$1:
                return a2;
              default:
                return r2;
            }
        }
      case c$1:
        return r2;
    }
  }
}
reactIs_production_min.ContextConsumer = h$1;
reactIs_production_min.ContextProvider = g$1;
reactIs_production_min.Element = b$1;
reactIs_production_min.ForwardRef = l$1;
reactIs_production_min.Fragment = d$2;
reactIs_production_min.Lazy = q$2;
reactIs_production_min.Memo = p$1;
reactIs_production_min.Portal = c$1;
reactIs_production_min.Profiler = f$1;
reactIs_production_min.StrictMode = e$1;
reactIs_production_min.Suspense = m$2;
reactIs_production_min.SuspenseList = n$1;
reactIs_production_min.isAsyncMode = function() {
  return false;
};
reactIs_production_min.isConcurrentMode = function() {
  return false;
};
reactIs_production_min.isContextConsumer = function(a2) {
  return v$1(a2) === h$1;
};
reactIs_production_min.isContextProvider = function(a2) {
  return v$1(a2) === g$1;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === b$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return v$1(a2) === l$1;
};
reactIs_production_min.isFragment = function(a2) {
  return v$1(a2) === d$2;
};
reactIs_production_min.isLazy = function(a2) {
  return v$1(a2) === q$2;
};
reactIs_production_min.isMemo = function(a2) {
  return v$1(a2) === p$1;
};
reactIs_production_min.isPortal = function(a2) {
  return v$1(a2) === c$1;
};
reactIs_production_min.isProfiler = function(a2) {
  return v$1(a2) === f$1;
};
reactIs_production_min.isStrictMode = function(a2) {
  return v$1(a2) === e$1;
};
reactIs_production_min.isSuspense = function(a2) {
  return v$1(a2) === m$2;
};
reactIs_production_min.isSuspenseList = function(a2) {
  return v$1(a2) === n$1;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === d$2 || a2 === f$1 || a2 === e$1 || a2 === m$2 || a2 === n$1 || a2 === t$1 || "object" === typeof a2 && null !== a2 && (a2.$$typeof === q$2 || a2.$$typeof === p$1 || a2.$$typeof === g$1 || a2.$$typeof === h$1 || a2.$$typeof === l$1 || a2.$$typeof === u$1 || void 0 !== a2.getModuleId) ? true : false;
};
reactIs_production_min.typeOf = v$1;
function createListenerCollection() {
  const batch2 = getBatch();
  let first = null;
  let last = null;
  return {
    clear() {
      first = null;
      last = null;
    },
    notify() {
      batch2(() => {
        let listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get() {
      let listeners = [];
      let listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe(callback) {
      let isSubscribed = true;
      let listener = last = {
        callback,
        next: null,
        prev: last
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
const nullListeners = {
  notify() {
  },
  get: () => []
};
function createSubscription(store2, parentSub) {
  let unsubscribe;
  let listeners = nullListeners;
  let subscriptionsAmount = 0;
  let selfSubscribed = false;
  function addNestedSub(listener) {
    trySubscribe();
    const cleanupListener = listeners.subscribe(listener);
    let removed = false;
    return () => {
      if (!removed) {
        removed = true;
        cleanupListener();
        tryUnsubscribe();
      }
    };
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return selfSubscribed;
  }
  function trySubscribe() {
    subscriptionsAmount++;
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store2.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    subscriptionsAmount--;
    if (unsubscribe && subscriptionsAmount === 0) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  function trySubscribeSelf() {
    if (!selfSubscribed) {
      selfSubscribed = true;
      trySubscribe();
    }
  }
  function tryUnsubscribeSelf() {
    if (selfSubscribed) {
      selfSubscribed = false;
      tryUnsubscribe();
    }
  }
  const subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe: trySubscribeSelf,
    tryUnsubscribe: tryUnsubscribeSelf,
    getListeners: () => listeners
  };
  return subscription;
}
const canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
const useIsomorphicLayoutEffect$2 = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
function is(x2, y2) {
  if (x2 === y2) {
    return x2 !== 0 || y2 !== 0 || 1 / x2 === 1 / y2;
  } else {
    return x2 !== x2 && y2 !== y2;
  }
}
function shallowEqual(objA, objB) {
  if (is(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (let i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !is(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
function Provider({
  store: store2,
  context,
  children,
  serverState,
  stabilityCheck = "once",
  noopCheck = "once"
}) {
  const contextValue = reactExports.useMemo(() => {
    const subscription = createSubscription(store2);
    return {
      store: store2,
      subscription,
      getServerState: serverState ? () => serverState : void 0,
      stabilityCheck,
      noopCheck
    };
  }, [store2, serverState, stabilityCheck, noopCheck]);
  const previousState = reactExports.useMemo(() => store2.getState(), [store2]);
  useIsomorphicLayoutEffect$2(() => {
    const {
      subscription
    } = contextValue;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store2.getState()) {
      subscription.notifyNestedSubs();
    }
    return () => {
      subscription.tryUnsubscribe();
      subscription.onStateChange = void 0;
    };
  }, [contextValue, previousState]);
  const Context = context || ReactReduxContext;
  return /* @__PURE__ */ reactExports.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
function createStoreHook(context = ReactReduxContext) {
  const useReduxContext$1 = (
    // @ts-ignore
    context === ReactReduxContext ? useReduxContext : (
      // @ts-ignore
      createReduxContextHook(context)
    )
  );
  return function useStore2() {
    const {
      store: store2
    } = useReduxContext$1();
    return store2;
  };
}
const useStore = /* @__PURE__ */ createStoreHook();
function createDispatchHook(context = ReactReduxContext) {
  const useStore$1 = (
    // @ts-ignore
    context === ReactReduxContext ? useStore : createStoreHook(context)
  );
  return function useDispatch2() {
    const store2 = useStore$1();
    return store2.dispatch;
  };
}
const useDispatch = /* @__PURE__ */ createDispatchHook();
initializeUseSelector(withSelectorExports.useSyncExternalStoreWithSelector);
setBatch(reactDomExports.unstable_batchedUpdates);
const useTypedSelector = useSelector;
function n(n2) {
  for (var r2 = arguments.length, t2 = Array(r2 > 1 ? r2 - 1 : 0), e2 = 1; e2 < r2; e2++)
    t2[e2 - 1] = arguments[e2];
  throw Error("[Immer] minified error nr: " + n2 + (t2.length ? " " + t2.map(function(n3) {
    return "'" + n3 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r$1(n2) {
  return !!n2 && !!n2[Q$1];
}
function t(n2) {
  var r2;
  return !!n2 && (function(n3) {
    if (!n3 || "object" != typeof n3)
      return false;
    var r3 = Object.getPrototypeOf(n3);
    if (null === r3)
      return true;
    var t2 = Object.hasOwnProperty.call(r3, "constructor") && r3.constructor;
    return t2 === Object || "function" == typeof t2 && Function.toString.call(t2) === Z$1;
  }(n2) || Array.isArray(n2) || !!n2[L$1] || !!(null === (r2 = n2.constructor) || void 0 === r2 ? void 0 : r2[L$1]) || s(n2) || v(n2));
}
function e(t2) {
  return r$1(t2) || n(23, t2), t2[Q$1].t;
}
function i(n2, r2, t2) {
  void 0 === t2 && (t2 = false), 0 === o(n2) ? (t2 ? Object.keys : nn)(n2).forEach(function(e2) {
    t2 && "symbol" == typeof e2 || r2(e2, n2[e2], n2);
  }) : n2.forEach(function(t3, e2) {
    return r2(e2, t3, n2);
  });
}
function o(n2) {
  var r2 = n2[Q$1];
  return r2 ? r2.i > 3 ? r2.i - 4 : r2.i : Array.isArray(n2) ? 1 : s(n2) ? 2 : v(n2) ? 3 : 0;
}
function u(n2, r2) {
  return 2 === o(n2) ? n2.has(r2) : Object.prototype.hasOwnProperty.call(n2, r2);
}
function a(n2, r2) {
  return 2 === o(n2) ? n2.get(r2) : n2[r2];
}
function f(n2, r2, t2) {
  var e2 = o(n2);
  2 === e2 ? n2.set(r2, t2) : 3 === e2 ? n2.add(t2) : n2[r2] = t2;
}
function c(n2, r2) {
  return n2 === r2 ? 0 !== n2 || 1 / n2 == 1 / r2 : n2 != n2 && r2 != r2;
}
function s(n2) {
  return X$1 && n2 instanceof Map;
}
function v(n2) {
  return q$1 && n2 instanceof Set;
}
function p(n2) {
  return n2.o || n2.t;
}
function l(n2) {
  if (Array.isArray(n2))
    return Array.prototype.slice.call(n2);
  var r2 = rn(n2);
  delete r2[Q$1];
  for (var t2 = nn(r2), e2 = 0; e2 < t2.length; e2++) {
    var i2 = t2[e2], o2 = r2[i2];
    false === o2.writable && (o2.writable = true, o2.configurable = true), (o2.get || o2.set) && (r2[i2] = { configurable: true, writable: true, enumerable: o2.enumerable, value: n2[i2] });
  }
  return Object.create(Object.getPrototypeOf(n2), r2);
}
function d$1(n2, e2) {
  return void 0 === e2 && (e2 = false), y(n2) || r$1(n2) || !t(n2) || (o(n2) > 1 && (n2.set = n2.add = n2.clear = n2.delete = h), Object.freeze(n2), e2 && i(n2, function(n3, r2) {
    return d$1(r2, true);
  }, true)), n2;
}
function h() {
  n(2);
}
function y(n2) {
  return null == n2 || "object" != typeof n2 || Object.isFrozen(n2);
}
function b(r2) {
  var t2 = tn[r2];
  return t2 || n(18, r2), t2;
}
function m$1(n2, r2) {
  tn[n2] || (tn[n2] = r2);
}
function _$1() {
  return U$1;
}
function j$1(n2, r2) {
  r2 && (b("Patches"), n2.u = [], n2.s = [], n2.v = r2);
}
function g(n2) {
  O(n2), n2.p.forEach(S), n2.p = null;
}
function O(n2) {
  n2 === U$1 && (U$1 = n2.l);
}
function w(n2) {
  return U$1 = { p: [], l: U$1, h: n2, m: true, _: 0 };
}
function S(n2) {
  var r2 = n2[Q$1];
  0 === r2.i || 1 === r2.i ? r2.j() : r2.g = true;
}
function P$1(r2, e2) {
  e2._ = e2.p.length;
  var i2 = e2.p[0], o2 = void 0 !== r2 && r2 !== i2;
  return e2.h.O || b("ES5").S(e2, r2, o2), o2 ? (i2[Q$1].P && (g(e2), n(4)), t(r2) && (r2 = M(e2, r2), e2.l || x(e2, r2)), e2.u && b("Patches").M(i2[Q$1].t, r2, e2.u, e2.s)) : r2 = M(e2, i2, []), g(e2), e2.u && e2.v(e2.u, e2.s), r2 !== H ? r2 : void 0;
}
function M(n2, r2, t2) {
  if (y(r2))
    return r2;
  var e2 = r2[Q$1];
  if (!e2)
    return i(r2, function(i2, o3) {
      return A(n2, e2, r2, i2, o3, t2);
    }, true), r2;
  if (e2.A !== n2)
    return r2;
  if (!e2.P)
    return x(n2, e2.t, true), e2.t;
  if (!e2.I) {
    e2.I = true, e2.A._--;
    var o2 = 4 === e2.i || 5 === e2.i ? e2.o = l(e2.k) : e2.o, u2 = o2, a2 = false;
    3 === e2.i && (u2 = new Set(o2), o2.clear(), a2 = true), i(u2, function(r3, i2) {
      return A(n2, e2, o2, r3, i2, t2, a2);
    }), x(n2, o2, false), t2 && n2.u && b("Patches").N(e2, t2, n2.u, n2.s);
  }
  return e2.o;
}
function A(e2, i2, o2, a2, c2, s2, v2) {
  if (r$1(c2)) {
    var p2 = M(e2, c2, s2 && i2 && 3 !== i2.i && !u(i2.R, a2) ? s2.concat(a2) : void 0);
    if (f(o2, a2, p2), !r$1(p2))
      return;
    e2.m = false;
  } else
    v2 && o2.add(c2);
  if (t(c2) && !y(c2)) {
    if (!e2.h.D && e2._ < 1)
      return;
    M(e2, c2), i2 && i2.A.l || x(e2, c2);
  }
}
function x(n2, r2, t2) {
  void 0 === t2 && (t2 = false), !n2.l && n2.h.D && n2.m && d$1(r2, t2);
}
function z$1(n2, r2) {
  var t2 = n2[Q$1];
  return (t2 ? p(t2) : n2)[r2];
}
function I(n2, r2) {
  if (r2 in n2)
    for (var t2 = Object.getPrototypeOf(n2); t2; ) {
      var e2 = Object.getOwnPropertyDescriptor(t2, r2);
      if (e2)
        return e2;
      t2 = Object.getPrototypeOf(t2);
    }
}
function k(n2) {
  n2.P || (n2.P = true, n2.l && k(n2.l));
}
function E(n2) {
  n2.o || (n2.o = l(n2.t));
}
function N(n2, r2, t2) {
  var e2 = s(r2) ? b("MapSet").F(r2, t2) : v(r2) ? b("MapSet").T(r2, t2) : n2.O ? function(n3, r3) {
    var t3 = Array.isArray(n3), e3 = { i: t3 ? 1 : 0, A: r3 ? r3.A : _$1(), P: false, I: false, R: {}, l: r3, t: n3, k: null, o: null, j: null, C: false }, i2 = e3, o2 = en;
    t3 && (i2 = [e3], o2 = on);
    var u2 = Proxy.revocable(i2, o2), a2 = u2.revoke, f2 = u2.proxy;
    return e3.k = f2, e3.j = a2, f2;
  }(r2, t2) : b("ES5").J(r2, t2);
  return (t2 ? t2.A : _$1()).p.push(e2), e2;
}
function R(e2) {
  return r$1(e2) || n(22, e2), function n2(r2) {
    if (!t(r2))
      return r2;
    var e3, u2 = r2[Q$1], c2 = o(r2);
    if (u2) {
      if (!u2.P && (u2.i < 4 || !b("ES5").K(u2)))
        return u2.t;
      u2.I = true, e3 = D$1(r2, c2), u2.I = false;
    } else
      e3 = D$1(r2, c2);
    return i(e3, function(r3, t2) {
      u2 && a(u2.t, r3) === t2 || f(e3, r3, n2(t2));
    }), 3 === c2 ? new Set(e3) : e3;
  }(e2);
}
function D$1(n2, r2) {
  switch (r2) {
    case 2:
      return new Map(n2);
    case 3:
      return Array.from(n2);
  }
  return l(n2);
}
function F$1() {
  function t2(n2, r2) {
    var t3 = s2[n2];
    return t3 ? t3.enumerable = r2 : s2[n2] = t3 = { configurable: true, enumerable: r2, get: function() {
      var r3 = this[Q$1];
      return en.get(r3, n2);
    }, set: function(r3) {
      var t4 = this[Q$1];
      en.set(t4, n2, r3);
    } }, t3;
  }
  function e2(n2) {
    for (var r2 = n2.length - 1; r2 >= 0; r2--) {
      var t3 = n2[r2][Q$1];
      if (!t3.P)
        switch (t3.i) {
          case 5:
            a2(t3) && k(t3);
            break;
          case 4:
            o2(t3) && k(t3);
        }
    }
  }
  function o2(n2) {
    for (var r2 = n2.t, t3 = n2.k, e3 = nn(t3), i2 = e3.length - 1; i2 >= 0; i2--) {
      var o3 = e3[i2];
      if (o3 !== Q$1) {
        var a3 = r2[o3];
        if (void 0 === a3 && !u(r2, o3))
          return true;
        var f2 = t3[o3], s3 = f2 && f2[Q$1];
        if (s3 ? s3.t !== a3 : !c(f2, a3))
          return true;
      }
    }
    var v2 = !!r2[Q$1];
    return e3.length !== nn(r2).length + (v2 ? 0 : 1);
  }
  function a2(n2) {
    var r2 = n2.k;
    if (r2.length !== n2.t.length)
      return true;
    var t3 = Object.getOwnPropertyDescriptor(r2, r2.length - 1);
    if (t3 && !t3.get)
      return true;
    for (var e3 = 0; e3 < r2.length; e3++)
      if (!r2.hasOwnProperty(e3))
        return true;
    return false;
  }
  var s2 = {};
  m$1("ES5", { J: function(n2, r2) {
    var e3 = Array.isArray(n2), i2 = function(n3, r3) {
      if (n3) {
        for (var e4 = Array(r3.length), i3 = 0; i3 < r3.length; i3++)
          Object.defineProperty(e4, "" + i3, t2(i3, true));
        return e4;
      }
      var o4 = rn(r3);
      delete o4[Q$1];
      for (var u2 = nn(o4), a3 = 0; a3 < u2.length; a3++) {
        var f2 = u2[a3];
        o4[f2] = t2(f2, n3 || !!o4[f2].enumerable);
      }
      return Object.create(Object.getPrototypeOf(r3), o4);
    }(e3, n2), o3 = { i: e3 ? 5 : 4, A: r2 ? r2.A : _$1(), P: false, I: false, R: {}, l: r2, t: n2, k: i2, o: null, g: false, C: false };
    return Object.defineProperty(i2, Q$1, { value: o3, writable: true }), i2;
  }, S: function(n2, t3, o3) {
    o3 ? r$1(t3) && t3[Q$1].A === n2 && e2(n2.p) : (n2.u && function n3(r2) {
      if (r2 && "object" == typeof r2) {
        var t4 = r2[Q$1];
        if (t4) {
          var e3 = t4.t, o4 = t4.k, f2 = t4.R, c2 = t4.i;
          if (4 === c2)
            i(o4, function(r3) {
              r3 !== Q$1 && (void 0 !== e3[r3] || u(e3, r3) ? f2[r3] || n3(o4[r3]) : (f2[r3] = true, k(t4)));
            }), i(e3, function(n4) {
              void 0 !== o4[n4] || u(o4, n4) || (f2[n4] = false, k(t4));
            });
          else if (5 === c2) {
            if (a2(t4) && (k(t4), f2.length = true), o4.length < e3.length)
              for (var s3 = o4.length; s3 < e3.length; s3++)
                f2[s3] = false;
            else
              for (var v2 = e3.length; v2 < o4.length; v2++)
                f2[v2] = true;
            for (var p2 = Math.min(o4.length, e3.length), l2 = 0; l2 < p2; l2++)
              o4.hasOwnProperty(l2) || (f2[l2] = true), void 0 === f2[l2] && n3(o4[l2]);
          }
        }
      }
    }(n2.p[0]), e2(n2.p));
  }, K: function(n2) {
    return 4 === n2.i ? o2(n2) : a2(n2);
  } });
}
function T$1() {
  function e2(n2) {
    if (!t(n2))
      return n2;
    if (Array.isArray(n2))
      return n2.map(e2);
    if (s(n2))
      return new Map(Array.from(n2.entries()).map(function(n3) {
        return [n3[0], e2(n3[1])];
      }));
    if (v(n2))
      return new Set(Array.from(n2).map(e2));
    var r2 = Object.create(Object.getPrototypeOf(n2));
    for (var i2 in n2)
      r2[i2] = e2(n2[i2]);
    return u(n2, L$1) && (r2[L$1] = n2[L$1]), r2;
  }
  function f2(n2) {
    return r$1(n2) ? e2(n2) : n2;
  }
  var c2 = "add";
  m$1("Patches", { $: function(r2, t2) {
    return t2.forEach(function(t3) {
      for (var i2 = t3.path, u2 = t3.op, f3 = r2, s2 = 0; s2 < i2.length - 1; s2++) {
        var v2 = o(f3), p2 = i2[s2];
        "string" != typeof p2 && "number" != typeof p2 && (p2 = "" + p2), 0 !== v2 && 1 !== v2 || "__proto__" !== p2 && "constructor" !== p2 || n(24), "function" == typeof f3 && "prototype" === p2 && n(24), "object" != typeof (f3 = a(f3, p2)) && n(15, i2.join("/"));
      }
      var l2 = o(f3), d2 = e2(t3.value), h2 = i2[i2.length - 1];
      switch (u2) {
        case "replace":
          switch (l2) {
            case 2:
              return f3.set(h2, d2);
            case 3:
              n(16);
            default:
              return f3[h2] = d2;
          }
        case c2:
          switch (l2) {
            case 1:
              return "-" === h2 ? f3.push(d2) : f3.splice(h2, 0, d2);
            case 2:
              return f3.set(h2, d2);
            case 3:
              return f3.add(d2);
            default:
              return f3[h2] = d2;
          }
        case "remove":
          switch (l2) {
            case 1:
              return f3.splice(h2, 1);
            case 2:
              return f3.delete(h2);
            case 3:
              return f3.delete(t3.value);
            default:
              return delete f3[h2];
          }
        default:
          n(17, u2);
      }
    }), r2;
  }, N: function(n2, r2, t2, e3) {
    switch (n2.i) {
      case 0:
      case 4:
      case 2:
        return function(n3, r3, t3, e4) {
          var o2 = n3.t, s2 = n3.o;
          i(n3.R, function(n4, i2) {
            var v2 = a(o2, n4), p2 = a(s2, n4), l2 = i2 ? u(o2, n4) ? "replace" : c2 : "remove";
            if (v2 !== p2 || "replace" !== l2) {
              var d2 = r3.concat(n4);
              t3.push("remove" === l2 ? { op: l2, path: d2 } : { op: l2, path: d2, value: p2 }), e4.push(l2 === c2 ? { op: "remove", path: d2 } : "remove" === l2 ? { op: c2, path: d2, value: f2(v2) } : { op: "replace", path: d2, value: f2(v2) });
            }
          });
        }(n2, r2, t2, e3);
      case 5:
      case 1:
        return function(n3, r3, t3, e4) {
          var i2 = n3.t, o2 = n3.R, u2 = n3.o;
          if (u2.length < i2.length) {
            var a2 = [u2, i2];
            i2 = a2[0], u2 = a2[1];
            var s2 = [e4, t3];
            t3 = s2[0], e4 = s2[1];
          }
          for (var v2 = 0; v2 < i2.length; v2++)
            if (o2[v2] && u2[v2] !== i2[v2]) {
              var p2 = r3.concat([v2]);
              t3.push({ op: "replace", path: p2, value: f2(u2[v2]) }), e4.push({ op: "replace", path: p2, value: f2(i2[v2]) });
            }
          for (var l2 = i2.length; l2 < u2.length; l2++) {
            var d2 = r3.concat([l2]);
            t3.push({ op: c2, path: d2, value: f2(u2[l2]) });
          }
          i2.length < u2.length && e4.push({ op: "replace", path: r3.concat(["length"]), value: i2.length });
        }(n2, r2, t2, e3);
      case 3:
        return function(n3, r3, t3, e4) {
          var i2 = n3.t, o2 = n3.o, u2 = 0;
          i2.forEach(function(n4) {
            if (!o2.has(n4)) {
              var i3 = r3.concat([u2]);
              t3.push({ op: "remove", path: i3, value: n4 }), e4.unshift({ op: c2, path: i3, value: n4 });
            }
            u2++;
          }), u2 = 0, o2.forEach(function(n4) {
            if (!i2.has(n4)) {
              var o3 = r3.concat([u2]);
              t3.push({ op: c2, path: o3, value: n4 }), e4.unshift({ op: "remove", path: o3, value: n4 });
            }
            u2++;
          });
        }(n2, r2, t2, e3);
    }
  }, M: function(n2, r2, t2, e3) {
    t2.push({ op: "replace", path: [], value: r2 === H ? void 0 : r2 }), e3.push({ op: "replace", path: [], value: n2 });
  } });
}
var G$1, U$1, W$1 = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x"), X$1 = "undefined" != typeof Map, q$1 = "undefined" != typeof Set, B$1 = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect, H = W$1 ? Symbol.for("immer-nothing") : ((G$1 = {})["immer-nothing"] = true, G$1), L$1 = W$1 ? Symbol.for("immer-draftable") : "__$immer_draftable", Q$1 = W$1 ? Symbol.for("immer-state") : "__$immer_state", Z$1 = "" + Object.prototype.constructor, nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n2) {
  return Object.getOwnPropertyNames(n2).concat(Object.getOwnPropertySymbols(n2));
} : Object.getOwnPropertyNames, rn = Object.getOwnPropertyDescriptors || function(n2) {
  var r2 = {};
  return nn(n2).forEach(function(t2) {
    r2[t2] = Object.getOwnPropertyDescriptor(n2, t2);
  }), r2;
}, tn = {}, en = { get: function(n2, r2) {
  if (r2 === Q$1)
    return n2;
  var e2 = p(n2);
  if (!u(e2, r2))
    return function(n3, r3, t2) {
      var e3, i3 = I(r3, t2);
      return i3 ? "value" in i3 ? i3.value : null === (e3 = i3.get) || void 0 === e3 ? void 0 : e3.call(n3.k) : void 0;
    }(n2, e2, r2);
  var i2 = e2[r2];
  return n2.I || !t(i2) ? i2 : i2 === z$1(n2.t, r2) ? (E(n2), n2.o[r2] = N(n2.A.h, i2, n2)) : i2;
}, has: function(n2, r2) {
  return r2 in p(n2);
}, ownKeys: function(n2) {
  return Reflect.ownKeys(p(n2));
}, set: function(n2, r2, t2) {
  var e2 = I(p(n2), r2);
  if (null == e2 ? void 0 : e2.set)
    return e2.set.call(n2.k, t2), true;
  if (!n2.P) {
    var i2 = z$1(p(n2), r2), o2 = null == i2 ? void 0 : i2[Q$1];
    if (o2 && o2.t === t2)
      return n2.o[r2] = t2, n2.R[r2] = false, true;
    if (c(t2, i2) && (void 0 !== t2 || u(n2.t, r2)))
      return true;
    E(n2), k(n2);
  }
  return n2.o[r2] === t2 && (void 0 !== t2 || r2 in n2.o) || Number.isNaN(t2) && Number.isNaN(n2.o[r2]) || (n2.o[r2] = t2, n2.R[r2] = true), true;
}, deleteProperty: function(n2, r2) {
  return void 0 !== z$1(n2.t, r2) || r2 in n2.t ? (n2.R[r2] = false, E(n2), k(n2)) : delete n2.R[r2], n2.o && delete n2.o[r2], true;
}, getOwnPropertyDescriptor: function(n2, r2) {
  var t2 = p(n2), e2 = Reflect.getOwnPropertyDescriptor(t2, r2);
  return e2 ? { writable: true, configurable: 1 !== n2.i || "length" !== r2, enumerable: e2.enumerable, value: t2[r2] } : e2;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n2) {
  return Object.getPrototypeOf(n2.t);
}, setPrototypeOf: function() {
  n(12);
} }, on = {};
i(en, function(n2, r2) {
  on[n2] = function() {
    return arguments[0] = arguments[0][0], r2.apply(this, arguments);
  };
}), on.deleteProperty = function(r2, t2) {
  return on.set.call(this, r2, t2, void 0);
}, on.set = function(r2, t2, e2) {
  return en.set.call(this, r2[0], t2, e2, r2[0]);
};
var un = function() {
  function e2(r2) {
    var e3 = this;
    this.O = B$1, this.D = true, this.produce = function(r3, i3, o2) {
      if ("function" == typeof r3 && "function" != typeof i3) {
        var u2 = i3;
        i3 = r3;
        var a2 = e3;
        return function(n2) {
          var r4 = this;
          void 0 === n2 && (n2 = u2);
          for (var t2 = arguments.length, e4 = Array(t2 > 1 ? t2 - 1 : 0), o3 = 1; o3 < t2; o3++)
            e4[o3 - 1] = arguments[o3];
          return a2.produce(n2, function(n3) {
            var t3;
            return (t3 = i3).call.apply(t3, [r4, n3].concat(e4));
          });
        };
      }
      var f2;
      if ("function" != typeof i3 && n(6), void 0 !== o2 && "function" != typeof o2 && n(7), t(r3)) {
        var c2 = w(e3), s2 = N(e3, r3, void 0), v2 = true;
        try {
          f2 = i3(s2), v2 = false;
        } finally {
          v2 ? g(c2) : O(c2);
        }
        return "undefined" != typeof Promise && f2 instanceof Promise ? f2.then(function(n2) {
          return j$1(c2, o2), P$1(n2, c2);
        }, function(n2) {
          throw g(c2), n2;
        }) : (j$1(c2, o2), P$1(f2, c2));
      }
      if (!r3 || "object" != typeof r3) {
        if (void 0 === (f2 = i3(r3)) && (f2 = r3), f2 === H && (f2 = void 0), e3.D && d$1(f2, true), o2) {
          var p2 = [], l2 = [];
          b("Patches").M(r3, f2, p2, l2), o2(p2, l2);
        }
        return f2;
      }
      n(21, r3);
    }, this.produceWithPatches = function(n2, r3) {
      if ("function" == typeof n2)
        return function(r4) {
          for (var t3 = arguments.length, i4 = Array(t3 > 1 ? t3 - 1 : 0), o3 = 1; o3 < t3; o3++)
            i4[o3 - 1] = arguments[o3];
          return e3.produceWithPatches(r4, function(r5) {
            return n2.apply(void 0, [r5].concat(i4));
          });
        };
      var t2, i3, o2 = e3.produce(n2, r3, function(n3, r4) {
        t2 = n3, i3 = r4;
      });
      return "undefined" != typeof Promise && o2 instanceof Promise ? o2.then(function(n3) {
        return [n3, t2, i3];
      }) : [o2, t2, i3];
    }, "boolean" == typeof (null == r2 ? void 0 : r2.useProxies) && this.setUseProxies(r2.useProxies), "boolean" == typeof (null == r2 ? void 0 : r2.autoFreeze) && this.setAutoFreeze(r2.autoFreeze);
  }
  var i2 = e2.prototype;
  return i2.createDraft = function(e3) {
    t(e3) || n(8), r$1(e3) && (e3 = R(e3));
    var i3 = w(this), o2 = N(this, e3, void 0);
    return o2[Q$1].C = true, O(i3), o2;
  }, i2.finishDraft = function(r2, t2) {
    var e3 = r2 && r2[Q$1];
    var i3 = e3.A;
    return j$1(i3, t2), P$1(void 0, i3);
  }, i2.setAutoFreeze = function(n2) {
    this.D = n2;
  }, i2.setUseProxies = function(r2) {
    r2 && !B$1 && n(20), this.O = r2;
  }, i2.applyPatches = function(n2, t2) {
    var e3;
    for (e3 = t2.length - 1; e3 >= 0; e3--) {
      var i3 = t2[e3];
      if (0 === i3.path.length && "replace" === i3.op) {
        n2 = i3.value;
        break;
      }
    }
    e3 > -1 && (t2 = t2.slice(e3 + 1));
    var o2 = b("Patches").$;
    return r$1(n2) ? o2(n2, t2) : this.produce(n2, function(n3) {
      return o2(n3, t2);
    });
  }, e2;
}(), an = new un(), fn = an.produce, cn = an.produceWithPatches.bind(an);
an.setAutoFreeze.bind(an);
an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
an.createDraft.bind(an);
an.finishDraft.bind(an);
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function _toPrimitive(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys(e2, r2) {
  var t2 = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o2 = Object.getOwnPropertySymbols(e2);
    r2 && (o2 = o2.filter(function(r3) {
      return Object.getOwnPropertyDescriptor(e2, r3).enumerable;
    })), t2.push.apply(t2, o2);
  }
  return t2;
}
function _objectSpread2(e2) {
  for (var r2 = 1; r2 < arguments.length; r2++) {
    var t2 = null != arguments[r2] ? arguments[r2] : {};
    r2 % 2 ? ownKeys(Object(t2), true).forEach(function(r3) {
      _defineProperty(e2, r3, t2[r3]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t2)) : ownKeys(Object(t2)).forEach(function(r3) {
      Object.defineProperty(e2, r3, Object.getOwnPropertyDescriptor(t2, r3));
    });
  }
  return e2;
}
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$4(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore(reducer2, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer2, preloadedState);
  }
  if (typeof reducer2 !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer2;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$4(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function(key) {
    var reducer2 = reducers[key];
    var initialState2 = reducer2(void 0, {
      type: ActionTypes.INIT
    });
    if (typeof initialState2 === "undefined") {
      throw new Error(formatProdErrorMessage(12));
    }
    if (typeof reducer2(void 0, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === "undefined") {
      throw new Error(formatProdErrorMessage(13));
    }
  });
}
function combineReducers(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};
  for (var i2 = 0; i2 < reducerKeys.length; i2++) {
    var key = reducerKeys[i2];
    if (typeof reducers[key] === "function") {
      finalReducers[key] = reducers[key];
    }
  }
  var finalReducerKeys = Object.keys(finalReducers);
  var shapeAssertionError;
  try {
    assertReducerShape(finalReducers);
  } catch (e2) {
    shapeAssertionError = e2;
  }
  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }
    if (shapeAssertionError) {
      throw shapeAssertionError;
    }
    var hasChanged = false;
    var nextState = {};
    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer2 = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer2(previousStateForKey, action);
      if (typeof nextStateForKey === "undefined") {
        action && action.type;
        throw new Error(formatProdErrorMessage(14));
      }
      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }
    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(formatProdErrorMessage(16));
  }
  var boundActionCreators = {};
  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose$1() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a2, b2) {
    return function() {
      return a2(b2.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore2) {
    return function() {
      var store2 = createStore2.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(formatProdErrorMessage(15));
      };
      var middlewareAPI = {
        getState: store2.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware2) {
        return middleware2(middlewareAPI);
      });
      _dispatch = compose$1.apply(void 0, chain)(store2.dispatch);
      return _objectSpread2(_objectSpread2({}, store2), {}, {
        dispatch: _dispatch
      });
    };
  };
}
var NOT_FOUND = "NOT_FOUND";
function createSingletonCache(equals) {
  var entry;
  return {
    get: function get(key) {
      if (entry && equals(entry.key, key)) {
        return entry.value;
      }
      return NOT_FOUND;
    },
    put: function put(key, value) {
      entry = {
        key,
        value
      };
    },
    getEntries: function getEntries() {
      return entry ? [entry] : [];
    },
    clear: function clear() {
      entry = void 0;
    }
  };
}
function createLruCache(maxSize, equals) {
  var entries = [];
  function get(key) {
    var cacheIndex = entries.findIndex(function(entry2) {
      return equals(key, entry2.key);
    });
    if (cacheIndex > -1) {
      var entry = entries[cacheIndex];
      if (cacheIndex > 0) {
        entries.splice(cacheIndex, 1);
        entries.unshift(entry);
      }
      return entry.value;
    }
    return NOT_FOUND;
  }
  function put(key, value) {
    if (get(key) === NOT_FOUND) {
      entries.unshift({
        key,
        value
      });
      if (entries.length > maxSize) {
        entries.pop();
      }
    }
  }
  function getEntries() {
    return entries;
  }
  function clear() {
    entries = [];
  }
  return {
    get,
    put,
    getEntries,
    clear
  };
}
var defaultEqualityCheck = function defaultEqualityCheck2(a2, b2) {
  return a2 === b2;
};
function createCacheKeyComparator(equalityCheck) {
  return function areArgumentsShallowlyEqual(prev2, next2) {
    if (prev2 === null || next2 === null || prev2.length !== next2.length) {
      return false;
    }
    var length2 = prev2.length;
    for (var i2 = 0; i2 < length2; i2++) {
      if (!equalityCheck(prev2[i2], next2[i2])) {
        return false;
      }
    }
    return true;
  };
}
function defaultMemoize(func, equalityCheckOrOptions) {
  var providedOptions = typeof equalityCheckOrOptions === "object" ? equalityCheckOrOptions : {
    equalityCheck: equalityCheckOrOptions
  };
  var _providedOptions$equa = providedOptions.equalityCheck, equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa, _providedOptions$maxS = providedOptions.maxSize, maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS, resultEqualityCheck = providedOptions.resultEqualityCheck;
  var comparator = createCacheKeyComparator(equalityCheck);
  var cache2 = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator);
  function memoized() {
    var value = cache2.get(arguments);
    if (value === NOT_FOUND) {
      value = func.apply(null, arguments);
      if (resultEqualityCheck) {
        var entries = cache2.getEntries();
        var matchingEntry = entries.find(function(entry) {
          return resultEqualityCheck(entry.value, value);
        });
        if (matchingEntry) {
          value = matchingEntry.value;
        }
      }
      cache2.put(arguments, value);
    }
    return value;
  }
  memoized.clearCache = function() {
    return cache2.clear();
  };
  return memoized;
}
function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;
  if (!dependencies.every(function(dep) {
    return typeof dep === "function";
  })) {
    var dependencyTypes = dependencies.map(function(dep) {
      return typeof dep === "function" ? "function " + (dep.name || "unnamed") + "()" : typeof dep;
    }).join(", ");
    throw new Error("createSelector expects all input-selectors to be functions, but received the following types: [" + dependencyTypes + "]");
  }
  return dependencies;
}
function createSelectorCreator(memoize2) {
  for (var _len = arguments.length, memoizeOptionsFromArgs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptionsFromArgs[_key - 1] = arguments[_key];
  }
  var createSelector2 = function createSelector3() {
    for (var _len2 = arguments.length, funcs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }
    var _recomputations = 0;
    var _lastResult;
    var directlyPassedOptions = {
      memoizeOptions: void 0
    };
    var resultFunc = funcs.pop();
    if (typeof resultFunc === "object") {
      directlyPassedOptions = resultFunc;
      resultFunc = funcs.pop();
    }
    if (typeof resultFunc !== "function") {
      throw new Error("createSelector expects an output function after the inputs, but received: [" + typeof resultFunc + "]");
    }
    var _directlyPassedOption = directlyPassedOptions, _directlyPassedOption2 = _directlyPassedOption.memoizeOptions, memoizeOptions = _directlyPassedOption2 === void 0 ? memoizeOptionsFromArgs : _directlyPassedOption2;
    var finalMemoizeOptions = Array.isArray(memoizeOptions) ? memoizeOptions : [memoizeOptions];
    var dependencies = getDependencies(funcs);
    var memoizedResultFunc = memoize2.apply(void 0, [function recomputationWrapper() {
      _recomputations++;
      return resultFunc.apply(null, arguments);
    }].concat(finalMemoizeOptions));
    var selector = memoize2(function dependenciesChecker() {
      var params = [];
      var length2 = dependencies.length;
      for (var i2 = 0; i2 < length2; i2++) {
        params.push(dependencies[i2].apply(null, arguments));
      }
      _lastResult = memoizedResultFunc.apply(null, params);
      return _lastResult;
    });
    Object.assign(selector, {
      resultFunc,
      memoizedResultFunc,
      dependencies,
      lastResult: function lastResult() {
        return _lastResult;
      },
      recomputations: function recomputations() {
        return _recomputations;
      },
      resetRecomputations: function resetRecomputations() {
        return _recomputations = 0;
      }
    });
    return selector;
  };
  return createSelector2;
}
var createSelector = /* @__PURE__ */ createSelectorCreator(defaultMemoize);
function createThunkMiddleware(extraArgument) {
  var middleware2 = function middleware3(_ref) {
    var dispatch = _ref.dispatch, getState = _ref.getState;
    return function(next2) {
      return function(action) {
        if (typeof action === "function") {
          return action(dispatch, getState, extraArgument);
        }
        return next2(action);
      };
    };
  };
  return middleware2;
}
var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;
const thunkMiddleware = thunk;
var __extends = globalThis && globalThis.__extends || function() {
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  return function(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __generator$1 = globalThis && globalThis.__generator || function(thisArg, body2) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray$2 = globalThis && globalThis.__spreadArray || function(to2, from2) {
  for (var i2 = 0, il2 = from2.length, j2 = to2.length; i2 < il2; i2++, j2++)
    to2[j2] = from2[i2];
  return to2;
};
var __defProp$2 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = function(obj, key, value) {
  return key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
};
var __spreadValues$2 = function(a2, b2) {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$2.call(b2, prop))
      __defNormalProp$2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$2)
    for (var _i = 0, _c = __getOwnPropSymbols$2(b2); _i < _c.length; _i++) {
      var prop = _c[_i];
      if (__propIsEnum$2.call(b2, prop))
        __defNormalProp$2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$2 = function(a2, b2) {
  return __defProps$2(a2, __getOwnPropDescs$2(b2));
};
var __async$1 = function(__this, __arguments, generator) {
  return new Promise(function(resolve, reject) {
    var fulfilled = function(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = function(value) {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = function(x2) {
      return x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    };
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var composeWithDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ : function() {
  if (arguments.length === 0)
    return void 0;
  if (typeof arguments[0] === "object")
    return compose$1;
  return compose$1.apply(null, arguments);
};
function isPlainObject$3(value) {
  if (typeof value !== "object" || value === null)
    return false;
  var proto = Object.getPrototypeOf(value);
  if (proto === null)
    return true;
  var baseProto = proto;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto === baseProto;
}
var hasMatchFunction = function(v2) {
  return v2 && typeof v2.match === "function";
};
function createAction(type, prepareAction) {
  function actionCreator() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (prepareAction) {
      var prepared = prepareAction.apply(void 0, args);
      if (!prepared) {
        throw new Error("prepareAction did not return an object");
      }
      return __spreadValues$2(__spreadValues$2({
        type,
        payload: prepared.payload
      }, "meta" in prepared && { meta: prepared.meta }), "error" in prepared && { error: prepared.error });
    }
    return { type, payload: args[0] };
  }
  actionCreator.toString = function() {
    return "" + type;
  };
  actionCreator.type = type;
  actionCreator.match = function(action) {
    return action.type === type;
  };
  return actionCreator;
}
var MiddlewareArray = (
  /** @class */
  function(_super) {
    __extends(MiddlewareArray2, _super);
    function MiddlewareArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, MiddlewareArray2.prototype);
      return _this;
    }
    Object.defineProperty(MiddlewareArray2, Symbol.species, {
      get: function() {
        return MiddlewareArray2;
      },
      enumerable: false,
      configurable: true
    });
    MiddlewareArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    MiddlewareArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray$2([void 0], arr[0].concat(this))))();
      }
      return new (MiddlewareArray2.bind.apply(MiddlewareArray2, __spreadArray$2([void 0], arr.concat(this))))();
    };
    return MiddlewareArray2;
  }(Array)
);
var EnhancerArray = (
  /** @class */
  function(_super) {
    __extends(EnhancerArray2, _super);
    function EnhancerArray2() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var _this = _super.apply(this, args) || this;
      Object.setPrototypeOf(_this, EnhancerArray2.prototype);
      return _this;
    }
    Object.defineProperty(EnhancerArray2, Symbol.species, {
      get: function() {
        return EnhancerArray2;
      },
      enumerable: false,
      configurable: true
    });
    EnhancerArray2.prototype.concat = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      return _super.prototype.concat.apply(this, arr);
    };
    EnhancerArray2.prototype.prepend = function() {
      var arr = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        arr[_i] = arguments[_i];
      }
      if (arr.length === 1 && Array.isArray(arr[0])) {
        return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray$2([void 0], arr[0].concat(this))))();
      }
      return new (EnhancerArray2.bind.apply(EnhancerArray2, __spreadArray$2([void 0], arr.concat(this))))();
    };
    return EnhancerArray2;
  }(Array)
);
function freezeDraftable(val) {
  return t(val) ? fn(val, function() {
  }) : val;
}
function isBoolean$1(x2) {
  return typeof x2 === "boolean";
}
function curryGetDefaultMiddleware() {
  return function curriedGetDefaultMiddleware(options) {
    return getDefaultMiddleware(options);
  };
}
function getDefaultMiddleware(options) {
  if (options === void 0) {
    options = {};
  }
  var _c = options.thunk, thunk2 = _c === void 0 ? true : _c;
  options.immutableCheck;
  options.serializableCheck;
  options.actionCreatorCheck;
  var middlewareArray = new MiddlewareArray();
  if (thunk2) {
    if (isBoolean$1(thunk2)) {
      middlewareArray.push(thunkMiddleware);
    } else {
      middlewareArray.push(thunkMiddleware.withExtraArgument(thunk2.extraArgument));
    }
  }
  return middlewareArray;
}
var IS_PRODUCTION = true;
function configureStore(options) {
  var curriedGetDefaultMiddleware = curryGetDefaultMiddleware();
  var _c = options || {}, _d = _c.reducer, reducer2 = _d === void 0 ? void 0 : _d, _e2 = _c.middleware, middleware2 = _e2 === void 0 ? curriedGetDefaultMiddleware() : _e2, _f = _c.devTools, devTools = _f === void 0 ? true : _f, _g = _c.preloadedState, preloadedState = _g === void 0 ? void 0 : _g, _h = _c.enhancers, enhancers = _h === void 0 ? void 0 : _h;
  var rootReducer;
  if (typeof reducer2 === "function") {
    rootReducer = reducer2;
  } else if (isPlainObject$3(reducer2)) {
    rootReducer = combineReducers(reducer2);
  } else {
    throw new Error('"reducer" is a required argument, and must be a function or an object of functions that can be passed to combineReducers');
  }
  var finalMiddleware = middleware2;
  if (typeof finalMiddleware === "function") {
    finalMiddleware = finalMiddleware(curriedGetDefaultMiddleware);
  }
  var middlewareEnhancer = applyMiddleware.apply(void 0, finalMiddleware);
  var finalCompose = compose$1;
  if (devTools) {
    finalCompose = composeWithDevTools(__spreadValues$2({
      trace: !IS_PRODUCTION
    }, typeof devTools === "object" && devTools));
  }
  var defaultEnhancers = new EnhancerArray(middlewareEnhancer);
  var storeEnhancers = defaultEnhancers;
  if (Array.isArray(enhancers)) {
    storeEnhancers = __spreadArray$2([middlewareEnhancer], enhancers);
  } else if (typeof enhancers === "function") {
    storeEnhancers = enhancers(defaultEnhancers);
  }
  var composedEnhancer = finalCompose.apply(void 0, storeEnhancers);
  return createStore(rootReducer, preloadedState, composedEnhancer);
}
function executeReducerBuilderCallback(builderCallback) {
  var actionsMap = {};
  var actionMatchers = [];
  var defaultCaseReducer;
  var builder = {
    addCase: function(typeOrActionCreator, reducer2) {
      var type = typeof typeOrActionCreator === "string" ? typeOrActionCreator : typeOrActionCreator.type;
      if (!type) {
        throw new Error("`builder.addCase` cannot be called with an empty action type");
      }
      if (type in actionsMap) {
        throw new Error("`builder.addCase` cannot be called with two reducers for the same action type");
      }
      actionsMap[type] = reducer2;
      return builder;
    },
    addMatcher: function(matcher, reducer2) {
      actionMatchers.push({ matcher, reducer: reducer2 });
      return builder;
    },
    addDefaultCase: function(reducer2) {
      defaultCaseReducer = reducer2;
      return builder;
    }
  };
  builderCallback(builder);
  return [actionsMap, actionMatchers, defaultCaseReducer];
}
function isStateFunction(x2) {
  return typeof x2 === "function";
}
function createReducer(initialState2, mapOrBuilderCallback, actionMatchers, defaultCaseReducer) {
  if (actionMatchers === void 0) {
    actionMatchers = [];
  }
  var _c = typeof mapOrBuilderCallback === "function" ? executeReducerBuilderCallback(mapOrBuilderCallback) : [mapOrBuilderCallback, actionMatchers, defaultCaseReducer], actionsMap = _c[0], finalActionMatchers = _c[1], finalDefaultCaseReducer = _c[2];
  var getInitialState;
  if (isStateFunction(initialState2)) {
    getInitialState = function() {
      return freezeDraftable(initialState2());
    };
  } else {
    var frozenInitialState_1 = freezeDraftable(initialState2);
    getInitialState = function() {
      return frozenInitialState_1;
    };
  }
  function reducer2(state, action) {
    if (state === void 0) {
      state = getInitialState();
    }
    var caseReducers = __spreadArray$2([
      actionsMap[action.type]
    ], finalActionMatchers.filter(function(_c2) {
      var matcher = _c2.matcher;
      return matcher(action);
    }).map(function(_c2) {
      var reducer22 = _c2.reducer;
      return reducer22;
    }));
    if (caseReducers.filter(function(cr) {
      return !!cr;
    }).length === 0) {
      caseReducers = [finalDefaultCaseReducer];
    }
    return caseReducers.reduce(function(previousState, caseReducer) {
      if (caseReducer) {
        if (r$1(previousState)) {
          var draft = previousState;
          var result = caseReducer(draft, action);
          if (result === void 0) {
            return previousState;
          }
          return result;
        } else if (!t(previousState)) {
          var result = caseReducer(previousState, action);
          if (result === void 0) {
            if (previousState === null) {
              return previousState;
            }
            throw Error("A case reducer on a non-draftable value must not return undefined");
          }
          return result;
        } else {
          return fn(previousState, function(draft2) {
            return caseReducer(draft2, action);
          });
        }
      }
      return previousState;
    }, state);
  }
  reducer2.getInitialState = getInitialState;
  return reducer2;
}
function getType2(slice2, actionKey) {
  return slice2 + "/" + actionKey;
}
function createSlice(options) {
  var name = options.name;
  if (!name) {
    throw new Error("`name` is a required option for createSlice");
  }
  if (typeof process !== "undefined" && false) {
    if (options.initialState === void 0) {
      console.error("You must provide an `initialState` value that is not `undefined`. You may have misspelled `initialState`");
    }
  }
  var initialState2 = typeof options.initialState == "function" ? options.initialState : freezeDraftable(options.initialState);
  var reducers = options.reducers || {};
  var reducerNames = Object.keys(reducers);
  var sliceCaseReducersByName = {};
  var sliceCaseReducersByType = {};
  var actionCreators = {};
  reducerNames.forEach(function(reducerName) {
    var maybeReducerWithPrepare = reducers[reducerName];
    var type = getType2(name, reducerName);
    var caseReducer;
    var prepareCallback;
    if ("reducer" in maybeReducerWithPrepare) {
      caseReducer = maybeReducerWithPrepare.reducer;
      prepareCallback = maybeReducerWithPrepare.prepare;
    } else {
      caseReducer = maybeReducerWithPrepare;
    }
    sliceCaseReducersByName[reducerName] = caseReducer;
    sliceCaseReducersByType[type] = caseReducer;
    actionCreators[reducerName] = prepareCallback ? createAction(type, prepareCallback) : createAction(type);
  });
  function buildReducer() {
    var _c = typeof options.extraReducers === "function" ? executeReducerBuilderCallback(options.extraReducers) : [options.extraReducers], _d = _c[0], extraReducers = _d === void 0 ? {} : _d, _e2 = _c[1], actionMatchers = _e2 === void 0 ? [] : _e2, _f = _c[2], defaultCaseReducer = _f === void 0 ? void 0 : _f;
    var finalCaseReducers = __spreadValues$2(__spreadValues$2({}, extraReducers), sliceCaseReducersByType);
    return createReducer(initialState2, function(builder) {
      for (var key in finalCaseReducers) {
        builder.addCase(key, finalCaseReducers[key]);
      }
      for (var _i = 0, actionMatchers_1 = actionMatchers; _i < actionMatchers_1.length; _i++) {
        var m2 = actionMatchers_1[_i];
        builder.addMatcher(m2.matcher, m2.reducer);
      }
      if (defaultCaseReducer) {
        builder.addDefaultCase(defaultCaseReducer);
      }
    });
  }
  var _reducer;
  return {
    name,
    reducer: function(state, action) {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer(state, action);
    },
    actions: actionCreators,
    caseReducers: sliceCaseReducersByName,
    getInitialState: function() {
      if (!_reducer)
        _reducer = buildReducer();
      return _reducer.getInitialState();
    }
  };
}
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
var nanoid = function(size) {
  if (size === void 0) {
    size = 21;
  }
  var id2 = "";
  var i2 = size;
  while (i2--) {
    id2 += urlAlphabet[Math.random() * 64 | 0];
  }
  return id2;
};
var commonProperties = [
  "name",
  "message",
  "stack",
  "code"
];
var RejectWithValue = (
  /** @class */
  function() {
    function RejectWithValue2(payload, meta) {
      this.payload = payload;
      this.meta = meta;
    }
    return RejectWithValue2;
  }()
);
var FulfillWithMeta = (
  /** @class */
  function() {
    function FulfillWithMeta2(payload, meta) {
      this.payload = payload;
      this.meta = meta;
    }
    return FulfillWithMeta2;
  }()
);
var miniSerializeError = function(value) {
  if (typeof value === "object" && value !== null) {
    var simpleError = {};
    for (var _i = 0, commonProperties_1 = commonProperties; _i < commonProperties_1.length; _i++) {
      var property = commonProperties_1[_i];
      if (typeof value[property] === "string") {
        simpleError[property] = value[property];
      }
    }
    return simpleError;
  }
  return { message: String(value) };
};
var createAsyncThunk = function() {
  function createAsyncThunk2(typePrefix, payloadCreator, options) {
    var fulfilled = createAction(typePrefix + "/fulfilled", function(payload, requestId, arg, meta) {
      return {
        payload,
        meta: __spreadProps$2(__spreadValues$2({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "fulfilled"
        })
      };
    });
    var pending = createAction(typePrefix + "/pending", function(requestId, arg, meta) {
      return {
        payload: void 0,
        meta: __spreadProps$2(__spreadValues$2({}, meta || {}), {
          arg,
          requestId,
          requestStatus: "pending"
        })
      };
    });
    var rejected = createAction(typePrefix + "/rejected", function(error, requestId, arg, payload, meta) {
      return {
        payload,
        error: (options && options.serializeError || miniSerializeError)(error || "Rejected"),
        meta: __spreadProps$2(__spreadValues$2({}, meta || {}), {
          arg,
          requestId,
          rejectedWithValue: !!payload,
          requestStatus: "rejected",
          aborted: (error == null ? void 0 : error.name) === "AbortError",
          condition: (error == null ? void 0 : error.name) === "ConditionError"
        })
      };
    });
    var AC = typeof AbortController !== "undefined" ? AbortController : (
      /** @class */
      function() {
        function class_1() {
          this.signal = {
            aborted: false,
            addEventListener: function() {
            },
            dispatchEvent: function() {
              return false;
            },
            onabort: function() {
            },
            removeEventListener: function() {
            },
            reason: void 0,
            throwIfAborted: function() {
            }
          };
        }
        class_1.prototype.abort = function() {
        };
        return class_1;
      }()
    );
    function actionCreator(arg) {
      return function(dispatch, getState, extra) {
        var requestId = (options == null ? void 0 : options.idGenerator) ? options.idGenerator(arg) : nanoid();
        var abortController = new AC();
        var abortReason;
        function abort(reason) {
          abortReason = reason;
          abortController.abort();
        }
        var promise2 = function() {
          return __async$1(this, null, function() {
            var _a, _b, finalAction, conditionResult, abortedPromise, err_1, skipDispatch;
            return __generator$1(this, function(_c) {
              switch (_c.label) {
                case 0:
                  _c.trys.push([0, 4, , 5]);
                  conditionResult = (_a = options == null ? void 0 : options.condition) == null ? void 0 : _a.call(options, arg, { getState, extra });
                  if (!isThenable$1(conditionResult))
                    return [3, 2];
                  return [4, conditionResult];
                case 1:
                  conditionResult = _c.sent();
                  _c.label = 2;
                case 2:
                  if (conditionResult === false || abortController.signal.aborted) {
                    throw {
                      name: "ConditionError",
                      message: "Aborted due to condition callback returning false."
                    };
                  }
                  abortedPromise = new Promise(function(_2, reject) {
                    return abortController.signal.addEventListener("abort", function() {
                      return reject({
                        name: "AbortError",
                        message: abortReason || "Aborted"
                      });
                    });
                  });
                  dispatch(pending(requestId, arg, (_b = options == null ? void 0 : options.getPendingMeta) == null ? void 0 : _b.call(options, { requestId, arg }, { getState, extra })));
                  return [4, Promise.race([
                    abortedPromise,
                    Promise.resolve(payloadCreator(arg, {
                      dispatch,
                      getState,
                      extra,
                      requestId,
                      signal: abortController.signal,
                      abort,
                      rejectWithValue: function(value, meta) {
                        return new RejectWithValue(value, meta);
                      },
                      fulfillWithValue: function(value, meta) {
                        return new FulfillWithMeta(value, meta);
                      }
                    })).then(function(result) {
                      if (result instanceof RejectWithValue) {
                        throw result;
                      }
                      if (result instanceof FulfillWithMeta) {
                        return fulfilled(result.payload, requestId, arg, result.meta);
                      }
                      return fulfilled(result, requestId, arg);
                    })
                  ])];
                case 3:
                  finalAction = _c.sent();
                  return [3, 5];
                case 4:
                  err_1 = _c.sent();
                  finalAction = err_1 instanceof RejectWithValue ? rejected(null, requestId, arg, err_1.payload, err_1.meta) : rejected(err_1, requestId, arg);
                  return [3, 5];
                case 5:
                  skipDispatch = options && !options.dispatchConditionRejection && rejected.match(finalAction) && finalAction.meta.condition;
                  if (!skipDispatch) {
                    dispatch(finalAction);
                  }
                  return [2, finalAction];
              }
            });
          });
        }();
        return Object.assign(promise2, {
          abort,
          requestId,
          arg,
          unwrap: function() {
            return promise2.then(unwrapResult);
          }
        });
      };
    }
    return Object.assign(actionCreator, {
      pending,
      rejected,
      fulfilled,
      typePrefix
    });
  }
  createAsyncThunk2.withTypes = function() {
    return createAsyncThunk2;
  };
  return createAsyncThunk2;
}();
function unwrapResult(action) {
  if (action.meta && action.meta.rejectedWithValue) {
    throw action.payload;
  }
  if (action.error) {
    throw action.error;
  }
  return action.payload;
}
function isThenable$1(value) {
  return value !== null && typeof value === "object" && typeof value.then === "function";
}
var matches = function(matcher, action) {
  if (hasMatchFunction(matcher)) {
    return matcher.match(action);
  } else {
    return matcher(action);
  }
};
function isAnyOf() {
  var matchers = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    matchers[_i] = arguments[_i];
  }
  return function(action) {
    return matchers.some(function(matcher) {
      return matches(matcher, action);
    });
  };
}
function isAllOf() {
  var matchers = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    matchers[_i] = arguments[_i];
  }
  return function(action) {
    return matchers.every(function(matcher) {
      return matches(matcher, action);
    });
  };
}
function hasExpectedRequestMetadata(action, validStatus) {
  if (!action || !action.meta)
    return false;
  var hasValidRequestId = typeof action.meta.requestId === "string";
  var hasValidRequestStatus = validStatus.indexOf(action.meta.requestStatus) > -1;
  return hasValidRequestId && hasValidRequestStatus;
}
function isAsyncThunkArray(a2) {
  return typeof a2[0] === "function" && "pending" in a2[0] && "fulfilled" in a2[0] && "rejected" in a2[0];
}
function isPending() {
  var asyncThunks = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    asyncThunks[_i] = arguments[_i];
  }
  if (asyncThunks.length === 0) {
    return function(action) {
      return hasExpectedRequestMetadata(action, ["pending"]);
    };
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isPending()(asyncThunks[0]);
  }
  return function(action) {
    var matchers = asyncThunks.map(function(asyncThunk) {
      return asyncThunk.pending;
    });
    var combinedMatcher = isAnyOf.apply(void 0, matchers);
    return combinedMatcher(action);
  };
}
function isRejected() {
  var asyncThunks = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    asyncThunks[_i] = arguments[_i];
  }
  if (asyncThunks.length === 0) {
    return function(action) {
      return hasExpectedRequestMetadata(action, ["rejected"]);
    };
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejected()(asyncThunks[0]);
  }
  return function(action) {
    var matchers = asyncThunks.map(function(asyncThunk) {
      return asyncThunk.rejected;
    });
    var combinedMatcher = isAnyOf.apply(void 0, matchers);
    return combinedMatcher(action);
  };
}
function isRejectedWithValue() {
  var asyncThunks = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    asyncThunks[_i] = arguments[_i];
  }
  var hasFlag = function(action) {
    return action && action.meta && action.meta.rejectedWithValue;
  };
  if (asyncThunks.length === 0) {
    return function(action) {
      var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);
      return combinedMatcher(action);
    };
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isRejectedWithValue()(asyncThunks[0]);
  }
  return function(action) {
    var combinedMatcher = isAllOf(isRejected.apply(void 0, asyncThunks), hasFlag);
    return combinedMatcher(action);
  };
}
function isFulfilled() {
  var asyncThunks = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    asyncThunks[_i] = arguments[_i];
  }
  if (asyncThunks.length === 0) {
    return function(action) {
      return hasExpectedRequestMetadata(action, ["fulfilled"]);
    };
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isFulfilled()(asyncThunks[0]);
  }
  return function(action) {
    var matchers = asyncThunks.map(function(asyncThunk) {
      return asyncThunk.fulfilled;
    });
    var combinedMatcher = isAnyOf.apply(void 0, matchers);
    return combinedMatcher(action);
  };
}
function isAsyncThunkAction() {
  var asyncThunks = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    asyncThunks[_i] = arguments[_i];
  }
  if (asyncThunks.length === 0) {
    return function(action) {
      return hasExpectedRequestMetadata(action, ["pending", "fulfilled", "rejected"]);
    };
  }
  if (!isAsyncThunkArray(asyncThunks)) {
    return isAsyncThunkAction()(asyncThunks[0]);
  }
  return function(action) {
    var matchers = [];
    for (var _i2 = 0, asyncThunks_1 = asyncThunks; _i2 < asyncThunks_1.length; _i2++) {
      var asyncThunk = asyncThunks_1[_i2];
      matchers.push(asyncThunk.pending, asyncThunk.rejected, asyncThunk.fulfilled);
    }
    var combinedMatcher = isAnyOf.apply(void 0, matchers);
    return combinedMatcher(action);
  };
}
var alm = "listenerMiddleware";
createAction(alm + "/add");
createAction(alm + "/removeAll");
createAction(alm + "/remove");
var SHOULD_AUTOBATCH = "RTK_autoBatch";
var prepareAutoBatched = function() {
  return function(payload) {
    var _c;
    return {
      payload,
      meta: (_c = {}, _c[SHOULD_AUTOBATCH] = true, _c)
    };
  };
};
var promise$1;
typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb2) {
  return (promise$1 || (promise$1 = Promise.resolve())).then(cb2).catch(function(err) {
    return setTimeout(function() {
      throw err;
    }, 0);
  });
};
F$1();
var __generator = globalThis && globalThis.__generator || function(thisArg, body2) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f2, y2, t2, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done)
          return t2;
        if (y2 = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body2.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __spreadArray$1 = globalThis && globalThis.__spreadArray || function(to2, from2) {
  for (var i2 = 0, il2 = from2.length, j2 = to2.length; i2 < il2; i2++, j2++)
    to2[j2] = from2[i2];
  return to2;
};
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = function(obj, key, value) {
  return key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
};
var __spreadValues$1 = function(a2, b2) {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp$1.call(b2, prop))
      __defNormalProp$1(a2, prop, b2[prop]);
  if (__getOwnPropSymbols$1)
    for (var _j = 0, _k = __getOwnPropSymbols$1(b2); _j < _k.length; _j++) {
      var prop = _k[_j];
      if (__propIsEnum$1.call(b2, prop))
        __defNormalProp$1(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps$1 = function(a2, b2) {
  return __defProps$1(a2, __getOwnPropDescs$1(b2));
};
var __objRest = function(source, exclude) {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols$1)
    for (var _j = 0, _k = __getOwnPropSymbols$1(source); _j < _k.length; _j++) {
      var prop = _k[_j];
      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __async = function(__this, __arguments, generator) {
  return new Promise(function(resolve, reject) {
    var fulfilled = function(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = function(value) {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = function(x2) {
      return x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    };
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var QueryStatus;
(function(QueryStatus2) {
  QueryStatus2["uninitialized"] = "uninitialized";
  QueryStatus2["pending"] = "pending";
  QueryStatus2["fulfilled"] = "fulfilled";
  QueryStatus2["rejected"] = "rejected";
})(QueryStatus || (QueryStatus = {}));
function getRequestStatusFlags(status) {
  return {
    status,
    isUninitialized: status === QueryStatus.uninitialized,
    isLoading: status === QueryStatus.pending,
    isSuccess: status === QueryStatus.fulfilled,
    isError: status === QueryStatus.rejected
  };
}
function isAbsoluteUrl(url) {
  return new RegExp("(^|:)//").test(url);
}
var withoutTrailingSlash = function(url) {
  return url.replace(/\/$/, "");
};
var withoutLeadingSlash = function(url) {
  return url.replace(/^\//, "");
};
function joinUrls(base, url) {
  if (!base) {
    return url;
  }
  if (!url) {
    return base;
  }
  if (isAbsoluteUrl(url)) {
    return url;
  }
  var delimiter2 = base.endsWith("/") || !url.startsWith("?") ? "/" : "";
  base = withoutTrailingSlash(base);
  url = withoutLeadingSlash(url);
  return "" + base + delimiter2 + url;
}
var flatten = function(arr) {
  return [].concat.apply([], arr);
};
function isOnline() {
  return typeof navigator === "undefined" ? true : navigator.onLine === void 0 ? true : navigator.onLine;
}
function isDocumentVisible() {
  if (typeof document === "undefined") {
    return true;
  }
  return document.visibilityState !== "hidden";
}
var isPlainObject$2 = isPlainObject$3;
function copyWithStructuralSharing(oldObj, newObj) {
  if (oldObj === newObj || !(isPlainObject$2(oldObj) && isPlainObject$2(newObj) || Array.isArray(oldObj) && Array.isArray(newObj))) {
    return newObj;
  }
  var newKeys = Object.keys(newObj);
  var oldKeys = Object.keys(oldObj);
  var isSameObject = newKeys.length === oldKeys.length;
  var mergeObj = Array.isArray(newObj) ? [] : {};
  for (var _j = 0, newKeys_1 = newKeys; _j < newKeys_1.length; _j++) {
    var key = newKeys_1[_j];
    mergeObj[key] = copyWithStructuralSharing(oldObj[key], newObj[key]);
    if (isSameObject)
      isSameObject = oldObj[key] === mergeObj[key];
  }
  return isSameObject ? oldObj : mergeObj;
}
var defaultFetchFn = function() {
  var args = [];
  for (var _j = 0; _j < arguments.length; _j++) {
    args[_j] = arguments[_j];
  }
  return fetch.apply(void 0, args);
};
var defaultValidateStatus = function(response) {
  return response.status >= 200 && response.status <= 299;
};
var defaultIsJsonContentType = function(headers) {
  return /ion\/(vnd\.api\+)?json/.test(headers.get("content-type") || "");
};
function stripUndefined(obj) {
  if (!isPlainObject$3(obj)) {
    return obj;
  }
  var copy2 = __spreadValues$1({}, obj);
  for (var _j = 0, _k = Object.entries(copy2); _j < _k.length; _j++) {
    var _l = _k[_j], k2 = _l[0], v2 = _l[1];
    if (v2 === void 0)
      delete copy2[k2];
  }
  return copy2;
}
function fetchBaseQuery(_a) {
  var _this = this;
  if (_a === void 0) {
    _a = {};
  }
  var _b = _a, baseUrl = _b.baseUrl, _j = _b.prepareHeaders, prepareHeaders = _j === void 0 ? function(x2) {
    return x2;
  } : _j, _k = _b.fetchFn, fetchFn = _k === void 0 ? defaultFetchFn : _k, paramsSerializer = _b.paramsSerializer, _l = _b.isJsonContentType, isJsonContentType = _l === void 0 ? defaultIsJsonContentType : _l, _m = _b.jsonContentType, jsonContentType = _m === void 0 ? "application/json" : _m, jsonReplacer = _b.jsonReplacer, defaultTimeout = _b.timeout, globalResponseHandler = _b.responseHandler, globalValidateStatus = _b.validateStatus, baseFetchOptions = __objRest(_b, [
    "baseUrl",
    "prepareHeaders",
    "fetchFn",
    "paramsSerializer",
    "isJsonContentType",
    "jsonContentType",
    "jsonReplacer",
    "timeout",
    "responseHandler",
    "validateStatus"
  ]);
  if (typeof fetch === "undefined" && fetchFn === defaultFetchFn) {
    console.warn("Warning: `fetch` is not available. Please supply a custom `fetchFn` property to use `fetchBaseQuery` on SSR environments.");
  }
  return function(arg, api2) {
    return __async(_this, null, function() {
      var signal, getState, extra, endpoint, forced, type, meta, _a2, url, _j2, headers, _k2, params, _l2, responseHandler, _m2, validateStatus2, _o2, timeout, rest, config2, _p, isJsonifiable, divider, query, request, requestClone, response, timedOut, timeoutId, e_1, responseClone, resultData, responseText, handleResponseError_1, e_2;
      return __generator(this, function(_q) {
        switch (_q.label) {
          case 0:
            signal = api2.signal, getState = api2.getState, extra = api2.extra, endpoint = api2.endpoint, forced = api2.forced, type = api2.type;
            _a2 = typeof arg == "string" ? { url: arg } : arg, url = _a2.url, _j2 = _a2.headers, headers = _j2 === void 0 ? new Headers(baseFetchOptions.headers) : _j2, _k2 = _a2.params, params = _k2 === void 0 ? void 0 : _k2, _l2 = _a2.responseHandler, responseHandler = _l2 === void 0 ? globalResponseHandler != null ? globalResponseHandler : "json" : _l2, _m2 = _a2.validateStatus, validateStatus2 = _m2 === void 0 ? globalValidateStatus != null ? globalValidateStatus : defaultValidateStatus : _m2, _o2 = _a2.timeout, timeout = _o2 === void 0 ? defaultTimeout : _o2, rest = __objRest(_a2, [
              "url",
              "headers",
              "params",
              "responseHandler",
              "validateStatus",
              "timeout"
            ]);
            config2 = __spreadValues$1(__spreadProps$1(__spreadValues$1({}, baseFetchOptions), {
              signal
            }), rest);
            headers = new Headers(stripUndefined(headers));
            _p = config2;
            return [4, prepareHeaders(headers, {
              getState,
              extra,
              endpoint,
              forced,
              type
            })];
          case 1:
            _p.headers = _q.sent() || headers;
            isJsonifiable = function(body2) {
              return typeof body2 === "object" && (isPlainObject$3(body2) || Array.isArray(body2) || typeof body2.toJSON === "function");
            };
            if (!config2.headers.has("content-type") && isJsonifiable(config2.body)) {
              config2.headers.set("content-type", jsonContentType);
            }
            if (isJsonifiable(config2.body) && isJsonContentType(config2.headers)) {
              config2.body = JSON.stringify(config2.body, jsonReplacer);
            }
            if (params) {
              divider = ~url.indexOf("?") ? "&" : "?";
              query = paramsSerializer ? paramsSerializer(params) : new URLSearchParams(stripUndefined(params));
              url += divider + query;
            }
            url = joinUrls(baseUrl, url);
            request = new Request(url, config2);
            requestClone = new Request(url, config2);
            meta = { request: requestClone };
            timedOut = false, timeoutId = timeout && setTimeout(function() {
              timedOut = true;
              api2.abort();
            }, timeout);
            _q.label = 2;
          case 2:
            _q.trys.push([2, 4, 5, 6]);
            return [4, fetchFn(request)];
          case 3:
            response = _q.sent();
            return [3, 6];
          case 4:
            e_1 = _q.sent();
            return [2, {
              error: {
                status: timedOut ? "TIMEOUT_ERROR" : "FETCH_ERROR",
                error: String(e_1)
              },
              meta
            }];
          case 5:
            if (timeoutId)
              clearTimeout(timeoutId);
            return [
              7
              /*endfinally*/
            ];
          case 6:
            responseClone = response.clone();
            meta.response = responseClone;
            responseText = "";
            _q.label = 7;
          case 7:
            _q.trys.push([7, 9, , 10]);
            return [4, Promise.all([
              handleResponse(response, responseHandler).then(function(r2) {
                return resultData = r2;
              }, function(e2) {
                return handleResponseError_1 = e2;
              }),
              responseClone.text().then(function(r2) {
                return responseText = r2;
              }, function() {
              })
            ])];
          case 8:
            _q.sent();
            if (handleResponseError_1)
              throw handleResponseError_1;
            return [3, 10];
          case 9:
            e_2 = _q.sent();
            return [2, {
              error: {
                status: "PARSING_ERROR",
                originalStatus: response.status,
                data: responseText,
                error: String(e_2)
              },
              meta
            }];
          case 10:
            return [2, validateStatus2(response, resultData) ? {
              data: resultData,
              meta
            } : {
              error: {
                status: response.status,
                data: resultData
              },
              meta
            }];
        }
      });
    });
  };
  function handleResponse(response, responseHandler) {
    return __async(this, null, function() {
      var text;
      return __generator(this, function(_j2) {
        switch (_j2.label) {
          case 0:
            if (typeof responseHandler === "function") {
              return [2, responseHandler(response)];
            }
            if (responseHandler === "content-type") {
              responseHandler = isJsonContentType(response.headers) ? "json" : "text";
            }
            if (!(responseHandler === "json"))
              return [3, 2];
            return [4, response.text()];
          case 1:
            text = _j2.sent();
            return [2, text.length ? JSON.parse(text) : null];
          case 2:
            return [2, response.text()];
        }
      });
    });
  }
}
var HandledError = (
  /** @class */
  function() {
    function HandledError2(value, meta) {
      if (meta === void 0) {
        meta = void 0;
      }
      this.value = value;
      this.meta = meta;
    }
    return HandledError2;
  }()
);
var onFocus = /* @__PURE__ */ createAction("__rtkq/focused");
var onFocusLost = /* @__PURE__ */ createAction("__rtkq/unfocused");
var onOnline = /* @__PURE__ */ createAction("__rtkq/online");
var onOffline = /* @__PURE__ */ createAction("__rtkq/offline");
var DefinitionType$1;
(function(DefinitionType2) {
  DefinitionType2["query"] = "query";
  DefinitionType2["mutation"] = "mutation";
})(DefinitionType$1 || (DefinitionType$1 = {}));
function isQueryDefinition$1(e2) {
  return e2.type === DefinitionType$1.query;
}
function isMutationDefinition$1(e2) {
  return e2.type === DefinitionType$1.mutation;
}
function calculateProvidedBy(description, result, error, queryArg, meta, assertTagTypes) {
  if (isFunction$1(description)) {
    return description(result, error, queryArg, meta).map(expandTagDescription).map(assertTagTypes);
  }
  if (Array.isArray(description)) {
    return description.map(expandTagDescription).map(assertTagTypes);
  }
  return [];
}
function isFunction$1(t2) {
  return typeof t2 === "function";
}
function expandTagDescription(description) {
  return typeof description === "string" ? { type: description } : description;
}
function isNotNullish(v2) {
  return v2 != null;
}
var forceQueryFnSymbol = Symbol("forceQueryFn");
var isUpsertQuery = function(arg) {
  return typeof arg[forceQueryFnSymbol] === "function";
};
function buildInitiate(_j) {
  var serializeQueryArgs = _j.serializeQueryArgs, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, api2 = _j.api, context = _j.context;
  var runningQueries = /* @__PURE__ */ new Map();
  var runningMutations = /* @__PURE__ */ new Map();
  var _k = api2.internalActions, unsubscribeQueryResult = _k.unsubscribeQueryResult, removeMutationResult = _k.removeMutationResult, updateSubscriptionOptions = _k.updateSubscriptionOptions;
  return {
    buildInitiateQuery,
    buildInitiateMutation,
    getRunningQueryThunk,
    getRunningMutationThunk,
    getRunningQueriesThunk,
    getRunningMutationsThunk,
    getRunningOperationPromises,
    removalWarning
  };
  function removalWarning() {
    throw new Error("This method had to be removed due to a conceptual bug in RTK.\n       Please see https://github.com/reduxjs/redux-toolkit/pull/2481 for details.\n       See https://redux-toolkit.js.org/rtk-query/usage/server-side-rendering for new guidance on SSR.");
  }
  function getRunningOperationPromises() {
    if (typeof process !== "undefined" && false) {
      removalWarning();
    } else {
      var extract = function(v2) {
        return Array.from(v2.values()).flatMap(function(queriesForStore) {
          return queriesForStore ? Object.values(queriesForStore) : [];
        });
      };
      return __spreadArray$1(__spreadArray$1([], extract(runningQueries)), extract(runningMutations)).filter(isNotNullish);
    }
  }
  function getRunningQueryThunk(endpointName, queryArgs) {
    return function(dispatch) {
      var _a;
      var endpointDefinition = context.endpointDefinitions[endpointName];
      var queryCacheKey = serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      });
      return (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
    };
  }
  function getRunningMutationThunk(_endpointName, fixedCacheKeyOrRequestId) {
    return function(dispatch) {
      var _a;
      return (_a = runningMutations.get(dispatch)) == null ? void 0 : _a[fixedCacheKeyOrRequestId];
    };
  }
  function getRunningQueriesThunk() {
    return function(dispatch) {
      return Object.values(runningQueries.get(dispatch) || {}).filter(isNotNullish);
    };
  }
  function getRunningMutationsThunk() {
    return function(dispatch) {
      return Object.values(runningMutations.get(dispatch) || {}).filter(isNotNullish);
    };
  }
  function buildInitiateQuery(endpointName, endpointDefinition) {
    var queryAction = function(arg, _j2) {
      var _k2 = _j2 === void 0 ? {} : _j2, _l = _k2.subscribe, subscribe = _l === void 0 ? true : _l, forceRefetch = _k2.forceRefetch, subscriptionOptions = _k2.subscriptionOptions, _m = forceQueryFnSymbol, forceQueryFn = _k2[_m];
      return function(dispatch, getState) {
        var _j3;
        var _a;
        var queryCacheKey = serializeQueryArgs({
          queryArgs: arg,
          endpointDefinition,
          endpointName
        });
        var thunk2 = queryThunk((_j3 = {
          type: "query",
          subscribe,
          forceRefetch,
          subscriptionOptions,
          endpointName,
          originalArgs: arg,
          queryCacheKey
        }, _j3[forceQueryFnSymbol] = forceQueryFn, _j3));
        var selector = api2.endpoints[endpointName].select(arg);
        var thunkResult = dispatch(thunk2);
        var stateAfter = selector(getState());
        var requestId = thunkResult.requestId, abort = thunkResult.abort;
        var skippedSynchronously = stateAfter.requestId !== requestId;
        var runningQuery = (_a = runningQueries.get(dispatch)) == null ? void 0 : _a[queryCacheKey];
        var selectFromState = function() {
          return selector(getState());
        };
        var statePromise = Object.assign(forceQueryFn ? thunkResult.then(selectFromState) : skippedSynchronously && !runningQuery ? Promise.resolve(stateAfter) : Promise.all([runningQuery, thunkResult]).then(selectFromState), {
          arg,
          requestId,
          subscriptionOptions,
          queryCacheKey,
          abort,
          unwrap: function() {
            return __async(this, null, function() {
              var result;
              return __generator(this, function(_j4) {
                switch (_j4.label) {
                  case 0:
                    return [4, statePromise];
                  case 1:
                    result = _j4.sent();
                    if (result.isError) {
                      throw result.error;
                    }
                    return [2, result.data];
                }
              });
            });
          },
          refetch: function() {
            return dispatch(queryAction(arg, { subscribe: false, forceRefetch: true }));
          },
          unsubscribe: function() {
            if (subscribe)
              dispatch(unsubscribeQueryResult({
                queryCacheKey,
                requestId
              }));
          },
          updateSubscriptionOptions: function(options) {
            statePromise.subscriptionOptions = options;
            dispatch(updateSubscriptionOptions({
              endpointName,
              requestId,
              queryCacheKey,
              options
            }));
          }
        });
        if (!runningQuery && !skippedSynchronously && !forceQueryFn) {
          var running_1 = runningQueries.get(dispatch) || {};
          running_1[queryCacheKey] = statePromise;
          runningQueries.set(dispatch, running_1);
          statePromise.then(function() {
            delete running_1[queryCacheKey];
            if (!Object.keys(running_1).length) {
              runningQueries.delete(dispatch);
            }
          });
        }
        return statePromise;
      };
    };
    return queryAction;
  }
  function buildInitiateMutation(endpointName) {
    return function(arg, _j2) {
      var _k2 = _j2 === void 0 ? {} : _j2, _l = _k2.track, track = _l === void 0 ? true : _l, fixedCacheKey = _k2.fixedCacheKey;
      return function(dispatch, getState) {
        var thunk2 = mutationThunk({
          type: "mutation",
          endpointName,
          originalArgs: arg,
          track,
          fixedCacheKey
        });
        var thunkResult = dispatch(thunk2);
        var requestId = thunkResult.requestId, abort = thunkResult.abort, unwrap = thunkResult.unwrap;
        var returnValuePromise = thunkResult.unwrap().then(function(data) {
          return { data };
        }).catch(function(error) {
          return { error };
        });
        var reset = function() {
          dispatch(removeMutationResult({ requestId, fixedCacheKey }));
        };
        var ret = Object.assign(returnValuePromise, {
          arg: thunkResult.arg,
          requestId,
          abort,
          unwrap,
          unsubscribe: reset,
          reset
        });
        var running = runningMutations.get(dispatch) || {};
        runningMutations.set(dispatch, running);
        running[requestId] = ret;
        ret.then(function() {
          delete running[requestId];
          if (!Object.keys(running).length) {
            runningMutations.delete(dispatch);
          }
        });
        if (fixedCacheKey) {
          running[fixedCacheKey] = ret;
          ret.then(function() {
            if (running[fixedCacheKey] === ret) {
              delete running[fixedCacheKey];
              if (!Object.keys(running).length) {
                runningMutations.delete(dispatch);
              }
            }
          });
        }
        return ret;
      };
    };
  }
}
function defaultTransformResponse(baseQueryReturnValue) {
  return baseQueryReturnValue;
}
function buildThunks(_j) {
  var _this = this;
  var reducerPath = _j.reducerPath, baseQuery = _j.baseQuery, endpointDefinitions = _j.context.endpointDefinitions, serializeQueryArgs = _j.serializeQueryArgs, api2 = _j.api, assertTagType = _j.assertTagType;
  var patchQueryData = function(endpointName, args, patches, updateProvided) {
    return function(dispatch, getState) {
      var endpointDefinition = endpointDefinitions[endpointName];
      var queryCacheKey = serializeQueryArgs({
        queryArgs: args,
        endpointDefinition,
        endpointName
      });
      dispatch(api2.internalActions.queryResultPatched({ queryCacheKey, patches }));
      if (!updateProvided) {
        return;
      }
      var newValue = api2.endpoints[endpointName].select(args)(getState());
      var providedTags = calculateProvidedBy(endpointDefinition.providesTags, newValue.data, void 0, args, {}, assertTagType);
      dispatch(api2.internalActions.updateProvidedBy({ queryCacheKey, providedTags }));
    };
  };
  var updateQueryData = function(endpointName, args, updateRecipe, updateProvided) {
    if (updateProvided === void 0) {
      updateProvided = true;
    }
    return function(dispatch, getState) {
      var _j2, _k;
      var endpointDefinition = api2.endpoints[endpointName];
      var currentState = endpointDefinition.select(args)(getState());
      var ret = {
        patches: [],
        inversePatches: [],
        undo: function() {
          return dispatch(api2.util.patchQueryData(endpointName, args, ret.inversePatches, updateProvided));
        }
      };
      if (currentState.status === QueryStatus.uninitialized) {
        return ret;
      }
      var newValue;
      if ("data" in currentState) {
        if (t(currentState.data)) {
          var _l = cn(currentState.data, updateRecipe), value = _l[0], patches = _l[1], inversePatches = _l[2];
          (_j2 = ret.patches).push.apply(_j2, patches);
          (_k = ret.inversePatches).push.apply(_k, inversePatches);
          newValue = value;
        } else {
          newValue = updateRecipe(currentState.data);
          ret.patches.push({ op: "replace", path: [], value: newValue });
          ret.inversePatches.push({
            op: "replace",
            path: [],
            value: currentState.data
          });
        }
      }
      dispatch(api2.util.patchQueryData(endpointName, args, ret.patches, updateProvided));
      return ret;
    };
  };
  var upsertQueryData = function(endpointName, args, value) {
    return function(dispatch) {
      var _j2;
      return dispatch(api2.endpoints[endpointName].initiate(args, (_j2 = {
        subscribe: false,
        forceRefetch: true
      }, _j2[forceQueryFnSymbol] = function() {
        return {
          data: value
        };
      }, _j2)));
    };
  };
  var executeEndpoint = function(_0, _1) {
    return __async(_this, [_0, _1], function(arg, _j2) {
      var endpointDefinition, transformResponse2, result, baseQueryApi_1, forceQueryFn, what, err, _k, _l, key, _m, error_1, catchedError, transformErrorResponse, _o2, e_4;
      var _p, _q;
      var signal = _j2.signal, abort = _j2.abort, rejectWithValue = _j2.rejectWithValue, fulfillWithValue = _j2.fulfillWithValue, dispatch = _j2.dispatch, getState = _j2.getState, extra = _j2.extra;
      return __generator(this, function(_r) {
        switch (_r.label) {
          case 0:
            endpointDefinition = endpointDefinitions[arg.endpointName];
            _r.label = 1;
          case 1:
            _r.trys.push([1, 8, , 13]);
            transformResponse2 = defaultTransformResponse;
            result = void 0;
            baseQueryApi_1 = {
              signal,
              abort,
              dispatch,
              getState,
              extra,
              endpoint: arg.endpointName,
              type: arg.type,
              forced: arg.type === "query" ? isForcedQuery(arg, getState()) : void 0
            };
            forceQueryFn = arg.type === "query" ? arg[forceQueryFnSymbol] : void 0;
            if (!forceQueryFn)
              return [3, 2];
            result = forceQueryFn();
            return [3, 6];
          case 2:
            if (!endpointDefinition.query)
              return [3, 4];
            return [4, baseQuery(endpointDefinition.query(arg.originalArgs), baseQueryApi_1, endpointDefinition.extraOptions)];
          case 3:
            result = _r.sent();
            if (endpointDefinition.transformResponse) {
              transformResponse2 = endpointDefinition.transformResponse;
            }
            return [3, 6];
          case 4:
            return [4, endpointDefinition.queryFn(arg.originalArgs, baseQueryApi_1, endpointDefinition.extraOptions, function(arg2) {
              return baseQuery(arg2, baseQueryApi_1, endpointDefinition.extraOptions);
            })];
          case 5:
            result = _r.sent();
            _r.label = 6;
          case 6:
            if (typeof process !== "undefined" && false) {
              what = endpointDefinition.query ? "`baseQuery`" : "`queryFn`";
              err = void 0;
              if (!result) {
                err = what + " did not return anything.";
              } else if (typeof result !== "object") {
                err = what + " did not return an object.";
              } else if (result.error && result.data) {
                err = what + " returned an object containing both `error` and `result`.";
              } else if (result.error === void 0 && result.data === void 0) {
                err = what + " returned an object containing neither a valid `error` and `result`. At least one of them should not be `undefined`";
              } else {
                for (_k = 0, _l = Object.keys(result); _k < _l.length; _k++) {
                  key = _l[_k];
                  if (key !== "error" && key !== "data" && key !== "meta") {
                    err = "The object returned by " + what + " has the unknown property " + key + ".";
                    break;
                  }
                }
              }
              if (err) {
                console.error("Error encountered handling the endpoint " + arg.endpointName + ".\n              " + err + "\n              It needs to return an object with either the shape `{ data: <value> }` or `{ error: <value> }` that may contain an optional `meta` property.\n              Object returned was:", result);
              }
            }
            if (result.error)
              throw new HandledError(result.error, result.meta);
            _m = fulfillWithValue;
            return [4, transformResponse2(result.data, result.meta, arg.originalArgs)];
          case 7:
            return [2, _m.apply(void 0, [_r.sent(), (_p = {
              fulfilledTimeStamp: Date.now(),
              baseQueryMeta: result.meta
            }, _p[SHOULD_AUTOBATCH] = true, _p)])];
          case 8:
            error_1 = _r.sent();
            catchedError = error_1;
            if (!(catchedError instanceof HandledError))
              return [3, 12];
            transformErrorResponse = defaultTransformResponse;
            if (endpointDefinition.query && endpointDefinition.transformErrorResponse) {
              transformErrorResponse = endpointDefinition.transformErrorResponse;
            }
            _r.label = 9;
          case 9:
            _r.trys.push([9, 11, , 12]);
            _o2 = rejectWithValue;
            return [4, transformErrorResponse(catchedError.value, catchedError.meta, arg.originalArgs)];
          case 10:
            return [2, _o2.apply(void 0, [_r.sent(), (_q = { baseQueryMeta: catchedError.meta }, _q[SHOULD_AUTOBATCH] = true, _q)])];
          case 11:
            e_4 = _r.sent();
            catchedError = e_4;
            return [3, 12];
          case 12:
            if (typeof process !== "undefined" && false) {
              console.error('An unhandled error occurred processing a request for the endpoint "' + arg.endpointName + '".\nIn the case of an unhandled error, no tags will be "provided" or "invalidated".', catchedError);
            } else {
              console.error(catchedError);
            }
            throw catchedError;
          case 13:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  };
  function isForcedQuery(arg, state) {
    var _a, _b, _c, _d;
    var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[arg.queryCacheKey];
    var baseFetchOnMountOrArgChange = (_c = state[reducerPath]) == null ? void 0 : _c.config.refetchOnMountOrArgChange;
    var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
    var refetchVal = (_d = arg.forceRefetch) != null ? _d : arg.subscribe && baseFetchOnMountOrArgChange;
    if (refetchVal) {
      return refetchVal === true || (Number(/* @__PURE__ */ new Date()) - Number(fulfilledVal)) / 1e3 >= refetchVal;
    }
    return false;
  }
  var queryThunk = createAsyncThunk(reducerPath + "/executeQuery", executeEndpoint, {
    getPendingMeta: function() {
      var _j2;
      return _j2 = { startedTimeStamp: Date.now() }, _j2[SHOULD_AUTOBATCH] = true, _j2;
    },
    condition: function(queryThunkArgs, _j2) {
      var getState = _j2.getState;
      var _a, _b, _c;
      var state = getState();
      var requestState = (_b = (_a = state[reducerPath]) == null ? void 0 : _a.queries) == null ? void 0 : _b[queryThunkArgs.queryCacheKey];
      var fulfilledVal = requestState == null ? void 0 : requestState.fulfilledTimeStamp;
      var currentArg = queryThunkArgs.originalArgs;
      var previousArg = requestState == null ? void 0 : requestState.originalArgs;
      var endpointDefinition = endpointDefinitions[queryThunkArgs.endpointName];
      if (isUpsertQuery(queryThunkArgs)) {
        return true;
      }
      if ((requestState == null ? void 0 : requestState.status) === "pending") {
        return false;
      }
      if (isForcedQuery(queryThunkArgs, state)) {
        return true;
      }
      if (isQueryDefinition$1(endpointDefinition) && ((_c = endpointDefinition == null ? void 0 : endpointDefinition.forceRefetch) == null ? void 0 : _c.call(endpointDefinition, {
        currentArg,
        previousArg,
        endpointState: requestState,
        state
      }))) {
        return true;
      }
      if (fulfilledVal) {
        return false;
      }
      return true;
    },
    dispatchConditionRejection: true
  });
  var mutationThunk = createAsyncThunk(reducerPath + "/executeMutation", executeEndpoint, {
    getPendingMeta: function() {
      var _j2;
      return _j2 = { startedTimeStamp: Date.now() }, _j2[SHOULD_AUTOBATCH] = true, _j2;
    }
  });
  var hasTheForce = function(options) {
    return "force" in options;
  };
  var hasMaxAge = function(options) {
    return "ifOlderThan" in options;
  };
  var prefetch = function(endpointName, arg, options) {
    return function(dispatch, getState) {
      var force = hasTheForce(options) && options.force;
      var maxAge = hasMaxAge(options) && options.ifOlderThan;
      var queryAction = function(force2) {
        if (force2 === void 0) {
          force2 = true;
        }
        return api2.endpoints[endpointName].initiate(arg, { forceRefetch: force2 });
      };
      var latestStateValue = api2.endpoints[endpointName].select(arg)(getState());
      if (force) {
        dispatch(queryAction());
      } else if (maxAge) {
        var lastFulfilledTs = latestStateValue == null ? void 0 : latestStateValue.fulfilledTimeStamp;
        if (!lastFulfilledTs) {
          dispatch(queryAction());
          return;
        }
        var shouldRetrigger = (Number(/* @__PURE__ */ new Date()) - Number(new Date(lastFulfilledTs))) / 1e3 >= maxAge;
        if (shouldRetrigger) {
          dispatch(queryAction());
        }
      } else {
        dispatch(queryAction(false));
      }
    };
  };
  function matchesEndpoint(endpointName) {
    return function(action) {
      var _a, _b;
      return ((_b = (_a = action == null ? void 0 : action.meta) == null ? void 0 : _a.arg) == null ? void 0 : _b.endpointName) === endpointName;
    };
  }
  function buildMatchThunkActions(thunk2, endpointName) {
    return {
      matchPending: isAllOf(isPending(thunk2), matchesEndpoint(endpointName)),
      matchFulfilled: isAllOf(isFulfilled(thunk2), matchesEndpoint(endpointName)),
      matchRejected: isAllOf(isRejected(thunk2), matchesEndpoint(endpointName))
    };
  }
  return {
    queryThunk,
    mutationThunk,
    prefetch,
    updateQueryData,
    upsertQueryData,
    patchQueryData,
    buildMatchThunkActions
  };
}
function calculateProvidedByThunk(action, type, endpointDefinitions, assertTagType) {
  return calculateProvidedBy(endpointDefinitions[action.meta.arg.endpointName][type], isFulfilled(action) ? action.payload : void 0, isRejectedWithValue(action) ? action.payload : void 0, action.meta.arg.originalArgs, "baseQueryMeta" in action.meta ? action.meta.baseQueryMeta : void 0, assertTagType);
}
function updateQuerySubstateIfExists(state, queryCacheKey, update2) {
  var substate = state[queryCacheKey];
  if (substate) {
    update2(substate);
  }
}
function getMutationCacheKey(id2) {
  var _a;
  return (_a = "arg" in id2 ? id2.arg.fixedCacheKey : id2.fixedCacheKey) != null ? _a : id2.requestId;
}
function updateMutationSubstateIfExists(state, id2, update2) {
  var substate = state[getMutationCacheKey(id2)];
  if (substate) {
    update2(substate);
  }
}
var initialState$1 = {};
function buildSlice(_j) {
  var reducerPath = _j.reducerPath, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk, _k = _j.context, definitions = _k.endpointDefinitions, apiUid = _k.apiUid, extractRehydrationInfo = _k.extractRehydrationInfo, hasRehydrationInfo = _k.hasRehydrationInfo, assertTagType = _j.assertTagType, config2 = _j.config;
  var resetApiState = createAction(reducerPath + "/resetApiState");
  var querySlice = createSlice({
    name: reducerPath + "/queries",
    initialState: initialState$1,
    reducers: {
      removeQueryResult: {
        reducer: function(draft, _j2) {
          var queryCacheKey = _j2.payload.queryCacheKey;
          delete draft[queryCacheKey];
        },
        prepare: prepareAutoBatched()
      },
      queryResultPatched: {
        reducer: function(draft, _j2) {
          var _k2 = _j2.payload, queryCacheKey = _k2.queryCacheKey, patches = _k2.patches;
          updateQuerySubstateIfExists(draft, queryCacheKey, function(substate) {
            substate.data = pn(substate.data, patches.concat());
          });
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers: function(builder) {
      builder.addCase(queryThunk.pending, function(draft, _j2) {
        var meta = _j2.meta, arg = _j2.meta.arg;
        var _a, _b;
        var upserting = isUpsertQuery(arg);
        if (arg.subscribe || upserting) {
          (_b = draft[_a = arg.queryCacheKey]) != null ? _b : draft[_a] = {
            status: QueryStatus.uninitialized,
            endpointName: arg.endpointName
          };
        }
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {
          substate.status = QueryStatus.pending;
          substate.requestId = upserting && substate.requestId ? substate.requestId : meta.requestId;
          if (arg.originalArgs !== void 0) {
            substate.originalArgs = arg.originalArgs;
          }
          substate.startedTimeStamp = meta.startedTimeStamp;
        });
      }).addCase(queryThunk.fulfilled, function(draft, _j2) {
        var meta = _j2.meta, payload = _j2.payload;
        updateQuerySubstateIfExists(draft, meta.arg.queryCacheKey, function(substate) {
          var _a;
          if (substate.requestId !== meta.requestId && !isUpsertQuery(meta.arg))
            return;
          var merge2 = definitions[meta.arg.endpointName].merge;
          substate.status = QueryStatus.fulfilled;
          if (merge2) {
            if (substate.data !== void 0) {
              var fulfilledTimeStamp_1 = meta.fulfilledTimeStamp, arg_1 = meta.arg, baseQueryMeta_1 = meta.baseQueryMeta, requestId_1 = meta.requestId;
              var newData = fn(substate.data, function(draftSubstateData) {
                return merge2(draftSubstateData, payload, {
                  arg: arg_1.originalArgs,
                  baseQueryMeta: baseQueryMeta_1,
                  fulfilledTimeStamp: fulfilledTimeStamp_1,
                  requestId: requestId_1
                });
              });
              substate.data = newData;
            } else {
              substate.data = payload;
            }
          } else {
            substate.data = ((_a = definitions[meta.arg.endpointName].structuralSharing) != null ? _a : true) ? copyWithStructuralSharing(r$1(substate.data) ? e(substate.data) : substate.data, payload) : payload;
          }
          delete substate.error;
          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
        });
      }).addCase(queryThunk.rejected, function(draft, _j2) {
        var _k2 = _j2.meta, condition = _k2.condition, arg = _k2.arg, requestId = _k2.requestId, error = _j2.error, payload = _j2.payload;
        updateQuerySubstateIfExists(draft, arg.queryCacheKey, function(substate) {
          if (condition)
            ;
          else {
            if (substate.requestId !== requestId)
              return;
            substate.status = QueryStatus.rejected;
            substate.error = payload != null ? payload : error;
          }
        });
      }).addMatcher(hasRehydrationInfo, function(draft, action) {
        var queries = extractRehydrationInfo(action).queries;
        for (var _j2 = 0, _k2 = Object.entries(queries); _j2 < _k2.length; _j2++) {
          var _l = _k2[_j2], key = _l[0], entry = _l[1];
          if ((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) {
            draft[key] = entry;
          }
        }
      });
    }
  });
  var mutationSlice = createSlice({
    name: reducerPath + "/mutations",
    initialState: initialState$1,
    reducers: {
      removeMutationResult: {
        reducer: function(draft, _j2) {
          var payload = _j2.payload;
          var cacheKey = getMutationCacheKey(payload);
          if (cacheKey in draft) {
            delete draft[cacheKey];
          }
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers: function(builder) {
      builder.addCase(mutationThunk.pending, function(draft, _j2) {
        var meta = _j2.meta, _k2 = _j2.meta, requestId = _k2.requestId, arg = _k2.arg, startedTimeStamp = _k2.startedTimeStamp;
        if (!arg.track)
          return;
        draft[getMutationCacheKey(meta)] = {
          requestId,
          status: QueryStatus.pending,
          endpointName: arg.endpointName,
          startedTimeStamp
        };
      }).addCase(mutationThunk.fulfilled, function(draft, _j2) {
        var payload = _j2.payload, meta = _j2.meta;
        if (!meta.arg.track)
          return;
        updateMutationSubstateIfExists(draft, meta, function(substate) {
          if (substate.requestId !== meta.requestId)
            return;
          substate.status = QueryStatus.fulfilled;
          substate.data = payload;
          substate.fulfilledTimeStamp = meta.fulfilledTimeStamp;
        });
      }).addCase(mutationThunk.rejected, function(draft, _j2) {
        var payload = _j2.payload, error = _j2.error, meta = _j2.meta;
        if (!meta.arg.track)
          return;
        updateMutationSubstateIfExists(draft, meta, function(substate) {
          if (substate.requestId !== meta.requestId)
            return;
          substate.status = QueryStatus.rejected;
          substate.error = payload != null ? payload : error;
        });
      }).addMatcher(hasRehydrationInfo, function(draft, action) {
        var mutations = extractRehydrationInfo(action).mutations;
        for (var _j2 = 0, _k2 = Object.entries(mutations); _j2 < _k2.length; _j2++) {
          var _l = _k2[_j2], key = _l[0], entry = _l[1];
          if (((entry == null ? void 0 : entry.status) === QueryStatus.fulfilled || (entry == null ? void 0 : entry.status) === QueryStatus.rejected) && key !== (entry == null ? void 0 : entry.requestId)) {
            draft[key] = entry;
          }
        }
      });
    }
  });
  var invalidationSlice = createSlice({
    name: reducerPath + "/invalidation",
    initialState: initialState$1,
    reducers: {
      updateProvidedBy: {
        reducer: function(draft, action) {
          var _a, _b, _c, _d;
          var _j2 = action.payload, queryCacheKey = _j2.queryCacheKey, providedTags = _j2.providedTags;
          for (var _k2 = 0, _l = Object.values(draft); _k2 < _l.length; _k2++) {
            var tagTypeSubscriptions = _l[_k2];
            for (var _m = 0, _o2 = Object.values(tagTypeSubscriptions); _m < _o2.length; _m++) {
              var idSubscriptions = _o2[_m];
              var foundAt = idSubscriptions.indexOf(queryCacheKey);
              if (foundAt !== -1) {
                idSubscriptions.splice(foundAt, 1);
              }
            }
          }
          for (var _p = 0, providedTags_1 = providedTags; _p < providedTags_1.length; _p++) {
            var _q = providedTags_1[_p], type = _q.type, id2 = _q.id;
            var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id2 || "__internal_without_id"]) != null ? _d : _b[_c] = [];
            var alreadySubscribed = subscribedQueries.includes(queryCacheKey);
            if (!alreadySubscribed) {
              subscribedQueries.push(queryCacheKey);
            }
          }
        },
        prepare: prepareAutoBatched()
      }
    },
    extraReducers: function(builder) {
      builder.addCase(querySlice.actions.removeQueryResult, function(draft, _j2) {
        var queryCacheKey = _j2.payload.queryCacheKey;
        for (var _k2 = 0, _l = Object.values(draft); _k2 < _l.length; _k2++) {
          var tagTypeSubscriptions = _l[_k2];
          for (var _m = 0, _o2 = Object.values(tagTypeSubscriptions); _m < _o2.length; _m++) {
            var idSubscriptions = _o2[_m];
            var foundAt = idSubscriptions.indexOf(queryCacheKey);
            if (foundAt !== -1) {
              idSubscriptions.splice(foundAt, 1);
            }
          }
        }
      }).addMatcher(hasRehydrationInfo, function(draft, action) {
        var _a, _b, _c, _d;
        var provided = extractRehydrationInfo(action).provided;
        for (var _j2 = 0, _k2 = Object.entries(provided); _j2 < _k2.length; _j2++) {
          var _l = _k2[_j2], type = _l[0], incomingTags = _l[1];
          for (var _m = 0, _o2 = Object.entries(incomingTags); _m < _o2.length; _m++) {
            var _p = _o2[_m], id2 = _p[0], cacheKeys = _p[1];
            var subscribedQueries = (_d = (_b = (_a = draft[type]) != null ? _a : draft[type] = {})[_c = id2 || "__internal_without_id"]) != null ? _d : _b[_c] = [];
            for (var _q = 0, cacheKeys_1 = cacheKeys; _q < cacheKeys_1.length; _q++) {
              var queryCacheKey = cacheKeys_1[_q];
              var alreadySubscribed = subscribedQueries.includes(queryCacheKey);
              if (!alreadySubscribed) {
                subscribedQueries.push(queryCacheKey);
              }
            }
          }
        }
      }).addMatcher(isAnyOf(isFulfilled(queryThunk), isRejectedWithValue(queryThunk)), function(draft, action) {
        var providedTags = calculateProvidedByThunk(action, "providesTags", definitions, assertTagType);
        var queryCacheKey = action.meta.arg.queryCacheKey;
        invalidationSlice.caseReducers.updateProvidedBy(draft, invalidationSlice.actions.updateProvidedBy({
          queryCacheKey,
          providedTags
        }));
      });
    }
  });
  var subscriptionSlice = createSlice({
    name: reducerPath + "/subscriptions",
    initialState: initialState$1,
    reducers: {
      updateSubscriptionOptions: function(d2, a2) {
      },
      unsubscribeQueryResult: function(d2, a2) {
      },
      internal_probeSubscription: function(d2, a2) {
      }
    }
  });
  var internalSubscriptionsSlice = createSlice({
    name: reducerPath + "/internalSubscriptions",
    initialState: initialState$1,
    reducers: {
      subscriptionsUpdated: {
        reducer: function(state, action) {
          return pn(state, action.payload);
        },
        prepare: prepareAutoBatched()
      }
    }
  });
  var configSlice = createSlice({
    name: reducerPath + "/config",
    initialState: __spreadValues$1({
      online: isOnline(),
      focused: isDocumentVisible(),
      middlewareRegistered: false
    }, config2),
    reducers: {
      middlewareRegistered: function(state, _j2) {
        var payload = _j2.payload;
        state.middlewareRegistered = state.middlewareRegistered === "conflict" || apiUid !== payload ? "conflict" : true;
      }
    },
    extraReducers: function(builder) {
      builder.addCase(onOnline, function(state) {
        state.online = true;
      }).addCase(onOffline, function(state) {
        state.online = false;
      }).addCase(onFocus, function(state) {
        state.focused = true;
      }).addCase(onFocusLost, function(state) {
        state.focused = false;
      }).addMatcher(hasRehydrationInfo, function(draft) {
        return __spreadValues$1({}, draft);
      });
    }
  });
  var combinedReducer = combineReducers({
    queries: querySlice.reducer,
    mutations: mutationSlice.reducer,
    provided: invalidationSlice.reducer,
    subscriptions: internalSubscriptionsSlice.reducer,
    config: configSlice.reducer
  });
  var reducer2 = function(state, action) {
    return combinedReducer(resetApiState.match(action) ? void 0 : state, action);
  };
  var actions2 = __spreadProps$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1(__spreadValues$1({}, configSlice.actions), querySlice.actions), subscriptionSlice.actions), internalSubscriptionsSlice.actions), mutationSlice.actions), invalidationSlice.actions), {
    unsubscribeMutationResult: mutationSlice.actions.removeMutationResult,
    resetApiState
  });
  return { reducer: reducer2, actions: actions2 };
}
var skipToken = /* @__PURE__ */ Symbol.for("RTKQ/skipToken");
var initialSubState = {
  status: QueryStatus.uninitialized
};
var defaultQuerySubState = /* @__PURE__ */ fn(initialSubState, function() {
});
var defaultMutationSubState = /* @__PURE__ */ fn(initialSubState, function() {
});
function buildSelectors(_j) {
  var serializeQueryArgs = _j.serializeQueryArgs, reducerPath = _j.reducerPath;
  var selectSkippedQuery = function(state) {
    return defaultQuerySubState;
  };
  var selectSkippedMutation = function(state) {
    return defaultMutationSubState;
  };
  return { buildQuerySelector, buildMutationSelector, selectInvalidatedBy };
  function withRequestFlags(substate) {
    return __spreadValues$1(__spreadValues$1({}, substate), getRequestStatusFlags(substate.status));
  }
  function selectInternalState(rootState) {
    var state = rootState[reducerPath];
    return state;
  }
  function buildQuerySelector(endpointName, endpointDefinition) {
    return function(queryArgs) {
      var serializedArgs = serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      });
      var selectQuerySubstate = function(state) {
        var _a, _b, _c;
        return (_c = (_b = (_a = selectInternalState(state)) == null ? void 0 : _a.queries) == null ? void 0 : _b[serializedArgs]) != null ? _c : defaultQuerySubState;
      };
      var finalSelectQuerySubState = queryArgs === skipToken ? selectSkippedQuery : selectQuerySubstate;
      return createSelector(finalSelectQuerySubState, withRequestFlags);
    };
  }
  function buildMutationSelector() {
    return function(id2) {
      var _a;
      var mutationId;
      if (typeof id2 === "object") {
        mutationId = (_a = getMutationCacheKey(id2)) != null ? _a : skipToken;
      } else {
        mutationId = id2;
      }
      var selectMutationSubstate = function(state) {
        var _a2, _b, _c;
        return (_c = (_b = (_a2 = selectInternalState(state)) == null ? void 0 : _a2.mutations) == null ? void 0 : _b[mutationId]) != null ? _c : defaultMutationSubState;
      };
      var finalSelectMutationSubstate = mutationId === skipToken ? selectSkippedMutation : selectMutationSubstate;
      return createSelector(finalSelectMutationSubstate, withRequestFlags);
    };
  }
  function selectInvalidatedBy(state, tags2) {
    var _a;
    var apiState = state[reducerPath];
    var toInvalidate = /* @__PURE__ */ new Set();
    for (var _j2 = 0, _k = tags2.map(expandTagDescription); _j2 < _k.length; _j2++) {
      var tag = _k[_j2];
      var provided = apiState.provided[tag.type];
      if (!provided) {
        continue;
      }
      var invalidateSubscriptions = (_a = tag.id !== void 0 ? provided[tag.id] : flatten(Object.values(provided))) != null ? _a : [];
      for (var _l = 0, invalidateSubscriptions_1 = invalidateSubscriptions; _l < invalidateSubscriptions_1.length; _l++) {
        var invalidate = invalidateSubscriptions_1[_l];
        toInvalidate.add(invalidate);
      }
    }
    return flatten(Array.from(toInvalidate.values()).map(function(queryCacheKey) {
      var querySubState = apiState.queries[queryCacheKey];
      return querySubState ? [
        {
          queryCacheKey,
          endpointName: querySubState.endpointName,
          originalArgs: querySubState.originalArgs
        }
      ] : [];
    }));
  }
}
var cache$1 = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
var defaultSerializeQueryArgs$1 = function(_j) {
  var endpointName = _j.endpointName, queryArgs = _j.queryArgs;
  var serialized = "";
  var cached = cache$1 == null ? void 0 : cache$1.get(queryArgs);
  if (typeof cached === "string") {
    serialized = cached;
  } else {
    var stringified = JSON.stringify(queryArgs, function(key, value) {
      return isPlainObject$3(value) ? Object.keys(value).sort().reduce(function(acc, key2) {
        acc[key2] = value[key2];
        return acc;
      }, {}) : value;
    });
    if (isPlainObject$3(queryArgs)) {
      cache$1 == null ? void 0 : cache$1.set(queryArgs, stringified);
    }
    serialized = stringified;
  }
  return endpointName + "(" + serialized + ")";
};
function buildCreateApi() {
  var modules = [];
  for (var _j = 0; _j < arguments.length; _j++) {
    modules[_j] = arguments[_j];
  }
  return function baseCreateApi(options) {
    var extractRehydrationInfo = defaultMemoize(function(action) {
      var _a, _b;
      return (_b = options.extractRehydrationInfo) == null ? void 0 : _b.call(options, action, {
        reducerPath: (_a = options.reducerPath) != null ? _a : "api"
      });
    });
    var optionsWithDefaults = __spreadProps$1(__spreadValues$1({
      reducerPath: "api",
      keepUnusedDataFor: 60,
      refetchOnMountOrArgChange: false,
      refetchOnFocus: false,
      refetchOnReconnect: false
    }, options), {
      extractRehydrationInfo,
      serializeQueryArgs: function(queryArgsApi) {
        var finalSerializeQueryArgs = defaultSerializeQueryArgs$1;
        if ("serializeQueryArgs" in queryArgsApi.endpointDefinition) {
          var endpointSQA_1 = queryArgsApi.endpointDefinition.serializeQueryArgs;
          finalSerializeQueryArgs = function(queryArgsApi2) {
            var initialResult = endpointSQA_1(queryArgsApi2);
            if (typeof initialResult === "string") {
              return initialResult;
            } else {
              return defaultSerializeQueryArgs$1(__spreadProps$1(__spreadValues$1({}, queryArgsApi2), {
                queryArgs: initialResult
              }));
            }
          };
        } else if (options.serializeQueryArgs) {
          finalSerializeQueryArgs = options.serializeQueryArgs;
        }
        return finalSerializeQueryArgs(queryArgsApi);
      },
      tagTypes: __spreadArray$1([], options.tagTypes || [])
    });
    var context = {
      endpointDefinitions: {},
      batch: function(fn2) {
        fn2();
      },
      apiUid: nanoid(),
      extractRehydrationInfo,
      hasRehydrationInfo: defaultMemoize(function(action) {
        return extractRehydrationInfo(action) != null;
      })
    };
    var api2 = {
      injectEndpoints,
      enhanceEndpoints: function(_j2) {
        var addTagTypes = _j2.addTagTypes, endpoints = _j2.endpoints;
        if (addTagTypes) {
          for (var _k = 0, addTagTypes_1 = addTagTypes; _k < addTagTypes_1.length; _k++) {
            var eT = addTagTypes_1[_k];
            if (!optionsWithDefaults.tagTypes.includes(eT)) {
              optionsWithDefaults.tagTypes.push(eT);
            }
          }
        }
        if (endpoints) {
          for (var _l = 0, _m = Object.entries(endpoints); _l < _m.length; _l++) {
            var _o2 = _m[_l], endpointName = _o2[0], partialDefinition = _o2[1];
            if (typeof partialDefinition === "function") {
              partialDefinition(context.endpointDefinitions[endpointName]);
            } else {
              Object.assign(context.endpointDefinitions[endpointName] || {}, partialDefinition);
            }
          }
        }
        return api2;
      }
    };
    var initializedModules = modules.map(function(m2) {
      return m2.init(api2, optionsWithDefaults, context);
    });
    function injectEndpoints(inject) {
      var evaluatedEndpoints = inject.endpoints({
        query: function(x2) {
          return __spreadProps$1(__spreadValues$1({}, x2), { type: DefinitionType$1.query });
        },
        mutation: function(x2) {
          return __spreadProps$1(__spreadValues$1({}, x2), { type: DefinitionType$1.mutation });
        }
      });
      for (var _j2 = 0, _k = Object.entries(evaluatedEndpoints); _j2 < _k.length; _j2++) {
        var _l = _k[_j2], endpointName = _l[0], definition = _l[1];
        if (!inject.overrideExisting && endpointName in context.endpointDefinitions) {
          if (typeof process !== "undefined" && false) {
            console.error("called `injectEndpoints` to override already-existing endpointName " + endpointName + " without specifying `overrideExisting: true`");
          }
          continue;
        }
        context.endpointDefinitions[endpointName] = definition;
        for (var _m = 0, initializedModules_1 = initializedModules; _m < initializedModules_1.length; _m++) {
          var m2 = initializedModules_1[_m];
          m2.injectEndpoint(endpointName, definition);
        }
      }
      return api2;
    }
    return api2.injectEndpoints({ endpoints: options.endpoints });
  };
}
function isObjectEmpty$1(obj) {
  for (var k2 in obj) {
    return false;
  }
  return true;
}
var THIRTY_TWO_BIT_MAX_TIMER_SECONDS = 2147483647 / 1e3 - 1;
var buildCacheCollectionHandler = function(_j) {
  var reducerPath = _j.reducerPath, api2 = _j.api, context = _j.context, internalState = _j.internalState;
  var _k = api2.internalActions, removeQueryResult = _k.removeQueryResult, unsubscribeQueryResult = _k.unsubscribeQueryResult;
  function anySubscriptionsRemainingForKey(queryCacheKey) {
    var subscriptions = internalState.currentSubscriptions[queryCacheKey];
    return !!subscriptions && !isObjectEmpty$1(subscriptions);
  }
  var currentRemovalTimeouts = {};
  var handler = function(action, mwApi, internalState2) {
    var _a;
    if (unsubscribeQueryResult.match(action)) {
      var state = mwApi.getState()[reducerPath];
      var queryCacheKey = action.payload.queryCacheKey;
      handleUnsubscribe(queryCacheKey, (_a = state.queries[queryCacheKey]) == null ? void 0 : _a.endpointName, mwApi, state.config);
    }
    if (api2.util.resetApiState.match(action)) {
      for (var _j2 = 0, _k2 = Object.entries(currentRemovalTimeouts); _j2 < _k2.length; _j2++) {
        var _l = _k2[_j2], key = _l[0], timeout = _l[1];
        if (timeout)
          clearTimeout(timeout);
        delete currentRemovalTimeouts[key];
      }
    }
    if (context.hasRehydrationInfo(action)) {
      var state = mwApi.getState()[reducerPath];
      var queries = context.extractRehydrationInfo(action).queries;
      for (var _m = 0, _o2 = Object.entries(queries); _m < _o2.length; _m++) {
        var _p = _o2[_m], queryCacheKey = _p[0], queryState = _p[1];
        handleUnsubscribe(queryCacheKey, queryState == null ? void 0 : queryState.endpointName, mwApi, state.config);
      }
    }
  };
  function handleUnsubscribe(queryCacheKey, endpointName, api22, config2) {
    var _a;
    var endpointDefinition = context.endpointDefinitions[endpointName];
    var keepUnusedDataFor = (_a = endpointDefinition == null ? void 0 : endpointDefinition.keepUnusedDataFor) != null ? _a : config2.keepUnusedDataFor;
    if (keepUnusedDataFor === Infinity) {
      return;
    }
    var finalKeepUnusedDataFor = Math.max(0, Math.min(keepUnusedDataFor, THIRTY_TWO_BIT_MAX_TIMER_SECONDS));
    if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
      var currentTimeout = currentRemovalTimeouts[queryCacheKey];
      if (currentTimeout) {
        clearTimeout(currentTimeout);
      }
      currentRemovalTimeouts[queryCacheKey] = setTimeout(function() {
        if (!anySubscriptionsRemainingForKey(queryCacheKey)) {
          api22.dispatch(removeQueryResult({ queryCacheKey }));
        }
        delete currentRemovalTimeouts[queryCacheKey];
      }, finalKeepUnusedDataFor * 1e3);
    }
  }
  return handler;
};
var buildInvalidationByTagsHandler = function(_j) {
  var reducerPath = _j.reducerPath, context = _j.context, endpointDefinitions = _j.context.endpointDefinitions, mutationThunk = _j.mutationThunk, api2 = _j.api, assertTagType = _j.assertTagType, refetchQuery = _j.refetchQuery;
  var removeQueryResult = api2.internalActions.removeQueryResult;
  var isThunkActionWithTags = isAnyOf(isFulfilled(mutationThunk), isRejectedWithValue(mutationThunk));
  var handler = function(action, mwApi) {
    if (isThunkActionWithTags(action)) {
      invalidateTags(calculateProvidedByThunk(action, "invalidatesTags", endpointDefinitions, assertTagType), mwApi);
    }
    if (api2.util.invalidateTags.match(action)) {
      invalidateTags(calculateProvidedBy(action.payload, void 0, void 0, void 0, void 0, assertTagType), mwApi);
    }
  };
  function invalidateTags(tags2, mwApi) {
    var rootState = mwApi.getState();
    var state = rootState[reducerPath];
    var toInvalidate = api2.util.selectInvalidatedBy(rootState, tags2);
    context.batch(function() {
      var _a;
      var valuesArray = Array.from(toInvalidate.values());
      for (var _j2 = 0, valuesArray_1 = valuesArray; _j2 < valuesArray_1.length; _j2++) {
        var queryCacheKey = valuesArray_1[_j2].queryCacheKey;
        var querySubState = state.queries[queryCacheKey];
        var subscriptionSubState = (_a = state.subscriptions[queryCacheKey]) != null ? _a : {};
        if (querySubState) {
          if (Object.keys(subscriptionSubState).length === 0) {
            mwApi.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== QueryStatus.uninitialized) {
            mwApi.dispatch(refetchQuery(querySubState, queryCacheKey));
          }
        }
      }
    });
  }
  return handler;
};
var buildPollingHandler = function(_j) {
  var reducerPath = _j.reducerPath, queryThunk = _j.queryThunk, api2 = _j.api, refetchQuery = _j.refetchQuery, internalState = _j.internalState;
  var currentPolls = {};
  var handler = function(action, mwApi) {
    if (api2.internalActions.updateSubscriptionOptions.match(action) || api2.internalActions.unsubscribeQueryResult.match(action)) {
      updatePollingInterval(action.payload, mwApi);
    }
    if (queryThunk.pending.match(action) || queryThunk.rejected.match(action) && action.meta.condition) {
      updatePollingInterval(action.meta.arg, mwApi);
    }
    if (queryThunk.fulfilled.match(action) || queryThunk.rejected.match(action) && !action.meta.condition) {
      startNextPoll(action.meta.arg, mwApi);
    }
    if (api2.util.resetApiState.match(action)) {
      clearPolls();
    }
  };
  function startNextPoll(_j2, api22) {
    var queryCacheKey = _j2.queryCacheKey;
    var state = api22.getState()[reducerPath];
    var querySubState = state.queries[queryCacheKey];
    var subscriptions = internalState.currentSubscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === QueryStatus.uninitialized)
      return;
    var lowestPollingInterval = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval))
      return;
    var currentPoll = currentPolls[queryCacheKey];
    if (currentPoll == null ? void 0 : currentPoll.timeout) {
      clearTimeout(currentPoll.timeout);
      currentPoll.timeout = void 0;
    }
    var nextPollTimestamp = Date.now() + lowestPollingInterval;
    var currentInterval = currentPolls[queryCacheKey] = {
      nextPollTimestamp,
      pollingInterval: lowestPollingInterval,
      timeout: setTimeout(function() {
        currentInterval.timeout = void 0;
        api22.dispatch(refetchQuery(querySubState, queryCacheKey));
      }, lowestPollingInterval)
    };
  }
  function updatePollingInterval(_j2, api22) {
    var queryCacheKey = _j2.queryCacheKey;
    var state = api22.getState()[reducerPath];
    var querySubState = state.queries[queryCacheKey];
    var subscriptions = internalState.currentSubscriptions[queryCacheKey];
    if (!querySubState || querySubState.status === QueryStatus.uninitialized) {
      return;
    }
    var lowestPollingInterval = findLowestPollingInterval(subscriptions);
    if (!Number.isFinite(lowestPollingInterval)) {
      cleanupPollForKey(queryCacheKey);
      return;
    }
    var currentPoll = currentPolls[queryCacheKey];
    var nextPollTimestamp = Date.now() + lowestPollingInterval;
    if (!currentPoll || nextPollTimestamp < currentPoll.nextPollTimestamp) {
      startNextPoll({ queryCacheKey }, api22);
    }
  }
  function cleanupPollForKey(key) {
    var existingPoll = currentPolls[key];
    if (existingPoll == null ? void 0 : existingPoll.timeout) {
      clearTimeout(existingPoll.timeout);
    }
    delete currentPolls[key];
  }
  function clearPolls() {
    for (var _j2 = 0, _k = Object.keys(currentPolls); _j2 < _k.length; _j2++) {
      var key = _k[_j2];
      cleanupPollForKey(key);
    }
  }
  function findLowestPollingInterval(subscribers) {
    if (subscribers === void 0) {
      subscribers = {};
    }
    var lowestPollingInterval = Number.POSITIVE_INFINITY;
    for (var key in subscribers) {
      if (!!subscribers[key].pollingInterval) {
        lowestPollingInterval = Math.min(subscribers[key].pollingInterval, lowestPollingInterval);
      }
    }
    return lowestPollingInterval;
  }
  return handler;
};
var buildWindowEventHandler = function(_j) {
  var reducerPath = _j.reducerPath, context = _j.context, api2 = _j.api, refetchQuery = _j.refetchQuery, internalState = _j.internalState;
  var removeQueryResult = api2.internalActions.removeQueryResult;
  var handler = function(action, mwApi) {
    if (onFocus.match(action)) {
      refetchValidQueries(mwApi, "refetchOnFocus");
    }
    if (onOnline.match(action)) {
      refetchValidQueries(mwApi, "refetchOnReconnect");
    }
  };
  function refetchValidQueries(api22, type) {
    var state = api22.getState()[reducerPath];
    var queries = state.queries;
    var subscriptions = internalState.currentSubscriptions;
    context.batch(function() {
      for (var _j2 = 0, _k = Object.keys(subscriptions); _j2 < _k.length; _j2++) {
        var queryCacheKey = _k[_j2];
        var querySubState = queries[queryCacheKey];
        var subscriptionSubState = subscriptions[queryCacheKey];
        if (!subscriptionSubState || !querySubState)
          continue;
        var shouldRefetch = Object.values(subscriptionSubState).some(function(sub) {
          return sub[type] === true;
        }) || Object.values(subscriptionSubState).every(function(sub) {
          return sub[type] === void 0;
        }) && state.config[type];
        if (shouldRefetch) {
          if (Object.keys(subscriptionSubState).length === 0) {
            api22.dispatch(removeQueryResult({
              queryCacheKey
            }));
          } else if (querySubState.status !== QueryStatus.uninitialized) {
            api22.dispatch(refetchQuery(querySubState, queryCacheKey));
          }
        }
      }
    });
  }
  return handler;
};
var neverResolvedError = new Error("Promise never resolved before cacheEntryRemoved.");
var buildCacheLifecycleHandler = function(_j) {
  var api2 = _j.api, reducerPath = _j.reducerPath, context = _j.context, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk;
  _j.internalState;
  var isQueryThunk = isAsyncThunkAction(queryThunk);
  var isMutationThunk = isAsyncThunkAction(mutationThunk);
  var isFulfilledThunk = isFulfilled(queryThunk, mutationThunk);
  var lifecycleMap = {};
  var handler = function(action, mwApi, stateBefore) {
    var cacheKey = getCacheKey(action);
    if (queryThunk.pending.match(action)) {
      var oldState = stateBefore[reducerPath].queries[cacheKey];
      var state = mwApi.getState()[reducerPath].queries[cacheKey];
      if (!oldState && state) {
        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
      }
    } else if (mutationThunk.pending.match(action)) {
      var state = mwApi.getState()[reducerPath].mutations[cacheKey];
      if (state) {
        handleNewKey(action.meta.arg.endpointName, action.meta.arg.originalArgs, cacheKey, mwApi, action.meta.requestId);
      }
    } else if (isFulfilledThunk(action)) {
      var lifecycle = lifecycleMap[cacheKey];
      if (lifecycle == null ? void 0 : lifecycle.valueResolved) {
        lifecycle.valueResolved({
          data: action.payload,
          meta: action.meta.baseQueryMeta
        });
        delete lifecycle.valueResolved;
      }
    } else if (api2.internalActions.removeQueryResult.match(action) || api2.internalActions.removeMutationResult.match(action)) {
      var lifecycle = lifecycleMap[cacheKey];
      if (lifecycle) {
        delete lifecycleMap[cacheKey];
        lifecycle.cacheEntryRemoved();
      }
    } else if (api2.util.resetApiState.match(action)) {
      for (var _j2 = 0, _k = Object.entries(lifecycleMap); _j2 < _k.length; _j2++) {
        var _l = _k[_j2], cacheKey2 = _l[0], lifecycle = _l[1];
        delete lifecycleMap[cacheKey2];
        lifecycle.cacheEntryRemoved();
      }
    }
  };
  function getCacheKey(action) {
    if (isQueryThunk(action))
      return action.meta.arg.queryCacheKey;
    if (isMutationThunk(action))
      return action.meta.requestId;
    if (api2.internalActions.removeQueryResult.match(action))
      return action.payload.queryCacheKey;
    if (api2.internalActions.removeMutationResult.match(action))
      return getMutationCacheKey(action.payload);
    return "";
  }
  function handleNewKey(endpointName, originalArgs, queryCacheKey, mwApi, requestId) {
    var endpointDefinition = context.endpointDefinitions[endpointName];
    var onCacheEntryAdded = endpointDefinition == null ? void 0 : endpointDefinition.onCacheEntryAdded;
    if (!onCacheEntryAdded)
      return;
    var lifecycle = {};
    var cacheEntryRemoved = new Promise(function(resolve) {
      lifecycle.cacheEntryRemoved = resolve;
    });
    var cacheDataLoaded = Promise.race([
      new Promise(function(resolve) {
        lifecycle.valueResolved = resolve;
      }),
      cacheEntryRemoved.then(function() {
        throw neverResolvedError;
      })
    ]);
    cacheDataLoaded.catch(function() {
    });
    lifecycleMap[queryCacheKey] = lifecycle;
    var selector = api2.endpoints[endpointName].select(endpointDefinition.type === DefinitionType$1.query ? originalArgs : queryCacheKey);
    var extra = mwApi.dispatch(function(_2, __, extra2) {
      return extra2;
    });
    var lifecycleApi = __spreadProps$1(__spreadValues$1({}, mwApi), {
      getCacheEntry: function() {
        return selector(mwApi.getState());
      },
      requestId,
      extra,
      updateCachedData: endpointDefinition.type === DefinitionType$1.query ? function(updateRecipe) {
        return mwApi.dispatch(api2.util.updateQueryData(endpointName, originalArgs, updateRecipe));
      } : void 0,
      cacheDataLoaded,
      cacheEntryRemoved
    });
    var runningHandler = onCacheEntryAdded(originalArgs, lifecycleApi);
    Promise.resolve(runningHandler).catch(function(e2) {
      if (e2 === neverResolvedError)
        return;
      throw e2;
    });
  }
  return handler;
};
var buildQueryLifecycleHandler = function(_j) {
  var api2 = _j.api, context = _j.context, queryThunk = _j.queryThunk, mutationThunk = _j.mutationThunk;
  var isPendingThunk = isPending(queryThunk, mutationThunk);
  var isRejectedThunk = isRejected(queryThunk, mutationThunk);
  var isFullfilledThunk = isFulfilled(queryThunk, mutationThunk);
  var lifecycleMap = {};
  var handler = function(action, mwApi) {
    var _a, _b, _c;
    if (isPendingThunk(action)) {
      var _j2 = action.meta, requestId = _j2.requestId, _k = _j2.arg, endpointName_1 = _k.endpointName, originalArgs_1 = _k.originalArgs;
      var endpointDefinition = context.endpointDefinitions[endpointName_1];
      var onQueryStarted = endpointDefinition == null ? void 0 : endpointDefinition.onQueryStarted;
      if (onQueryStarted) {
        var lifecycle_1 = {};
        var queryFulfilled = new Promise(function(resolve, reject) {
          lifecycle_1.resolve = resolve;
          lifecycle_1.reject = reject;
        });
        queryFulfilled.catch(function() {
        });
        lifecycleMap[requestId] = lifecycle_1;
        var selector_1 = api2.endpoints[endpointName_1].select(endpointDefinition.type === DefinitionType$1.query ? originalArgs_1 : requestId);
        var extra = mwApi.dispatch(function(_2, __, extra2) {
          return extra2;
        });
        var lifecycleApi = __spreadProps$1(__spreadValues$1({}, mwApi), {
          getCacheEntry: function() {
            return selector_1(mwApi.getState());
          },
          requestId,
          extra,
          updateCachedData: endpointDefinition.type === DefinitionType$1.query ? function(updateRecipe) {
            return mwApi.dispatch(api2.util.updateQueryData(endpointName_1, originalArgs_1, updateRecipe));
          } : void 0,
          queryFulfilled
        });
        onQueryStarted(originalArgs_1, lifecycleApi);
      }
    } else if (isFullfilledThunk(action)) {
      var _l = action.meta, requestId = _l.requestId, baseQueryMeta = _l.baseQueryMeta;
      (_a = lifecycleMap[requestId]) == null ? void 0 : _a.resolve({
        data: action.payload,
        meta: baseQueryMeta
      });
      delete lifecycleMap[requestId];
    } else if (isRejectedThunk(action)) {
      var _m = action.meta, requestId = _m.requestId, rejectedWithValue = _m.rejectedWithValue, baseQueryMeta = _m.baseQueryMeta;
      (_c = lifecycleMap[requestId]) == null ? void 0 : _c.reject({
        error: (_b = action.payload) != null ? _b : action.error,
        isUnhandledError: !rejectedWithValue,
        meta: baseQueryMeta
      });
      delete lifecycleMap[requestId];
    }
  };
  return handler;
};
var buildDevCheckHandler = function(_j) {
  var api2 = _j.api, apiUid = _j.context.apiUid, reducerPath = _j.reducerPath;
  return function(action, mwApi) {
    var _a, _b;
    if (api2.util.resetApiState.match(action)) {
      mwApi.dispatch(api2.internalActions.middlewareRegistered(apiUid));
    }
    if (typeof process !== "undefined" && false) {
      if (api2.internalActions.middlewareRegistered.match(action) && action.payload === apiUid && ((_b = (_a = mwApi.getState()[reducerPath]) == null ? void 0 : _a.config) == null ? void 0 : _b.middlewareRegistered) === "conflict") {
        console.warn('There is a mismatch between slice and middleware for the reducerPath "' + reducerPath + '".\nYou can only have one api per reducer path, this will lead to crashes in various situations!' + (reducerPath === "api" ? "\nIf you have multiple apis, you *have* to specify the reducerPath option when using createApi!" : ""));
      }
    }
  };
};
var promise;
var queueMicrotaskShim = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : globalThis) : function(cb2) {
  return (promise || (promise = Promise.resolve())).then(cb2).catch(function(err) {
    return setTimeout(function() {
      throw err;
    }, 0);
  });
};
var buildBatchedActionsHandler = function(_j) {
  var api2 = _j.api, queryThunk = _j.queryThunk, internalState = _j.internalState;
  var subscriptionsPrefix = api2.reducerPath + "/subscriptions";
  var previousSubscriptions = null;
  var dispatchQueued = false;
  var _k = api2.internalActions, updateSubscriptionOptions = _k.updateSubscriptionOptions, unsubscribeQueryResult = _k.unsubscribeQueryResult;
  var actuallyMutateSubscriptions = function(mutableState, action) {
    var _a, _b, _c, _d, _e2, _f, _g, _h, _i;
    if (updateSubscriptionOptions.match(action)) {
      var _j2 = action.payload, queryCacheKey = _j2.queryCacheKey, requestId = _j2.requestId, options = _j2.options;
      if ((_a = mutableState == null ? void 0 : mutableState[queryCacheKey]) == null ? void 0 : _a[requestId]) {
        mutableState[queryCacheKey][requestId] = options;
      }
      return true;
    }
    if (unsubscribeQueryResult.match(action)) {
      var _k2 = action.payload, queryCacheKey = _k2.queryCacheKey, requestId = _k2.requestId;
      if (mutableState[queryCacheKey]) {
        delete mutableState[queryCacheKey][requestId];
      }
      return true;
    }
    if (api2.internalActions.removeQueryResult.match(action)) {
      delete mutableState[action.payload.queryCacheKey];
      return true;
    }
    if (queryThunk.pending.match(action)) {
      var _l = action.meta, arg = _l.arg, requestId = _l.requestId;
      if (arg.subscribe) {
        var substate = (_c = mutableState[_b = arg.queryCacheKey]) != null ? _c : mutableState[_b] = {};
        substate[requestId] = (_e2 = (_d = arg.subscriptionOptions) != null ? _d : substate[requestId]) != null ? _e2 : {};
        return true;
      }
    }
    if (queryThunk.rejected.match(action)) {
      var _m = action.meta, condition = _m.condition, arg = _m.arg, requestId = _m.requestId;
      if (condition && arg.subscribe) {
        var substate = (_g = mutableState[_f = arg.queryCacheKey]) != null ? _g : mutableState[_f] = {};
        substate[requestId] = (_i = (_h = arg.subscriptionOptions) != null ? _h : substate[requestId]) != null ? _i : {};
        return true;
      }
    }
    return false;
  };
  return function(action, mwApi) {
    var _a, _b;
    if (!previousSubscriptions) {
      previousSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
    }
    if (api2.util.resetApiState.match(action)) {
      previousSubscriptions = internalState.currentSubscriptions = {};
      return [true, false];
    }
    if (api2.internalActions.internal_probeSubscription.match(action)) {
      var _j2 = action.payload, queryCacheKey = _j2.queryCacheKey, requestId = _j2.requestId;
      var hasSubscription = !!((_a = internalState.currentSubscriptions[queryCacheKey]) == null ? void 0 : _a[requestId]);
      return [false, hasSubscription];
    }
    var didMutate = actuallyMutateSubscriptions(internalState.currentSubscriptions, action);
    if (didMutate) {
      if (!dispatchQueued) {
        queueMicrotaskShim(function() {
          var newSubscriptions = JSON.parse(JSON.stringify(internalState.currentSubscriptions));
          var _j3 = cn(previousSubscriptions, function() {
            return newSubscriptions;
          }), patches = _j3[1];
          mwApi.next(api2.internalActions.subscriptionsUpdated(patches));
          previousSubscriptions = newSubscriptions;
          dispatchQueued = false;
        });
        dispatchQueued = true;
      }
      var isSubscriptionSliceAction = !!((_b = action.type) == null ? void 0 : _b.startsWith(subscriptionsPrefix));
      var isAdditionalSubscriptionAction = queryThunk.rejected.match(action) && action.meta.condition && !!action.meta.arg.subscribe;
      var actionShouldContinue = !isSubscriptionSliceAction && !isAdditionalSubscriptionAction;
      return [actionShouldContinue, false];
    }
    return [true, false];
  };
};
function buildMiddleware(input) {
  var reducerPath = input.reducerPath, queryThunk = input.queryThunk, api2 = input.api, context = input.context;
  var apiUid = context.apiUid;
  var actions2 = {
    invalidateTags: createAction(reducerPath + "/invalidateTags")
  };
  var isThisApiSliceAction = function(action) {
    return !!action && typeof action.type === "string" && action.type.startsWith(reducerPath + "/");
  };
  var handlerBuilders = [
    buildDevCheckHandler,
    buildCacheCollectionHandler,
    buildInvalidationByTagsHandler,
    buildPollingHandler,
    buildCacheLifecycleHandler,
    buildQueryLifecycleHandler
  ];
  var middleware2 = function(mwApi) {
    var initialized2 = false;
    var internalState = {
      currentSubscriptions: {}
    };
    var builderArgs = __spreadProps$1(__spreadValues$1({}, input), {
      internalState,
      refetchQuery
    });
    var handlers = handlerBuilders.map(function(build) {
      return build(builderArgs);
    });
    var batchedActionsHandler = buildBatchedActionsHandler(builderArgs);
    var windowEventsHandler = buildWindowEventHandler(builderArgs);
    return function(next2) {
      return function(action) {
        if (!initialized2) {
          initialized2 = true;
          mwApi.dispatch(api2.internalActions.middlewareRegistered(apiUid));
        }
        var mwApiWithNext = __spreadProps$1(__spreadValues$1({}, mwApi), { next: next2 });
        var stateBefore = mwApi.getState();
        var _j = batchedActionsHandler(action, mwApiWithNext, stateBefore), actionShouldContinue = _j[0], hasSubscription = _j[1];
        var res;
        if (actionShouldContinue) {
          res = next2(action);
        } else {
          res = hasSubscription;
        }
        if (!!mwApi.getState()[reducerPath]) {
          windowEventsHandler(action, mwApiWithNext, stateBefore);
          if (isThisApiSliceAction(action) || context.hasRehydrationInfo(action)) {
            for (var _k = 0, handlers_1 = handlers; _k < handlers_1.length; _k++) {
              var handler = handlers_1[_k];
              handler(action, mwApiWithNext, stateBefore);
            }
          }
        }
        return res;
      };
    };
  };
  return { middleware: middleware2, actions: actions2 };
  function refetchQuery(querySubState, queryCacheKey, override) {
    if (override === void 0) {
      override = {};
    }
    return queryThunk(__spreadValues$1({
      type: "query",
      endpointName: querySubState.endpointName,
      originalArgs: querySubState.originalArgs,
      subscribe: false,
      forceRefetch: true,
      queryCacheKey
    }, override));
  }
}
function safeAssign$1(target) {
  var args = [];
  for (var _j = 1; _j < arguments.length; _j++) {
    args[_j - 1] = arguments[_j];
  }
  Object.assign.apply(Object, __spreadArray$1([target], args));
}
var coreModuleName = /* @__PURE__ */ Symbol();
var coreModule = function() {
  return {
    name: coreModuleName,
    init: function(api2, _j, context) {
      var baseQuery = _j.baseQuery, tagTypes = _j.tagTypes, reducerPath = _j.reducerPath, serializeQueryArgs = _j.serializeQueryArgs, keepUnusedDataFor = _j.keepUnusedDataFor, refetchOnMountOrArgChange = _j.refetchOnMountOrArgChange, refetchOnFocus = _j.refetchOnFocus, refetchOnReconnect = _j.refetchOnReconnect;
      T$1();
      var assertTagType = function(tag) {
        if (typeof process !== "undefined" && false) {
          if (!tagTypes.includes(tag.type)) {
            console.error("Tag type '" + tag.type + "' was used, but not specified in `tagTypes`!");
          }
        }
        return tag;
      };
      Object.assign(api2, {
        reducerPath,
        endpoints: {},
        internalActions: {
          onOnline,
          onOffline,
          onFocus,
          onFocusLost
        },
        util: {}
      });
      var _k = buildThunks({
        baseQuery,
        reducerPath,
        context,
        api: api2,
        serializeQueryArgs,
        assertTagType
      }), queryThunk = _k.queryThunk, mutationThunk = _k.mutationThunk, patchQueryData = _k.patchQueryData, updateQueryData = _k.updateQueryData, upsertQueryData = _k.upsertQueryData, prefetch = _k.prefetch, buildMatchThunkActions = _k.buildMatchThunkActions;
      var _l = buildSlice({
        context,
        queryThunk,
        mutationThunk,
        reducerPath,
        assertTagType,
        config: {
          refetchOnFocus,
          refetchOnReconnect,
          refetchOnMountOrArgChange,
          keepUnusedDataFor,
          reducerPath
        }
      }), reducer2 = _l.reducer, sliceActions = _l.actions;
      safeAssign$1(api2.util, {
        patchQueryData,
        updateQueryData,
        upsertQueryData,
        prefetch,
        resetApiState: sliceActions.resetApiState
      });
      safeAssign$1(api2.internalActions, sliceActions);
      var _m = buildMiddleware({
        reducerPath,
        context,
        queryThunk,
        mutationThunk,
        api: api2,
        assertTagType
      }), middleware2 = _m.middleware, middlewareActions = _m.actions;
      safeAssign$1(api2.util, middlewareActions);
      safeAssign$1(api2, { reducer: reducer2, middleware: middleware2 });
      var _o2 = buildSelectors({
        serializeQueryArgs,
        reducerPath
      }), buildQuerySelector = _o2.buildQuerySelector, buildMutationSelector = _o2.buildMutationSelector, selectInvalidatedBy = _o2.selectInvalidatedBy;
      safeAssign$1(api2.util, { selectInvalidatedBy });
      var _p = buildInitiate({
        queryThunk,
        mutationThunk,
        api: api2,
        serializeQueryArgs,
        context
      }), buildInitiateQuery = _p.buildInitiateQuery, buildInitiateMutation = _p.buildInitiateMutation, getRunningMutationThunk = _p.getRunningMutationThunk, getRunningMutationsThunk = _p.getRunningMutationsThunk, getRunningQueriesThunk = _p.getRunningQueriesThunk, getRunningQueryThunk = _p.getRunningQueryThunk, getRunningOperationPromises = _p.getRunningOperationPromises, removalWarning = _p.removalWarning;
      safeAssign$1(api2.util, {
        getRunningOperationPromises,
        getRunningOperationPromise: removalWarning,
        getRunningMutationThunk,
        getRunningMutationsThunk,
        getRunningQueryThunk,
        getRunningQueriesThunk
      });
      return {
        name: coreModuleName,
        injectEndpoint: function(endpointName, definition) {
          var _a, _b;
          var anyApi = api2;
          (_b = (_a = anyApi.endpoints)[endpointName]) != null ? _b : _a[endpointName] = {};
          if (isQueryDefinition$1(definition)) {
            safeAssign$1(anyApi.endpoints[endpointName], {
              name: endpointName,
              select: buildQuerySelector(endpointName, definition),
              initiate: buildInitiateQuery(endpointName, definition)
            }, buildMatchThunkActions(queryThunk, endpointName));
          } else if (isMutationDefinition$1(definition)) {
            safeAssign$1(anyApi.endpoints[endpointName], {
              name: endpointName,
              select: buildMutationSelector(),
              initiate: buildInitiateMutation(endpointName)
            }, buildMatchThunkActions(mutationThunk, endpointName));
          }
        }
      };
    }
  };
};
var __spreadArray = globalThis && globalThis.__spreadArray || function(to2, from2) {
  for (var i2 = 0, il2 = from2.length, j2 = to2.length; i2 < il2; i2++, j2++)
    to2[j2] = from2[i2];
  return to2;
};
var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = function(obj, key, value) {
  return key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
};
var __spreadValues = function(a2, b2) {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var _i = 0, _c = __getOwnPropSymbols(b2); _i < _c.length; _i++) {
      var prop = _c[_i];
      if (__propIsEnum.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = function(a2, b2) {
  return __defProps(a2, __getOwnPropDescs(b2));
};
function useStableQueryArgs(queryArgs, serialize2, endpointDefinition, endpointName) {
  var incoming = reactExports.useMemo(function() {
    return {
      queryArgs,
      serialized: typeof queryArgs == "object" ? serialize2({ queryArgs, endpointDefinition, endpointName }) : queryArgs
    };
  }, [queryArgs, serialize2, endpointDefinition, endpointName]);
  var cache2 = reactExports.useRef(incoming);
  reactExports.useEffect(function() {
    if (cache2.current.serialized !== incoming.serialized) {
      cache2.current = incoming;
    }
  }, [incoming]);
  return cache2.current.serialized === incoming.serialized ? cache2.current.queryArgs : queryArgs;
}
var UNINITIALIZED_VALUE = Symbol();
function useShallowStableValue(value) {
  var cache2 = reactExports.useRef(value);
  reactExports.useEffect(function() {
    if (!shallowEqual(cache2.current, value)) {
      cache2.current = value;
    }
  }, [value]);
  return shallowEqual(cache2.current, value) ? cache2.current : value;
}
var cache = WeakMap ? /* @__PURE__ */ new WeakMap() : void 0;
var defaultSerializeQueryArgs = function(_c) {
  var endpointName = _c.endpointName, queryArgs = _c.queryArgs;
  var serialized = "";
  var cached = cache == null ? void 0 : cache.get(queryArgs);
  if (typeof cached === "string") {
    serialized = cached;
  } else {
    var stringified = JSON.stringify(queryArgs, function(key, value) {
      return isPlainObject$3(value) ? Object.keys(value).sort().reduce(function(acc, key2) {
        acc[key2] = value[key2];
        return acc;
      }, {}) : value;
    });
    if (isPlainObject$3(queryArgs)) {
      cache == null ? void 0 : cache.set(queryArgs, stringified);
    }
    serialized = stringified;
  }
  return endpointName + "(" + serialized + ")";
};
var useIsomorphicLayoutEffect$1 = typeof window !== "undefined" && !!window.document && !!window.document.createElement ? reactExports.useLayoutEffect : reactExports.useEffect;
var defaultMutationStateSelector = function(x2) {
  return x2;
};
var noPendingQueryStateSelector = function(selected) {
  if (selected.isUninitialized) {
    return __spreadProps(__spreadValues({}, selected), {
      isUninitialized: false,
      isFetching: true,
      isLoading: selected.data !== void 0 ? false : true,
      status: QueryStatus.pending
    });
  }
  return selected;
};
function buildHooks(_c) {
  var api2 = _c.api, _d = _c.moduleOptions, batch2 = _d.batch, useDispatch2 = _d.useDispatch, useSelector2 = _d.useSelector, useStore2 = _d.useStore, unstable__sideEffectsInRender = _d.unstable__sideEffectsInRender, serializeQueryArgs = _c.serializeQueryArgs, context = _c.context;
  var usePossiblyImmediateEffect = unstable__sideEffectsInRender ? function(cb2) {
    return cb2();
  } : reactExports.useEffect;
  return { buildQueryHooks, buildMutationHook, usePrefetch };
  function queryStatePreSelector(currentState, lastResult, queryArgs) {
    if ((lastResult == null ? void 0 : lastResult.endpointName) && currentState.isUninitialized) {
      var endpointName = lastResult.endpointName;
      var endpointDefinition = context.endpointDefinitions[endpointName];
      if (serializeQueryArgs({
        queryArgs: lastResult.originalArgs,
        endpointDefinition,
        endpointName
      }) === serializeQueryArgs({
        queryArgs,
        endpointDefinition,
        endpointName
      }))
        lastResult = void 0;
    }
    var data = currentState.isSuccess ? currentState.data : lastResult == null ? void 0 : lastResult.data;
    if (data === void 0)
      data = currentState.data;
    var hasData = data !== void 0;
    var isFetching = currentState.isLoading;
    var isLoading = !hasData && isFetching;
    var isSuccess = currentState.isSuccess || isFetching && hasData;
    return __spreadProps(__spreadValues({}, currentState), {
      data,
      currentData: currentState.data,
      isFetching,
      isLoading,
      isSuccess
    });
  }
  function usePrefetch(endpointName, defaultOptions) {
    var dispatch = useDispatch2();
    var stableDefaultOptions = useShallowStableValue(defaultOptions);
    return reactExports.useCallback(function(arg, options) {
      return dispatch(api2.util.prefetch(endpointName, arg, __spreadValues(__spreadValues({}, stableDefaultOptions), options)));
    }, [endpointName, dispatch, stableDefaultOptions]);
  }
  function buildQueryHooks(name) {
    var useQuerySubscription = function(arg, _c2) {
      var _d2 = _c2 === void 0 ? {} : _c2, refetchOnReconnect = _d2.refetchOnReconnect, refetchOnFocus = _d2.refetchOnFocus, refetchOnMountOrArgChange = _d2.refetchOnMountOrArgChange, _e2 = _d2.skip, skip = _e2 === void 0 ? false : _e2, _f = _d2.pollingInterval, pollingInterval = _f === void 0 ? 0 : _f;
      var initiate = api2.endpoints[name].initiate;
      var dispatch = useDispatch2();
      var stableArg = useStableQueryArgs(skip ? skipToken : arg, defaultSerializeQueryArgs, context.endpointDefinitions[name], name);
      var stableSubscriptionOptions = useShallowStableValue({
        refetchOnReconnect,
        refetchOnFocus,
        pollingInterval
      });
      var lastRenderHadSubscription = reactExports.useRef(false);
      var promiseRef = reactExports.useRef();
      var _g = promiseRef.current || {}, queryCacheKey = _g.queryCacheKey, requestId = _g.requestId;
      var currentRenderHasSubscription = false;
      if (queryCacheKey && requestId) {
        var returnedValue = dispatch(api2.internalActions.internal_probeSubscription({
          queryCacheKey,
          requestId
        }));
        currentRenderHasSubscription = !!returnedValue;
      }
      var subscriptionRemoved = !currentRenderHasSubscription && lastRenderHadSubscription.current;
      usePossiblyImmediateEffect(function() {
        lastRenderHadSubscription.current = currentRenderHasSubscription;
      });
      usePossiblyImmediateEffect(function() {
        if (subscriptionRemoved) {
          promiseRef.current = void 0;
        }
      }, [subscriptionRemoved]);
      usePossiblyImmediateEffect(function() {
        var _a;
        var lastPromise = promiseRef.current;
        if (typeof process !== "undefined" && false) {
          console.log(subscriptionRemoved);
        }
        if (stableArg === skipToken) {
          lastPromise == null ? void 0 : lastPromise.unsubscribe();
          promiseRef.current = void 0;
          return;
        }
        var lastSubscriptionOptions = (_a = promiseRef.current) == null ? void 0 : _a.subscriptionOptions;
        if (!lastPromise || lastPromise.arg !== stableArg) {
          lastPromise == null ? void 0 : lastPromise.unsubscribe();
          var promise2 = dispatch(initiate(stableArg, {
            subscriptionOptions: stableSubscriptionOptions,
            forceRefetch: refetchOnMountOrArgChange
          }));
          promiseRef.current = promise2;
        } else if (stableSubscriptionOptions !== lastSubscriptionOptions) {
          lastPromise.updateSubscriptionOptions(stableSubscriptionOptions);
        }
      }, [
        dispatch,
        initiate,
        refetchOnMountOrArgChange,
        stableArg,
        stableSubscriptionOptions,
        subscriptionRemoved
      ]);
      reactExports.useEffect(function() {
        return function() {
          var _a;
          (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe();
          promiseRef.current = void 0;
        };
      }, []);
      return reactExports.useMemo(function() {
        return {
          refetch: function() {
            var _a;
            if (!promiseRef.current)
              throw new Error("Cannot refetch a query that has not been started yet.");
            return (_a = promiseRef.current) == null ? void 0 : _a.refetch();
          }
        };
      }, []);
    };
    var useLazyQuerySubscription = function(_c2) {
      var _d2 = _c2 === void 0 ? {} : _c2, refetchOnReconnect = _d2.refetchOnReconnect, refetchOnFocus = _d2.refetchOnFocus, _e2 = _d2.pollingInterval, pollingInterval = _e2 === void 0 ? 0 : _e2;
      var initiate = api2.endpoints[name].initiate;
      var dispatch = useDispatch2();
      var _f = reactExports.useState(UNINITIALIZED_VALUE), arg = _f[0], setArg = _f[1];
      var promiseRef = reactExports.useRef();
      var stableSubscriptionOptions = useShallowStableValue({
        refetchOnReconnect,
        refetchOnFocus,
        pollingInterval
      });
      usePossiblyImmediateEffect(function() {
        var _a, _b;
        var lastSubscriptionOptions = (_a = promiseRef.current) == null ? void 0 : _a.subscriptionOptions;
        if (stableSubscriptionOptions !== lastSubscriptionOptions) {
          (_b = promiseRef.current) == null ? void 0 : _b.updateSubscriptionOptions(stableSubscriptionOptions);
        }
      }, [stableSubscriptionOptions]);
      var subscriptionOptionsRef = reactExports.useRef(stableSubscriptionOptions);
      usePossiblyImmediateEffect(function() {
        subscriptionOptionsRef.current = stableSubscriptionOptions;
      }, [stableSubscriptionOptions]);
      var trigger = reactExports.useCallback(function(arg2, preferCacheValue) {
        if (preferCacheValue === void 0) {
          preferCacheValue = false;
        }
        var promise2;
        batch2(function() {
          var _a;
          (_a = promiseRef.current) == null ? void 0 : _a.unsubscribe();
          promiseRef.current = promise2 = dispatch(initiate(arg2, {
            subscriptionOptions: subscriptionOptionsRef.current,
            forceRefetch: !preferCacheValue
          }));
          setArg(arg2);
        });
        return promise2;
      }, [dispatch, initiate]);
      reactExports.useEffect(function() {
        return function() {
          var _a;
          (_a = promiseRef == null ? void 0 : promiseRef.current) == null ? void 0 : _a.unsubscribe();
        };
      }, []);
      reactExports.useEffect(function() {
        if (arg !== UNINITIALIZED_VALUE && !promiseRef.current) {
          trigger(arg, true);
        }
      }, [arg, trigger]);
      return reactExports.useMemo(function() {
        return [trigger, arg];
      }, [trigger, arg]);
    };
    var useQueryState = function(arg, _c2) {
      var _d2 = _c2 === void 0 ? {} : _c2, _e2 = _d2.skip, skip = _e2 === void 0 ? false : _e2, selectFromResult = _d2.selectFromResult;
      var select = api2.endpoints[name].select;
      var stableArg = useStableQueryArgs(skip ? skipToken : arg, serializeQueryArgs, context.endpointDefinitions[name], name);
      var lastValue = reactExports.useRef();
      var selectDefaultResult = reactExports.useMemo(function() {
        return createSelector([
          select(stableArg),
          function(_2, lastResult) {
            return lastResult;
          },
          function(_2) {
            return stableArg;
          }
        ], queryStatePreSelector);
      }, [select, stableArg]);
      var querySelector = reactExports.useMemo(function() {
        return selectFromResult ? createSelector([selectDefaultResult], selectFromResult) : selectDefaultResult;
      }, [selectDefaultResult, selectFromResult]);
      var currentState = useSelector2(function(state) {
        return querySelector(state, lastValue.current);
      }, shallowEqual);
      var store2 = useStore2();
      var newLastValue = selectDefaultResult(store2.getState(), lastValue.current);
      useIsomorphicLayoutEffect$1(function() {
        lastValue.current = newLastValue;
      }, [newLastValue]);
      return currentState;
    };
    return {
      useQueryState,
      useQuerySubscription,
      useLazyQuerySubscription,
      useLazyQuery: function(options) {
        var _c2 = useLazyQuerySubscription(options), trigger = _c2[0], arg = _c2[1];
        var queryStateResults = useQueryState(arg, __spreadProps(__spreadValues({}, options), {
          skip: arg === UNINITIALIZED_VALUE
        }));
        var info = reactExports.useMemo(function() {
          return { lastArg: arg };
        }, [arg]);
        return reactExports.useMemo(function() {
          return [trigger, queryStateResults, info];
        }, [trigger, queryStateResults, info]);
      },
      useQuery: function(arg, options) {
        var querySubscriptionResults = useQuerySubscription(arg, options);
        var queryStateResults = useQueryState(arg, __spreadValues({
          selectFromResult: arg === skipToken || (options == null ? void 0 : options.skip) ? void 0 : noPendingQueryStateSelector
        }, options));
        var data = queryStateResults.data, status = queryStateResults.status, isLoading = queryStateResults.isLoading, isSuccess = queryStateResults.isSuccess, isError = queryStateResults.isError, error = queryStateResults.error;
        reactExports.useDebugValue({ data, status, isLoading, isSuccess, isError, error });
        return reactExports.useMemo(function() {
          return __spreadValues(__spreadValues({}, queryStateResults), querySubscriptionResults);
        }, [queryStateResults, querySubscriptionResults]);
      }
    };
  }
  function buildMutationHook(name) {
    return function(_c2) {
      var _d2 = _c2 === void 0 ? {} : _c2, _e2 = _d2.selectFromResult, selectFromResult = _e2 === void 0 ? defaultMutationStateSelector : _e2, fixedCacheKey = _d2.fixedCacheKey;
      var _f = api2.endpoints[name], select = _f.select, initiate = _f.initiate;
      var dispatch = useDispatch2();
      var _g = reactExports.useState(), promise2 = _g[0], setPromise = _g[1];
      reactExports.useEffect(function() {
        return function() {
          if (!(promise2 == null ? void 0 : promise2.arg.fixedCacheKey)) {
            promise2 == null ? void 0 : promise2.reset();
          }
        };
      }, [promise2]);
      var triggerMutation = reactExports.useCallback(function(arg) {
        var promise22 = dispatch(initiate(arg, { fixedCacheKey }));
        setPromise(promise22);
        return promise22;
      }, [dispatch, initiate, fixedCacheKey]);
      var requestId = (promise2 || {}).requestId;
      var mutationSelector = reactExports.useMemo(function() {
        return createSelector([select({ fixedCacheKey, requestId: promise2 == null ? void 0 : promise2.requestId })], selectFromResult);
      }, [select, promise2, selectFromResult, fixedCacheKey]);
      var currentState = useSelector2(mutationSelector, shallowEqual);
      var originalArgs = fixedCacheKey == null ? promise2 == null ? void 0 : promise2.arg.originalArgs : void 0;
      var reset = reactExports.useCallback(function() {
        batch2(function() {
          if (promise2) {
            setPromise(void 0);
          }
          if (fixedCacheKey) {
            dispatch(api2.internalActions.removeMutationResult({
              requestId,
              fixedCacheKey
            }));
          }
        });
      }, [dispatch, fixedCacheKey, promise2, requestId]);
      var endpointName = currentState.endpointName, data = currentState.data, status = currentState.status, isLoading = currentState.isLoading, isSuccess = currentState.isSuccess, isError = currentState.isError, error = currentState.error;
      reactExports.useDebugValue({
        endpointName,
        data,
        status,
        isLoading,
        isSuccess,
        isError,
        error
      });
      var finalState = reactExports.useMemo(function() {
        return __spreadProps(__spreadValues({}, currentState), { originalArgs, reset });
      }, [currentState, originalArgs, reset]);
      return reactExports.useMemo(function() {
        return [triggerMutation, finalState];
      }, [triggerMutation, finalState]);
    };
  }
}
var DefinitionType;
(function(DefinitionType2) {
  DefinitionType2["query"] = "query";
  DefinitionType2["mutation"] = "mutation";
})(DefinitionType || (DefinitionType = {}));
function isQueryDefinition(e2) {
  return e2.type === DefinitionType.query;
}
function isMutationDefinition(e2) {
  return e2.type === DefinitionType.mutation;
}
function capitalize$1(str) {
  return str.replace(str[0], str[0].toUpperCase());
}
function safeAssign(target) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  Object.assign.apply(Object, __spreadArray([target], args));
}
var reactHooksModuleName = /* @__PURE__ */ Symbol();
var reactHooksModule = function(_c) {
  var _d = _c === void 0 ? {} : _c, _e2 = _d.batch, batch2 = _e2 === void 0 ? reactDomExports.unstable_batchedUpdates : _e2, _f = _d.useDispatch, useDispatch$1 = _f === void 0 ? useDispatch : _f, _g = _d.useSelector, useSelector$1 = _g === void 0 ? useSelector : _g, _h = _d.useStore, useStore$1 = _h === void 0 ? useStore : _h, _j = _d.unstable__sideEffectsInRender, unstable__sideEffectsInRender = _j === void 0 ? false : _j;
  return {
    name: reactHooksModuleName,
    init: function(api2, _c2, context) {
      var serializeQueryArgs = _c2.serializeQueryArgs;
      var anyApi = api2;
      var _d2 = buildHooks({
        api: api2,
        moduleOptions: {
          batch: batch2,
          useDispatch: useDispatch$1,
          useSelector: useSelector$1,
          useStore: useStore$1,
          unstable__sideEffectsInRender
        },
        serializeQueryArgs,
        context
      }), buildQueryHooks = _d2.buildQueryHooks, buildMutationHook = _d2.buildMutationHook, usePrefetch = _d2.usePrefetch;
      safeAssign(anyApi, { usePrefetch });
      safeAssign(context, { batch: batch2 });
      return {
        injectEndpoint: function(endpointName, definition) {
          if (isQueryDefinition(definition)) {
            var _c3 = buildQueryHooks(endpointName), useQuery = _c3.useQuery, useLazyQuery = _c3.useLazyQuery, useLazyQuerySubscription = _c3.useLazyQuerySubscription, useQueryState = _c3.useQueryState, useQuerySubscription = _c3.useQuerySubscription;
            safeAssign(anyApi.endpoints[endpointName], {
              useQuery,
              useLazyQuery,
              useLazyQuerySubscription,
              useQueryState,
              useQuerySubscription
            });
            api2["use" + capitalize$1(endpointName) + "Query"] = useQuery;
            api2["useLazy" + capitalize$1(endpointName) + "Query"] = useLazyQuery;
          } else if (isMutationDefinition(definition)) {
            var useMutation = buildMutationHook(endpointName);
            safeAssign(anyApi.endpoints[endpointName], {
              useMutation
            });
            api2["use" + capitalize$1(endpointName) + "Mutation"] = useMutation;
          }
        }
      };
    }
  };
};
var createApi = /* @__PURE__ */ buildCreateApi(coreModule(), reactHooksModule());
const API_URL = "/api/";
const api = createApi({
  reducerPath: "api",
  tagTypes: [
    "News",
    "NewsById",
    "NewsCategory",
    "Courses",
    "ThemeById",
    "CourseById",
    "ChapterById",
    "LessonById",
    "User",
    "Competition",
    "CourseProgress",
    "NewsByCategory",
    "CompetitionById"
  ],
  baseQuery: fetchBaseQuery({
    baseUrl: API_URL,
    prepareHeaders: (headers, { getState }) => {
      const token2 = getState().auth.token;
      if (token2) {
        headers.set("X-CSRF-Token", token2);
      }
      return headers;
    }
  }),
  endpoints: () => ({})
});
const userApi = api.injectEndpoints({
  endpoints: (builder) => ({
    checkUser: builder.query({
      query: () => "whoami",
      providesTags: () => [
        {
          type: "User"
        }
      ]
    })
  }),
  overrideExisting: false
});
const selectUser = userApi.endpoints.checkUser.select();
const { useCheckUserQuery } = userApi;
const Container$L = st$1.div`
  display: flex;
  align-items: center;
  gap: 10px;
  margin-left: auto;
`;
const Container$K = st$1.div``;
const InitialsWrapper = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 42px;
  height: 42px;
  border-radius: 50%;
  border: 1px solid ${(props) => props.theme.colors.greyF1};
  @media ${(props) => props.theme.media.mobile} {
    width: 8.75vw;
    height: 8.75vw;
  }
`;
const Initials = st$1.p`
width: fit-content;
text-align: center;
font-size: 15px;
font-weight: 400;
line-height: 148%;
text-transform: uppercase;
color: ${(props) => props.theme.colors.mainBlue};
@media ${(props) => props.theme.media.mobile} {
  font-size: 3.125vw;
}
`;
const getInitials = (fullName) => {
  if (!fullName) {
    return "";
  }
  const [firstName, lastName] = fullName.split(" ");
  if (!lastName || !firstName) {
    return "";
  }
  return `${firstName[0]}${lastName[0]}`;
};
function Profile({ userData }) {
  const [initials, setInitials] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (userData.name) {
      const initials2 = getInitials(userData.name);
      initials2.length > 1 ? setInitials(initials2) : setInitials(null);
    }
  }, [userData.name]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$K, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(InitialsWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Initials, { children: initials }) }) });
}
function ProfileBlock() {
  const user = useTypedSelector((state) => {
    var _a;
    return (_a = selectUser(state).data) == null ? void 0 : _a.user;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$L, { children: user && /* @__PURE__ */ jsxRuntimeExports.jsx(Profile, { userData: user }) });
}
const burgerIconOpen = "/assets/burger-icon-open.svg";
const burgerIconClose = "/assets/burger-icon-close.svg";
const Button$2 = st$1.button`
  display: none;
  background-color: transparent;
  padding: 0;
  margin: 0;
  width: fit-content;
  @media ${(props) => props.theme.media.mobile} {
    display: block;
  }
`;
const OpenIcon = st$1(Icon$2)`
  width: 7.5vw;
  height: 7.5vw;
  background-image: url(${burgerIconOpen});
`;
const CloseIcon = st$1(OpenIcon)`
  background-image: url(${burgerIconClose});
`;
function BurgerBtn({ onClick: onClick2, isOpen }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Button$2, { onClick: onClick2, children: isOpen ? /* @__PURE__ */ jsxRuntimeExports.jsx(CloseIcon, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(OpenIcon, {}) });
}
const Container$J = st$1.div`
  display: flex;
  align-items: center;
  padding: 3.125%;
  margin-bottom: 5%;
  border-bottom: 1px solid ${(props) => props.theme.colors.greyF1};
`;
const ProfileWrapper = st$1.div`
  display: flex;
  align-items: center;
  margin-left: auto;
  gap: 3vw;
`;
const UserName = st$1.div`
  display: flex;
  flex-direction: column;
`;
const Name = st$1.p`
  font-size: 3.75vw;
  font-weight: 500;
  color: ${(props) => props.theme.colors.dark};
`;
const Surname = st$1(Name)``;
const getUsername = (username) => {
  if (!username)
    return null;
  const [firstName, lastName] = username.split(" ");
  if (!firstName || !lastName)
    return null;
  return {
    firstName,
    lastName
  };
};
function Head$3({ onClose }) {
  const user = useTypedSelector((state) => {
    var _a;
    return (_a = selectUser(state).data) == null ? void 0 : _a.user;
  });
  const username = getUsername(user == null ? void 0 : user.name);
  reactExports.useEffect(() => {
    setTimeout(() => {
      document.body.addEventListener("click", onClose);
    });
    return () => {
      document.body.removeEventListener("click", onClose);
    };
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$J, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BurgerBtn,
      {
        isOpen: true,
        onClick: onClose
      }
    ),
    user && /* @__PURE__ */ jsxRuntimeExports.jsxs(ProfileWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Profile, { userData: user }),
      username && /* @__PURE__ */ jsxRuntimeExports.jsxs(UserName, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Name, { children: username.firstName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Surname, { children: username.lastName })
      ] })
    ] })
  ] });
}
const Container$I = st$1.div`
  display: flex;
  flex-direction: column;
  position: fixed;
  top: 0;
  left: 0;
  z-index: ${(props) => props.theme.utils.zIndex.burgerMenu};
  width: 100vw;
  height: 100vh;
  background-color: ${(props) => props.theme.colors.realWhite};
  overflow-y: auto;
`;
const Container$H = st$1.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5.6vw;
`;
function Nav({ onClose }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$H, { children: Object.values(NAV_LINKS).map((navLink, index) => /* @__PURE__ */ reactExports.createElement(
    CustomNavLink,
    {
      ...navLink,
      key: index,
      onClick: onClose
    }
  )) });
}
const Container$G = st$1.div`
  display: none;
  flex-direction: column;
  padding: 0 3.125%;
  margin-bottom: 5%;
  @media ${(props) => props.theme.media.mobile} {
    display: flex;
  }
`;
function Body({ onClose }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$G, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Nav, { onClose }) });
}
const useAphorism = () => {
  const defaultAphorism = {
    text: "Во всем надлежит действовать терпеливо.",
    author: "Набэсима Наосигэ"
  };
  const aphorisms = APHORISMS;
  if (!aphorisms || aphorisms.length === 0) {
    return defaultAphorism;
  }
  const randomIndex = Math.floor(Math.random() * aphorisms.length);
  return aphorisms[randomIndex];
};
const Container$F = st$1.div`
  display: none;
  @media ${(props) => props.theme.media.mobile} {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-bottom: 18.75vw;
  }
`;
const Title$g = st$1.h3`
  margin-bottom: 3.125vw;
  font-size: 3.125vw;
  font-weight: 700;
  line-height: 148%;
  color: ${(props) => props.theme.colors.grey93};
  text-align: center;
`;
const Aphorism$1 = st$1.p`
  margin-bottom: 9.375vw;
  font-size: 3.75vw;
  font-weight: 500;
  line-height: 148%;
  color: ${(props) => props.theme.colors.realBlack};
  text-align: center;
`;
const Author$1 = st$1(Aphorism$1)`
  margin-bottom: 0;
  font-weight: 400;
`;
function Aphorism() {
  const { text, author } = useAphorism();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$F, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title$g, { children: "Фраза дня" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Aphorism$1, { children: text }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Author$1, { children: author })
  ] });
}
const Container$E = st$1.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 0 3.125% 2.1875vw;
  margin-top: auto;
`;
const Bottom$1 = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
`;
const Logo$1 = st$1.img`
  display: block;
  width: 20.25vw;
`;
const Copyright = st$1.p`
  color: ${(props) => props.theme.colors.dark};
  font-size: 3.125vw;
  font-weight: 400;
  line-height: 148%;
`;
const logoMobile = "/assets/logo-mobile.svg";
function Footer$2() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$E, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Aphorism, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Bottom$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Logo$1,
        {
          src: logoMobile,
          alt: "Kaizen"
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Copyright, { children: "Создано в Ямагучи для Ямагучи (с) 2023" })
    ] })
  ] });
}
function BurgerMenu({ onClose }) {
  const modalRoot = document.querySelector("#modal-root");
  if (!modalRoot)
    return null;
  return ReactDOM.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$I, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Head$3, { onClose }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Body, { onClose }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Footer$2, {})
    ] }),
    modalRoot
  );
}
const common = {
  black: "#000",
  white: "#fff"
};
const common$1 = common;
const red = {
  50: "#ffebee",
  100: "#ffcdd2",
  200: "#ef9a9a",
  300: "#e57373",
  400: "#ef5350",
  500: "#f44336",
  600: "#e53935",
  700: "#d32f2f",
  800: "#c62828",
  900: "#b71c1c",
  A100: "#ff8a80",
  A200: "#ff5252",
  A400: "#ff1744",
  A700: "#d50000"
};
const red$1 = red;
const purple = {
  50: "#f3e5f5",
  100: "#e1bee7",
  200: "#ce93d8",
  300: "#ba68c8",
  400: "#ab47bc",
  500: "#9c27b0",
  600: "#8e24aa",
  700: "#7b1fa2",
  800: "#6a1b9a",
  900: "#4a148c",
  A100: "#ea80fc",
  A200: "#e040fb",
  A400: "#d500f9",
  A700: "#aa00ff"
};
const purple$1 = purple;
const blue = {
  50: "#e3f2fd",
  100: "#bbdefb",
  200: "#90caf9",
  300: "#64b5f6",
  400: "#42a5f5",
  500: "#2196f3",
  600: "#1e88e5",
  700: "#1976d2",
  800: "#1565c0",
  900: "#0d47a1",
  A100: "#82b1ff",
  A200: "#448aff",
  A400: "#2979ff",
  A700: "#2962ff"
};
const blue$1 = blue;
const lightBlue = {
  50: "#e1f5fe",
  100: "#b3e5fc",
  200: "#81d4fa",
  300: "#4fc3f7",
  400: "#29b6f6",
  500: "#03a9f4",
  600: "#039be5",
  700: "#0288d1",
  800: "#0277bd",
  900: "#01579b",
  A100: "#80d8ff",
  A200: "#40c4ff",
  A400: "#00b0ff",
  A700: "#0091ea"
};
const lightBlue$1 = lightBlue;
const green = {
  50: "#e8f5e9",
  100: "#c8e6c9",
  200: "#a5d6a7",
  300: "#81c784",
  400: "#66bb6a",
  500: "#4caf50",
  600: "#43a047",
  700: "#388e3c",
  800: "#2e7d32",
  900: "#1b5e20",
  A100: "#b9f6ca",
  A200: "#69f0ae",
  A400: "#00e676",
  A700: "#00c853"
};
const green$1 = green;
const orange = {
  50: "#fff3e0",
  100: "#ffe0b2",
  200: "#ffcc80",
  300: "#ffb74d",
  400: "#ffa726",
  500: "#ff9800",
  600: "#fb8c00",
  700: "#f57c00",
  800: "#ef6c00",
  900: "#e65100",
  A100: "#ffd180",
  A200: "#ffab40",
  A400: "#ff9100",
  A700: "#ff6d00"
};
const orange$1 = orange;
const grey = {
  50: "#fafafa",
  100: "#f5f5f5",
  200: "#eeeeee",
  300: "#e0e0e0",
  400: "#bdbdbd",
  500: "#9e9e9e",
  600: "#757575",
  700: "#616161",
  800: "#424242",
  900: "#212121",
  A100: "#f5f5f5",
  A200: "#eeeeee",
  A400: "#bdbdbd",
  A700: "#616161"
};
const grey$1 = grey;
function isPlainObject$1(item) {
  return item !== null && typeof item === "object" && item.constructor === Object;
}
function deepClone(source) {
  if (!isPlainObject$1(source)) {
    return source;
  }
  const output = {};
  Object.keys(source).forEach((key) => {
    output[key] = deepClone(source[key]);
  });
  return output;
}
function deepmerge(target, source, options = {
  clone: true
}) {
  const output = options.clone ? _extends$1({}, target) : target;
  if (isPlainObject$1(target) && isPlainObject$1(source)) {
    Object.keys(source).forEach((key) => {
      if (key === "__proto__") {
        return;
      }
      if (isPlainObject$1(source[key]) && key in target && isPlainObject$1(target[key])) {
        output[key] = deepmerge(target[key], source[key], options);
      } else if (options.clone) {
        output[key] = isPlainObject$1(source[key]) ? deepClone(source[key]) : source[key];
      } else {
        output[key] = source[key];
      }
    });
  }
  return output;
}
function formatMuiErrorMessage(code) {
  let url = "https://mui.com/production-error/?code=" + code;
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    url += "&args[]=" + encodeURIComponent(arguments[i2]);
  }
  return "Minified MUI error #" + code + "; visit " + url + " for the full message.";
}
function capitalize(string) {
  if (typeof string !== "string") {
    throw new Error(formatMuiErrorMessage(7));
  }
  return string.charAt(0).toUpperCase() + string.slice(1);
}
function createChainedFunction(...funcs) {
  return funcs.reduce((acc, func) => {
    if (func == null) {
      return acc;
    }
    return function chainedFunction(...args) {
      acc.apply(this, args);
      func.apply(this, args);
    };
  }, () => {
  });
}
function debounce(func, wait = 166) {
  let timeout;
  function debounced(...args) {
    const later = () => {
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  }
  debounced.clear = () => {
    clearTimeout(timeout);
  };
  return debounced;
}
function ownerDocument(node2) {
  return node2 && node2.ownerDocument || document;
}
function ownerWindow(node2) {
  const doc = ownerDocument(node2);
  return doc.defaultView || window;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
}
const useEnhancedEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
const useEnhancedEffect$1 = useEnhancedEffect;
let globalId = 0;
function useGlobalId(idOverride) {
  const [defaultId, setDefaultId] = reactExports.useState(idOverride);
  const id2 = idOverride || defaultId;
  reactExports.useEffect(() => {
    if (defaultId == null) {
      globalId += 1;
      setDefaultId(`mui-${globalId}`);
    }
  }, [defaultId]);
  return id2;
}
const maybeReactUseId = React$1["useId".toString()];
function useId(idOverride) {
  if (maybeReactUseId !== void 0) {
    const reactId = maybeReactUseId();
    return idOverride != null ? idOverride : reactId;
  }
  return useGlobalId(idOverride);
}
function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = "value"
}) {
  const {
    current: isControlled
  } = reactExports.useRef(controlled !== void 0);
  const [valueState, setValue] = reactExports.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  const setValueIfUncontrolled = reactExports.useCallback((newValue) => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}
function useEventCallback(fn2) {
  const ref = reactExports.useRef(fn2);
  useEnhancedEffect$1(() => {
    ref.current = fn2;
  });
  return reactExports.useCallback((...args) => (
    // @ts-expect-error hide `this`
    // tslint:disable-next-line:ban-comma-operator
    (0, ref.current)(...args)
  ), []);
}
function useForkRef(...refs) {
  return reactExports.useMemo(() => {
    if (refs.every((ref) => ref == null)) {
      return null;
    }
    return (instance) => {
      refs.forEach((ref) => {
        setRef(ref, instance);
      });
    };
  }, refs);
}
let hadKeyboardEvent = true;
let hadFocusVisibleRecently = false;
let hadFocusVisibleRecentlyTimeout;
const inputTypesWhitelist = {
  text: true,
  search: true,
  url: true,
  tel: true,
  email: true,
  password: true,
  number: true,
  date: true,
  month: true,
  week: true,
  time: true,
  datetime: true,
  "datetime-local": true
};
function focusTriggersKeyboardModality(node2) {
  const {
    type,
    tagName
  } = node2;
  if (tagName === "INPUT" && inputTypesWhitelist[type] && !node2.readOnly) {
    return true;
  }
  if (tagName === "TEXTAREA" && !node2.readOnly) {
    return true;
  }
  if (node2.isContentEditable) {
    return true;
  }
  return false;
}
function handleKeyDown(event) {
  if (event.metaKey || event.altKey || event.ctrlKey) {
    return;
  }
  hadKeyboardEvent = true;
}
function handlePointerDown() {
  hadKeyboardEvent = false;
}
function handleVisibilityChange() {
  if (this.visibilityState === "hidden") {
    if (hadFocusVisibleRecently) {
      hadKeyboardEvent = true;
    }
  }
}
function prepare(doc) {
  doc.addEventListener("keydown", handleKeyDown, true);
  doc.addEventListener("mousedown", handlePointerDown, true);
  doc.addEventListener("pointerdown", handlePointerDown, true);
  doc.addEventListener("touchstart", handlePointerDown, true);
  doc.addEventListener("visibilitychange", handleVisibilityChange, true);
}
function isFocusVisible(event) {
  const {
    target
  } = event;
  try {
    return target.matches(":focus-visible");
  } catch (error) {
  }
  return hadKeyboardEvent || focusTriggersKeyboardModality(target);
}
function useIsFocusVisible() {
  const ref = reactExports.useCallback((node2) => {
    if (node2 != null) {
      prepare(node2.ownerDocument);
    }
  }, []);
  const isFocusVisibleRef = reactExports.useRef(false);
  function handleBlurVisible() {
    if (isFocusVisibleRef.current) {
      hadFocusVisibleRecently = true;
      window.clearTimeout(hadFocusVisibleRecentlyTimeout);
      hadFocusVisibleRecentlyTimeout = window.setTimeout(() => {
        hadFocusVisibleRecently = false;
      }, 100);
      isFocusVisibleRef.current = false;
      return true;
    }
    return false;
  }
  function handleFocusVisible(event) {
    if (isFocusVisible(event)) {
      isFocusVisibleRef.current = true;
      return true;
    }
    return false;
  }
  return {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref
  };
}
function getScrollbarSize(doc) {
  const documentWidth = doc.documentElement.clientWidth;
  return Math.abs(window.innerWidth - documentWidth);
}
function resolveProps(defaultProps2, props) {
  const output = _extends$1({}, props);
  Object.keys(defaultProps2).forEach((propName) => {
    if (propName.toString().match(/^(components|slots)$/)) {
      output[propName] = _extends$1({}, defaultProps2[propName], output[propName]);
    } else if (propName.toString().match(/^(componentsProps|slotProps)$/)) {
      const defaultSlotProps = defaultProps2[propName] || {};
      const slotProps = props[propName];
      output[propName] = {};
      if (!slotProps || !Object.keys(slotProps)) {
        output[propName] = defaultSlotProps;
      } else if (!defaultSlotProps || !Object.keys(defaultSlotProps)) {
        output[propName] = slotProps;
      } else {
        output[propName] = _extends$1({}, slotProps);
        Object.keys(defaultSlotProps).forEach((slotPropName) => {
          output[propName][slotPropName] = resolveProps(defaultSlotProps[slotPropName], slotProps[slotPropName]);
        });
      }
    } else if (output[propName] === void 0) {
      output[propName] = defaultProps2[propName];
    }
  });
  return output;
}
function composeClasses(slots, getUtilityClass, classes2 = void 0) {
  const output = {};
  Object.keys(slots).forEach(
    // `Object.keys(slots)` can't be wider than `T` because we infer `T` from `slots`.
    // @ts-expect-error https://github.com/microsoft/TypeScript/pull/12253#issuecomment-263132208
    (slot) => {
      output[slot] = slots[slot].reduce((acc, key) => {
        if (key) {
          const utilityClass = getUtilityClass(key);
          if (utilityClass !== "") {
            acc.push(utilityClass);
          }
          if (classes2 && classes2[key]) {
            acc.push(classes2[key]);
          }
        }
        return acc;
      }, []).join(" ");
    }
  );
  return output;
}
const defaultGenerator = (componentName) => componentName;
const createClassNameGenerator = () => {
  let generate = defaultGenerator;
  return {
    configure(generator) {
      generate = generator;
    },
    generate(componentName) {
      return generate(componentName);
    },
    reset() {
      generate = defaultGenerator;
    }
  };
};
const ClassNameGenerator = createClassNameGenerator();
const ClassNameGenerator$1 = ClassNameGenerator;
const globalStateClassesMapping = {
  active: "active",
  checked: "checked",
  completed: "completed",
  disabled: "disabled",
  error: "error",
  expanded: "expanded",
  focused: "focused",
  focusVisible: "focusVisible",
  open: "open",
  readOnly: "readOnly",
  required: "required",
  selected: "selected"
};
function generateUtilityClass(componentName, slot, globalStatePrefix = "Mui") {
  const globalStateClass = globalStateClassesMapping[slot];
  return globalStateClass ? `${globalStatePrefix}-${globalStateClass}` : `${ClassNameGenerator$1.generate(componentName)}-${slot}`;
}
function generateUtilityClasses(componentName, slots, globalStatePrefix = "Mui") {
  const result = {};
  slots.forEach((slot) => {
    result[slot] = generateUtilityClass(componentName, slot, globalStatePrefix);
  });
  return result;
}
const THEME_ID = "$$material";
function sheetForTag(tag) {
  if (tag.sheet) {
    return tag.sheet;
  }
  for (var i2 = 0; i2 < document.styleSheets.length; i2++) {
    if (document.styleSheets[i2].ownerNode === tag) {
      return document.styleSheets[i2];
    }
  }
}
function createStyleElement(options) {
  var tag = document.createElement("style");
  tag.setAttribute("data-emotion", options.key);
  if (options.nonce !== void 0) {
    tag.setAttribute("nonce", options.nonce);
  }
  tag.appendChild(document.createTextNode(""));
  tag.setAttribute("data-s", "");
  return tag;
}
var StyleSheet = /* @__PURE__ */ function() {
  function StyleSheet2(options) {
    var _this = this;
    this._insertTag = function(tag) {
      var before;
      if (_this.tags.length === 0) {
        if (_this.insertionPoint) {
          before = _this.insertionPoint.nextSibling;
        } else if (_this.prepend) {
          before = _this.container.firstChild;
        } else {
          before = _this.before;
        }
      } else {
        before = _this.tags[_this.tags.length - 1].nextSibling;
      }
      _this.container.insertBefore(tag, before);
      _this.tags.push(tag);
    };
    this.isSpeedy = options.speedy === void 0 ? true : options.speedy;
    this.tags = [];
    this.ctr = 0;
    this.nonce = options.nonce;
    this.key = options.key;
    this.container = options.container;
    this.prepend = options.prepend;
    this.insertionPoint = options.insertionPoint;
    this.before = null;
  }
  var _proto = StyleSheet2.prototype;
  _proto.hydrate = function hydrate(nodes) {
    nodes.forEach(this._insertTag);
  };
  _proto.insert = function insert(rule) {
    if (this.ctr % (this.isSpeedy ? 65e3 : 1) === 0) {
      this._insertTag(createStyleElement(this));
    }
    var tag = this.tags[this.tags.length - 1];
    if (this.isSpeedy) {
      var sheet = sheetForTag(tag);
      try {
        sheet.insertRule(rule, sheet.cssRules.length);
      } catch (e2) {
      }
    } else {
      tag.appendChild(document.createTextNode(rule));
    }
    this.ctr++;
  };
  _proto.flush = function flush() {
    this.tags.forEach(function(tag) {
      return tag.parentNode && tag.parentNode.removeChild(tag);
    });
    this.tags = [];
    this.ctr = 0;
  };
  return StyleSheet2;
}();
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim$1(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index) {
  return value.charCodeAt(index) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "" };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0), root, { length: -root.length }, props);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim$1(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index) {
  while (!token(peek()))
    next();
  return slice(index, position);
}
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (ampersand == -1)
              characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root, parent, index, offset, rules, points, type, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index = offset = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size; ++x2)
      if (z2 = trim$1(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length2);
}
function comment(value, root, parent) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root, parent, length2) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i2 = 0; i2 < length2; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length)
        break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
var identifierWithPointTracking = function identifierWithPointTracking2(begin, points, index) {
  var previous = 0;
  var character2 = 0;
  while (true) {
    previous = character2;
    character2 = peek();
    if (previous === 38 && character2 === 12) {
      points[index] = 1;
    }
    if (token(character2)) {
      break;
    }
    next();
  }
  return slice(begin, position);
};
var toRules = function toRules2(parsed, points) {
  var index = -1;
  var character2 = 44;
  do {
    switch (token(character2)) {
      case 0:
        if (character2 === 38 && peek() === 12) {
          points[index] = 1;
        }
        parsed[index] += identifierWithPointTracking(position - 1, points, index);
        break;
      case 2:
        parsed[index] += delimit(character2);
        break;
      case 4:
        if (character2 === 44) {
          parsed[++index] = peek() === 58 ? "&\f" : "";
          points[index] = parsed[index].length;
          break;
        }
      default:
        parsed[index] += from(character2);
    }
  } while (character2 = next());
  return parsed;
};
var getRules = function getRules2(value, points) {
  return dealloc(toRules(alloc(value), points));
};
var fixedElements = /* @__PURE__ */ new WeakMap();
var compat = function compat2(element) {
  if (element.type !== "rule" || !element.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  element.length < 1) {
    return;
  }
  var value = element.value, parent = element.parent;
  var isImplicitRule = element.column === parent.column && element.line === parent.line;
  while (parent.type !== "rule") {
    parent = parent.parent;
    if (!parent)
      return;
  }
  if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {
    return;
  }
  if (isImplicitRule) {
    return;
  }
  fixedElements.set(element, true);
  var points = [];
  var rules = getRules(value, points);
  var parentRules = parent.props;
  for (var i2 = 0, k2 = 0; i2 < rules.length; i2++) {
    for (var j2 = 0; j2 < parentRules.length; j2++, k2++) {
      element.props[k2] = points[i2] ? rules[i2].replace(/&\f/g, parentRules[j2]) : parentRules[j2] + " " + rules[i2];
    }
  }
};
var removeLabel = function removeLabel2(element) {
  if (element.type === "decl") {
    var value = element.value;
    if (
      // charcode for l
      value.charCodeAt(0) === 108 && // charcode for b
      value.charCodeAt(2) === 98
    ) {
      element["return"] = "";
      element.value = "";
    }
  }
};
function prefix(value, length2) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 6828:
    case 4268:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/, "") + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch") ? prefix(replace(value, "stretch", "fill-available"), length2) + value : value;
        }
      break;
    case 4949:
      if (charat(value, length2 + 1) !== 115)
        break;
    case 6444:
      switch (charat(value, strlen(value) - 3 - (~indexof(value, "!important") && 10))) {
        case 107:
          return replace(value, ":", ":" + WEBKIT) + value;
        case 101:
          return replace(value, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
      }
      break;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
      return WEBKIT + value + MS + value + value;
  }
  return value;
}
var prefixer = function prefixer2(element, index, children, callback) {
  if (element.length > -1) {
    if (!element["return"])
      switch (element.type) {
        case DECLARATION:
          element["return"] = prefix(element.value, element.length);
          break;
        case KEYFRAMES:
          return serialize([copy(element, {
            value: replace(element.value, "@", "@" + WEBKIT)
          })], callback);
        case RULESET:
          if (element.length)
            return combine(element.props, function(value) {
              switch (match(value, /(::plac\w+|:read-\w+)/)) {
                case ":read-only":
                case ":read-write":
                  return serialize([copy(element, {
                    props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")]
                  })], callback);
                case "::placeholder":
                  return serialize([copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")]
                  }), copy(element, {
                    props: [replace(value, /:(plac\w+)/, MS + "input-$1")]
                  })], callback);
              }
              return "";
            });
      }
  }
};
var defaultStylisPlugins = [prefixer];
var createCache = function createCache2(options) {
  var key = options.key;
  if (key === "css") {
    var ssrStyles = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(ssrStyles, function(node2) {
      var dataEmotionAttribute = node2.getAttribute("data-emotion");
      if (dataEmotionAttribute.indexOf(" ") === -1) {
        return;
      }
      document.head.appendChild(node2);
      node2.setAttribute("data-s", "");
    });
  }
  var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;
  var inserted = {};
  var container;
  var nodesToHydrate = [];
  {
    container = options.container || document.head;
    Array.prototype.forEach.call(
      // this means we will ignore elements which don't have a space in them which
      // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
      document.querySelectorAll('style[data-emotion^="' + key + ' "]'),
      function(node2) {
        var attrib = node2.getAttribute("data-emotion").split(" ");
        for (var i2 = 1; i2 < attrib.length; i2++) {
          inserted[attrib[i2]] = true;
        }
        nodesToHydrate.push(node2);
      }
    );
  }
  var _insert;
  var omnipresentPlugins = [compat, removeLabel];
  {
    var currentSheet;
    var finalizingPlugins = [stringify, rulesheet(function(rule) {
      currentSheet.insert(rule);
    })];
    var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));
    var stylis = function stylis2(styles2) {
      return serialize(compile(styles2), serializer);
    };
    _insert = function insert(selector, serialized, sheet, shouldCache) {
      currentSheet = sheet;
      stylis(selector ? selector + "{" + serialized.styles + "}" : serialized.styles);
      if (shouldCache) {
        cache2.inserted[serialized.name] = true;
      }
    };
  }
  var cache2 = {
    key,
    sheet: new StyleSheet({
      key,
      container,
      nonce: options.nonce,
      speedy: options.speedy,
      prepend: options.prepend,
      insertionPoint: options.insertionPoint
    }),
    nonce: options.nonce,
    inserted,
    registered: {},
    insert: _insert
  };
  cache2.sheet.hydrate(nodesToHydrate);
  return cache2;
};
var isBrowser = true;
function getRegisteredStyles(registered, registeredStyles, classNames) {
  var rawClassName = "";
  classNames.split(" ").forEach(function(className) {
    if (registered[className] !== void 0) {
      registeredStyles.push(registered[className] + ";");
    } else {
      rawClassName += className + " ";
    }
  });
  return rawClassName;
}
var registerStyles = function registerStyles2(cache2, serialized, isStringTag2) {
  var className = cache2.key + "-" + serialized.name;
  if (
    // we only need to add the styles to the registered cache if the
    // class name could be used further down
    // the tree but if it's a string tag, we know it won't
    // so we don't have to add it to registered cache.
    // this improves memory usage since we can avoid storing the whole style string
    (isStringTag2 === false || // we need to always store it if we're in compat mode and
    // in node since emotion-server relies on whether a style is in
    // the registered cache to know whether a style is global or not
    // also, note that this check will be dead code eliminated in the browser
    isBrowser === false) && cache2.registered[className] === void 0
  ) {
    cache2.registered[className] = serialized.styles;
  }
};
var insertStyles = function insertStyles2(cache2, serialized, isStringTag2) {
  registerStyles(cache2, serialized, isStringTag2);
  var className = cache2.key + "-" + serialized.name;
  if (cache2.inserted[serialized.name] === void 0) {
    var current = serialized;
    do {
      cache2.insert(serialized === current ? "." + className : "", current, cache2.sheet, true);
      current = current.next;
    } while (current !== void 0);
  }
};
function murmur2(str) {
  var h2 = 0;
  var k2, i2 = 0, len = str.length;
  for (; len >= 4; ++i2, len -= 4) {
    k2 = str.charCodeAt(i2) & 255 | (str.charCodeAt(++i2) & 255) << 8 | (str.charCodeAt(++i2) & 255) << 16 | (str.charCodeAt(++i2) & 255) << 24;
    k2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
    k2 ^= /* k >>> r: */
    k2 >>> 24;
    h2 = /* Math.imul(k, m): */
    (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  switch (len) {
    case 3:
      h2 ^= (str.charCodeAt(i2 + 2) & 255) << 16;
    case 2:
      h2 ^= (str.charCodeAt(i2 + 1) & 255) << 8;
    case 1:
      h2 ^= str.charCodeAt(i2) & 255;
      h2 = /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  }
  h2 ^= h2 >>> 13;
  h2 = /* Math.imul(h, m): */
  (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
  return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
}
var hyphenateRegex = /[A-Z]|^ms/g;
var animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;
var isCustomProperty = function isCustomProperty2(property) {
  return property.charCodeAt(1) === 45;
};
var isProcessableValue = function isProcessableValue2(value) {
  return value != null && typeof value !== "boolean";
};
var processStyleName = /* @__PURE__ */ memoize$1(function(styleName) {
  return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, "-$&").toLowerCase();
});
var processStyleValue = function processStyleValue2(key, value) {
  switch (key) {
    case "animation":
    case "animationName": {
      if (typeof value === "string") {
        return value.replace(animationRegex, function(match2, p1, p2) {
          cursor = {
            name: p1,
            styles: p2,
            next: cursor
          };
          return p1;
        });
      }
    }
  }
  if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === "number" && value !== 0) {
    return value + "px";
  }
  return value;
};
var noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(mergedProps, registered, interpolation) {
  if (interpolation == null) {
    return "";
  }
  if (interpolation.__emotion_styles !== void 0) {
    return interpolation;
  }
  switch (typeof interpolation) {
    case "boolean": {
      return "";
    }
    case "object": {
      if (interpolation.anim === 1) {
        cursor = {
          name: interpolation.name,
          styles: interpolation.styles,
          next: cursor
        };
        return interpolation.name;
      }
      if (interpolation.styles !== void 0) {
        var next2 = interpolation.next;
        if (next2 !== void 0) {
          while (next2 !== void 0) {
            cursor = {
              name: next2.name,
              styles: next2.styles,
              next: cursor
            };
            next2 = next2.next;
          }
        }
        var styles2 = interpolation.styles + ";";
        return styles2;
      }
      return createStringFromObject(mergedProps, registered, interpolation);
    }
    case "function": {
      if (mergedProps !== void 0) {
        var previousCursor = cursor;
        var result = interpolation(mergedProps);
        cursor = previousCursor;
        return handleInterpolation(mergedProps, registered, result);
      }
      break;
    }
  }
  if (registered == null) {
    return interpolation;
  }
  var cached = registered[interpolation];
  return cached !== void 0 ? cached : interpolation;
}
function createStringFromObject(mergedProps, registered, obj) {
  var string = "";
  if (Array.isArray(obj)) {
    for (var i2 = 0; i2 < obj.length; i2++) {
      string += handleInterpolation(mergedProps, registered, obj[i2]) + ";";
    }
  } else {
    for (var _key in obj) {
      var value = obj[_key];
      if (typeof value !== "object") {
        if (registered != null && registered[value] !== void 0) {
          string += _key + "{" + registered[value] + "}";
        } else if (isProcessableValue(value)) {
          string += processStyleName(_key) + ":" + processStyleValue(_key, value) + ";";
        }
      } else {
        if (_key === "NO_COMPONENT_SELECTOR" && false) {
          throw new Error(noComponentSelectorMessage);
        }
        if (Array.isArray(value) && typeof value[0] === "string" && (registered == null || registered[value[0]] === void 0)) {
          for (var _i = 0; _i < value.length; _i++) {
            if (isProcessableValue(value[_i])) {
              string += processStyleName(_key) + ":" + processStyleValue(_key, value[_i]) + ";";
            }
          }
        } else {
          var interpolated = handleInterpolation(mergedProps, registered, value);
          switch (_key) {
            case "animation":
            case "animationName": {
              string += processStyleName(_key) + ":" + interpolated + ";";
              break;
            }
            default: {
              string += _key + "{" + interpolated + "}";
            }
          }
        }
      }
    }
  }
  return string;
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g;
var cursor;
var serializeStyles = function serializeStyles2(args, registered, mergedProps) {
  if (args.length === 1 && typeof args[0] === "object" && args[0] !== null && args[0].styles !== void 0) {
    return args[0];
  }
  var stringMode = true;
  var styles2 = "";
  cursor = void 0;
  var strings = args[0];
  if (strings == null || strings.raw === void 0) {
    stringMode = false;
    styles2 += handleInterpolation(mergedProps, registered, strings);
  } else {
    styles2 += strings[0];
  }
  for (var i2 = 1; i2 < args.length; i2++) {
    styles2 += handleInterpolation(mergedProps, registered, args[i2]);
    if (stringMode) {
      styles2 += strings[i2];
    }
  }
  labelPattern.lastIndex = 0;
  var identifierName = "";
  var match2;
  while ((match2 = labelPattern.exec(styles2)) !== null) {
    identifierName += "-" + // $FlowFixMe we know it's not null
    match2[1];
  }
  var name = murmur2(styles2) + identifierName;
  return {
    name,
    styles: styles2,
    next: cursor
  };
};
var syncFallback = function syncFallback2(create) {
  return create();
};
var useInsertionEffect = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : false;
var useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback;
var useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect;
var EmotionCacheContext = /* @__PURE__ */ reactExports.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement !== "undefined" ? /* @__PURE__ */ createCache({
    key: "css"
  }) : null
);
EmotionCacheContext.Provider;
var withEmotionCache = function withEmotionCache2(func) {
  return /* @__PURE__ */ reactExports.forwardRef(function(props, ref) {
    var cache2 = reactExports.useContext(EmotionCacheContext);
    return func(props, cache2, ref);
  });
};
var ThemeContext = /* @__PURE__ */ reactExports.createContext({});
var Global = /* @__PURE__ */ withEmotionCache(function(props, cache2) {
  var styles2 = props.styles;
  var serialized = serializeStyles([styles2], void 0, reactExports.useContext(ThemeContext));
  var sheetRef = reactExports.useRef();
  useInsertionEffectWithLayoutFallback(function() {
    var key = cache2.key + "-global";
    var sheet = new cache2.sheet.constructor({
      key,
      nonce: cache2.sheet.nonce,
      container: cache2.sheet.container,
      speedy: cache2.sheet.isSpeedy
    });
    var rehydrating = false;
    var node2 = document.querySelector('style[data-emotion="' + key + " " + serialized.name + '"]');
    if (cache2.sheet.tags.length) {
      sheet.before = cache2.sheet.tags[0];
    }
    if (node2 !== null) {
      rehydrating = true;
      node2.setAttribute("data-emotion", key);
      sheet.hydrate([node2]);
    }
    sheetRef.current = [sheet, rehydrating];
    return function() {
      sheet.flush();
    };
  }, [cache2]);
  useInsertionEffectWithLayoutFallback(function() {
    var sheetRefCurrent = sheetRef.current;
    var sheet = sheetRefCurrent[0], rehydrating = sheetRefCurrent[1];
    if (rehydrating) {
      sheetRefCurrent[1] = false;
      return;
    }
    if (serialized.next !== void 0) {
      insertStyles(cache2, serialized.next, true);
    }
    if (sheet.tags.length) {
      var element = sheet.tags[sheet.tags.length - 1].nextElementSibling;
      sheet.before = element;
      sheet.flush();
    }
    cache2.insert("", serialized, sheet, false);
  }, [cache2, serialized.name]);
  return null;
});
function css() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return serializeStyles(args);
}
var keyframes = function keyframes2() {
  var insertable = css.apply(void 0, arguments);
  var name = "animation-" + insertable.name;
  return {
    name,
    styles: "@keyframes " + name + "{" + insertable.styles + "}",
    anim: 1,
    toString: function toString3() {
      return "_EMO_" + this.name + "_" + this.styles + "_EMO_";
    }
  };
};
var testOmitPropsOnStringTag = isPropValid;
var testOmitPropsOnComponent = function testOmitPropsOnComponent2(key) {
  return key !== "theme";
};
var getDefaultShouldForwardProp = function getDefaultShouldForwardProp2(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;
};
var composeShouldForwardProps = function composeShouldForwardProps2(tag, options, isReal) {
  var shouldForwardProp2;
  if (options) {
    var optionsShouldForwardProp = options.shouldForwardProp;
    shouldForwardProp2 = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {
      return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);
    } : optionsShouldForwardProp;
  }
  if (typeof shouldForwardProp2 !== "function" && isReal) {
    shouldForwardProp2 = tag.__emotion_forwardProp;
  }
  return shouldForwardProp2;
};
var Insertion = function Insertion2(_ref) {
  var cache2 = _ref.cache, serialized = _ref.serialized, isStringTag2 = _ref.isStringTag;
  registerStyles(cache2, serialized, isStringTag2);
  useInsertionEffectAlwaysWithSyncFallback(function() {
    return insertStyles(cache2, serialized, isStringTag2);
  });
  return null;
};
var createStyled$1 = function createStyled(tag, options) {
  var isReal = tag.__emotion_real === tag;
  var baseTag = isReal && tag.__emotion_base || tag;
  var identifierName;
  var targetClassName;
  if (options !== void 0) {
    identifierName = options.label;
    targetClassName = options.target;
  }
  var shouldForwardProp2 = composeShouldForwardProps(tag, options, isReal);
  var defaultShouldForwardProp = shouldForwardProp2 || getDefaultShouldForwardProp(baseTag);
  var shouldUseAs = !defaultShouldForwardProp("as");
  return function() {
    var args = arguments;
    var styles2 = isReal && tag.__emotion_styles !== void 0 ? tag.__emotion_styles.slice(0) : [];
    if (identifierName !== void 0) {
      styles2.push("label:" + identifierName + ";");
    }
    if (args[0] == null || args[0].raw === void 0) {
      styles2.push.apply(styles2, args);
    } else {
      styles2.push(args[0][0]);
      var len = args.length;
      var i2 = 1;
      for (; i2 < len; i2++) {
        styles2.push(args[i2], args[0][i2]);
      }
    }
    var Styled = withEmotionCache(function(props, cache2, ref) {
      var FinalTag = shouldUseAs && props.as || baseTag;
      var className = "";
      var classInterpolations = [];
      var mergedProps = props;
      if (props.theme == null) {
        mergedProps = {};
        for (var key in props) {
          mergedProps[key] = props[key];
        }
        mergedProps.theme = reactExports.useContext(ThemeContext);
      }
      if (typeof props.className === "string") {
        className = getRegisteredStyles(cache2.registered, classInterpolations, props.className);
      } else if (props.className != null) {
        className = props.className + " ";
      }
      var serialized = serializeStyles(styles2.concat(classInterpolations), cache2.registered, mergedProps);
      className += cache2.key + "-" + serialized.name;
      if (targetClassName !== void 0) {
        className += " " + targetClassName;
      }
      var finalShouldForwardProp = shouldUseAs && shouldForwardProp2 === void 0 ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;
      var newProps = {};
      for (var _key in props) {
        if (shouldUseAs && _key === "as")
          continue;
        if (
          // $FlowFixMe
          finalShouldForwardProp(_key)
        ) {
          newProps[_key] = props[_key];
        }
      }
      newProps.className = className;
      newProps.ref = ref;
      return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(Insertion, {
        cache: cache2,
        serialized,
        isStringTag: typeof FinalTag === "string"
      }), /* @__PURE__ */ reactExports.createElement(FinalTag, newProps));
    });
    Styled.displayName = identifierName !== void 0 ? identifierName : "Styled(" + (typeof baseTag === "string" ? baseTag : baseTag.displayName || baseTag.name || "Component") + ")";
    Styled.defaultProps = tag.defaultProps;
    Styled.__emotion_real = Styled;
    Styled.__emotion_base = baseTag;
    Styled.__emotion_styles = styles2;
    Styled.__emotion_forwardProp = shouldForwardProp2;
    Object.defineProperty(Styled, "toString", {
      value: function value() {
        if (targetClassName === void 0 && false) {
          return "NO_COMPONENT_SELECTOR";
        }
        return "." + targetClassName;
      }
    });
    Styled.withComponent = function(nextTag, nextOptions) {
      return createStyled(nextTag, _extends$1({}, options, nextOptions, {
        shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)
      })).apply(void 0, styles2);
    };
    return Styled;
  };
};
var tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "big",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "keygen",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "marquee",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rp",
  "rt",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr",
  // SVG
  "circle",
  "clipPath",
  "defs",
  "ellipse",
  "foreignObject",
  "g",
  "image",
  "line",
  "linearGradient",
  "mask",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "radialGradient",
  "rect",
  "stop",
  "svg",
  "text",
  "tspan"
];
var newStyled = createStyled$1.bind();
tags.forEach(function(tagName) {
  newStyled[tagName] = newStyled(tagName);
});
function isEmpty$4(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0;
}
function GlobalStyles$2(props) {
  const {
    styles: styles2,
    defaultTheme: defaultTheme2 = {}
  } = props;
  const globalStyles = typeof styles2 === "function" ? (themeInput) => styles2(isEmpty$4(themeInput) ? defaultTheme2 : themeInput) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Global, {
    styles: globalStyles
  });
}
/**
 * @mui/styled-engine v5.14.13
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$2(tag, options) {
  const stylesFactory = newStyled(tag, options);
  return stylesFactory;
}
const internal_processStyles = (tag, processor) => {
  if (Array.isArray(tag.__emotion_styles)) {
    tag.__emotion_styles = processor(tag.__emotion_styles);
  }
};
const _excluded$y = ["values", "unit", "step"];
const sortBreakpointsValues = (values2) => {
  const breakpointsAsArray = Object.keys(values2).map((key) => ({
    key,
    val: values2[key]
  })) || [];
  breakpointsAsArray.sort((breakpoint1, breakpoint2) => breakpoint1.val - breakpoint2.val);
  return breakpointsAsArray.reduce((acc, obj) => {
    return _extends$1({}, acc, {
      [obj.key]: obj.val
    });
  }, {});
};
function createBreakpoints(breakpoints2) {
  const {
    // The breakpoint **start** at this value.
    // For instance with the first breakpoint xs: [xs, sm).
    values: values2 = {
      xs: 0,
      // phone
      sm: 600,
      // tablet
      md: 900,
      // small laptop
      lg: 1200,
      // desktop
      xl: 1536
      // large screen
    },
    unit = "px",
    step = 5
  } = breakpoints2, other = _objectWithoutPropertiesLoose(breakpoints2, _excluded$y);
  const sortedValues = sortBreakpointsValues(values2);
  const keys = Object.keys(sortedValues);
  function up(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (min-width:${value}${unit})`;
  }
  function down(key) {
    const value = typeof values2[key] === "number" ? values2[key] : key;
    return `@media (max-width:${value - step / 100}${unit})`;
  }
  function between(start, end) {
    const endIndex = keys.indexOf(end);
    return `@media (min-width:${typeof values2[start] === "number" ? values2[start] : start}${unit}) and (max-width:${(endIndex !== -1 && typeof values2[keys[endIndex]] === "number" ? values2[keys[endIndex]] : end) - step / 100}${unit})`;
  }
  function only(key) {
    if (keys.indexOf(key) + 1 < keys.length) {
      return between(key, keys[keys.indexOf(key) + 1]);
    }
    return up(key);
  }
  function not(key) {
    const keyIndex = keys.indexOf(key);
    if (keyIndex === 0) {
      return up(keys[1]);
    }
    if (keyIndex === keys.length - 1) {
      return down(keys[keyIndex]);
    }
    return between(key, keys[keys.indexOf(key) + 1]).replace("@media", "@media not all and");
  }
  return _extends$1({
    keys,
    values: sortedValues,
    up,
    down,
    between,
    only,
    not,
    unit
  }, other);
}
const shape = {
  borderRadius: 4
};
const shape$1 = shape;
function merge$1(acc, item) {
  if (!item) {
    return acc;
  }
  return deepmerge(acc, item, {
    clone: false
    // No need to clone deep, it's way faster.
  });
}
const values$1 = {
  xs: 0,
  // phone
  sm: 600,
  // tablet
  md: 900,
  // small laptop
  lg: 1200,
  // desktop
  xl: 1536
  // large screen
};
const defaultBreakpoints = {
  // Sorted ASC by size. That's important.
  // It can't be configured as it's used statically for propTypes.
  keys: ["xs", "sm", "md", "lg", "xl"],
  up: (key) => `@media (min-width:${values$1[key]}px)`
};
function handleBreakpoints(props, propValue, styleFromPropValue) {
  const theme = props.theme || {};
  if (Array.isArray(propValue)) {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return propValue.reduce((acc, item, index) => {
      acc[themeBreakpoints.up(themeBreakpoints.keys[index])] = styleFromPropValue(propValue[index]);
      return acc;
    }, {});
  }
  if (typeof propValue === "object") {
    const themeBreakpoints = theme.breakpoints || defaultBreakpoints;
    return Object.keys(propValue).reduce((acc, breakpoint) => {
      if (Object.keys(themeBreakpoints.values || values$1).indexOf(breakpoint) !== -1) {
        const mediaKey = themeBreakpoints.up(breakpoint);
        acc[mediaKey] = styleFromPropValue(propValue[breakpoint], breakpoint);
      } else {
        const cssKey = breakpoint;
        acc[cssKey] = propValue[cssKey];
      }
      return acc;
    }, {});
  }
  const output = styleFromPropValue(propValue);
  return output;
}
function createEmptyBreakpointObject(breakpointsInput = {}) {
  var _breakpointsInput$key;
  const breakpointsInOrder = (_breakpointsInput$key = breakpointsInput.keys) == null ? void 0 : _breakpointsInput$key.reduce((acc, key) => {
    const breakpointStyleKey = breakpointsInput.up(key);
    acc[breakpointStyleKey] = {};
    return acc;
  }, {});
  return breakpointsInOrder || {};
}
function removeUnusedBreakpoints(breakpointKeys, style2) {
  return breakpointKeys.reduce((acc, key) => {
    const breakpointOutput = acc[key];
    const isBreakpointUnused = !breakpointOutput || Object.keys(breakpointOutput).length === 0;
    if (isBreakpointUnused) {
      delete acc[key];
    }
    return acc;
  }, style2);
}
function getPath(obj, path, checkVars = true) {
  if (!path || typeof path !== "string") {
    return null;
  }
  if (obj && obj.vars && checkVars) {
    const val = `vars.${path}`.split(".").reduce((acc, item) => acc && acc[item] ? acc[item] : null, obj);
    if (val != null) {
      return val;
    }
  }
  return path.split(".").reduce((acc, item) => {
    if (acc && acc[item] != null) {
      return acc[item];
    }
    return null;
  }, obj);
}
function getStyleValue$1(themeMapping, transform, propValueFinal, userValue = propValueFinal) {
  let value;
  if (typeof themeMapping === "function") {
    value = themeMapping(propValueFinal);
  } else if (Array.isArray(themeMapping)) {
    value = themeMapping[propValueFinal] || userValue;
  } else {
    value = getPath(themeMapping, propValueFinal) || userValue;
  }
  if (transform) {
    value = transform(value, userValue, themeMapping);
  }
  return value;
}
function style$1(options) {
  const {
    prop,
    cssProperty = options.prop,
    themeKey,
    transform
  } = options;
  const fn2 = (props) => {
    if (props[prop] == null) {
      return null;
    }
    const propValue = props[prop];
    const theme = props.theme;
    const themeMapping = getPath(theme, themeKey) || {};
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, propValue, styleFromPropValue);
  };
  fn2.propTypes = {};
  fn2.filterProps = [prop];
  return fn2;
}
function memoize(fn2) {
  const cache2 = {};
  return (arg) => {
    if (cache2[arg] === void 0) {
      cache2[arg] = fn2(arg);
    }
    return cache2[arg];
  };
}
const properties = {
  m: "margin",
  p: "padding"
};
const directions = {
  t: "Top",
  r: "Right",
  b: "Bottom",
  l: "Left",
  x: ["Left", "Right"],
  y: ["Top", "Bottom"]
};
const aliases = {
  marginX: "mx",
  marginY: "my",
  paddingX: "px",
  paddingY: "py"
};
const getCssProperties = memoize((prop) => {
  if (prop.length > 2) {
    if (aliases[prop]) {
      prop = aliases[prop];
    } else {
      return [prop];
    }
  }
  const [a2, b2] = prop.split("");
  const property = properties[a2];
  const direction = directions[b2] || "";
  return Array.isArray(direction) ? direction.map((dir) => property + dir) : [property + direction];
});
const marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"];
const paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(theme, themeKey, defaultValue, propName) {
  var _getPath;
  const themeSpacing = (_getPath = getPath(theme, themeKey, false)) != null ? _getPath : defaultValue;
  if (typeof themeSpacing === "number") {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing * abs2;
    };
  }
  if (Array.isArray(themeSpacing)) {
    return (abs2) => {
      if (typeof abs2 === "string") {
        return abs2;
      }
      return themeSpacing[abs2];
    };
  }
  if (typeof themeSpacing === "function") {
    return themeSpacing;
  }
  return () => void 0;
}
function createUnarySpacing(theme) {
  return createUnaryUnit(theme, "spacing", 8);
}
function getValue(transformer, propValue) {
  if (typeof propValue === "string" || propValue == null) {
    return propValue;
  }
  const abs2 = Math.abs(propValue);
  const transformed = transformer(abs2);
  if (propValue >= 0) {
    return transformed;
  }
  if (typeof transformed === "number") {
    return -transformed;
  }
  return `-${transformed}`;
}
function getStyleFromPropValue(cssProperties, transformer) {
  return (propValue) => cssProperties.reduce((acc, cssProperty) => {
    acc[cssProperty] = getValue(transformer, propValue);
    return acc;
  }, {});
}
function resolveCssProperty(props, keys, prop, transformer) {
  if (keys.indexOf(prop) === -1) {
    return null;
  }
  const cssProperties = getCssProperties(prop);
  const styleFromPropValue = getStyleFromPropValue(cssProperties, transformer);
  const propValue = props[prop];
  return handleBreakpoints(props, propValue, styleFromPropValue);
}
function style(props, keys) {
  const transformer = createUnarySpacing(props.theme);
  return Object.keys(props).map((prop) => resolveCssProperty(props, keys, prop, transformer)).reduce(merge$1, {});
}
function margin(props) {
  return style(props, marginKeys);
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(props) {
  return style(props, paddingKeys);
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(spacingInput = 8) {
  if (spacingInput.mui) {
    return spacingInput;
  }
  const transform = createUnarySpacing({
    spacing: spacingInput
  });
  const spacing = (...argsInput) => {
    const args = argsInput.length === 0 ? [1] : argsInput;
    return args.map((argument) => {
      const output = transform(argument);
      return typeof output === "number" ? `${output}px` : output;
    }).join(" ");
  };
  spacing.mui = true;
  return spacing;
}
function compose(...styles2) {
  const handlers = styles2.reduce((acc, style2) => {
    style2.filterProps.forEach((prop) => {
      acc[prop] = style2;
    });
    return acc;
  }, {});
  const fn2 = (props) => {
    return Object.keys(props).reduce((acc, prop) => {
      if (handlers[prop]) {
        return merge$1(acc, handlers[prop](props));
      }
      return acc;
    }, {});
  };
  fn2.propTypes = {};
  fn2.filterProps = styles2.reduce((acc, style2) => acc.concat(style2.filterProps), []);
  return fn2;
}
function borderTransform(value) {
  if (typeof value !== "number") {
    return value;
  }
  return `${value}px solid`;
}
const border = style$1({
  prop: "border",
  themeKey: "borders",
  transform: borderTransform
});
const borderTop = style$1({
  prop: "borderTop",
  themeKey: "borders",
  transform: borderTransform
});
const borderRight = style$1({
  prop: "borderRight",
  themeKey: "borders",
  transform: borderTransform
});
const borderBottom = style$1({
  prop: "borderBottom",
  themeKey: "borders",
  transform: borderTransform
});
const borderLeft = style$1({
  prop: "borderLeft",
  themeKey: "borders",
  transform: borderTransform
});
const borderColor = style$1({
  prop: "borderColor",
  themeKey: "palette"
});
const borderTopColor = style$1({
  prop: "borderTopColor",
  themeKey: "palette"
});
const borderRightColor = style$1({
  prop: "borderRightColor",
  themeKey: "palette"
});
const borderBottomColor = style$1({
  prop: "borderBottomColor",
  themeKey: "palette"
});
const borderLeftColor = style$1({
  prop: "borderLeftColor",
  themeKey: "palette"
});
const borderRadius = (props) => {
  if (props.borderRadius !== void 0 && props.borderRadius !== null) {
    const transformer = createUnaryUnit(props.theme, "shape.borderRadius", 4);
    const styleFromPropValue = (propValue) => ({
      borderRadius: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.borderRadius, styleFromPropValue);
  }
  return null;
};
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius);
const gap = (props) => {
  if (props.gap !== void 0 && props.gap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      gap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.gap, styleFromPropValue);
  }
  return null;
};
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = (props) => {
  if (props.columnGap !== void 0 && props.columnGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      columnGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.columnGap, styleFromPropValue);
  }
  return null;
};
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = (props) => {
  if (props.rowGap !== void 0 && props.rowGap !== null) {
    const transformer = createUnaryUnit(props.theme, "spacing", 8);
    const styleFromPropValue = (propValue) => ({
      rowGap: getValue(transformer, propValue)
    });
    return handleBreakpoints(props, props.rowGap, styleFromPropValue);
  }
  return null;
};
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$1({
  prop: "gridColumn"
});
const gridRow = style$1({
  prop: "gridRow"
});
const gridAutoFlow = style$1({
  prop: "gridAutoFlow"
});
const gridAutoColumns = style$1({
  prop: "gridAutoColumns"
});
const gridAutoRows = style$1({
  prop: "gridAutoRows"
});
const gridTemplateColumns = style$1({
  prop: "gridTemplateColumns"
});
const gridTemplateRows = style$1({
  prop: "gridTemplateRows"
});
const gridTemplateAreas = style$1({
  prop: "gridTemplateAreas"
});
const gridArea = style$1({
  prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(value, userValue) {
  if (userValue === "grey") {
    return userValue;
  }
  return value;
}
const color = style$1({
  prop: "color",
  themeKey: "palette",
  transform: paletteTransform
});
const bgcolor = style$1({
  prop: "bgcolor",
  cssProperty: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
const backgroundColor = style$1({
  prop: "backgroundColor",
  themeKey: "palette",
  transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(value) {
  return value <= 1 && value !== 0 ? `${value * 100}%` : value;
}
const width = style$1({
  prop: "width",
  transform: sizingTransform
});
const maxWidth = (props) => {
  if (props.maxWidth !== void 0 && props.maxWidth !== null) {
    const styleFromPropValue = (propValue) => {
      var _props$theme, _props$theme2;
      const breakpoint = ((_props$theme = props.theme) == null || (_props$theme = _props$theme.breakpoints) == null || (_props$theme = _props$theme.values) == null ? void 0 : _props$theme[propValue]) || values$1[propValue];
      if (!breakpoint) {
        return {
          maxWidth: sizingTransform(propValue)
        };
      }
      if (((_props$theme2 = props.theme) == null || (_props$theme2 = _props$theme2.breakpoints) == null ? void 0 : _props$theme2.unit) !== "px") {
        return {
          maxWidth: `${breakpoint}${props.theme.breakpoints.unit}`
        };
      }
      return {
        maxWidth: breakpoint
      };
    };
    return handleBreakpoints(props, props.maxWidth, styleFromPropValue);
  }
  return null;
};
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$1({
  prop: "minWidth",
  transform: sizingTransform
});
const height = style$1({
  prop: "height",
  transform: sizingTransform
});
const maxHeight = style$1({
  prop: "maxHeight",
  transform: sizingTransform
});
const minHeight = style$1({
  prop: "minHeight",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "width",
  transform: sizingTransform
});
style$1({
  prop: "size",
  cssProperty: "height",
  transform: sizingTransform
});
const boxSizing = style$1({
  prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
  // borders
  border: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderTop: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderRight: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderBottom: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderLeft: {
    themeKey: "borders",
    transform: borderTransform
  },
  borderColor: {
    themeKey: "palette"
  },
  borderTopColor: {
    themeKey: "palette"
  },
  borderRightColor: {
    themeKey: "palette"
  },
  borderBottomColor: {
    themeKey: "palette"
  },
  borderLeftColor: {
    themeKey: "palette"
  },
  borderRadius: {
    themeKey: "shape.borderRadius",
    style: borderRadius
  },
  // palette
  color: {
    themeKey: "palette",
    transform: paletteTransform
  },
  bgcolor: {
    themeKey: "palette",
    cssProperty: "backgroundColor",
    transform: paletteTransform
  },
  backgroundColor: {
    themeKey: "palette",
    transform: paletteTransform
  },
  // spacing
  p: {
    style: padding
  },
  pt: {
    style: padding
  },
  pr: {
    style: padding
  },
  pb: {
    style: padding
  },
  pl: {
    style: padding
  },
  px: {
    style: padding
  },
  py: {
    style: padding
  },
  padding: {
    style: padding
  },
  paddingTop: {
    style: padding
  },
  paddingRight: {
    style: padding
  },
  paddingBottom: {
    style: padding
  },
  paddingLeft: {
    style: padding
  },
  paddingX: {
    style: padding
  },
  paddingY: {
    style: padding
  },
  paddingInline: {
    style: padding
  },
  paddingInlineStart: {
    style: padding
  },
  paddingInlineEnd: {
    style: padding
  },
  paddingBlock: {
    style: padding
  },
  paddingBlockStart: {
    style: padding
  },
  paddingBlockEnd: {
    style: padding
  },
  m: {
    style: margin
  },
  mt: {
    style: margin
  },
  mr: {
    style: margin
  },
  mb: {
    style: margin
  },
  ml: {
    style: margin
  },
  mx: {
    style: margin
  },
  my: {
    style: margin
  },
  margin: {
    style: margin
  },
  marginTop: {
    style: margin
  },
  marginRight: {
    style: margin
  },
  marginBottom: {
    style: margin
  },
  marginLeft: {
    style: margin
  },
  marginX: {
    style: margin
  },
  marginY: {
    style: margin
  },
  marginInline: {
    style: margin
  },
  marginInlineStart: {
    style: margin
  },
  marginInlineEnd: {
    style: margin
  },
  marginBlock: {
    style: margin
  },
  marginBlockStart: {
    style: margin
  },
  marginBlockEnd: {
    style: margin
  },
  // display
  displayPrint: {
    cssProperty: false,
    transform: (value) => ({
      "@media print": {
        display: value
      }
    })
  },
  display: {},
  overflow: {},
  textOverflow: {},
  visibility: {},
  whiteSpace: {},
  // flexbox
  flexBasis: {},
  flexDirection: {},
  flexWrap: {},
  justifyContent: {},
  alignItems: {},
  alignContent: {},
  order: {},
  flex: {},
  flexGrow: {},
  flexShrink: {},
  alignSelf: {},
  justifyItems: {},
  justifySelf: {},
  // grid
  gap: {
    style: gap
  },
  rowGap: {
    style: rowGap
  },
  columnGap: {
    style: columnGap
  },
  gridColumn: {},
  gridRow: {},
  gridAutoFlow: {},
  gridAutoColumns: {},
  gridAutoRows: {},
  gridTemplateColumns: {},
  gridTemplateRows: {},
  gridTemplateAreas: {},
  gridArea: {},
  // positions
  position: {},
  zIndex: {
    themeKey: "zIndex"
  },
  top: {},
  right: {},
  bottom: {},
  left: {},
  // shadows
  boxShadow: {
    themeKey: "shadows"
  },
  // sizing
  width: {
    transform: sizingTransform
  },
  maxWidth: {
    style: maxWidth
  },
  minWidth: {
    transform: sizingTransform
  },
  height: {
    transform: sizingTransform
  },
  maxHeight: {
    transform: sizingTransform
  },
  minHeight: {
    transform: sizingTransform
  },
  boxSizing: {},
  // typography
  fontFamily: {
    themeKey: "typography"
  },
  fontSize: {
    themeKey: "typography"
  },
  fontStyle: {
    themeKey: "typography"
  },
  fontWeight: {
    themeKey: "typography"
  },
  letterSpacing: {},
  textTransform: {},
  lineHeight: {},
  textAlign: {},
  typography: {
    cssProperty: false,
    themeKey: "typography"
  }
};
const defaultSxConfig$1 = defaultSxConfig;
function objectsHaveSameKeys(...objects) {
  const allKeys = objects.reduce((keys, object) => keys.concat(Object.keys(object)), []);
  const union = new Set(allKeys);
  return objects.every((object) => union.size === Object.keys(object).length);
}
function callIfFn(maybeFn, arg) {
  return typeof maybeFn === "function" ? maybeFn(arg) : maybeFn;
}
function unstable_createStyleFunctionSx() {
  function getThemeValue(prop, val, theme, config2) {
    const props = {
      [prop]: val,
      theme
    };
    const options = config2[prop];
    if (!options) {
      return {
        [prop]: val
      };
    }
    const {
      cssProperty = prop,
      themeKey,
      transform,
      style: style2
    } = options;
    if (val == null) {
      return null;
    }
    if (themeKey === "typography" && val === "inherit") {
      return {
        [prop]: val
      };
    }
    const themeMapping = getPath(theme, themeKey) || {};
    if (style2) {
      return style2(props);
    }
    const styleFromPropValue = (propValueFinal) => {
      let value = getStyleValue$1(themeMapping, transform, propValueFinal);
      if (propValueFinal === value && typeof propValueFinal === "string") {
        value = getStyleValue$1(themeMapping, transform, `${prop}${propValueFinal === "default" ? "" : capitalize(propValueFinal)}`, propValueFinal);
      }
      if (cssProperty === false) {
        return value;
      }
      return {
        [cssProperty]: value
      };
    };
    return handleBreakpoints(props, val, styleFromPropValue);
  }
  function styleFunctionSx2(props) {
    var _theme$unstable_sxCon;
    const {
      sx,
      theme = {}
    } = props || {};
    if (!sx) {
      return null;
    }
    const config2 = (_theme$unstable_sxCon = theme.unstable_sxConfig) != null ? _theme$unstable_sxCon : defaultSxConfig$1;
    function traverse(sxInput) {
      let sxObject = sxInput;
      if (typeof sxInput === "function") {
        sxObject = sxInput(theme);
      } else if (typeof sxInput !== "object") {
        return sxInput;
      }
      if (!sxObject) {
        return null;
      }
      const emptyBreakpoints = createEmptyBreakpointObject(theme.breakpoints);
      const breakpointsKeys = Object.keys(emptyBreakpoints);
      let css2 = emptyBreakpoints;
      Object.keys(sxObject).forEach((styleKey) => {
        const value = callIfFn(sxObject[styleKey], theme);
        if (value !== null && value !== void 0) {
          if (typeof value === "object") {
            if (config2[styleKey]) {
              css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
            } else {
              const breakpointsValues = handleBreakpoints({
                theme
              }, value, (x2) => ({
                [styleKey]: x2
              }));
              if (objectsHaveSameKeys(breakpointsValues, value)) {
                css2[styleKey] = styleFunctionSx2({
                  sx: value,
                  theme
                });
              } else {
                css2 = merge$1(css2, breakpointsValues);
              }
            }
          } else {
            css2 = merge$1(css2, getThemeValue(styleKey, value, theme, config2));
          }
        }
      });
      return removeUnusedBreakpoints(breakpointsKeys, css2);
    }
    return Array.isArray(sx) ? sx.map(traverse) : traverse(sx);
  }
  return styleFunctionSx2;
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
const styleFunctionSx$1 = styleFunctionSx;
const _excluded$x = ["breakpoints", "palette", "spacing", "shape"];
function createTheme$1(options = {}, ...args) {
  const {
    breakpoints: breakpointsInput = {},
    palette: paletteInput = {},
    spacing: spacingInput,
    shape: shapeInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$x);
  const breakpoints2 = createBreakpoints(breakpointsInput);
  const spacing = createSpacing(spacingInput);
  let muiTheme = deepmerge({
    breakpoints: breakpoints2,
    direction: "ltr",
    components: {},
    // Inject component definitions.
    palette: _extends$1({
      mode: "light"
    }, paletteInput),
    spacing,
    shape: _extends$1({}, shape$1, shapeInput)
  }, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
function isObjectEmpty(obj) {
  return Object.keys(obj).length === 0;
}
function useTheme$2(defaultTheme2 = null) {
  const contextTheme = reactExports.useContext(ThemeContext);
  return !contextTheme || isObjectEmpty(contextTheme) ? defaultTheme2 : contextTheme;
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$1(defaultTheme2 = systemDefaultTheme$1) {
  return useTheme$2(defaultTheme2);
}
function GlobalStyles$1({
  styles: styles2,
  themeId,
  defaultTheme: defaultTheme2 = {}
}) {
  const upperTheme = useTheme$1(defaultTheme2);
  const globalStyles = typeof styles2 === "function" ? styles2(themeId ? upperTheme[themeId] || upperTheme : upperTheme) : styles2;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$2, {
    styles: globalStyles
  });
}
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2))
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t2 in e2)
        e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const _excluded$w = ["variant"];
function isEmpty$3(string) {
  return string.length === 0;
}
function propsToClassKey(props) {
  const {
    variant
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$w);
  let classKey = variant || "";
  Object.keys(other).sort().forEach((key) => {
    if (key === "color") {
      classKey += isEmpty$3(classKey) ? props[key] : capitalize(props[key]);
    } else {
      classKey += `${isEmpty$3(classKey) ? key : capitalize(key)}${capitalize(props[key].toString())}`;
    }
  });
  return classKey;
}
const _excluded$v = ["name", "slot", "skipVariantsResolver", "skipSx", "overridesResolver"];
function isEmpty$2(obj) {
  return Object.keys(obj).length === 0;
}
function isStringTag(tag) {
  return typeof tag === "string" && // 96 is one less than the char code
  // for "a" so this is checking that
  // it's a lowercase character
  tag.charCodeAt(0) > 96;
}
const getStyleOverrides = (name, theme) => {
  if (theme.components && theme.components[name] && theme.components[name].styleOverrides) {
    return theme.components[name].styleOverrides;
  }
  return null;
};
const transformVariants = (variants) => {
  const variantsStyles = {};
  if (variants) {
    variants.forEach((definition) => {
      const key = propsToClassKey(definition.props);
      variantsStyles[key] = definition.style;
    });
  }
  return variantsStyles;
};
const getVariantStyles = (name, theme) => {
  let variants = [];
  if (theme && theme.components && theme.components[name] && theme.components[name].variants) {
    variants = theme.components[name].variants;
  }
  return transformVariants(variants);
};
const variantsResolver = (props, styles2, variants) => {
  const {
    ownerState = {}
  } = props;
  const variantsStyles = [];
  if (variants) {
    variants.forEach((variant) => {
      let isMatch = true;
      Object.keys(variant.props).forEach((key) => {
        if (ownerState[key] !== variant.props[key] && props[key] !== variant.props[key]) {
          isMatch = false;
        }
      });
      if (isMatch) {
        variantsStyles.push(styles2[propsToClassKey(variant.props)]);
      }
    });
  }
  return variantsStyles;
};
const themeVariantsResolver = (props, styles2, theme, name) => {
  var _theme$components;
  const themeVariants = theme == null || (_theme$components = theme.components) == null || (_theme$components = _theme$components[name]) == null ? void 0 : _theme$components.variants;
  return variantsResolver(props, styles2, themeVariants);
};
function shouldForwardProp(prop) {
  return prop !== "ownerState" && prop !== "theme" && prop !== "sx" && prop !== "as";
}
const systemDefaultTheme = createTheme$1();
const lowercaseFirstLetter = (string) => {
  if (!string) {
    return string;
  }
  return string.charAt(0).toLowerCase() + string.slice(1);
};
function resolveTheme({
  defaultTheme: defaultTheme2,
  theme,
  themeId
}) {
  return isEmpty$2(theme) ? defaultTheme2 : theme[themeId] || theme;
}
function defaultOverridesResolver(slot) {
  if (!slot) {
    return null;
  }
  return (props, styles2) => styles2[slot];
}
const muiStyledFunctionResolver = ({
  styledArg,
  props,
  defaultTheme: defaultTheme2,
  themeId
}) => {
  const resolvedStyles = styledArg(_extends$1({}, props, {
    theme: resolveTheme(_extends$1({}, props, {
      defaultTheme: defaultTheme2,
      themeId
    }))
  }));
  let optionalVariants;
  if (resolvedStyles && resolvedStyles.variants) {
    optionalVariants = resolvedStyles.variants;
    delete resolvedStyles.variants;
  }
  if (optionalVariants) {
    const variantsStyles = variantsResolver(props, transformVariants(optionalVariants), optionalVariants);
    return [resolvedStyles, ...variantsStyles];
  }
  return resolvedStyles;
};
function createStyled2(input = {}) {
  const {
    themeId,
    defaultTheme: defaultTheme2 = systemDefaultTheme,
    rootShouldForwardProp: rootShouldForwardProp2 = shouldForwardProp,
    slotShouldForwardProp: slotShouldForwardProp2 = shouldForwardProp
  } = input;
  const systemSx = (props) => {
    return styleFunctionSx$1(_extends$1({}, props, {
      theme: resolveTheme(_extends$1({}, props, {
        defaultTheme: defaultTheme2,
        themeId
      }))
    }));
  };
  systemSx.__mui_systemSx = true;
  return (tag, inputOptions = {}) => {
    internal_processStyles(tag, (styles2) => styles2.filter((style2) => !(style2 != null && style2.__mui_systemSx)));
    const {
      name: componentName,
      slot: componentSlot,
      skipVariantsResolver: inputSkipVariantsResolver,
      skipSx: inputSkipSx,
      // TODO v6: remove `lowercaseFirstLetter()` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      overridesResolver: overridesResolver2 = defaultOverridesResolver(lowercaseFirstLetter(componentSlot))
    } = inputOptions, options = _objectWithoutPropertiesLoose(inputOptions, _excluded$v);
    const skipVariantsResolver = inputSkipVariantsResolver !== void 0 ? inputSkipVariantsResolver : (
      // TODO v6: remove `Root` in the next major release
      // For more details: https://github.com/mui/material-ui/pull/37908
      componentSlot && componentSlot !== "Root" && componentSlot !== "root" || false
    );
    const skipSx = inputSkipSx || false;
    let label;
    let shouldForwardPropOption = shouldForwardProp;
    if (componentSlot === "Root" || componentSlot === "root") {
      shouldForwardPropOption = rootShouldForwardProp2;
    } else if (componentSlot) {
      shouldForwardPropOption = slotShouldForwardProp2;
    } else if (isStringTag(tag)) {
      shouldForwardPropOption = void 0;
    }
    const defaultStyledResolver = styled$2(tag, _extends$1({
      shouldForwardProp: shouldForwardPropOption,
      label
    }, options));
    const muiStyledResolver = (styleArg, ...expressions) => {
      const expressionsWithDefaultTheme = expressions ? expressions.map((stylesArg) => {
        if (typeof stylesArg === "function" && stylesArg.__emotion_real !== stylesArg) {
          return (props) => muiStyledFunctionResolver({
            styledArg: stylesArg,
            props,
            defaultTheme: defaultTheme2,
            themeId
          });
        }
        if (isPlainObject$1(stylesArg)) {
          let transformedStylesArg = stylesArg;
          let styledArgVariants;
          if (stylesArg && stylesArg.variants) {
            styledArgVariants = stylesArg.variants;
            delete transformedStylesArg.variants;
            transformedStylesArg = (props) => {
              let result = stylesArg;
              const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
              variantStyles.forEach((variantStyle) => {
                result = deepmerge(result, variantStyle);
              });
              return result;
            };
          }
          return transformedStylesArg;
        }
        return stylesArg;
      }) : [];
      let transformedStyleArg = styleArg;
      if (isPlainObject$1(styleArg)) {
        let styledArgVariants;
        if (styleArg && styleArg.variants) {
          styledArgVariants = styleArg.variants;
          delete transformedStyleArg.variants;
          transformedStyleArg = (props) => {
            let result = styleArg;
            const variantStyles = variantsResolver(props, transformVariants(styledArgVariants), styledArgVariants);
            variantStyles.forEach((variantStyle) => {
              result = deepmerge(result, variantStyle);
            });
            return result;
          };
        }
      } else if (typeof styleArg === "function" && // On the server Emotion doesn't use React.forwardRef for creating components, so the created
      // component stays as a function. This condition makes sure that we do not interpolate functions
      // which are basically components used as a selectors.
      styleArg.__emotion_real !== styleArg) {
        transformedStyleArg = (props) => muiStyledFunctionResolver({
          styledArg: styleArg,
          props,
          defaultTheme: defaultTheme2,
          themeId
        });
      }
      if (componentName && overridesResolver2) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = resolveTheme(_extends$1({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          const styleOverrides = getStyleOverrides(componentName, theme);
          if (styleOverrides) {
            const resolvedStyleOverrides = {};
            Object.entries(styleOverrides).forEach(([slotKey, slotStyle]) => {
              resolvedStyleOverrides[slotKey] = typeof slotStyle === "function" ? slotStyle(_extends$1({}, props, {
                theme
              })) : slotStyle;
            });
            return overridesResolver2(props, resolvedStyleOverrides);
          }
          return null;
        });
      }
      if (componentName && !skipVariantsResolver) {
        expressionsWithDefaultTheme.push((props) => {
          const theme = resolveTheme(_extends$1({}, props, {
            defaultTheme: defaultTheme2,
            themeId
          }));
          return themeVariantsResolver(props, getVariantStyles(componentName, theme), theme, componentName);
        });
      }
      if (!skipSx) {
        expressionsWithDefaultTheme.push(systemSx);
      }
      const numOfCustomFnsApplied = expressionsWithDefaultTheme.length - expressions.length;
      if (Array.isArray(styleArg) && numOfCustomFnsApplied > 0) {
        const placeholders = new Array(numOfCustomFnsApplied).fill("");
        transformedStyleArg = [...styleArg, ...placeholders];
        transformedStyleArg.raw = [...styleArg.raw, ...placeholders];
      }
      const Component = defaultStyledResolver(transformedStyleArg, ...expressionsWithDefaultTheme);
      if (tag.muiName) {
        Component.muiName = tag.muiName;
      }
      return Component;
    };
    if (defaultStyledResolver.withConfig) {
      muiStyledResolver.withConfig = defaultStyledResolver.withConfig;
    }
    return muiStyledResolver;
  };
}
function getThemeProps(params) {
  const {
    theme,
    name,
    props
  } = params;
  if (!theme || !theme.components || !theme.components[name] || !theme.components[name].defaultProps) {
    return props;
  }
  return resolveProps(theme.components[name].defaultProps, props);
}
function useThemeProps$1({
  props,
  name,
  defaultTheme: defaultTheme2,
  themeId
}) {
  let theme = useTheme$1(defaultTheme2);
  if (themeId) {
    theme = theme[themeId] || theme;
  }
  const mergedProps = getThemeProps({
    theme,
    name,
    props
  });
  return mergedProps;
}
function clamp(value, min = 0, max = 1) {
  return Math.min(Math.max(min, value), max);
}
function hexToRgb(color2) {
  color2 = color2.slice(1);
  const re2 = new RegExp(`.{1,${color2.length >= 6 ? 2 : 1}}`, "g");
  let colors = color2.match(re2);
  if (colors && colors[0].length === 1) {
    colors = colors.map((n2) => n2 + n2);
  }
  return colors ? `rgb${colors.length === 4 ? "a" : ""}(${colors.map((n2, index) => {
    return index < 3 ? parseInt(n2, 16) : Math.round(parseInt(n2, 16) / 255 * 1e3) / 1e3;
  }).join(", ")})` : "";
}
function decomposeColor(color2) {
  if (color2.type) {
    return color2;
  }
  if (color2.charAt(0) === "#") {
    return decomposeColor(hexToRgb(color2));
  }
  const marker = color2.indexOf("(");
  const type = color2.substring(0, marker);
  if (["rgb", "rgba", "hsl", "hsla", "color"].indexOf(type) === -1) {
    throw new Error(formatMuiErrorMessage(9, color2));
  }
  let values2 = color2.substring(marker + 1, color2.length - 1);
  let colorSpace;
  if (type === "color") {
    values2 = values2.split(" ");
    colorSpace = values2.shift();
    if (values2.length === 4 && values2[3].charAt(0) === "/") {
      values2[3] = values2[3].slice(1);
    }
    if (["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].indexOf(colorSpace) === -1) {
      throw new Error(formatMuiErrorMessage(10, colorSpace));
    }
  } else {
    values2 = values2.split(",");
  }
  values2 = values2.map((value) => parseFloat(value));
  return {
    type,
    values: values2,
    colorSpace
  };
}
function recomposeColor(color2) {
  const {
    type,
    colorSpace
  } = color2;
  let {
    values: values2
  } = color2;
  if (type.indexOf("rgb") !== -1) {
    values2 = values2.map((n2, i2) => i2 < 3 ? parseInt(n2, 10) : n2);
  } else if (type.indexOf("hsl") !== -1) {
    values2[1] = `${values2[1]}%`;
    values2[2] = `${values2[2]}%`;
  }
  if (type.indexOf("color") !== -1) {
    values2 = `${colorSpace} ${values2.join(" ")}`;
  } else {
    values2 = `${values2.join(", ")}`;
  }
  return `${type}(${values2})`;
}
function hslToRgb(color2) {
  color2 = decomposeColor(color2);
  const {
    values: values2
  } = color2;
  const h2 = values2[0];
  const s2 = values2[1] / 100;
  const l2 = values2[2] / 100;
  const a2 = s2 * Math.min(l2, 1 - l2);
  const f2 = (n2, k2 = (n2 + h2 / 30) % 12) => l2 - a2 * Math.max(Math.min(k2 - 3, 9 - k2, 1), -1);
  let type = "rgb";
  const rgb = [Math.round(f2(0) * 255), Math.round(f2(8) * 255), Math.round(f2(4) * 255)];
  if (color2.type === "hsla") {
    type += "a";
    rgb.push(values2[3]);
  }
  return recomposeColor({
    type,
    values: rgb
  });
}
function getLuminance(color2) {
  color2 = decomposeColor(color2);
  let rgb = color2.type === "hsl" || color2.type === "hsla" ? decomposeColor(hslToRgb(color2)).values : color2.values;
  rgb = rgb.map((val) => {
    if (color2.type !== "color") {
      val /= 255;
    }
    return val <= 0.03928 ? val / 12.92 : ((val + 0.055) / 1.055) ** 2.4;
  });
  return Number((0.2126 * rgb[0] + 0.7152 * rgb[1] + 0.0722 * rgb[2]).toFixed(3));
}
function getContrastRatio(foreground, background) {
  const lumA = getLuminance(foreground);
  const lumB = getLuminance(background);
  return (Math.max(lumA, lumB) + 0.05) / (Math.min(lumA, lumB) + 0.05);
}
function alpha(color2, value) {
  color2 = decomposeColor(color2);
  value = clamp(value);
  if (color2.type === "rgb" || color2.type === "hsl") {
    color2.type += "a";
  }
  if (color2.type === "color") {
    color2.values[3] = `/${value}`;
  } else {
    color2.values[3] = value;
  }
  return recomposeColor(color2);
}
function darken(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clamp(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] *= 1 - coefficient;
  } else if (color2.type.indexOf("rgb") !== -1 || color2.type.indexOf("color") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] *= 1 - coefficient;
    }
  }
  return recomposeColor(color2);
}
function lighten(color2, coefficient) {
  color2 = decomposeColor(color2);
  coefficient = clamp(coefficient);
  if (color2.type.indexOf("hsl") !== -1) {
    color2.values[2] += (100 - color2.values[2]) * coefficient;
  } else if (color2.type.indexOf("rgb") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (255 - color2.values[i2]) * coefficient;
    }
  } else if (color2.type.indexOf("color") !== -1) {
    for (let i2 = 0; i2 < 3; i2 += 1) {
      color2.values[i2] += (1 - color2.values[i2]) * coefficient;
    }
  }
  return recomposeColor(color2);
}
function createMixins(breakpoints2, mixins) {
  return _extends$1({
    toolbar: {
      minHeight: 56,
      [breakpoints2.up("xs")]: {
        "@media (orientation: landscape)": {
          minHeight: 48
        }
      },
      [breakpoints2.up("sm")]: {
        minHeight: 64
      }
    }
  }, mixins);
}
const _excluded$u = ["mode", "contrastThreshold", "tonalOffset"];
const light = {
  // The colors used to style the text.
  text: {
    // The most important text.
    primary: "rgba(0, 0, 0, 0.87)",
    // Secondary text.
    secondary: "rgba(0, 0, 0, 0.6)",
    // Disabled text have even lower visual prominence.
    disabled: "rgba(0, 0, 0, 0.38)"
  },
  // The color used to divide different elements.
  divider: "rgba(0, 0, 0, 0.12)",
  // The background colors used to style the surfaces.
  // Consistency between these values is important.
  background: {
    paper: common$1.white,
    default: common$1.white
  },
  // The colors used to style the action elements.
  action: {
    // The color of an active action like an icon button.
    active: "rgba(0, 0, 0, 0.54)",
    // The color of an hovered action.
    hover: "rgba(0, 0, 0, 0.04)",
    hoverOpacity: 0.04,
    // The color of a selected action.
    selected: "rgba(0, 0, 0, 0.08)",
    selectedOpacity: 0.08,
    // The color of a disabled action.
    disabled: "rgba(0, 0, 0, 0.26)",
    // The background color of a disabled action.
    disabledBackground: "rgba(0, 0, 0, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(0, 0, 0, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.12
  }
};
const dark = {
  text: {
    primary: common$1.white,
    secondary: "rgba(255, 255, 255, 0.7)",
    disabled: "rgba(255, 255, 255, 0.5)",
    icon: "rgba(255, 255, 255, 0.5)"
  },
  divider: "rgba(255, 255, 255, 0.12)",
  background: {
    paper: "#121212",
    default: "#121212"
  },
  action: {
    active: common$1.white,
    hover: "rgba(255, 255, 255, 0.08)",
    hoverOpacity: 0.08,
    selected: "rgba(255, 255, 255, 0.16)",
    selectedOpacity: 0.16,
    disabled: "rgba(255, 255, 255, 0.3)",
    disabledBackground: "rgba(255, 255, 255, 0.12)",
    disabledOpacity: 0.38,
    focus: "rgba(255, 255, 255, 0.12)",
    focusOpacity: 0.12,
    activatedOpacity: 0.24
  }
};
function addLightOrDark(intent, direction, shade, tonalOffset) {
  const tonalOffsetLight = tonalOffset.light || tonalOffset;
  const tonalOffsetDark = tonalOffset.dark || tonalOffset * 1.5;
  if (!intent[direction]) {
    if (intent.hasOwnProperty(shade)) {
      intent[direction] = intent[shade];
    } else if (direction === "light") {
      intent.light = lighten(intent.main, tonalOffsetLight);
    } else if (direction === "dark") {
      intent.dark = darken(intent.main, tonalOffsetDark);
    }
  }
}
function getDefaultPrimary(mode = "light") {
  if (mode === "dark") {
    return {
      main: blue$1[200],
      light: blue$1[50],
      dark: blue$1[400]
    };
  }
  return {
    main: blue$1[700],
    light: blue$1[400],
    dark: blue$1[800]
  };
}
function getDefaultSecondary(mode = "light") {
  if (mode === "dark") {
    return {
      main: purple$1[200],
      light: purple$1[50],
      dark: purple$1[400]
    };
  }
  return {
    main: purple$1[500],
    light: purple$1[300],
    dark: purple$1[700]
  };
}
function getDefaultError(mode = "light") {
  if (mode === "dark") {
    return {
      main: red$1[500],
      light: red$1[300],
      dark: red$1[700]
    };
  }
  return {
    main: red$1[700],
    light: red$1[400],
    dark: red$1[800]
  };
}
function getDefaultInfo(mode = "light") {
  if (mode === "dark") {
    return {
      main: lightBlue$1[400],
      light: lightBlue$1[300],
      dark: lightBlue$1[700]
    };
  }
  return {
    main: lightBlue$1[700],
    light: lightBlue$1[500],
    dark: lightBlue$1[900]
  };
}
function getDefaultSuccess(mode = "light") {
  if (mode === "dark") {
    return {
      main: green$1[400],
      light: green$1[300],
      dark: green$1[700]
    };
  }
  return {
    main: green$1[800],
    light: green$1[500],
    dark: green$1[900]
  };
}
function getDefaultWarning(mode = "light") {
  if (mode === "dark") {
    return {
      main: orange$1[400],
      light: orange$1[300],
      dark: orange$1[700]
    };
  }
  return {
    main: "#ed6c02",
    // closest to orange[800] that pass 3:1.
    light: orange$1[500],
    dark: orange$1[900]
  };
}
function createPalette(palette) {
  const {
    mode = "light",
    contrastThreshold = 3,
    tonalOffset = 0.2
  } = palette, other = _objectWithoutPropertiesLoose(palette, _excluded$u);
  const primary = palette.primary || getDefaultPrimary(mode);
  const secondary = palette.secondary || getDefaultSecondary(mode);
  const error = palette.error || getDefaultError(mode);
  const info = palette.info || getDefaultInfo(mode);
  const success = palette.success || getDefaultSuccess(mode);
  const warning2 = palette.warning || getDefaultWarning(mode);
  function getContrastText(background) {
    const contrastText = getContrastRatio(background, dark.text.primary) >= contrastThreshold ? dark.text.primary : light.text.primary;
    return contrastText;
  }
  const augmentColor = ({
    color: color2,
    name,
    mainShade = 500,
    lightShade = 300,
    darkShade = 700
  }) => {
    color2 = _extends$1({}, color2);
    if (!color2.main && color2[mainShade]) {
      color2.main = color2[mainShade];
    }
    if (!color2.hasOwnProperty("main")) {
      throw new Error(formatMuiErrorMessage(11, name ? ` (${name})` : "", mainShade));
    }
    if (typeof color2.main !== "string") {
      throw new Error(formatMuiErrorMessage(12, name ? ` (${name})` : "", JSON.stringify(color2.main)));
    }
    addLightOrDark(color2, "light", lightShade, tonalOffset);
    addLightOrDark(color2, "dark", darkShade, tonalOffset);
    if (!color2.contrastText) {
      color2.contrastText = getContrastText(color2.main);
    }
    return color2;
  };
  const modes = {
    dark,
    light
  };
  const paletteOutput = deepmerge(_extends$1({
    // A collection of common colors.
    common: _extends$1({}, common$1),
    // prevent mutable object.
    // The palette mode, can be light or dark.
    mode,
    // The colors used to represent primary interface elements for a user.
    primary: augmentColor({
      color: primary,
      name: "primary"
    }),
    // The colors used to represent secondary interface elements for a user.
    secondary: augmentColor({
      color: secondary,
      name: "secondary",
      mainShade: "A400",
      lightShade: "A200",
      darkShade: "A700"
    }),
    // The colors used to represent interface elements that the user should be made aware of.
    error: augmentColor({
      color: error,
      name: "error"
    }),
    // The colors used to represent potentially dangerous actions or important messages.
    warning: augmentColor({
      color: warning2,
      name: "warning"
    }),
    // The colors used to present information to the user that is neutral and not necessarily important.
    info: augmentColor({
      color: info,
      name: "info"
    }),
    // The colors used to indicate the successful completion of an action that user triggered.
    success: augmentColor({
      color: success,
      name: "success"
    }),
    // The grey colors.
    grey: grey$1,
    // Used by `getContrastText()` to maximize the contrast between
    // the background and the text.
    contrastThreshold,
    // Takes a background color and returns the text color that maximizes the contrast.
    getContrastText,
    // Generate a rich color object.
    augmentColor,
    // Used by the functions below to shift a color's luminance by approximately
    // two indexes within its tonal palette.
    // E.g., shift from Red 500 to Red 300 or Red 700.
    tonalOffset
  }, modes[mode]), other);
  return paletteOutput;
}
const _excluded$t = ["fontFamily", "fontSize", "fontWeightLight", "fontWeightRegular", "fontWeightMedium", "fontWeightBold", "htmlFontSize", "allVariants", "pxToRem"];
function round(value) {
  return Math.round(value * 1e5) / 1e5;
}
const caseAllCaps = {
  textTransform: "uppercase"
};
const defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(palette, typography2) {
  const _ref = typeof typography2 === "function" ? typography2(palette) : typography2, {
    fontFamily = defaultFontFamily,
    // The default font size of the Material Specification.
    fontSize = 14,
    // px
    fontWeightLight = 300,
    fontWeightRegular = 400,
    fontWeightMedium = 500,
    fontWeightBold = 700,
    // Tell MUI what's the font-size on the html element.
    // 16px is the default font-size used by browsers.
    htmlFontSize = 16,
    // Apply the CSS properties to all the variants.
    allVariants,
    pxToRem: pxToRem2
  } = _ref, other = _objectWithoutPropertiesLoose(_ref, _excluded$t);
  const coef = fontSize / 14;
  const pxToRem = pxToRem2 || ((size) => `${size / htmlFontSize * coef}rem`);
  const buildVariant = (fontWeight, size, lineHeight, letterSpacing, casing) => _extends$1({
    fontFamily,
    fontWeight,
    fontSize: pxToRem(size),
    // Unitless following https://meyerweb.com/eric/thoughts/2006/02/08/unitless-line-heights/
    lineHeight
  }, fontFamily === defaultFontFamily ? {
    letterSpacing: `${round(letterSpacing / size)}em`
  } : {}, casing, allVariants);
  const variants = {
    h1: buildVariant(fontWeightLight, 96, 1.167, -1.5),
    h2: buildVariant(fontWeightLight, 60, 1.2, -0.5),
    h3: buildVariant(fontWeightRegular, 48, 1.167, 0),
    h4: buildVariant(fontWeightRegular, 34, 1.235, 0.25),
    h5: buildVariant(fontWeightRegular, 24, 1.334, 0),
    h6: buildVariant(fontWeightMedium, 20, 1.6, 0.15),
    subtitle1: buildVariant(fontWeightRegular, 16, 1.75, 0.15),
    subtitle2: buildVariant(fontWeightMedium, 14, 1.57, 0.1),
    body1: buildVariant(fontWeightRegular, 16, 1.5, 0.15),
    body2: buildVariant(fontWeightRegular, 14, 1.43, 0.15),
    button: buildVariant(fontWeightMedium, 14, 1.75, 0.4, caseAllCaps),
    caption: buildVariant(fontWeightRegular, 12, 1.66, 0.4),
    overline: buildVariant(fontWeightRegular, 12, 2.66, 1, caseAllCaps),
    // TODO v6: Remove handling of 'inherit' variant from the theme as it is already handled in Material UI's Typography component. Also, remember to remove the associated types.
    inherit: {
      fontFamily: "inherit",
      fontWeight: "inherit",
      fontSize: "inherit",
      lineHeight: "inherit",
      letterSpacing: "inherit"
    }
  };
  return deepmerge(_extends$1({
    htmlFontSize,
    pxToRem,
    fontFamily,
    fontSize,
    fontWeightLight,
    fontWeightRegular,
    fontWeightMedium,
    fontWeightBold
  }, variants), other, {
    clone: false
    // No need to clone deep
  });
}
const shadowKeyUmbraOpacity = 0.2;
const shadowKeyPenumbraOpacity = 0.14;
const shadowAmbientShadowOpacity = 0.12;
function createShadow(...px) {
  return [`${px[0]}px ${px[1]}px ${px[2]}px ${px[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${px[4]}px ${px[5]}px ${px[6]}px ${px[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${px[8]}px ${px[9]}px ${px[10]}px ${px[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",");
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)];
const shadows$1 = shadows;
const _excluded$s = ["duration", "easing", "delay"];
const easing = {
  // This is the most common easing curve.
  easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
  // Objects enter the screen at full velocity from off-screen and
  // slowly decelerate to a resting point.
  easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
  // Objects leave the screen at full velocity. They do not decelerate when off-screen.
  easeIn: "cubic-bezier(0.4, 0, 1, 1)",
  // The sharp curve is used by objects that may return to the screen at any time.
  sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
};
const duration = {
  shortest: 150,
  shorter: 200,
  short: 250,
  // most basic recommended timing
  standard: 300,
  // this is to be used in complex animations
  complex: 375,
  // recommended when something is entering screen
  enteringScreen: 225,
  // recommended when something is leaving screen
  leavingScreen: 195
};
function formatMs(milliseconds) {
  return `${Math.round(milliseconds)}ms`;
}
function getAutoHeightDuration(height2) {
  if (!height2) {
    return 0;
  }
  const constant = height2 / 36;
  return Math.round((4 + 15 * constant ** 0.25 + constant / 5) * 10);
}
function createTransitions(inputTransitions) {
  const mergedEasing = _extends$1({}, easing, inputTransitions.easing);
  const mergedDuration = _extends$1({}, duration, inputTransitions.duration);
  const create = (props = ["all"], options = {}) => {
    const {
      duration: durationOption = mergedDuration.standard,
      easing: easingOption = mergedEasing.easeInOut,
      delay = 0
    } = options;
    _objectWithoutPropertiesLoose(options, _excluded$s);
    return (Array.isArray(props) ? props : [props]).map((animatedProp) => `${animatedProp} ${typeof durationOption === "string" ? durationOption : formatMs(durationOption)} ${easingOption} ${typeof delay === "string" ? delay : formatMs(delay)}`).join(",");
  };
  return _extends$1({
    getAutoHeightDuration,
    create
  }, inputTransitions, {
    easing: mergedEasing,
    duration: mergedDuration
  });
}
const zIndex = {
  mobileStepper: 1e3,
  fab: 1050,
  speedDial: 1050,
  appBar: 1100,
  drawer: 1200,
  modal: 1300,
  snackbar: 1400,
  tooltip: 1500
};
const zIndex$1 = zIndex;
const _excluded$r = ["breakpoints", "mixins", "spacing", "palette", "transitions", "typography", "shape"];
function createTheme(options = {}, ...args) {
  const {
    mixins: mixinsInput = {},
    palette: paletteInput = {},
    transitions: transitionsInput = {},
    typography: typographyInput = {}
  } = options, other = _objectWithoutPropertiesLoose(options, _excluded$r);
  if (options.vars) {
    throw new Error(formatMuiErrorMessage(18));
  }
  const palette = createPalette(paletteInput);
  const systemTheme = createTheme$1(options);
  let muiTheme = deepmerge(systemTheme, {
    mixins: createMixins(systemTheme.breakpoints, mixinsInput),
    palette,
    // Don't use [...shadows] until you've verified its transpiled code is not invoking the iterator protocol.
    shadows: shadows$1.slice(),
    typography: createTypography(palette, typographyInput),
    transitions: createTransitions(transitionsInput),
    zIndex: _extends$1({}, zIndex$1)
  });
  muiTheme = deepmerge(muiTheme, other);
  muiTheme = args.reduce((acc, argument) => deepmerge(acc, argument), muiTheme);
  muiTheme.unstable_sxConfig = _extends$1({}, defaultSxConfig$1, other == null ? void 0 : other.unstable_sxConfig);
  muiTheme.unstable_sx = function sx(props) {
    return styleFunctionSx$1({
      sx: props,
      theme: this
    });
  };
  return muiTheme;
}
const defaultTheme = createTheme();
const defaultTheme$1 = defaultTheme;
function useTheme() {
  const theme = useTheme$1(defaultTheme$1);
  return theme[THEME_ID] || theme;
}
function useThemeProps({
  props,
  name
}) {
  return useThemeProps$1({
    props,
    name,
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  });
}
const rootShouldForwardProp = (prop) => shouldForwardProp(prop) && prop !== "classes";
const slotShouldForwardProp = shouldForwardProp;
const styled = createStyled2({
  themeId: THEME_ID,
  defaultTheme: defaultTheme$1,
  rootShouldForwardProp
});
const styled$1 = styled;
const getOverlayAlpha = (elevation) => {
  let alphaValue;
  if (elevation < 1) {
    alphaValue = 5.11916 * elevation ** 2;
  } else {
    alphaValue = 4.5 * Math.log(elevation + 1) + 2;
  }
  return (alphaValue / 100).toFixed(2);
};
const getOverlayAlpha$1 = getOverlayAlpha;
function getSvgIconUtilityClass(slot) {
  return generateUtilityClass("MuiSvgIcon", slot);
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const _excluded$q = ["children", "className", "color", "component", "fontSize", "htmlColor", "inheritViewBox", "titleAccess", "viewBox"];
const useUtilityClasses$j = (ownerState) => {
  const {
    color: color2,
    fontSize,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", color2 !== "inherit" && `color${capitalize(color2)}`, `fontSize${capitalize(fontSize)}`]
  };
  return composeClasses(slots, getSvgIconUtilityClass, classes2);
};
const SvgIconRoot = styled$1("svg", {
  name: "MuiSvgIcon",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.color !== "inherit" && styles2[`color${capitalize(ownerState.color)}`], styles2[`fontSize${capitalize(ownerState.fontSize)}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$transitions, _theme$transitions$cr, _theme$transitions2, _theme$typography, _theme$typography$pxT, _theme$typography2, _theme$typography2$px, _theme$typography3, _theme$typography3$px, _palette$ownerState$c, _palette, _palette2, _palette3;
  return {
    userSelect: "none",
    width: "1em",
    height: "1em",
    display: "inline-block",
    // the <svg> will define the property that has `currentColor`
    // e.g. heroicons uses fill="none" and stroke="currentColor"
    fill: ownerState.hasSvgAsChild ? void 0 : "currentColor",
    flexShrink: 0,
    transition: (_theme$transitions = theme.transitions) == null || (_theme$transitions$cr = _theme$transitions.create) == null ? void 0 : _theme$transitions$cr.call(_theme$transitions, "fill", {
      duration: (_theme$transitions2 = theme.transitions) == null || (_theme$transitions2 = _theme$transitions2.duration) == null ? void 0 : _theme$transitions2.shorter
    }),
    fontSize: {
      inherit: "inherit",
      small: ((_theme$typography = theme.typography) == null || (_theme$typography$pxT = _theme$typography.pxToRem) == null ? void 0 : _theme$typography$pxT.call(_theme$typography, 20)) || "1.25rem",
      medium: ((_theme$typography2 = theme.typography) == null || (_theme$typography2$px = _theme$typography2.pxToRem) == null ? void 0 : _theme$typography2$px.call(_theme$typography2, 24)) || "1.5rem",
      large: ((_theme$typography3 = theme.typography) == null || (_theme$typography3$px = _theme$typography3.pxToRem) == null ? void 0 : _theme$typography3$px.call(_theme$typography3, 35)) || "2.1875rem"
    }[ownerState.fontSize],
    // TODO v5 deprecate, v6 remove for sx
    color: (_palette$ownerState$c = (_palette = (theme.vars || theme).palette) == null || (_palette = _palette[ownerState.color]) == null ? void 0 : _palette.main) != null ? _palette$ownerState$c : {
      action: (_palette2 = (theme.vars || theme).palette) == null || (_palette2 = _palette2.action) == null ? void 0 : _palette2.active,
      disabled: (_palette3 = (theme.vars || theme).palette) == null || (_palette3 = _palette3.action) == null ? void 0 : _palette3.disabled,
      inherit: void 0
    }[ownerState.color]
  };
});
const SvgIcon = /* @__PURE__ */ reactExports.forwardRef(function SvgIcon2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiSvgIcon"
  });
  const {
    children,
    className,
    color: color2 = "inherit",
    component = "svg",
    fontSize = "medium",
    htmlColor,
    inheritViewBox = false,
    titleAccess,
    viewBox = "0 0 24 24"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$q);
  const hasSvgAsChild = /* @__PURE__ */ reactExports.isValidElement(children) && children.type === "svg";
  const ownerState = _extends$1({}, props, {
    color: color2,
    component,
    fontSize,
    instanceFontSize: inProps.fontSize,
    inheritViewBox,
    viewBox,
    hasSvgAsChild
  });
  const more = {};
  if (!inheritViewBox) {
    more.viewBox = viewBox;
  }
  const classes2 = useUtilityClasses$j(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(SvgIconRoot, _extends$1({
    as: component,
    className: clsx(classes2.root, className),
    focusable: "false",
    color: htmlColor,
    "aria-hidden": titleAccess ? void 0 : true,
    role: titleAccess ? "img" : void 0,
    ref
  }, more, other, hasSvgAsChild && children.props, {
    ownerState,
    children: [hasSvgAsChild ? children.props.children : children, titleAccess ? /* @__PURE__ */ jsxRuntimeExports.jsx("title", {
      children: titleAccess
    }) : null]
  }));
});
SvgIcon.muiName = "SvgIcon";
const SvgIcon$1 = SvgIcon;
function createSvgIcon(path, displayName) {
  function Component(props, ref) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SvgIcon$1, _extends$1({
      "data-testid": `${displayName}Icon`,
      ref
    }, props, {
      children: path
    }));
  }
  Component.muiName = SvgIcon$1.muiName;
  return /* @__PURE__ */ reactExports.memo(/* @__PURE__ */ reactExports.forwardRef(Component));
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
const config = {
  disabled: false
};
const TransitionGroupContext = React.createContext(null);
var forceReflow = function forceReflow2(node2) {
  return node2.scrollTop;
};
var UNMOUNTED = "unmounted";
var EXITED = "exited";
var ENTERING = "entering";
var ENTERED = "entered";
var EXITING = "exiting";
var Transition = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(Transition2, _React$Component);
  function Transition2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var parentGroup = context;
    var appear = parentGroup && !parentGroup.isMounting ? props.enter : props.appear;
    var initialStatus;
    _this.appearStatus = null;
    if (props.in) {
      if (appear) {
        initialStatus = EXITED;
        _this.appearStatus = ENTERING;
      } else {
        initialStatus = ENTERED;
      }
    } else {
      if (props.unmountOnExit || props.mountOnEnter) {
        initialStatus = UNMOUNTED;
      } else {
        initialStatus = EXITED;
      }
    }
    _this.state = {
      status: initialStatus
    };
    _this.nextCallback = null;
    return _this;
  }
  Transition2.getDerivedStateFromProps = function getDerivedStateFromProps(_ref, prevState) {
    var nextIn = _ref.in;
    if (nextIn && prevState.status === UNMOUNTED) {
      return {
        status: EXITED
      };
    }
    return null;
  };
  var _proto = Transition2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.updateStatus(true, this.appearStatus);
  };
  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var nextStatus = null;
    if (prevProps !== this.props) {
      var status = this.state.status;
      if (this.props.in) {
        if (status !== ENTERING && status !== ENTERED) {
          nextStatus = ENTERING;
        }
      } else {
        if (status === ENTERING || status === ENTERED) {
          nextStatus = EXITING;
        }
      }
    }
    this.updateStatus(false, nextStatus);
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.cancelNextCallback();
  };
  _proto.getTimeouts = function getTimeouts() {
    var timeout = this.props.timeout;
    var exit, enter, appear;
    exit = enter = appear = timeout;
    if (timeout != null && typeof timeout !== "number") {
      exit = timeout.exit;
      enter = timeout.enter;
      appear = timeout.appear !== void 0 ? timeout.appear : enter;
    }
    return {
      exit,
      enter,
      appear
    };
  };
  _proto.updateStatus = function updateStatus(mounting, nextStatus) {
    if (mounting === void 0) {
      mounting = false;
    }
    if (nextStatus !== null) {
      this.cancelNextCallback();
      if (nextStatus === ENTERING) {
        if (this.props.unmountOnExit || this.props.mountOnEnter) {
          var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
          if (node2)
            forceReflow(node2);
        }
        this.performEnter(mounting);
      } else {
        this.performExit();
      }
    } else if (this.props.unmountOnExit && this.state.status === EXITED) {
      this.setState({
        status: UNMOUNTED
      });
    }
  };
  _proto.performEnter = function performEnter(mounting) {
    var _this2 = this;
    var enter = this.props.enter;
    var appearing = this.context ? this.context.isMounting : mounting;
    var _ref2 = this.props.nodeRef ? [appearing] : [ReactDOM.findDOMNode(this), appearing], maybeNode = _ref2[0], maybeAppearing = _ref2[1];
    var timeouts = this.getTimeouts();
    var enterTimeout = appearing ? timeouts.appear : timeouts.enter;
    if (!mounting && !enter || config.disabled) {
      this.safeSetState({
        status: ENTERED
      }, function() {
        _this2.props.onEntered(maybeNode);
      });
      return;
    }
    this.props.onEnter(maybeNode, maybeAppearing);
    this.safeSetState({
      status: ENTERING
    }, function() {
      _this2.props.onEntering(maybeNode, maybeAppearing);
      _this2.onTransitionEnd(enterTimeout, function() {
        _this2.safeSetState({
          status: ENTERED
        }, function() {
          _this2.props.onEntered(maybeNode, maybeAppearing);
        });
      });
    });
  };
  _proto.performExit = function performExit() {
    var _this3 = this;
    var exit = this.props.exit;
    var timeouts = this.getTimeouts();
    var maybeNode = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
    if (!exit || config.disabled) {
      this.safeSetState({
        status: EXITED
      }, function() {
        _this3.props.onExited(maybeNode);
      });
      return;
    }
    this.props.onExit(maybeNode);
    this.safeSetState({
      status: EXITING
    }, function() {
      _this3.props.onExiting(maybeNode);
      _this3.onTransitionEnd(timeouts.exit, function() {
        _this3.safeSetState({
          status: EXITED
        }, function() {
          _this3.props.onExited(maybeNode);
        });
      });
    });
  };
  _proto.cancelNextCallback = function cancelNextCallback() {
    if (this.nextCallback !== null) {
      this.nextCallback.cancel();
      this.nextCallback = null;
    }
  };
  _proto.safeSetState = function safeSetState(nextState, callback) {
    callback = this.setNextCallback(callback);
    this.setState(nextState, callback);
  };
  _proto.setNextCallback = function setNextCallback(callback) {
    var _this4 = this;
    var active = true;
    this.nextCallback = function(event) {
      if (active) {
        active = false;
        _this4.nextCallback = null;
        callback(event);
      }
    };
    this.nextCallback.cancel = function() {
      active = false;
    };
    return this.nextCallback;
  };
  _proto.onTransitionEnd = function onTransitionEnd(timeout, handler) {
    this.setNextCallback(handler);
    var node2 = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this);
    var doesNotHaveTimeoutOrListener = timeout == null && !this.props.addEndListener;
    if (!node2 || doesNotHaveTimeoutOrListener) {
      setTimeout(this.nextCallback, 0);
      return;
    }
    if (this.props.addEndListener) {
      var _ref3 = this.props.nodeRef ? [this.nextCallback] : [node2, this.nextCallback], maybeNode = _ref3[0], maybeNextCallback = _ref3[1];
      this.props.addEndListener(maybeNode, maybeNextCallback);
    }
    if (timeout != null) {
      setTimeout(this.nextCallback, timeout);
    }
  };
  _proto.render = function render() {
    var status = this.state.status;
    if (status === UNMOUNTED) {
      return null;
    }
    var _this$props = this.props, children = _this$props.children;
    _this$props.in;
    _this$props.mountOnEnter;
    _this$props.unmountOnExit;
    _this$props.appear;
    _this$props.enter;
    _this$props.exit;
    _this$props.timeout;
    _this$props.addEndListener;
    _this$props.onEnter;
    _this$props.onEntering;
    _this$props.onEntered;
    _this$props.onExit;
    _this$props.onExiting;
    _this$props.onExited;
    _this$props.nodeRef;
    var childProps = _objectWithoutPropertiesLoose(_this$props, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
    return (
      // allows for nested Transitions
      /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: null
      }, typeof children === "function" ? children(status, childProps) : React.cloneElement(React.Children.only(children), childProps))
    );
  };
  return Transition2;
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$1() {
}
Transition.defaultProps = {
  in: false,
  mountOnEnter: false,
  unmountOnExit: false,
  appear: false,
  enter: true,
  exit: true,
  onEnter: noop$1,
  onEntering: noop$1,
  onEntered: noop$1,
  onExit: noop$1,
  onExiting: noop$1,
  onExited: noop$1
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function getChildMapping(children, mapFn) {
  var mapper = function mapper2(child) {
    return mapFn && reactExports.isValidElement(child) ? mapFn(child) : child;
  };
  var result = /* @__PURE__ */ Object.create(null);
  if (children)
    reactExports.Children.map(children, function(c2) {
      return c2;
    }).forEach(function(child) {
      result[child.key] = mapper(child);
    });
  return result;
}
function mergeChildMappings(prev2, next2) {
  prev2 = prev2 || {};
  next2 = next2 || {};
  function getValueForKey(key) {
    return key in next2 ? next2[key] : prev2[key];
  }
  var nextKeysPending = /* @__PURE__ */ Object.create(null);
  var pendingKeys = [];
  for (var prevKey in prev2) {
    if (prevKey in next2) {
      if (pendingKeys.length) {
        nextKeysPending[prevKey] = pendingKeys;
        pendingKeys = [];
      }
    } else {
      pendingKeys.push(prevKey);
    }
  }
  var i2;
  var childMapping = {};
  for (var nextKey in next2) {
    if (nextKeysPending[nextKey]) {
      for (i2 = 0; i2 < nextKeysPending[nextKey].length; i2++) {
        var pendingNextKey = nextKeysPending[nextKey][i2];
        childMapping[nextKeysPending[nextKey][i2]] = getValueForKey(pendingNextKey);
      }
    }
    childMapping[nextKey] = getValueForKey(nextKey);
  }
  for (i2 = 0; i2 < pendingKeys.length; i2++) {
    childMapping[pendingKeys[i2]] = getValueForKey(pendingKeys[i2]);
  }
  return childMapping;
}
function getProp(child, prop, props) {
  return props[prop] != null ? props[prop] : child.props[prop];
}
function getInitialChildMapping(props, onExited) {
  return getChildMapping(props.children, function(child) {
    return reactExports.cloneElement(child, {
      onExited: onExited.bind(null, child),
      in: true,
      appear: getProp(child, "appear", props),
      enter: getProp(child, "enter", props),
      exit: getProp(child, "exit", props)
    });
  });
}
function getNextChildMapping(nextProps, prevChildMapping, onExited) {
  var nextChildMapping = getChildMapping(nextProps.children);
  var children = mergeChildMappings(prevChildMapping, nextChildMapping);
  Object.keys(children).forEach(function(key) {
    var child = children[key];
    if (!reactExports.isValidElement(child))
      return;
    var hasPrev = key in prevChildMapping;
    var hasNext = key in nextChildMapping;
    var prevChild = prevChildMapping[key];
    var isLeaving = reactExports.isValidElement(prevChild) && !prevChild.props.in;
    if (hasNext && (!hasPrev || isLeaving)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: true,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    } else if (!hasNext && hasPrev && !isLeaving) {
      children[key] = reactExports.cloneElement(child, {
        in: false
      });
    } else if (hasNext && hasPrev && reactExports.isValidElement(prevChild)) {
      children[key] = reactExports.cloneElement(child, {
        onExited: onExited.bind(null, child),
        in: prevChild.props.in,
        exit: getProp(child, "exit", nextProps),
        enter: getProp(child, "enter", nextProps)
      });
    }
  });
  return children;
}
var values = Object.values || function(obj) {
  return Object.keys(obj).map(function(k2) {
    return obj[k2];
  });
};
var defaultProps = {
  component: "div",
  childFactory: function childFactory(child) {
    return child;
  }
};
var TransitionGroup = /* @__PURE__ */ function(_React$Component) {
  _inheritsLoose(TransitionGroup2, _React$Component);
  function TransitionGroup2(props, context) {
    var _this;
    _this = _React$Component.call(this, props, context) || this;
    var handleExited = _this.handleExited.bind(_assertThisInitialized(_this));
    _this.state = {
      contextValue: {
        isMounting: true
      },
      handleExited,
      firstRender: true
    };
    return _this;
  }
  var _proto = TransitionGroup2.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    this.setState({
      contextValue: {
        isMounting: false
      }
    });
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };
  TransitionGroup2.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, _ref) {
    var prevChildMapping = _ref.children, handleExited = _ref.handleExited, firstRender = _ref.firstRender;
    return {
      children: firstRender ? getInitialChildMapping(nextProps, handleExited) : getNextChildMapping(nextProps, prevChildMapping, handleExited),
      firstRender: false
    };
  };
  _proto.handleExited = function handleExited(child, node2) {
    var currentChildMapping = getChildMapping(this.props.children);
    if (child.key in currentChildMapping)
      return;
    if (child.props.onExited) {
      child.props.onExited(node2);
    }
    if (this.mounted) {
      this.setState(function(state) {
        var children = _extends$1({}, state.children);
        delete children[child.key];
        return {
          children
        };
      });
    }
  };
  _proto.render = function render() {
    var _this$props = this.props, Component = _this$props.component, childFactory2 = _this$props.childFactory, props = _objectWithoutPropertiesLoose(_this$props, ["component", "childFactory"]);
    var contextValue = this.state.contextValue;
    var children = values(this.state.children).map(childFactory2);
    delete props.appear;
    delete props.enter;
    delete props.exit;
    if (Component === null) {
      return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
        value: contextValue
      }, children);
    }
    return /* @__PURE__ */ React.createElement(TransitionGroupContext.Provider, {
      value: contextValue
    }, /* @__PURE__ */ React.createElement(Component, props, children));
  };
  return TransitionGroup2;
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup;
const reflow = (node2) => node2.scrollTop;
function getTransitionProps(props, options) {
  var _style$transitionDura, _style$transitionTimi;
  const {
    timeout,
    easing: easing2,
    style: style2 = {}
  } = props;
  return {
    duration: (_style$transitionDura = style2.transitionDuration) != null ? _style$transitionDura : typeof timeout === "number" ? timeout : timeout[options.mode] || 0,
    easing: (_style$transitionTimi = style2.transitionTimingFunction) != null ? _style$transitionTimi : typeof easing2 === "object" ? easing2[options.mode] : easing2,
    delay: style2.transitionDelay
  };
}
function getCollapseUtilityClass(slot) {
  return generateUtilityClass("MuiCollapse", slot);
}
generateUtilityClasses("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const _excluded$p = ["addEndListener", "children", "className", "collapsedSize", "component", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "orientation", "style", "timeout", "TransitionComponent"];
const useUtilityClasses$i = (ownerState) => {
  const {
    orientation,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", `${orientation}`],
    entered: ["entered"],
    hidden: ["hidden"],
    wrapper: ["wrapper", `${orientation}`],
    wrapperInner: ["wrapperInner", `${orientation}`]
  };
  return composeClasses(slots, getCollapseUtilityClass, classes2);
};
const CollapseRoot = styled$1("div", {
  name: "MuiCollapse",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.orientation], ownerState.state === "entered" && styles2.entered, ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && styles2.hidden];
  }
})(({
  theme,
  ownerState
}) => _extends$1({
  height: 0,
  overflow: "hidden",
  transition: theme.transitions.create("height")
}, ownerState.orientation === "horizontal" && {
  height: "auto",
  width: 0,
  transition: theme.transitions.create("width")
}, ownerState.state === "entered" && _extends$1({
  height: "auto",
  overflow: "visible"
}, ownerState.orientation === "horizontal" && {
  width: "auto"
}), ownerState.state === "exited" && !ownerState.in && ownerState.collapsedSize === "0px" && {
  visibility: "hidden"
}));
const CollapseWrapper = styled$1("div", {
  name: "MuiCollapse",
  slot: "Wrapper",
  overridesResolver: (props, styles2) => styles2.wrapper
})(({
  ownerState
}) => _extends$1({
  // Hack to get children with a negative margin to not falsify the height computation.
  display: "flex",
  width: "100%"
}, ownerState.orientation === "horizontal" && {
  width: "auto",
  height: "100%"
}));
const CollapseWrapperInner = styled$1("div", {
  name: "MuiCollapse",
  slot: "WrapperInner",
  overridesResolver: (props, styles2) => styles2.wrapperInner
})(({
  ownerState
}) => _extends$1({
  width: "100%"
}, ownerState.orientation === "horizontal" && {
  width: "auto",
  height: "100%"
}));
const Collapse = /* @__PURE__ */ reactExports.forwardRef(function Collapse2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiCollapse"
  });
  const {
    addEndListener,
    children,
    className,
    collapsedSize: collapsedSizeProp = "0px",
    component,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    orientation = "vertical",
    style: style2,
    timeout = duration.standard,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$p);
  const ownerState = _extends$1({}, props, {
    orientation,
    collapsedSize: collapsedSizeProp
  });
  const classes2 = useUtilityClasses$i(ownerState);
  const theme = useTheme();
  const timer = reactExports.useRef();
  const wrapperRef = reactExports.useRef(null);
  const autoTransitionDuration = reactExports.useRef();
  const collapsedSize = typeof collapsedSizeProp === "number" ? `${collapsedSizeProp}px` : collapsedSizeProp;
  const isHorizontal = orientation === "horizontal";
  const size = isHorizontal ? "width" : "height";
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(timer.current);
    };
  }, []);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(ref, nodeRef);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const getWrapperSize = () => wrapperRef.current ? wrapperRef.current[isHorizontal ? "clientWidth" : "clientHeight"] : 0;
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    if (wrapperRef.current && isHorizontal) {
      wrapperRef.current.style.position = "absolute";
    }
    node2.style[size] = collapsedSize;
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntering = normalizedTransitionCallback((node2, isAppearing) => {
    const wrapperSize = getWrapperSize();
    if (wrapperRef.current && isHorizontal) {
      wrapperRef.current.style.position = "";
    }
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    if (timeout === "auto") {
      const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
      node2.style.transitionDuration = `${duration2}ms`;
      autoTransitionDuration.current = duration2;
    } else {
      node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node2.style[size] = `${wrapperSize}px`;
    node2.style.transitionTimingFunction = transitionTimingFunction;
    if (onEntering) {
      onEntering(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback((node2, isAppearing) => {
    node2.style[size] = "auto";
    if (onEntered) {
      onEntered(node2, isAppearing);
    }
  });
  const handleExit = normalizedTransitionCallback((node2) => {
    node2.style[size] = `${getWrapperSize()}px`;
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleExiting = normalizedTransitionCallback((node2) => {
    const wrapperSize = getWrapperSize();
    const {
      duration: transitionDuration,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    if (timeout === "auto") {
      const duration2 = theme.transitions.getAutoHeightDuration(wrapperSize);
      node2.style.transitionDuration = `${duration2}ms`;
      autoTransitionDuration.current = duration2;
    } else {
      node2.style.transitionDuration = typeof transitionDuration === "string" ? transitionDuration : `${transitionDuration}ms`;
    }
    node2.style[size] = collapsedSize;
    node2.style.transitionTimingFunction = transitionTimingFunction;
    if (onExiting) {
      onExiting(node2);
    }
  });
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.current = setTimeout(next2, autoTransitionDuration.current || 0);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
    in: inProp,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    nodeRef,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state, childProps) => /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseRoot, _extends$1({
      as: component,
      className: clsx(classes2.root, className, {
        "entered": classes2.entered,
        "exited": !inProp && collapsedSize === "0px" && classes2.hidden
      }[state]),
      style: _extends$1({
        [isHorizontal ? "minWidth" : "minHeight"]: collapsedSize
      }, style2),
      ownerState: _extends$1({}, ownerState, {
        state
      }),
      ref: handleRef
    }, childProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapper, {
        ownerState: _extends$1({}, ownerState, {
          state
        }),
        className: classes2.wrapper,
        ref: wrapperRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(CollapseWrapperInner, {
          ownerState: _extends$1({}, ownerState, {
            state
          }),
          className: classes2.wrapperInner,
          children
        })
      })
    }))
  }));
});
Collapse.muiSupportAuto = true;
const Collapse$1 = Collapse;
function getPaperUtilityClass(slot) {
  return generateUtilityClass("MuiPaper", slot);
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const _excluded$o = ["className", "component", "elevation", "square", "variant"];
const useUtilityClasses$h = (ownerState) => {
  const {
    square,
    elevation,
    variant,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", variant, !square && "rounded", variant === "elevation" && `elevation${elevation}`]
  };
  return composeClasses(slots, getPaperUtilityClass, classes2);
};
const PaperRoot = styled$1("div", {
  name: "MuiPaper",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, styles2[ownerState.variant], !ownerState.square && styles2.rounded, ownerState.variant === "elevation" && styles2[`elevation${ownerState.elevation}`]];
  }
})(({
  theme,
  ownerState
}) => {
  var _theme$vars$overlays;
  return _extends$1({
    backgroundColor: (theme.vars || theme).palette.background.paper,
    color: (theme.vars || theme).palette.text.primary,
    transition: theme.transitions.create("box-shadow")
  }, !ownerState.square && {
    borderRadius: theme.shape.borderRadius
  }, ownerState.variant === "outlined" && {
    border: `1px solid ${(theme.vars || theme).palette.divider}`
  }, ownerState.variant === "elevation" && _extends$1({
    boxShadow: (theme.vars || theme).shadows[ownerState.elevation]
  }, !theme.vars && theme.palette.mode === "dark" && {
    backgroundImage: `linear-gradient(${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))}, ${alpha("#fff", getOverlayAlpha$1(ownerState.elevation))})`
  }, theme.vars && {
    backgroundImage: (_theme$vars$overlays = theme.vars.overlays) == null ? void 0 : _theme$vars$overlays[ownerState.elevation]
  }));
});
const Paper = /* @__PURE__ */ reactExports.forwardRef(function Paper2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiPaper"
  });
  const {
    className,
    component = "div",
    elevation = 1,
    square = false,
    variant = "elevation"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$o);
  const ownerState = _extends$1({}, props, {
    component,
    elevation,
    square,
    variant
  });
  const classes2 = useUtilityClasses$h(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaperRoot, _extends$1({
    as: component,
    ownerState,
    className: clsx(classes2.root, className),
    ref
  }, other));
});
const Paper$1 = Paper;
const AccordionContext = /* @__PURE__ */ reactExports.createContext({});
const AccordionContext$1 = AccordionContext;
function getAccordionUtilityClass(slot) {
  return generateUtilityClass("MuiAccordion", slot);
}
const accordionClasses = generateUtilityClasses("MuiAccordion", ["root", "rounded", "expanded", "disabled", "gutters", "region"]);
const accordionClasses$1 = accordionClasses;
const _excluded$n = ["children", "className", "defaultExpanded", "disabled", "disableGutters", "expanded", "onChange", "square", "TransitionComponent", "TransitionProps"];
const useUtilityClasses$g = (ownerState) => {
  const {
    classes: classes2,
    square,
    expanded,
    disabled,
    disableGutters
  } = ownerState;
  const slots = {
    root: ["root", !square && "rounded", expanded && "expanded", disabled && "disabled", !disableGutters && "gutters"],
    region: ["region"]
  };
  return composeClasses(slots, getAccordionUtilityClass, classes2);
};
const AccordionRoot = styled$1(Paper$1, {
  name: "MuiAccordion",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${accordionClasses$1.region}`]: styles2.region
    }, styles2.root, !ownerState.square && styles2.rounded, !ownerState.disableGutters && styles2.gutters];
  }
})(({
  theme
}) => {
  const transition2 = {
    duration: theme.transitions.duration.shortest
  };
  return {
    position: "relative",
    transition: theme.transitions.create(["margin"], transition2),
    overflowAnchor: "none",
    // Keep the same scrolling position
    "&:before": {
      position: "absolute",
      left: 0,
      top: -1,
      right: 0,
      height: 1,
      content: '""',
      opacity: 1,
      backgroundColor: (theme.vars || theme).palette.divider,
      transition: theme.transitions.create(["opacity", "background-color"], transition2)
    },
    "&:first-of-type": {
      "&:before": {
        display: "none"
      }
    },
    [`&.${accordionClasses$1.expanded}`]: {
      "&:before": {
        opacity: 0
      },
      "&:first-of-type": {
        marginTop: 0
      },
      "&:last-of-type": {
        marginBottom: 0
      },
      "& + &": {
        "&:before": {
          display: "none"
        }
      }
    },
    [`&.${accordionClasses$1.disabled}`]: {
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    }
  };
}, ({
  theme,
  ownerState
}) => _extends$1({}, !ownerState.square && {
  borderRadius: 0,
  "&:first-of-type": {
    borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
    borderTopRightRadius: (theme.vars || theme).shape.borderRadius
  },
  "&:last-of-type": {
    borderBottomLeftRadius: (theme.vars || theme).shape.borderRadius,
    borderBottomRightRadius: (theme.vars || theme).shape.borderRadius,
    // Fix a rendering issue on Edge
    "@supports (-ms-ime-align: auto)": {
      borderBottomLeftRadius: 0,
      borderBottomRightRadius: 0
    }
  }
}, !ownerState.disableGutters && {
  [`&.${accordionClasses$1.expanded}`]: {
    margin: "16px 0"
  }
}));
const Accordion = /* @__PURE__ */ reactExports.forwardRef(function Accordion2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAccordion"
  });
  const {
    children: childrenProp,
    className,
    defaultExpanded = false,
    disabled = false,
    disableGutters = false,
    expanded: expandedProp,
    onChange,
    square = false,
    TransitionComponent = Collapse$1,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$n);
  const [expanded, setExpandedState] = useControlled({
    controlled: expandedProp,
    default: defaultExpanded,
    name: "Accordion",
    state: "expanded"
  });
  const handleChange = reactExports.useCallback((event) => {
    setExpandedState(!expanded);
    if (onChange) {
      onChange(event, !expanded);
    }
  }, [expanded, onChange, setExpandedState]);
  const [summary, ...children] = reactExports.Children.toArray(childrenProp);
  const contextValue = reactExports.useMemo(() => ({
    expanded,
    disabled,
    disableGutters,
    toggle: handleChange
  }), [expanded, disabled, disableGutters, handleChange]);
  const ownerState = _extends$1({}, props, {
    square,
    disabled,
    disableGutters,
    expanded
  });
  const classes2 = useUtilityClasses$g(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(AccordionRoot, _extends$1({
    className: clsx(classes2.root, className),
    ref,
    ownerState,
    square
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AccordionContext$1.Provider, {
      value: contextValue,
      children: summary
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
      in: expanded,
      timeout: "auto"
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        "aria-labelledby": summary.props.id,
        id: summary.props["aria-controls"],
        role: "region",
        className: classes2.region,
        children
      })
    }))]
  }));
});
const Accordion$1 = Accordion;
function getAccordionDetailsUtilityClass(slot) {
  return generateUtilityClass("MuiAccordionDetails", slot);
}
generateUtilityClasses("MuiAccordionDetails", ["root"]);
const _excluded$m = ["className"];
const useUtilityClasses$f = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getAccordionDetailsUtilityClass, classes2);
};
const AccordionDetailsRoot = styled$1("div", {
  name: "MuiAccordionDetails",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme
}) => ({
  padding: theme.spacing(1, 2, 2)
}));
const AccordionDetails = /* @__PURE__ */ reactExports.forwardRef(function AccordionDetails2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAccordionDetails"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$m);
  const ownerState = props;
  const classes2 = useUtilityClasses$f(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionDetailsRoot, _extends$1({
    className: clsx(classes2.root, className),
    ref,
    ownerState
  }, other));
});
const AccordionDetails$1 = AccordionDetails;
function Ripple(props) {
  const {
    className,
    classes: classes2,
    pulsate = false,
    rippleX,
    rippleY,
    rippleSize,
    in: inProp,
    onExited,
    timeout
  } = props;
  const [leaving, setLeaving] = reactExports.useState(false);
  const rippleClassName = clsx(className, classes2.ripple, classes2.rippleVisible, pulsate && classes2.ripplePulsate);
  const rippleStyles = {
    width: rippleSize,
    height: rippleSize,
    top: -(rippleSize / 2) + rippleY,
    left: -(rippleSize / 2) + rippleX
  };
  const childClassName = clsx(classes2.child, leaving && classes2.childLeaving, pulsate && classes2.childPulsate);
  if (!inProp && !leaving) {
    setLeaving(true);
  }
  reactExports.useEffect(() => {
    if (!inProp && onExited != null) {
      const timeoutId = setTimeout(onExited, timeout);
      return () => {
        clearTimeout(timeoutId);
      };
    }
    return void 0;
  }, [onExited, inProp, timeout]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
    className: rippleClassName,
    style: rippleStyles,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
      className: childClassName
    })
  });
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"]);
const touchRippleClasses$1 = touchRippleClasses;
const _excluded$l = ["center", "classes", "className"];
let _ = (t2) => t2, _t, _t2, _t3, _t4;
const DURATION = 550;
const DELAY_RIPPLE = 80;
const enterKeyframe = keyframes(_t || (_t = _`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`));
const exitKeyframe = keyframes(_t2 || (_t2 = _`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`));
const pulsateKeyframe = keyframes(_t3 || (_t3 = _`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`));
const TouchRippleRoot = styled$1("span", {
  name: "MuiTouchRipple",
  slot: "Root"
})({
  overflow: "hidden",
  pointerEvents: "none",
  position: "absolute",
  zIndex: 0,
  top: 0,
  right: 0,
  bottom: 0,
  left: 0,
  borderRadius: "inherit"
});
const TouchRippleRipple = styled$1(Ripple, {
  name: "MuiTouchRipple",
  slot: "Ripple"
})(_t4 || (_t4 = _`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`), touchRippleClasses$1.rippleVisible, enterKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses$1.ripplePulsate, ({
  theme
}) => theme.transitions.duration.shorter, touchRippleClasses$1.child, touchRippleClasses$1.childLeaving, exitKeyframe, DURATION, ({
  theme
}) => theme.transitions.easing.easeInOut, touchRippleClasses$1.childPulsate, pulsateKeyframe, ({
  theme
}) => theme.transitions.easing.easeInOut);
const TouchRipple = /* @__PURE__ */ reactExports.forwardRef(function TouchRipple2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiTouchRipple"
  });
  const {
    center: centerProp = false,
    classes: classes2 = {},
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$l);
  const [ripples, setRipples] = reactExports.useState([]);
  const nextKey = reactExports.useRef(0);
  const rippleCallback = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (rippleCallback.current) {
      rippleCallback.current();
      rippleCallback.current = null;
    }
  }, [ripples]);
  const ignoringMouseDown = reactExports.useRef(false);
  const startTimer = reactExports.useRef(0);
  const startTimerCommit = reactExports.useRef(null);
  const container = reactExports.useRef(null);
  reactExports.useEffect(() => {
    return () => {
      if (startTimer.current) {
        clearTimeout(startTimer.current);
      }
    };
  }, []);
  const startCommit = reactExports.useCallback((params) => {
    const {
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize,
      cb: cb2
    } = params;
    setRipples((oldRipples) => [...oldRipples, /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRipple, {
      classes: {
        ripple: clsx(classes2.ripple, touchRippleClasses$1.ripple),
        rippleVisible: clsx(classes2.rippleVisible, touchRippleClasses$1.rippleVisible),
        ripplePulsate: clsx(classes2.ripplePulsate, touchRippleClasses$1.ripplePulsate),
        child: clsx(classes2.child, touchRippleClasses$1.child),
        childLeaving: clsx(classes2.childLeaving, touchRippleClasses$1.childLeaving),
        childPulsate: clsx(classes2.childPulsate, touchRippleClasses$1.childPulsate)
      },
      timeout: DURATION,
      pulsate: pulsate2,
      rippleX,
      rippleY,
      rippleSize
    }, nextKey.current)]);
    nextKey.current += 1;
    rippleCallback.current = cb2;
  }, [classes2]);
  const start = reactExports.useCallback((event = {}, options = {}, cb2 = () => {
  }) => {
    const {
      pulsate: pulsate2 = false,
      center = centerProp || options.pulsate,
      fakeElement = false
      // For test purposes
    } = options;
    if ((event == null ? void 0 : event.type) === "mousedown" && ignoringMouseDown.current) {
      ignoringMouseDown.current = false;
      return;
    }
    if ((event == null ? void 0 : event.type) === "touchstart") {
      ignoringMouseDown.current = true;
    }
    const element = fakeElement ? null : container.current;
    const rect = element ? element.getBoundingClientRect() : {
      width: 0,
      height: 0,
      left: 0,
      top: 0
    };
    let rippleX;
    let rippleY;
    let rippleSize;
    if (center || event === void 0 || event.clientX === 0 && event.clientY === 0 || !event.clientX && !event.touches) {
      rippleX = Math.round(rect.width / 2);
      rippleY = Math.round(rect.height / 2);
    } else {
      const {
        clientX,
        clientY
      } = event.touches && event.touches.length > 0 ? event.touches[0] : event;
      rippleX = Math.round(clientX - rect.left);
      rippleY = Math.round(clientY - rect.top);
    }
    if (center) {
      rippleSize = Math.sqrt((2 * rect.width ** 2 + rect.height ** 2) / 3);
      if (rippleSize % 2 === 0) {
        rippleSize += 1;
      }
    } else {
      const sizeX = Math.max(Math.abs((element ? element.clientWidth : 0) - rippleX), rippleX) * 2 + 2;
      const sizeY = Math.max(Math.abs((element ? element.clientHeight : 0) - rippleY), rippleY) * 2 + 2;
      rippleSize = Math.sqrt(sizeX ** 2 + sizeY ** 2);
    }
    if (event != null && event.touches) {
      if (startTimerCommit.current === null) {
        startTimerCommit.current = () => {
          startCommit({
            pulsate: pulsate2,
            rippleX,
            rippleY,
            rippleSize,
            cb: cb2
          });
        };
        startTimer.current = setTimeout(() => {
          if (startTimerCommit.current) {
            startTimerCommit.current();
            startTimerCommit.current = null;
          }
        }, DELAY_RIPPLE);
      }
    } else {
      startCommit({
        pulsate: pulsate2,
        rippleX,
        rippleY,
        rippleSize,
        cb: cb2
      });
    }
  }, [centerProp, startCommit]);
  const pulsate = reactExports.useCallback(() => {
    start({}, {
      pulsate: true
    });
  }, [start]);
  const stop = reactExports.useCallback((event, cb2) => {
    clearTimeout(startTimer.current);
    if ((event == null ? void 0 : event.type) === "touchend" && startTimerCommit.current) {
      startTimerCommit.current();
      startTimerCommit.current = null;
      startTimer.current = setTimeout(() => {
        stop(event, cb2);
      });
      return;
    }
    startTimerCommit.current = null;
    setRipples((oldRipples) => {
      if (oldRipples.length > 0) {
        return oldRipples.slice(1);
      }
      return oldRipples;
    });
    rippleCallback.current = cb2;
  }, []);
  reactExports.useImperativeHandle(ref, () => ({
    pulsate,
    start,
    stop
  }), [pulsate, start, stop]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRippleRoot, _extends$1({
    className: clsx(touchRippleClasses$1.root, classes2.root, className),
    ref: container
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionGroup$1, {
      component: null,
      exit: true,
      children: ripples
    })
  }));
});
const TouchRipple$1 = TouchRipple;
function getButtonBaseUtilityClass(slot) {
  return generateUtilityClass("MuiButtonBase", slot);
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"]);
const buttonBaseClasses$1 = buttonBaseClasses;
const _excluded$k = ["action", "centerRipple", "children", "className", "component", "disabled", "disableRipple", "disableTouchRipple", "focusRipple", "focusVisibleClassName", "LinkComponent", "onBlur", "onClick", "onContextMenu", "onDragLeave", "onFocus", "onFocusVisible", "onKeyDown", "onKeyUp", "onMouseDown", "onMouseLeave", "onMouseUp", "onTouchEnd", "onTouchMove", "onTouchStart", "tabIndex", "TouchRippleProps", "touchRippleRef", "type"];
const useUtilityClasses$e = (ownerState) => {
  const {
    disabled,
    focusVisible,
    focusVisibleClassName,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", disabled && "disabled", focusVisible && "focusVisible"]
  };
  const composedClasses = composeClasses(slots, getButtonBaseUtilityClass, classes2);
  if (focusVisible && focusVisibleClassName) {
    composedClasses.root += ` ${focusVisibleClassName}`;
  }
  return composedClasses;
};
const ButtonBaseRoot = styled$1("button", {
  name: "MuiButtonBase",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  position: "relative",
  boxSizing: "border-box",
  WebkitTapHighlightColor: "transparent",
  backgroundColor: "transparent",
  // Reset default value
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0,
  border: 0,
  margin: 0,
  // Remove the margin in Safari
  borderRadius: 0,
  padding: 0,
  // Remove the padding in Firefox
  cursor: "pointer",
  userSelect: "none",
  verticalAlign: "middle",
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  textDecoration: "none",
  // So we take precedent over the style of a native <a /> element.
  color: "inherit",
  "&::-moz-focus-inner": {
    borderStyle: "none"
    // Remove Firefox dotted outline.
  },
  [`&.${buttonBaseClasses$1.disabled}`]: {
    pointerEvents: "none",
    // Disable link interactions
    cursor: "default"
  },
  "@media print": {
    colorAdjust: "exact"
  }
});
const ButtonBase = /* @__PURE__ */ reactExports.forwardRef(function ButtonBase2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiButtonBase"
  });
  const {
    action,
    centerRipple = false,
    children,
    className,
    component = "button",
    disabled = false,
    disableRipple = false,
    disableTouchRipple = false,
    focusRipple = false,
    LinkComponent = "a",
    onBlur,
    onClick: onClick2,
    onContextMenu,
    onDragLeave,
    onFocus: onFocus2,
    onFocusVisible,
    onKeyDown,
    onKeyUp,
    onMouseDown,
    onMouseLeave,
    onMouseUp,
    onTouchEnd: onTouchEnd2,
    onTouchMove: onTouchMove2,
    onTouchStart: onTouchStart2,
    tabIndex = 0,
    TouchRippleProps,
    touchRippleRef,
    type
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$k);
  const buttonRef = reactExports.useRef(null);
  const rippleRef = reactExports.useRef(null);
  const handleRippleRef = useForkRef(rippleRef, touchRippleRef);
  const {
    isFocusVisibleRef,
    onFocus: handleFocusVisible,
    onBlur: handleBlurVisible,
    ref: focusVisibleRef
  } = useIsFocusVisible();
  const [focusVisible, setFocusVisible] = reactExports.useState(false);
  if (disabled && focusVisible) {
    setFocusVisible(false);
  }
  reactExports.useImperativeHandle(action, () => ({
    focusVisible: () => {
      setFocusVisible(true);
      buttonRef.current.focus();
    }
  }), []);
  const [mountedState, setMountedState] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMountedState(true);
  }, []);
  const enableTouchRipple = mountedState && !disableRipple && !disabled;
  reactExports.useEffect(() => {
    if (focusVisible && focusRipple && !disableRipple && mountedState) {
      rippleRef.current.pulsate();
    }
  }, [disableRipple, focusRipple, focusVisible, mountedState]);
  function useRippleHandler(rippleAction, eventCallback, skipRippleAction = disableTouchRipple) {
    return useEventCallback((event) => {
      if (eventCallback) {
        eventCallback(event);
      }
      const ignore = skipRippleAction;
      if (!ignore && rippleRef.current) {
        rippleRef.current[rippleAction](event);
      }
      return true;
    });
  }
  const handleMouseDown = useRippleHandler("start", onMouseDown);
  const handleContextMenu = useRippleHandler("stop", onContextMenu);
  const handleDragLeave = useRippleHandler("stop", onDragLeave);
  const handleMouseUp = useRippleHandler("stop", onMouseUp);
  const handleMouseLeave = useRippleHandler("stop", (event) => {
    if (focusVisible) {
      event.preventDefault();
    }
    if (onMouseLeave) {
      onMouseLeave(event);
    }
  });
  const handleTouchStart = useRippleHandler("start", onTouchStart2);
  const handleTouchEnd = useRippleHandler("stop", onTouchEnd2);
  const handleTouchMove = useRippleHandler("stop", onTouchMove2);
  const handleBlur = useRippleHandler("stop", (event) => {
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusVisible(false);
    }
    if (onBlur) {
      onBlur(event);
    }
  }, false);
  const handleFocus = useEventCallback((event) => {
    if (!buttonRef.current) {
      buttonRef.current = event.currentTarget;
    }
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusVisible(true);
      if (onFocusVisible) {
        onFocusVisible(event);
      }
    }
    if (onFocus2) {
      onFocus2(event);
    }
  });
  const isNonNativeButton = () => {
    const button = buttonRef.current;
    return component && component !== "button" && !(button.tagName === "A" && button.href);
  };
  const keydownRef = reactExports.useRef(false);
  const handleKeyDown2 = useEventCallback((event) => {
    if (focusRipple && !keydownRef.current && focusVisible && rippleRef.current && event.key === " ") {
      keydownRef.current = true;
      rippleRef.current.stop(event, () => {
        rippleRef.current.start(event);
      });
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === " ") {
      event.preventDefault();
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (event.target === event.currentTarget && isNonNativeButton() && event.key === "Enter" && !disabled) {
      event.preventDefault();
      if (onClick2) {
        onClick2(event);
      }
    }
  });
  const handleKeyUp = useEventCallback((event) => {
    if (focusRipple && event.key === " " && rippleRef.current && focusVisible && !event.defaultPrevented) {
      keydownRef.current = false;
      rippleRef.current.stop(event, () => {
        rippleRef.current.pulsate(event);
      });
    }
    if (onKeyUp) {
      onKeyUp(event);
    }
    if (onClick2 && event.target === event.currentTarget && isNonNativeButton() && event.key === " " && !event.defaultPrevented) {
      onClick2(event);
    }
  });
  let ComponentProp = component;
  if (ComponentProp === "button" && (other.href || other.to)) {
    ComponentProp = LinkComponent;
  }
  const buttonProps = {};
  if (ComponentProp === "button") {
    buttonProps.type = type === void 0 ? "button" : type;
    buttonProps.disabled = disabled;
  } else {
    if (!other.href && !other.to) {
      buttonProps.role = "button";
    }
    if (disabled) {
      buttonProps["aria-disabled"] = disabled;
    }
  }
  const handleRef = useForkRef(ref, focusVisibleRef, buttonRef);
  const ownerState = _extends$1({}, props, {
    centerRipple,
    component,
    disabled,
    disableRipple,
    disableTouchRipple,
    focusRipple,
    tabIndex,
    focusVisible
  });
  const classes2 = useUtilityClasses$e(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ButtonBaseRoot, _extends$1({
    as: ComponentProp,
    className: clsx(classes2.root, className),
    ownerState,
    onBlur: handleBlur,
    onClick: onClick2,
    onContextMenu: handleContextMenu,
    onFocus: handleFocus,
    onKeyDown: handleKeyDown2,
    onKeyUp: handleKeyUp,
    onMouseDown: handleMouseDown,
    onMouseLeave: handleMouseLeave,
    onMouseUp: handleMouseUp,
    onDragLeave: handleDragLeave,
    onTouchEnd: handleTouchEnd,
    onTouchMove: handleTouchMove,
    onTouchStart: handleTouchStart,
    ref: handleRef,
    tabIndex: disabled ? -1 : tabIndex,
    type
  }, buttonProps, other, {
    children: [children, enableTouchRipple ? (
      /* TouchRipple is only needed client-side, x2 boost on the server. */
      /* @__PURE__ */ jsxRuntimeExports.jsx(TouchRipple$1, _extends$1({
        ref: handleRippleRef,
        center: centerRipple
      }, TouchRippleProps))
    ) : null]
  }));
});
const ButtonBase$1 = ButtonBase;
function getAccordionSummaryUtilityClass(slot) {
  return generateUtilityClass("MuiAccordionSummary", slot);
}
const accordionSummaryClasses = generateUtilityClasses("MuiAccordionSummary", ["root", "expanded", "focusVisible", "disabled", "gutters", "contentGutters", "content", "expandIconWrapper"]);
const accordionSummaryClasses$1 = accordionSummaryClasses;
const _excluded$j = ["children", "className", "expandIcon", "focusVisibleClassName", "onClick"];
const useUtilityClasses$d = (ownerState) => {
  const {
    classes: classes2,
    expanded,
    disabled,
    disableGutters
  } = ownerState;
  const slots = {
    root: ["root", expanded && "expanded", disabled && "disabled", !disableGutters && "gutters"],
    focusVisible: ["focusVisible"],
    content: ["content", expanded && "expanded", !disableGutters && "contentGutters"],
    expandIconWrapper: ["expandIconWrapper", expanded && "expanded"]
  };
  return composeClasses(slots, getAccordionSummaryUtilityClass, classes2);
};
const AccordionSummaryRoot = styled$1(ButtonBase$1, {
  name: "MuiAccordionSummary",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})(({
  theme,
  ownerState
}) => {
  const transition2 = {
    duration: theme.transitions.duration.shortest
  };
  return _extends$1({
    display: "flex",
    minHeight: 48,
    padding: theme.spacing(0, 2),
    transition: theme.transitions.create(["min-height", "background-color"], transition2),
    [`&.${accordionSummaryClasses$1.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    [`&.${accordionSummaryClasses$1.disabled}`]: {
      opacity: (theme.vars || theme).palette.action.disabledOpacity
    },
    [`&:hover:not(.${accordionSummaryClasses$1.disabled})`]: {
      cursor: "pointer"
    }
  }, !ownerState.disableGutters && {
    [`&.${accordionSummaryClasses$1.expanded}`]: {
      minHeight: 64
    }
  });
});
const AccordionSummaryContent = styled$1("div", {
  name: "MuiAccordionSummary",
  slot: "Content",
  overridesResolver: (props, styles2) => styles2.content
})(({
  theme,
  ownerState
}) => _extends$1({
  display: "flex",
  flexGrow: 1,
  margin: "12px 0"
}, !ownerState.disableGutters && {
  transition: theme.transitions.create(["margin"], {
    duration: theme.transitions.duration.shortest
  }),
  [`&.${accordionSummaryClasses$1.expanded}`]: {
    margin: "20px 0"
  }
}));
const AccordionSummaryExpandIconWrapper = styled$1("div", {
  name: "MuiAccordionSummary",
  slot: "ExpandIconWrapper",
  overridesResolver: (props, styles2) => styles2.expandIconWrapper
})(({
  theme
}) => ({
  display: "flex",
  color: (theme.vars || theme).palette.action.active,
  transform: "rotate(0deg)",
  transition: theme.transitions.create("transform", {
    duration: theme.transitions.duration.shortest
  }),
  [`&.${accordionSummaryClasses$1.expanded}`]: {
    transform: "rotate(180deg)"
  }
}));
const AccordionSummary = /* @__PURE__ */ reactExports.forwardRef(function AccordionSummary2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAccordionSummary"
  });
  const {
    children,
    className,
    expandIcon,
    focusVisibleClassName,
    onClick: onClick2
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$j);
  const {
    disabled = false,
    disableGutters,
    expanded,
    toggle
  } = reactExports.useContext(AccordionContext$1);
  const handleChange = (event) => {
    if (toggle) {
      toggle(event);
    }
    if (onClick2) {
      onClick2(event);
    }
  };
  const ownerState = _extends$1({}, props, {
    expanded,
    disabled,
    disableGutters
  });
  const classes2 = useUtilityClasses$d(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(AccordionSummaryRoot, _extends$1({
    focusRipple: false,
    disableRipple: true,
    disabled,
    component: "div",
    "aria-expanded": expanded,
    className: clsx(classes2.root, className),
    focusVisibleClassName: clsx(classes2.focusVisible, focusVisibleClassName),
    onClick: handleChange,
    ref,
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AccordionSummaryContent, {
      className: classes2.content,
      ownerState,
      children
    }), expandIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionSummaryExpandIconWrapper, {
      className: classes2.expandIconWrapper,
      ownerState,
      children: expandIcon
    })]
  }));
});
const AccordionSummary$1 = AccordionSummary;
function isHostComponent(element) {
  return typeof element === "string";
}
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === void 0 || isHostComponent(elementType)) {
    return otherProps;
  }
  return _extends$1({}, otherProps, {
    ownerState: _extends$1({}, otherProps.ownerState, ownerState)
  });
}
function extractEventHandlers(object, excludeKeys = []) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => prop.match(/^on[A-Z]/) && typeof object[prop] === "function" && !excludeKeys.includes(prop)).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function resolveComponentProps(componentProps, ownerState, slotState) {
  if (typeof componentProps === "function") {
    return componentProps(ownerState, slotState);
  }
  return componentProps;
}
function omitEventHandlers(object) {
  if (object === void 0) {
    return {};
  }
  const result = {};
  Object.keys(object).filter((prop) => !(prop.match(/^on[A-Z]/) && typeof object[prop] === "function")).forEach((prop) => {
    result[prop] = object[prop];
  });
  return result;
}
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    const joinedClasses2 = clsx(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
    const mergedStyle2 = _extends$1({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props2 = _extends$1({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses2.length > 0) {
      props2.className = joinedClasses2;
    }
    if (Object.keys(mergedStyle2).length > 0) {
      props2.style = mergedStyle2;
    }
    return {
      props: props2,
      internalRef: void 0
    };
  }
  const eventHandlers = extractEventHandlers(_extends$1({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = omitEventHandlers(externalSlotProps);
  const otherPropsWithoutEventHandlers = omitEventHandlers(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);
  const joinedClasses = clsx(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = _extends$1({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = _extends$1({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}
const _excluded$i = ["elementType", "externalSlotProps", "ownerState", "skipResolvingSlotProps"];
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
    elementType,
    externalSlotProps,
    ownerState,
    skipResolvingSlotProps = false
  } = parameters, rest = _objectWithoutPropertiesLoose(parameters, _excluded$i);
  const resolvedComponentsProps = skipResolvingSlotProps ? {} : resolveComponentProps(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = mergeSlotProps(_extends$1({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = useForkRef(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = appendOwnerState(elementType, _extends$1({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(node2) {
  const tabindexAttr = parseInt(node2.getAttribute("tabindex") || "", 10);
  if (!Number.isNaN(tabindexAttr)) {
    return tabindexAttr;
  }
  if (node2.contentEditable === "true" || (node2.nodeName === "AUDIO" || node2.nodeName === "VIDEO" || node2.nodeName === "DETAILS") && node2.getAttribute("tabindex") === null) {
    return 0;
  }
  return node2.tabIndex;
}
function isNonTabbableRadio(node2) {
  if (node2.tagName !== "INPUT" || node2.type !== "radio") {
    return false;
  }
  if (!node2.name) {
    return false;
  }
  const getRadio = (selector) => node2.ownerDocument.querySelector(`input[type="radio"]${selector}`);
  let roving = getRadio(`[name="${node2.name}"]:checked`);
  if (!roving) {
    roving = getRadio(`[name="${node2.name}"]`);
  }
  return roving !== node2;
}
function isNodeMatchingSelectorFocusable(node2) {
  if (node2.disabled || node2.tagName === "INPUT" && node2.type === "hidden" || isNonTabbableRadio(node2)) {
    return false;
  }
  return true;
}
function defaultGetTabbable(root) {
  const regularTabNodes = [];
  const orderedTabNodes = [];
  Array.from(root.querySelectorAll(candidatesSelector)).forEach((node2, i2) => {
    const nodeTabIndex = getTabIndex(node2);
    if (nodeTabIndex === -1 || !isNodeMatchingSelectorFocusable(node2)) {
      return;
    }
    if (nodeTabIndex === 0) {
      regularTabNodes.push(node2);
    } else {
      orderedTabNodes.push({
        documentOrder: i2,
        tabIndex: nodeTabIndex,
        node: node2
      });
    }
  });
  return orderedTabNodes.sort((a2, b2) => a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex).map((a2) => a2.node).concat(regularTabNodes);
}
function defaultIsEnabled() {
  return true;
}
function FocusTrap(props) {
  const {
    children,
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableRestoreFocus = false,
    getTabbable = defaultGetTabbable,
    isEnabled = defaultIsEnabled,
    open
  } = props;
  const ignoreNextEnforceFocus = reactExports.useRef(false);
  const sentinelStart = reactExports.useRef(null);
  const sentinelEnd = reactExports.useRef(null);
  const nodeToRestore = reactExports.useRef(null);
  const reactFocusEventTarget = reactExports.useRef(null);
  const activated = reactExports.useRef(false);
  const rootRef = reactExports.useRef(null);
  const handleRef = useForkRef(children.ref, rootRef);
  const lastKeydown = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    activated.current = !disableAutoFocus;
  }, [disableAutoFocus, open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    if (!rootRef.current.contains(doc.activeElement)) {
      if (!rootRef.current.hasAttribute("tabIndex")) {
        rootRef.current.setAttribute("tabIndex", "-1");
      }
      if (activated.current) {
        rootRef.current.focus();
      }
    }
    return () => {
      if (!disableRestoreFocus) {
        if (nodeToRestore.current && nodeToRestore.current.focus) {
          ignoreNextEnforceFocus.current = true;
          nodeToRestore.current.focus();
        }
        nodeToRestore.current = null;
      }
    };
  }, [open]);
  reactExports.useEffect(() => {
    if (!open || !rootRef.current) {
      return;
    }
    const doc = ownerDocument(rootRef.current);
    const loopFocus = (nativeEvent) => {
      lastKeydown.current = nativeEvent;
      if (disableEnforceFocus || !isEnabled() || nativeEvent.key !== "Tab") {
        return;
      }
      if (doc.activeElement === rootRef.current && nativeEvent.shiftKey) {
        ignoreNextEnforceFocus.current = true;
        if (sentinelEnd.current) {
          sentinelEnd.current.focus();
        }
      }
    };
    const contain = () => {
      const rootElement = rootRef.current;
      if (rootElement === null) {
        return;
      }
      if (!doc.hasFocus() || !isEnabled() || ignoreNextEnforceFocus.current) {
        ignoreNextEnforceFocus.current = false;
        return;
      }
      if (rootElement.contains(doc.activeElement)) {
        return;
      }
      if (disableEnforceFocus && doc.activeElement !== sentinelStart.current && doc.activeElement !== sentinelEnd.current) {
        return;
      }
      if (doc.activeElement !== reactFocusEventTarget.current) {
        reactFocusEventTarget.current = null;
      } else if (reactFocusEventTarget.current !== null) {
        return;
      }
      if (!activated.current) {
        return;
      }
      let tabbable = [];
      if (doc.activeElement === sentinelStart.current || doc.activeElement === sentinelEnd.current) {
        tabbable = getTabbable(rootRef.current);
      }
      if (tabbable.length > 0) {
        var _lastKeydown$current, _lastKeydown$current2;
        const isShiftTab = Boolean(((_lastKeydown$current = lastKeydown.current) == null ? void 0 : _lastKeydown$current.shiftKey) && ((_lastKeydown$current2 = lastKeydown.current) == null ? void 0 : _lastKeydown$current2.key) === "Tab");
        const focusNext = tabbable[0];
        const focusPrevious = tabbable[tabbable.length - 1];
        if (typeof focusNext !== "string" && typeof focusPrevious !== "string") {
          if (isShiftTab) {
            focusPrevious.focus();
          } else {
            focusNext.focus();
          }
        }
      } else {
        rootElement.focus();
      }
    };
    doc.addEventListener("focusin", contain);
    doc.addEventListener("keydown", loopFocus, true);
    const interval = setInterval(() => {
      if (doc.activeElement && doc.activeElement.tagName === "BODY") {
        contain();
      }
    }, 50);
    return () => {
      clearInterval(interval);
      doc.removeEventListener("focusin", contain);
      doc.removeEventListener("keydown", loopFocus, true);
    };
  }, [disableAutoFocus, disableEnforceFocus, disableRestoreFocus, isEnabled, open, getTabbable]);
  const onFocus2 = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
    reactFocusEventTarget.current = event.target;
    const childrenPropsHandler = children.props.onFocus;
    if (childrenPropsHandler) {
      childrenPropsHandler(event);
    }
  };
  const handleFocusSentinel = (event) => {
    if (nodeToRestore.current === null) {
      nodeToRestore.current = event.relatedTarget;
    }
    activated.current = true;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelStart,
      "data-testid": "sentinelStart"
    }), /* @__PURE__ */ reactExports.cloneElement(children, {
      ref: handleRef,
      onFocus: onFocus2
    }), /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
      tabIndex: open ? 0 : -1,
      onFocus: handleFocusSentinel,
      ref: sentinelEnd,
      "data-testid": "sentinelEnd"
    })]
  });
}
function getContainer$1(container) {
  return typeof container === "function" ? container() : container;
}
const Portal = /* @__PURE__ */ reactExports.forwardRef(function Portal2(props, forwardedRef) {
  const {
    children,
    container,
    disablePortal = false
  } = props;
  const [mountNode, setMountNode] = reactExports.useState(null);
  const handleRef = useForkRef(/* @__PURE__ */ reactExports.isValidElement(children) ? children.ref : null, forwardedRef);
  useEnhancedEffect$1(() => {
    if (!disablePortal) {
      setMountNode(getContainer$1(container) || document.body);
    }
  }, [container, disablePortal]);
  useEnhancedEffect$1(() => {
    if (mountNode && !disablePortal) {
      setRef(forwardedRef, mountNode);
      return () => {
        setRef(forwardedRef, null);
      };
    }
    return void 0;
  }, [forwardedRef, mountNode, disablePortal]);
  if (disablePortal) {
    if (/* @__PURE__ */ reactExports.isValidElement(children)) {
      const newProps = {
        ref: handleRef
      };
      return /* @__PURE__ */ reactExports.cloneElement(children, newProps);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
      children
    });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: mountNode ? /* @__PURE__ */ reactDomExports.createPortal(children, mountNode) : mountNode
  });
});
function isOverflowing(container) {
  const doc = ownerDocument(container);
  if (doc.body === container) {
    return ownerWindow(container).innerWidth > doc.documentElement.clientWidth;
  }
  return container.scrollHeight > container.clientHeight;
}
function ariaHidden(element, show) {
  if (show) {
    element.setAttribute("aria-hidden", "true");
  } else {
    element.removeAttribute("aria-hidden");
  }
}
function getPaddingRight(element) {
  return parseInt(ownerWindow(element).getComputedStyle(element).paddingRight, 10) || 0;
}
function isAriaHiddenForbiddenOnElement(element) {
  const forbiddenTagNames = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"];
  const isForbiddenTagName = forbiddenTagNames.indexOf(element.tagName) !== -1;
  const isInputHidden = element.tagName === "INPUT" && element.getAttribute("type") === "hidden";
  return isForbiddenTagName || isInputHidden;
}
function ariaHiddenSiblings(container, mountElement, currentElement, elementsToExclude, show) {
  const blacklist = [mountElement, currentElement, ...elementsToExclude];
  [].forEach.call(container.children, (element) => {
    const isNotExcludedElement = blacklist.indexOf(element) === -1;
    const isNotForbiddenElement = !isAriaHiddenForbiddenOnElement(element);
    if (isNotExcludedElement && isNotForbiddenElement) {
      ariaHidden(element, show);
    }
  });
}
function findIndexOf(items, callback) {
  let idx = -1;
  items.some((item, index) => {
    if (callback(item)) {
      idx = index;
      return true;
    }
    return false;
  });
  return idx;
}
function handleContainer(containerInfo, props) {
  const restoreStyle = [];
  const container = containerInfo.container;
  if (!props.disableScrollLock) {
    if (isOverflowing(container)) {
      const scrollbarSize = getScrollbarSize(ownerDocument(container));
      restoreStyle.push({
        value: container.style.paddingRight,
        property: "padding-right",
        el: container
      });
      container.style.paddingRight = `${getPaddingRight(container) + scrollbarSize}px`;
      const fixedElements2 = ownerDocument(container).querySelectorAll(".mui-fixed");
      [].forEach.call(fixedElements2, (element) => {
        restoreStyle.push({
          value: element.style.paddingRight,
          property: "padding-right",
          el: element
        });
        element.style.paddingRight = `${getPaddingRight(element) + scrollbarSize}px`;
      });
    }
    let scrollContainer;
    if (container.parentNode instanceof DocumentFragment) {
      scrollContainer = ownerDocument(container).body;
    } else {
      const parent = container.parentElement;
      const containerWindow = ownerWindow(container);
      scrollContainer = (parent == null ? void 0 : parent.nodeName) === "HTML" && containerWindow.getComputedStyle(parent).overflowY === "scroll" ? parent : container;
    }
    restoreStyle.push({
      value: scrollContainer.style.overflow,
      property: "overflow",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowX,
      property: "overflow-x",
      el: scrollContainer
    }, {
      value: scrollContainer.style.overflowY,
      property: "overflow-y",
      el: scrollContainer
    });
    scrollContainer.style.overflow = "hidden";
  }
  const restore = () => {
    restoreStyle.forEach(({
      value,
      el: el2,
      property
    }) => {
      if (value) {
        el2.style.setProperty(property, value);
      } else {
        el2.style.removeProperty(property);
      }
    });
  };
  return restore;
}
function getHiddenSiblings(container) {
  const hiddenSiblings = [];
  [].forEach.call(container.children, (element) => {
    if (element.getAttribute("aria-hidden") === "true") {
      hiddenSiblings.push(element);
    }
  });
  return hiddenSiblings;
}
class ModalManager {
  constructor() {
    this.containers = void 0;
    this.modals = void 0;
    this.modals = [];
    this.containers = [];
  }
  add(modal, container) {
    let modalIndex = this.modals.indexOf(modal);
    if (modalIndex !== -1) {
      return modalIndex;
    }
    modalIndex = this.modals.length;
    this.modals.push(modal);
    if (modal.modalRef) {
      ariaHidden(modal.modalRef, false);
    }
    const hiddenSiblings = getHiddenSiblings(container);
    ariaHiddenSiblings(container, modal.mount, modal.modalRef, hiddenSiblings, true);
    const containerIndex = findIndexOf(this.containers, (item) => item.container === container);
    if (containerIndex !== -1) {
      this.containers[containerIndex].modals.push(modal);
      return modalIndex;
    }
    this.containers.push({
      modals: [modal],
      container,
      restore: null,
      hiddenSiblings
    });
    return modalIndex;
  }
  mount(modal, props) {
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    if (!containerInfo.restore) {
      containerInfo.restore = handleContainer(containerInfo, props);
    }
  }
  remove(modal, ariaHiddenState = true) {
    const modalIndex = this.modals.indexOf(modal);
    if (modalIndex === -1) {
      return modalIndex;
    }
    const containerIndex = findIndexOf(this.containers, (item) => item.modals.indexOf(modal) !== -1);
    const containerInfo = this.containers[containerIndex];
    containerInfo.modals.splice(containerInfo.modals.indexOf(modal), 1);
    this.modals.splice(modalIndex, 1);
    if (containerInfo.modals.length === 0) {
      if (containerInfo.restore) {
        containerInfo.restore();
      }
      if (modal.modalRef) {
        ariaHidden(modal.modalRef, ariaHiddenState);
      }
      ariaHiddenSiblings(containerInfo.container, modal.mount, modal.modalRef, containerInfo.hiddenSiblings, false);
      this.containers.splice(containerIndex, 1);
    } else {
      const nextTop = containerInfo.modals[containerInfo.modals.length - 1];
      if (nextTop.modalRef) {
        ariaHidden(nextTop.modalRef, false);
      }
    }
    return modalIndex;
  }
  isTopModal(modal) {
    return this.modals.length > 0 && this.modals[this.modals.length - 1] === modal;
  }
}
function getContainer(container) {
  return typeof container === "function" ? container() : container;
}
function getHasTransition(children) {
  return children ? children.props.hasOwnProperty("in") : false;
}
const defaultManager = new ModalManager();
function useModal(parameters) {
  const {
    container,
    disableEscapeKeyDown = false,
    disableScrollLock = false,
    // @ts-ignore internal logic - Base UI supports the manager as a prop too
    manager = defaultManager,
    closeAfterTransition = false,
    onTransitionEnter,
    onTransitionExited,
    children,
    onClose,
    open,
    rootRef
  } = parameters;
  const modal = reactExports.useRef({});
  const mountNodeRef = reactExports.useRef(null);
  const modalRef = reactExports.useRef(null);
  const handleRef = useForkRef(modalRef, rootRef);
  const [exited, setExited] = reactExports.useState(!open);
  const hasTransition = getHasTransition(children);
  let ariaHiddenProp = true;
  if (parameters["aria-hidden"] === "false" || parameters["aria-hidden"] === false) {
    ariaHiddenProp = false;
  }
  const getDoc = () => ownerDocument(mountNodeRef.current);
  const getModal = () => {
    modal.current.modalRef = modalRef.current;
    modal.current.mount = mountNodeRef.current;
    return modal.current;
  };
  const handleMounted = () => {
    manager.mount(getModal(), {
      disableScrollLock
    });
    if (modalRef.current) {
      modalRef.current.scrollTop = 0;
    }
  };
  const handleOpen = useEventCallback(() => {
    const resolvedContainer = getContainer(container) || getDoc().body;
    manager.add(getModal(), resolvedContainer);
    if (modalRef.current) {
      handleMounted();
    }
  });
  const isTopModal = reactExports.useCallback(() => manager.isTopModal(getModal()), [manager]);
  const handlePortalRef = useEventCallback((node2) => {
    mountNodeRef.current = node2;
    if (!node2) {
      return;
    }
    if (open && isTopModal()) {
      handleMounted();
    } else if (modalRef.current) {
      ariaHidden(modalRef.current, ariaHiddenProp);
    }
  });
  const handleClose = reactExports.useCallback(() => {
    manager.remove(getModal(), ariaHiddenProp);
  }, [ariaHiddenProp, manager]);
  reactExports.useEffect(() => {
    return () => {
      handleClose();
    };
  }, [handleClose]);
  reactExports.useEffect(() => {
    if (open) {
      handleOpen();
    } else if (!hasTransition || !closeAfterTransition) {
      handleClose();
    }
  }, [open, handleClose, hasTransition, closeAfterTransition, handleOpen]);
  const createHandleKeyDown = (otherHandlers) => (event) => {
    var _otherHandlers$onKeyD;
    (_otherHandlers$onKeyD = otherHandlers.onKeyDown) == null || _otherHandlers$onKeyD.call(otherHandlers, event);
    if (event.key !== "Escape" || !isTopModal()) {
      return;
    }
    if (!disableEscapeKeyDown) {
      event.stopPropagation();
      if (onClose) {
        onClose(event, "escapeKeyDown");
      }
    }
  };
  const createHandleBackdropClick = (otherHandlers) => (event) => {
    var _otherHandlers$onClic;
    (_otherHandlers$onClic = otherHandlers.onClick) == null || _otherHandlers$onClic.call(otherHandlers, event);
    if (event.target !== event.currentTarget) {
      return;
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const getRootProps = (otherHandlers = {}) => {
    const propsEventHandlers = extractEventHandlers(parameters);
    delete propsEventHandlers.onTransitionEnter;
    delete propsEventHandlers.onTransitionExited;
    const externalEventHandlers = _extends$1({}, propsEventHandlers, otherHandlers);
    return _extends$1({
      role: "presentation"
    }, externalEventHandlers, {
      onKeyDown: createHandleKeyDown(externalEventHandlers),
      ref: handleRef
    });
  };
  const getBackdropProps = (otherHandlers = {}) => {
    const externalEventHandlers = otherHandlers;
    return _extends$1({
      "aria-hidden": true
    }, externalEventHandlers, {
      onClick: createHandleBackdropClick(externalEventHandlers),
      open
    });
  };
  const getTransitionProps2 = () => {
    const handleEnter = () => {
      setExited(false);
      if (onTransitionEnter) {
        onTransitionEnter();
      }
    };
    const handleExited = () => {
      setExited(true);
      if (onTransitionExited) {
        onTransitionExited();
      }
      if (closeAfterTransition) {
        handleClose();
      }
    };
    return {
      onEnter: createChainedFunction(handleEnter, children == null ? void 0 : children.props.onEnter),
      onExited: createChainedFunction(handleExited, children == null ? void 0 : children.props.onExited)
    };
  };
  return {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    rootRef: handleRef,
    portalRef: handlePortalRef,
    isTopModal,
    exited,
    hasTransition
  };
}
const _excluded$h = ["onChange", "maxRows", "minRows", "style", "value"];
function getStyleValue(value) {
  return parseInt(value, 10) || 0;
}
const styles$3 = {
  shadow: {
    // Visibility needed to hide the extra text area on iPads
    visibility: "hidden",
    // Remove from the content flow
    position: "absolute",
    // Ignore the scrollbar width
    overflow: "hidden",
    height: 0,
    top: 0,
    left: 0,
    // Create a new layer, increase the isolation of the computed values
    transform: "translateZ(0)"
  }
};
function isEmpty$1(obj) {
  return obj === void 0 || obj === null || Object.keys(obj).length === 0 || obj.outerHeightStyle === 0 && !obj.overflow;
}
const TextareaAutosize = /* @__PURE__ */ reactExports.forwardRef(function TextareaAutosize2(props, forwardedRef) {
  const {
    onChange,
    maxRows,
    minRows = 1,
    style: style2,
    value
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$h);
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef(null);
  const handleRef = useForkRef(forwardedRef, inputRef);
  const shadowRef = reactExports.useRef(null);
  const renders = reactExports.useRef(0);
  const [state, setState] = reactExports.useState({
    outerHeightStyle: 0
  });
  const getUpdatedState = reactExports.useCallback(() => {
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    const computedStyle = containerWindow.getComputedStyle(input);
    if (computedStyle.width === "0px") {
      return {
        outerHeightStyle: 0
      };
    }
    const inputShallow = shadowRef.current;
    inputShallow.style.width = computedStyle.width;
    inputShallow.value = input.value || props.placeholder || "x";
    if (inputShallow.value.slice(-1) === "\n") {
      inputShallow.value += " ";
    }
    const boxSizing2 = computedStyle.boxSizing;
    const padding2 = getStyleValue(computedStyle.paddingBottom) + getStyleValue(computedStyle.paddingTop);
    const border2 = getStyleValue(computedStyle.borderBottomWidth) + getStyleValue(computedStyle.borderTopWidth);
    const innerHeight = inputShallow.scrollHeight;
    inputShallow.value = "x";
    const singleRowHeight = inputShallow.scrollHeight;
    let outerHeight = innerHeight;
    if (minRows) {
      outerHeight = Math.max(Number(minRows) * singleRowHeight, outerHeight);
    }
    if (maxRows) {
      outerHeight = Math.min(Number(maxRows) * singleRowHeight, outerHeight);
    }
    outerHeight = Math.max(outerHeight, singleRowHeight);
    const outerHeightStyle = outerHeight + (boxSizing2 === "border-box" ? padding2 + border2 : 0);
    const overflow = Math.abs(outerHeight - innerHeight) <= 1;
    return {
      outerHeightStyle,
      overflow
    };
  }, [maxRows, minRows, props.placeholder]);
  const updateState = (prevState, newState) => {
    const {
      outerHeightStyle,
      overflow
    } = newState;
    if (renders.current < 20 && (outerHeightStyle > 0 && Math.abs((prevState.outerHeightStyle || 0) - outerHeightStyle) > 1 || prevState.overflow !== overflow)) {
      renders.current += 1;
      return {
        overflow,
        outerHeightStyle
      };
    }
    return prevState;
  };
  const syncHeight = reactExports.useCallback(() => {
    const newState = getUpdatedState();
    if (isEmpty$1(newState)) {
      return;
    }
    setState((prevState) => updateState(prevState, newState));
  }, [getUpdatedState]);
  useEnhancedEffect$1(() => {
    const syncHeightWithFlushSync = () => {
      const newState = getUpdatedState();
      if (isEmpty$1(newState)) {
        return;
      }
      reactDomExports.flushSync(() => {
        setState((prevState) => updateState(prevState, newState));
      });
    };
    const handleResize = () => {
      renders.current = 0;
      syncHeightWithFlushSync();
    };
    let rAF;
    const debounceHandleResize = debounce(handleResize);
    const input = inputRef.current;
    const containerWindow = ownerWindow(input);
    containerWindow.addEventListener("resize", debounceHandleResize);
    let resizeObserver;
    if (typeof ResizeObserver !== "undefined") {
      resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(input);
    }
    return () => {
      debounceHandleResize.clear();
      cancelAnimationFrame(rAF);
      containerWindow.removeEventListener("resize", debounceHandleResize);
      if (resizeObserver) {
        resizeObserver.disconnect();
      }
    };
  }, [getUpdatedState]);
  useEnhancedEffect$1(() => {
    syncHeight();
  });
  reactExports.useEffect(() => {
    renders.current = 0;
  }, [value]);
  const handleChange = (event) => {
    renders.current = 0;
    if (!isControlled) {
      syncHeight();
    }
    if (onChange) {
      onChange(event);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx("textarea", _extends$1({
      value,
      onChange: handleChange,
      ref: handleRef,
      rows: minRows,
      style: _extends$1({
        height: state.outerHeightStyle,
        // Need a large enough difference to allow scrolling.
        // This prevents infinite rendering loop.
        overflow: state.overflow ? "hidden" : void 0
      }, style2)
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx("textarea", {
      "aria-hidden": true,
      className: props.className,
      readOnly: true,
      ref: shadowRef,
      tabIndex: -1,
      style: _extends$1({}, styles$3.shadow, style2, {
        paddingTop: 0,
        paddingBottom: 0
      })
    })]
  });
});
function formControlState({
  props,
  states,
  muiFormControl
}) {
  return states.reduce((acc, state) => {
    acc[state] = props[state];
    if (muiFormControl) {
      if (typeof props[state] === "undefined") {
        acc[state] = muiFormControl[state];
      }
    }
    return acc;
  }, {});
}
const FormControlContext = /* @__PURE__ */ reactExports.createContext(void 0);
const FormControlContext$1 = FormControlContext;
function useFormControl() {
  return reactExports.useContext(FormControlContext$1);
}
function GlobalStyles(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles$1, _extends$1({}, props, {
    defaultTheme: defaultTheme$1,
    themeId: THEME_ID
  }));
}
function hasValue(value) {
  return value != null && !(Array.isArray(value) && value.length === 0);
}
function isFilled(obj, SSR = false) {
  return obj && (hasValue(obj.value) && obj.value !== "" || SSR && hasValue(obj.defaultValue) && obj.defaultValue !== "");
}
function getInputBaseUtilityClass(slot) {
  return generateUtilityClass("MuiInputBase", slot);
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
const inputBaseClasses$1 = inputBaseClasses;
const _excluded$g = ["aria-describedby", "autoComplete", "autoFocus", "className", "color", "components", "componentsProps", "defaultValue", "disabled", "disableInjectingGlobalStyles", "endAdornment", "error", "fullWidth", "id", "inputComponent", "inputProps", "inputRef", "margin", "maxRows", "minRows", "multiline", "name", "onBlur", "onChange", "onClick", "onFocus", "onKeyDown", "onKeyUp", "placeholder", "readOnly", "renderSuffix", "rows", "size", "slotProps", "slots", "startAdornment", "type", "value"];
const rootOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.formControl && styles2.formControl, ownerState.startAdornment && styles2.adornedStart, ownerState.endAdornment && styles2.adornedEnd, ownerState.error && styles2.error, ownerState.size === "small" && styles2.sizeSmall, ownerState.multiline && styles2.multiline, ownerState.color && styles2[`color${capitalize(ownerState.color)}`], ownerState.fullWidth && styles2.fullWidth, ownerState.hiddenLabel && styles2.hiddenLabel];
};
const inputOverridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.input, ownerState.size === "small" && styles2.inputSizeSmall, ownerState.multiline && styles2.inputMultiline, ownerState.type === "search" && styles2.inputTypeSearch, ownerState.startAdornment && styles2.inputAdornedStart, ownerState.endAdornment && styles2.inputAdornedEnd, ownerState.hiddenLabel && styles2.inputHiddenLabel];
};
const useUtilityClasses$c = (ownerState) => {
  const {
    classes: classes2,
    color: color2,
    disabled,
    error,
    endAdornment,
    focused,
    formControl,
    fullWidth,
    hiddenLabel,
    multiline,
    readOnly,
    size,
    startAdornment,
    type
  } = ownerState;
  const slots = {
    root: ["root", `color${capitalize(color2)}`, disabled && "disabled", error && "error", fullWidth && "fullWidth", focused && "focused", formControl && "formControl", size && size !== "medium" && `size${capitalize(size)}`, multiline && "multiline", startAdornment && "adornedStart", endAdornment && "adornedEnd", hiddenLabel && "hiddenLabel", readOnly && "readOnly"],
    input: ["input", disabled && "disabled", type === "search" && "inputTypeSearch", multiline && "inputMultiline", size === "small" && "inputSizeSmall", hiddenLabel && "inputHiddenLabel", startAdornment && "inputAdornedStart", endAdornment && "inputAdornedEnd", readOnly && "readOnly"]
  };
  return composeClasses(slots, getInputBaseUtilityClass, classes2);
};
const InputBaseRoot = styled$1("div", {
  name: "MuiInputBase",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme,
  ownerState
}) => _extends$1({}, theme.typography.body1, {
  color: (theme.vars || theme).palette.text.primary,
  lineHeight: "1.4375em",
  // 23px
  boxSizing: "border-box",
  // Prevent padding issue with fullWidth.
  position: "relative",
  cursor: "text",
  display: "inline-flex",
  alignItems: "center",
  [`&.${inputBaseClasses$1.disabled}`]: {
    color: (theme.vars || theme).palette.text.disabled,
    cursor: "default"
  }
}, ownerState.multiline && _extends$1({
  padding: "4px 0 5px"
}, ownerState.size === "small" && {
  paddingTop: 1
}), ownerState.fullWidth && {
  width: "100%"
}));
const InputBaseComponent = styled$1("input", {
  name: "MuiInputBase",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => {
  const light2 = theme.palette.mode === "light";
  const placeholder = _extends$1({
    color: "currentColor"
  }, theme.vars ? {
    opacity: theme.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  }, {
    transition: theme.transitions.create("opacity", {
      duration: theme.transitions.duration.shorter
    })
  });
  const placeholderHidden = {
    opacity: "0 !important"
  };
  const placeholderVisible = theme.vars ? {
    opacity: theme.vars.opacity.inputPlaceholder
  } : {
    opacity: light2 ? 0.42 : 0.5
  };
  return _extends$1({
    font: "inherit",
    letterSpacing: "inherit",
    color: "currentColor",
    padding: "4px 0 5px",
    border: 0,
    boxSizing: "content-box",
    background: "none",
    height: "1.4375em",
    // Reset 23pxthe native input line-height
    margin: 0,
    // Reset for Safari
    WebkitTapHighlightColor: "transparent",
    display: "block",
    // Make the flex item shrink with Firefox
    minWidth: 0,
    width: "100%",
    // Fix IE11 width issue
    animationName: "mui-auto-fill-cancel",
    animationDuration: "10ms",
    "&::-webkit-input-placeholder": placeholder,
    "&::-moz-placeholder": placeholder,
    // Firefox 19+
    "&:-ms-input-placeholder": placeholder,
    // IE11
    "&::-ms-input-placeholder": placeholder,
    // Edge
    "&:focus": {
      outline: 0
    },
    // Reset Firefox invalid required input style
    "&:invalid": {
      boxShadow: "none"
    },
    "&::-webkit-search-decoration": {
      // Remove the padding when type=search.
      WebkitAppearance: "none"
    },
    // Show and hide the placeholder logic
    [`label[data-shrink=false] + .${inputBaseClasses$1.formControl} &`]: {
      "&::-webkit-input-placeholder": placeholderHidden,
      "&::-moz-placeholder": placeholderHidden,
      // Firefox 19+
      "&:-ms-input-placeholder": placeholderHidden,
      // IE11
      "&::-ms-input-placeholder": placeholderHidden,
      // Edge
      "&:focus::-webkit-input-placeholder": placeholderVisible,
      "&:focus::-moz-placeholder": placeholderVisible,
      // Firefox 19+
      "&:focus:-ms-input-placeholder": placeholderVisible,
      // IE11
      "&:focus::-ms-input-placeholder": placeholderVisible
      // Edge
    },
    [`&.${inputBaseClasses$1.disabled}`]: {
      opacity: 1,
      // Reset iOS opacity
      WebkitTextFillColor: (theme.vars || theme).palette.text.disabled
      // Fix opacity Safari bug
    },
    "&:-webkit-autofill": {
      animationDuration: "5000s",
      animationName: "mui-auto-fill"
    }
  }, ownerState.size === "small" && {
    paddingTop: 1
  }, ownerState.multiline && {
    height: "auto",
    resize: "none",
    padding: 0,
    paddingTop: 0
  }, ownerState.type === "search" && {
    // Improve type search style.
    MozAppearance: "textfield"
  });
});
const inputGlobalStyles = /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyles, {
  styles: {
    "@keyframes mui-auto-fill": {
      from: {
        display: "block"
      }
    },
    "@keyframes mui-auto-fill-cancel": {
      from: {
        display: "block"
      }
    }
  }
});
const InputBase = /* @__PURE__ */ reactExports.forwardRef(function InputBase2(inProps, ref) {
  var _slotProps$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiInputBase"
  });
  const {
    "aria-describedby": ariaDescribedby,
    autoComplete,
    autoFocus,
    className,
    components = {},
    componentsProps = {},
    defaultValue,
    disabled,
    disableInjectingGlobalStyles,
    endAdornment,
    fullWidth = false,
    id: id2,
    inputComponent = "input",
    inputProps: inputPropsProp = {},
    inputRef: inputRefProp,
    maxRows,
    minRows,
    multiline = false,
    name,
    onBlur,
    onChange,
    onClick: onClick2,
    onFocus: onFocus2,
    onKeyDown,
    onKeyUp,
    placeholder,
    readOnly,
    renderSuffix,
    rows,
    slotProps = {},
    slots = {},
    startAdornment,
    type = "text",
    value: valueProp
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$g);
  const value = inputPropsProp.value != null ? inputPropsProp.value : valueProp;
  const {
    current: isControlled
  } = reactExports.useRef(value != null);
  const inputRef = reactExports.useRef();
  const handleInputRefWarning = reactExports.useCallback((instance) => {
  }, []);
  const handleInputRef = useForkRef(inputRef, inputRefProp, inputPropsProp.ref, handleInputRefWarning);
  const [focused, setFocused] = reactExports.useState(false);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
  });
  fcs.focused = muiFormControl ? muiFormControl.focused : focused;
  reactExports.useEffect(() => {
    if (!muiFormControl && disabled && focused) {
      setFocused(false);
      if (onBlur) {
        onBlur();
      }
    }
  }, [muiFormControl, disabled, focused, onBlur]);
  const onFilled = muiFormControl && muiFormControl.onFilled;
  const onEmpty = muiFormControl && muiFormControl.onEmpty;
  const checkDirty = reactExports.useCallback((obj) => {
    if (isFilled(obj)) {
      if (onFilled) {
        onFilled();
      }
    } else if (onEmpty) {
      onEmpty();
    }
  }, [onFilled, onEmpty]);
  useEnhancedEffect$1(() => {
    if (isControlled) {
      checkDirty({
        value
      });
    }
  }, [value, checkDirty, isControlled]);
  const handleFocus = (event) => {
    if (fcs.disabled) {
      event.stopPropagation();
      return;
    }
    if (onFocus2) {
      onFocus2(event);
    }
    if (inputPropsProp.onFocus) {
      inputPropsProp.onFocus(event);
    }
    if (muiFormControl && muiFormControl.onFocus) {
      muiFormControl.onFocus(event);
    } else {
      setFocused(true);
    }
  };
  const handleBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (inputPropsProp.onBlur) {
      inputPropsProp.onBlur(event);
    }
    if (muiFormControl && muiFormControl.onBlur) {
      muiFormControl.onBlur(event);
    } else {
      setFocused(false);
    }
  };
  const handleChange = (event, ...args) => {
    if (!isControlled) {
      const element = event.target || inputRef.current;
      if (element == null) {
        throw new Error(formatMuiErrorMessage(1));
      }
      checkDirty({
        value: element.value
      });
    }
    if (inputPropsProp.onChange) {
      inputPropsProp.onChange(event, ...args);
    }
    if (onChange) {
      onChange(event, ...args);
    }
  };
  reactExports.useEffect(() => {
    checkDirty(inputRef.current);
  }, []);
  const handleClick = (event) => {
    if (inputRef.current && event.currentTarget === event.target) {
      inputRef.current.focus();
    }
    if (onClick2) {
      onClick2(event);
    }
  };
  let InputComponent = inputComponent;
  let inputProps = inputPropsProp;
  if (multiline && InputComponent === "input") {
    if (rows) {
      inputProps = _extends$1({
        type: void 0,
        minRows: rows,
        maxRows: rows
      }, inputProps);
    } else {
      inputProps = _extends$1({
        type: void 0,
        maxRows,
        minRows
      }, inputProps);
    }
    InputComponent = TextareaAutosize;
  }
  const handleAutoFill = (event) => {
    checkDirty(event.animationName === "mui-auto-fill-cancel" ? inputRef.current : {
      value: "x"
    });
  };
  reactExports.useEffect(() => {
    if (muiFormControl) {
      muiFormControl.setAdornedStart(Boolean(startAdornment));
    }
  }, [muiFormControl, startAdornment]);
  const ownerState = _extends$1({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    endAdornment,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    startAdornment,
    type
  });
  const classes2 = useUtilityClasses$c(ownerState);
  const Root = slots.root || components.Root || InputBaseRoot;
  const rootProps = slotProps.root || componentsProps.root || {};
  const Input3 = slots.input || components.Input || InputBaseComponent;
  inputProps = _extends$1({}, inputProps, (_slotProps$input = slotProps.input) != null ? _slotProps$input : componentsProps.input);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [!disableInjectingGlobalStyles && inputGlobalStyles, /* @__PURE__ */ jsxRuntimeExports.jsxs(Root, _extends$1({}, rootProps, !isHostComponent(Root) && {
      ownerState: _extends$1({}, ownerState, rootProps.ownerState)
    }, {
      ref,
      onClick: handleClick
    }, other, {
      className: clsx(classes2.root, rootProps.className, className, readOnly && "MuiInputBase-readOnly"),
      children: [startAdornment, /* @__PURE__ */ jsxRuntimeExports.jsx(FormControlContext$1.Provider, {
        value: null,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input3, _extends$1({
          ownerState,
          "aria-invalid": fcs.error,
          "aria-describedby": ariaDescribedby,
          autoComplete,
          autoFocus,
          defaultValue,
          disabled: fcs.disabled,
          id: id2,
          onAnimationStart: handleAutoFill,
          name,
          placeholder,
          readOnly,
          required: fcs.required,
          rows,
          value,
          onKeyDown,
          onKeyUp,
          type
        }, inputProps, !isHostComponent(Input3) && {
          as: InputComponent,
          ownerState: _extends$1({}, ownerState, inputProps.ownerState)
        }, {
          ref: handleInputRef,
          className: clsx(classes2.input, inputProps.className, readOnly && "MuiInputBase-readOnly"),
          onBlur: handleBlur,
          onChange: handleChange,
          onFocus: handleFocus
        }))
      }), endAdornment, renderSuffix ? renderSuffix(_extends$1({}, fcs, {
        startAdornment
      })) : null]
    }))]
  });
});
const InputBase$1 = InputBase;
function getInputUtilityClass(slot) {
  return generateUtilityClass("MuiInput", slot);
}
const inputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiInput", ["root", "underline", "input"]));
const inputClasses$1 = inputClasses;
function getOutlinedInputUtilityClass(slot) {
  return generateUtilityClass("MuiOutlinedInput", slot);
}
const outlinedInputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"]));
const outlinedInputClasses$1 = outlinedInputClasses;
function getFilledInputUtilityClass(slot) {
  return generateUtilityClass("MuiFilledInput", slot);
}
const filledInputClasses = _extends$1({}, inputBaseClasses$1, generateUtilityClasses("MuiFilledInput", ["root", "underline", "input"]));
const filledInputClasses$1 = filledInputClasses;
const ArrowDropDownIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M7 10l5 5 5-5z"
}), "ArrowDropDown");
const _excluded$f = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
const styles$2 = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  }
};
const Fade = /* @__PURE__ */ reactExports.forwardRef(function Fade2(props, ref) {
  const theme = useTheme();
  const defaultTimeout = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = defaultTimeout,
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$f);
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const transitionProps = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    node2.style.webkitTransition = theme.transitions.create("opacity", transitionProps);
    node2.style.transition = theme.transitions.create("opacity", transitionProps);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
        style: _extends$1({
          opacity: 0,
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$2[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
const Fade$1 = Fade;
function getBackdropUtilityClass(slot) {
  return generateUtilityClass("MuiBackdrop", slot);
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const _excluded$e = ["children", "className", "component", "components", "componentsProps", "invisible", "open", "slotProps", "slots", "TransitionComponent", "transitionDuration"];
const useUtilityClasses$b = (ownerState) => {
  const {
    classes: classes2,
    invisible
  } = ownerState;
  const slots = {
    root: ["root", invisible && "invisible"]
  };
  return composeClasses(slots, getBackdropUtilityClass, classes2);
};
const BackdropRoot = styled$1("div", {
  name: "MuiBackdrop",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, ownerState.invisible && styles2.invisible];
  }
})(({
  ownerState
}) => _extends$1({
  position: "fixed",
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  right: 0,
  bottom: 0,
  top: 0,
  left: 0,
  backgroundColor: "rgba(0, 0, 0, 0.5)",
  WebkitTapHighlightColor: "transparent"
}, ownerState.invisible && {
  backgroundColor: "transparent"
}));
const Backdrop = /* @__PURE__ */ reactExports.forwardRef(function Backdrop2(inProps, ref) {
  var _slotProps$root, _ref, _slots$root;
  const props = useThemeProps({
    props: inProps,
    name: "MuiBackdrop"
  });
  const {
    children,
    className,
    component = "div",
    components = {},
    componentsProps = {},
    invisible = false,
    open,
    slotProps = {},
    slots = {},
    TransitionComponent = Fade$1,
    transitionDuration
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$e);
  const ownerState = _extends$1({}, props, {
    component,
    invisible
  });
  const classes2 = useUtilityClasses$b(ownerState);
  const rootSlotProps = (_slotProps$root = slotProps.root) != null ? _slotProps$root : componentsProps.root;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
    in: open,
    timeout: transitionDuration
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropRoot, _extends$1({
      "aria-hidden": true
    }, rootSlotProps, {
      as: (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : component,
      className: clsx(classes2.root, className, rootSlotProps == null ? void 0 : rootSlotProps.className),
      ownerState: _extends$1({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
      classes: classes2,
      ref,
      children
    }))
  }));
});
const Backdrop$1 = Backdrop;
function getModalUtilityClass(slot) {
  return generateUtilityClass("MuiModal", slot);
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const _excluded$d = ["BackdropComponent", "BackdropProps", "classes", "className", "closeAfterTransition", "children", "container", "component", "components", "componentsProps", "disableAutoFocus", "disableEnforceFocus", "disableEscapeKeyDown", "disablePortal", "disableRestoreFocus", "disableScrollLock", "hideBackdrop", "keepMounted", "onBackdropClick", "onClose", "onTransitionEnter", "onTransitionExited", "open", "slotProps", "slots", "theme"];
const useUtilityClasses$a = (ownerState) => {
  const {
    open,
    exited,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", !open && exited && "hidden"],
    backdrop: ["backdrop"]
  };
  return composeClasses(slots, getModalUtilityClass, classes2);
};
const ModalRoot = styled$1("div", {
  name: "MuiModal",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.open && ownerState.exited && styles2.hidden];
  }
})(({
  theme,
  ownerState
}) => _extends$1({
  position: "fixed",
  zIndex: (theme.vars || theme).zIndex.modal,
  right: 0,
  bottom: 0,
  top: 0,
  left: 0
}, !ownerState.open && ownerState.exited && {
  visibility: "hidden"
}));
const ModalBackdrop = styled$1(Backdrop$1, {
  name: "MuiModal",
  slot: "Backdrop",
  overridesResolver: (props, styles2) => {
    return styles2.backdrop;
  }
})({
  zIndex: -1
});
const Modal = /* @__PURE__ */ reactExports.forwardRef(function Modal2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$backdrop, _slotProps$root, _slotProps$backdrop;
  const props = useThemeProps({
    name: "MuiModal",
    props: inProps
  });
  const {
    BackdropComponent = ModalBackdrop,
    BackdropProps,
    className,
    closeAfterTransition = false,
    children,
    container,
    component,
    components = {},
    componentsProps = {},
    disableAutoFocus = false,
    disableEnforceFocus = false,
    disableEscapeKeyDown = false,
    disablePortal = false,
    disableRestoreFocus = false,
    disableScrollLock = false,
    hideBackdrop = false,
    keepMounted = false,
    onBackdropClick,
    open,
    slotProps,
    slots
    // eslint-disable-next-line react/prop-types
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$d);
  const propsWithDefaults = _extends$1({}, props, {
    closeAfterTransition,
    disableAutoFocus,
    disableEnforceFocus,
    disableEscapeKeyDown,
    disablePortal,
    disableRestoreFocus,
    disableScrollLock,
    hideBackdrop,
    keepMounted
  });
  const {
    getRootProps,
    getBackdropProps,
    getTransitionProps: getTransitionProps2,
    portalRef,
    isTopModal,
    exited,
    hasTransition
  } = useModal(_extends$1({}, propsWithDefaults, {
    rootRef: ref
  }));
  const ownerState = _extends$1({}, propsWithDefaults, {
    exited
  });
  const classes2 = useUtilityClasses$a(ownerState);
  const childProps = {};
  if (children.props.tabIndex === void 0) {
    childProps.tabIndex = "-1";
  }
  if (hasTransition) {
    const {
      onEnter,
      onExited
    } = getTransitionProps2();
    childProps.onEnter = onEnter;
    childProps.onExited = onExited;
  }
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : ModalRoot;
  const BackdropSlot = (_ref2 = (_slots$backdrop = slots == null ? void 0 : slots.backdrop) != null ? _slots$backdrop : components.Backdrop) != null ? _ref2 : BackdropComponent;
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const backdropSlotProps = (_slotProps$backdrop = slotProps == null ? void 0 : slotProps.backdrop) != null ? _slotProps$backdrop : componentsProps.backdrop;
  const rootProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    getSlotProps: getRootProps,
    additionalProps: {
      ref,
      as: component
    },
    ownerState,
    className: clsx(className, rootSlotProps == null ? void 0 : rootSlotProps.className, classes2 == null ? void 0 : classes2.root, !ownerState.open && ownerState.exited && (classes2 == null ? void 0 : classes2.hidden))
  });
  const backdropProps = useSlotProps({
    elementType: BackdropSlot,
    externalSlotProps: backdropSlotProps,
    additionalProps: BackdropProps,
    getSlotProps: (otherHandlers) => {
      return getBackdropProps(_extends$1({}, otherHandlers, {
        onClick: (e2) => {
          if (onBackdropClick) {
            onBackdropClick(e2);
          }
          if (otherHandlers != null && otherHandlers.onClick) {
            otherHandlers.onClick(e2);
          }
        }
      }));
    },
    className: clsx(backdropSlotProps == null ? void 0 : backdropSlotProps.className, BackdropProps == null ? void 0 : BackdropProps.className, classes2 == null ? void 0 : classes2.backdrop),
    ownerState
  });
  if (!keepMounted && !open && (!hasTransition || exited)) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, {
    ref: portalRef,
    container,
    disablePortal,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(RootSlot, _extends$1({}, rootProps, {
      children: [!hideBackdrop && BackdropComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(BackdropSlot, _extends$1({}, backdropProps)) : null, /* @__PURE__ */ jsxRuntimeExports.jsx(FocusTrap, {
        disableEnforceFocus,
        disableAutoFocus,
        disableRestoreFocus,
        isEnabled: isTopModal,
        open,
        children: /* @__PURE__ */ reactExports.cloneElement(children, childProps)
      })]
    }))
  });
});
const Modal$1 = Modal;
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"]);
const dividerClasses$1 = dividerClasses;
const _excluded$c = ["disableUnderline", "components", "componentsProps", "fullWidth", "hiddenLabel", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes: classes2,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getFilledInputUtilityClass, classes2);
  return _extends$1({}, classes2, composedClasses);
};
const FilledInputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiFilledInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme,
  ownerState
}) => {
  var _palette;
  const light2 = theme.palette.mode === "light";
  const bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  const backgroundColor2 = light2 ? "rgba(0, 0, 0, 0.06)" : "rgba(255, 255, 255, 0.09)";
  const hoverBackground = light2 ? "rgba(0, 0, 0, 0.09)" : "rgba(255, 255, 255, 0.13)";
  const disabledBackground = light2 ? "rgba(0, 0, 0, 0.12)" : "rgba(255, 255, 255, 0.12)";
  return _extends$1({
    position: "relative",
    backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2,
    borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
    borderTopRightRadius: (theme.vars || theme).shape.borderRadius,
    transition: theme.transitions.create("background-color", {
      duration: theme.transitions.duration.shorter,
      easing: theme.transitions.easing.easeOut
    }),
    "&:hover": {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.hoverBg : hoverBackground,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
      }
    },
    [`&.${filledInputClasses$1.focused}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.bg : backgroundColor2
    },
    [`&.${filledInputClasses$1.disabled}`]: {
      backgroundColor: theme.vars ? theme.vars.palette.FilledInput.disabledBg : disabledBackground
    }
  }, !ownerState.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(_palette = (theme.vars || theme).palette[ownerState.color || "primary"]) == null ? void 0 : _palette.main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme.transitions.create("transform", {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${filledInputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${filledInputClasses$1.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (theme.vars || theme).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})` : bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme.transitions.create("border-bottom-color", {
        duration: theme.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${filledInputClasses$1.disabled}, .${filledInputClasses$1.error}):before`]: {
      borderBottom: `1px solid ${(theme.vars || theme).palette.text.primary}`
    },
    [`&.${filledInputClasses$1.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  }, ownerState.startAdornment && {
    paddingLeft: 12
  }, ownerState.endAdornment && {
    paddingRight: 12
  }, ownerState.multiline && _extends$1({
    padding: "25px 12px 8px"
  }, ownerState.size === "small" && {
    paddingTop: 21,
    paddingBottom: 4
  }, ownerState.hiddenLabel && {
    paddingTop: 16,
    paddingBottom: 17
  }));
});
const FilledInputInput = styled$1(InputBaseComponent, {
  name: "MuiFilledInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => _extends$1({
  paddingTop: 25,
  paddingRight: 12,
  paddingBottom: 8,
  paddingLeft: 12
}, !theme.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
    caretColor: theme.palette.mode === "light" ? null : "#fff",
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  }
}, theme.vars && {
  "&:-webkit-autofill": {
    borderTopLeftRadius: "inherit",
    borderTopRightRadius: "inherit"
  },
  [theme.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  paddingTop: 21,
  paddingBottom: 4
}, ownerState.hiddenLabel && {
  paddingTop: 16,
  paddingBottom: 17
}, ownerState.multiline && {
  paddingTop: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  paddingRight: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}, ownerState.hiddenLabel && ownerState.size === "small" && {
  paddingTop: 8,
  paddingBottom: 9
}));
const FilledInput = /* @__PURE__ */ reactExports.forwardRef(function FilledInput2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiFilledInput"
  });
  const {
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    // declare here to prevent spreading to DOM
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$c);
  const ownerState = _extends$1({}, props, {
    fullWidth,
    inputComponent,
    multiline,
    type
  });
  const classes2 = useUtilityClasses$9(props);
  const filledInputComponentsProps = {
    root: {
      ownerState
    },
    input: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, filledInputComponentsProps) : filledInputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : FilledInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : FilledInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes: classes2
  }));
});
FilledInput.muiName = "Input";
const FilledInput$1 = FilledInput;
const _excluded$b = ["addEndListener", "appear", "children", "easing", "in", "onEnter", "onEntered", "onEntering", "onExit", "onExited", "onExiting", "style", "timeout", "TransitionComponent"];
function getScale(value) {
  return `scale(${value}, ${value ** 2})`;
}
const styles$1 = {
  entering: {
    opacity: 1,
    transform: getScale(1)
  },
  entered: {
    opacity: 1,
    transform: "none"
  }
};
const isWebKit154 = typeof navigator !== "undefined" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent);
const Grow = /* @__PURE__ */ reactExports.forwardRef(function Grow2(props, ref) {
  const {
    addEndListener,
    appear = true,
    children,
    easing: easing2,
    in: inProp,
    onEnter,
    onEntered,
    onEntering,
    onExit,
    onExited,
    onExiting,
    style: style2,
    timeout = "auto",
    // eslint-disable-next-line react/prop-types
    TransitionComponent = Transition$1
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$b);
  const timer = reactExports.useRef();
  const autoTimeout = reactExports.useRef();
  const theme = useTheme();
  const nodeRef = reactExports.useRef(null);
  const handleRef = useForkRef(nodeRef, children.ref, ref);
  const normalizedTransitionCallback = (callback) => (maybeIsAppearing) => {
    if (callback) {
      const node2 = nodeRef.current;
      if (maybeIsAppearing === void 0) {
        callback(node2);
      } else {
        callback(node2, maybeIsAppearing);
      }
    }
  };
  const handleEntering = normalizedTransitionCallback(onEntering);
  const handleEnter = normalizedTransitionCallback((node2, isAppearing) => {
    reflow(node2);
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "enter"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay,
      easing: transitionTimingFunction
    })].join(",");
    if (onEnter) {
      onEnter(node2, isAppearing);
    }
  });
  const handleEntered = normalizedTransitionCallback(onEntered);
  const handleExiting = normalizedTransitionCallback(onExiting);
  const handleExit = normalizedTransitionCallback((node2) => {
    const {
      duration: transitionDuration,
      delay,
      easing: transitionTimingFunction
    } = getTransitionProps({
      style: style2,
      timeout,
      easing: easing2
    }, {
      mode: "exit"
    });
    let duration2;
    if (timeout === "auto") {
      duration2 = theme.transitions.getAutoHeightDuration(node2.clientHeight);
      autoTimeout.current = duration2;
    } else {
      duration2 = transitionDuration;
    }
    node2.style.transition = [theme.transitions.create("opacity", {
      duration: duration2,
      delay
    }), theme.transitions.create("transform", {
      duration: isWebKit154 ? duration2 : duration2 * 0.666,
      delay: isWebKit154 ? delay : delay || duration2 * 0.333,
      easing: transitionTimingFunction
    })].join(",");
    node2.style.opacity = 0;
    node2.style.transform = getScale(0.75);
    if (onExit) {
      onExit(node2);
    }
  });
  const handleExited = normalizedTransitionCallback(onExited);
  const handleAddEndListener = (next2) => {
    if (timeout === "auto") {
      timer.current = setTimeout(next2, autoTimeout.current || 0);
    }
    if (addEndListener) {
      addEndListener(nodeRef.current, next2);
    }
  };
  reactExports.useEffect(() => {
    return () => {
      clearTimeout(timer.current);
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
    appear,
    in: inProp,
    nodeRef,
    onEnter: handleEnter,
    onEntered: handleEntered,
    onEntering: handleEntering,
    onExit: handleExit,
    onExited: handleExited,
    onExiting: handleExiting,
    addEndListener: handleAddEndListener,
    timeout: timeout === "auto" ? null : timeout
  }, other, {
    children: (state, childProps) => {
      return /* @__PURE__ */ reactExports.cloneElement(children, _extends$1({
        style: _extends$1({
          opacity: 0,
          transform: getScale(0.75),
          visibility: state === "exited" && !inProp ? "hidden" : void 0
        }, styles$1[state], style2, children.props.style),
        ref: handleRef
      }, childProps));
    }
  }));
});
Grow.muiSupportAuto = true;
const Grow$1 = Grow;
function useMediaQueryOld(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const [match2, setMatch] = reactExports.useState(() => {
    if (noSsr && matchMedia) {
      return matchMedia(query).matches;
    }
    if (ssrMatchMedia) {
      return ssrMatchMedia(query).matches;
    }
    return defaultMatches;
  });
  useEnhancedEffect$1(() => {
    let active = true;
    if (!matchMedia) {
      return void 0;
    }
    const queryList = matchMedia(query);
    const updateMatch = () => {
      if (active) {
        setMatch(queryList.matches);
      }
    };
    updateMatch();
    queryList.addListener(updateMatch);
    return () => {
      active = false;
      queryList.removeListener(updateMatch);
    };
  }, [query, matchMedia]);
  return match2;
}
const maybeReactUseSyncExternalStore = React$1["useSyncExternalStore"];
function useMediaQueryNew(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr) {
  const getDefaultSnapshot = reactExports.useCallback(() => defaultMatches, [defaultMatches]);
  const getServerSnapshot = reactExports.useMemo(() => {
    if (noSsr && matchMedia) {
      return () => matchMedia(query).matches;
    }
    if (ssrMatchMedia !== null) {
      const {
        matches: matches2
      } = ssrMatchMedia(query);
      return () => matches2;
    }
    return getDefaultSnapshot;
  }, [getDefaultSnapshot, query, ssrMatchMedia, noSsr, matchMedia]);
  const [getSnapshot, subscribe] = reactExports.useMemo(() => {
    if (matchMedia === null) {
      return [getDefaultSnapshot, () => () => {
      }];
    }
    const mediaQueryList = matchMedia(query);
    return [() => mediaQueryList.matches, (notify) => {
      mediaQueryList.addListener(notify);
      return () => {
        mediaQueryList.removeListener(notify);
      };
    }];
  }, [getDefaultSnapshot, matchMedia, query]);
  const match2 = maybeReactUseSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
  return match2;
}
function useMediaQuery$1(queryInput, options = {}) {
  const theme = useTheme$2();
  const supportMatchMedia = typeof window !== "undefined" && typeof window.matchMedia !== "undefined";
  const {
    defaultMatches = false,
    matchMedia = supportMatchMedia ? window.matchMedia : null,
    ssrMatchMedia = null,
    noSsr = false
  } = getThemeProps({
    name: "MuiUseMediaQuery",
    props: options,
    theme
  });
  let query = typeof queryInput === "function" ? queryInput(theme) : queryInput;
  query = query.replace(/^@media( ?)/m, "");
  const useMediaQueryImplementation = maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld;
  const match2 = useMediaQueryImplementation(query, defaultMatches, matchMedia, ssrMatchMedia, noSsr);
  return match2;
}
const _excluded$a = ["disableUnderline", "components", "componentsProps", "fullWidth", "inputComponent", "multiline", "slotProps", "slots", "type"];
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes: classes2,
    disableUnderline
  } = ownerState;
  const slots = {
    root: ["root", !disableUnderline && "underline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getInputUtilityClass, classes2);
  return _extends$1({}, classes2, composedClasses);
};
const InputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiInput",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [...rootOverridesResolver(props, styles2), !ownerState.disableUnderline && styles2.underline];
  }
})(({
  theme,
  ownerState
}) => {
  const light2 = theme.palette.mode === "light";
  let bottomLineColor = light2 ? "rgba(0, 0, 0, 0.42)" : "rgba(255, 255, 255, 0.7)";
  if (theme.vars) {
    bottomLineColor = `rgba(${theme.vars.palette.common.onBackgroundChannel} / ${theme.vars.opacity.inputUnderline})`;
  }
  return _extends$1({
    position: "relative"
  }, ownerState.formControl && {
    "label + &": {
      marginTop: 16
    }
  }, !ownerState.disableUnderline && {
    "&:after": {
      borderBottom: `2px solid ${(theme.vars || theme).palette[ownerState.color].main}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '""',
      position: "absolute",
      right: 0,
      transform: "scaleX(0)",
      transition: theme.transitions.create("transform", {
        duration: theme.transitions.duration.shorter,
        easing: theme.transitions.easing.easeOut
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&.${inputClasses$1.focused}:after`]: {
      // translateX(0) is a workaround for Safari transform scale bug
      // See https://github.com/mui/material-ui/issues/31766
      transform: "scaleX(1) translateX(0)"
    },
    [`&.${inputClasses$1.error}`]: {
      "&:before, &:after": {
        borderBottomColor: (theme.vars || theme).palette.error.main
      }
    },
    "&:before": {
      borderBottom: `1px solid ${bottomLineColor}`,
      left: 0,
      bottom: 0,
      // Doing the other way around crash on IE11 "''" https://github.com/cssinjs/jss/issues/242
      content: '"\\00a0"',
      position: "absolute",
      right: 0,
      transition: theme.transitions.create("border-bottom-color", {
        duration: theme.transitions.duration.shorter
      }),
      pointerEvents: "none"
      // Transparent to the hover style.
    },
    [`&:hover:not(.${inputClasses$1.disabled}, .${inputClasses$1.error}):before`]: {
      borderBottom: `2px solid ${(theme.vars || theme).palette.text.primary}`,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        borderBottom: `1px solid ${bottomLineColor}`
      }
    },
    [`&.${inputClasses$1.disabled}:before`]: {
      borderBottomStyle: "dotted"
    }
  });
});
const InputInput = styled$1(InputBaseComponent, {
  name: "MuiInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})({});
const Input$2 = /* @__PURE__ */ reactExports.forwardRef(function Input(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input;
  const props = useThemeProps({
    props: inProps,
    name: "MuiInput"
  });
  const {
    disableUnderline,
    components = {},
    componentsProps: componentsPropsProp,
    fullWidth = false,
    inputComponent = "input",
    multiline = false,
    slotProps,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$a);
  const classes2 = useUtilityClasses$8(props);
  const ownerState = {
    disableUnderline
  };
  const inputComponentsProps = {
    root: {
      ownerState
    }
  };
  const componentsProps = (slotProps != null ? slotProps : componentsPropsProp) ? deepmerge(slotProps != null ? slotProps : componentsPropsProp, inputComponentsProps) : inputComponentsProps;
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : InputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : InputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    slotProps: componentsProps,
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes: classes2
  }));
});
Input$2.muiName = "Input";
const Input$3 = Input$2;
const ListContext = /* @__PURE__ */ reactExports.createContext({});
const ListContext$1 = ListContext;
function getListUtilityClass(slot) {
  return generateUtilityClass("MuiList", slot);
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const _excluded$9 = ["children", "className", "component", "dense", "disablePadding", "subheader"];
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes: classes2,
    disablePadding,
    dense,
    subheader
  } = ownerState;
  const slots = {
    root: ["root", !disablePadding && "padding", dense && "dense", subheader && "subheader"]
  };
  return composeClasses(slots, getListUtilityClass, classes2);
};
const ListRoot = styled$1("ul", {
  name: "MuiList",
  slot: "Root",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.root, !ownerState.disablePadding && styles2.padding, ownerState.dense && styles2.dense, ownerState.subheader && styles2.subheader];
  }
})(({
  ownerState
}) => _extends$1({
  listStyle: "none",
  margin: 0,
  padding: 0,
  position: "relative"
}, !ownerState.disablePadding && {
  paddingTop: 8,
  paddingBottom: 8
}, ownerState.subheader && {
  paddingTop: 0
}));
const List$2 = /* @__PURE__ */ reactExports.forwardRef(function List(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiList"
  });
  const {
    children,
    className,
    component = "ul",
    dense = false,
    disablePadding = false,
    subheader
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$9);
  const context = reactExports.useMemo(() => ({
    dense
  }), [dense]);
  const ownerState = _extends$1({}, props, {
    component,
    dense,
    disablePadding
  });
  const classes2 = useUtilityClasses$7(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: context,
    children: /* @__PURE__ */ jsxRuntimeExports.jsxs(ListRoot, _extends$1({
      as: component,
      className: clsx(classes2.root, className),
      ref,
      ownerState
    }, other, {
      children: [subheader, children]
    }))
  });
});
const List$3 = List$2;
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"]);
const listItemIconClasses$1 = listItemIconClasses;
const listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
const listItemTextClasses$1 = listItemTextClasses;
const _excluded$8 = ["actions", "autoFocus", "autoFocusItem", "children", "className", "disabledItemsFocusable", "disableListWrap", "onKeyDown", "variant"];
function nextItem(list, item, disableListWrap) {
  if (list === item) {
    return list.firstChild;
  }
  if (item && item.nextElementSibling) {
    return item.nextElementSibling;
  }
  return disableListWrap ? null : list.firstChild;
}
function previousItem(list, item, disableListWrap) {
  if (list === item) {
    return disableListWrap ? list.firstChild : list.lastChild;
  }
  if (item && item.previousElementSibling) {
    return item.previousElementSibling;
  }
  return disableListWrap ? null : list.lastChild;
}
function textCriteriaMatches(nextFocus, textCriteria) {
  if (textCriteria === void 0) {
    return true;
  }
  let text = nextFocus.innerText;
  if (text === void 0) {
    text = nextFocus.textContent;
  }
  text = text.trim().toLowerCase();
  if (text.length === 0) {
    return false;
  }
  if (textCriteria.repeating) {
    return text[0] === textCriteria.keys[0];
  }
  return text.indexOf(textCriteria.keys.join("")) === 0;
}
function moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, traversalFunction, textCriteria) {
  let wrappedOnce = false;
  let nextFocus = traversalFunction(list, currentFocus, currentFocus ? disableListWrap : false);
  while (nextFocus) {
    if (nextFocus === list.firstChild) {
      if (wrappedOnce) {
        return false;
      }
      wrappedOnce = true;
    }
    const nextFocusDisabled = disabledItemsFocusable ? false : nextFocus.disabled || nextFocus.getAttribute("aria-disabled") === "true";
    if (!nextFocus.hasAttribute("tabindex") || !textCriteriaMatches(nextFocus, textCriteria) || nextFocusDisabled) {
      nextFocus = traversalFunction(list, nextFocus, disableListWrap);
    } else {
      nextFocus.focus();
      return true;
    }
  }
  return false;
}
const MenuList = /* @__PURE__ */ reactExports.forwardRef(function MenuList2(props, ref) {
  const {
    // private
    // eslint-disable-next-line react/prop-types
    actions: actions2,
    autoFocus = false,
    autoFocusItem = false,
    children,
    className,
    disabledItemsFocusable = false,
    disableListWrap = false,
    onKeyDown,
    variant = "selectedMenu"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$8);
  const listRef = reactExports.useRef(null);
  const textCriteriaRef = reactExports.useRef({
    keys: [],
    repeating: true,
    previousKeyMatched: true,
    lastTime: null
  });
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      listRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useImperativeHandle(actions2, () => ({
    adjustStyleForScrollbar: (containerElement, theme) => {
      const noExplicitWidth = !listRef.current.style.width;
      if (containerElement.clientHeight < listRef.current.clientHeight && noExplicitWidth) {
        const scrollbarSize = `${getScrollbarSize(ownerDocument(containerElement))}px`;
        listRef.current.style[theme.direction === "rtl" ? "paddingLeft" : "paddingRight"] = scrollbarSize;
        listRef.current.style.width = `calc(100% + ${scrollbarSize})`;
      }
      return listRef.current;
    }
  }), []);
  const handleKeyDown2 = (event) => {
    const list = listRef.current;
    const key = event.key;
    const currentFocus = ownerDocument(list).activeElement;
    if (key === "ArrowDown") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "ArrowUp") {
      event.preventDefault();
      moveFocus(list, currentFocus, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key === "Home") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, nextItem);
    } else if (key === "End") {
      event.preventDefault();
      moveFocus(list, null, disableListWrap, disabledItemsFocusable, previousItem);
    } else if (key.length === 1) {
      const criteria = textCriteriaRef.current;
      const lowerKey = key.toLowerCase();
      const currTime = performance.now();
      if (criteria.keys.length > 0) {
        if (currTime - criteria.lastTime > 500) {
          criteria.keys = [];
          criteria.repeating = true;
          criteria.previousKeyMatched = true;
        } else if (criteria.repeating && lowerKey !== criteria.keys[0]) {
          criteria.repeating = false;
        }
      }
      criteria.lastTime = currTime;
      criteria.keys.push(lowerKey);
      const keepFocusOnCurrent = currentFocus && !criteria.repeating && textCriteriaMatches(currentFocus, criteria);
      if (criteria.previousKeyMatched && (keepFocusOnCurrent || moveFocus(list, currentFocus, false, disabledItemsFocusable, nextItem, criteria))) {
        event.preventDefault();
      } else {
        criteria.previousKeyMatched = false;
      }
    }
    if (onKeyDown) {
      onKeyDown(event);
    }
  };
  const handleRef = useForkRef(listRef, ref);
  let activeItemIndex = -1;
  reactExports.Children.forEach(children, (child, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      if (activeItemIndex === index) {
        activeItemIndex += 1;
        if (activeItemIndex >= children.length) {
          activeItemIndex = -1;
        }
      }
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
    if (activeItemIndex === index && (child.props.disabled || child.props.muiSkipListHighlight || child.type.muiSkipListHighlight)) {
      activeItemIndex += 1;
      if (activeItemIndex >= children.length) {
        activeItemIndex = -1;
      }
    }
  });
  const items = reactExports.Children.map(children, (child, index) => {
    if (index === activeItemIndex) {
      const newChildProps = {};
      if (autoFocusItem) {
        newChildProps.autoFocus = true;
      }
      if (child.props.tabIndex === void 0 && variant === "selectedMenu") {
        newChildProps.tabIndex = 0;
      }
      return /* @__PURE__ */ reactExports.cloneElement(child, newChildProps);
    }
    return child;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$3, _extends$1({
    role: "menu",
    ref: handleRef,
    className,
    onKeyDown: handleKeyDown2,
    tabIndex: autoFocus ? 0 : -1
  }, other, {
    children: items
  }));
});
const MenuList$1 = MenuList;
function getPopoverUtilityClass(slot) {
  return generateUtilityClass("MuiPopover", slot);
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
const _excluded$7 = ["onEntering"], _excluded2$2 = ["action", "anchorEl", "anchorOrigin", "anchorPosition", "anchorReference", "children", "className", "container", "elevation", "marginThreshold", "open", "PaperProps", "slots", "slotProps", "transformOrigin", "TransitionComponent", "transitionDuration", "TransitionProps", "disableScrollLock"], _excluded3 = ["slotProps"];
function getOffsetTop(rect, vertical) {
  let offset = 0;
  if (typeof vertical === "number") {
    offset = vertical;
  } else if (vertical === "center") {
    offset = rect.height / 2;
  } else if (vertical === "bottom") {
    offset = rect.height;
  }
  return offset;
}
function getOffsetLeft(rect, horizontal) {
  let offset = 0;
  if (typeof horizontal === "number") {
    offset = horizontal;
  } else if (horizontal === "center") {
    offset = rect.width / 2;
  } else if (horizontal === "right") {
    offset = rect.width;
  }
  return offset;
}
function getTransformOriginValue(transformOrigin) {
  return [transformOrigin.horizontal, transformOrigin.vertical].map((n2) => typeof n2 === "number" ? `${n2}px` : n2).join(" ");
}
function resolveAnchorEl(anchorEl) {
  return typeof anchorEl === "function" ? anchorEl() : anchorEl;
}
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"]
  };
  return composeClasses(slots, getPopoverUtilityClass, classes2);
};
const PopoverRoot = styled$1(Modal$1, {
  name: "MuiPopover",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const PopoverPaper = styled$1(Paper$1, {
  name: "MuiPopover",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  position: "absolute",
  overflowY: "auto",
  overflowX: "hidden",
  // So we see the popover when it's empty.
  // It's most likely on issue on userland.
  minWidth: 16,
  minHeight: 16,
  maxWidth: "calc(100% - 32px)",
  maxHeight: "calc(100% - 32px)",
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Popover = /* @__PURE__ */ reactExports.forwardRef(function Popover2(inProps, ref) {
  var _slotProps$paper, _slots$root, _slots$paper;
  const props = useThemeProps({
    props: inProps,
    name: "MuiPopover"
  });
  const {
    action,
    anchorEl,
    anchorOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    anchorPosition,
    anchorReference = "anchorEl",
    children,
    className,
    container: containerProp,
    elevation = 8,
    marginThreshold = 16,
    open,
    PaperProps: PaperPropsProp = {},
    slots,
    slotProps,
    transformOrigin = {
      vertical: "top",
      horizontal: "left"
    },
    TransitionComponent = Grow$1,
    transitionDuration: transitionDurationProp = "auto",
    TransitionProps: {
      onEntering
    } = {},
    disableScrollLock = false
  } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$7), other = _objectWithoutPropertiesLoose(props, _excluded2$2);
  const externalPaperSlotProps = (_slotProps$paper = slotProps == null ? void 0 : slotProps.paper) != null ? _slotProps$paper : PaperPropsProp;
  const paperRef = reactExports.useRef();
  const handlePaperRef = useForkRef(paperRef, externalPaperSlotProps.ref);
  const ownerState = _extends$1({}, props, {
    anchorOrigin,
    anchorReference,
    elevation,
    marginThreshold,
    externalPaperSlotProps,
    transformOrigin,
    TransitionComponent,
    transitionDuration: transitionDurationProp,
    TransitionProps
  });
  const classes2 = useUtilityClasses$6(ownerState);
  const getAnchorOffset = reactExports.useCallback(() => {
    if (anchorReference === "anchorPosition") {
      return anchorPosition;
    }
    const resolvedAnchorEl = resolveAnchorEl(anchorEl);
    const anchorElement = resolvedAnchorEl && resolvedAnchorEl.nodeType === 1 ? resolvedAnchorEl : ownerDocument(paperRef.current).body;
    const anchorRect = anchorElement.getBoundingClientRect();
    return {
      top: anchorRect.top + getOffsetTop(anchorRect, anchorOrigin.vertical),
      left: anchorRect.left + getOffsetLeft(anchorRect, anchorOrigin.horizontal)
    };
  }, [anchorEl, anchorOrigin.horizontal, anchorOrigin.vertical, anchorPosition, anchorReference]);
  const getTransformOrigin = reactExports.useCallback((elemRect) => {
    return {
      vertical: getOffsetTop(elemRect, transformOrigin.vertical),
      horizontal: getOffsetLeft(elemRect, transformOrigin.horizontal)
    };
  }, [transformOrigin.horizontal, transformOrigin.vertical]);
  const getPositioningStyle = reactExports.useCallback((element) => {
    const elemRect = {
      width: element.offsetWidth,
      height: element.offsetHeight
    };
    const elemTransformOrigin = getTransformOrigin(elemRect);
    if (anchorReference === "none") {
      return {
        top: null,
        left: null,
        transformOrigin: getTransformOriginValue(elemTransformOrigin)
      };
    }
    const anchorOffset = getAnchorOffset();
    let top = anchorOffset.top - elemTransformOrigin.vertical;
    let left = anchorOffset.left - elemTransformOrigin.horizontal;
    const bottom = top + elemRect.height;
    const right = left + elemRect.width;
    const containerWindow = ownerWindow(resolveAnchorEl(anchorEl));
    const heightThreshold = containerWindow.innerHeight - marginThreshold;
    const widthThreshold = containerWindow.innerWidth - marginThreshold;
    if (marginThreshold !== null && top < marginThreshold) {
      const diff = top - marginThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    } else if (marginThreshold !== null && bottom > heightThreshold) {
      const diff = bottom - heightThreshold;
      top -= diff;
      elemTransformOrigin.vertical += diff;
    }
    if (marginThreshold !== null && left < marginThreshold) {
      const diff = left - marginThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    } else if (right > widthThreshold) {
      const diff = right - widthThreshold;
      left -= diff;
      elemTransformOrigin.horizontal += diff;
    }
    return {
      top: `${Math.round(top)}px`,
      left: `${Math.round(left)}px`,
      transformOrigin: getTransformOriginValue(elemTransformOrigin)
    };
  }, [anchorEl, anchorReference, getAnchorOffset, getTransformOrigin, marginThreshold]);
  const [isPositioned, setIsPositioned] = reactExports.useState(open);
  const setPositioningStyles = reactExports.useCallback(() => {
    const element = paperRef.current;
    if (!element) {
      return;
    }
    const positioning = getPositioningStyle(element);
    if (positioning.top !== null) {
      element.style.top = positioning.top;
    }
    if (positioning.left !== null) {
      element.style.left = positioning.left;
    }
    element.style.transformOrigin = positioning.transformOrigin;
    setIsPositioned(true);
  }, [getPositioningStyle]);
  reactExports.useEffect(() => {
    if (disableScrollLock) {
      window.addEventListener("scroll", setPositioningStyles);
    }
    return () => window.removeEventListener("scroll", setPositioningStyles);
  }, [anchorEl, disableScrollLock, setPositioningStyles]);
  const handleEntering = (element, isAppearing) => {
    if (onEntering) {
      onEntering(element, isAppearing);
    }
    setPositioningStyles();
  };
  const handleExited = () => {
    setIsPositioned(false);
  };
  reactExports.useEffect(() => {
    if (open) {
      setPositioningStyles();
    }
  });
  reactExports.useImperativeHandle(action, () => open ? {
    updatePosition: () => {
      setPositioningStyles();
    }
  } : null, [open, setPositioningStyles]);
  reactExports.useEffect(() => {
    if (!open) {
      return void 0;
    }
    const handleResize = debounce(() => {
      setPositioningStyles();
    });
    const containerWindow = ownerWindow(anchorEl);
    containerWindow.addEventListener("resize", handleResize);
    return () => {
      handleResize.clear();
      containerWindow.removeEventListener("resize", handleResize);
    };
  }, [anchorEl, open, setPositioningStyles]);
  let transitionDuration = transitionDurationProp;
  if (transitionDurationProp === "auto" && !TransitionComponent.muiSupportAuto) {
    transitionDuration = void 0;
  }
  const container = containerProp || (anchorEl ? ownerDocument(resolveAnchorEl(anchorEl)).body : void 0);
  const RootSlot = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : PopoverRoot;
  const PaperSlot = (_slots$paper = slots == null ? void 0 : slots.paper) != null ? _slots$paper : PopoverPaper;
  const paperProps = useSlotProps({
    elementType: PaperSlot,
    externalSlotProps: _extends$1({}, externalPaperSlotProps, {
      style: isPositioned ? externalPaperSlotProps.style : _extends$1({}, externalPaperSlotProps.style, {
        opacity: 0
      })
    }),
    additionalProps: {
      elevation,
      ref: handlePaperRef
    },
    ownerState,
    className: clsx(classes2.paper, externalPaperSlotProps == null ? void 0 : externalPaperSlotProps.className)
  });
  const _useSlotProps = useSlotProps({
    elementType: RootSlot,
    externalSlotProps: (slotProps == null ? void 0 : slotProps.root) || {},
    externalForwardedProps: other,
    additionalProps: {
      ref,
      slotProps: {
        backdrop: {
          invisible: true
        }
      },
      container,
      open
    },
    ownerState,
    className: clsx(classes2.root, className)
  }), {
    slotProps: rootSlotPropsProp
  } = _useSlotProps, rootProps = _objectWithoutPropertiesLoose(_useSlotProps, _excluded3);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RootSlot, _extends$1({}, rootProps, !isHostComponent(RootSlot) && {
    slotProps: rootSlotPropsProp,
    disableScrollLock
  }, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$1({
      appear: true,
      in: open,
      onEntering: handleEntering,
      onExited: handleExited,
      timeout: transitionDuration
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaperSlot, _extends$1({}, paperProps, {
        children
      }))
    }))
  }));
});
const Popover$1 = Popover;
function getMenuUtilityClass(slot) {
  return generateUtilityClass("MuiMenu", slot);
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const _excluded$6 = ["onEntering"], _excluded2$1 = ["autoFocus", "children", "className", "disableAutoFocusItem", "MenuListProps", "onClose", "open", "PaperProps", "PopoverClasses", "transitionDuration", "TransitionProps", "variant", "slots", "slotProps"];
const RTL_ORIGIN = {
  vertical: "top",
  horizontal: "right"
};
const LTR_ORIGIN = {
  vertical: "top",
  horizontal: "left"
};
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    paper: ["paper"],
    list: ["list"]
  };
  return composeClasses(slots, getMenuUtilityClass, classes2);
};
const MenuRoot = styled$1(Popover$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenu",
  slot: "Root",
  overridesResolver: (props, styles2) => styles2.root
})({});
const MenuPaper = styled$1(PopoverPaper, {
  name: "MuiMenu",
  slot: "Paper",
  overridesResolver: (props, styles2) => styles2.paper
})({
  // specZ: The maximum height of a simple menu should be one or more rows less than the view
  // height. This ensures a tappable area outside of the simple menu with which to dismiss
  // the menu.
  maxHeight: "calc(100% - 96px)",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch"
});
const MenuMenuList = styled$1(MenuList$1, {
  name: "MuiMenu",
  slot: "List",
  overridesResolver: (props, styles2) => styles2.list
})({
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
});
const Menu = /* @__PURE__ */ reactExports.forwardRef(function Menu2(inProps, ref) {
  var _slots$paper, _slotProps$paper;
  const props = useThemeProps({
    props: inProps,
    name: "MuiMenu"
  });
  const {
    autoFocus = true,
    children,
    className,
    disableAutoFocusItem = false,
    MenuListProps = {},
    onClose,
    open,
    PaperProps = {},
    PopoverClasses,
    transitionDuration = "auto",
    TransitionProps: {
      onEntering
    } = {},
    variant = "selectedMenu",
    slots = {},
    slotProps = {}
  } = props, TransitionProps = _objectWithoutPropertiesLoose(props.TransitionProps, _excluded$6), other = _objectWithoutPropertiesLoose(props, _excluded2$1);
  const theme = useTheme();
  const isRtl = theme.direction === "rtl";
  const ownerState = _extends$1({}, props, {
    autoFocus,
    disableAutoFocusItem,
    MenuListProps,
    onEntering,
    PaperProps,
    transitionDuration,
    TransitionProps,
    variant
  });
  const classes2 = useUtilityClasses$5(ownerState);
  const autoFocusItem = autoFocus && !disableAutoFocusItem && open;
  const menuListActionsRef = reactExports.useRef(null);
  const handleEntering = (element, isAppearing) => {
    if (menuListActionsRef.current) {
      menuListActionsRef.current.adjustStyleForScrollbar(element, theme);
    }
    if (onEntering) {
      onEntering(element, isAppearing);
    }
  };
  const handleListKeyDown = (event) => {
    if (event.key === "Tab") {
      event.preventDefault();
      if (onClose) {
        onClose(event, "tabKeyDown");
      }
    }
  };
  let activeItemIndex = -1;
  reactExports.Children.map(children, (child, index) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return;
    }
    if (!child.props.disabled) {
      if (variant === "selectedMenu" && child.props.selected) {
        activeItemIndex = index;
      } else if (activeItemIndex === -1) {
        activeItemIndex = index;
      }
    }
  });
  const PaperSlot = (_slots$paper = slots.paper) != null ? _slots$paper : MenuPaper;
  const paperExternalSlotProps = (_slotProps$paper = slotProps.paper) != null ? _slotProps$paper : PaperProps;
  const rootSlotProps = useSlotProps({
    elementType: slots.root,
    externalSlotProps: slotProps.root,
    ownerState,
    className: [classes2.root, className]
  });
  const paperSlotProps = useSlotProps({
    elementType: PaperSlot,
    externalSlotProps: paperExternalSlotProps,
    ownerState,
    className: classes2.paper
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRoot, _extends$1({
    onClose,
    anchorOrigin: {
      vertical: "bottom",
      horizontal: isRtl ? "right" : "left"
    },
    transformOrigin: isRtl ? RTL_ORIGIN : LTR_ORIGIN,
    slots: {
      paper: PaperSlot,
      root: slots.root
    },
    slotProps: {
      root: rootSlotProps,
      paper: paperSlotProps
    },
    open,
    ref,
    transitionDuration,
    TransitionProps: _extends$1({
      onEntering: handleEntering
    }, TransitionProps),
    ownerState
  }, other, {
    classes: PopoverClasses,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuMenuList, _extends$1({
      onKeyDown: handleListKeyDown,
      actions: menuListActionsRef,
      autoFocus: autoFocus && (activeItemIndex === -1 || disableAutoFocusItem),
      autoFocusItem,
      variant
    }, MenuListProps, {
      className: clsx(classes2.list, MenuListProps.className),
      children
    }))
  }));
});
const Menu$1 = Menu;
function getMenuItemUtilityClass(slot) {
  return generateUtilityClass("MuiMenuItem", slot);
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"]);
const menuItemClasses$1 = menuItemClasses;
const _excluded$5 = ["autoFocus", "component", "dense", "divider", "disableGutters", "focusVisibleClassName", "role", "tabIndex", "className"];
const overridesResolver = (props, styles2) => {
  const {
    ownerState
  } = props;
  return [styles2.root, ownerState.dense && styles2.dense, ownerState.divider && styles2.divider, !ownerState.disableGutters && styles2.gutters];
};
const useUtilityClasses$4 = (ownerState) => {
  const {
    disabled,
    dense,
    divider,
    disableGutters,
    selected,
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", disabled && "disabled", !disableGutters && "gutters", divider && "divider", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getMenuItemUtilityClass, classes2);
  return _extends$1({}, classes2, composedClasses);
};
const MenuItemRoot = styled$1(ButtonBase$1, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiMenuItem",
  slot: "Root",
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends$1({}, theme.typography.body1, {
  display: "flex",
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minHeight: 48,
  paddingTop: 6,
  paddingBottom: 6,
  boxSizing: "border-box",
  whiteSpace: "nowrap"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
  backgroundClip: "padding-box"
}, {
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${menuItemClasses$1.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    [`&.${menuItemClasses$1.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    }
  },
  [`&.${menuItemClasses$1.selected}:hover`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)
    }
  },
  [`&.${menuItemClasses$1.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${menuItemClasses$1.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  },
  [`& + .${dividerClasses$1.root}`]: {
    marginTop: theme.spacing(1),
    marginBottom: theme.spacing(1)
  },
  [`& + .${dividerClasses$1.inset}`]: {
    marginLeft: 52
  },
  [`& .${listItemTextClasses$1.root}`]: {
    marginTop: 0,
    marginBottom: 0
  },
  [`& .${listItemTextClasses$1.inset}`]: {
    paddingLeft: 36
  },
  [`& .${listItemIconClasses$1.root}`]: {
    minWidth: 36
  }
}, !ownerState.dense && {
  [theme.breakpoints.up("sm")]: {
    minHeight: "auto"
  }
}, ownerState.dense && _extends$1({
  minHeight: 32,
  // https://m2.material.io/components/menus#specs > Dense
  paddingTop: 4,
  paddingBottom: 4
}, theme.typography.body2, {
  [`& .${listItemIconClasses$1.root} svg`]: {
    fontSize: "1.25rem"
  }
})));
const MenuItem = /* @__PURE__ */ reactExports.forwardRef(function MenuItem2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiMenuItem"
  });
  const {
    autoFocus = false,
    component = "li",
    dense = false,
    divider = false,
    disableGutters = false,
    focusVisibleClassName,
    role = "menuitem",
    tabIndex: tabIndexProp,
    className
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$5);
  const context = reactExports.useContext(ListContext$1);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    disableGutters
  }), [context.dense, dense, disableGutters]);
  const menuItemRef = reactExports.useRef(null);
  useEnhancedEffect$1(() => {
    if (autoFocus) {
      if (menuItemRef.current) {
        menuItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$1({}, props, {
    dense: childContext.dense,
    divider,
    disableGutters
  });
  const classes2 = useUtilityClasses$4(props);
  const handleRef = useForkRef(menuItemRef, ref);
  let tabIndex;
  if (!props.disabled) {
    tabIndex = tabIndexProp !== void 0 ? tabIndexProp : -1;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext$1.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuItemRoot, _extends$1({
      ref: handleRef,
      role,
      tabIndex,
      component,
      focusVisibleClassName: clsx(classes2.focusVisible, focusVisibleClassName),
      className: clsx(classes2.root, className)
    }, other, {
      ownerState,
      classes: classes2
    }))
  });
});
const MenuItem$1 = MenuItem;
function getNativeSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiNativeSelect", slot);
}
const nativeSelectClasses = generateUtilityClasses("MuiNativeSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const nativeSelectClasses$1 = nativeSelectClasses;
const _excluded$4 = ["className", "disabled", "error", "IconComponent", "inputRef", "variant"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes: classes2,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"]
  };
  return composeClasses(slots, getNativeSelectUtilityClasses, classes2);
};
const nativeSelectSelectStyles = ({
  ownerState,
  theme
}) => _extends$1({
  MozAppearance: "none",
  // Reset
  WebkitAppearance: "none",
  // Reset
  // When interacting quickly, the text can end up selected.
  // Native select can't be selected either.
  userSelect: "none",
  borderRadius: 0,
  // Reset
  cursor: "pointer",
  "&:focus": _extends$1({}, theme.vars ? {
    backgroundColor: `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.05)`
  } : {
    backgroundColor: theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.05)" : "rgba(255, 255, 255, 0.05)"
  }, {
    borderRadius: 0
    // Reset Chrome style
  }),
  // Remove IE11 arrow
  "&::-ms-expand": {
    display: "none"
  },
  [`&.${nativeSelectClasses$1.disabled}`]: {
    cursor: "default"
  },
  "&[multiple]": {
    height: "auto"
  },
  "&:not([multiple]) option, &:not([multiple]) optgroup": {
    backgroundColor: (theme.vars || theme).palette.background.paper
  },
  // Bump specificity to allow extending custom inputs
  "&&&": {
    paddingRight: 24,
    minWidth: 16
    // So it doesn't collapse.
  }
}, ownerState.variant === "filled" && {
  "&&&": {
    paddingRight: 32
  }
}, ownerState.variant === "outlined" && {
  borderRadius: (theme.vars || theme).shape.borderRadius,
  "&:focus": {
    borderRadius: (theme.vars || theme).shape.borderRadius
    // Reset the reset for Chrome style
  },
  "&&&": {
    paddingRight: 32
  }
});
const NativeSelectSelect = styled$1("select", {
  name: "MuiNativeSelect",
  slot: "Select",
  shouldForwardProp: rootShouldForwardProp,
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.select, styles2[ownerState.variant], ownerState.error && styles2.error, {
      [`&.${nativeSelectClasses$1.multiple}`]: styles2.multiple
    }];
  }
})(nativeSelectSelectStyles);
const nativeSelectIconStyles = ({
  ownerState,
  theme
}) => _extends$1({
  // We use a position absolute over a flexbox in order to forward the pointer events
  // to the input and to support wrapping tags..
  position: "absolute",
  right: 0,
  top: "calc(50% - .5em)",
  // Center vertically, height is 1em
  pointerEvents: "none",
  // Don't block pointer events on the select under the icon.
  color: (theme.vars || theme).palette.action.active,
  [`&.${nativeSelectClasses$1.disabled}`]: {
    color: (theme.vars || theme).palette.action.disabled
  }
}, ownerState.open && {
  transform: "rotate(180deg)"
}, ownerState.variant === "filled" && {
  right: 7
}, ownerState.variant === "outlined" && {
  right: 7
});
const NativeSelectIcon = styled$1("svg", {
  name: "MuiNativeSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const NativeSelectInput = /* @__PURE__ */ reactExports.forwardRef(function NativeSelectInput2(props, ref) {
  const {
    className,
    disabled,
    error,
    IconComponent,
    inputRef,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$4);
  const ownerState = _extends$1({}, props, {
    disabled,
    variant,
    error
  });
  const classes2 = useUtilityClasses$3(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectSelect, _extends$1({
      ownerState,
      className: clsx(classes2.select, className),
      disabled,
      ref: inputRef || ref
    }, other)), props.multiple ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(NativeSelectIcon, {
      as: IconComponent,
      ownerState,
      className: classes2.icon
    })]
  });
});
const NativeSelectInput$1 = NativeSelectInput;
var _span$1;
const _excluded$3 = ["children", "classes", "className", "label", "notched"];
const NotchedOutlineRoot$1 = styled$1("fieldset")({
  textAlign: "left",
  position: "absolute",
  bottom: 0,
  right: 0,
  top: -5,
  left: 0,
  margin: 0,
  padding: "0 8px",
  pointerEvents: "none",
  borderRadius: "inherit",
  borderStyle: "solid",
  borderWidth: 1,
  overflow: "hidden",
  minWidth: "0%"
});
const NotchedOutlineLegend = styled$1("legend")(({
  ownerState,
  theme
}) => _extends$1({
  float: "unset",
  // Fix conflict with bootstrap
  width: "auto",
  // Fix conflict with bootstrap
  overflow: "hidden"
}, !ownerState.withLabel && {
  padding: 0,
  lineHeight: "11px",
  // sync with `height` in `legend` styles
  transition: theme.transitions.create("width", {
    duration: 150,
    easing: theme.transitions.easing.easeOut
  })
}, ownerState.withLabel && _extends$1({
  display: "block",
  // Fix conflict with normalize.css and sanitize.css
  padding: 0,
  height: 11,
  // sync with `lineHeight` in `legend` styles
  fontSize: "0.75em",
  visibility: "hidden",
  maxWidth: 0.01,
  transition: theme.transitions.create("max-width", {
    duration: 50,
    easing: theme.transitions.easing.easeOut
  }),
  whiteSpace: "nowrap",
  "& > span": {
    paddingLeft: 5,
    paddingRight: 5,
    display: "inline-block",
    opacity: 0,
    visibility: "visible"
  }
}, ownerState.notched && {
  maxWidth: "100%",
  transition: theme.transitions.create("max-width", {
    duration: 100,
    easing: theme.transitions.easing.easeOut,
    delay: 50
  })
})));
function NotchedOutline(props) {
  const {
    className,
    label,
    notched
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$3);
  const withLabel = label != null && label !== "";
  const ownerState = _extends$1({}, props, {
    notched,
    withLabel
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot$1, _extends$1({
    "aria-hidden": true,
    className,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineLegend, {
      ownerState,
      children: withLabel ? /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
        children: label
      }) : (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span$1 || (_span$1 = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      )
    })
  }));
}
const _excluded$2 = ["components", "fullWidth", "inputComponent", "label", "multiline", "notched", "slots", "type"];
const useUtilityClasses$2 = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  const slots = {
    root: ["root"],
    notchedOutline: ["notchedOutline"],
    input: ["input"]
  };
  const composedClasses = composeClasses(slots, getOutlinedInputUtilityClass, classes2);
  return _extends$1({}, classes2, composedClasses);
};
const OutlinedInputRoot = styled$1(InputBaseRoot, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiOutlinedInput",
  slot: "Root",
  overridesResolver: rootOverridesResolver
})(({
  theme,
  ownerState
}) => {
  const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return _extends$1({
    position: "relative",
    borderRadius: (theme.vars || theme).shape.borderRadius,
    [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.text.primary
    },
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      [`&:hover .${outlinedInputClasses$1.notchedOutline}`]: {
        borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
      }
    },
    [`&.${outlinedInputClasses$1.focused} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette[ownerState.color].main,
      borderWidth: 2
    },
    [`&.${outlinedInputClasses$1.error} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.error.main
    },
    [`&.${outlinedInputClasses$1.disabled} .${outlinedInputClasses$1.notchedOutline}`]: {
      borderColor: (theme.vars || theme).palette.action.disabled
    }
  }, ownerState.startAdornment && {
    paddingLeft: 14
  }, ownerState.endAdornment && {
    paddingRight: 14
  }, ownerState.multiline && _extends$1({
    padding: "16.5px 14px"
  }, ownerState.size === "small" && {
    padding: "8.5px 14px"
  }));
});
const NotchedOutlineRoot = styled$1(NotchedOutline, {
  name: "MuiOutlinedInput",
  slot: "NotchedOutline",
  overridesResolver: (props, styles2) => styles2.notchedOutline
})(({
  theme
}) => {
  const borderColor2 = theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
  return {
    borderColor: theme.vars ? `rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : borderColor2
  };
});
const OutlinedInputInput = styled$1(InputBaseComponent, {
  name: "MuiOutlinedInput",
  slot: "Input",
  overridesResolver: inputOverridesResolver
})(({
  theme,
  ownerState
}) => _extends$1({
  padding: "16.5px 14px"
}, !theme.vars && {
  "&:-webkit-autofill": {
    WebkitBoxShadow: theme.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
    WebkitTextFillColor: theme.palette.mode === "light" ? null : "#fff",
    caretColor: theme.palette.mode === "light" ? null : "#fff",
    borderRadius: "inherit"
  }
}, theme.vars && {
  "&:-webkit-autofill": {
    borderRadius: "inherit"
  },
  [theme.getColorSchemeSelector("dark")]: {
    "&:-webkit-autofill": {
      WebkitBoxShadow: "0 0 0 100px #266798 inset",
      WebkitTextFillColor: "#fff",
      caretColor: "#fff"
    }
  }
}, ownerState.size === "small" && {
  padding: "8.5px 14px"
}, ownerState.multiline && {
  padding: 0
}, ownerState.startAdornment && {
  paddingLeft: 0
}, ownerState.endAdornment && {
  paddingRight: 0
}));
const OutlinedInput = /* @__PURE__ */ reactExports.forwardRef(function OutlinedInput2(inProps, ref) {
  var _ref, _slots$root, _ref2, _slots$input, _React$Fragment;
  const props = useThemeProps({
    props: inProps,
    name: "MuiOutlinedInput"
  });
  const {
    components = {},
    fullWidth = false,
    inputComponent = "input",
    label,
    multiline = false,
    notched,
    slots = {},
    type = "text"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$2);
  const classes2 = useUtilityClasses$2(props);
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
  });
  const ownerState = _extends$1({}, props, {
    color: fcs.color || "primary",
    disabled: fcs.disabled,
    error: fcs.error,
    focused: fcs.focused,
    formControl: muiFormControl,
    fullWidth,
    hiddenLabel: fcs.hiddenLabel,
    multiline,
    size: fcs.size,
    type
  });
  const RootSlot = (_ref = (_slots$root = slots.root) != null ? _slots$root : components.Root) != null ? _ref : OutlinedInputRoot;
  const InputSlot = (_ref2 = (_slots$input = slots.input) != null ? _slots$input : components.Input) != null ? _ref2 : OutlinedInputInput;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(InputBase$1, _extends$1({
    slots: {
      root: RootSlot,
      input: InputSlot
    },
    renderSuffix: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(NotchedOutlineRoot, {
      ownerState,
      className: classes2.notchedOutline,
      label: label != null && label !== "" && fcs.required ? _React$Fragment || (_React$Fragment = /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [label, " ", "*"]
      })) : label,
      notched: typeof notched !== "undefined" ? notched : Boolean(state.startAdornment || state.filled || state.focused)
    }),
    fullWidth,
    inputComponent,
    multiline,
    ref,
    type
  }, other, {
    classes: _extends$1({}, classes2, {
      notchedOutline: null
    })
  }));
});
OutlinedInput.muiName = "Input";
const OutlinedInput$1 = OutlinedInput;
function getSelectUtilityClasses(slot) {
  return generateUtilityClass("MuiSelect", slot);
}
const selectClasses = generateUtilityClasses("MuiSelect", ["root", "select", "multiple", "filled", "outlined", "standard", "disabled", "focused", "icon", "iconOpen", "iconFilled", "iconOutlined", "iconStandard", "nativeInput", "error"]);
const selectClasses$1 = selectClasses;
var _span;
const _excluded$1 = ["aria-describedby", "aria-label", "autoFocus", "autoWidth", "children", "className", "defaultOpen", "defaultValue", "disabled", "displayEmpty", "error", "IconComponent", "inputRef", "labelId", "MenuProps", "multiple", "name", "onBlur", "onChange", "onClose", "onFocus", "onOpen", "open", "readOnly", "renderValue", "SelectDisplayProps", "tabIndex", "type", "value", "variant"];
const SelectSelect = styled$1("div", {
  name: "MuiSelect",
  slot: "Select",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [
      // Win specificity over the input base
      {
        [`&.${selectClasses$1.select}`]: styles2.select
      },
      {
        [`&.${selectClasses$1.select}`]: styles2[ownerState.variant]
      },
      {
        [`&.${selectClasses$1.error}`]: styles2.error
      },
      {
        [`&.${selectClasses$1.multiple}`]: styles2.multiple
      }
    ];
  }
})(nativeSelectSelectStyles, {
  // Win specificity over the input base
  [`&.${selectClasses$1.select}`]: {
    height: "auto",
    // Resets for multiple select with chips
    minHeight: "1.4375em",
    // Required for select\text-field height consistency
    textOverflow: "ellipsis",
    whiteSpace: "nowrap",
    overflow: "hidden"
  }
});
const SelectIcon$2 = styled$1("svg", {
  name: "MuiSelect",
  slot: "Icon",
  overridesResolver: (props, styles2) => {
    const {
      ownerState
    } = props;
    return [styles2.icon, ownerState.variant && styles2[`icon${capitalize(ownerState.variant)}`], ownerState.open && styles2.iconOpen];
  }
})(nativeSelectIconStyles);
const SelectNativeInput = styled$1("input", {
  shouldForwardProp: (prop) => slotShouldForwardProp(prop) && prop !== "classes",
  name: "MuiSelect",
  slot: "NativeInput",
  overridesResolver: (props, styles2) => styles2.nativeInput
})({
  bottom: 0,
  left: 0,
  position: "absolute",
  opacity: 0,
  pointerEvents: "none",
  width: "100%",
  boxSizing: "border-box"
});
function areEqualValues(a2, b2) {
  if (typeof b2 === "object" && b2 !== null) {
    return a2 === b2;
  }
  return String(a2) === String(b2);
}
function isEmpty(display) {
  return display == null || typeof display === "string" && !display.trim();
}
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes: classes2,
    variant,
    disabled,
    multiple,
    open,
    error
  } = ownerState;
  const slots = {
    select: ["select", variant, disabled && "disabled", multiple && "multiple", error && "error"],
    icon: ["icon", `icon${capitalize(variant)}`, open && "iconOpen", disabled && "disabled"],
    nativeInput: ["nativeInput"]
  };
  return composeClasses(slots, getSelectUtilityClasses, classes2);
};
const SelectInput = /* @__PURE__ */ reactExports.forwardRef(function SelectInput2(props, ref) {
  var _MenuProps$slotProps;
  const {
    "aria-describedby": ariaDescribedby,
    "aria-label": ariaLabel,
    autoFocus,
    autoWidth,
    children,
    className,
    defaultOpen,
    defaultValue,
    disabled,
    displayEmpty,
    error = false,
    IconComponent,
    inputRef: inputRefProp,
    labelId,
    MenuProps = {},
    multiple,
    name,
    onBlur,
    onChange,
    onClose,
    onFocus: onFocus2,
    onOpen,
    open: openProp,
    readOnly,
    renderValue,
    SelectDisplayProps = {},
    tabIndex: tabIndexProp,
    value: valueProp,
    variant = "standard"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded$1);
  const [value, setValueState] = useControlled({
    controlled: valueProp,
    default: defaultValue,
    name: "Select"
  });
  const [openState, setOpenState] = useControlled({
    controlled: openProp,
    default: defaultOpen,
    name: "Select"
  });
  const inputRef = reactExports.useRef(null);
  const displayRef = reactExports.useRef(null);
  const [displayNode, setDisplayNode] = reactExports.useState(null);
  const {
    current: isOpenControlled
  } = reactExports.useRef(openProp != null);
  const [menuMinWidthState, setMenuMinWidthState] = reactExports.useState();
  const handleRef = useForkRef(ref, inputRefProp);
  const handleDisplayRef = reactExports.useCallback((node2) => {
    displayRef.current = node2;
    if (node2) {
      setDisplayNode(node2);
    }
  }, []);
  const anchorElement = displayNode == null ? void 0 : displayNode.parentNode;
  reactExports.useImperativeHandle(handleRef, () => ({
    focus: () => {
      displayRef.current.focus();
    },
    node: inputRef.current,
    value
  }), [value]);
  reactExports.useEffect(() => {
    if (defaultOpen && openState && displayNode && !isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      displayRef.current.focus();
    }
  }, [displayNode, autoWidth]);
  reactExports.useEffect(() => {
    if (autoFocus) {
      displayRef.current.focus();
    }
  }, [autoFocus]);
  reactExports.useEffect(() => {
    if (!labelId) {
      return void 0;
    }
    const label = ownerDocument(displayRef.current).getElementById(labelId);
    if (label) {
      const handler = () => {
        if (getSelection().isCollapsed) {
          displayRef.current.focus();
        }
      };
      label.addEventListener("click", handler);
      return () => {
        label.removeEventListener("click", handler);
      };
    }
    return void 0;
  }, [labelId]);
  const update2 = (open2, event) => {
    if (open2) {
      if (onOpen) {
        onOpen(event);
      }
    } else if (onClose) {
      onClose(event);
    }
    if (!isOpenControlled) {
      setMenuMinWidthState(autoWidth ? null : anchorElement.clientWidth);
      setOpenState(open2);
    }
  };
  const handleMouseDown = (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    displayRef.current.focus();
    update2(true, event);
  };
  const handleClose = (event) => {
    update2(false, event);
  };
  const childrenArray = reactExports.Children.toArray(children);
  const handleChange = (event) => {
    const child = childrenArray.find((childItem) => childItem.props.value === event.target.value);
    if (child === void 0) {
      return;
    }
    setValueState(child.props.value);
    if (onChange) {
      onChange(event, child);
    }
  };
  const handleItemClick = (child) => (event) => {
    let newValue;
    if (!event.currentTarget.hasAttribute("tabindex")) {
      return;
    }
    if (multiple) {
      newValue = Array.isArray(value) ? value.slice() : [];
      const itemIndex = value.indexOf(child.props.value);
      if (itemIndex === -1) {
        newValue.push(child.props.value);
      } else {
        newValue.splice(itemIndex, 1);
      }
    } else {
      newValue = child.props.value;
    }
    if (child.props.onClick) {
      child.props.onClick(event);
    }
    if (value !== newValue) {
      setValueState(newValue);
      if (onChange) {
        const nativeEvent = event.nativeEvent || event;
        const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
        Object.defineProperty(clonedEvent, "target", {
          writable: true,
          value: {
            value: newValue,
            name
          }
        });
        onChange(clonedEvent, child);
      }
    }
    if (!multiple) {
      update2(false, event);
    }
  };
  const handleKeyDown2 = (event) => {
    if (!readOnly) {
      const validKeys = [
        " ",
        "ArrowUp",
        "ArrowDown",
        // The native select doesn't respond to enter on macOS, but it's recommended by
        // https://www.w3.org/WAI/ARIA/apg/patterns/combobox/examples/combobox-select-only/
        "Enter"
      ];
      if (validKeys.indexOf(event.key) !== -1) {
        event.preventDefault();
        update2(true, event);
      }
    }
  };
  const open = displayNode !== null && openState;
  const handleBlur = (event) => {
    if (!open && onBlur) {
      Object.defineProperty(event, "target", {
        writable: true,
        value: {
          value,
          name
        }
      });
      onBlur(event);
    }
  };
  delete other["aria-invalid"];
  let display;
  let displaySingle;
  const displayMultiple = [];
  let computeDisplay = false;
  if (isFilled({
    value
  }) || displayEmpty) {
    if (renderValue) {
      display = renderValue(value);
    } else {
      computeDisplay = true;
    }
  }
  const items = childrenArray.map((child) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(child)) {
      return null;
    }
    let selected;
    if (multiple) {
      if (!Array.isArray(value)) {
        throw new Error(formatMuiErrorMessage(2));
      }
      selected = value.some((v2) => areEqualValues(v2, child.props.value));
      if (selected && computeDisplay) {
        displayMultiple.push(child.props.children);
      }
    } else {
      selected = areEqualValues(value, child.props.value);
      if (selected && computeDisplay) {
        displaySingle = child.props.children;
      }
    }
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      "aria-selected": selected ? "true" : "false",
      onClick: handleItemClick(child),
      onKeyUp: (event) => {
        if (event.key === " ") {
          event.preventDefault();
        }
        if (child.props.onKeyUp) {
          child.props.onKeyUp(event);
        }
      },
      role: "option",
      selected,
      value: void 0,
      // The value is most likely not a valid HTML attribute.
      "data-value": child.props.value
      // Instead, we provide it as a data attribute.
    });
  });
  if (computeDisplay) {
    if (multiple) {
      if (displayMultiple.length === 0) {
        display = null;
      } else {
        display = displayMultiple.reduce((output, child, index) => {
          output.push(child);
          if (index < displayMultiple.length - 1) {
            output.push(", ");
          }
          return output;
        }, []);
      }
    } else {
      display = displaySingle;
    }
  }
  let menuMinWidth = menuMinWidthState;
  if (!autoWidth && isOpenControlled && displayNode) {
    menuMinWidth = anchorElement.clientWidth;
  }
  let tabIndex;
  if (typeof tabIndexProp !== "undefined") {
    tabIndex = tabIndexProp;
  } else {
    tabIndex = disabled ? null : 0;
  }
  const buttonId = SelectDisplayProps.id || (name ? `mui-component-select-${name}` : void 0);
  const ownerState = _extends$1({}, props, {
    variant,
    value,
    open,
    error
  });
  const classes2 = useUtilityClasses$1(ownerState);
  const paperProps = _extends$1({}, MenuProps.PaperProps, (_MenuProps$slotProps = MenuProps.slotProps) == null ? void 0 : _MenuProps$slotProps.paper);
  const listboxId = useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(SelectSelect, _extends$1({
      ref: handleDisplayRef,
      tabIndex,
      role: "combobox",
      "aria-controls": listboxId,
      "aria-disabled": disabled ? "true" : void 0,
      "aria-expanded": open ? "true" : "false",
      "aria-haspopup": "listbox",
      "aria-label": ariaLabel,
      "aria-labelledby": [labelId, buttonId].filter(Boolean).join(" ") || void 0,
      "aria-describedby": ariaDescribedby,
      onKeyDown: handleKeyDown2,
      onMouseDown: disabled || readOnly ? null : handleMouseDown,
      onBlur: handleBlur,
      onFocus: onFocus2
    }, SelectDisplayProps, {
      ownerState,
      className: clsx(SelectDisplayProps.className, classes2.select, className),
      id: buttonId,
      children: isEmpty(display) ? (
        // notranslate needed while Google Translate will not fix zero-width space issue
        _span || (_span = /* @__PURE__ */ jsxRuntimeExports.jsx("span", {
          className: "notranslate",
          children: "​"
        }))
      ) : display
    })), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectNativeInput, _extends$1({
      "aria-invalid": error,
      value: Array.isArray(value) ? value.join(",") : value,
      name,
      ref: inputRef,
      "aria-hidden": true,
      onChange: handleChange,
      tabIndex: -1,
      disabled,
      className: classes2.nativeInput,
      autoFocus,
      ownerState
    }, other)), /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon$2, {
      as: IconComponent,
      className: classes2.icon,
      ownerState
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(Menu$1, _extends$1({
      id: `menu-${name || ""}`,
      anchorEl: anchorElement,
      open,
      onClose: handleClose,
      anchorOrigin: {
        vertical: "bottom",
        horizontal: "center"
      },
      transformOrigin: {
        vertical: "top",
        horizontal: "center"
      }
    }, MenuProps, {
      MenuListProps: _extends$1({
        "aria-labelledby": labelId,
        role: "listbox",
        "aria-multiselectable": multiple ? "true" : void 0,
        disableListWrap: true,
        id: listboxId
      }, MenuProps.MenuListProps),
      slotProps: _extends$1({}, MenuProps.slotProps, {
        paper: _extends$1({}, paperProps, {
          style: _extends$1({
            minWidth: menuMinWidth
          }, paperProps != null ? paperProps.style : null)
        })
      }),
      children: items
    }))]
  });
});
const SelectInput$1 = SelectInput;
const _excluded = ["autoWidth", "children", "classes", "className", "defaultOpen", "displayEmpty", "IconComponent", "id", "input", "inputProps", "label", "labelId", "MenuProps", "multiple", "native", "onClose", "onOpen", "open", "renderValue", "SelectDisplayProps", "variant"], _excluded2 = ["root"];
const useUtilityClasses = (ownerState) => {
  const {
    classes: classes2
  } = ownerState;
  return classes2;
};
const styledRootConfig = {
  name: "MuiSelect",
  overridesResolver: (props, styles2) => styles2.root,
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) && prop !== "variant",
  slot: "Root"
};
const StyledInput = styled$1(Input$3, styledRootConfig)("");
const StyledOutlinedInput = styled$1(OutlinedInput$1, styledRootConfig)("");
const StyledFilledInput = styled$1(FilledInput$1, styledRootConfig)("");
const Select = /* @__PURE__ */ reactExports.forwardRef(function Select2(inProps, ref) {
  const props = useThemeProps({
    name: "MuiSelect",
    props: inProps
  });
  const {
    autoWidth = false,
    children,
    classes: classesProp = {},
    className,
    defaultOpen = false,
    displayEmpty = false,
    IconComponent = ArrowDropDownIcon,
    id: id2,
    input,
    inputProps,
    label,
    labelId,
    MenuProps,
    multiple = false,
    native = false,
    onClose,
    onOpen,
    open,
    renderValue,
    SelectDisplayProps,
    variant: variantProp = "outlined"
  } = props, other = _objectWithoutPropertiesLoose(props, _excluded);
  const inputComponent = native ? NativeSelectInput$1 : SelectInput$1;
  const muiFormControl = useFormControl();
  const fcs = formControlState({
    props,
    muiFormControl,
    states: ["variant", "error"]
  });
  const variant = fcs.variant || variantProp;
  const ownerState = _extends$1({}, props, {
    variant,
    classes: classesProp
  });
  const classes2 = useUtilityClasses(ownerState);
  const restOfClasses = _objectWithoutPropertiesLoose(classes2, _excluded2);
  const InputComponent = input || {
    standard: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledInput, {
      ownerState
    }),
    outlined: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledOutlinedInput, {
      label,
      ownerState
    }),
    filled: /* @__PURE__ */ jsxRuntimeExports.jsx(StyledFilledInput, {
      ownerState
    })
  }[variant];
  const inputComponentRef = useForkRef(ref, InputComponent.ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Fragment, {
    children: /* @__PURE__ */ reactExports.cloneElement(InputComponent, _extends$1({
      // Most of the logic is implemented in `SelectInput`.
      // The `Select` component is a simple API wrapper to expose something better to play with.
      inputComponent,
      inputProps: _extends$1({
        children,
        error: fcs.error,
        IconComponent,
        variant,
        type: void 0,
        // We render a select. We can ignore the type provided by the `Input`.
        multiple
      }, native ? {
        id: id2
      } : {
        autoWidth,
        defaultOpen,
        displayEmpty,
        labelId,
        MenuProps,
        onClose,
        onOpen,
        open,
        renderValue,
        SelectDisplayProps: _extends$1({
          id: id2
        }, SelectDisplayProps)
      }, inputProps, {
        classes: inputProps ? deepmerge(restOfClasses, inputProps.classes) : restOfClasses
      }, input ? input.props.inputProps : {})
    }, multiple && native && variant === "outlined" ? {
      notched: true
    } : {}, {
      ref: inputComponentRef,
      className: clsx(InputComponent.props.className, className, classes2.root)
    }, !input && {
      variant
    }, other))
  });
});
Select.muiName = "Select";
const Select$1 = Select;
function Header$2() {
  const [isBurgerMenuOpen, setBurgerMenuOpen] = reactExports.useState(false);
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  reactExports.useEffect(() => {
    if (isBurgerMenuOpen && isMobile) {
      document.body.style.overflow = "hidden";
    } else {
      document.body.style.overflow = "unset";
    }
  }, [isBurgerMenuOpen, isMobile]);
  const handleToggleBurgerMenu = () => {
    setBurgerMenuOpen(!isBurgerMenuOpen);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header$3, { children: [
    isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
      BurgerBtn,
      {
        isOpen: false,
        onClick: handleToggleBurgerMenu
      }
    ),
    !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MainLogo, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Nav$1, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProfileBlock, {}),
    isBurgerMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(BurgerMenu, { onClose: handleToggleBurgerMenu })
  ] });
}
const Container$D = st$1(FlexContainer)`
  align-items: center;
  margin-bottom: 20px;
`;
st$1.div`
  padding: 3px 15px;
  margin-right: 20px;
  font-weight: 700;
  font-size: 24.923px;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realWhite};
  background-color: ${(props) => props.theme.colors.mainBlue};
  border-radius: 18px;
`;
st$1(Text$6)`
  font-weight: 24.923px;
`;
const ModalInitialState = {
  isModalOpen: false,
  modalType: ""
};
const modalSlice = createSlice({
  name: "modal",
  initialState: ModalInitialState,
  reducers: {
    setModalOpen: (state, { payload }) => {
      state.isModalOpen = payload;
      payload ? document.body.style.overflow = "hidden" : document.body.style.overflow = "unset";
    },
    setModalType: (state, { payload }) => {
      state.modalType = payload;
    }
  }
});
const { actions: actions$6, reducer: reducer$7 } = modalSlice;
const AuthInitialState = {
  token: null
};
const authSlice = createSlice({
  name: "auth",
  initialState: AuthInitialState,
  reducers: {
    setAuthToken: (state, { payload }) => {
      state.token = payload;
    }
  }
});
const { actions: actions$5, reducer: reducer$6 } = authSlice;
const courseInitialState = {
  data: {
    id: 0,
    title: "",
    description: "",
    is_open: 0,
    status: 0,
    user_id: 0,
    date: "",
    is_deleted: 0,
    chapters: [],
    image: null
  },
  activeChapterId: null,
  activeTheme: null,
  activeLesson: null,
  updatingChapterData: null,
  updatingThemeData: null
};
const courseSlice = createSlice({
  name: "course",
  initialState: courseInitialState,
  reducers: {
    setCourseData: (state, { payload }) => {
      return {
        ...state,
        ...{ data: payload || courseInitialState.data }
      };
    },
    changeCourseData: (state, { payload }) => {
      state.data = { ...state.data, ...payload };
    },
    setActiveChapterId: (state, { payload }) => {
      state.activeChapterId = payload;
    },
    addChapter: (state, { payload }) => {
      var _a;
      (_a = state.data.chapters) == null ? void 0 : _a.push(payload);
    },
    changeChapter: (state, { payload }) => {
      var _a, _b;
      if (!state.data || !state.data.chapters) {
        console.warn(`No chapters in course`);
        return;
      }
      const currentChapterIndex = (_b = (_a = state.data) == null ? void 0 : _a.chapters) == null ? void 0 : _b.findIndex(
        (chapter) => chapter.id === Number(payload.id)
      );
      if (currentChapterIndex === -1) {
        console.error(`No chapter with id: ${payload.id}`);
        return;
      }
      state.data.chapters[currentChapterIndex] = {
        ...state.data.chapters[currentChapterIndex],
        ...payload
      };
    },
    setActiveTheme: (state, { payload }) => {
      state.activeTheme = { ...payload };
    },
    setActiveLesson: (state, { payload }) => {
      state.activeLesson = { ...payload };
    },
    setUpdatingChapterData: (state, { payload }) => {
      state.updatingChapterData = { ...payload };
    },
    setUpdatingThemeData: (state, { payload }) => {
      state.updatingThemeData = { ...payload };
    }
  }
});
const { actions: actions$4, reducer: reducer$5 } = courseSlice;
const loaderInitialState = {
  active: false
};
const loaderSlice = createSlice({
  name: "loader",
  initialState: loaderInitialState,
  reducers: {
    setLoaderActive(state, { payload }) {
      state.active = payload;
    }
  }
});
const { reducer: reducer$4, actions: actions$3 } = loaderSlice;
class EmptyAnswer {
  constructor() {
    __publicField(this, "id");
    __publicField(this, "answer");
    __publicField(this, "right_answer");
    __publicField(this, "text");
    this.id = nanoid();
    this.answer = "";
    this.right_answer = false;
    this.text = "";
  }
}
class EmptyTest {
  constructor() {
    __publicField(this, "id");
    __publicField(this, "question");
    __publicField(this, "answers");
    this.id = nanoid();
    this.question = "";
    this.answers = [
      {
        id: nanoid(),
        answer: "",
        right_answer: false,
        text: ""
      },
      {
        id: nanoid(),
        answer: "",
        right_answer: true,
        text: ""
      }
    ];
  }
}
const lessonInitialState = {
  tests: [],
  navPopup: false
};
const lessonSlice = createSlice({
  name: "lesson",
  initialState: lessonInitialState,
  reducers: {
    addEmptyTest: (state) => {
      let tests = state.tests;
      tests = [...tests, new EmptyTest()];
      return {
        ...state,
        tests
      };
    },
    deleteTest: (state, { payload }) => {
      const updatedTests = state.tests.filter((test) => test.id !== payload);
      return {
        ...state,
        tests: updatedTests
      };
    },
    addAnswer: (state, { payload }) => {
      const { tests } = state;
      const testIndex = tests.findIndex((test) => test.id === payload.id);
      if (testIndex === -1)
        return state;
      const newTests = [...tests];
      newTests[testIndex] = {
        ...newTests[testIndex],
        answers: [...newTests[testIndex].answers, new EmptyAnswer()]
      };
      return {
        ...state,
        tests: newTests
      };
    },
    deleteAnswer: (state, { payload }) => {
      const { testId, answerId } = payload;
      const testIndex = state.tests.findIndex((test) => test.id === testId);
      if (testIndex === -1) {
        return state;
      }
      const filteredAnswers = state.tests[testIndex].answers.filter(
        (answer) => answer.id !== answerId
      );
      const modifyTests = state.tests.map((test) => {
        if (test.id === testId) {
          test.answers = filteredAnswers;
        }
        return test;
      });
      state.tests = modifyTests;
    },
    setTestsData: (state, { payload }) => {
      state.tests = [...payload];
    },
    changeTestQuestion: (state, { payload }) => {
      const testIndex = state.tests.findIndex((test) => test.id === payload.id);
      if (testIndex === -1) {
        return state;
      }
      const modifyTests = state.tests.map((test) => {
        if (test.id === payload.id) {
          test.question = payload.question;
        }
        return test;
      });
      state.tests = modifyTests;
    },
    toggleAnswer: (state, { payload }) => {
      const testIndex = state.tests.findIndex((test) => test.id === payload.testId);
      if (testIndex === -1)
        return;
      const changedAnswers = state.tests[testIndex].answers.map((answer) => {
        if (payload.isRight) {
          if (answer.id === payload.answerId && payload.isRight) {
            answer.right_answer = payload.isRight;
          } else {
            answer.right_answer = false;
          }
        } else {
          answer.right_answer = payload.isRight;
        }
        return answer;
      });
      const modifyTests = state.tests.map((test) => {
        if (test.id === payload.testId) {
          test.answers = changedAnswers;
        }
        return test;
      });
      state.tests = modifyTests;
    },
    changeAnswer: (state, { payload }) => {
      const testIndex = state.tests.findIndex((test) => test.id === payload.testId);
      if (testIndex === -1)
        return;
      const changedAnswers = state.tests[testIndex].answers.map((answer) => {
        if (payload.answerId === answer.id) {
          answer.answer = payload.value;
        }
        return answer;
      });
      const modifyTests = state.tests.map((test) => {
        if (test.id === payload.testId) {
          test.answers = changedAnswers;
        }
        return test;
      });
      state.tests = modifyTests;
    },
    changeAnswerComment: (state, { payload }) => {
      const testIndex = state.tests.findIndex((test) => test.id === payload.testId);
      if (testIndex === -1)
        return;
      const changedAnswers = state.tests[testIndex].answers.map((answer) => {
        if (payload.answerId === answer.id) {
          answer.text = payload.value;
        }
        return answer;
      });
      const modifyTests = state.tests.map((test) => {
        if (test.id === payload.testId) {
          test.answers = changedAnswers;
        }
        return test;
      });
      state.tests = modifyTests;
    },
    setNavPopup: (state, { payload }) => {
      state.navPopup = payload;
    }
  }
});
const { reducer: reducer$3, actions: actions$2 } = lessonSlice;
const competitionInitialState = {
  updatingCompetitionData: null
};
const competitionSlice = createSlice({
  name: "competition",
  initialState: competitionInitialState,
  reducers: {
    setUpdatingCompetitionData: (state, { payload }) => {
      state.updatingCompetitionData = payload ? { ...payload } : null;
    }
  }
});
const { actions: actions$1, reducer: reducer$2 } = competitionSlice;
const initialState = {
  newsCategories: []
};
const newsSlice = createSlice({
  name: "news",
  initialState,
  reducers: {
    setNewsCategories: (state, { payload }) => {
      state.newsCategories = payload;
    },
    addNewsCategory: (state, { payload }) => {
      state.newsCategories.push(payload);
    },
    deleteNewsCategory: (state, { payload }) => {
      const index = state.newsCategories.findIndex(
        (category) => category.id === payload.id || category.title === payload.title
      );
      if (index !== -1) {
        state.newsCategories.splice(index, 1);
      }
    }
  }
});
const { actions, reducer: reducer$1 } = newsSlice;
const rootActions = {
  ...actions$5,
  ...actions$6,
  ...actions$4,
  ...actions$3,
  ...actions$2,
  ...actions$1,
  ...actions
};
const useActions = () => {
  const dispatch = useDispatch();
  return reactExports.useMemo(() => bindActionCreators(rootActions, dispatch), [dispatch]);
};
const editIcon$2 = "/assets/editIcon.svg";
const addIcon$2 = "/assets/addIcon.svg";
const AdminBtn$1 = st$1.button`
  position: relative;
  width: 24px;
  height: 24px;
  background-color: transparent;
  background-image: url(${(props) => props.$type === ADMIN_BTN_TYPES.edit ? editIcon$2 : addIcon$2});
  background-repeat: no-repeat;
  background-size: 100%;
  background-position: center;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
    width: 7.5vw;
    height: 7.5vw;
  }
`;
const isHideIcon = "/assets/hideIcon.svg";
const addIcon$1 = "/assets/addIconBlack.svg";
const editIcon$1 = "/assets/editIconRed.svg";
const deleteIcon$1 = "/assets/deleteIcon.svg";
const visibleIcon = "/assets/visibleIcon.svg";
const Overlay$3 = st$1(DarkOverlay)`
    z-index: ${(props) => props.theme.utils.zIndex.popup};
  @media ${(props) => props.theme.media.desktop} {
    background-color: transparent;
    position: absolute;
    top: 100%;
    right: 0;
    left: unset;
    width: 320px;
    filter: drop-shadow(0px 0px 9px rgba(0, 0, 0, 0.25));
  }
`;
const Container$C = st$1(FlexContainer)`
  flex-direction: column;
  width: 100%;
  padding: 15px 10px 10px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.greyF1};
  @media ${(props) => props.theme.media.mobile} {
    padding: 3.125vw;
    border-radius: 0px 0px 15px 15px;
  }
`;
const Title$f = st$1(Text$6)`
  margin-bottom: 15px;
  text-align: center;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 4.6875vw;
  }
`;
const Btn = st$1.div`
  ${TextStyles}
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 60px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
  transition: ${(props) => props.theme.utils.transition};
  @media ${(props) => props.theme.media.mobile} {
    min-height: 18.75vw;
  }

  &:not(:last-child) {
    margin-bottom: 5px;
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 1.5625vw;
    }
  }

  &:hover {
    background-color: ${(props) => props.theme.colors.greyF1};
  }
`;
const HideBtn = st$1(Btn)``;
const VisibleBtn = st$1(Btn)``;
const AddBtn = st$1(Btn)``;
const EditBtn = st$1(Btn)``;
const DeleteBtn$3 = st$1(Btn)`
  color: ${(props) => props.theme.colors.yRed};
`;
const RestoreBtn = st$1(Btn)``;
const BtnIcon = st$1(Icon$2)`
  margin-right: 15px;
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 3.125vw;
  }
`;
const HideIcon = st$1(BtnIcon)`
  background-image: url(${isHideIcon});
`;
const AddIcon$1 = st$1(BtnIcon)`
  background-image: url(${addIcon$1});
`;
const EditIcon$1 = st$1(BtnIcon)`
  background-image: url(${editIcon$1});
`;
const DeleteIcon$1 = st$1(BtnIcon)`
  background-image: url(${deleteIcon$1});
`;
const VisibleIcon = st$1(BtnIcon)`
  background-image: url(${visibleIcon});
`;
function ControlsPopup({
  innerRef,
  name,
  onHide,
  onAdd,
  onDelete,
  onEdit,
  onRestore,
  onVisible
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay$3, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$C, { ref: innerRef, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title$f, { children: name }),
    onHide && /* @__PURE__ */ jsxRuntimeExports.jsxs(HideBtn, { onClick: onHide, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(HideIcon, {}),
      "скрыть"
    ] }),
    onVisible && /* @__PURE__ */ jsxRuntimeExports.jsxs(VisibleBtn, { onClick: onVisible, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(VisibleIcon, {}),
      "показать"
    ] }),
    onAdd && /* @__PURE__ */ jsxRuntimeExports.jsxs(AddBtn, { onClick: onAdd, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon$1, {}),
      "добавить"
    ] }),
    onEdit && /* @__PURE__ */ jsxRuntimeExports.jsxs(EditBtn, { onClick: onEdit, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon$1, {}),
      "изменить"
    ] }),
    onDelete && /* @__PURE__ */ jsxRuntimeExports.jsxs(DeleteBtn$3, { onClick: onDelete, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon$1, {}),
      "удалить"
    ] }),
    onRestore && /* @__PURE__ */ jsxRuntimeExports.jsx(RestoreBtn, { onClick: onRestore, children: "восстановить" })
  ] }) });
}
const body = document.body;
function AdminBtn({ type, onClick: onClick2, popupName, popupHandlers, styles: styles2 = {} }) {
  const [isPopup, setPopup] = reactExports.useState();
  const user = useTypedSelector((state) => selectUser(state).data);
  const ref = reactExports.useRef(null);
  const popupInnerRef = reactExports.useRef(null);
  const [isAdmin, setAdmin] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (user && user.user.role === USER_ROLES.admin) {
      setAdmin(true);
    }
  }, [user]);
  const handleOverlayClick = (event) => {
    if (!popupInnerRef.current)
      return;
    if (event.target !== popupInnerRef.current && event.target !== ref.current) {
      setPopup(false);
      body.removeEventListener("click", handleOverlayClick);
    }
  };
  const handleClick = (event) => {
    event.stopPropagation();
    if (onClick2) {
      onClick2(event);
    }
    if (type === ADMIN_BTN_TYPES.edit) {
      if (isPopup) {
        setPopup(false);
      } else {
        setPopup(true);
        body.addEventListener("click", handleOverlayClick);
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: isAdmin && /* @__PURE__ */ jsxRuntimeExports.jsx(
    AdminBtn$1,
    {
      style: styles2,
      ref,
      $type: type,
      onClick: handleClick,
      children: isPopup && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ControlsPopup,
        {
          innerRef: popupInnerRef,
          name: popupName,
          ...popupHandlers
        }
      )
    }
  ) });
}
const courseApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getCourses: builder.query({
      query: () => "course",
      providesTags: () => [
        {
          type: "Courses"
        }
      ]
    }),
    getCourseById: builder.query({
      query: (id2) => `course/${id2}`,
      providesTags: () => [
        {
          type: "CourseById"
        }
      ]
    }),
    createCourse: builder.mutation({
      query: (data) => ({
        url: "course/create",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [
        {
          type: "Courses"
        }
      ]
    }),
    updateCourse: builder.mutation({
      query: (data) => ({
        url: "course/update",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["Courses"]
    }),
    deleteCourse: builder.mutation({
      query: (data) => ({
        url: "course/delete",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["Courses"]
    }),
    restoreCourse: builder.mutation({
      query: (data) => ({
        url: "course/restore",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["Courses"]
    }),
    getCourseProgress: builder.query({
      query: (data) => ({
        url: "course/get-users-progress",
        method: "POST",
        body: data
      }),
      providesTags: () => [
        {
          type: "CourseProgress"
        }
      ]
    })
  }),
  overrideExisting: false
});
const {
  useCreateCourseMutation,
  useDeleteCourseMutation,
  useGetCoursesQuery,
  useGetCourseByIdQuery,
  useRestoreCourseMutation,
  useUpdateCourseMutation,
  useGetCourseProgressQuery
} = courseApi;
const selectCourses = courseApi.endpoints.getCourses.select();
const SelectIcon$1 = st$1(Icon$2)`
  top: 25% !important;
  width: 33px;
  height: 33px;
  background-image: url(${selectIcon});
`;
const ProgressContainer$1 = st$1.h4`
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 90px;
  height: 36px;
  border-radius: 18px;
  background-color: ${(props) => props.$isStart ? props.theme.colors.mainBlue : props.theme.colors.dark};
  margin-right: 20px;

  color: #fff;
  font-family: "Montserrat";
  font-size: 24.923px;
  font-weight: 700;
  line-height: 120%;
`;
function ProgressCounter({ percentage = 0 }) {
  const isStart = percentage > 0;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ProgressContainer$1, { $isStart: isStart, children: [
    percentage,
    "%"
  ] });
}
const CustomSelectOption$1 = st$1.label`
  display: flex;
  align-items: center;
  border: 0;
  padding-bottom: 5px;
  cursor: pointer;
  @media ${(props) => props.theme.media.mobile} {
    padding-bottom: 0;
  }
  &*:first-child {
    padding: 0;
  }
  &*:focus {
    background-color: transparent;
  }
`;
const TextLabel = st$1.p`
  margin-right: 30px;
  color: #000;
  font-family: 'Montserrat';
  font-size: 24.923px;
  font-weight: ${(props) => props.$isSelected ? 700 : 500};
  line-height: 120%;
  &:first-child {
    font-weight: 700;
    @media ${(props) => props.theme.media.mobile} {
      font-weight: 500;
    }
  }
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 2%;
    font-size: 4.6875vw;
    font-weight: 500;
  }
`;
const IsHiddenIcon$1 = st$1(Icon$2)`
  margin-left: auto;
  margin-right: 20px;
  background-image: url(${isHideIcon});
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 0;
  }
`;
function CustomSelectOption({
  percentage,
  status,
  title,
  isSelected,
  isDeleted
}) {
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(CustomSelectOption$1, { children: [
    !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressCounter, { percentage: percentage || 0 }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      TextLabel,
      {
        $isSelected: isSelected,
        $isDeleted: isDeleted,
        children: [
          "Курс: ",
          title
        ]
      }
    ),
    status === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IsHiddenIcon$1, {})
  ] });
}
const styles = "";
function CourseCustomSelect({ options, value, onChange }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Select$1,
    {
      value,
      onChange,
      IconComponent: SelectIcon$1,
      sx: {
        minWidth: "50%",
        marginRight: "auto",
        border: 0,
        "& fieldset": { border: "none" }
      },
      children: options.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuItem$1,
        {
          value: option.value,
          sx: {
            "&.Mui-selected": {
              backgroundColor: "#f1f1f1 !important"
            },
            "&.Mui-selected:hover": {
              backgroundColor: "#e0e0e0"
            },
            padding: "10px 25px"
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            CustomSelectOption,
            {
              title: `${option.data.title}`,
              percentage: option.data.percentage,
              status: option.data.status,
              isSelected: option.value === value,
              isDeleted: option.data.isDeleted
            },
            option.value
          )
        },
        option.value
      ))
    }
  );
}
let init = true;
function CourseSelect() {
  const coursesData = useTypedSelector((state) => {
    var _a;
    return (_a = selectCourses(state).data) == null ? void 0 : _a.data;
  });
  const { setModalOpen, setModalType, setCourseData, setLoaderActive } = useActions();
  const [updateCourse] = useUpdateCourseMutation();
  const [deleteCourse] = useDeleteCourseMutation();
  const [restoreCourse] = useRestoreCourseMutation();
  const courseData = useTypedSelector((state) => state.course.data);
  const [selectedValue, setSelectedValue] = reactExports.useState("");
  const navigate = useNavigate();
  const selectOptions = reactExports.useMemo(() => {
    if (!coursesData) {
      return [];
    }
    const options = coursesData.map((course) => {
      var _a;
      return {
        value: `${course.id}`,
        label: course.title,
        data: {
          status: Number(course.status),
          title: course.title,
          percentage: ((_a = course.percentage) == null ? void 0 : _a.percentage) || 0,
          isDeleted: !!course.is_deleted
        }
      };
    });
    return options;
  }, [coursesData]);
  reactExports.useEffect(() => {
    if (selectOptions.length > 0 && init) {
      init = false;
      setSelectedValue(selectOptions[0].value);
    } else if (selectOptions.length > 0) {
      const selectedCourseData = selectOptions.find(
        (option) => Number(option.value) === Number(courseData.id)
      );
      if (!selectedCourseData) {
        return;
      }
      setSelectedValue(selectedCourseData == null ? void 0 : selectedCourseData.value);
    }
  }, [courseData.id, selectOptions]);
  const handleAddCourse = () => {
    setModalType(MODAL_TYPES.createCourse);
    setModalOpen(true);
  };
  const handleEditCourse = () => {
    if (!courseData.id) {
      console.error(`No course with id: ${courseData.id}!`);
      return;
    }
    setModalType(MODAL_TYPES.editCourse);
    setModalOpen(true);
  };
  const handleToggleCourseStatus = () => {
    if (!courseData.id) {
      console.error(`No course with id: ${courseData.id}!`);
      return;
    }
    updateCourse({
      id: courseData.id,
      status: Number(courseData.status) === 0 ? 1 : 0,
      image: courseData.image
    }).then((res) => {
      if ("data" in res) {
        setCourseData(res.data.data);
      }
    });
    setLoaderActive(true);
  };
  const handleDeleteCourse = () => {
    deleteCourse({
      id: Number(courseData.id)
    }).then((res) => {
      if ("result" in res && !res.result) {
        alert("Что-то пошло не так...");
        console.error(`Course with id: ${courseData.id} not found!`);
      }
    });
    setLoaderActive(true);
  };
  const handleRestoreCourse = () => {
    restoreCourse({
      id: Number(courseData.id)
    }).then((res) => {
      if ("result" in res && !res.result) {
        alert("Что-то пошло не так...");
        console.error(`Course with id: ${courseData.id} not found!`);
      }
    });
    setLoaderActive(true);
  };
  const handleChange = (event) => {
    const selectedCourseId = event.target.value;
    setSelectedValue(`${selectedCourseId}`);
    navigate(`/courses/${selectedCourseId}`);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$D, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CourseCustomSelect,
      {
        options: selectOptions,
        value: selectedValue,
        onChange: handleChange
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminBtn,
      {
        popupName: "Курс",
        type: ADMIN_BTN_TYPES.edit,
        onClick: () => {
        },
        popupHandlers: {
          onAdd: handleAddCourse,
          onEdit: handleEditCourse,
          onHide: Number(courseData.status) === 1 ? handleToggleCourseStatus : void 0,
          onVisible: Number(courseData.status) === 0 ? handleToggleCourseStatus : void 0,
          onDelete: courseData.is_deleted ? void 0 : handleDeleteCourse,
          onRestore: courseData.is_deleted ? handleRestoreCourse : void 0
        }
      }
    )
  ] });
}
const Container$B = st$1(FlexContainer)`
  flex-direction: column;
  padding: 60px 0 150px 0;
  @media ${(props) => props.theme.media.mobile} {
    padding: 2% 0 15%;
  }
`;
const Container$A = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  margin-bottom: 66px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 7.8125vw;
  }
`;
const Wrapper$2 = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
  width: 49.7%;
  height: 400px;
  padding: 20px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    height: auto;
    padding: 0.94vw 4.69vw 4.69vw;
  }
`;
const ImgWrapper = st$1(Wrapper$2)`
  padding: 0;
  overflow: hidden;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
const Preview = st$1.img`
  width: 100%;
  height: 100%;
  object-fit: cover;
`;
st$1.p`
  display: flex;
  align-items: center;
  height: fit-content;
  margin-bottom: 33px;
  font-size: 15px;
  font-weight: 500;
  line-height: 130%;
  color: ${(props) => props.theme.colors.realBlack};
`;
st$1.img`
  display: inline-block;
  width: 24px;
  margin: 0 5px;
`;
const LessonName = st$1(Text$6)`
  max-width: 95%;
  font-size: 25px;
  line-height: 130%;
  @media ${(props) => props.theme.media.mobile} {
    max-width: 100%;
    margin-bottom: 12.5vw;
    font-size: 4.6875vw;
  }
`;
const OpenCourse = st$1(DefaultBtn)`
  width: fit-content;
  padding: 0 40px;
  margin-top: auto;
  border-radius: 22px;
  @media ${(props) => props.theme.media.mobile} {
    min-height: 12.5vw;
    padding: 0 7.5vw;
    font-size: 4.6875vw;
    border-radius: 7px;
  }
`;
const CourseName = st$1(LessonName)`
  margin-bottom: 12px;
`;
const CompleteStatus = st$1(Text$6)`
  font-size: 22.689px;
  color: ${(props) => props.theme.colors.mainBlue};
`;
const ErrorName = st$1(LessonName)`
  margin: auto;
`;
const defaultPreview = "/assets/defaultCoursePreview.png";
const arrowRight = "/assets/arrowRight.svg";
const Container$z = st$1(FlexContainer)`
  align-items: center;
  column-gap: 7px;
  flex-wrap: wrap;
  @media ${(props) => props.theme.media.mobile} {
    flex-direction: column;
    align-items: flex-start;
  }
`;
const TextStyle = nt$1`
  font-size: 15px;
  font-weight: 500;
  line-height: 130%;
  color: ${(props) => props.theme.colors.realBlack};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 3.75vw;
  }

  &:not(:last-child) {
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 3.125vw;
    }
  }
`;
const Chapter$1 = st$1.p`
  ${TextStyle}
`;
const Theme$2 = st$1.p`
  ${TextStyle}
`;
const Lesson = st$1.p`
  ${TextStyle}
`;
const Arrow = st$1(Icon$2)`
  background-image: url(${arrowRight});
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
function CourseBreadcrumb({ chapter, theme, lesson, containerStyles }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$z, { style: containerStyles, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Chapter$1, { children: [
      "Глава ",
      chapter.position,
      "/",
      chapter.allQuantity
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Theme$2, { children: [
      "Тема ",
      theme.position,
      "/",
      theme.allQuantity,
      ": ",
      theme.name
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Lesson, { children: [
      "Урок ",
      lesson.position,
      "/",
      lesson.allQuantity
    ] })
  ] });
}
const Container$y = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
`;
const Text$5 = st$1(Text$6)`
  max-width: 268px;
  font-size: 37.778px;
  @media ${(props) => props.theme.media.mobile} {
    max-width: 50%;
    font-size: 6.13vw;
  }
`;
const Percentage = st$1.h3`
  font-size: 105.387px;
  font-weight: 700;
  line-height: 100%;
  color: ${(props) => props.theme.colors.mainBlue};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 17.09vw;
    line-height: 113%;
  }
`;
function ProgressInfo({ text, percentage, styles: styles2 = {} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$y, { style: styles2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Text$5, { children: text }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Percentage, { children: [
      percentage,
      "%"
    ] })
  ] });
}
const Overlay$2 = st$1.div`
  display: flex;
  align-items: flex-end;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: rgba(0, 0, 0, 0.5);
  z-index: ${(props) => props.theme.utils.zIndex.darkOverlay};
`;
const Container$x = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  padding-top: 4.0625vw;
  background-color: ${(props) => props.theme.colors.realWhite};
  border-radius: ${(props) => props.theme.utils.br} ${(props) => props.theme.utils.br} 0px 0px;
`;
const CoursesList = st$1.ul`
  display: flex;
  flex-direction: column;
  padding: 0 4.6875vw;
  margin-bottom: 3.75vw;
`;
const Course$1 = st$1.li`
  &:not(:last-child) {
    margin-bottom: 6.25vw;
  }
`;
const AddCourseBtn = st$1.button`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  padding: 0 4.6875vw;
  margin: 0;
  margin-bottom: 2%;
  background-color: transparent;
`;
const AddCourseBtnTitle = st$1(Text$6)`
  width: 90%;
  font-size: 4.6875vw;
  font-weight: 600;
  text-align: start;
`;
const AddCourseBtnIcon = st$1(Icon$2)`
  background-image: url(${addIcon$2});
`;
const CloseBtnWrapper = st$1.div`
  padding: 3.125vw 4.6875vw;
  border-top: 1px solid ${(props) => props.theme.colors.greyF1};
`;
const CloseBtn$2 = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-height: 15.625vw;
  color: ${(props) => props.theme.colors.grey93};
  background-color: ${(props) => props.theme.colors.greyF1};
`;
function Popup({ coursesData, onClose }) {
  const { setModalOpen, setModalType } = useActions();
  const selectedCourseid = useTypedSelector((state) => state.course.data.id);
  const modalRoot = document.querySelector("#modal-root");
  const navigate = useNavigate();
  if (!modalRoot) {
    return null;
  }
  const handleSelectCourse = (id2) => {
    onClose();
    navigate(`/courses/${id2}`);
  };
  const handleAddCourse = () => {
    onClose();
    setModalOpen(true);
    setModalType(MODAL_TYPES.createCourse);
  };
  return ReactDOM.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay$2, { onClick: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$x, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CoursesList, { children: coursesData && coursesData.map((course) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Course$1,
        {
          onClick: () => {
            handleSelectCourse(course.id);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            CustomSelectOption,
            {
              title: course.title,
              status: course.status,
              isDeleted: !!course.is_deleted,
              isSelected: Number(course.id) === Number(selectedCourseid)
            },
            course.id
          )
        }
      )) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(AddCourseBtn, { onClick: handleAddCourse, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AddCourseBtnTitle, { children: "Добавить курс" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AddCourseBtnIcon, {})
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CloseBtnWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CloseBtn$2, { onClick: onClose, children: "Отмена" }) })
    ] }) }),
    modalRoot
  );
}
const Container$w = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  margin-bottom: 4.6875vw;
`;
const Wrapper$1 = st$1.div`
  display: flex;
  align-items: center;
  width: 100%;
  max-width: 75%;
`;
const CourseTitle = st$1(Text$6)`
  /* width: 90%; */
  margin-right: 1.875vw;
  font-size: 4.6875vw;
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};
`;
const SelectIcon = st$1(Icon$2)`
  background-image: url(${selectIcon});
  @media ${(props) => props.theme.media.mobile} {
    min-width: 7.5vw;
    min-height: 7.5vw;
  }
`;
const IsHiddenIcon = st$1(Icon$2)`
  margin-left: auto;
  margin-right: 2%;
  background-image: url(${isHideIcon});
`;
function OpenSelect({ courseData, onOpen }) {
  const { setModalOpen, setModalType, setLoaderActive, setCourseData } = useActions();
  const [updateCourse] = useUpdateCourseMutation();
  const [deleteCourse] = useDeleteCourseMutation();
  const [restoreCourse] = useRestoreCourseMutation();
  const handleAddCourse = () => {
    setModalType(MODAL_TYPES.createCourse);
    setModalOpen(true);
  };
  const handleEditCourse = () => {
    if (!courseData.id) {
      console.error(`No course with id: ${courseData.id}!`);
      return;
    }
    setModalType(MODAL_TYPES.editCourse);
    setModalOpen(true);
  };
  const handleToggleCourseStatus = () => {
    if (!courseData.id) {
      console.error(`No course with id: ${courseData.id}!`);
      return;
    }
    updateCourse({
      id: courseData.id,
      status: Number(courseData.status) === 0 ? 1 : 0
    }).then((res) => {
      if ("data" in res) {
        setCourseData(res.data.data);
      }
    });
    setLoaderActive(true);
  };
  const handleDeleteCourse = () => {
    deleteCourse({
      id: Number(courseData.id)
    }).then((res) => {
      if ("result" in res && !res.result) {
        alert("Что-то пошло не так...");
        console.error(`Course with id: ${courseData.id} not found!`);
      }
    });
    setLoaderActive(true);
  };
  const handleRestoreCourse = () => {
    restoreCourse({
      id: Number(courseData.id)
    }).then((res) => {
      if ("result" in res && !res.result) {
        alert("Что-то пошло не так...");
        console.error(`Course with id: ${courseData.id} not found!`);
      }
    });
    setLoaderActive(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$w, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Wrapper$1, { onClick: onOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CourseTitle, { $isDeleted: !!courseData.is_deleted, children: courseData.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectIcon, {})
    ] }),
    courseData.status === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(IsHiddenIcon, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminBtn,
      {
        popupName: "Курс",
        type: ADMIN_BTN_TYPES.edit,
        popupHandlers: {
          onAdd: handleAddCourse,
          onEdit: handleEditCourse,
          onHide: Number(courseData.status) === 1 ? handleToggleCourseStatus : void 0,
          onVisible: Number(courseData.status) === 0 ? handleToggleCourseStatus : void 0,
          onDelete: courseData.is_deleted ? void 0 : handleDeleteCourse,
          onRestore: courseData.is_deleted ? handleRestoreCourse : void 0
        }
      }
    )
  ] });
}
const loadingLogo = "/assets/loadingLogo.svg";
const Overlay$1 = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 0;
  left: 0;
  z-index: ${(props) => props.theme.utils.zIndex.popup};
  width: 100%;
  height: 100%;
  border-radius: inherit;
  background-color: ${(props) => props.theme.colors.realWhite};
`;
const Container$v = st$1.div`
  display: flex;
  align-items: center;
  width: fit-content;
`;
const LoadingIcon = st$1(Icon$2)`
  margin-right: 15px;
  background-image: url(${loadingLogo});
`;
const LoadingText = st$1(Text$6)`
  font-size: 22px;
`;
function LoadingSmall() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$v, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingIcon, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingText, { children: "Загрузка..." })
  ] }) });
}
function CourseMainInfo({ coursesData }) {
  var _a;
  const { courseId } = useParams();
  const navigate = useNavigate();
  const courseData = useTypedSelector((state) => state.course.data);
  const [previewSrc, setPreviewSrc] = reactExports.useState("");
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  const [isPopupOpen, setIsPopupOpen] = reactExports.useState(false);
  const { data, isError, isFetching } = useGetCourseProgressQuery(
    { course_id: Number(courseId) },
    {
      skip: !courseId
    }
  );
  reactExports.useEffect(() => {
    if (courseData.image) {
      const src = courseData.image.directory + "/" + courseData.image.name;
      setPreviewSrc(src);
      return;
    }
    setPreviewSrc(defaultPreview);
  }, [courseData.image]);
  const handleLoadError = () => {
    setPreviewSrc(defaultPreview);
  };
  const handleClosePopup = () => {
    setIsPopupOpen(false);
  };
  const handleOpenPopup = () => {
    setIsPopupOpen(true);
  };
  const handleGoToCurrentLesson = () => {
    if (data && "chapter" in data) {
      navigate(`/courses/${courseId}/${data.chapter.id}/${data.theme.id}/${data.lesson.id}`);
    }
  };
  const progressInfoStyles = {
    marginBottom: "3.13vw"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$A, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Wrapper$2, { children: [
      isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSmall, {}),
      isMobile && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          ProgressInfo,
          {
            percentage: `${(_a = courseData.percentage) == null ? void 0 : _a.percentage}`,
            text: "Твой курс закончен на",
            styles: progressInfoStyles
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          OpenSelect,
          {
            courseData,
            onOpen: handleOpenPopup
          }
        )
      ] }),
      data && "chapter" in data && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          CourseBreadcrumb,
          {
            containerStyles: { marginBottom: isMobile ? "5vw" : "30px" },
            chapter: { name: data.chapter.name, position: data.chapter.position, allQuantity: data.chapter.allQuantity },
            theme: { name: data.theme.name, position: data.theme.position, allQuantity: data.theme.allQuantity },
            lesson: { name: data.lesson.name, position: data.lesson.position, allQuantity: data.lesson.allQuantity }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(LessonName, { children: data.lesson.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(OpenCourse, { onClick: handleGoToCurrentLesson, children: "Учиться" })
      ] }),
      data && "courseComplete" in data && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CourseName, { children: courseData.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CompleteStatus, { children: "Пройден" })
      ] }),
      isError || data && "error" in data && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorName, { children: "Информация отсутствует" })
    ] }),
    !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(ImgWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Preview,
      {
        src: previewSrc,
        onError: handleLoadError
      }
    ) }),
    isPopupOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Popup,
      {
        coursesData,
        onClose: handleClosePopup
      }
    )
  ] });
}
const Container$u = st$1(FlexContainer)`
  flex-direction: column;
`;
const Head$2 = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0 3.125vw;
    margin-bottom: 4.6875vw;
    font-size: 4.6875vw;
  }
`;
const Title$e = st$1(Text$6)`
  @media ${(props) => props.theme.media.mobile} {
    margin: 0 auto;
    font-size: 4.6875vw;
  }
`;
const CardList = st$1.ul`
  display: flex;
  flex-wrap: wrap;
  /* justify-content: space-between; */
  gap: 9px;
  @media ${(props) => props.theme.media.mobile} {
    justify-content: space-between;
    gap: unset;
    row-gap: 1.875vw;
  }
`;
const Card = st$1(FlexContainer)`
  flex-direction: column;
  width: 310px;
  height: 400px;
  padding: 20px;
  padding-bottom: 15px;
  background-color: ${(props) => props.$isDeleted ? props.theme.colors.grey93 : props.theme.colors.realWhite};
  border-radius: ${(props) => props.theme.utils.br};
  @media ${(props) => props.theme.media.mobile} {
    width: 49%;
    height: auto;
    min-height: 63.125vw;
    padding: 3.125vw 3.125vw 2.1875vw;
    border-radius: 7.597px;
  }
`;
const imgWrapper = st$1.div`
  width: 100%;
  aspect-ratio: 3/2;
  margin-bottom: 15px;
  overflow: hidden;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.greyEO};
  cursor: pointer;
  transition: transform 0.3s ease-in-out;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 2.5vw;
    border-radius: 7.597px;
  }

  &:hover {
    transform: scale(1.05);
  }
`;
const Img = st$1.img`
  display: block;
  width: 100%;
  height: 100%;
  object-fit: cover;
`;
const Title$d = st$1(Text$6)`
  word-break: break-all;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 3.75vw;
  }
`;
const ProgressContainer = st$1(FlexContainer)`
  flex-direction: column;
  margin-top: auto;
`;
const ProgressStatusWrapper = st$1(FlexContainer)`
  align-items: center;
  margin-bottom: 10px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 0;
  }
`;
st$1.p`
  margin-right: auto;
  font-size: 15px;
  font-weight: 500;
  color: ${(props) => props.theme.colors.realBlack};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 2.5vw;
  }
`;
const defaultCardImg = "/assets/defaultCardImg.png";
const chapterApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getChapterById: builder.query({
      query: (id2) => `chapter/${id2}`,
      providesTags: () => [
        {
          type: "ChapterById"
        }
      ]
    }),
    createChapter: builder.mutation({
      query: (data) => ({
        url: "course/create-chapter",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [
        {
          type: "Courses"
        }
      ]
    }),
    updateChapter: builder.mutation({
      query: (data) => ({
        url: "course/update-chapter",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["Courses", "ChapterById"]
    }),
    deleteChapter: builder.mutation({
      query: (data) => ({
        url: "course/delete-chapter",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["CourseById", "ChapterById"]
    }),
    restoreChapter: builder.mutation({
      query: (data) => ({
        url: "course/restore-chapter",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["CourseById", "ChapterById"]
    })
  }),
  overrideExisting: false
});
const {
  useCreateChapterMutation,
  useDeleteChapterMutation,
  useGetChapterByIdQuery,
  useRestoreChapterMutation,
  useUpdateChapterMutation
} = chapterApi;
function CourseProgrammCard({ data }) {
  const navigation = useNavigate();
  const [deleteChapter] = useDeleteChapterMutation();
  const [restoreChapter] = useRestoreChapterMutation();
  const [isDeleted, setDeleted] = reactExports.useState(false);
  const { setLoaderActive, setModalOpen, setModalType, setUpdatingChapterData } = useActions();
  const [imgSrc, setImgSrc] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (data.image) {
      const src = data.image.directory + "/" + data.image.name;
      setImgSrc(src);
    }
  }, [data.image]);
  reactExports.useEffect(() => {
    Number(data.is_deleted) === 0 ? setDeleted(false) : setDeleted(true);
  }, [data.is_deleted]);
  const handleClick = () => {
    navigation(`/courses/${data.course_id}/${data.id}/`);
  };
  const handleDeleteChapter = () => {
    deleteChapter({ id: data.id }).then(() => {
      setLoaderActive(false);
      setDeleted(true);
    });
    setLoaderActive(true);
  };
  const handleRestoreChapter = () => {
    restoreChapter({ id: data.id }).then(() => {
      setLoaderActive(false);
      setDeleted(false);
    });
    setLoaderActive(true);
  };
  const handleEditChapter = () => {
    setModalType(MODAL_TYPES.editChapter);
    setUpdatingChapterData(data);
    setModalOpen(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { $isDeleted: isDeleted, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(imgWrapper, { onClick: handleClick, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Img, { src: imgSrc || defaultCardImg }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title$d, { children: data.title }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressStatusWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminBtn,
      {
        popupName: "Глава",
        type: ADMIN_BTN_TYPES.edit,
        onClick: () => {
        },
        popupHandlers: {
          onDelete: isDeleted ? void 0 : handleDeleteChapter,
          onRestore: isDeleted ? handleRestoreChapter : void 0,
          onEdit: handleEditChapter
        }
      }
    ) }) })
  ] });
}
function CourseProgramm() {
  const { setModalOpen, setModalType } = useActions();
  const courseChapters = useTypedSelector((state) => {
    var _a;
    return (_a = state.course.data) == null ? void 0 : _a.chapters;
  });
  const role = useTypedSelector((state) => {
    var _a;
    return (_a = selectUser(state).data) == null ? void 0 : _a.user.role;
  });
  const [chaptersData, setChaptersData] = reactExports.useState();
  reactExports.useEffect(() => {
    if (courseChapters && courseChapters) {
      setChaptersData(courseChapters);
    } else {
      setChaptersData([]);
    }
  }, [courseChapters]);
  const openCreateChapterModal = () => {
    setModalType(MODAL_TYPES.createChapter);
    setModalOpen(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$u, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Head$2, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Title$e, { as: "h4", children: "Программа курса" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        AdminBtn,
        {
          popupName: "Глава",
          type: ADMIN_BTN_TYPES.add,
          onClick: openCreateChapterModal
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CardList, { children: chaptersData && chaptersData.length > 0 && chaptersData.map((chapter) => {
      if (!chapter.is_deleted || role === USER_ROLES.admin) {
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          CourseProgrammCard,
          {
            data: chapter
          },
          chapter.id
        );
      }
    }) })
  ] });
}
const Container$t = st$1(FlexContainer)`
  align-items: center;
  justify-content: center;
  height: 188px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
`;
const Text$4 = st$1(Text$6)`
  font-size: 22.714px;
`;
function ErrorBlock() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$t, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$4, { children: "Что-то пошло не так" }) });
}
const NoAvailableCourses = st$1(FlexContainer)`
  align-items: center;
  justify-content: center;
  min-height: 200px;
  background-color: ${(props) => props.theme.colors.realWhite};
  border-radius: ${(props) => props.theme.utils.br};
`;
const NoAvailableCoursesText = st$1(Text$6)`
  margin-right: 10px;
  font-size: 22px;
`;
function NoAvailable({ text, onAdd = () => {
}, style: style2 = {} }) {
  const user = useTypedSelector((state) => {
    var _a;
    return (_a = selectUser(state).data) == null ? void 0 : _a.user;
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(NoAvailableCourses, { style: style2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(NoAvailableCoursesText, { children: text }),
    (user == null ? void 0 : user.role) === "admin" && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminBtn,
      {
        popupName: "",
        onClick: onAdd,
        type: "add"
      }
    )
  ] });
}
function CoursePreview() {
  const { data, isError, isFetching } = useGetCoursesQuery();
  const { setCourseData, setLoaderActive, setModalOpen, setModalType } = useActions();
  const params = useParams();
  const navigate = useNavigate();
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  reactExports.useEffect(() => {
    setLoaderActive(isFetching);
  }, [isFetching, setLoaderActive]);
  reactExports.useEffect(() => {
    if (data) {
      const currentCourseId = params.courseId || null;
      const currentCourse = data.data.find((course) => course.id === Number(currentCourseId));
      if (data.data.length > 0 && !currentCourseId || data.data.length > 0 && !currentCourse) {
        navigate(`/courses/${data.data[0].id}`);
        return;
      }
      if (data.data.length === 0) {
        navigate("/courses");
      }
      if (currentCourse) {
        setCourseData(currentCourse);
      }
    }
  }, [data, navigate, params.courseId, setCourseData]);
  const handleCreateCourse = () => {
    setModalOpen(true);
    setModalType("createCourse");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$B, { children: [
    isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
    data && data.data.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(CourseSelect, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CourseMainInfo, { coursesData: data.data }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CourseProgramm, {})
    ] }),
    data && data.data.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(NoAvailable, { text: "Нет доступных курсов", onAdd: handleCreateCourse })
  ] }) });
}
const Container$s = st$1.div`
  display: flex;
  align-items: center;
  width: 100%;
  margin-bottom: 30px;
  cursor: pointer;
  opacity: ${(props) => props.$isDeleted ? 0.5 : 1};
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};
  transition: opacity 0.2s ease-in-out;

  &:hover {
    opacity: 1;
  }
`;
const lessonApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getLessonById: builder.query({
      query: (id2) => `lesson/${id2}`,
      providesTags: () => [
        {
          type: "LessonById"
        }
      ]
    }),
    createLesson: builder.mutation({
      query: (data) => ({
        url: "course/create-lesson",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [
        {
          type: "ChapterById"
        }
      ]
    }),
    updateLesson: builder.mutation({
      query: (data) => ({
        url: "course/update-lesson",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["LessonById"]
    }),
    deleteLesson: builder.mutation({
      query: (data) => ({
        url: "course/delete-lesson",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["LessonById", "ChapterById"]
    }),
    restoreLesson: builder.mutation({
      query: (data) => ({
        url: "course/restore-lesson",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["LessonById", "ChapterById"]
    }),
    checkLesson: builder.mutation({
      query: (data) => ({
        url: "course/check-lesson",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => ["ChapterById", "LessonById"]
    })
  }),
  overrideExisting: false
});
const {
  useCheckLessonMutation,
  useCreateLessonMutation,
  useDeleteLessonMutation,
  useGetLessonByIdQuery,
  useRestoreLessonMutation,
  useUpdateLessonMutation
} = lessonApi;
const Title$c = st$1.p`
  font-size: 15px;
  font-weight: 500;
  line-height: 100%;
  color: ${(props) => props.$active ? props.theme.colors.dark : props.theme.colors.grey93};
  text-decoration: ${(props) => props.$isDeleted ? "line-through" : "none"};
  @media ${(props) => props.theme.media.mobile} {
    font-size: 3.75vw;
  }
`;
function CourseNavItemTitle({
  text = "",
  children,
  onClick: onClick2 = () => {
  },
  styles: styles2 = {},
  isActive = true,
  isDeleted = false
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Title$c,
    {
      style: styles2,
      onClick: onClick2,
      $active: isActive,
      $isDeleted: isDeleted,
      children: [
        text,
        children
      ]
    }
  );
}
function CourseNavLesson({ data }) {
  const [isInit, setInit] = reactExports.useState(true);
  const { setActiveLesson, setLoaderActive } = useActions();
  const navigate = useNavigate();
  const { lessonId, chapterId, courseId } = useParams();
  const [deleteLesson] = useDeleteLessonMutation();
  const [restoreLesson] = useRestoreLessonMutation();
  const handleClick = () => {
    setActiveLesson(data);
    const lessonPath = generatePath(`/courses/:courseId/:chapterId/:themeId/:lessonId`, {
      courseId: String(courseId),
      chapterId: String(chapterId),
      themeId: String(data.theme_id),
      lessonId: String(data.id)
    });
    navigate(lessonPath);
  };
  reactExports.useEffect(() => {
    if (isInit && lessonId) {
      if (data.id === Number(lessonId)) {
        setActiveLesson(data);
      }
      setInit(false);
    }
  }, [data, isInit, lessonId, setActiveLesson]);
  const handleEditLesson = () => {
    navigate(
      generatePath(`/courses/:courseId/:chapterId/:themeId/:lessonId/edit-lesson`, {
        courseId: String(courseId),
        chapterId: String(chapterId),
        themeId: String(data.theme_id),
        lessonId: String(data.id)
      })
    );
  };
  const handleDeleteLesson = () => {
    deleteLesson({
      id: Number(data.id)
    });
    setLoaderActive(true);
  };
  const handleRestoreLesson = () => {
    restoreLesson({
      id: Number(data.id)
    });
    setLoaderActive(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$s, { $isDeleted: !!data.is_deleted, onClick: handleClick, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CourseNavItemTitle, { text: data.title, isActive: !data.isChecked }),
    data.isChecked && /* @__PURE__ */ jsxRuntimeExports.jsx(DoneIcon$2, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminBtn,
      {
        popupName: "Урок",
        styles: { marginLeft: "auto" },
        type: "edit",
        onClick: () => {
        },
        popupHandlers: {
          onEdit: handleEditLesson,
          onDelete: data.is_deleted ? void 0 : handleDeleteLesson,
          onRestore: data.is_deleted ? handleRestoreLesson : void 0
        }
      }
    )
  ] });
}
const dndIcon = "/assets/dnd-btn.svg";
const DndBtn$1 = st$1.button`
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  padding: 5px;
  background-color: transparent;
  cursor: grab;
  background-image: url(${dndIcon});
  background-repeat: no-repeat;
  background-size: 100%;
  background-position: center;
`;
function DndBtn({ onClick: onClick2, styles: styles2 = {} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DndBtn$1,
    {
      style: styles2,
      onClick: onClick2
    }
  );
}
const Container$r = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
  opacity: ${(props) => props.$isDeleted ? 0.5 : 1};
`;
const Theme$1 = st$1(FlexContainer)`
  align-items: center;
  margin-bottom: 30px;
`;
const AccSum = st$1(FlexContainer)`
  align-items: center;
`;
st$1.button`
  display: flex;
  align-items: center;
  width: fit-content;
  padding: 0;
  margin-right: 5px;
  background-color: transparent;
`;
st$1.div`
  width: 83%;
  height: 0px;
  overflow: hidden;
  margin-left: auto;
  transition: all 0.2s ease-in-out;
  animation: ${(props) => props.$active ? "openAccordion" : "closeAccrodion"} .2s ease-out forwards;

  @keyframes openAccordion {
    99% {
      height: ${(props) => props.$height};
      overflow: hidden;
    }
    100% {
      height: ${(props) => props.$height};
      overflow: visible;
    }
  }

  @keyframes closeAccrodion {
    0% {
      height: ${(props) => props.$height};
      overflow: hidden;
    }
    100% {
      height: 0px;
      overflow: hidden;
    }
  }
`;
st$1(FlexContainer)`
  flex-direction: column;
  min-height: fit-content;
`;
const themeApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getThemeById: builder.query({
      query: (id2) => `theme/${id2}`,
      providesTags: () => [
        {
          type: "ThemeById"
        }
      ]
    }),
    createTheme: builder.mutation({
      query: (data) => ({
        url: "course/create-theme",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [
        {
          type: "ChapterById"
        }
      ]
    }),
    updateTheme: builder.mutation({
      query: (data) => ({
        url: "course/update-theme",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => ["ChapterById"]
    }),
    deleteTheme: builder.mutation({
      query: (data) => ({
        url: "course/delete-theme",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => ["ChapterById"]
    }),
    restoreTheme: builder.mutation({
      query: (data) => ({
        url: "course/restore-theme",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => ["ChapterById"]
    })
  }),
  overrideExisting: false
});
const {
  useCreateThemeMutation,
  useDeleteThemeMutation,
  useGetThemeByIdQuery,
  useRestoreThemeMutation,
  useUpdateThemeMutation
} = themeApi;
function CourseNavTheme({ data, courseId }) {
  const { setActiveTheme, setModalOpen, setModalType, setUpdatingThemeData, setLoaderActive } = useActions();
  const [deleteTheme] = useDeleteThemeMutation();
  const [restoreTheme] = useRestoreThemeMutation();
  const navigate = useNavigate();
  const { themeId } = useParams();
  const isThemeChecked = reactExports.useMemo(() => {
    if (data.lessons && data.lessons.length > 0) {
      const uncheckedLessons = data.lessons.filter((lesson) => lesson.isChecked !== true);
      return uncheckedLessons.length === 0;
    }
    return false;
  }, [data.lessons]);
  const handleChange = (panel) => (event, isExpanded) => {
    setActiveTheme(data);
    const themePath = generatePath(
      `/courses/:courseId/:chapterId/${isExpanded ? ":themeId" : ""}`,
      {
        courseId: String(courseId),
        chapterId: String(data.chapter_id),
        themeId: panel ? String(panel) : ""
      }
    );
    navigate(themePath);
  };
  const handleAddLesson = () => {
    const createLessonPath = generatePath(`/courses/:courseId/:chapterId/:themeId/create-lesson/`, {
      courseId: String(courseId),
      chapterId: String(data.chapter_id),
      themeId: String(data.id)
    });
    navigate(createLessonPath);
  };
  const handleEditTheme = () => {
    setUpdatingThemeData(data);
    setModalType("editTheme");
    setModalOpen(true);
  };
  const handleDeleteTheme = () => {
    deleteTheme({
      id: data.id
    });
    setLoaderActive(true);
  };
  const handleRestoreTheme = () => {
    restoreTheme({
      id: data.id
    });
    setLoaderActive(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$r, { $isDeleted: !!data.is_deleted, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Theme$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Accordion$1,
    {
      sx: { width: "100%", boxShadow: "unset" },
      expanded: Number(themeId) === data.id,
      onChange: handleChange(data.id),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          AccordionSummary$1,
          {
            sx: { padding: 0 },
            expandIcon: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { display: "none" } }),
            "aria-controls": `${data.id}_content`,
            id: `${data.id}_header`,
            children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AccSum, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                DndBtn,
                {
                  onClick: () => {
                  },
                  styles: { marginRight: "20px" }
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionIcon, { $active: Number(themeId) === data.id }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                CourseNavItemTitle,
                {
                  text: data.title,
                  isActive: !isThemeChecked,
                  isDeleted: !!data.is_deleted
                }
              ),
              isThemeChecked && /* @__PURE__ */ jsxRuntimeExports.jsx(DoneIcon$2, {}),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                AdminBtn,
                {
                  popupName: "Тема",
                  styles: { marginLeft: "auto" },
                  type: "edit",
                  onClick: () => {
                  },
                  popupHandlers: {
                    onAdd: handleAddLesson,
                    onEdit: handleEditTheme,
                    onDelete: data.is_deleted ? void 0 : handleDeleteTheme,
                    onRestore: data.is_deleted ? handleRestoreTheme : void 0
                  }
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionDetails$1, { sx: { paddingLeft: "102px", paddingRight: 0 }, children: data.lessons && data.lessons.map((lesson) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          CourseNavLesson,
          {
            data: lesson
          },
          lesson.id
        )) })
      ]
    }
  ) }) });
}
const Container$q = st$1(FlexContainer)`
  flex-direction: column;
`;
const Title$b = st$1.h4`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 25px;
  font-size: 18px;
  font-weight: 500;
  line-height: 100%;
  color: ${(props) => props.theme.colors.grey93};

  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 3.125vw;
    font-size: 3.75vw;
  }
`;
function FadedTitle({ text, children, onClick: onClick2 = () => {
}, styles: styles2 = {} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Title$b,
    {
      onClick: onClick2,
      style: styles2,
      children: [
        text,
        children
      ]
    }
  );
}
function CourseNavBody({ data }) {
  const { setModalType, setModalOpen } = useActions();
  const userRole = useTypedSelector((state) => {
    var _a;
    return (_a = selectUser(state).data) == null ? void 0 : _a.user.role;
  });
  const openCreateThemeModal = () => {
    setModalType(MODAL_TYPES.createTheme);
    setModalOpen(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$q, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(FadedTitle, { text: "Темы главы", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminBtn,
      {
        popupName: "Тема",
        type: "add",
        onClick: openCreateThemeModal
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Container$q, { children: data.themes && data.themes.map((theme) => {
      if (Number(theme.is_deleted) === 1 && userRole !== "admin") {
        return;
      }
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        CourseNavTheme,
        {
          data: theme,
          courseId: data.course_id
        },
        theme.id
      );
    }) })
  ] });
}
const Container$p = st$1(FlexContainer)`
  height: calc(100vh - 62.25px);
  background-color: ${(props) => props.theme.colors.realWhite};
`;
const NavContainer = st$1(FlexContainer)`
  flex-direction: column;
  width: 33.25%; 
  padding: 15px 15px 80px;
  border-right: 1px solid ${(props) => props.theme.colors.greyF1};
`;
const ContentContainer = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
  width: calc(100% - 33.25%);
  max-height: 100vh;
  overflow-y: scroll;
  padding: 20px 35px 80px;
  margin-left: auto;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    padding: 3.125vw 0 10vw;
    margin: 0;
  }
`;
const bodyOverflow$1 = at$1`
  body {
    overflow: hidden;
    background-color: ${(props) => props.theme.colors.realWhite};
  }
`;
const Container$o = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 18px;
  margin-bottom: 40px;
`;
const TitleWrapper = st$1(FlexContainer)`
  justify-content: space-between;
  align-items: center;
`;
const Title$a = st$1(Text$6)`
  font-size: 25px;
`;
const ProgressBar = st$1(ProgressBar$1)`
  height: 10px;
`;
function CourseNavHead({ data }) {
  const [deleteChapter] = useDeleteChapterMutation();
  const [restoreChapter] = useRestoreChapterMutation();
  const { setLoaderActive, setModalType, setUpdatingChapterData, setModalOpen } = useActions();
  const chapterProgress = reactExports.useMemo(() => {
    var _a;
    if (data) {
      let lessons = 0;
      let checkedlessons = 0;
      (_a = data.themes) == null ? void 0 : _a.forEach((theme) => {
        var _a2;
        (_a2 = theme.lessons) == null ? void 0 : _a2.forEach((lesson) => {
          if (lesson.isChecked) {
            checkedlessons++;
          }
          lessons++;
        });
      });
      return checkedlessons / lessons * 100;
    }
  }, [data]);
  const handleDeleteChapter = () => {
    deleteChapter({ id: data.id }).then(() => {
      setLoaderActive(false);
    });
    setLoaderActive(true);
  };
  const handleRestoreChapter = () => {
    restoreChapter({ id: data.id }).then(() => {
      setLoaderActive(false);
    });
    setLoaderActive(true);
  };
  const handleEditChapter = () => {
    setUpdatingChapterData(data);
    setModalType(MODAL_TYPES.editChapter);
    setModalOpen(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$o, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TitleWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Title$a,
        {
          $isDeleted: !!data.is_deleted,
          as: "h3",
          children: data.title
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        AdminBtn,
        {
          popupName: "Глава",
          type: "edit",
          onClick: () => {
          },
          popupHandlers: {
            onDelete: !data.is_deleted ? handleDeleteChapter : void 0,
            onRestore: data.is_deleted ? handleRestoreChapter : void 0,
            onEdit: handleEditChapter
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ProgressBar, { $progress: `${chapterProgress}` })
  ] });
}
const forwardIcon = "/assets/forwardIcon.svg";
const forwardIconDisabled = "/assets/forwardIconDisabled.svg";
const Title$9 = st$1(Text$6)`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 35px;
  font-size: 31px;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0 3.125vw;
    margin-bottom: 6.25vw;
    font-size:  5.625vw;
  }
`;
const Container$n = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
`;
st$1(FlexContainer)`
  flex-direction: column;
  padding-right: 20px;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0;
  }
`;
st$1.div`
  position: absolute;
  top: 0;
  right: 0;
`;
const NoOpenLesson = st$1(Text$6)`
  font-size: 31px;
`;
const ForwardBtn = st$1(DefaultBtn)`
  width: 166px;
  padding: 0 20px 0 28px;
  text-align: start;
  background-image: url(${forwardIcon});
  background-repeat: no-repeat;
  background-position: 87% 50%;
  background-size: 33px;
  @media ${(props) => props.theme.media.mobile} {
    width: fit-content;
    min-height: 15.625vw;
    padding: 0px 15vw 0px 8vw;
    margin: 0;
    margin-left: auto;
    margin-right: 3.125vw;
    text-align: center;
    background-position: 88% 50%;
    background-size: 10.3125vw;
  }

  &:disabled {
    color: ${(props) => props.theme.colors.grey57};
    background-color: ${(props) => props.theme.colors.grey93};
    background-image: url(${forwardIconDisabled});
  }
`;
const Container$m = st$1(FlexContainer)`
  display: flex;
  width: 100%;
  flex-direction: column;
  padding: 40px 45px;
  border: 1px solid
    ${(props) => props.$isPassed ? props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed : props.theme.colors.greyF1};
  border-radius: ${(props) => props.theme.utils.br};
  margin-bottom: 30px;
  @media ${(props) => props.theme.media.mobile} {
    padding: 6.25vw;
    border-radius: 17.089px;
  }

  &:last-child {
    margin-bottom: 115px;
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 3.125vw;
    }
  }
`;
const Title$8 = st$1(Text$6)`
  margin-bottom: 40px;
  font-size: 25px;
  line-height: 150%;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 4.6875vw;
    font-size: 4.6875vw;
  }
`;
const Answers = st$1(FlexContainer)`
  flex-direction: column;
  margin-bottom: 30px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 6.25vw;
  }
`;
const CheckBtn = st$1(DefaultBtn)`
  align-self: flex-end;
  width: fit-content;
  padding: 19px 30px;
  @media ${(props) => props.theme.media.mobile} {
    align-self: center;
    padding: 0;
    width: 100%;
    min-height: 12.5vw;
    font-weight: 500;
    text-align: center;
    border-radius: 15px;
  }

  &:disabled {
    color: ${(props) => props.theme.colors.grey57};
    background-color: ${(props) => props.theme.colors.grey93};
  }
`;
const radio = "/assets/radio.svg";
const radioChecked = "/assets/radio-checked.svg";
const Label$2 = st$1.label`
  display: flex;
  align-items: center;
  cursor: pointer;
  ${TextStyles}
  font-weight: 400;
  @media ${(props) => props.theme.media.mobile} {
    font-size: 4.6875vw;
  }

  &:not(:last-child) {
    margin-bottom: 20px;
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 6.25vw;
    }
  }
`;
const RadioBtn$1 = st$1.input`
  appearance: none;
  width: 36px;
  height: 36px;
  margin-right: 25px;
  background-image: url(${radio});
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;
  @media ${(props) => props.theme.media.mobile} {
    width: 7.5vw;
    height: 7.5vw;
    margin-right: 3.75vw;
  }

  &:checked {
    background-image: url(${radioChecked});
  }
`;
function RadioBtn({ onChange, label, name, disabled = false }) {
  const handleChange = () => {
    if (onChange) {
      onChange();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Label$2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioBtn$1,
      {
        type: "radio",
        onChange: handleChange,
        name,
        disabled
      }
    ),
    label
  ] });
}
const lessonTestApi = api.injectEndpoints({
  endpoints: (builder) => ({
    addTest: builder.mutation({
      query: (data) => ({
        url: "test/add-test",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [{ type: "LessonById" }]
    }),
    updateTest: builder.mutation({
      query: (data) => ({
        url: "test/update-test",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [{ type: "LessonById" }]
    }),
    createQuestion: builder.mutation({
      query: (data) => ({
        url: "test/create-question",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [{ type: "LessonById" }]
    }),
    updateQuestion: builder.mutation({
      query: (data) => ({
        url: "test/update-question",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [{ type: "LessonById" }]
    }),
    deleteQuestion: builder.mutation({
      query: (data) => ({
        url: "test/delete-question",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => ["LessonById", "LessonById"]
    }),
    sendAnswer: builder.mutation({
      query: (data) => ({
        url: "test/send-answer",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => ["LessonById"]
    })
  }),
  overrideExisting: false
});
const {
  useAddTestMutation,
  useCreateQuestionMutation,
  useDeleteQuestionMutation,
  useSendAnswerMutation,
  useUpdateQuestionMutation,
  useUpdateTestMutation
} = lessonTestApi;
const wrongAnswer = "/assets/wrongAnswer.svg";
const rightAnswer = "/assets/rightAnswer.svg";
const Container$l = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 15px;
  @media ${(props) => props.theme.media.mobile} {
    row-gap: unset;
  }
  
  &:not(:last-child) {
    margin-bottom: 40px;
    @media ${(props) => props.theme.media.mobile} {
      margin-bottom: 6.25vw;
    }
  }
`;
const Answer = st$1(Text$6)`
  padding-left: 56px;
  font-weight: 400;
  color: ${(props) => props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed};
  background-image: url(${(props) => props.$isRight ? rightAnswer : wrongAnswer});
  background-repeat: no-repeat;
  background-position: left center;
  background-size: 36px;
  @media ${(props) => props.theme.media.mobile} {
    padding-left: 9.6875vw;
    background-size: 7.5vw;
  }
`;
const Comment = st$1(Text$6)`
  font-weight: 600;
  color: ${(props) => props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed};
`;
function CheckedAnswer({ data }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$l, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Answer, { $isRight: !!data.right_answer, children: data.answer }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Comment, { $isRight: !!data.right_answer, children: data.text })
  ] });
}
function LessonTest({ data }) {
  const { setLoaderActive } = useActions();
  const [checkedAnswer, setCheckedAnswer] = reactExports.useState(null);
  const [sendAnswer] = useSendAnswerMutation();
  const [isUserRightAnswer, setIsUserRightAnswer] = reactExports.useState(false);
  const [isTestPassed, setIsTestPassed] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (data.userTestAnswer) {
      setIsTestPassed(true);
      setIsUserRightAnswer(!!data.userTestAnswer.is_right);
    }
  }, [data.userTestAnswer]);
  const handleChange = (answer) => {
    setCheckedAnswer(answer);
  };
  const handleSendAnswer = () => {
    if (checkedAnswer) {
      sendAnswer({ test_id: data.id, answer: checkedAnswer }).then(() => {
        setCheckedAnswer(null);
      });
      setLoaderActive(true);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container$m,
    {
      $isRight: isUserRightAnswer,
      $isPassed: isTestPassed,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$8, { children: data.question }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Answers, { children: [
          !data.userTestAnswer && data.answers.map((answer) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            RadioBtn,
            {
              name: data.id,
              label: `${answer.answer}`,
              onChange: () => {
                handleChange(`${answer.id}`);
              }
            },
            answer.id
          )),
          data.userTestAnswer && data.answers.map((answer) => {
            var _a, _b;
            if (Number(answer.id) === ((_a = data.userTestAnswer) == null ? void 0 : _a.answer)) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckedAnswer, { data: answer });
            }
            if (!!answer.right_answer && Number(answer.id) !== ((_b = data.userTestAnswer) == null ? void 0 : _b.answer)) {
              return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckedAnswer, { data: answer });
            }
            return /* @__PURE__ */ jsxRuntimeExports.jsx(
              RadioBtn,
              {
                name: data.id,
                label: `${answer.answer}`,
                onChange: () => {
                },
                disabled: true
              },
              answer.id
            );
          })
        ] }),
        !data.userTestAnswer && /* @__PURE__ */ jsxRuntimeExports.jsx(
          CheckBtn,
          {
            onClick: handleSendAnswer,
            disabled: !checkedAnswer,
            children: "Проверить"
          }
        )
      ]
    }
  );
}
const useMediaQuery = (query) => {
  if (!query) {
    console.error(`useMediaQuery: ${query}. Current query is not valid!`);
    return false;
  }
  return window.matchMedia(query).matches;
};
function CourseContent() {
  const { setLoaderActive } = useActions();
  const { courseId, lessonId, chapterId } = useParams();
  const chapterData = useGetChapterByIdQuery(Number(chapterId), {
    skip: !chapterId
  });
  const [deleteLesson] = useDeleteLessonMutation();
  const [restoreLesson] = useRestoreLessonMutation();
  const { data, isError, isFetching } = useGetLessonByIdQuery(String(lessonId), {
    skip: !lessonId
  });
  const [checkLesson] = useCheckLessonMutation();
  const [isForwardBtnDisabled, setIsForwardBtnDisabled] = reactExports.useState(true);
  const isMobile = useMediaQuery(MediaQueries.mobile);
  const navigate = useNavigate();
  const isTestsPassed = reactExports.useMemo(() => {
    if ((data == null ? void 0 : data.data.tests) && (data == null ? void 0 : data.data.tests.length) > 0) {
      return data == null ? void 0 : data.data.tests.every((test) => test.userTestAnswer);
    }
  }, [data == null ? void 0 : data.data.tests]);
  reactExports.useEffect(() => {
    if (isFetching || (data == null ? void 0 : data.data.isChecked) || (data == null ? void 0 : data.data.tests) && (data == null ? void 0 : data.data.tests.length) > 0 && !isTestsPassed) {
      setIsForwardBtnDisabled(true);
    } else {
      setIsForwardBtnDisabled(false);
    }
  }, [data == null ? void 0 : data.data.isChecked, data == null ? void 0 : data.data.tests, isFetching, isTestsPassed]);
  const handleCheckLesson = () => {
    if (data && data.data.id) {
      checkLesson({ id: data.data.id }).then((res) => {
        var _a;
        if (!("data" in res) || "data" in res && !res.data.data) {
          return;
        }
        if (!chapterData.data || !chapterData.data.data || !chapterData.data.data.themes) {
          return;
        }
        const theme = (_a = chapterData.data) == null ? void 0 : _a.data.themes.find((theme2) => theme2.id === res.data.data.theme_id);
        if (!theme || !(theme == null ? void 0 : theme.lessons)) {
          return;
        }
        const index = theme == null ? void 0 : theme.lessons.findIndex((lesson) => lesson.id === Number(lessonId));
        if (index && index !== -1 && (theme == null ? void 0 : theme.lessons.length) > index + 1) {
          navigate(`/courses/${courseId}/${chapterId}/${res.data.data.theme_id}/${theme.lessons[index + 1].id}`);
        }
        setLoaderActive(false);
      });
      setLoaderActive(true);
    }
  };
  const renderLessonTests = () => {
    return data == null ? void 0 : data.data.tests.map((test) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      LessonTest,
      {
        data: test
      },
      test.id
    ));
  };
  const renderForwardButton = () => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ForwardBtn,
      {
        onClick: handleCheckLesson,
        disabled: isForwardBtnDisabled,
        children: "Вперёд"
      }
    );
  };
  const handleEditLesson = () => {
    if (data) {
      navigate(
        generatePath(`/courses/:courseId/:chapterId/:themeId/:lessonId/edit-lesson`, {
          courseId: String(courseId),
          chapterId: String(chapterId),
          themeId: String(data.data.theme_id),
          lessonId: String(data.data.id)
        })
      );
    }
  };
  const handleDeleteLesson = () => {
    if (!data)
      return;
    deleteLesson({
      id: Number(data.data.id)
    });
    setLoaderActive(true);
  };
  const handleRestoreLesson = () => {
    if (!data)
      return;
    restoreLesson({
      id: Number(data.data.id)
    });
    setLoaderActive(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    !lessonId && /* @__PURE__ */ jsxRuntimeExports.jsx(NoOpenLesson, { children: "Выберите урок" }),
    lessonId && isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
    lessonId && data && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$9, { as: "h2", children: [
        data.data.title,
        !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdminBtn,
          {
            popupName: "Урок",
            type: "edit",
            onClick: () => {
            },
            popupHandlers: {
              onEdit: handleEditLesson,
              onDelete: data.data.is_deleted ? void 0 : handleDeleteLesson,
              onRestore: data.data.is_deleted ? handleRestoreLesson : void 0
            }
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$n, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: data.data.description } }),
        data.data.tests.length > 0 && renderLessonTests(),
        data.data.description.length > 0 && !isFetching && !data.data.isChecked && renderForwardButton()
      ] })
    ] })
  ] });
}
const closeIcon = "/assets/close-icon.svg";
const Button$1 = st$1.button`
  width: 24px;
  height: 24px;
  padding: 0;
  margin: 0;
  background-image: url(${closeIcon});
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;
  background-color: transparent;
  @media ${(props) => props.theme.media.mobile} {
    width: 7.5vw;
    height: 7.5vw;
  }
`;
function CloseBtn$1({ onClick: onClick2 = () => {
}, styles: styles2 = {} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Button$1,
    {
      onClick: onClick2,
      style: styles2
    }
  );
}
const arrowIcon = "/assets/grey-arrow-right.svg";
const NavList$2 = st$1.ul`
  display: flex;
  align-items: center;
  width: fit-content;
`;
const NavItem = st$1.li`
  padding-bottom: 3.125vw;
  border-bottom: 4px solid ${(props) => props.theme.colors.grey93};
  margin-right: 3.125vw;
  font-size: 4.6875vw;
  font-weight: 500;
  line-height: 130%;
  color: #000;
`;
const Chapter = st$1(NavItem)`
  ${(props) => {
  if (!props.$isActive) {
    return nt$1`
        color: ${(props2) => props2.theme.colors.grey93};
        border-bottom: none;
      `;
  }
}}
`;
const ArrowIcon = st$1(Icon$2)`
  margin-right: 3.125vw;
  background-image: url(${arrowIcon});
`;
const Theme = st$1(NavItem)`
  color: ${(props) => props.theme.colors.dark};
  border-color: ${(props) => props.theme.colors.dark};
`;
function NavBar({ activeStep }) {
  const { courseId, chapterId } = useParams();
  const navigate = useNavigate();
  const handleClick = reactExports.useCallback(() => {
    if (activeStep === Steps.theme) {
      navigate(`/courses/${courseId}/${chapterId}`);
    }
  }, [activeStep, chapterId, courseId, navigate]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(NavList$2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Chapter,
      {
        $isActive: activeStep === Steps.chapter,
        onClick: handleClick,
        children: "Глава"
      }
    ),
    activeStep === Steps.theme && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowIcon, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Theme, { children: "Тема" })
    ] })
  ] });
}
const Container$k = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  border-bottom: 1px solid ${(props) => props.theme.colors.grey93};
  margin-bottom: 4.6875vw;
`;
function Head$1({ activeStep, onClose = () => {
} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$k, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(NavBar, { activeStep }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CloseBtn$1, { onClick: onClose })
  ] });
}
const Container$j = st$1.div`
  display: flex;
  flex-direction: column;
  position: fixed;
  top: 0;
  left: 0;
  z-index: ${(props) => props.theme.utils.zIndex.overDarkOverlay};
  width: 100vw;
  height: 100vh;
  overflow-y: auto;
  padding: 3.125vw; 
  background-color: ${(props) => props.theme.colors.realWhite};
`;
const MainContent = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
`;
const NavList$1 = st$1.ul`
  display: flex;
  flex-direction: column;
  width: 100%;
  row-gap: 3.125vw;
`;
const NavListItem$1 = st$1.li`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  min-height: 7.5vw;
`;
const DoneIcon$1 = st$1(Icon$2)`
  background-image: url(${doneIcon});
`;
function DoneIcon() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DoneIcon$1, {});
}
function NavPopup({ chapterData }) {
  const { themeId, lessonId } = useParams();
  const [activeStep, setActiveStep] = reactExports.useState(Steps.chapter);
  const { setNavPopup } = useActions();
  const navigate = useNavigate();
  const [navListData, setNavListData] = reactExports.useState([]);
  reactExports.useEffect(() => {
    themeId ? setActiveStep(Steps.theme) : setActiveStep(Steps.chapter);
  }, [themeId]);
  const handleClose = reactExports.useCallback(() => {
    if (themeId && lessonId) {
      setNavPopup(false);
    } else {
      navigate(`/courses/${chapterData.course_id}`);
    }
  }, [chapterData.course_id, lessonId, navigate, setNavPopup, themeId]);
  reactExports.useEffect(() => {
    if (activeStep === Steps.chapter) {
      const data = chapterData.themes || [];
      setNavListData(data);
      return;
    }
    if (activeStep === Steps.theme && chapterData.themes) {
      const currentTheme = chapterData.themes.find((theme) => Number(theme.id) === Number(themeId));
      if (currentTheme) {
        const data = currentTheme.lessons || [];
        setNavListData(data);
        return;
      }
    }
  }, [activeStep, chapterData.themes, themeId]);
  const handleClick = (id2) => {
    let url = "";
    if (activeStep === Steps.theme) {
      url = `/courses/${chapterData.course_id}/${chapterData.id}/${themeId}/${id2}`;
    } else {
      url = `/courses/${chapterData.course_id}/${chapterData.id}/${id2}`;
    }
    navigate(url);
    if (activeStep === Steps.theme) {
      setNavPopup(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$j, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Head$1,
      {
        activeStep,
        onClose: handleClose
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(MainContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CourseNavHead, { data: chapterData }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FadedTitle,
        {
          text: activeStep === Steps.chapter ? "Темы главы" : "Уроки",
          styles: {
            marginBottom: "3.125vw",
            minHeight: "7.5vw"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(NavList$1, { children: navListData && navListData.length > 0 && navListData.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        NavListItem$1,
        {
          onClick: () => handleClick(item.id),
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              CourseNavItemTitle,
              {
                text: item.title,
                isDeleted: !!item.is_deleted
              }
            ),
            "isChecked" in item && /* @__PURE__ */ jsxRuntimeExports.jsx(DoneIcon, {})
          ]
        },
        item.id
      )) })
    ] })
  ] });
}
function Course() {
  const { setActiveChapterId, setLoaderActive, setNavPopup } = useActions();
  const { chapterId, lessonId } = useParams();
  const { data, isError, isFetching } = useGetChapterByIdQuery(Number(chapterId));
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  const isNavPopup = useTypedSelector((state) => state.lesson.navPopup);
  reactExports.useEffect(() => {
    lessonId ? setNavPopup(false) : setNavPopup(true);
  }, [lessonId, setNavPopup]);
  reactExports.useEffect(() => {
    setLoaderActive(isFetching);
  }, [isFetching, setLoaderActive]);
  reactExports.useEffect(() => {
    if (chapterId) {
      setActiveChapterId(chapterId);
    }
  }, [chapterId, setActiveChapterId]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$p, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(bodyOverflow$1, {}),
      !isMobile && data && /* @__PURE__ */ jsxRuntimeExports.jsxs(NavContainer, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CourseNavHead, { data: data.data }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CourseNavBody, { data: data.data })
      ] }),
      isMobile && data && isNavPopup && /* @__PURE__ */ jsxRuntimeExports.jsx(NavPopup, { chapterData: data.data }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContentContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CourseContent, {}) })
    ] })
  ] });
}
function Courses() {
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "/:courseId?",
        element: /* @__PURE__ */ jsxRuntimeExports.jsx(CoursePreview, {})
      }
    ),
    !isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
      Route,
      {
        path: "/:courseId/:chapterId/:themeId?/:lessonId?",
        element: /* @__PURE__ */ jsxRuntimeExports.jsx(Course, {})
      }
    )
  ] }) });
}
const competitionApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getAllCompetitions: builder.query({
      query: () => "competition",
      providesTags: () => [
        {
          type: "Competition"
        }
      ]
    }),
    getCompetitionById: builder.query({
      query: (id2) => `competition/${id2}`,
      providesTags: () => [
        {
          type: "CompetitionById"
        }
      ]
    }),
    createCompetition: builder.mutation({
      query: (data) => ({
        url: "competition/create",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["Competition"]
    }),
    updateCompetition: builder.mutation({
      query: (data) => ({
        url: "competition/update",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["Competition", "CompetitionById"]
    }),
    deleteCompetition: builder.mutation({
      query: (data) => ({
        url: "competition/delete",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["Competition", "CompetitionById"]
    }),
    restoreCompetition: builder.mutation({
      query: (data) => ({
        url: "competition/restore",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["Competition", "CompetitionById"]
    })
  }),
  overrideExisting: false
});
const {
  useCreateCompetitionMutation,
  useDeleteCompetitionMutation,
  useGetCompetitionByIdQuery,
  useGetAllCompetitionsQuery,
  useRestoreCompetitionMutation,
  useUpdateCompetitionMutation
} = competitionApi;
const arrowLeft = "/assets/swiperArrowLeft.svg";
const Container$i = st$1.div`
  position: relative;
  width: 49.7%;
  height: 400px;
  background-color: ${(props) => props.theme.colors.realWhite};
  border-radius: ${(props) => props.theme.utils.br};
  overflow: hidden;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
  }
`;
const SwiperPrevBtn = st$1.div`
  position: absolute;
  bottom: 40px;
  left: 20px;
  z-index: 2;
  width: 33px;
  height: 33px;
  background-image: url(${arrowLeft});
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;
  cursor: pointer;
`;
const SwiperNextBtn = st$1(SwiperPrevBtn)`
  right: 20px;
  left: unset;
  transform: rotate(-180deg);
`;
st$1(DefaultBtn)`
  z-index: 2;
  position: absolute;
  top:50%;
  left:50%;
  color:white;
  border-radius:15px;
  width: fit-content;
  padding:20px 30px;
  background-color:rgb(0, 122, 255);
  cursor: pointer;
  transform: translate(-50%, -50%);
`;
st$1(Text$6)`
  position: absolute;
  left: 50%;
  top: 50%;
  font-size: 22px;
  transform: translate(-50%, -50%);
  z-index: 2;
`;
function isObject$3(obj) {
  return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend$3(target, src) {
  if (target === void 0) {
    target = {};
  }
  if (src === void 0) {
    src = {};
  }
  Object.keys(src).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject$3(src[key]) && isObject$3(target[key]) && Object.keys(src[key]).length > 0) {
      extend$3(target[key], src[key]);
    }
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const doc = typeof document !== "undefined" ? document : {};
  extend$3(doc, ssrDocument);
  return doc;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function CustomEvent2() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(callback) {
    if (typeof setTimeout === "undefined") {
      callback();
      return null;
    }
    return setTimeout(callback, 0);
  },
  cancelAnimationFrame(id2) {
    if (typeof setTimeout === "undefined") {
      return;
    }
    clearTimeout(id2);
  }
};
function getWindow() {
  const win = typeof window !== "undefined" ? window : {};
  extend$3(win, ssrWindow);
  return win;
}
function deleteProps(obj) {
  const object = obj;
  Object.keys(object).forEach((key) => {
    try {
      object[key] = null;
    } catch (e2) {
    }
    try {
      delete object[key];
    } catch (e2) {
    }
  });
}
function nextTick(callback, delay) {
  if (delay === void 0) {
    delay = 0;
  }
  return setTimeout(callback, delay);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(el2) {
  const window2 = getWindow();
  let style2;
  if (window2.getComputedStyle) {
    style2 = window2.getComputedStyle(el2, null);
  }
  if (!style2 && el2.currentStyle) {
    style2 = el2.currentStyle;
  }
  if (!style2) {
    style2 = el2.style;
  }
  return style2;
}
function getTranslate(el2, axis) {
  if (axis === void 0) {
    axis = "x";
  }
  const window2 = getWindow();
  let matrix;
  let curTransform;
  let transformMatrix;
  const curStyle = getComputedStyle$1(el2);
  if (window2.WebKitCSSMatrix) {
    curTransform = curStyle.transform || curStyle.webkitTransform;
    if (curTransform.split(",").length > 6) {
      curTransform = curTransform.split(", ").map((a2) => a2.replace(",", ".")).join(", ");
    }
    transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
  } else {
    transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
    matrix = transformMatrix.toString().split(",");
  }
  if (axis === "x") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m41;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[12]);
    else
      curTransform = parseFloat(matrix[4]);
  }
  if (axis === "y") {
    if (window2.WebKitCSSMatrix)
      curTransform = transformMatrix.m42;
    else if (matrix.length === 16)
      curTransform = parseFloat(matrix[13]);
    else
      curTransform = parseFloat(matrix[5]);
  }
  return curTransform || 0;
}
function isObject$2(o2) {
  return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object";
}
function isNode(node2) {
  if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
    return node2 instanceof HTMLElement;
  }
  return node2 && (node2.nodeType === 1 || node2.nodeType === 11);
}
function extend$2() {
  const to2 = Object(arguments.length <= 0 ? void 0 : arguments[0]);
  const noExtend = ["__proto__", "constructor", "prototype"];
  for (let i2 = 1; i2 < arguments.length; i2 += 1) {
    const nextSource = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
    if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
      const keysArray = Object.keys(Object(nextSource)).filter((key) => noExtend.indexOf(key) < 0);
      for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
        const nextKey = keysArray[nextIndex];
        const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          if (isObject$2(to2[nextKey]) && isObject$2(nextSource[nextKey])) {
            if (nextSource[nextKey].__swiper__) {
              to2[nextKey] = nextSource[nextKey];
            } else {
              extend$2(to2[nextKey], nextSource[nextKey]);
            }
          } else if (!isObject$2(to2[nextKey]) && isObject$2(nextSource[nextKey])) {
            to2[nextKey] = {};
            if (nextSource[nextKey].__swiper__) {
              to2[nextKey] = nextSource[nextKey];
            } else {
              extend$2(to2[nextKey], nextSource[nextKey]);
            }
          } else {
            to2[nextKey] = nextSource[nextKey];
          }
        }
      }
    }
  }
  return to2;
}
function setCSSProperty(el2, varName, varValue) {
  el2.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
  let {
    swiper: swiper2,
    targetPosition,
    side
  } = _ref;
  const window2 = getWindow();
  const startPosition = -swiper2.translate;
  let startTime = null;
  let time;
  const duration2 = swiper2.params.speed;
  swiper2.wrapperEl.style.scrollSnapType = "none";
  window2.cancelAnimationFrame(swiper2.cssModeFrameID);
  const dir = targetPosition > startPosition ? "next" : "prev";
  const isOutOfBound = (current, target) => {
    return dir === "next" && current >= target || dir === "prev" && current <= target;
  };
  const animate = () => {
    time = (/* @__PURE__ */ new Date()).getTime();
    if (startTime === null) {
      startTime = time;
    }
    const progress = Math.max(Math.min((time - startTime) / duration2, 1), 0);
    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
    let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
    if (isOutOfBound(currentPosition, targetPosition)) {
      currentPosition = targetPosition;
    }
    swiper2.wrapperEl.scrollTo({
      [side]: currentPosition
    });
    if (isOutOfBound(currentPosition, targetPosition)) {
      swiper2.wrapperEl.style.overflow = "hidden";
      swiper2.wrapperEl.style.scrollSnapType = "";
      setTimeout(() => {
        swiper2.wrapperEl.style.overflow = "";
        swiper2.wrapperEl.scrollTo({
          [side]: currentPosition
        });
      });
      window2.cancelAnimationFrame(swiper2.cssModeFrameID);
      return;
    }
    swiper2.cssModeFrameID = window2.requestAnimationFrame(animate);
  };
  animate();
}
function elementChildren(element, selector) {
  if (selector === void 0) {
    selector = "";
  }
  return [...element.children].filter((el2) => el2.matches(selector));
}
function createElement(tag, classes2) {
  if (classes2 === void 0) {
    classes2 = [];
  }
  const el2 = document.createElement(tag);
  el2.classList.add(...Array.isArray(classes2) ? classes2 : [classes2]);
  return el2;
}
function elementPrevAll(el2, selector) {
  const prevEls = [];
  while (el2.previousElementSibling) {
    const prev2 = el2.previousElementSibling;
    if (selector) {
      if (prev2.matches(selector))
        prevEls.push(prev2);
    } else
      prevEls.push(prev2);
    el2 = prev2;
  }
  return prevEls;
}
function elementNextAll(el2, selector) {
  const nextEls = [];
  while (el2.nextElementSibling) {
    const next2 = el2.nextElementSibling;
    if (selector) {
      if (next2.matches(selector))
        nextEls.push(next2);
    } else
      nextEls.push(next2);
    el2 = next2;
  }
  return nextEls;
}
function elementStyle(el2, prop) {
  const window2 = getWindow();
  return window2.getComputedStyle(el2, null).getPropertyValue(prop);
}
function elementIndex(el2) {
  let child = el2;
  let i2;
  if (child) {
    i2 = 0;
    while ((child = child.previousSibling) !== null) {
      if (child.nodeType === 1)
        i2 += 1;
    }
    return i2;
  }
  return void 0;
}
function elementParents(el2, selector) {
  const parents = [];
  let parent = el2.parentElement;
  while (parent) {
    if (selector) {
      if (parent.matches(selector))
        parents.push(parent);
    } else {
      parents.push(parent);
    }
    parent = parent.parentElement;
  }
  return parents;
}
function elementOuterSize(el2, size, includeMargins) {
  const window2 = getWindow();
  if (includeMargins) {
    return el2[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el2, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el2, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
  }
  return el2.offsetWidth;
}
let support;
function calcSupport() {
  const window2 = getWindow();
  const document2 = getDocument();
  return {
    smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
    touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
  };
}
function getSupport() {
  if (!support) {
    support = calcSupport();
  }
  return support;
}
let deviceCached;
function calcDevice(_temp) {
  let {
    userAgent
  } = _temp === void 0 ? {} : _temp;
  const support2 = getSupport();
  const window2 = getWindow();
  const platform2 = window2.navigator.platform;
  const ua2 = userAgent || window2.navigator.userAgent;
  const device = {
    ios: false,
    android: false
  };
  const screenWidth = window2.screen.width;
  const screenHeight = window2.screen.height;
  const android = ua2.match(/(Android);?[\s\/]+([\d.]+)?/);
  let ipad = ua2.match(/(iPad).*OS\s([\d_]+)/);
  const ipod = ua2.match(/(iPod)(.*OS\s([\d_]+))?/);
  const iphone = !ipad && ua2.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
  const windows = platform2 === "Win32";
  let macos = platform2 === "MacIntel";
  const iPadScreens = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  if (!ipad && macos && support2.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
    ipad = ua2.match(/(Version)\/([\d.]+)/);
    if (!ipad)
      ipad = [0, 1, "13_0_0"];
    macos = false;
  }
  if (android && !windows) {
    device.os = "android";
    device.android = true;
  }
  if (ipad || iphone || ipod) {
    device.os = "ios";
    device.ios = true;
  }
  return device;
}
function getDevice(overrides) {
  if (overrides === void 0) {
    overrides = {};
  }
  if (!deviceCached) {
    deviceCached = calcDevice(overrides);
  }
  return deviceCached;
}
let browser;
function calcBrowser() {
  const window2 = getWindow();
  let needPerspectiveFix = false;
  function isSafari() {
    const ua2 = window2.navigator.userAgent.toLowerCase();
    return ua2.indexOf("safari") >= 0 && ua2.indexOf("chrome") < 0 && ua2.indexOf("android") < 0;
  }
  if (isSafari()) {
    const ua2 = String(window2.navigator.userAgent);
    if (ua2.includes("Version/")) {
      const [major, minor] = ua2.split("Version/")[1].split(" ")[0].split(".").map((num) => Number(num));
      needPerspectiveFix = major < 16 || major === 16 && minor < 2;
    }
  }
  return {
    isSafari: needPerspectiveFix || isSafari(),
    needPerspectiveFix,
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent)
  };
}
function getBrowser() {
  if (!browser) {
    browser = calcBrowser();
  }
  return browser;
}
function Resize(_ref) {
  let {
    swiper: swiper2,
    on: on2,
    emit
  } = _ref;
  const window2 = getWindow();
  let observer = null;
  let animationFrame = null;
  const resizeHandler = () => {
    if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
      return;
    emit("beforeResize");
    emit("resize");
  };
  const createObserver = () => {
    if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
      return;
    observer = new ResizeObserver((entries) => {
      animationFrame = window2.requestAnimationFrame(() => {
        const {
          width: width2,
          height: height2
        } = swiper2;
        let newWidth = width2;
        let newHeight = height2;
        entries.forEach((_ref2) => {
          let {
            contentBoxSize,
            contentRect,
            target
          } = _ref2;
          if (target && target !== swiper2.el)
            return;
          newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
          newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
        });
        if (newWidth !== width2 || newHeight !== height2) {
          resizeHandler();
        }
      });
    });
    observer.observe(swiper2.el);
  };
  const removeObserver = () => {
    if (animationFrame) {
      window2.cancelAnimationFrame(animationFrame);
    }
    if (observer && observer.unobserve && swiper2.el) {
      observer.unobserve(swiper2.el);
      observer = null;
    }
  };
  const orientationChangeHandler = () => {
    if (!swiper2 || swiper2.destroyed || !swiper2.initialized)
      return;
    emit("orientationchange");
  };
  on2("init", () => {
    if (swiper2.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
      createObserver();
      return;
    }
    window2.addEventListener("resize", resizeHandler);
    window2.addEventListener("orientationchange", orientationChangeHandler);
  });
  on2("destroy", () => {
    removeObserver();
    window2.removeEventListener("resize", resizeHandler);
    window2.removeEventListener("orientationchange", orientationChangeHandler);
  });
}
function Observer(_ref) {
  let {
    swiper: swiper2,
    extendParams,
    on: on2,
    emit
  } = _ref;
  const observers = [];
  const window2 = getWindow();
  const attach = function(target, options) {
    if (options === void 0) {
      options = {};
    }
    const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
    const observer = new ObserverFunc((mutations) => {
      if (swiper2.__preventObserver__)
        return;
      if (mutations.length === 1) {
        emit("observerUpdate", mutations[0]);
        return;
      }
      const observerUpdate = function observerUpdate2() {
        emit("observerUpdate", mutations[0]);
      };
      if (window2.requestAnimationFrame) {
        window2.requestAnimationFrame(observerUpdate);
      } else {
        window2.setTimeout(observerUpdate, 0);
      }
    });
    observer.observe(target, {
      attributes: typeof options.attributes === "undefined" ? true : options.attributes,
      childList: typeof options.childList === "undefined" ? true : options.childList,
      characterData: typeof options.characterData === "undefined" ? true : options.characterData
    });
    observers.push(observer);
  };
  const init2 = () => {
    if (!swiper2.params.observer)
      return;
    if (swiper2.params.observeParents) {
      const containerParents = elementParents(swiper2.hostEl);
      for (let i2 = 0; i2 < containerParents.length; i2 += 1) {
        attach(containerParents[i2]);
      }
    }
    attach(swiper2.hostEl, {
      childList: swiper2.params.observeSlideChildren
    });
    attach(swiper2.wrapperEl, {
      attributes: false
    });
  };
  const destroy = () => {
    observers.forEach((observer) => {
      observer.disconnect();
    });
    observers.splice(0, observers.length);
  };
  extendParams({
    observer: false,
    observeParents: false,
    observeSlideChildren: false
  });
  on2("init", init2);
  on2("destroy", destroy);
}
var eventsEmitter = {
  on(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    events2.split(" ").forEach((event) => {
      if (!self2.eventsListeners[event])
        self2.eventsListeners[event] = [];
      self2.eventsListeners[event][method](handler);
    });
    return self2;
  },
  once(events2, handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    function onceHandler() {
      self2.off(events2, onceHandler);
      if (onceHandler.__emitterProxy) {
        delete onceHandler.__emitterProxy;
      }
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      handler.apply(self2, args);
    }
    onceHandler.__emitterProxy = handler;
    return self2.on(events2, onceHandler, priority);
  },
  onAny(handler, priority) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (typeof handler !== "function")
      return self2;
    const method = priority ? "unshift" : "push";
    if (self2.eventsAnyListeners.indexOf(handler) < 0) {
      self2.eventsAnyListeners[method](handler);
    }
    return self2;
  },
  offAny(handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsAnyListeners)
      return self2;
    const index = self2.eventsAnyListeners.indexOf(handler);
    if (index >= 0) {
      self2.eventsAnyListeners.splice(index, 1);
    }
    return self2;
  },
  off(events2, handler) {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsListeners)
      return self2;
    events2.split(" ").forEach((event) => {
      if (typeof handler === "undefined") {
        self2.eventsListeners[event] = [];
      } else if (self2.eventsListeners[event]) {
        self2.eventsListeners[event].forEach((eventHandler, index) => {
          if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
            self2.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self2;
  },
  emit() {
    const self2 = this;
    if (!self2.eventsListeners || self2.destroyed)
      return self2;
    if (!self2.eventsListeners)
      return self2;
    let events2;
    let data;
    let context;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (typeof args[0] === "string" || Array.isArray(args[0])) {
      events2 = args[0];
      data = args.slice(1, args.length);
      context = self2;
    } else {
      events2 = args[0].events;
      data = args[0].data;
      context = args[0].context || self2;
    }
    data.unshift(context);
    const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
    eventsArray.forEach((event) => {
      if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
        self2.eventsAnyListeners.forEach((eventHandler) => {
          eventHandler.apply(context, [event, ...data]);
        });
      }
      if (self2.eventsListeners && self2.eventsListeners[event]) {
        self2.eventsListeners[event].forEach((eventHandler) => {
          eventHandler.apply(context, data);
        });
      }
    });
    return self2;
  }
};
function updateSize() {
  const swiper2 = this;
  let width2;
  let height2;
  const el2 = swiper2.el;
  if (typeof swiper2.params.width !== "undefined" && swiper2.params.width !== null) {
    width2 = swiper2.params.width;
  } else {
    width2 = el2.clientWidth;
  }
  if (typeof swiper2.params.height !== "undefined" && swiper2.params.height !== null) {
    height2 = swiper2.params.height;
  } else {
    height2 = el2.clientHeight;
  }
  if (width2 === 0 && swiper2.isHorizontal() || height2 === 0 && swiper2.isVertical()) {
    return;
  }
  width2 = width2 - parseInt(elementStyle(el2, "padding-left") || 0, 10) - parseInt(elementStyle(el2, "padding-right") || 0, 10);
  height2 = height2 - parseInt(elementStyle(el2, "padding-top") || 0, 10) - parseInt(elementStyle(el2, "padding-bottom") || 0, 10);
  if (Number.isNaN(width2))
    width2 = 0;
  if (Number.isNaN(height2))
    height2 = 0;
  Object.assign(swiper2, {
    width: width2,
    height: height2,
    size: swiper2.isHorizontal() ? width2 : height2
  });
}
function updateSlides() {
  const swiper2 = this;
  function getDirectionLabel(property) {
    if (swiper2.isHorizontal()) {
      return property;
    }
    return {
      "width": "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      "marginRight": "marginBottom"
    }[property];
  }
  function getDirectionPropertyValue(node2, label) {
    return parseFloat(node2.getPropertyValue(getDirectionLabel(label)) || 0);
  }
  const params = swiper2.params;
  const {
    wrapperEl,
    slidesEl,
    size: swiperSize,
    rtlTranslate: rtl,
    wrongRTL
  } = swiper2;
  const isVirtual = swiper2.virtual && params.virtual.enabled;
  const previousSlidesLength = isVirtual ? swiper2.virtual.slides.length : swiper2.slides.length;
  const slides = elementChildren(slidesEl, `.${swiper2.params.slideClass}, swiper-slide`);
  const slidesLength = isVirtual ? swiper2.virtual.slides.length : slides.length;
  let snapGrid = [];
  const slidesGrid = [];
  const slidesSizesGrid = [];
  let offsetBefore = params.slidesOffsetBefore;
  if (typeof offsetBefore === "function") {
    offsetBefore = params.slidesOffsetBefore.call(swiper2);
  }
  let offsetAfter = params.slidesOffsetAfter;
  if (typeof offsetAfter === "function") {
    offsetAfter = params.slidesOffsetAfter.call(swiper2);
  }
  const previousSnapGridLength = swiper2.snapGrid.length;
  const previousSlidesGridLength = swiper2.slidesGrid.length;
  let spaceBetween = params.spaceBetween;
  let slidePosition = -offsetBefore;
  let prevSlideSize = 0;
  let index = 0;
  if (typeof swiperSize === "undefined") {
    return;
  }
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  swiper2.virtualSize = -spaceBetween;
  slides.forEach((slideEl) => {
    if (rtl) {
      slideEl.style.marginLeft = "";
    } else {
      slideEl.style.marginRight = "";
    }
    slideEl.style.marginBottom = "";
    slideEl.style.marginTop = "";
  });
  if (params.centeredSlides && params.cssMode) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
  }
  const gridEnabled = params.grid && params.grid.rows > 1 && swiper2.grid;
  if (gridEnabled) {
    swiper2.grid.initSlides(slidesLength);
  }
  let slideSize;
  const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key) => {
    return typeof params.breakpoints[key].slidesPerView !== "undefined";
  }).length > 0;
  for (let i2 = 0; i2 < slidesLength; i2 += 1) {
    slideSize = 0;
    let slide2;
    if (slides[i2])
      slide2 = slides[i2];
    if (gridEnabled) {
      swiper2.grid.updateSlide(i2, slide2, slidesLength, getDirectionLabel);
    }
    if (slides[i2] && elementStyle(slide2, "display") === "none")
      continue;
    if (params.slidesPerView === "auto") {
      if (shouldResetSlideSize) {
        slides[i2].style[getDirectionLabel("width")] = ``;
      }
      const slideStyles = getComputedStyle(slide2);
      const currentTransform = slide2.style.transform;
      const currentWebKitTransform = slide2.style.webkitTransform;
      if (currentTransform) {
        slide2.style.transform = "none";
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = "none";
      }
      if (params.roundLengths) {
        slideSize = swiper2.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
      } else {
        const width2 = getDirectionPropertyValue(slideStyles, "width");
        const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
        const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
        const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
        const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
        const boxSizing2 = slideStyles.getPropertyValue("box-sizing");
        if (boxSizing2 && boxSizing2 === "border-box") {
          slideSize = width2 + marginLeft + marginRight;
        } else {
          const {
            clientWidth,
            offsetWidth
          } = slide2;
          slideSize = width2 + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
        }
      }
      if (currentTransform) {
        slide2.style.transform = currentTransform;
      }
      if (currentWebKitTransform) {
        slide2.style.webkitTransform = currentWebKitTransform;
      }
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
    } else {
      slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
      if (params.roundLengths)
        slideSize = Math.floor(slideSize);
      if (slides[i2]) {
        slides[i2].style[getDirectionLabel("width")] = `${slideSize}px`;
      }
    }
    if (slides[i2]) {
      slides[i2].swiperSlideSize = slideSize;
    }
    slidesSizesGrid.push(slideSize);
    if (params.centeredSlides) {
      slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
      if (prevSlideSize === 0 && i2 !== 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (i2 === 0)
        slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
      if (Math.abs(slidePosition) < 1 / 1e3)
        slidePosition = 0;
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if (index % params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
    } else {
      if (params.roundLengths)
        slidePosition = Math.floor(slidePosition);
      if ((index - Math.min(swiper2.params.slidesPerGroupSkip, index)) % swiper2.params.slidesPerGroup === 0)
        snapGrid.push(slidePosition);
      slidesGrid.push(slidePosition);
      slidePosition = slidePosition + slideSize + spaceBetween;
    }
    swiper2.virtualSize += slideSize + spaceBetween;
    prevSlideSize = slideSize;
    index += 1;
  }
  swiper2.virtualSize = Math.max(swiper2.virtualSize, swiperSize) + offsetAfter;
  if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
    wrapperEl.style.width = `${swiper2.virtualSize + spaceBetween}px`;
  }
  if (params.setWrapperSize) {
    wrapperEl.style[getDirectionLabel("width")] = `${swiper2.virtualSize + spaceBetween}px`;
  }
  if (gridEnabled) {
    swiper2.grid.updateWrapperSize(slideSize, snapGrid, getDirectionLabel);
  }
  if (!params.centeredSlides) {
    const newSlidesGrid = [];
    for (let i2 = 0; i2 < snapGrid.length; i2 += 1) {
      let slidesGridItem = snapGrid[i2];
      if (params.roundLengths)
        slidesGridItem = Math.floor(slidesGridItem);
      if (snapGrid[i2] <= swiper2.virtualSize - swiperSize) {
        newSlidesGrid.push(slidesGridItem);
      }
    }
    snapGrid = newSlidesGrid;
    if (Math.floor(swiper2.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
      snapGrid.push(swiper2.virtualSize - swiperSize);
    }
  }
  if (isVirtual && params.loop) {
    const size = slidesSizesGrid[0] + spaceBetween;
    if (params.slidesPerGroup > 1) {
      const groups = Math.ceil((swiper2.virtual.slidesBefore + swiper2.virtual.slidesAfter) / params.slidesPerGroup);
      const groupSize = size * params.slidesPerGroup;
      for (let i2 = 0; i2 < groups; i2 += 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
      }
    }
    for (let i2 = 0; i2 < swiper2.virtual.slidesBefore + swiper2.virtual.slidesAfter; i2 += 1) {
      if (params.slidesPerGroup === 1) {
        snapGrid.push(snapGrid[snapGrid.length - 1] + size);
      }
      slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
      swiper2.virtualSize += size;
    }
  }
  if (snapGrid.length === 0)
    snapGrid = [0];
  if (spaceBetween !== 0) {
    const key = swiper2.isHorizontal() && rtl ? "marginLeft" : getDirectionLabel("marginRight");
    slides.filter((_2, slideIndex) => {
      if (!params.cssMode || params.loop)
        return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }).forEach((slideEl) => {
      slideEl.style[key] = `${spaceBetween}px`;
    });
  }
  if (params.centeredSlides && params.centeredSlidesBounds) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    const maxSnap = allSlidesSize - swiperSize;
    snapGrid = snapGrid.map((snap) => {
      if (snap <= 0)
        return -offsetBefore;
      if (snap > maxSnap)
        return maxSnap + offsetAfter;
      return snap;
    });
  }
  if (params.centerInsufficientSlides) {
    let allSlidesSize = 0;
    slidesSizesGrid.forEach((slideSizeValue) => {
      allSlidesSize += slideSizeValue + (spaceBetween || 0);
    });
    allSlidesSize -= spaceBetween;
    if (allSlidesSize < swiperSize) {
      const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
      snapGrid.forEach((snap, snapIndex) => {
        snapGrid[snapIndex] = snap - allSlidesOffset;
      });
      slidesGrid.forEach((snap, snapIndex) => {
        slidesGrid[snapIndex] = snap + allSlidesOffset;
      });
    }
  }
  Object.assign(swiper2, {
    slides,
    snapGrid,
    slidesGrid,
    slidesSizesGrid
  });
  if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper2.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
    const addToSnapGrid = -swiper2.snapGrid[0];
    const addToSlidesGrid = -swiper2.slidesGrid[0];
    swiper2.snapGrid = swiper2.snapGrid.map((v2) => v2 + addToSnapGrid);
    swiper2.slidesGrid = swiper2.slidesGrid.map((v2) => v2 + addToSlidesGrid);
  }
  if (slidesLength !== previousSlidesLength) {
    swiper2.emit("slidesLengthChange");
  }
  if (snapGrid.length !== previousSnapGridLength) {
    if (swiper2.params.watchOverflow)
      swiper2.checkOverflow();
    swiper2.emit("snapGridLengthChange");
  }
  if (slidesGrid.length !== previousSlidesGridLength) {
    swiper2.emit("slidesGridLengthChange");
  }
  if (params.watchSlidesProgress) {
    swiper2.updateSlidesOffset();
  }
  if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
    const hasClassBackfaceClassAdded = swiper2.el.classList.contains(backFaceHiddenClass);
    if (slidesLength <= params.maxBackfaceHiddenSlides) {
      if (!hasClassBackfaceClassAdded)
        swiper2.el.classList.add(backFaceHiddenClass);
    } else if (hasClassBackfaceClassAdded) {
      swiper2.el.classList.remove(backFaceHiddenClass);
    }
  }
}
function updateAutoHeight(speed) {
  const swiper2 = this;
  const activeSlides = [];
  const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
  let newHeight = 0;
  let i2;
  if (typeof speed === "number") {
    swiper2.setTransition(speed);
  } else if (speed === true) {
    swiper2.setTransition(swiper2.params.speed);
  }
  const getSlideByIndex = (index) => {
    if (isVirtual) {
      return swiper2.slides[swiper2.getSlideIndexByData(index)];
    }
    return swiper2.slides[index];
  };
  if (swiper2.params.slidesPerView !== "auto" && swiper2.params.slidesPerView > 1) {
    if (swiper2.params.centeredSlides) {
      (swiper2.visibleSlides || []).forEach((slide2) => {
        activeSlides.push(slide2);
      });
    } else {
      for (i2 = 0; i2 < Math.ceil(swiper2.params.slidesPerView); i2 += 1) {
        const index = swiper2.activeIndex + i2;
        if (index > swiper2.slides.length && !isVirtual)
          break;
        activeSlides.push(getSlideByIndex(index));
      }
    }
  } else {
    activeSlides.push(getSlideByIndex(swiper2.activeIndex));
  }
  for (i2 = 0; i2 < activeSlides.length; i2 += 1) {
    if (typeof activeSlides[i2] !== "undefined") {
      const height2 = activeSlides[i2].offsetHeight;
      newHeight = height2 > newHeight ? height2 : newHeight;
    }
  }
  if (newHeight || newHeight === 0)
    swiper2.wrapperEl.style.height = `${newHeight}px`;
}
function updateSlidesOffset() {
  const swiper2 = this;
  const slides = swiper2.slides;
  const minusOffset = swiper2.isElement ? swiper2.isHorizontal() ? swiper2.wrapperEl.offsetLeft : swiper2.wrapperEl.offsetTop : 0;
  for (let i2 = 0; i2 < slides.length; i2 += 1) {
    slides[i2].swiperSlideOffset = (swiper2.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop) - minusOffset - swiper2.cssOverflowAdjustment();
  }
}
function updateSlidesProgress(translate2) {
  if (translate2 === void 0) {
    translate2 = this && this.translate || 0;
  }
  const swiper2 = this;
  const params = swiper2.params;
  const {
    slides,
    rtlTranslate: rtl,
    snapGrid
  } = swiper2;
  if (slides.length === 0)
    return;
  if (typeof slides[0].swiperSlideOffset === "undefined")
    swiper2.updateSlidesOffset();
  let offsetCenter = -translate2;
  if (rtl)
    offsetCenter = translate2;
  slides.forEach((slideEl) => {
    slideEl.classList.remove(params.slideVisibleClass);
  });
  swiper2.visibleSlidesIndexes = [];
  swiper2.visibleSlides = [];
  let spaceBetween = params.spaceBetween;
  if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
    spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper2.size;
  } else if (typeof spaceBetween === "string") {
    spaceBetween = parseFloat(spaceBetween);
  }
  for (let i2 = 0; i2 < slides.length; i2 += 1) {
    const slide2 = slides[i2];
    let slideOffset = slide2.swiperSlideOffset;
    if (params.cssMode && params.centeredSlides) {
      slideOffset -= slides[0].swiperSlideOffset;
    }
    const slideProgress = (offsetCenter + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper2.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
    const slideBefore = -(offsetCenter - slideOffset);
    const slideAfter = slideBefore + swiper2.slidesSizesGrid[i2];
    const isVisible = slideBefore >= 0 && slideBefore < swiper2.size - 1 || slideAfter > 1 && slideAfter <= swiper2.size || slideBefore <= 0 && slideAfter >= swiper2.size;
    if (isVisible) {
      swiper2.visibleSlides.push(slide2);
      swiper2.visibleSlidesIndexes.push(i2);
      slides[i2].classList.add(params.slideVisibleClass);
    }
    slide2.progress = rtl ? -slideProgress : slideProgress;
    slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
  }
}
function updateProgress(translate2) {
  const swiper2 = this;
  if (typeof translate2 === "undefined") {
    const multiplier = swiper2.rtlTranslate ? -1 : 1;
    translate2 = swiper2 && swiper2.translate && swiper2.translate * multiplier || 0;
  }
  const params = swiper2.params;
  const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
  let {
    progress,
    isBeginning,
    isEnd,
    progressLoop
  } = swiper2;
  const wasBeginning = isBeginning;
  const wasEnd = isEnd;
  if (translatesDiff === 0) {
    progress = 0;
    isBeginning = true;
    isEnd = true;
  } else {
    progress = (translate2 - swiper2.minTranslate()) / translatesDiff;
    const isBeginningRounded = Math.abs(translate2 - swiper2.minTranslate()) < 1;
    const isEndRounded = Math.abs(translate2 - swiper2.maxTranslate()) < 1;
    isBeginning = isBeginningRounded || progress <= 0;
    isEnd = isEndRounded || progress >= 1;
    if (isBeginningRounded)
      progress = 0;
    if (isEndRounded)
      progress = 1;
  }
  if (params.loop) {
    const firstSlideIndex = swiper2.getSlideIndexByData(0);
    const lastSlideIndex = swiper2.getSlideIndexByData(swiper2.slides.length - 1);
    const firstSlideTranslate = swiper2.slidesGrid[firstSlideIndex];
    const lastSlideTranslate = swiper2.slidesGrid[lastSlideIndex];
    const translateMax = swiper2.slidesGrid[swiper2.slidesGrid.length - 1];
    const translateAbs = Math.abs(translate2);
    if (translateAbs >= firstSlideTranslate) {
      progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
    } else {
      progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
    }
    if (progressLoop > 1)
      progressLoop -= 1;
  }
  Object.assign(swiper2, {
    progress,
    progressLoop,
    isBeginning,
    isEnd
  });
  if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight)
    swiper2.updateSlidesProgress(translate2);
  if (isBeginning && !wasBeginning) {
    swiper2.emit("reachBeginning toEdge");
  }
  if (isEnd && !wasEnd) {
    swiper2.emit("reachEnd toEdge");
  }
  if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
    swiper2.emit("fromEdge");
  }
  swiper2.emit("progress", progress);
}
function updateSlidesClasses() {
  const swiper2 = this;
  const {
    slides,
    params,
    slidesEl,
    activeIndex
  } = swiper2;
  const isVirtual = swiper2.virtual && params.virtual.enabled;
  const getFilteredSlide = (selector) => {
    return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
  };
  slides.forEach((slideEl) => {
    slideEl.classList.remove(params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
  });
  let activeSlide;
  if (isVirtual) {
    if (params.loop) {
      let slideIndex = activeIndex - swiper2.virtual.slidesBefore;
      if (slideIndex < 0)
        slideIndex = swiper2.virtual.slides.length + slideIndex;
      if (slideIndex >= swiper2.virtual.slides.length)
        slideIndex -= swiper2.virtual.slides.length;
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
    } else {
      activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
    }
  } else {
    activeSlide = slides[activeIndex];
  }
  if (activeSlide) {
    activeSlide.classList.add(params.slideActiveClass);
    let nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
    if (params.loop && !nextSlide) {
      nextSlide = slides[0];
    }
    if (nextSlide) {
      nextSlide.classList.add(params.slideNextClass);
    }
    let prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
    if (params.loop && !prevSlide === 0) {
      prevSlide = slides[slides.length - 1];
    }
    if (prevSlide) {
      prevSlide.classList.add(params.slidePrevClass);
    }
  }
  swiper2.emitSlidesClasses();
}
const processLazyPreloader = (swiper2, imageEl) => {
  if (!swiper2 || swiper2.destroyed || !swiper2.params)
    return;
  const slideSelector = () => swiper2.isElement ? `swiper-slide` : `.${swiper2.params.slideClass}`;
  const slideEl = imageEl.closest(slideSelector());
  if (slideEl) {
    let lazyEl = slideEl.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
    if (!lazyEl && swiper2.isElement) {
      if (slideEl.shadowRoot) {
        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
      } else {
        requestAnimationFrame(() => {
          if (slideEl.shadowRoot) {
            lazyEl = slideEl.shadowRoot.querySelector(`.${swiper2.params.lazyPreloaderClass}`);
            if (lazyEl)
              lazyEl.remove();
          }
        });
      }
    }
    if (lazyEl)
      lazyEl.remove();
  }
};
const unlazy = (swiper2, index) => {
  if (!swiper2.slides[index])
    return;
  const imageEl = swiper2.slides[index].querySelector('[loading="lazy"]');
  if (imageEl)
    imageEl.removeAttribute("loading");
};
const preload = (swiper2) => {
  if (!swiper2 || swiper2.destroyed || !swiper2.params)
    return;
  let amount = swiper2.params.lazyPreloadPrevNext;
  const len = swiper2.slides.length;
  if (!len || !amount || amount < 0)
    return;
  amount = Math.min(amount, len);
  const slidesPerView = swiper2.params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(swiper2.params.slidesPerView);
  const activeIndex = swiper2.activeIndex;
  if (swiper2.params.grid && swiper2.params.grid.rows > 1) {
    const activeColumn = activeIndex;
    const preloadColumns = [activeColumn - amount];
    preloadColumns.push(...Array.from({
      length: amount
    }).map((_2, i2) => {
      return activeColumn + slidesPerView + i2;
    }));
    swiper2.slides.forEach((slideEl, i2) => {
      if (preloadColumns.includes(slideEl.column))
        unlazy(swiper2, i2);
    });
    return;
  }
  const slideIndexLastInView = activeIndex + slidesPerView - 1;
  if (swiper2.params.rewind || swiper2.params.loop) {
    for (let i2 = activeIndex - amount; i2 <= slideIndexLastInView + amount; i2 += 1) {
      const realIndex = (i2 % len + len) % len;
      if (realIndex < activeIndex || realIndex > slideIndexLastInView)
        unlazy(swiper2, realIndex);
    }
  } else {
    for (let i2 = Math.max(activeIndex - amount, 0); i2 <= Math.min(slideIndexLastInView + amount, len - 1); i2 += 1) {
      if (i2 !== activeIndex && (i2 > slideIndexLastInView || i2 < activeIndex)) {
        unlazy(swiper2, i2);
      }
    }
  }
};
function getActiveIndexByTranslate(swiper2) {
  const {
    slidesGrid,
    params
  } = swiper2;
  const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
  let activeIndex;
  for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
    if (typeof slidesGrid[i2 + 1] !== "undefined") {
      if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) {
        activeIndex = i2;
      } else if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1]) {
        activeIndex = i2 + 1;
      }
    } else if (translate2 >= slidesGrid[i2]) {
      activeIndex = i2;
    }
  }
  if (params.normalizeSlideIndex) {
    if (activeIndex < 0 || typeof activeIndex === "undefined")
      activeIndex = 0;
  }
  return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
  const swiper2 = this;
  const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
  const {
    snapGrid,
    params,
    activeIndex: previousIndex,
    realIndex: previousRealIndex,
    snapIndex: previousSnapIndex
  } = swiper2;
  let activeIndex = newActiveIndex;
  let snapIndex;
  const getVirtualRealIndex = (aIndex) => {
    let realIndex2 = aIndex - swiper2.virtual.slidesBefore;
    if (realIndex2 < 0) {
      realIndex2 = swiper2.virtual.slides.length + realIndex2;
    }
    if (realIndex2 >= swiper2.virtual.slides.length) {
      realIndex2 -= swiper2.virtual.slides.length;
    }
    return realIndex2;
  };
  if (typeof activeIndex === "undefined") {
    activeIndex = getActiveIndexByTranslate(swiper2);
  }
  if (snapGrid.indexOf(translate2) >= 0) {
    snapIndex = snapGrid.indexOf(translate2);
  } else {
    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
    snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
  }
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  if (activeIndex === previousIndex) {
    if (snapIndex !== previousSnapIndex) {
      swiper2.snapIndex = snapIndex;
      swiper2.emit("snapIndexChange");
    }
    if (swiper2.params.loop && swiper2.virtual && swiper2.params.virtual.enabled) {
      swiper2.realIndex = getVirtualRealIndex(activeIndex);
    }
    return;
  }
  let realIndex;
  if (swiper2.virtual && params.virtual.enabled && params.loop) {
    realIndex = getVirtualRealIndex(activeIndex);
  } else if (swiper2.slides[activeIndex]) {
    realIndex = parseInt(swiper2.slides[activeIndex].getAttribute("data-swiper-slide-index") || activeIndex, 10);
  } else {
    realIndex = activeIndex;
  }
  Object.assign(swiper2, {
    previousSnapIndex,
    snapIndex,
    previousRealIndex,
    realIndex,
    previousIndex,
    activeIndex
  });
  if (swiper2.initialized) {
    preload(swiper2);
  }
  swiper2.emit("activeIndexChange");
  swiper2.emit("snapIndexChange");
  if (swiper2.initialized || swiper2.params.runCallbacksOnInit) {
    if (previousRealIndex !== realIndex) {
      swiper2.emit("realIndexChange");
    }
    swiper2.emit("slideChange");
  }
}
function updateClickedSlide(el2, path) {
  const swiper2 = this;
  const params = swiper2.params;
  let slide2 = el2.closest(`.${params.slideClass}, swiper-slide`);
  if (!slide2 && swiper2.isElement && path && path.length > 1 && path.includes(el2)) {
    [...path.slice(path.indexOf(el2) + 1, path.length)].forEach((pathEl) => {
      if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
        slide2 = pathEl;
      }
    });
  }
  let slideFound = false;
  let slideIndex;
  if (slide2) {
    for (let i2 = 0; i2 < swiper2.slides.length; i2 += 1) {
      if (swiper2.slides[i2] === slide2) {
        slideFound = true;
        slideIndex = i2;
        break;
      }
    }
  }
  if (slide2 && slideFound) {
    swiper2.clickedSlide = slide2;
    if (swiper2.virtual && swiper2.params.virtual.enabled) {
      swiper2.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
    } else {
      swiper2.clickedIndex = slideIndex;
    }
  } else {
    swiper2.clickedSlide = void 0;
    swiper2.clickedIndex = void 0;
    return;
  }
  if (params.slideToClickedSlide && swiper2.clickedIndex !== void 0 && swiper2.clickedIndex !== swiper2.activeIndex) {
    swiper2.slideToClickedSlide();
  }
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(axis) {
  if (axis === void 0) {
    axis = this.isHorizontal() ? "x" : "y";
  }
  const swiper2 = this;
  const {
    params,
    rtlTranslate: rtl,
    translate: translate2,
    wrapperEl
  } = swiper2;
  if (params.virtualTranslate) {
    return rtl ? -translate2 : translate2;
  }
  if (params.cssMode) {
    return translate2;
  }
  let currentTranslate = getTranslate(wrapperEl, axis);
  currentTranslate += swiper2.cssOverflowAdjustment();
  if (rtl)
    currentTranslate = -currentTranslate;
  return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
  const swiper2 = this;
  const {
    rtlTranslate: rtl,
    params,
    wrapperEl,
    progress
  } = swiper2;
  let x2 = 0;
  let y2 = 0;
  const z2 = 0;
  if (swiper2.isHorizontal()) {
    x2 = rtl ? -translate2 : translate2;
  } else {
    y2 = translate2;
  }
  if (params.roundLengths) {
    x2 = Math.floor(x2);
    y2 = Math.floor(y2);
  }
  swiper2.previousTranslate = swiper2.translate;
  swiper2.translate = swiper2.isHorizontal() ? x2 : y2;
  if (params.cssMode) {
    wrapperEl[swiper2.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper2.isHorizontal() ? -x2 : -y2;
  } else if (!params.virtualTranslate) {
    if (swiper2.isHorizontal()) {
      x2 -= swiper2.cssOverflowAdjustment();
    } else {
      y2 -= swiper2.cssOverflowAdjustment();
    }
    wrapperEl.style.transform = `translate3d(${x2}px, ${y2}px, ${z2}px)`;
  }
  let newProgress;
  const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (translate2 - swiper2.minTranslate()) / translatesDiff;
  }
  if (newProgress !== progress) {
    swiper2.updateProgress(translate2);
  }
  swiper2.emit("setTranslate", swiper2.translate, byController);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
  if (translate2 === void 0) {
    translate2 = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (translateBounds === void 0) {
    translateBounds = true;
  }
  const swiper2 = this;
  const {
    params,
    wrapperEl
  } = swiper2;
  if (swiper2.animating && params.preventInteractionOnTransition) {
    return false;
  }
  const minTranslate2 = swiper2.minTranslate();
  const maxTranslate2 = swiper2.maxTranslate();
  let newTranslate;
  if (translateBounds && translate2 > minTranslate2)
    newTranslate = minTranslate2;
  else if (translateBounds && translate2 < maxTranslate2)
    newTranslate = maxTranslate2;
  else
    newTranslate = translate2;
  swiper2.updateProgress(newTranslate);
  if (params.cssMode) {
    const isH = swiper2.isHorizontal();
    if (speed === 0) {
      wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
    } else {
      if (!swiper2.support.smoothScroll) {
        animateCSSModeScroll({
          swiper: swiper2,
          targetPosition: -newTranslate,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: -newTranslate,
        behavior: "smooth"
      });
    }
    return true;
  }
  if (speed === 0) {
    swiper2.setTransition(0);
    swiper2.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper2.emit("beforeTransitionStart", speed, internal);
      swiper2.emit("transitionEnd");
    }
  } else {
    swiper2.setTransition(speed);
    swiper2.setTranslate(newTranslate);
    if (runCallbacks) {
      swiper2.emit("beforeTransitionStart", speed, internal);
      swiper2.emit("transitionStart");
    }
    if (!swiper2.animating) {
      swiper2.animating = true;
      if (!swiper2.onTranslateToWrapperTransitionEnd) {
        swiper2.onTranslateToWrapperTransitionEnd = function transitionEnd2(e2) {
          if (!swiper2 || swiper2.destroyed)
            return;
          if (e2.target !== this)
            return;
          swiper2.wrapperEl.removeEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
          swiper2.onTranslateToWrapperTransitionEnd = null;
          delete swiper2.onTranslateToWrapperTransitionEnd;
          if (runCallbacks) {
            swiper2.emit("transitionEnd");
          }
        };
      }
      swiper2.wrapperEl.addEventListener("transitionend", swiper2.onTranslateToWrapperTransitionEnd);
    }
  }
  return true;
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(duration2, byController) {
  const swiper2 = this;
  if (!swiper2.params.cssMode) {
    swiper2.wrapperEl.style.transitionDuration = `${duration2}ms`;
    swiper2.wrapperEl.style.transitionDelay = duration2 === 0 ? `0ms` : "";
  }
  swiper2.emit("setTransition", duration2, byController);
}
function transitionEmit(_ref) {
  let {
    swiper: swiper2,
    runCallbacks,
    direction,
    step
  } = _ref;
  const {
    activeIndex,
    previousIndex
  } = swiper2;
  let dir = direction;
  if (!dir) {
    if (activeIndex > previousIndex)
      dir = "next";
    else if (activeIndex < previousIndex)
      dir = "prev";
    else
      dir = "reset";
  }
  swiper2.emit(`transition${step}`);
  if (runCallbacks && activeIndex !== previousIndex) {
    if (dir === "reset") {
      swiper2.emit(`slideResetTransition${step}`);
      return;
    }
    swiper2.emit(`slideChangeTransition${step}`);
    if (dir === "next") {
      swiper2.emit(`slideNextTransition${step}`);
    } else {
      swiper2.emit(`slidePrevTransition${step}`);
    }
  }
}
function transitionStart(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  const {
    params
  } = swiper2;
  if (params.cssMode)
    return;
  if (params.autoHeight) {
    swiper2.updateAutoHeight();
  }
  transitionEmit({
    swiper: swiper2,
    runCallbacks,
    direction,
    step: "Start"
  });
}
function transitionEnd(runCallbacks, direction) {
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  const {
    params
  } = swiper2;
  swiper2.animating = false;
  if (params.cssMode)
    return;
  swiper2.setTransition(0);
  transitionEmit({
    swiper: swiper2,
    runCallbacks,
    direction,
    step: "End"
  });
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(index, speed, runCallbacks, internal, initial) {
  if (index === void 0) {
    index = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === "string") {
    index = parseInt(index, 10);
  }
  const swiper2 = this;
  let slideIndex = index;
  if (slideIndex < 0)
    slideIndex = 0;
  const {
    params,
    snapGrid,
    slidesGrid,
    previousIndex,
    activeIndex,
    rtlTranslate: rtl,
    wrapperEl,
    enabled
  } = swiper2;
  if (swiper2.animating && params.preventInteractionOnTransition || !enabled && !internal && !initial) {
    return false;
  }
  const skip = Math.min(swiper2.params.slidesPerGroupSkip, slideIndex);
  let snapIndex = skip + Math.floor((slideIndex - skip) / swiper2.params.slidesPerGroup);
  if (snapIndex >= snapGrid.length)
    snapIndex = snapGrid.length - 1;
  const translate2 = -snapGrid[snapIndex];
  if (params.normalizeSlideIndex) {
    for (let i2 = 0; i2 < slidesGrid.length; i2 += 1) {
      const normalizedTranslate = -Math.floor(translate2 * 100);
      const normalizedGrid = Math.floor(slidesGrid[i2] * 100);
      const normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
      if (typeof slidesGrid[i2 + 1] !== "undefined") {
        if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
          slideIndex = i2;
        } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
          slideIndex = i2 + 1;
        }
      } else if (normalizedTranslate >= normalizedGrid) {
        slideIndex = i2;
      }
    }
  }
  if (swiper2.initialized && slideIndex !== activeIndex) {
    if (!swiper2.allowSlideNext && (rtl ? translate2 > swiper2.translate && translate2 > swiper2.minTranslate() : translate2 < swiper2.translate && translate2 < swiper2.minTranslate())) {
      return false;
    }
    if (!swiper2.allowSlidePrev && translate2 > swiper2.translate && translate2 > swiper2.maxTranslate()) {
      if ((activeIndex || 0) !== slideIndex) {
        return false;
      }
    }
  }
  if (slideIndex !== (previousIndex || 0) && runCallbacks) {
    swiper2.emit("beforeSlideChangeStart");
  }
  swiper2.updateProgress(translate2);
  let direction;
  if (slideIndex > activeIndex)
    direction = "next";
  else if (slideIndex < activeIndex)
    direction = "prev";
  else
    direction = "reset";
  if (rtl && -translate2 === swiper2.translate || !rtl && translate2 === swiper2.translate) {
    swiper2.updateActiveIndex(slideIndex);
    if (params.autoHeight) {
      swiper2.updateAutoHeight();
    }
    swiper2.updateSlidesClasses();
    if (params.effect !== "slide") {
      swiper2.setTranslate(translate2);
    }
    if (direction !== "reset") {
      swiper2.transitionStart(runCallbacks, direction);
      swiper2.transitionEnd(runCallbacks, direction);
    }
    return false;
  }
  if (params.cssMode) {
    const isH = swiper2.isHorizontal();
    const t2 = rtl ? translate2 : -translate2;
    if (speed === 0) {
      const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
      if (isVirtual) {
        swiper2.wrapperEl.style.scrollSnapType = "none";
        swiper2._immediateVirtual = true;
      }
      if (isVirtual && !swiper2._cssModeVirtualInitialSet && swiper2.params.initialSlide > 0) {
        swiper2._cssModeVirtualInitialSet = true;
        requestAnimationFrame(() => {
          wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
        });
      } else {
        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t2;
      }
      if (isVirtual) {
        requestAnimationFrame(() => {
          swiper2.wrapperEl.style.scrollSnapType = "";
          swiper2._immediateVirtual = false;
        });
      }
    } else {
      if (!swiper2.support.smoothScroll) {
        animateCSSModeScroll({
          swiper: swiper2,
          targetPosition: t2,
          side: isH ? "left" : "top"
        });
        return true;
      }
      wrapperEl.scrollTo({
        [isH ? "left" : "top"]: t2,
        behavior: "smooth"
      });
    }
    return true;
  }
  swiper2.setTransition(speed);
  swiper2.setTranslate(translate2);
  swiper2.updateActiveIndex(slideIndex);
  swiper2.updateSlidesClasses();
  swiper2.emit("beforeTransitionStart", speed, internal);
  swiper2.transitionStart(runCallbacks, direction);
  if (speed === 0) {
    swiper2.transitionEnd(runCallbacks, direction);
  } else if (!swiper2.animating) {
    swiper2.animating = true;
    if (!swiper2.onSlideToWrapperTransitionEnd) {
      swiper2.onSlideToWrapperTransitionEnd = function transitionEnd2(e2) {
        if (!swiper2 || swiper2.destroyed)
          return;
        if (e2.target !== this)
          return;
        swiper2.wrapperEl.removeEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
        swiper2.onSlideToWrapperTransitionEnd = null;
        delete swiper2.onSlideToWrapperTransitionEnd;
        swiper2.transitionEnd(runCallbacks, direction);
      };
    }
    swiper2.wrapperEl.addEventListener("transitionend", swiper2.onSlideToWrapperTransitionEnd);
  }
  return true;
}
function slideToLoop(index, speed, runCallbacks, internal) {
  if (index === void 0) {
    index = 0;
  }
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (typeof index === "string") {
    const indexAsNumber = parseInt(index, 10);
    index = indexAsNumber;
  }
  const swiper2 = this;
  let newIndex = index;
  if (swiper2.params.loop) {
    if (swiper2.virtual && swiper2.params.virtual.enabled) {
      newIndex = newIndex + swiper2.virtual.slidesBefore;
    } else {
      newIndex = swiper2.getSlideIndexByData(newIndex);
    }
  }
  return swiper2.slideTo(newIndex, speed, runCallbacks, internal);
}
function slideNext(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  const {
    enabled,
    params,
    animating
  } = swiper2;
  if (!enabled)
    return swiper2;
  let perGroup = params.slidesPerGroup;
  if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
    perGroup = Math.max(swiper2.slidesPerViewDynamic("current", true), 1);
  }
  const increment = swiper2.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
  const isVirtual = swiper2.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return false;
    swiper2.loopFix({
      direction: "next"
    });
    swiper2._clientLeft = swiper2.wrapperEl.clientLeft;
    if (swiper2.activeIndex === swiper2.slides.length - 1 && params.cssMode) {
      requestAnimationFrame(() => {
        swiper2.slideTo(swiper2.activeIndex + increment, speed, runCallbacks, internal);
      });
      return true;
    }
  }
  if (params.rewind && swiper2.isEnd) {
    return swiper2.slideTo(0, speed, runCallbacks, internal);
  }
  return swiper2.slideTo(swiper2.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  const {
    params,
    snapGrid,
    slidesGrid,
    rtlTranslate,
    enabled,
    animating
  } = swiper2;
  if (!enabled)
    return swiper2;
  const isVirtual = swiper2.virtual && params.virtual.enabled;
  if (params.loop) {
    if (animating && !isVirtual && params.loopPreventsSliding)
      return false;
    swiper2.loopFix({
      direction: "prev"
    });
    swiper2._clientLeft = swiper2.wrapperEl.clientLeft;
  }
  const translate2 = rtlTranslate ? swiper2.translate : -swiper2.translate;
  function normalize2(val) {
    if (val < 0)
      return -Math.floor(Math.abs(val));
    return Math.floor(val);
  }
  const normalizedTranslate = normalize2(translate2);
  const normalizedSnapGrid = snapGrid.map((val) => normalize2(val));
  let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
  if (typeof prevSnap === "undefined" && params.cssMode) {
    let prevSnapIndex;
    snapGrid.forEach((snap, snapIndex) => {
      if (normalizedTranslate >= snap) {
        prevSnapIndex = snapIndex;
      }
    });
    if (typeof prevSnapIndex !== "undefined") {
      prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
    }
  }
  let prevIndex = 0;
  if (typeof prevSnap !== "undefined") {
    prevIndex = slidesGrid.indexOf(prevSnap);
    if (prevIndex < 0)
      prevIndex = swiper2.activeIndex - 1;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
      prevIndex = prevIndex - swiper2.slidesPerViewDynamic("previous", true) + 1;
      prevIndex = Math.max(prevIndex, 0);
    }
  }
  if (params.rewind && swiper2.isBeginning) {
    const lastIndex = swiper2.params.virtual && swiper2.params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
    return swiper2.slideTo(lastIndex, speed, runCallbacks, internal);
  } else if (params.loop && swiper2.activeIndex === 0 && params.cssMode) {
    requestAnimationFrame(() => {
      swiper2.slideTo(prevIndex, speed, runCallbacks, internal);
    });
    return true;
  }
  return swiper2.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed, runCallbacks, internal) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  const swiper2 = this;
  return swiper2.slideTo(swiper2.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed, runCallbacks, internal, threshold) {
  if (speed === void 0) {
    speed = this.params.speed;
  }
  if (runCallbacks === void 0) {
    runCallbacks = true;
  }
  if (threshold === void 0) {
    threshold = 0.5;
  }
  const swiper2 = this;
  let index = swiper2.activeIndex;
  const skip = Math.min(swiper2.params.slidesPerGroupSkip, index);
  const snapIndex = skip + Math.floor((index - skip) / swiper2.params.slidesPerGroup);
  const translate2 = swiper2.rtlTranslate ? swiper2.translate : -swiper2.translate;
  if (translate2 >= swiper2.snapGrid[snapIndex]) {
    const currentSnap = swiper2.snapGrid[snapIndex];
    const nextSnap = swiper2.snapGrid[snapIndex + 1];
    if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
      index += swiper2.params.slidesPerGroup;
    }
  } else {
    const prevSnap = swiper2.snapGrid[snapIndex - 1];
    const currentSnap = swiper2.snapGrid[snapIndex];
    if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
      index -= swiper2.params.slidesPerGroup;
    }
  }
  index = Math.max(index, 0);
  index = Math.min(index, swiper2.slidesGrid.length - 1);
  return swiper2.slideTo(index, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
  const swiper2 = this;
  const {
    params,
    slidesEl
  } = swiper2;
  const slidesPerView = params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : params.slidesPerView;
  let slideToIndex = swiper2.clickedIndex;
  let realIndex;
  const slideSelector = swiper2.isElement ? `swiper-slide` : `.${params.slideClass}`;
  if (params.loop) {
    if (swiper2.animating)
      return;
    realIndex = parseInt(swiper2.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
    if (params.centeredSlides) {
      if (slideToIndex < swiper2.loopedSlides - slidesPerView / 2 || slideToIndex > swiper2.slides.length - swiper2.loopedSlides + slidesPerView / 2) {
        swiper2.loopFix();
        slideToIndex = swiper2.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
        nextTick(() => {
          swiper2.slideTo(slideToIndex);
        });
      } else {
        swiper2.slideTo(slideToIndex);
      }
    } else if (slideToIndex > swiper2.slides.length - slidesPerView) {
      swiper2.loopFix();
      slideToIndex = swiper2.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
      nextTick(() => {
        swiper2.slideTo(slideToIndex);
      });
    } else {
      swiper2.slideTo(slideToIndex);
    }
  } else {
    swiper2.slideTo(slideToIndex);
  }
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate(slideRealIndex) {
  const swiper2 = this;
  const {
    params,
    slidesEl
  } = swiper2;
  if (!params.loop || swiper2.virtual && swiper2.params.virtual.enabled)
    return;
  const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  slides.forEach((el2, index) => {
    el2.setAttribute("data-swiper-slide-index", index);
  });
  swiper2.loopFix({
    slideRealIndex,
    direction: params.centeredSlides ? void 0 : "next"
  });
}
function loopFix(_temp) {
  let {
    slideRealIndex,
    slideTo: slideTo2 = true,
    direction,
    setTranslate: setTranslate2,
    activeSlideIndex,
    byController,
    byMousewheel
  } = _temp === void 0 ? {} : _temp;
  const swiper2 = this;
  if (!swiper2.params.loop)
    return;
  swiper2.emit("beforeLoopFix");
  const {
    slides,
    allowSlidePrev,
    allowSlideNext,
    slidesEl,
    params
  } = swiper2;
  swiper2.allowSlidePrev = true;
  swiper2.allowSlideNext = true;
  if (swiper2.virtual && params.virtual.enabled) {
    if (slideTo2) {
      if (!params.centeredSlides && swiper2.snapIndex === 0) {
        swiper2.slideTo(swiper2.virtual.slides.length, 0, false, true);
      } else if (params.centeredSlides && swiper2.snapIndex < params.slidesPerView) {
        swiper2.slideTo(swiper2.virtual.slides.length + swiper2.snapIndex, 0, false, true);
      } else if (swiper2.snapIndex === swiper2.snapGrid.length - 1) {
        swiper2.slideTo(swiper2.virtual.slidesBefore, 0, false, true);
      }
    }
    swiper2.allowSlidePrev = allowSlidePrev;
    swiper2.allowSlideNext = allowSlideNext;
    swiper2.emit("loopFix");
    return;
  }
  const slidesPerView = params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10));
  let loopedSlides = params.loopedSlides || slidesPerView;
  if (loopedSlides % params.slidesPerGroup !== 0) {
    loopedSlides += params.slidesPerGroup - loopedSlides % params.slidesPerGroup;
  }
  swiper2.loopedSlides = loopedSlides;
  const prependSlidesIndexes = [];
  const appendSlidesIndexes = [];
  let activeIndex = swiper2.activeIndex;
  if (typeof activeSlideIndex === "undefined") {
    activeSlideIndex = swiper2.getSlideIndex(swiper2.slides.filter((el2) => el2.classList.contains(params.slideActiveClass))[0]);
  } else {
    activeIndex = activeSlideIndex;
  }
  const isNext = direction === "next" || !direction;
  const isPrev = direction === "prev" || !direction;
  let slidesPrepended = 0;
  let slidesAppended = 0;
  if (activeSlideIndex < loopedSlides) {
    slidesPrepended = Math.max(loopedSlides - activeSlideIndex, params.slidesPerGroup);
    for (let i2 = 0; i2 < loopedSlides - activeSlideIndex; i2 += 1) {
      const index = i2 - Math.floor(i2 / slides.length) * slides.length;
      prependSlidesIndexes.push(slides.length - index - 1);
    }
  } else if (activeSlideIndex > swiper2.slides.length - loopedSlides * 2) {
    slidesAppended = Math.max(activeSlideIndex - (swiper2.slides.length - loopedSlides * 2), params.slidesPerGroup);
    for (let i2 = 0; i2 < slidesAppended; i2 += 1) {
      const index = i2 - Math.floor(i2 / slides.length) * slides.length;
      appendSlidesIndexes.push(index);
    }
  }
  if (isPrev) {
    prependSlidesIndexes.forEach((index) => {
      swiper2.slides[index].swiperLoopMoveDOM = true;
      slidesEl.prepend(swiper2.slides[index]);
      swiper2.slides[index].swiperLoopMoveDOM = false;
    });
  }
  if (isNext) {
    appendSlidesIndexes.forEach((index) => {
      swiper2.slides[index].swiperLoopMoveDOM = true;
      slidesEl.append(swiper2.slides[index]);
      swiper2.slides[index].swiperLoopMoveDOM = false;
    });
  }
  swiper2.recalcSlides();
  if (params.slidesPerView === "auto") {
    swiper2.updateSlides();
  }
  if (params.watchSlidesProgress) {
    swiper2.updateSlidesOffset();
  }
  if (slideTo2) {
    if (prependSlidesIndexes.length > 0 && isPrev) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper2.slidesGrid[activeIndex];
        const newSlideTranslate = swiper2.slidesGrid[activeIndex + slidesPrepended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper2.setTranslate(swiper2.translate - diff);
        } else {
          swiper2.slideTo(activeIndex + slidesPrepended, 0, false, true);
          if (setTranslate2) {
            swiper2.touches[swiper2.isHorizontal() ? "startX" : "startY"] += diff;
            swiper2.touchEventsData.currentTranslate = swiper2.translate;
          }
        }
      } else {
        if (setTranslate2) {
          swiper2.slideToLoop(slideRealIndex, 0, false, true);
          swiper2.touchEventsData.currentTranslate = swiper2.translate;
        }
      }
    } else if (appendSlidesIndexes.length > 0 && isNext) {
      if (typeof slideRealIndex === "undefined") {
        const currentSlideTranslate = swiper2.slidesGrid[activeIndex];
        const newSlideTranslate = swiper2.slidesGrid[activeIndex - slidesAppended];
        const diff = newSlideTranslate - currentSlideTranslate;
        if (byMousewheel) {
          swiper2.setTranslate(swiper2.translate - diff);
        } else {
          swiper2.slideTo(activeIndex - slidesAppended, 0, false, true);
          if (setTranslate2) {
            swiper2.touches[swiper2.isHorizontal() ? "startX" : "startY"] += diff;
            swiper2.touchEventsData.currentTranslate = swiper2.translate;
          }
        }
      } else {
        swiper2.slideToLoop(slideRealIndex, 0, false, true);
      }
    }
  }
  swiper2.allowSlidePrev = allowSlidePrev;
  swiper2.allowSlideNext = allowSlideNext;
  if (swiper2.controller && swiper2.controller.control && !byController) {
    const loopParams = {
      slideRealIndex,
      direction,
      setTranslate: setTranslate2,
      activeSlideIndex,
      byController: true
    };
    if (Array.isArray(swiper2.controller.control)) {
      swiper2.controller.control.forEach((c2) => {
        if (!c2.destroyed && c2.params.loop)
          c2.loopFix({
            ...loopParams,
            slideTo: c2.params.slidesPerView === params.slidesPerView ? slideTo2 : false
          });
      });
    } else if (swiper2.controller.control instanceof swiper2.constructor && swiper2.controller.control.params.loop) {
      swiper2.controller.control.loopFix({
        ...loopParams,
        slideTo: swiper2.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
      });
    }
  }
  swiper2.emit("loopFix");
}
function loopDestroy() {
  const swiper2 = this;
  const {
    params,
    slidesEl
  } = swiper2;
  if (!params.loop || swiper2.virtual && swiper2.params.virtual.enabled)
    return;
  swiper2.recalcSlides();
  const newSlidesOrder = [];
  swiper2.slides.forEach((slideEl) => {
    const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
    newSlidesOrder[index] = slideEl;
  });
  swiper2.slides.forEach((slideEl) => {
    slideEl.removeAttribute("data-swiper-slide-index");
  });
  newSlidesOrder.forEach((slideEl) => {
    slidesEl.append(slideEl);
  });
  swiper2.recalcSlides();
  swiper2.slideTo(swiper2.realIndex, 0);
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(moving) {
  const swiper2 = this;
  if (!swiper2.params.simulateTouch || swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode)
    return;
  const el2 = swiper2.params.touchEventsTarget === "container" ? swiper2.el : swiper2.wrapperEl;
  if (swiper2.isElement) {
    swiper2.__preventObserver__ = true;
  }
  el2.style.cursor = "move";
  el2.style.cursor = moving ? "grabbing" : "grab";
  if (swiper2.isElement) {
    requestAnimationFrame(() => {
      swiper2.__preventObserver__ = false;
    });
  }
}
function unsetGrabCursor() {
  const swiper2 = this;
  if (swiper2.params.watchOverflow && swiper2.isLocked || swiper2.params.cssMode) {
    return;
  }
  if (swiper2.isElement) {
    swiper2.__preventObserver__ = true;
  }
  swiper2[swiper2.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
  if (swiper2.isElement) {
    requestAnimationFrame(() => {
      swiper2.__preventObserver__ = false;
    });
  }
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(selector, base) {
  if (base === void 0) {
    base = this;
  }
  function __closestFrom(el2) {
    if (!el2 || el2 === getDocument() || el2 === getWindow())
      return null;
    if (el2.assignedSlot)
      el2 = el2.assignedSlot;
    const found = el2.closest(selector);
    if (!found && !el2.getRootNode) {
      return null;
    }
    return found || __closestFrom(el2.getRootNode().host);
  }
  return __closestFrom(base);
}
function onTouchStart(event) {
  const swiper2 = this;
  const document2 = getDocument();
  const window2 = getWindow();
  const data = swiper2.touchEventsData;
  data.evCache.push(event);
  const {
    params,
    touches,
    enabled
  } = swiper2;
  if (!enabled)
    return;
  if (!params.simulateTouch && event.pointerType === "mouse")
    return;
  if (swiper2.animating && params.preventInteractionOnTransition) {
    return;
  }
  if (!swiper2.animating && params.cssMode && params.loop) {
    swiper2.loopFix();
  }
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  let targetEl = e2.target;
  if (params.touchEventsTarget === "wrapper") {
    if (!swiper2.wrapperEl.contains(targetEl))
      return;
  }
  if ("which" in e2 && e2.which === 3)
    return;
  if ("button" in e2 && e2.button > 0)
    return;
  if (data.isTouched && data.isMoved)
    return;
  const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
  const eventPath = event.composedPath ? event.composedPath() : event.path;
  if (swipingClassHasValue && e2.target && e2.target.shadowRoot && eventPath) {
    targetEl = eventPath[0];
  }
  const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
  const isTargetShadow = !!(e2.target && e2.target.shadowRoot);
  if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
    swiper2.allowClick = true;
    return;
  }
  if (params.swipeHandler) {
    if (!targetEl.closest(params.swipeHandler))
      return;
  }
  touches.currentX = e2.pageX;
  touches.currentY = e2.pageY;
  const startX = touches.currentX;
  const startY = touches.currentY;
  const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
  const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
  if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
    if (edgeSwipeDetection === "prevent") {
      event.preventDefault();
    } else {
      return;
    }
  }
  Object.assign(data, {
    isTouched: true,
    isMoved: false,
    allowTouchCallbacks: true,
    isScrolling: void 0,
    startMoving: void 0
  });
  touches.startX = startX;
  touches.startY = startY;
  data.touchStartTime = now();
  swiper2.allowClick = true;
  swiper2.updateSize();
  swiper2.swipeDirection = void 0;
  if (params.threshold > 0)
    data.allowThresholdMove = false;
  let preventDefault = true;
  if (targetEl.matches(data.focusableElements)) {
    preventDefault = false;
    if (targetEl.nodeName === "SELECT") {
      data.isTouched = false;
    }
  }
  if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl) {
    document2.activeElement.blur();
  }
  const shouldPreventDefault = preventDefault && swiper2.allowTouchMove && params.touchStartPreventDefault;
  if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
    e2.preventDefault();
  }
  if (params.freeMode && params.freeMode.enabled && swiper2.freeMode && swiper2.animating && !params.cssMode) {
    swiper2.freeMode.onTouchStart();
  }
  swiper2.emit("touchStart", e2);
}
function onTouchMove(event) {
  const document2 = getDocument();
  const swiper2 = this;
  const data = swiper2.touchEventsData;
  const {
    params,
    touches,
    rtlTranslate: rtl,
    enabled
  } = swiper2;
  if (!enabled)
    return;
  if (!params.simulateTouch && event.pointerType === "mouse")
    return;
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  if (!data.isTouched) {
    if (data.startMoving && data.isScrolling) {
      swiper2.emit("touchMoveOpposite", e2);
    }
    return;
  }
  const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === e2.pointerId);
  if (pointerIndex >= 0)
    data.evCache[pointerIndex] = e2;
  const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e2;
  const pageX = targetTouch.pageX;
  const pageY = targetTouch.pageY;
  if (e2.preventedByNestedSwiper) {
    touches.startX = pageX;
    touches.startY = pageY;
    return;
  }
  if (!swiper2.allowTouchMove) {
    if (!e2.target.matches(data.focusableElements)) {
      swiper2.allowClick = false;
    }
    if (data.isTouched) {
      Object.assign(touches, {
        startX: pageX,
        startY: pageY,
        prevX: swiper2.touches.currentX,
        prevY: swiper2.touches.currentY,
        currentX: pageX,
        currentY: pageY
      });
      data.touchStartTime = now();
    }
    return;
  }
  if (params.touchReleaseOnEdges && !params.loop) {
    if (swiper2.isVertical()) {
      if (pageY < touches.startY && swiper2.translate <= swiper2.maxTranslate() || pageY > touches.startY && swiper2.translate >= swiper2.minTranslate()) {
        data.isTouched = false;
        data.isMoved = false;
        return;
      }
    } else if (pageX < touches.startX && swiper2.translate <= swiper2.maxTranslate() || pageX > touches.startX && swiper2.translate >= swiper2.minTranslate()) {
      return;
    }
  }
  if (document2.activeElement) {
    if (e2.target === document2.activeElement && e2.target.matches(data.focusableElements)) {
      data.isMoved = true;
      swiper2.allowClick = false;
      return;
    }
  }
  if (data.allowTouchCallbacks) {
    swiper2.emit("touchMove", e2);
  }
  if (e2.targetTouches && e2.targetTouches.length > 1)
    return;
  touches.currentX = pageX;
  touches.currentY = pageY;
  const diffX = touches.currentX - touches.startX;
  const diffY = touches.currentY - touches.startY;
  if (swiper2.params.threshold && Math.sqrt(diffX ** 2 + diffY ** 2) < swiper2.params.threshold)
    return;
  if (typeof data.isScrolling === "undefined") {
    let touchAngle;
    if (swiper2.isHorizontal() && touches.currentY === touches.startY || swiper2.isVertical() && touches.currentX === touches.startX) {
      data.isScrolling = false;
    } else {
      if (diffX * diffX + diffY * diffY >= 25) {
        touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
        data.isScrolling = swiper2.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
      }
    }
  }
  if (data.isScrolling) {
    swiper2.emit("touchMoveOpposite", e2);
  }
  if (typeof data.startMoving === "undefined") {
    if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
      data.startMoving = true;
    }
  }
  if (data.isScrolling || swiper2.zoom && swiper2.params.zoom && swiper2.params.zoom.enabled && data.evCache.length > 1) {
    data.isTouched = false;
    return;
  }
  if (!data.startMoving) {
    return;
  }
  swiper2.allowClick = false;
  if (!params.cssMode && e2.cancelable) {
    e2.preventDefault();
  }
  if (params.touchMoveStopPropagation && !params.nested) {
    e2.stopPropagation();
  }
  let diff = swiper2.isHorizontal() ? diffX : diffY;
  let touchesDiff = swiper2.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
  if (params.oneWayMovement) {
    diff = Math.abs(diff) * (rtl ? 1 : -1);
    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
  }
  touches.diff = diff;
  diff *= params.touchRatio;
  if (rtl) {
    diff = -diff;
    touchesDiff = -touchesDiff;
  }
  const prevTouchesDirection = swiper2.touchesDirection;
  swiper2.swipeDirection = diff > 0 ? "prev" : "next";
  swiper2.touchesDirection = touchesDiff > 0 ? "prev" : "next";
  const isLoop = swiper2.params.loop && !params.cssMode;
  const allowLoopFix = swiper2.swipeDirection === "next" && swiper2.allowSlideNext || swiper2.swipeDirection === "prev" && swiper2.allowSlidePrev;
  if (!data.isMoved) {
    if (isLoop && allowLoopFix) {
      swiper2.loopFix({
        direction: swiper2.swipeDirection
      });
    }
    data.startTranslate = swiper2.getTranslate();
    swiper2.setTransition(0);
    if (swiper2.animating) {
      const evt = new window.CustomEvent("transitionend", {
        bubbles: true,
        cancelable: true
      });
      swiper2.wrapperEl.dispatchEvent(evt);
    }
    data.allowMomentumBounce = false;
    if (params.grabCursor && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
      swiper2.setGrabCursor(true);
    }
    swiper2.emit("sliderFirstMove", e2);
  }
  let loopFixed;
  if (data.isMoved && prevTouchesDirection !== swiper2.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
    swiper2.loopFix({
      direction: swiper2.swipeDirection,
      setTranslate: true
    });
    loopFixed = true;
  }
  swiper2.emit("sliderMove", e2);
  data.isMoved = true;
  data.currentTranslate = diff + data.startTranslate;
  let disableParentSwiper = true;
  let resistanceRatio = params.resistanceRatio;
  if (params.touchReleaseOnEdges) {
    resistanceRatio = 0;
  }
  if (diff > 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.currentTranslate > (params.centeredSlides ? swiper2.minTranslate() - swiper2.size / 2 : swiper2.minTranslate())) {
      swiper2.loopFix({
        direction: "prev",
        setTranslate: true,
        activeSlideIndex: 0
      });
    }
    if (data.currentTranslate > swiper2.minTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper2.minTranslate() - 1 + (-swiper2.minTranslate() + data.startTranslate + diff) ** resistanceRatio;
      }
    }
  } else if (diff < 0) {
    if (isLoop && allowLoopFix && !loopFixed && data.currentTranslate < (params.centeredSlides ? swiper2.maxTranslate() + swiper2.size / 2 : swiper2.maxTranslate())) {
      swiper2.loopFix({
        direction: "next",
        setTranslate: true,
        activeSlideIndex: swiper2.slides.length - (params.slidesPerView === "auto" ? swiper2.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
      });
    }
    if (data.currentTranslate < swiper2.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) {
        data.currentTranslate = swiper2.maxTranslate() + 1 - (swiper2.maxTranslate() - data.startTranslate - diff) ** resistanceRatio;
      }
    }
  }
  if (disableParentSwiper) {
    e2.preventedByNestedSwiper = true;
  }
  if (!swiper2.allowSlideNext && swiper2.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper2.allowSlidePrev && swiper2.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
    data.currentTranslate = data.startTranslate;
  }
  if (!swiper2.allowSlidePrev && !swiper2.allowSlideNext) {
    data.currentTranslate = data.startTranslate;
  }
  if (params.threshold > 0) {
    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
      if (!data.allowThresholdMove) {
        data.allowThresholdMove = true;
        touches.startX = touches.currentX;
        touches.startY = touches.currentY;
        data.currentTranslate = data.startTranslate;
        touches.diff = swiper2.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
        return;
      }
    } else {
      data.currentTranslate = data.startTranslate;
      return;
    }
  }
  if (!params.followFinger || params.cssMode)
    return;
  if (params.freeMode && params.freeMode.enabled && swiper2.freeMode || params.watchSlidesProgress) {
    swiper2.updateActiveIndex();
    swiper2.updateSlidesClasses();
  }
  if (params.freeMode && params.freeMode.enabled && swiper2.freeMode) {
    swiper2.freeMode.onTouchMove();
  }
  swiper2.updateProgress(data.currentTranslate);
  swiper2.setTranslate(data.currentTranslate);
}
function onTouchEnd(event) {
  const swiper2 = this;
  const data = swiper2.touchEventsData;
  const pointerIndex = data.evCache.findIndex((cachedEv) => cachedEv.pointerId === event.pointerId);
  if (pointerIndex >= 0) {
    data.evCache.splice(pointerIndex, 1);
  }
  if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(event.type)) {
    const proceed = ["pointercancel", "contextmenu"].includes(event.type) && (swiper2.browser.isSafari || swiper2.browser.isWebView);
    if (!proceed) {
      return;
    }
  }
  const {
    params,
    touches,
    rtlTranslate: rtl,
    slidesGrid,
    enabled
  } = swiper2;
  if (!enabled)
    return;
  if (!params.simulateTouch && event.pointerType === "mouse")
    return;
  let e2 = event;
  if (e2.originalEvent)
    e2 = e2.originalEvent;
  if (data.allowTouchCallbacks) {
    swiper2.emit("touchEnd", e2);
  }
  data.allowTouchCallbacks = false;
  if (!data.isTouched) {
    if (data.isMoved && params.grabCursor) {
      swiper2.setGrabCursor(false);
    }
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  if (params.grabCursor && data.isMoved && data.isTouched && (swiper2.allowSlideNext === true || swiper2.allowSlidePrev === true)) {
    swiper2.setGrabCursor(false);
  }
  const touchEndTime = now();
  const timeDiff = touchEndTime - data.touchStartTime;
  if (swiper2.allowClick) {
    const pathTree = e2.path || e2.composedPath && e2.composedPath();
    swiper2.updateClickedSlide(pathTree && pathTree[0] || e2.target, pathTree);
    swiper2.emit("tap click", e2);
    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
      swiper2.emit("doubleTap doubleClick", e2);
    }
  }
  data.lastClickTime = now();
  nextTick(() => {
    if (!swiper2.destroyed)
      swiper2.allowClick = true;
  });
  if (!data.isTouched || !data.isMoved || !swiper2.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    return;
  }
  data.isTouched = false;
  data.isMoved = false;
  data.startMoving = false;
  let currentPos;
  if (params.followFinger) {
    currentPos = rtl ? swiper2.translate : -swiper2.translate;
  } else {
    currentPos = -data.currentTranslate;
  }
  if (params.cssMode) {
    return;
  }
  if (params.freeMode && params.freeMode.enabled) {
    swiper2.freeMode.onTouchEnd({
      currentPos
    });
    return;
  }
  let stopIndex = 0;
  let groupSize = swiper2.slidesSizesGrid[0];
  for (let i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
    const increment2 = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (typeof slidesGrid[i2 + increment2] !== "undefined") {
      if (currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + increment2]) {
        stopIndex = i2;
        groupSize = slidesGrid[i2 + increment2] - slidesGrid[i2];
      }
    } else if (currentPos >= slidesGrid[i2]) {
      stopIndex = i2;
      groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
    }
  }
  let rewindFirstIndex = null;
  let rewindLastIndex = null;
  if (params.rewind) {
    if (swiper2.isBeginning) {
      rewindLastIndex = params.virtual && params.virtual.enabled && swiper2.virtual ? swiper2.virtual.slides.length - 1 : swiper2.slides.length - 1;
    } else if (swiper2.isEnd) {
      rewindFirstIndex = 0;
    }
  }
  const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
  const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
  if (timeDiff > params.longSwipesMs) {
    if (!params.longSwipes) {
      swiper2.slideTo(swiper2.activeIndex);
      return;
    }
    if (swiper2.swipeDirection === "next") {
      if (ratio >= params.longSwipesRatio)
        swiper2.slideTo(params.rewind && swiper2.isEnd ? rewindFirstIndex : stopIndex + increment);
      else
        swiper2.slideTo(stopIndex);
    }
    if (swiper2.swipeDirection === "prev") {
      if (ratio > 1 - params.longSwipesRatio) {
        swiper2.slideTo(stopIndex + increment);
      } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
        swiper2.slideTo(rewindLastIndex);
      } else {
        swiper2.slideTo(stopIndex);
      }
    }
  } else {
    if (!params.shortSwipes) {
      swiper2.slideTo(swiper2.activeIndex);
      return;
    }
    const isNavButtonTarget = swiper2.navigation && (e2.target === swiper2.navigation.nextEl || e2.target === swiper2.navigation.prevEl);
    if (!isNavButtonTarget) {
      if (swiper2.swipeDirection === "next") {
        swiper2.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
      }
      if (swiper2.swipeDirection === "prev") {
        swiper2.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
      }
    } else if (e2.target === swiper2.navigation.nextEl) {
      swiper2.slideTo(stopIndex + increment);
    } else {
      swiper2.slideTo(stopIndex);
    }
  }
}
function onResize() {
  const swiper2 = this;
  const {
    params,
    el: el2
  } = swiper2;
  if (el2 && el2.offsetWidth === 0)
    return;
  if (params.breakpoints) {
    swiper2.setBreakpoint();
  }
  const {
    allowSlideNext,
    allowSlidePrev,
    snapGrid
  } = swiper2;
  const isVirtual = swiper2.virtual && swiper2.params.virtual.enabled;
  swiper2.allowSlideNext = true;
  swiper2.allowSlidePrev = true;
  swiper2.updateSize();
  swiper2.updateSlides();
  swiper2.updateSlidesClasses();
  const isVirtualLoop = isVirtual && params.loop;
  if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper2.isEnd && !swiper2.isBeginning && !swiper2.params.centeredSlides && !isVirtualLoop) {
    swiper2.slideTo(swiper2.slides.length - 1, 0, false, true);
  } else {
    if (swiper2.params.loop && !isVirtual) {
      swiper2.slideToLoop(swiper2.realIndex, 0, false, true);
    } else {
      swiper2.slideTo(swiper2.activeIndex, 0, false, true);
    }
  }
  if (swiper2.autoplay && swiper2.autoplay.running && swiper2.autoplay.paused) {
    clearTimeout(swiper2.autoplay.resizeTimeout);
    swiper2.autoplay.resizeTimeout = setTimeout(() => {
      if (swiper2.autoplay && swiper2.autoplay.running && swiper2.autoplay.paused) {
        swiper2.autoplay.resume();
      }
    }, 500);
  }
  swiper2.allowSlidePrev = allowSlidePrev;
  swiper2.allowSlideNext = allowSlideNext;
  if (swiper2.params.watchOverflow && snapGrid !== swiper2.snapGrid) {
    swiper2.checkOverflow();
  }
}
function onClick(e2) {
  const swiper2 = this;
  if (!swiper2.enabled)
    return;
  if (!swiper2.allowClick) {
    if (swiper2.params.preventClicks)
      e2.preventDefault();
    if (swiper2.params.preventClicksPropagation && swiper2.animating) {
      e2.stopPropagation();
      e2.stopImmediatePropagation();
    }
  }
}
function onScroll() {
  const swiper2 = this;
  const {
    wrapperEl,
    rtlTranslate,
    enabled
  } = swiper2;
  if (!enabled)
    return;
  swiper2.previousTranslate = swiper2.translate;
  if (swiper2.isHorizontal()) {
    swiper2.translate = -wrapperEl.scrollLeft;
  } else {
    swiper2.translate = -wrapperEl.scrollTop;
  }
  if (swiper2.translate === 0)
    swiper2.translate = 0;
  swiper2.updateActiveIndex();
  swiper2.updateSlidesClasses();
  let newProgress;
  const translatesDiff = swiper2.maxTranslate() - swiper2.minTranslate();
  if (translatesDiff === 0) {
    newProgress = 0;
  } else {
    newProgress = (swiper2.translate - swiper2.minTranslate()) / translatesDiff;
  }
  if (newProgress !== swiper2.progress) {
    swiper2.updateProgress(rtlTranslate ? -swiper2.translate : swiper2.translate);
  }
  swiper2.emit("setTranslate", swiper2.translate, false);
}
function onLoad(e2) {
  const swiper2 = this;
  processLazyPreloader(swiper2, e2.target);
  if (swiper2.params.cssMode || swiper2.params.slidesPerView !== "auto" && !swiper2.params.autoHeight) {
    return;
  }
  swiper2.update();
}
let dummyEventAttached = false;
function dummyEventListener() {
}
const events = (swiper2, method) => {
  const document2 = getDocument();
  const {
    params,
    el: el2,
    wrapperEl,
    device
  } = swiper2;
  const capture = !!params.nested;
  const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
  const swiperMethod = method;
  el2[domMethod]("pointerdown", swiper2.onTouchStart, {
    passive: false
  });
  document2[domMethod]("pointermove", swiper2.onTouchMove, {
    passive: false,
    capture
  });
  document2[domMethod]("pointerup", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointercancel", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerout", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("pointerleave", swiper2.onTouchEnd, {
    passive: true
  });
  document2[domMethod]("contextmenu", swiper2.onTouchEnd, {
    passive: true
  });
  if (params.preventClicks || params.preventClicksPropagation) {
    el2[domMethod]("click", swiper2.onClick, true);
  }
  if (params.cssMode) {
    wrapperEl[domMethod]("scroll", swiper2.onScroll);
  }
  if (params.updateOnWindowResize) {
    swiper2[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
  } else {
    swiper2[swiperMethod]("observerUpdate", onResize, true);
  }
  el2[domMethod]("load", swiper2.onLoad, {
    capture: true
  });
};
function attachEvents() {
  const swiper2 = this;
  const document2 = getDocument();
  const {
    params
  } = swiper2;
  swiper2.onTouchStart = onTouchStart.bind(swiper2);
  swiper2.onTouchMove = onTouchMove.bind(swiper2);
  swiper2.onTouchEnd = onTouchEnd.bind(swiper2);
  if (params.cssMode) {
    swiper2.onScroll = onScroll.bind(swiper2);
  }
  swiper2.onClick = onClick.bind(swiper2);
  swiper2.onLoad = onLoad.bind(swiper2);
  if (!dummyEventAttached) {
    document2.addEventListener("touchstart", dummyEventListener);
    dummyEventAttached = true;
  }
  events(swiper2, "on");
}
function detachEvents() {
  const swiper2 = this;
  events(swiper2, "off");
}
var events$1 = {
  attachEvents,
  detachEvents
};
const isGridEnabled = (swiper2, params) => {
  return swiper2.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
  const swiper2 = this;
  const {
    realIndex,
    initialized,
    params,
    el: el2
  } = swiper2;
  const breakpoints2 = params.breakpoints;
  if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0)
    return;
  const breakpoint = swiper2.getBreakpoint(breakpoints2, swiper2.params.breakpointsBase, swiper2.el);
  if (!breakpoint || swiper2.currentBreakpoint === breakpoint)
    return;
  const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
  const breakpointParams = breakpointOnlyParams || swiper2.originalParams;
  const wasMultiRow = isGridEnabled(swiper2, params);
  const isMultiRow = isGridEnabled(swiper2, breakpointParams);
  const wasEnabled = params.enabled;
  if (wasMultiRow && !isMultiRow) {
    el2.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
    swiper2.emitContainerClasses();
  } else if (!wasMultiRow && isMultiRow) {
    el2.classList.add(`${params.containerModifierClass}grid`);
    if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
      el2.classList.add(`${params.containerModifierClass}grid-column`);
    }
    swiper2.emitContainerClasses();
  }
  ["navigation", "pagination", "scrollbar"].forEach((prop) => {
    if (typeof breakpointParams[prop] === "undefined")
      return;
    const wasModuleEnabled = params[prop] && params[prop].enabled;
    const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
    if (wasModuleEnabled && !isModuleEnabled) {
      swiper2[prop].disable();
    }
    if (!wasModuleEnabled && isModuleEnabled) {
      swiper2[prop].enable();
    }
  });
  const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
  const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
  const wasLoop = params.loop;
  if (directionChanged && initialized) {
    swiper2.changeDirection();
  }
  extend$2(swiper2.params, breakpointParams);
  const isEnabled = swiper2.params.enabled;
  const hasLoop = swiper2.params.loop;
  Object.assign(swiper2, {
    allowTouchMove: swiper2.params.allowTouchMove,
    allowSlideNext: swiper2.params.allowSlideNext,
    allowSlidePrev: swiper2.params.allowSlidePrev
  });
  if (wasEnabled && !isEnabled) {
    swiper2.disable();
  } else if (!wasEnabled && isEnabled) {
    swiper2.enable();
  }
  swiper2.currentBreakpoint = breakpoint;
  swiper2.emit("_beforeBreakpoint", breakpointParams);
  if (initialized) {
    if (needsReLoop) {
      swiper2.loopDestroy();
      swiper2.loopCreate(realIndex);
      swiper2.updateSlides();
    } else if (!wasLoop && hasLoop) {
      swiper2.loopCreate(realIndex);
      swiper2.updateSlides();
    } else if (wasLoop && !hasLoop) {
      swiper2.loopDestroy();
    }
  }
  swiper2.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base, containerEl) {
  if (base === void 0) {
    base = "window";
  }
  if (!breakpoints2 || base === "container" && !containerEl)
    return void 0;
  let breakpoint = false;
  const window2 = getWindow();
  const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
  const points = Object.keys(breakpoints2).map((point) => {
    if (typeof point === "string" && point.indexOf("@") === 0) {
      const minRatio = parseFloat(point.substr(1));
      const value = currentHeight * minRatio;
      return {
        value,
        point
      };
    }
    return {
      value: point,
      point
    };
  });
  points.sort((a2, b2) => parseInt(a2.value, 10) - parseInt(b2.value, 10));
  for (let i2 = 0; i2 < points.length; i2 += 1) {
    const {
      point,
      value
    } = points[i2];
    if (base === "window") {
      if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
        breakpoint = point;
      }
    } else if (value <= containerEl.clientWidth) {
      breakpoint = point;
    }
  }
  return breakpoint || "max";
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(entries, prefix2) {
  const resultClasses = [];
  entries.forEach((item) => {
    if (typeof item === "object") {
      Object.keys(item).forEach((classNames) => {
        if (item[classNames]) {
          resultClasses.push(prefix2 + classNames);
        }
      });
    } else if (typeof item === "string") {
      resultClasses.push(prefix2 + item);
    }
  });
  return resultClasses;
}
function addClasses() {
  const swiper2 = this;
  const {
    classNames,
    params,
    rtl,
    el: el2,
    device
  } = swiper2;
  const suffixes = prepareClasses(["initialized", params.direction, {
    "free-mode": swiper2.params.freeMode && params.freeMode.enabled
  }, {
    "autoheight": params.autoHeight
  }, {
    "rtl": rtl
  }, {
    "grid": params.grid && params.grid.rows > 1
  }, {
    "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
  }, {
    "android": device.android
  }, {
    "ios": device.ios
  }, {
    "css-mode": params.cssMode
  }, {
    "centered": params.cssMode && params.centeredSlides
  }, {
    "watch-progress": params.watchSlidesProgress
  }], params.containerModifierClass);
  classNames.push(...suffixes);
  el2.classList.add(...classNames);
  swiper2.emitContainerClasses();
}
function removeClasses() {
  const swiper2 = this;
  const {
    el: el2,
    classNames
  } = swiper2;
  el2.classList.remove(...classNames);
  swiper2.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses
};
function checkOverflow() {
  const swiper2 = this;
  const {
    isLocked: wasLocked,
    params
  } = swiper2;
  const {
    slidesOffsetBefore
  } = params;
  if (slidesOffsetBefore) {
    const lastSlideIndex = swiper2.slides.length - 1;
    const lastSlideRightEdge = swiper2.slidesGrid[lastSlideIndex] + swiper2.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
    swiper2.isLocked = swiper2.size > lastSlideRightEdge;
  } else {
    swiper2.isLocked = swiper2.snapGrid.length === 1;
  }
  if (params.allowSlideNext === true) {
    swiper2.allowSlideNext = !swiper2.isLocked;
  }
  if (params.allowSlidePrev === true) {
    swiper2.allowSlidePrev = !swiper2.isLocked;
  }
  if (wasLocked && wasLocked !== swiper2.isLocked) {
    swiper2.isEnd = false;
  }
  if (wasLocked !== swiper2.isLocked) {
    swiper2.emit(swiper2.isLocked ? "lock" : "unlock");
  }
}
var checkOverflow$1 = {
  checkOverflow
};
var defaults$2 = {
  init: true,
  direction: "horizontal",
  oneWayMovement: false,
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: false,
  updateOnWindowResize: true,
  resizeObserver: true,
  nested: false,
  createElements: false,
  enabled: true,
  focusableElements: "input, select, option, textarea, button, video, label",
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: false,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: false,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: false,
  // Set wrapper width
  setWrapperSize: false,
  // Virtual Translate
  virtualTranslate: false,
  // Effects
  effect: "slide",
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: "window",
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: false,
  centeredSlides: false,
  centeredSlidesBounds: false,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: true,
  centerInsufficientSlides: false,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: true,
  // Round length
  roundLengths: false,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: true,
  shortSwipes: true,
  longSwipes: true,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: true,
  allowTouchMove: true,
  threshold: 5,
  touchMoveStopPropagation: false,
  touchStartPreventDefault: true,
  touchStartForcePreventDefault: false,
  touchReleaseOnEdges: false,
  // Unique Navigation Elements
  uniqueNavElements: true,
  // Resistance
  resistance: true,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: false,
  // Cursor
  grabCursor: false,
  // Clicks
  preventClicks: true,
  preventClicksPropagation: true,
  slideToClickedSlide: false,
  // loop
  loop: false,
  loopedSlides: null,
  loopPreventsSliding: true,
  // rewind
  rewind: false,
  // Swiping/no swiping
  allowSlidePrev: true,
  allowSlideNext: true,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: true,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: true,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: "swiper-",
  // NEW
  slideClass: "swiper-slide",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: true,
  // Internals
  _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
  return function extendParams(obj) {
    if (obj === void 0) {
      obj = {};
    }
    const moduleParamName = Object.keys(obj)[0];
    const moduleParams = obj[moduleParamName];
    if (typeof moduleParams !== "object" || moduleParams === null) {
      extend$2(allModulesParams, obj);
      return;
    }
    if (params[moduleParamName] === true) {
      params[moduleParamName] = {
        enabled: true
      };
    }
    if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
      params[moduleParamName].auto = true;
    }
    if (["pagination", "scrollbar"].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
      params[moduleParamName].auto = true;
    }
    if (!(moduleParamName in params && "enabled" in moduleParams)) {
      extend$2(allModulesParams, obj);
      return;
    }
    if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
      params[moduleParamName].enabled = true;
    }
    if (!params[moduleParamName])
      params[moduleParamName] = {
        enabled: false
      };
    extend$2(allModulesParams, obj);
  };
}
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
};
const extendedDefaults = {};
let Swiper$1 = class Swiper {
  constructor() {
    let el2;
    let params;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
      params = args[0];
    } else {
      [el2, params] = args;
    }
    if (!params)
      params = {};
    params = extend$2({}, params);
    if (el2 && !params.el)
      params.el = el2;
    const document2 = getDocument();
    if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
      const swipers = [];
      document2.querySelectorAll(params.el).forEach((containerEl) => {
        const newParams = extend$2({}, params, {
          el: containerEl
        });
        swipers.push(new Swiper(newParams));
      });
      return swipers;
    }
    const swiper2 = this;
    swiper2.__swiper__ = true;
    swiper2.support = getSupport();
    swiper2.device = getDevice({
      userAgent: params.userAgent
    });
    swiper2.browser = getBrowser();
    swiper2.eventsListeners = {};
    swiper2.eventsAnyListeners = [];
    swiper2.modules = [...swiper2.__modules__];
    if (params.modules && Array.isArray(params.modules)) {
      swiper2.modules.push(...params.modules);
    }
    const allModulesParams = {};
    swiper2.modules.forEach((mod) => {
      mod({
        params,
        swiper: swiper2,
        extendParams: moduleExtendParams(params, allModulesParams),
        on: swiper2.on.bind(swiper2),
        once: swiper2.once.bind(swiper2),
        off: swiper2.off.bind(swiper2),
        emit: swiper2.emit.bind(swiper2)
      });
    });
    const swiperParams = extend$2({}, defaults$2, allModulesParams);
    swiper2.params = extend$2({}, swiperParams, extendedDefaults, params);
    swiper2.originalParams = extend$2({}, swiper2.params);
    swiper2.passedParams = extend$2({}, params);
    if (swiper2.params && swiper2.params.on) {
      Object.keys(swiper2.params.on).forEach((eventName) => {
        swiper2.on(eventName, swiper2.params.on[eventName]);
      });
    }
    if (swiper2.params && swiper2.params.onAny) {
      swiper2.onAny(swiper2.params.onAny);
    }
    Object.assign(swiper2, {
      enabled: swiper2.params.enabled,
      el: el2,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return swiper2.params.direction === "horizontal";
      },
      isVertical() {
        return swiper2.params.direction === "vertical";
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: true,
      isEnd: false,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: false,
      cssOverflowAdjustment() {
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: swiper2.params.allowSlideNext,
      allowSlidePrev: swiper2.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: swiper2.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        evCache: []
      },
      // Clicks
      allowClick: true,
      // Touches
      allowTouchMove: swiper2.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    });
    swiper2.emit("_swiper");
    if (swiper2.params.init) {
      swiper2.init();
    }
    return swiper2;
  }
  getSlideIndex(slideEl) {
    const {
      slidesEl,
      params
    } = this;
    const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    const firstSlideIndex = elementIndex(slides[0]);
    return elementIndex(slideEl) - firstSlideIndex;
  }
  getSlideIndexByData(index) {
    return this.getSlideIndex(this.slides.filter((slideEl) => slideEl.getAttribute("data-swiper-slide-index") * 1 === index)[0]);
  }
  recalcSlides() {
    const swiper2 = this;
    const {
      slidesEl,
      params
    } = swiper2;
    swiper2.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
  }
  enable() {
    const swiper2 = this;
    if (swiper2.enabled)
      return;
    swiper2.enabled = true;
    if (swiper2.params.grabCursor) {
      swiper2.setGrabCursor();
    }
    swiper2.emit("enable");
  }
  disable() {
    const swiper2 = this;
    if (!swiper2.enabled)
      return;
    swiper2.enabled = false;
    if (swiper2.params.grabCursor) {
      swiper2.unsetGrabCursor();
    }
    swiper2.emit("disable");
  }
  setProgress(progress, speed) {
    const swiper2 = this;
    progress = Math.min(Math.max(progress, 0), 1);
    const min = swiper2.minTranslate();
    const max = swiper2.maxTranslate();
    const current = (max - min) * progress + min;
    swiper2.translateTo(current, typeof speed === "undefined" ? 0 : speed);
    swiper2.updateActiveIndex();
    swiper2.updateSlidesClasses();
  }
  emitContainerClasses() {
    const swiper2 = this;
    if (!swiper2.params._emitClasses || !swiper2.el)
      return;
    const cls = swiper2.el.className.split(" ").filter((className) => {
      return className.indexOf("swiper") === 0 || className.indexOf(swiper2.params.containerModifierClass) === 0;
    });
    swiper2.emit("_containerClasses", cls.join(" "));
  }
  getSlideClasses(slideEl) {
    const swiper2 = this;
    if (swiper2.destroyed)
      return "";
    return slideEl.className.split(" ").filter((className) => {
      return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper2.params.slideClass) === 0;
    }).join(" ");
  }
  emitSlidesClasses() {
    const swiper2 = this;
    if (!swiper2.params._emitClasses || !swiper2.el)
      return;
    const updates = [];
    swiper2.slides.forEach((slideEl) => {
      const classNames = swiper2.getSlideClasses(slideEl);
      updates.push({
        slideEl,
        classNames
      });
      swiper2.emit("_slideClass", slideEl, classNames);
    });
    swiper2.emit("_slideClasses", updates);
  }
  slidesPerViewDynamic(view, exact) {
    if (view === void 0) {
      view = "current";
    }
    if (exact === void 0) {
      exact = false;
    }
    const swiper2 = this;
    const {
      params,
      slides,
      slidesGrid,
      slidesSizesGrid,
      size: swiperSize,
      activeIndex
    } = swiper2;
    let spv = 1;
    if (typeof params.slidesPerView === "number")
      return params.slidesPerView;
    if (params.centeredSlides) {
      let slideSize = slides[activeIndex] ? slides[activeIndex].swiperSlideSize : 0;
      let breakLoop;
      for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
        if (slides[i2] && !breakLoop) {
          slideSize += slides[i2].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
      for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
        if (slides[i2] && !breakLoop) {
          slideSize += slides[i2].swiperSlideSize;
          spv += 1;
          if (slideSize > swiperSize)
            breakLoop = true;
        }
      }
    } else {
      if (view === "current") {
        for (let i2 = activeIndex + 1; i2 < slides.length; i2 += 1) {
          const slideInView = exact ? slidesGrid[i2] + slidesSizesGrid[i2] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i2] - slidesGrid[activeIndex] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      } else {
        for (let i2 = activeIndex - 1; i2 >= 0; i2 -= 1) {
          const slideInView = slidesGrid[activeIndex] - slidesGrid[i2] < swiperSize;
          if (slideInView) {
            spv += 1;
          }
        }
      }
    }
    return spv;
  }
  update() {
    const swiper2 = this;
    if (!swiper2 || swiper2.destroyed)
      return;
    const {
      snapGrid,
      params
    } = swiper2;
    if (params.breakpoints) {
      swiper2.setBreakpoint();
    }
    [...swiper2.el.querySelectorAll('[loading="lazy"]')].forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper2, imageEl);
      }
    });
    swiper2.updateSize();
    swiper2.updateSlides();
    swiper2.updateProgress();
    swiper2.updateSlidesClasses();
    function setTranslate2() {
      const translateValue = swiper2.rtlTranslate ? swiper2.translate * -1 : swiper2.translate;
      const newTranslate = Math.min(Math.max(translateValue, swiper2.maxTranslate()), swiper2.minTranslate());
      swiper2.setTranslate(newTranslate);
      swiper2.updateActiveIndex();
      swiper2.updateSlidesClasses();
    }
    let translated;
    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
      setTranslate2();
      if (params.autoHeight) {
        swiper2.updateAutoHeight();
      }
    } else {
      if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper2.isEnd && !params.centeredSlides) {
        const slides = swiper2.virtual && params.virtual.enabled ? swiper2.virtual.slides : swiper2.slides;
        translated = swiper2.slideTo(slides.length - 1, 0, false, true);
      } else {
        translated = swiper2.slideTo(swiper2.activeIndex, 0, false, true);
      }
      if (!translated) {
        setTranslate2();
      }
    }
    if (params.watchOverflow && snapGrid !== swiper2.snapGrid) {
      swiper2.checkOverflow();
    }
    swiper2.emit("update");
  }
  changeDirection(newDirection, needUpdate) {
    if (needUpdate === void 0) {
      needUpdate = true;
    }
    const swiper2 = this;
    const currentDirection = swiper2.params.direction;
    if (!newDirection) {
      newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
    }
    if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
      return swiper2;
    }
    swiper2.el.classList.remove(`${swiper2.params.containerModifierClass}${currentDirection}`);
    swiper2.el.classList.add(`${swiper2.params.containerModifierClass}${newDirection}`);
    swiper2.emitContainerClasses();
    swiper2.params.direction = newDirection;
    swiper2.slides.forEach((slideEl) => {
      if (newDirection === "vertical") {
        slideEl.style.width = "";
      } else {
        slideEl.style.height = "";
      }
    });
    swiper2.emit("changeDirection");
    if (needUpdate)
      swiper2.update();
    return swiper2;
  }
  changeLanguageDirection(direction) {
    const swiper2 = this;
    if (swiper2.rtl && direction === "rtl" || !swiper2.rtl && direction === "ltr")
      return;
    swiper2.rtl = direction === "rtl";
    swiper2.rtlTranslate = swiper2.params.direction === "horizontal" && swiper2.rtl;
    if (swiper2.rtl) {
      swiper2.el.classList.add(`${swiper2.params.containerModifierClass}rtl`);
      swiper2.el.dir = "rtl";
    } else {
      swiper2.el.classList.remove(`${swiper2.params.containerModifierClass}rtl`);
      swiper2.el.dir = "ltr";
    }
    swiper2.update();
  }
  mount(element) {
    const swiper2 = this;
    if (swiper2.mounted)
      return true;
    let el2 = element || swiper2.params.el;
    if (typeof el2 === "string") {
      el2 = document.querySelector(el2);
    }
    if (!el2) {
      return false;
    }
    el2.swiper = swiper2;
    if (el2.parentNode && el2.parentNode.host && el2.parentNode.host.nodeName === "SWIPER-CONTAINER") {
      swiper2.isElement = true;
    }
    const getWrapperSelector = () => {
      return `.${(swiper2.params.wrapperClass || "").trim().split(" ").join(".")}`;
    };
    const getWrapper = () => {
      if (el2 && el2.shadowRoot && el2.shadowRoot.querySelector) {
        const res = el2.shadowRoot.querySelector(getWrapperSelector());
        return res;
      }
      return elementChildren(el2, getWrapperSelector())[0];
    };
    let wrapperEl = getWrapper();
    if (!wrapperEl && swiper2.params.createElements) {
      wrapperEl = createElement("div", swiper2.params.wrapperClass);
      el2.append(wrapperEl);
      elementChildren(el2, `.${swiper2.params.slideClass}`).forEach((slideEl) => {
        wrapperEl.append(slideEl);
      });
    }
    Object.assign(swiper2, {
      el: el2,
      wrapperEl,
      slidesEl: swiper2.isElement && !el2.parentNode.host.slideSlots ? el2.parentNode.host : wrapperEl,
      hostEl: swiper2.isElement ? el2.parentNode.host : el2,
      mounted: true,
      // RTL
      rtl: el2.dir.toLowerCase() === "rtl" || elementStyle(el2, "direction") === "rtl",
      rtlTranslate: swiper2.params.direction === "horizontal" && (el2.dir.toLowerCase() === "rtl" || elementStyle(el2, "direction") === "rtl"),
      wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
    });
    return true;
  }
  init(el2) {
    const swiper2 = this;
    if (swiper2.initialized)
      return swiper2;
    const mounted = swiper2.mount(el2);
    if (mounted === false)
      return swiper2;
    swiper2.emit("beforeInit");
    if (swiper2.params.breakpoints) {
      swiper2.setBreakpoint();
    }
    swiper2.addClasses();
    swiper2.updateSize();
    swiper2.updateSlides();
    if (swiper2.params.watchOverflow) {
      swiper2.checkOverflow();
    }
    if (swiper2.params.grabCursor && swiper2.enabled) {
      swiper2.setGrabCursor();
    }
    if (swiper2.params.loop && swiper2.virtual && swiper2.params.virtual.enabled) {
      swiper2.slideTo(swiper2.params.initialSlide + swiper2.virtual.slidesBefore, 0, swiper2.params.runCallbacksOnInit, false, true);
    } else {
      swiper2.slideTo(swiper2.params.initialSlide, 0, swiper2.params.runCallbacksOnInit, false, true);
    }
    if (swiper2.params.loop) {
      swiper2.loopCreate();
    }
    swiper2.attachEvents();
    const lazyElements = [...swiper2.el.querySelectorAll('[loading="lazy"]')];
    if (swiper2.isElement) {
      lazyElements.push(...swiper2.hostEl.querySelectorAll('[loading="lazy"]'));
    }
    lazyElements.forEach((imageEl) => {
      if (imageEl.complete) {
        processLazyPreloader(swiper2, imageEl);
      } else {
        imageEl.addEventListener("load", (e2) => {
          processLazyPreloader(swiper2, e2.target);
        });
      }
    });
    preload(swiper2);
    swiper2.initialized = true;
    preload(swiper2);
    swiper2.emit("init");
    swiper2.emit("afterInit");
    return swiper2;
  }
  destroy(deleteInstance, cleanStyles) {
    if (deleteInstance === void 0) {
      deleteInstance = true;
    }
    if (cleanStyles === void 0) {
      cleanStyles = true;
    }
    const swiper2 = this;
    const {
      params,
      el: el2,
      wrapperEl,
      slides
    } = swiper2;
    if (typeof swiper2.params === "undefined" || swiper2.destroyed) {
      return null;
    }
    swiper2.emit("beforeDestroy");
    swiper2.initialized = false;
    swiper2.detachEvents();
    if (params.loop) {
      swiper2.loopDestroy();
    }
    if (cleanStyles) {
      swiper2.removeClasses();
      el2.removeAttribute("style");
      wrapperEl.removeAttribute("style");
      if (slides && slides.length) {
        slides.forEach((slideEl) => {
          slideEl.classList.remove(params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
          slideEl.removeAttribute("style");
          slideEl.removeAttribute("data-swiper-slide-index");
        });
      }
    }
    swiper2.emit("destroy");
    Object.keys(swiper2.eventsListeners).forEach((eventName) => {
      swiper2.off(eventName);
    });
    if (deleteInstance !== false) {
      swiper2.el.swiper = null;
      deleteProps(swiper2);
    }
    swiper2.destroyed = true;
    return null;
  }
  static extendDefaults(newDefaults) {
    extend$2(extendedDefaults, newDefaults);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults$2;
  }
  static installModule(mod) {
    if (!Swiper.prototype.__modules__)
      Swiper.prototype.__modules__ = [];
    const modules = Swiper.prototype.__modules__;
    if (typeof mod === "function" && modules.indexOf(mod) < 0) {
      modules.push(mod);
    }
  }
  static use(module) {
    if (Array.isArray(module)) {
      module.forEach((m2) => Swiper.installModule(m2));
      return Swiper;
    }
    Swiper.installModule(module);
    return Swiper;
  }
};
Object.keys(prototypes).forEach((prototypeGroup) => {
  Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
    Swiper$1.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
  });
});
Swiper$1.use([Resize, Observer]);
const paramsList = [
  "eventsPrefix",
  "injectStyles",
  "injectStylesUrls",
  "modules",
  "init",
  "_direction",
  "oneWayMovement",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "breakpointsBase",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_loop",
  "loopedSlides",
  "loopPreventsSliding",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideActiveClass",
  "slideVisibleClass",
  "slideNextClass",
  "slidePrevClass",
  "wrapperClass",
  "lazyPreloaderClass",
  "lazyPreloadPrevNext",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  // modules
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom",
  "control"
];
function isObject$1(o2) {
  return typeof o2 === "object" && o2 !== null && o2.constructor && Object.prototype.toString.call(o2).slice(8, -1) === "Object" && !o2.__swiper__;
}
function extend$1(target, src) {
  const noExtend = ["__proto__", "constructor", "prototype"];
  Object.keys(src).filter((key) => noExtend.indexOf(key) < 0).forEach((key) => {
    if (typeof target[key] === "undefined")
      target[key] = src[key];
    else if (isObject$1(src[key]) && isObject$1(target[key]) && Object.keys(src[key]).length > 0) {
      if (src[key].__swiper__)
        target[key] = src[key];
      else
        extend$1(target[key], src[key]);
    } else {
      target[key] = src[key];
    }
  });
}
function needsNavigation(params) {
  if (params === void 0) {
    params = {};
  }
  return params.navigation && typeof params.navigation.nextEl === "undefined" && typeof params.navigation.prevEl === "undefined";
}
function needsPagination(params) {
  if (params === void 0) {
    params = {};
  }
  return params.pagination && typeof params.pagination.el === "undefined";
}
function needsScrollbar(params) {
  if (params === void 0) {
    params = {};
  }
  return params.scrollbar && typeof params.scrollbar.el === "undefined";
}
function uniqueClasses(classNames) {
  if (classNames === void 0) {
    classNames = "";
  }
  const classes2 = classNames.split(" ").map((c2) => c2.trim()).filter((c2) => !!c2);
  const unique = [];
  classes2.forEach((c2) => {
    if (unique.indexOf(c2) < 0)
      unique.push(c2);
  });
  return unique.join(" ");
}
function wrapperClass(className) {
  if (className === void 0) {
    className = "";
  }
  if (!className)
    return "swiper-wrapper";
  if (!className.includes("swiper-wrapper"))
    return `swiper-wrapper ${className}`;
  return className;
}
function updateSwiper(_ref) {
  let {
    swiper: swiper2,
    slides,
    passedParams,
    changedParams,
    nextEl,
    prevEl,
    scrollbarEl,
    paginationEl
  } = _ref;
  const updateParams = changedParams.filter((key) => key !== "children" && key !== "direction" && key !== "wrapperClass");
  const {
    params: currentParams,
    pagination,
    navigation,
    scrollbar,
    virtual,
    thumbs
  } = swiper2;
  let needThumbsInit;
  let needControllerInit;
  let needPaginationInit;
  let needScrollbarInit;
  let needNavigationInit;
  let loopNeedDestroy;
  let loopNeedEnable;
  let loopNeedReloop;
  if (changedParams.includes("thumbs") && passedParams.thumbs && passedParams.thumbs.swiper && currentParams.thumbs && !currentParams.thumbs.swiper) {
    needThumbsInit = true;
  }
  if (changedParams.includes("controller") && passedParams.controller && passedParams.controller.control && currentParams.controller && !currentParams.controller.control) {
    needControllerInit = true;
  }
  if (changedParams.includes("pagination") && passedParams.pagination && (passedParams.pagination.el || paginationEl) && (currentParams.pagination || currentParams.pagination === false) && pagination && !pagination.el) {
    needPaginationInit = true;
  }
  if (changedParams.includes("scrollbar") && passedParams.scrollbar && (passedParams.scrollbar.el || scrollbarEl) && (currentParams.scrollbar || currentParams.scrollbar === false) && scrollbar && !scrollbar.el) {
    needScrollbarInit = true;
  }
  if (changedParams.includes("navigation") && passedParams.navigation && (passedParams.navigation.prevEl || prevEl) && (passedParams.navigation.nextEl || nextEl) && (currentParams.navigation || currentParams.navigation === false) && navigation && !navigation.prevEl && !navigation.nextEl) {
    needNavigationInit = true;
  }
  const destroyModule = (mod) => {
    if (!swiper2[mod])
      return;
    swiper2[mod].destroy();
    if (mod === "navigation") {
      if (swiper2.isElement) {
        swiper2[mod].prevEl.remove();
        swiper2[mod].nextEl.remove();
      }
      currentParams[mod].prevEl = void 0;
      currentParams[mod].nextEl = void 0;
      swiper2[mod].prevEl = void 0;
      swiper2[mod].nextEl = void 0;
    } else {
      if (swiper2.isElement) {
        swiper2[mod].el.remove();
      }
      currentParams[mod].el = void 0;
      swiper2[mod].el = void 0;
    }
  };
  if (changedParams.includes("loop") && swiper2.isElement) {
    if (currentParams.loop && !passedParams.loop) {
      loopNeedDestroy = true;
    } else if (!currentParams.loop && passedParams.loop) {
      loopNeedEnable = true;
    } else {
      loopNeedReloop = true;
    }
  }
  updateParams.forEach((key) => {
    if (isObject$1(currentParams[key]) && isObject$1(passedParams[key])) {
      extend$1(currentParams[key], passedParams[key]);
      if ((key === "navigation" || key === "pagination" || key === "scrollbar") && "enabled" in passedParams[key] && !passedParams[key].enabled) {
        destroyModule(key);
      }
    } else {
      const newValue = passedParams[key];
      if ((newValue === true || newValue === false) && (key === "navigation" || key === "pagination" || key === "scrollbar")) {
        if (newValue === false) {
          destroyModule(key);
        }
      } else {
        currentParams[key] = passedParams[key];
      }
    }
  });
  if (updateParams.includes("controller") && !needControllerInit && swiper2.controller && swiper2.controller.control && currentParams.controller && currentParams.controller.control) {
    swiper2.controller.control = currentParams.controller.control;
  }
  if (changedParams.includes("children") && slides && virtual && currentParams.virtual.enabled) {
    virtual.slides = slides;
    virtual.update(true);
  }
  if (changedParams.includes("children") && slides && currentParams.loop) {
    loopNeedReloop = true;
  }
  if (needThumbsInit) {
    const initialized = thumbs.init();
    if (initialized)
      thumbs.update(true);
  }
  if (needControllerInit) {
    swiper2.controller.control = currentParams.controller.control;
  }
  if (needPaginationInit) {
    if (swiper2.isElement && (!paginationEl || typeof paginationEl === "string")) {
      paginationEl = document.createElement("div");
      paginationEl.classList.add("swiper-pagination");
      paginationEl.part.add("pagination");
      swiper2.el.appendChild(paginationEl);
    }
    if (paginationEl)
      currentParams.pagination.el = paginationEl;
    pagination.init();
    pagination.render();
    pagination.update();
  }
  if (needScrollbarInit) {
    if (swiper2.isElement && (!scrollbarEl || typeof scrollbarEl === "string")) {
      scrollbarEl = document.createElement("div");
      scrollbarEl.classList.add("swiper-scrollbar");
      scrollbarEl.part.add("scrollbar");
      swiper2.el.appendChild(scrollbarEl);
    }
    if (scrollbarEl)
      currentParams.scrollbar.el = scrollbarEl;
    scrollbar.init();
    scrollbar.updateSize();
    scrollbar.setTranslate();
  }
  if (needNavigationInit) {
    if (swiper2.isElement) {
      if (!nextEl || typeof nextEl === "string") {
        nextEl = document.createElement("div");
        nextEl.classList.add("swiper-button-next");
        nextEl.innerHTML = swiper2.hostEl.constructor.nextButtonSvg;
        nextEl.part.add("button-next");
        swiper2.el.appendChild(nextEl);
      }
      if (!prevEl || typeof prevEl === "string") {
        prevEl = document.createElement("div");
        prevEl.classList.add("swiper-button-prev");
        prevEl.innerHTML = swiper2.hostEl.constructor.prevButtonSvg;
        prevEl.part.add("button-prev");
        swiper2.el.appendChild(prevEl);
      }
    }
    if (nextEl)
      currentParams.navigation.nextEl = nextEl;
    if (prevEl)
      currentParams.navigation.prevEl = prevEl;
    navigation.init();
    navigation.update();
  }
  if (changedParams.includes("allowSlideNext")) {
    swiper2.allowSlideNext = passedParams.allowSlideNext;
  }
  if (changedParams.includes("allowSlidePrev")) {
    swiper2.allowSlidePrev = passedParams.allowSlidePrev;
  }
  if (changedParams.includes("direction")) {
    swiper2.changeDirection(passedParams.direction, false);
  }
  if (loopNeedDestroy || loopNeedReloop) {
    swiper2.loopDestroy();
  }
  if (loopNeedEnable || loopNeedReloop) {
    swiper2.loopCreate();
  }
  swiper2.update();
}
function getParams(obj, splitEvents) {
  if (obj === void 0) {
    obj = {};
  }
  if (splitEvents === void 0) {
    splitEvents = true;
  }
  const params = {
    on: {}
  };
  const events2 = {};
  const passedParams = {};
  extend$1(params, defaults$2);
  params._emitClasses = true;
  params.init = false;
  const rest = {};
  const allowedParams = paramsList.map((key) => key.replace(/_/, ""));
  const plainObj = Object.assign({}, obj);
  Object.keys(plainObj).forEach((key) => {
    if (typeof obj[key] === "undefined")
      return;
    if (allowedParams.indexOf(key) >= 0) {
      if (isObject$1(obj[key])) {
        params[key] = {};
        passedParams[key] = {};
        extend$1(params[key], obj[key]);
        extend$1(passedParams[key], obj[key]);
      } else {
        params[key] = obj[key];
        passedParams[key] = obj[key];
      }
    } else if (key.search(/on[A-Z]/) === 0 && typeof obj[key] === "function") {
      if (splitEvents) {
        events2[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      } else {
        params.on[`${key[2].toLowerCase()}${key.substr(3)}`] = obj[key];
      }
    } else {
      rest[key] = obj[key];
    }
  });
  ["navigation", "pagination", "scrollbar"].forEach((key) => {
    if (params[key] === true)
      params[key] = {};
    if (params[key] === false)
      delete params[key];
  });
  return {
    params,
    passedParams,
    rest,
    events: events2
  };
}
function mountSwiper(_ref, swiperParams) {
  let {
    el: el2,
    nextEl,
    prevEl,
    paginationEl,
    scrollbarEl,
    swiper: swiper2
  } = _ref;
  if (needsNavigation(swiperParams) && nextEl && prevEl) {
    swiper2.params.navigation.nextEl = nextEl;
    swiper2.originalParams.navigation.nextEl = nextEl;
    swiper2.params.navigation.prevEl = prevEl;
    swiper2.originalParams.navigation.prevEl = prevEl;
  }
  if (needsPagination(swiperParams) && paginationEl) {
    swiper2.params.pagination.el = paginationEl;
    swiper2.originalParams.pagination.el = paginationEl;
  }
  if (needsScrollbar(swiperParams) && scrollbarEl) {
    swiper2.params.scrollbar.el = scrollbarEl;
    swiper2.originalParams.scrollbar.el = scrollbarEl;
  }
  swiper2.init(el2);
}
function getChangedParams(swiperParams, oldParams, children, oldChildren, getKey) {
  const keys = [];
  if (!oldParams)
    return keys;
  const addKey = (key) => {
    if (keys.indexOf(key) < 0)
      keys.push(key);
  };
  if (children && oldChildren) {
    const oldChildrenKeys = oldChildren.map(getKey);
    const childrenKeys = children.map(getKey);
    if (oldChildrenKeys.join("") !== childrenKeys.join(""))
      addKey("children");
    if (oldChildren.length !== children.length)
      addKey("children");
  }
  const watchParams = paramsList.filter((key) => key[0] === "_").map((key) => key.replace(/_/, ""));
  watchParams.forEach((key) => {
    if (key in swiperParams && key in oldParams) {
      if (isObject$1(swiperParams[key]) && isObject$1(oldParams[key])) {
        const newKeys = Object.keys(swiperParams[key]);
        const oldKeys = Object.keys(oldParams[key]);
        if (newKeys.length !== oldKeys.length) {
          addKey(key);
        } else {
          newKeys.forEach((newKey) => {
            if (swiperParams[key][newKey] !== oldParams[key][newKey]) {
              addKey(key);
            }
          });
          oldKeys.forEach((oldKey) => {
            if (swiperParams[key][oldKey] !== oldParams[key][oldKey])
              addKey(key);
          });
        }
      } else if (swiperParams[key] !== oldParams[key]) {
        addKey(key);
      }
    }
  });
  return keys;
}
const updateOnVirtualData = (swiper2) => {
  if (!swiper2 || swiper2.destroyed || !swiper2.params.virtual || swiper2.params.virtual && !swiper2.params.virtual.enabled)
    return;
  swiper2.updateSlides();
  swiper2.updateProgress();
  swiper2.updateSlidesClasses();
  if (swiper2.parallax && swiper2.params.parallax && swiper2.params.parallax.enabled) {
    swiper2.parallax.setTranslate();
  }
};
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function isChildSwiperSlide(child) {
  return child.type && child.type.displayName && child.type.displayName.includes("SwiperSlide");
}
function processChildren(c2) {
  const slides = [];
  React.Children.toArray(c2).forEach((child) => {
    if (isChildSwiperSlide(child)) {
      slides.push(child);
    } else if (child.props && child.props.children) {
      processChildren(child.props.children).forEach((slide2) => slides.push(slide2));
    }
  });
  return slides;
}
function getChildren(c2) {
  const slides = [];
  const slots = {
    "container-start": [],
    "container-end": [],
    "wrapper-start": [],
    "wrapper-end": []
  };
  React.Children.toArray(c2).forEach((child) => {
    if (isChildSwiperSlide(child)) {
      slides.push(child);
    } else if (child.props && child.props.slot && slots[child.props.slot]) {
      slots[child.props.slot].push(child);
    } else if (child.props && child.props.children) {
      const foundSlides = processChildren(child.props.children);
      if (foundSlides.length > 0) {
        foundSlides.forEach((slide2) => slides.push(slide2));
      } else {
        slots["container-end"].push(child);
      }
    } else {
      slots["container-end"].push(child);
    }
  });
  return {
    slides,
    slots
  };
}
function renderVirtual(swiper2, slides, virtualData) {
  if (!virtualData)
    return null;
  const getSlideIndex = (index) => {
    let slideIndex = index;
    if (index < 0) {
      slideIndex = slides.length + index;
    } else if (slideIndex >= slides.length) {
      slideIndex = slideIndex - slides.length;
    }
    return slideIndex;
  };
  const style2 = swiper2.isHorizontal() ? {
    [swiper2.rtlTranslate ? "right" : "left"]: `${virtualData.offset}px`
  } : {
    top: `${virtualData.offset}px`
  };
  const {
    from: from2,
    to: to2
  } = virtualData;
  const loopFrom = swiper2.params.loop ? -slides.length : 0;
  const loopTo = swiper2.params.loop ? slides.length * 2 : slides.length;
  const slidesToRender = [];
  for (let i2 = loopFrom; i2 < loopTo; i2 += 1) {
    if (i2 >= from2 && i2 <= to2) {
      slidesToRender.push(slides[getSlideIndex(i2)]);
    }
  }
  return slidesToRender.map((child, index) => {
    return /* @__PURE__ */ React.cloneElement(child, {
      swiper: swiper2,
      style: style2,
      key: `slide-${index}`
    });
  });
}
function useIsomorphicLayoutEffect(callback, deps) {
  if (typeof window === "undefined")
    return reactExports.useEffect(callback, deps);
  return reactExports.useLayoutEffect(callback, deps);
}
const SwiperSlideContext = /* @__PURE__ */ reactExports.createContext(null);
const SwiperContext = /* @__PURE__ */ reactExports.createContext(null);
const Swiper2 = /* @__PURE__ */ reactExports.forwardRef(function(_temp, externalElRef) {
  let {
    className,
    tag: Tag = "div",
    wrapperTag: WrapperTag = "div",
    children,
    onSwiper,
    ...rest
  } = _temp === void 0 ? {} : _temp;
  let eventsAssigned = false;
  const [containerClasses, setContainerClasses] = reactExports.useState("swiper");
  const [virtualData, setVirtualData] = reactExports.useState(null);
  const [breakpointChanged, setBreakpointChanged] = reactExports.useState(false);
  const initializedRef = reactExports.useRef(false);
  const swiperElRef = reactExports.useRef(null);
  const swiperRef = reactExports.useRef(null);
  const oldPassedParamsRef = reactExports.useRef(null);
  const oldSlides = reactExports.useRef(null);
  const nextElRef = reactExports.useRef(null);
  const prevElRef = reactExports.useRef(null);
  const paginationElRef = reactExports.useRef(null);
  const scrollbarElRef = reactExports.useRef(null);
  const {
    params: swiperParams,
    passedParams,
    rest: restProps,
    events: events2
  } = getParams(rest);
  const {
    slides,
    slots
  } = getChildren(children);
  const onBeforeBreakpoint = () => {
    setBreakpointChanged(!breakpointChanged);
  };
  Object.assign(swiperParams.on, {
    _containerClasses(swiper2, classes2) {
      setContainerClasses(classes2);
    }
  });
  const initSwiper = () => {
    Object.assign(swiperParams.on, events2);
    eventsAssigned = true;
    const passParams = {
      ...swiperParams
    };
    delete passParams.wrapperClass;
    swiperRef.current = new Swiper$1(passParams);
    if (swiperRef.current.virtual && swiperRef.current.params.virtual.enabled) {
      swiperRef.current.virtual.slides = slides;
      const extendWith = {
        cache: false,
        slides,
        renderExternal: setVirtualData,
        renderExternalUpdate: false
      };
      extend$1(swiperRef.current.params.virtual, extendWith);
      extend$1(swiperRef.current.originalParams.virtual, extendWith);
    }
  };
  if (!swiperElRef.current) {
    initSwiper();
  }
  if (swiperRef.current) {
    swiperRef.current.on("_beforeBreakpoint", onBeforeBreakpoint);
  }
  const attachEvents2 = () => {
    if (eventsAssigned || !events2 || !swiperRef.current)
      return;
    Object.keys(events2).forEach((eventName) => {
      swiperRef.current.on(eventName, events2[eventName]);
    });
  };
  const detachEvents2 = () => {
    if (!events2 || !swiperRef.current)
      return;
    Object.keys(events2).forEach((eventName) => {
      swiperRef.current.off(eventName, events2[eventName]);
    });
  };
  reactExports.useEffect(() => {
    return () => {
      if (swiperRef.current)
        swiperRef.current.off("_beforeBreakpoint", onBeforeBreakpoint);
    };
  });
  reactExports.useEffect(() => {
    if (!initializedRef.current && swiperRef.current) {
      swiperRef.current.emitSlidesClasses();
      initializedRef.current = true;
    }
  });
  useIsomorphicLayoutEffect(() => {
    if (externalElRef) {
      externalElRef.current = swiperElRef.current;
    }
    if (!swiperElRef.current)
      return;
    if (swiperRef.current.destroyed) {
      initSwiper();
    }
    mountSwiper({
      el: swiperElRef.current,
      nextEl: nextElRef.current,
      prevEl: prevElRef.current,
      paginationEl: paginationElRef.current,
      scrollbarEl: scrollbarElRef.current,
      swiper: swiperRef.current
    }, swiperParams);
    if (onSwiper)
      onSwiper(swiperRef.current);
    return () => {
      if (swiperRef.current && !swiperRef.current.destroyed) {
        swiperRef.current.destroy(true, false);
      }
    };
  }, []);
  useIsomorphicLayoutEffect(() => {
    attachEvents2();
    const changedParams = getChangedParams(passedParams, oldPassedParamsRef.current, slides, oldSlides.current, (c2) => c2.key);
    oldPassedParamsRef.current = passedParams;
    oldSlides.current = slides;
    if (changedParams.length && swiperRef.current && !swiperRef.current.destroyed) {
      updateSwiper({
        swiper: swiperRef.current,
        slides,
        passedParams,
        changedParams,
        nextEl: nextElRef.current,
        prevEl: prevElRef.current,
        scrollbarEl: scrollbarElRef.current,
        paginationEl: paginationElRef.current
      });
    }
    return () => {
      detachEvents2();
    };
  });
  useIsomorphicLayoutEffect(() => {
    updateOnVirtualData(swiperRef.current);
  }, [virtualData]);
  function renderSlides() {
    if (swiperParams.virtual) {
      return renderVirtual(swiperRef.current, slides, virtualData);
    }
    return slides.map((child, index) => {
      return /* @__PURE__ */ React.cloneElement(child, {
        swiper: swiperRef.current,
        swiperSlideIndex: index
      });
    });
  }
  return /* @__PURE__ */ React.createElement(Tag, _extends({
    ref: swiperElRef,
    className: uniqueClasses(`${containerClasses}${className ? ` ${className}` : ""}`)
  }, restProps), /* @__PURE__ */ React.createElement(SwiperContext.Provider, {
    value: swiperRef.current
  }, slots["container-start"], /* @__PURE__ */ React.createElement(WrapperTag, {
    className: wrapperClass(swiperParams.wrapperClass)
  }, slots["wrapper-start"], renderSlides(), slots["wrapper-end"]), needsNavigation(swiperParams) && /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("div", {
    ref: prevElRef,
    className: "swiper-button-prev"
  }), /* @__PURE__ */ React.createElement("div", {
    ref: nextElRef,
    className: "swiper-button-next"
  })), needsScrollbar(swiperParams) && /* @__PURE__ */ React.createElement("div", {
    ref: scrollbarElRef,
    className: "swiper-scrollbar"
  }), needsPagination(swiperParams) && /* @__PURE__ */ React.createElement("div", {
    ref: paginationElRef,
    className: "swiper-pagination"
  }), slots["container-end"]));
});
Swiper2.displayName = "Swiper";
const SwiperSlide = /* @__PURE__ */ reactExports.forwardRef(function(_temp, externalRef) {
  let {
    tag: Tag = "div",
    children,
    className = "",
    swiper: swiper2,
    zoom,
    lazy,
    virtualIndex,
    swiperSlideIndex,
    ...rest
  } = _temp === void 0 ? {} : _temp;
  const slideElRef = reactExports.useRef(null);
  const [slideClasses, setSlideClasses] = reactExports.useState("swiper-slide");
  const [lazyLoaded, setLazyLoaded] = reactExports.useState(false);
  function updateClasses(_s, el2, classNames) {
    if (el2 === slideElRef.current) {
      setSlideClasses(classNames);
    }
  }
  useIsomorphicLayoutEffect(() => {
    if (typeof swiperSlideIndex !== "undefined") {
      slideElRef.current.swiperSlideIndex = swiperSlideIndex;
    }
    if (externalRef) {
      externalRef.current = slideElRef.current;
    }
    if (!slideElRef.current || !swiper2) {
      return;
    }
    if (swiper2.destroyed) {
      if (slideClasses !== "swiper-slide") {
        setSlideClasses("swiper-slide");
      }
      return;
    }
    swiper2.on("_slideClass", updateClasses);
    return () => {
      if (!swiper2)
        return;
      swiper2.off("_slideClass", updateClasses);
    };
  });
  useIsomorphicLayoutEffect(() => {
    if (swiper2 && slideElRef.current && !swiper2.destroyed) {
      setSlideClasses(swiper2.getSlideClasses(slideElRef.current));
    }
  }, [swiper2]);
  const slideData = {
    isActive: slideClasses.indexOf("swiper-slide-active") >= 0,
    isVisible: slideClasses.indexOf("swiper-slide-visible") >= 0,
    isPrev: slideClasses.indexOf("swiper-slide-prev") >= 0,
    isNext: slideClasses.indexOf("swiper-slide-next") >= 0
  };
  const renderChildren = () => {
    return typeof children === "function" ? children(slideData) : children;
  };
  const onLoad2 = () => {
    setLazyLoaded(true);
  };
  return /* @__PURE__ */ React.createElement(Tag, _extends({
    ref: slideElRef,
    className: uniqueClasses(`${slideClasses}${className ? ` ${className}` : ""}`),
    "data-swiper-slide-index": virtualIndex,
    onLoad: onLoad2
  }, rest), zoom && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, /* @__PURE__ */ React.createElement("div", {
    className: "swiper-zoom-container",
    "data-swiper-zoom": typeof zoom === "number" ? zoom : void 0
  }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ React.createElement("div", {
    className: "swiper-lazy-preloader"
  }))), !zoom && /* @__PURE__ */ React.createElement(SwiperSlideContext.Provider, {
    value: slideData
  }, renderChildren(), lazy && !lazyLoaded && /* @__PURE__ */ React.createElement("div", {
    className: "swiper-lazy-preloader"
  })));
});
SwiperSlide.displayName = "SwiperSlide";
function Autoplay(_ref) {
  let {
    swiper: swiper2,
    extendParams,
    on: on2,
    emit,
    params
  } = _ref;
  swiper2.autoplay = {
    running: false,
    paused: false,
    timeLeft: 0
  };
  extendParams({
    autoplay: {
      enabled: false,
      delay: 3e3,
      waitForTransition: true,
      disableOnInteraction: true,
      stopOnLastSlide: false,
      reverseDirection: false,
      pauseOnMouseEnter: false
    }
  });
  let timeout;
  let raf;
  let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
  let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
  let autoplayTimeLeft;
  let autoplayStartTime = (/* @__PURE__ */ new Date()).getTime;
  let wasPaused;
  let isTouched;
  let pausedByTouch;
  let touchStartTimeout;
  let slideChanged;
  let pausedByInteraction;
  function onTransitionEnd(e2) {
    if (!swiper2 || swiper2.destroyed || !swiper2.wrapperEl)
      return;
    if (e2.target !== swiper2.wrapperEl)
      return;
    swiper2.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
    resume();
  }
  const calcTimeLeft = () => {
    if (swiper2.destroyed || !swiper2.autoplay.running)
      return;
    if (swiper2.autoplay.paused) {
      wasPaused = true;
    } else if (wasPaused) {
      autoplayDelayCurrent = autoplayTimeLeft;
      wasPaused = false;
    }
    const timeLeft = swiper2.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - (/* @__PURE__ */ new Date()).getTime();
    swiper2.autoplay.timeLeft = timeLeft;
    emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
    raf = requestAnimationFrame(() => {
      calcTimeLeft();
    });
  };
  const getSlideDelay = () => {
    let activeSlideEl;
    if (swiper2.virtual && swiper2.params.virtual.enabled) {
      activeSlideEl = swiper2.slides.filter((slideEl) => slideEl.classList.contains("swiper-slide-active"))[0];
    } else {
      activeSlideEl = swiper2.slides[swiper2.activeIndex];
    }
    if (!activeSlideEl)
      return void 0;
    const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
    return currentSlideDelay;
  };
  const run = (delayForce) => {
    if (swiper2.destroyed || !swiper2.autoplay.running)
      return;
    cancelAnimationFrame(raf);
    calcTimeLeft();
    let delay = typeof delayForce === "undefined" ? swiper2.params.autoplay.delay : delayForce;
    autoplayDelayTotal = swiper2.params.autoplay.delay;
    autoplayDelayCurrent = swiper2.params.autoplay.delay;
    const currentSlideDelay = getSlideDelay();
    if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
      delay = currentSlideDelay;
      autoplayDelayTotal = currentSlideDelay;
      autoplayDelayCurrent = currentSlideDelay;
    }
    autoplayTimeLeft = delay;
    const speed = swiper2.params.speed;
    const proceed = () => {
      if (!swiper2 || swiper2.destroyed)
        return;
      if (swiper2.params.autoplay.reverseDirection) {
        if (!swiper2.isBeginning || swiper2.params.loop || swiper2.params.rewind) {
          swiper2.slidePrev(speed, true, true);
          emit("autoplay");
        } else if (!swiper2.params.autoplay.stopOnLastSlide) {
          swiper2.slideTo(swiper2.slides.length - 1, speed, true, true);
          emit("autoplay");
        }
      } else {
        if (!swiper2.isEnd || swiper2.params.loop || swiper2.params.rewind) {
          swiper2.slideNext(speed, true, true);
          emit("autoplay");
        } else if (!swiper2.params.autoplay.stopOnLastSlide) {
          swiper2.slideTo(0, speed, true, true);
          emit("autoplay");
        }
      }
      if (swiper2.params.cssMode) {
        autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
        requestAnimationFrame(() => {
          run();
        });
      }
    };
    if (delay > 0) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        proceed();
      }, delay);
    } else {
      requestAnimationFrame(() => {
        proceed();
      });
    }
    return delay;
  };
  const start = () => {
    swiper2.autoplay.running = true;
    run();
    emit("autoplayStart");
  };
  const stop = () => {
    swiper2.autoplay.running = false;
    clearTimeout(timeout);
    cancelAnimationFrame(raf);
    emit("autoplayStop");
  };
  const pause = (internal, reset) => {
    if (swiper2.destroyed || !swiper2.autoplay.running)
      return;
    clearTimeout(timeout);
    if (!internal) {
      pausedByInteraction = true;
    }
    const proceed = () => {
      emit("autoplayPause");
      if (swiper2.params.autoplay.waitForTransition) {
        swiper2.wrapperEl.addEventListener("transitionend", onTransitionEnd);
      } else {
        resume();
      }
    };
    swiper2.autoplay.paused = true;
    if (reset) {
      if (slideChanged) {
        autoplayTimeLeft = swiper2.params.autoplay.delay;
      }
      slideChanged = false;
      proceed();
      return;
    }
    const delay = autoplayTimeLeft || swiper2.params.autoplay.delay;
    autoplayTimeLeft = delay - ((/* @__PURE__ */ new Date()).getTime() - autoplayStartTime);
    if (swiper2.isEnd && autoplayTimeLeft < 0 && !swiper2.params.loop)
      return;
    if (autoplayTimeLeft < 0)
      autoplayTimeLeft = 0;
    proceed();
  };
  const resume = () => {
    if (swiper2.isEnd && autoplayTimeLeft < 0 && !swiper2.params.loop || swiper2.destroyed || !swiper2.autoplay.running)
      return;
    autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
    if (pausedByInteraction) {
      pausedByInteraction = false;
      run(autoplayTimeLeft);
    } else {
      run();
    }
    swiper2.autoplay.paused = false;
    emit("autoplayResume");
  };
  const onVisibilityChange = () => {
    if (swiper2.destroyed || !swiper2.autoplay.running)
      return;
    const document2 = getDocument();
    if (document2.visibilityState === "hidden") {
      pausedByInteraction = true;
      pause(true);
    }
    if (document2.visibilityState === "visible") {
      resume();
    }
  };
  const onPointerEnter = (e2) => {
    if (e2.pointerType !== "mouse")
      return;
    pausedByInteraction = true;
    if (swiper2.animating || swiper2.autoplay.paused)
      return;
    pause(true);
  };
  const onPointerLeave = (e2) => {
    if (e2.pointerType !== "mouse")
      return;
    if (swiper2.autoplay.paused) {
      resume();
    }
  };
  const attachMouseEvents = () => {
    if (swiper2.params.autoplay.pauseOnMouseEnter) {
      swiper2.el.addEventListener("pointerenter", onPointerEnter);
      swiper2.el.addEventListener("pointerleave", onPointerLeave);
    }
  };
  const detachMouseEvents = () => {
    swiper2.el.removeEventListener("pointerenter", onPointerEnter);
    swiper2.el.removeEventListener("pointerleave", onPointerLeave);
  };
  const attachDocumentEvents = () => {
    const document2 = getDocument();
    document2.addEventListener("visibilitychange", onVisibilityChange);
  };
  const detachDocumentEvents = () => {
    const document2 = getDocument();
    document2.removeEventListener("visibilitychange", onVisibilityChange);
  };
  on2("init", () => {
    if (swiper2.params.autoplay.enabled) {
      attachMouseEvents();
      attachDocumentEvents();
      autoplayStartTime = (/* @__PURE__ */ new Date()).getTime();
      start();
    }
  });
  on2("destroy", () => {
    detachMouseEvents();
    detachDocumentEvents();
    if (swiper2.autoplay.running) {
      stop();
    }
  });
  on2("beforeTransitionStart", (_s, speed, internal) => {
    if (swiper2.destroyed || !swiper2.autoplay.running)
      return;
    if (internal || !swiper2.params.autoplay.disableOnInteraction) {
      pause(true, true);
    } else {
      stop();
    }
  });
  on2("sliderFirstMove", () => {
    if (swiper2.destroyed || !swiper2.autoplay.running)
      return;
    if (swiper2.params.autoplay.disableOnInteraction) {
      stop();
      return;
    }
    isTouched = true;
    pausedByTouch = false;
    pausedByInteraction = false;
    touchStartTimeout = setTimeout(() => {
      pausedByInteraction = true;
      pausedByTouch = true;
      pause(true);
    }, 200);
  });
  on2("touchEnd", () => {
    if (swiper2.destroyed || !swiper2.autoplay.running || !isTouched)
      return;
    clearTimeout(touchStartTimeout);
    clearTimeout(timeout);
    if (swiper2.params.autoplay.disableOnInteraction) {
      pausedByTouch = false;
      isTouched = false;
      return;
    }
    if (pausedByTouch && swiper2.params.cssMode)
      resume();
    pausedByTouch = false;
    isTouched = false;
  });
  on2("slideChange", () => {
    if (swiper2.destroyed || !swiper2.autoplay.running)
      return;
    slideChanged = true;
  });
  Object.assign(swiper2.autoplay, {
    start,
    stop,
    pause,
    resume
  });
}
const swiper = "";
const Container$h = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
  padding: 25px;
  opacity: ${(props) => props.$isVisible ? 1 : 0.5};
  background-color: ${(props) => props.$isDeleted ? "rgba(224, 54, 56, .1)" : props.theme.colors.realWhite};
  transition: opacity 0.2s ease-in-out;
  border-radius: ${(props) => props.theme.utils.br};
  &:hover {
    opacity: 1;
  }
`;
const Head = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
`;
const CompetitionPagination = st$1.p`
  font-size: 15px;
  font-weight: 500;
  line-height: 130%;
  color: ${(props) => props.theme.colors.realBlack};
`;
const CompetitionTitle = st$1.h4`
  margin-bottom: 20px;
  font-size: 25px;
  font-weight: 700;
  line-height: 145.5%;
  color: ${(props) => props.theme.colors.realBlack};
`;
const CompetitionDescr = st$1.p`
  font-size: 18px;
  font-weight: 400;
  line-height: 170%;
  color: ${(props) => props.theme.colors.realBlack};
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
  overflow: hidden;
  text-overflow: ellipsis;
`;
const MoreBtn$1 = st$1(DefaultBtn)`
  width: fit-content;
  margin: auto auto 0;
  padding: 0 40px;
  border-radius: 22.689px;
`;
function Competition$1({ data, totalCount, index }) {
  const navigate = useNavigate();
  const [deleteCompetition] = useDeleteCompetitionMutation();
  const [restoreCompetition] = useRestoreCompetitionMutation();
  const [updateCompetition] = useUpdateCompetitionMutation();
  const [competitionDescr, setCompetitionDescr] = reactExports.useState("");
  const { setLoaderActive, setUpdatingCompetitionData } = useActions();
  const [isDeleted, setDeleted] = reactExports.useState(!!(data == null ? void 0 : data.is_deleted));
  const handleAddCompetition = () => {
    setUpdatingCompetitionData(null);
    navigate("/news/competition/create-competition");
  };
  const handleDeleteCompetition = () => {
    deleteCompetition({ id: data.id }).then(() => {
      setDeleted(true);
    });
  };
  const handleRestoreCompetition = () => {
    restoreCompetition({ id: data.id }).then(() => {
      setDeleted(false);
    });
  };
  const handleEditCompetition = () => {
    navigate(`/news/competition/edit-competition/${data.id}`);
  };
  const handleClickMore = (id2) => {
    navigate(`/news/competitions/${id2}`);
  };
  const handleVisibleCompetition = () => {
    updateCompetition({
      id: data.id,
      status: Number(data.status) === 0 ? 1 : 0
    }).then((res) => {
      if ("data" in res && !res.data.result) {
        alert("При редактировании конкурса произошла ошибка");
      }
    }).catch((err) => {
      console.error(err);
      alert("При редактировании конкурса произошла ошибка");
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container$h,
    {
      $isDeleted: isDeleted,
      $isVisible: Number(data.status) === 1,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Head, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CompetitionPagination, { children: [
            "Конкурс ",
            index + 1 + "/" + totalCount
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            AdminBtn,
            {
              popupName: "Конкурс",
              type: ADMIN_BTN_TYPES.edit,
              popupHandlers: {
                onAdd: handleAddCompetition,
                onDelete: isDeleted ? void 0 : handleDeleteCompetition,
                onRestore: isDeleted ? handleRestoreCompetition : void 0,
                onEdit: handleEditCompetition,
                onHide: Number(data.status) === 1 ? handleVisibleCompetition : void 0,
                onVisible: Number(data.status) === 0 ? handleVisibleCompetition : void 0
              }
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionTitle, { children: data == null ? void 0 : data.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionDescr, { children: competitionDescr }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(MoreBtn$1, { onClick: () => handleClickMore(data == null ? void 0 : data.id), children: "Подробнее" })
      ]
    }
  );
}
function CompetitionsSwiper({ data, isError, isFetching }) {
  var _a, _b, _c;
  const swiperRef = reactExports.useRef(null);
  const navigate = useNavigate();
  const handleCreateCompetition = () => {
    navigate(`/news/competition/create-competition`);
  };
  const handlePrev = reactExports.useCallback(() => {
    if (!swiperRef.current)
      return;
    swiperRef.current.swiper.slidePrev();
  }, []);
  const handleNext = reactExports.useCallback(() => {
    if (!swiperRef.current)
      return;
    swiperRef.current.swiper.slideNext();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$i, { children: [
    isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSmall, {}),
    isError && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
    data && !isError && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      !data.data.length && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(
        NoAvailable,
        {
          text: "Нет доступных конкурсов",
          onAdd: handleCreateCompetition,
          style: {
            position: "absolute",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%",
            zIndex: "2"
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Swiper2,
        {
          ref: swiperRef,
          style: { width: "100%", height: "100%" },
          autoplay: {
            delay: 4e3,
            disableOnInteraction: false,
            pauseOnMouseEnter: true
          },
          loop: true,
          modules: [Autoplay],
          children: ((_a = data == null ? void 0 : data.data) == null ? void 0 : _a.length) > 0 && ((_b = data == null ? void 0 : data.data) == null ? void 0 : _b.map((competitionData, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Competition$1,
            {
              data: competitionData,
              totalCount: data == null ? void 0 : data.count,
              index
            }
          ) }, competitionData == null ? void 0 : competitionData.id)))
        }
      ),
      ((_c = data == null ? void 0 : data.data) == null ? void 0 : _c.length) > 1 && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperPrevBtn, { onClick: handlePrev }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperNextBtn, { onClick: handleNext })
      ] })
    ] })
  ] });
}
const star = "/assets/star.svg";
const activeStar = "/assets/active-star.svg";
const moreIcon = "/assets/moreIcon.svg";
const Container$g = st$1(FlexContainer)`
  flex-direction: column;
  position: relative;
  width: 49.7%;
  height: 400px;
  padding: 25px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};

  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
  }
`;
const InfoBlock = st$1(FlexContainer)`
  flex-direction: column;
  gap: 23px;
  margin-bottom: 40px;
`;
const InfoRaw = st$1(FlexContainer)`
  align-items: center;
`;
const InfoRawTitle = st$1(Text$6)`
  min-width: fit-content;
  font-size: 20px;
`;
const InfoRawDots = st$1.div`
  width: 100%;
  height: 13px;
  margin: 0 2%;
  border-bottom: 5px dotted ${(props) => props.theme.colors.greyF1};
`;
const InfoRawValue = st$1(Text$6)`
  min-width: fit-content;
  font-size: 22px;
`;
const Footer$1 = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
`;
const YamaguchiLvl = st$1(FlexContainer)`
  flex-direction: column;
  max-width: 40%;
  row-gap: 8px;
`;
const YamaguchiLvlTitle = st$1(Text$6)`
  font-size: 15px;
`;
const StarsContainer = st$1(FlexContainer)`
  align-items: center;
`;
const Star = st$1(Icon$2)`
  width: 33px;
  height: 33px;
  background-image: url(${(props) => props.$active ? activeStar : star});
`;
const MoreLink = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  padding: 0 30px;
  border-radius: 22.689px;
  text-decoration: none !important;
`;
const MoreIcon = st$1(Icon$2)`
  margin-left: 13px;
  background-image: url(${moreIcon});
`;
const Container$f = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  border-radius: inherit;
  background-color: rgba(190, 190, 190, .5);
`;
const Text$3 = st$1.p`
  padding: 20px 25px;
  text-align: center;
  font-size: 29.051px;
  font-weight: 400;
  line-height: 100%;
  color: ${(props) => props.theme.colors.realWhite};
  background-color: ${(props) => props.theme.colors.mainBlue};
  transform: rotate(-9.76deg);
`;
function InDeveloping() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$f, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Text$3, { children: "В разработке" }) });
}
function ManagerInfo({
  percentage,
  salary,
  appSaleValue,
  zebrChair,
  yamaguchiLvl
}) {
  const stars = [1, 2, 3, 4, 5, 6];
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  const progressInfoStyles = {
    marginBottom: isMobile ? "10px" : "30px"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$g, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(InDeveloping, {}),
    percentage && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ProgressInfo,
      {
        percentage,
        text: "Твой план выполнен на",
        styles: progressInfoStyles
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoBlock, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoRaw, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawTitle, { children: "Зарплата" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawDots, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoRawValue, { children: [
          salary,
          " ₽"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoRaw, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawTitle, { children: "Через App" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawDots, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawValue, { children: appSaleValue })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(InfoRaw, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawTitle, { children: "Зебр по креслам" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawDots, {}),
        /* @__PURE__ */ jsxRuntimeExports.jsx(InfoRawValue, { children: zebrChair })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Footer$1, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(YamaguchiLvl, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(YamaguchiLvlTitle, { children: "Уровень Ямагучести!" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(StarsContainer, { children: stars.map((starNumber) => /* @__PURE__ */ jsxRuntimeExports.jsx(Star, { $active: starNumber > Number(yamaguchiLvl) ? false : true })) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        MoreLink,
        {
          as: "a",
          href: "#",
          children: [
            "Подробнее",
            /* @__PURE__ */ jsxRuntimeExports.jsx(MoreIcon, {})
          ]
        }
      )
    ] })
  ] });
}
const newsApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getAllNews: builder.query({
      query: () => "news",
      providesTags: () => [
        {
          type: "News"
        }
      ]
    }),
    getNewsByCategory: builder.query({
      query: (id2) => `news?category=${id2}`,
      providesTags: () => [
        {
          type: "NewsByCategory"
        }
      ]
    }),
    getNewsById: builder.query({
      query: (id2) => `news/${id2}`,
      providesTags: () => [
        {
          type: "NewsById"
        }
      ]
    }),
    createNews: builder.mutation({
      query: (news) => ({
        url: "news/create",
        method: "POST",
        body: news
      }),
      invalidatesTags: () => [
        {
          type: "News"
        }
      ]
    }),
    updateNews: builder.mutation({
      query: (updateNews) => ({
        url: "news/update",
        method: "POST",
        body: updateNews
      }),
      invalidatesTags: ["News", "NewsByCategory", "NewsById"]
    }),
    deleteNews: builder.mutation({
      query: (id2) => ({
        url: "news/delete",
        method: "POST",
        body: id2
      }),
      invalidatesTags: ["News", "NewsByCategory", "NewsById"]
    }),
    restoreNews: builder.mutation({
      query: (id2) => ({
        url: "news/restore",
        method: "POST",
        body: id2
      }),
      invalidatesTags: ["News", "NewsByCategory", "NewsById"]
    })
  }),
  overrideExisting: false
});
const { useGetAllNewsQuery, useCreateNewsMutation, useGetNewsByIdQuery, useDeleteNewsMutation, useRestoreNewsMutation, useUpdateNewsMutation, useGetNewsByCategoryQuery } = newsApi;
const Container$e = st$1.div`
  display: flex;
  width: 100%;
  flex-direction: column;
  padding: 20px 15px;
  border-radius: ${(props) => props.theme.utils.br};
  opacity: ${(props) => props.$isVisible ? 1 : 0.5};
  background-color: ${(props) => props.$isDeleted ? "rgba(224, 54, 56, .1)" : props.theme.colors.realWhite};
  transition: opacity 0.2s ease-in-out;
  &:hover {
    opacity: 1;
  }
`;
const Title$7 = st$1.h3`
  margin-bottom: 25px;
  font-size: 22px;
  font-weight: 700;
  line-height: 149.5%;
  color: ${(props) => props.theme.colors.mainBlue};
`;
st$1.img`
  display: block;
  margin-bottom: 20px;
  border-radius: ${(props) => props.theme.utils.br};
  width: 920px;
  height: 920px;
  object-fit: cover;
`;
const Footer = st$1(FlexContainer)`
  align-items: center;
  margin-top: 18px;
`;
const MoreBtn = st$1(DefaultBtn)`
  min-height: 44px;
  padding: 0 20%;
`;
st$1.div`
  aspect-ratio: 1/1;
  overflow: hidden;
  border-radius: ${(props) => props.theme.utils.br};
`;
const Container$d = st$1.div`
  display: flex;
  align-items: center;
`;
const Date$1 = st$1.p`
  margin-right: 20px;
  font-size: 18px;
  font-weight: 400;
  line-height: 149.5%;
  color: ${(props) => props.theme.colors.grey93};
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 6.25vw;
    font-size: 3.75vw;
  }
`;
const Author = st$1(Date$1)``;
function NewsRequisites({
  date,
  author,
  adminHandlers = {},
  onClick: onClick2 = () => {
  }
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$d, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Date$1, { children: date }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Author, { children: author }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminBtn,
      {
        popupName: "Новость",
        type: "edit",
        onClick: onClick2,
        popupHandlers: adminHandlers
      }
    )
  ] });
}
function NewsEl({ data }) {
  const { setLoaderActive } = useActions();
  const [authorName, setAuthorName] = reactExports.useState("");
  const navigate = useNavigate();
  const [deleteNews] = useDeleteNewsMutation();
  const [restoreNews] = useRestoreNewsMutation();
  const [update2] = useUpdateNewsMutation();
  reactExports.useEffect(() => {
    const name = data.user ? data.user.name : data.user_id;
    setAuthorName(name);
  }, [data.text, data.user, data.user_id]);
  const handleEditNews = () => {
    navigate(`/news/edit-news/${data.id}`);
  };
  const handleDeleteNews = () => {
    deleteNews({
      id: data.id
    }).then((res) => {
      if ("data" in res && !res.data.result) {
        alert("При удалении статьи произошла ошибка");
      }
    });
    setLoaderActive(true);
  };
  const handleRestoreNews = () => {
    restoreNews({
      id: data.id
    }).then((res) => {
      if ("data" in res && !res.data.result) {
        alert("При востановлении статьи произошла ошибка");
      }
    });
    setLoaderActive(true);
  };
  const handleVisibileNews = () => {
    update2({
      id: data.id,
      status: Number(data.status) === 0 ? 1 : 0
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container$e,
    {
      $isDeleted: !!data.is_deleted,
      $isVisible: Number(data.status) !== 0,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Title$7, { children: data.title }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Footer, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Link$1,
            {
              to: `/news/${data.id}`,
              style: { display: "block", marginRight: "auto" },
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(MoreBtn, { children: "Подробнее" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            NewsRequisites,
            {
              author: authorName,
              date: data.date,
              adminHandlers: {
                onEdit: handleEditNews,
                onDelete: data.is_deleted ? void 0 : handleDeleteNews,
                onRestore: data.is_deleted ? handleRestoreNews : void 0,
                onVisible: Number(data.status) === 0 ? handleVisibileNews : void 0,
                onHide: Number(data.status) === 1 ? handleVisibileNews : void 0
              }
            }
          )
        ] })
      ]
    }
  );
}
const Container$c = st$1(FlexContainer)`
  flex-direction: column;
`;
const Title$6 = st$1(Text$6)`
  display: flex;
  justify-content: space-between;
  align-items: center;
  width: 75%;
  align-self: flex-end;
  margin-bottom: 10px;
  font-size: 15px;
`;
const ContentWrapper = st$1(FlexContainer)``;
const News$1 = st$1(FlexContainer)`
  position: relative;
  width: 75%;
  min-height: 150px;
  flex-direction: column;
  row-gap: 10px;
  @media ${(props) => props.theme.media.desktop} {
   border-radius: ${(props) => props.theme.utils.br};
  }
`;
const Wrapper = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 22px;
  width: 25%;
`;
const Item = st$1(Text$6)`
  font-size: 22px;
  cursor: pointer;

  &:hover {
    text-decoration: underline;
  }
`;
function NavListItem({ title, onClick: onClick2 = () => {
} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Item, { onClick: onClick2, children: title });
}
const newsCategoryApi = api.injectEndpoints({
  endpoints: (builder) => ({
    getNewsCategory: builder.query({
      query: () => "news-category",
      providesTags: () => [
        {
          type: "NewsCategory"
        }
      ]
    }),
    createNewsCategory: builder.mutation({
      query: (data) => ({
        url: "news-category/create",
        method: "POST",
        body: data
      }),
      invalidatesTags: () => [
        {
          type: "NewsCategory"
        }
      ]
    }),
    updateNewsCategory: builder.mutation({
      query: (data) => ({
        url: "news-category/update",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["NewsCategory"]
    }),
    deleteNewsCategory: builder.mutation({
      query: (data) => ({
        url: "news-category/delete",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["NewsCategory"]
    }),
    restoreNewsCategory: builder.mutation({
      query: (data) => ({
        url: "news-category/restore",
        method: "POST",
        body: data
      }),
      invalidatesTags: ["NewsCategory"]
    })
  }),
  overrideExisting: false
});
const {
  useCreateNewsCategoryMutation,
  useDeleteNewsCategoryMutation,
  useGetNewsCategoryQuery,
  useRestoreNewsCategoryMutation,
  useUpdateNewsCategoryMutation
} = newsCategoryApi;
function NewsCategoryWrapper({ children }) {
  const { data, isError, isLoading } = useGetNewsCategoryQuery();
  const navigate = useNavigate();
  const handleGoToCategory = (id2) => {
    navigate(`/news?category=${id2}`);
  };
  const handleGoToAllNews = () => {
    navigate("/news");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Wrapper, { children: [
    children,
    data && data.data.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavListItem,
      {
        title: "Все новости",
        onClick: handleGoToAllNews
      }
    ),
    isLoading && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Загрузка..." }),
    isError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "Ошибка!" }),
    !isError && !isLoading && data && data.data.map((newsCategory) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      NavListItem,
      {
        onClick: () => handleGoToCategory(newsCategory.id),
        title: newsCategory.title
      },
      newsCategory.id
    ))
  ] });
}
function NewsContainer() {
  var _a;
  const navigate = useNavigate();
  const { setLoaderActive } = useActions();
  const [searchParams] = useSearchParams();
  const [categorySearchParam, setCategorySearchParam] = reactExports.useState(null);
  const { data, isError, isFetching } = useGetAllNewsQuery(void 0, {
    skip: !!categorySearchParam
  });
  const newsByCategory = useGetNewsByCategoryQuery(Number(categorySearchParam), {
    skip: !categorySearchParam
  });
  reactExports.useEffect(() => {
    setCategorySearchParam(searchParams.get("category"));
  }, [searchParams]);
  reactExports.useEffect(() => {
    setLoaderActive(isFetching);
  }, [isFetching, setLoaderActive]);
  const handleCreateNews = () => {
    navigate("/news/create-news");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$c, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$6, { children: [
      "Новости",
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        AdminBtn,
        {
          popupName: "Новость",
          type: "add",
          onClick: handleCreateNews
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ContentWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(NewsCategoryWrapper, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(News$1, { children: [
        isFetching || newsByCategory.isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSmall, {}),
        isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
        categorySearchParam && newsByCategory.data && newsByCategory.data.data.length > 0 && newsByCategory.data.data.map((newsData) => /* @__PURE__ */ jsxRuntimeExports.jsx(NewsEl, { data: newsData })),
        !categorySearchParam && data && data.data.length > 0 && data.data.map((newsData) => /* @__PURE__ */ jsxRuntimeExports.jsx(NewsEl, { data: newsData })),
        !((_a = newsByCategory.data) == null ? void 0 : _a.data.length) && !(data == null ? void 0 : data.data.length) && !isFetching && !newsByCategory.isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(NoAvailable, { text: "Нет доступных новостей", onAdd: handleCreateNews })
      ] })
    ] })
  ] });
}
const Container$b = st$1(FlexContainer)`
  flex-direction: column;
  padding: 60px 0 90px 0;
`;
const MainInfoWrapper = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  margin-bottom: 35px;

  @media ${(props) => props.theme.media.mobile} {
    flex-direction: column;
    align-items: unset;
    justify-content: unset;
    row-gap: 2vw;
  }
`;
function NewsMain() {
  const { data, isError, isFetching } = useGetAllCompetitionsQuery();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$b, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(MainInfoWrapper, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionsSwiper, { data, isError, isFetching }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        ManagerInfo,
        {
          percentage: "100",
          salary: "999999",
          appSaleValue: "999",
          yamaguchiLvl: "3",
          zebrChair: "2(x) из 33"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NewsContainer, {})
  ] }) });
}
const Container$a = st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  padding-top: 25px;
`;
const backIcon = "/assets/arrow-left-blue.svg";
const Button = st$1.button`
  display: flex;
  align-items: center;
  width: fit-content;
  background-color: transparent;
  padding: 0;
  margin: 0;
  margin-bottom: 18px;
`;
const Icon = st$1(Icon$2)`
  margin-right: 8px;
  background-image: url(${backIcon});
`;
const Text$2 = st$1.span`
  font-size: 22px;
  font-weight: 500;
  line-height: 149.5%;
  color: ${(props) => props.theme.colors.mainBlue};
`;
function BackBtn({ onClick: onClick2 = () => {
}, text = "назад" }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: onClick2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Text$2, { children: text })
  ] });
}
const Container$9 = st$1.div`
  display: flex;
  width: 100%;
`;
st$1.div`
  display: flex;
  flex-direction: column;
  width: 75%;
  padding: 15px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
`;
st$1.div`
  display: flex;
  flex-direction: column;
  width: 100%;
  margin-bottom: 50px;
`;
const Bottom = st$1.div`
  display: flex;
  align-items: center;
  justify-content: flex-end;
`;
const Content$1 = st$1.div`
  display: flex;
  flex-direction: column;
  position: relative;
  width: 75%;
  min-height: 200px;
  padding: 15px;
  border-radius: ${(props) => props.theme.utils.br};
  opacity: ${(props) => props.$isVisible ? 1 : 0.5};
  background-color: ${(props) => props.$isDeleted ? "rgba(224, 54, 56, .1)" : props.theme.colors.realWhite};
  transition: opacity 0.2s ease-in-out;
  &:hover {
    opacity: 1;
  }
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    padding: 4.6875vw;
  }
`;
function Content({ children, isDeleted, isVisible }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Content$1, { $isDeleted: isDeleted, $isVisible: isVisible, children });
}
const Title$5 = st$1(Text$6)`
  margin-bottom: 23px;
  font-size: 22px;
  @media ${(props) => props.theme.media.mobile} {
    display: none;
  }
`;
function ContentTitle({ title }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Title$5, { children: title });
}
function NewsContent() {
  var _a;
  const { setLoaderActive } = useActions();
  const { newsId } = useParams();
  const { data, isFetching, isError } = useGetNewsByIdQuery(Number(newsId), {
    skip: !newsId
  });
  const navigate = useNavigate();
  const [deleteNews] = useDeleteNewsMutation();
  const [restoreNews] = useRestoreNewsMutation();
  const [update2] = useUpdateNewsMutation();
  reactExports.useEffect(() => {
    setLoaderActive(isFetching);
  }, [isFetching, setLoaderActive]);
  const handleEditNews = () => {
    if (!data) {
      console.error("no data:" + data);
      return;
    }
    navigate(`/news/edit-news/${data.data.id}`);
  };
  const handleDeleteNews = () => {
    if (!data) {
      console.error("no data:" + data);
      return;
    }
    deleteNews({
      id: data.data.id
    }).then((res) => {
      if ("data" in res && !res.data.result) {
        alert("При удалении статьи произошла ошибка");
      }
    });
    setLoaderActive(true);
  };
  const handleRestoreNews = () => {
    if (!data) {
      console.error("no data:" + data);
      return;
    }
    restoreNews({
      id: data.data.id
    }).then((res) => {
      if ("data" in res && !res.data.result) {
        alert("При востановлении статьи произошла ошибка");
      }
    });
    setLoaderActive(true);
  };
  const handleVisibileNews = () => {
    if (!data) {
      console.error("no data:" + data);
      return;
    }
    update2({
      id: data.data.id,
      status: Number(data.data.status) === 0 ? 1 : 0
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { isDeleted: !!(data == null ? void 0 : data.data.is_deleted), isVisible: Number(data == null ? void 0 : data.data.status) === 1, children: [
    isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {}),
    data && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContentTitle, { title: data.data.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: data.data.text } }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Bottom, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        NewsRequisites,
        {
          author: ((_a = data.data.user) == null ? void 0 : _a.name) || data.data.user_id,
          date: data.data.date,
          adminHandlers: {
            onEdit: handleEditNews,
            onDelete: data.data.is_deleted ? void 0 : handleDeleteNews,
            onRestore: data.data.is_deleted ? handleRestoreNews : void 0,
            onVisible: Number(data.data.status) === 0 ? handleVisibileNews : void 0,
            onHide: Number(data.data.status) === 1 ? handleVisibileNews : void 0
          }
        }
      ) })
    ] })
  ] });
}
function NewsByIdContent() {
  const navigate = useNavigate();
  const handleGoBack = () => {
    navigate("/news");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$9, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(NewsCategoryWrapper, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(BackBtn, { onClick: handleGoBack }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NewsContent, {})
  ] });
}
function NewsById() {
  const navigate = useNavigate();
  const handleCreateNews = () => {
    navigate("/news/create-news");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$a, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminBtn,
      {
        popupName: "Новость",
        type: "add",
        styles: { marginLeft: "auto", display: "block" },
        onClick: handleCreateNews
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(NewsByIdContent, {})
  ] }) });
}
const List$1 = st$1.ul`
  display: flex;
  flex-direction: column;
  row-gap: 22px;
`;
function NavList({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(List$1, { children });
}
function CompetitionAside() {
  var _a;
  const navigate = useNavigate();
  const { competitionId } = useParams();
  const { data, isError, isFetching } = useGetAllCompetitionsQuery();
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  const competitionData = useGetCompetitionByIdQuery(Number(competitionId), {
    skip: !isMobile
  });
  const handleGoBack = () => {
    navigate("/news");
  };
  const handleGoToCompetition = (id2) => {
    navigate(`/news/competitions/${id2}`);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(BackBtn, { onClick: handleGoBack, text: isMobile ? (_a = competitionData.data) == null ? void 0 : _a.data.title : void 0 }),
    !isMobile && data && !isError && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(NavList, { children: data.data.map(
      (competition) => {
        if (Number(competitionId) === competition.id) {
          return null;
        }
        return /* @__PURE__ */ jsxRuntimeExports.jsx(
          NavListItem,
          {
            title: competition.title,
            onClick: () => {
              handleGoToCompetition(competition.id);
            }
          },
          competition.id
        );
      }
    ) })
  ] });
}
const Container$8 = st$1(FlexContainer)`
  padding-top: 50px;
  @media ${(props) => props.theme.media.mobile} {
    flex-direction: column;
    padding-top: 4.6875vw;
  }
`;
const Container$7 = st$1(FlexContainer)`
  flex-direction: column;
  width: 25%;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
  }
`;
function AsideBar({ children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Container$7, { children });
}
const externalLinkIcon = "/assets/moreIcon.svg";
const BottomContainer$2 = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
  @media ${(props) => props.theme.media.mobile} {
    flex-direction: column-reverse;
    align-items: flex-start;
    row-gap: 9.375vw;
  }
`;
st$1(FlexContainer)`
  flex-direction: column;
  margin-bottom: 50px;
`;
const Link = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  justify-content: center;
  width: fit-content;
  min-height: 44px;
  padding: 0 20px 0 23px;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    min-height: 12.5vw;
  }
`;
const LinkIcon = st$1(Icon$2)`
  margin-left: 10px;
  background-image: url(${externalLinkIcon});
`;
function CompetitionContent() {
  var _a;
  const { setLoaderActive } = useActions();
  const { competitionId } = useParams();
  const navigate = useNavigate();
  const [deleteCompetition] = useDeleteCompetitionMutation();
  const [restoreCompetition] = useRestoreCompetitionMutation();
  const [updateCompetition] = useUpdateCompetitionMutation();
  const { data, isFetching, isError } = useGetCompetitionByIdQuery(Number(competitionId), {
    skip: !competitionId
  });
  const isMobile = useMediaQuery(MediaQueries.mobile);
  const handleEditCompetition = () => {
    if (!data) {
      console.error("No data:", data);
      return;
    }
    navigate(`/news/competition/edit-competition/${data == null ? void 0 : data.data.id}`);
  };
  const handleDeleteCompetition = () => {
    if (!data) {
      console.error("No data:", data);
      return;
    }
    deleteCompetition({ id: data.data.id }).then(() => {
      setLoaderActive(false);
    });
    setLoaderActive(true);
  };
  const handleRestoreCompetition = () => {
    if (!data) {
      console.error("No data:", data);
      return;
    }
    restoreCompetition({ id: data.data.id }).then(() => {
      setLoaderActive(false);
    });
    setLoaderActive(true);
  };
  const handleVisibleCompetition = () => {
    if (!data) {
      console.error("No data:", data);
      return;
    }
    updateCompetition({
      id: data.data.id,
      status: Number(data.data.status) === 0 ? 1 : 0
    }).then((res) => {
      if ("data" in res && !res.data.result) {
        alert("При редактировании конкурса произошла ошибка");
      }
      setLoaderActive(false);
    }).catch((err) => {
      console.error(err);
      alert("При редактировании конкурса произошла ошибка");
      setLoaderActive(false);
    });
    setLoaderActive(true);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Content, { isDeleted: !!(data == null ? void 0 : data.data.is_deleted), isVisible: Number(data == null ? void 0 : data.data.status) === 1, children: [
    data && !isError && !isFetching && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ContentTitle, { title: data == null ? void 0 : data.data.title }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { dangerouslySetInnerHTML: { __html: data.data.text }, className: "ck-content" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(BottomContainer$2, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Link$1, { to: data.data.link, target: "_blank", style: {
          textDecoration: "none",
          width: isMobile ? "100%" : "auto"
        }, children: data.data.link && /* @__PURE__ */ jsxRuntimeExports.jsxs(Link, { children: [
          "Еще подробнее",
          /* @__PURE__ */ jsxRuntimeExports.jsx(LinkIcon, {})
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          NewsRequisites,
          {
            date: data.data.date,
            author: ((_a = data.data.user) == null ? void 0 : _a.name) || data.data.user_id,
            adminHandlers: {
              onDelete: data.data.is_deleted ? void 0 : handleDeleteCompetition,
              onRestore: data.data.is_deleted ? handleRestoreCompetition : void 0,
              onEdit: handleEditCompetition,
              onHide: Number(data.data.status) === 1 ? handleVisibleCompetition : void 0,
              onVisible: Number(data.data.status) === 0 ? handleVisibleCompetition : void 0
            }
          }
        )
      ] })
    ] }),
    isFetching && /* @__PURE__ */ jsxRuntimeExports.jsx(LoadingSmall, {}),
    isError && /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBlock, {})
  ] });
}
function Competition() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$8, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(AsideBar, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionAside, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CompetitionContent, {})
  ] }) });
}
function News() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/", element: /* @__PURE__ */ jsxRuntimeExports.jsx(NewsMain, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/:newsId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(NewsById, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/competitions/:competitionId", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Competition, {}) })
  ] });
}
function Main() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header$2, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/news/*",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(News, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/courses/*",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(Courses, {})
        }
      )
    ] })
  ] });
}
const ModalLayout$1 = st$1.div`
  display: flex;
  justify-content: flex-end;
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: transparent;
  animation: overlayEntrance 0.3s ease-out forwards;
  @media ${(props) => props.theme.media.mobile} {
    animation: unset;
  }

  @keyframes overlayEntrance {
    100% {
      background-color: rgba(0, 0, 0, 0.7);
    }
  }
`;
const Window = st$1.div`
  display: flex;
  flex-direction: column;
  position: relative;
  width: fit-content;
  height: 100%;
  overflow-y: auto;
  background-color: ${(props) => props.theme.colors.realWhite};
  animation: windowEntrance 0.3s ease-out forwards;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    padding: 3.125vw 0 0;
    animation-name: windowEntrance;
  }

  @keyframes windowEntrance {
    0% {
      transform: translateX(100%);
    }
    100% {
      transform: translate(0%);
    }
  }
`;
const ModalName = st$1.h3`
  position: absolute;
  top: 35px;
  left: -155px;
  font-size: 92.5px;
  font-weight: 700;
  line-height: 120%;
  color: ${(props) => props.theme.colors.realWhite};
  transform: rotate(-180deg);
  writing-mode: vertical-lr;
  pointer-events: none;
  @media ${(props) => props.theme.media.mobile} {
    display: flex;
    align-items: center;
    justify-content: space-between;
    position: static;
    padding: 0 3.125vw;
    margin-bottom: 4.6875vw;
    font-size: 3.75vw;
    color: ${(props) => props.theme.colors.mainBlue};
    transform: none;
    writing-mode: unset;
    pointer-events: unset;
  }
`;
const CloseBtn = st$1.button`
  display: none;
  @media ${(props) => props.theme.media.mobile} {
    display: block;
    width: 7.5vw;
    height: 7.5vw;
    padding: 0;
    margin: 0;
    background-color: transparent;
    background-image: url(${closeIcon});
    background-repeat: no-repeat;
    background-position: center;
    background-size: 100%;
  }
`;
function ModalLayout({ children, modalType: type }) {
  const { setModalOpen } = useActions();
  const [modalName, setModalName] = reactExports.useState();
  reactExports.useEffect(() => {
    let name = "";
    switch (type) {
      case MODAL_TYPES.createCourse:
        name = "Создание курса";
        break;
      case MODAL_TYPES.editCourse:
        name = "Изменение курса";
        break;
      case MODAL_TYPES.createChapter:
        name = "Создание главы";
        break;
      case MODAL_TYPES.editChapter:
        name = "Изменение главы";
        break;
      case MODAL_TYPES.createTheme:
        name = "Создание Темы";
        break;
      case MODAL_TYPES.editTheme:
        name = "Изменение Темы";
        break;
      case MODAL_TYPES.newsCategory:
        name = "Категории";
        break;
      default:
        console.error(`Unknown modal type: ${type}`);
    }
    setModalName(name);
  }, [type]);
  const modalRoot = document.getElementById("modal-root");
  if (!modalRoot)
    return;
  const handleOverlayClick = (event) => {
    if (event.target === event.currentTarget) {
      setModalOpen(false);
    }
  };
  const handleCloseModal = () => {
    setModalOpen(false);
  };
  return ReactDOM.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx(ModalLayout$1, { onClick: handleOverlayClick, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Window, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalName, { children: [
        modalName,
        /* @__PURE__ */ jsxRuntimeExports.jsx(CloseBtn, { onClick: handleCloseModal })
      ] }),
      children
    ] }) }),
    modalRoot
  );
}
const imagesIcon = "/assets/imagesIcon.svg";
const NameInput = st$1(InputWithState)`
  margin-bottom: 20px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 2.5vw;
  }
`;
const Textarea = st$1(InputWithState)`
  min-height: 557px;
  margin-bottom: 15px;
  resize: none;
  outline: none;
  @media ${(props) => props.theme.media.mobile} {
    min-height: 93.125vw;
    margin-bottom: 2.5vw;
  }
`;
st$1(DefaultBtn)`
  width: fit-content;
  min-height: 41px;
  padding: 0 24px 0 52px;
  margin-bottom: 20px;
  font-size: 15.397px;
  background-image: url(${imagesIcon});
  background-repeat: no-repeat;
  background-position: 17px 9px;
  background-size: 24px;
  @media ${(props) => props.theme.media.mobile} {
    min-height: 12.5vw;
    padding: 0  7.5vw 0 16.25vw;
    margin-bottom: 4.6875vw;
    font-size: 4.6875vw;
    background-size: 7.5vw;
    background-position: 5.3125vw center;
  }
`;
const BottomContainer$1 = st$1(FlexContainer)`
  justify-content: space-between;
`;
const Container$6 = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  row-gap: 10px;
  width: 100%;
  padding: 25px;
  margin-top: auto;
  border-top: 1px solid ${(props) => props.theme.colors.greyF1};
  @media ${(props) => props.theme.media.mobile} {
    flex-wrap: nowrap;
    padding: 3.125vw;
    gap: unset;
  }
`;
const ConfirmBtn = st$1(DefaultBtn)`
  width: 49%;
  min-width: 449px;
  @media ${(props) => props.theme.media.mobile} {
    min-width: unset;
    width: 48%;
    min-height: 15.625vw;
    font-size: 4.6875vw;
  }
`;
const CancelBtn = st$1(ConfirmBtn)`
  color: ${(props) => props.theme.colors.grey93};
  background-color: ${(props) => props.theme.colors.greyF1};

  &:hover {
    background-color: ${(props) => props.theme.colors.greyEO};
  }
`;
function FormControls({ handlers, names, containerStyles }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$6, { style: containerStyles, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CancelBtn, { onClick: handlers.cancel, children: names.cancel }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ConfirmBtn, { onClick: handlers.confirm, children: names.confirm })
  ] });
}
const Container$5 = st$1(FlexContainer)`
  flex-direction: column;
  width: ${(props) => props.$width};
  height: 100%;
  padding-top: 25px;
  @media ${(props) => props.theme.media.mobile} {
    width: 100%;
    padding-top: 0;
  }
`;
const Form = st$1.form`
  padding: 0 25px 5vh;
  @media ${(props) => props.theme.media.mobile} {
    padding: 0 3.125vw 15%;
  }
`;
function ModalForm({
  children,
  handlers,
  names,
  width: width2,
  onSubmit = () => {
  },
  styles: styles2
}) {
  const handleSubmit = (event) => {
    event.preventDefault();
    onSubmit();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Container$5,
    {
      $width: width2,
      style: styles2,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { onSubmit: handleSubmit, children }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormControls,
          {
            handlers,
            names
          }
        )
      ]
    }
  );
}
const editorjs = "";
const InputWrapper = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  width: fit-content;
`;
const FileInput = st$1.input`
  position: absolute;
  left: 50%;
  top: 50%;
  width: 100%;
  height: 100%;
  opacity: 0;
  transform: translate(-50%, -50%);
  cursor: pointer;
`;
function CustomFileInput({ onSet, children }) {
  const handleFileChange = (event) => {
    const file = event.target.files && event.target.files[0];
    if (file && file.type.startsWith("image/")) {
      const fileExtension = file.name.split(".").pop() || null;
      if (fileExtension) {
        convertToBase64(file, fileExtension);
      }
    }
  };
  const convertToBase64 = (file, extension) => {
    const reader = new FileReader();
    reader.onload = () => {
      const base64 = reader.result;
      onSet(base64, extension);
    };
    reader.readAsDataURL(file);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(InputWrapper, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FileInput,
      {
        type: "file",
        accept: "image/*",
        onChange: handleFileChange
      }
    ),
    children
  ] });
}
const ImageWrapper = st$1.div`
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  min-width: 342px;
  margin-bottom: 13px;
  aspect-ratio: 3/2;
  border-radius: 19px;
  background-color: ${(props) => props.theme.colors.greyF1};
  overflow: hidden;
  @media ${(props) => props.theme.media.mobile} {
    min-width: unset;
    max-width: unset;
    margin-bottom: 3.125vw;
    border-radius: 16.5px;
  }
`;
const Image$2 = st$1.img`
  width: 100%;
  height: 100%;
  object-fit: cover;
`;
function Image$1({ image, description, styles: styles2 = {} }) {
  const [src, setSrc] = reactExports.useState("");
  reactExports.useEffect(() => {
    if ("id" in image) {
      const src2 = image.directory + "/" + image.name;
      setSrc(src2);
      return;
    }
    if (image.data)
      [
        setSrc(image.data)
      ];
  }, [image]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ImageWrapper, { style: styles2, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    Image$2,
    {
      src,
      alt: description
    }
  ) });
}
const editIcon = "/assets/editIcon-with-pen.svg";
const deleteIcon = "/assets/deleteIcon-white.svg";
const Container$4 = st$1.div``;
st$1.div`
  position: relative;
  margin-bottom: 15px;
  @media ${(props) => props.theme.media.mobile} {
    margin-bottom: 3.125vw;
  }
`;
const ControlsGroup = st$1.div`
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
`;
const AddFileBtn = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  width: fit-content;
  min-height: 41px;
  padding: 0 23px 0 17px;
  font-size: 15.397px;
  @media ${(props) => props.theme.media.mobile} {
    min-height: 12.8125vw;
    padding: 0 7.1875vw 0 5.3125vw;
    font-size: 4.8115625vw;
  }
`;
const EditFileBtn = st$1(AddFileBtn)`
  min-height: 60px;
  padding: 0 30px;
  font-size: 15px;
  @media ${(props) => props.theme.media.mobile} {
    justify-content: center;
    min-height: 15.625vw;
    padding: 0;
    width: 45vw;
    font-size: 3.75vw;
    border-radius: 13.026px;
  }
`;
const DeleteFileBtn = st$1(EditFileBtn)`
  padding: 0 33px 0 23px;
  background-color: ${(props) => props.theme.colors.yRed};

  &:hover {
    background-color: ${(props) => props.theme.colors.darkRed};
  }
`;
const AddFileIcon = st$1(Icon$2)`
  margin-right: 11px;
  background-image: url(${imagesIcon});
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 3.125vw;
  }
`;
const EditIcon = st$1(Icon$2)`
  margin-right: 8px;
  background-image: url(${editIcon});
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 1.5625vw;
  }
`;
const DeleteIcon = st$1(Icon$2)`
  margin-right: 8px;
  background-image: url(${deleteIcon});
  @media ${(props) => props.theme.media.mobile} {
    margin-right: 1.5625vw;
  }
`;
function AddImage({ name, onSet, imageData, onDelete, previewImageStyles = {} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$4, { children: [
    imageData && /* @__PURE__ */ jsxRuntimeExports.jsx(Image$1, { image: imageData, styles: previewImageStyles }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(ControlsGroup, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CustomFileInput, { onSet, children: [
        !imageData && /* @__PURE__ */ jsxRuntimeExports.jsxs(AddFileBtn, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AddFileIcon, {}),
          name
        ] }),
        imageData && /* @__PURE__ */ jsxRuntimeExports.jsxs(EditFileBtn, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(EditIcon, {}),
          "изменить"
        ] })
      ] }),
      imageData && /* @__PURE__ */ jsxRuntimeExports.jsxs(DeleteFileBtn, { onClick: onDelete, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteIcon, {}),
        "Удалить"
      ] })
    ] })
  ] });
}
function CreateCourseForm() {
  const { setModalOpen, setLoaderActive } = useActions();
  const modalType = useTypedSelector((state) => state.modal.modalType);
  const courseData = useTypedSelector((state) => state.course.data);
  const [courseName, setCourseName] = reactExports.useState("");
  const [isValidName, setValidName] = reactExports.useState(false);
  const [isChangedName, setChangedName] = reactExports.useState(false);
  const [isEditForm, setEditForm] = reactExports.useState(false);
  const [courseImage, setCourseImage] = reactExports.useState(null);
  const [courseDescription, setCourseDescription] = reactExports.useState("");
  const [createCourse] = useCreateCourseMutation();
  const [updateCourse] = useUpdateCourseMutation();
  const navigate = useNavigate();
  reactExports.useEffect(() => {
    const isEdit = modalType === MODAL_TYPES.editCourse;
    setEditForm(isEdit);
    if (isEdit && courseData) {
      setCourseName((prevState) => (courseData == null ? void 0 : courseData.title) || prevState);
      setChangedName(true);
      setValidName(true);
      setCourseDescription((prevState) => (courseData == null ? void 0 : courseData.description) || prevState);
      setCourseImage((courseData == null ? void 0 : courseData.image) || null);
    }
  }, [courseData, modalType]);
  const handleChange = (event) => {
    setValidName(event.target.value.length > 1);
    setCourseName(event.target.value);
    if (!isChangedName) {
      setChangedName(true);
    }
  };
  const handleTeaxtAreaChange = (event) => {
    setCourseDescription(event.target.value);
  };
  const handleConfirm = () => {
    if (!isValidName) {
      setChangedName(true);
      return;
    }
    if (!isEditForm) {
      createCourse({
        title: courseName,
        description: courseDescription,
        is_open: 1,
        image: courseImage
      }).then((res) => {
        if ("data" in res) {
          setModalOpen(false);
          navigate(`/courses/${res.data.data.id}`);
        }
      });
      setLoaderActive(true);
    }
    if (isEditForm && courseData && courseData.id) {
      updateCourse({
        id: courseData.id,
        title: courseName,
        description: courseDescription,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        //@ts-ignore
        image: courseImage ? courseImage.id ? courseImage.id : courseImage : null
      }).then(() => setModalOpen(false));
      setLoaderActive(true);
    }
  };
  const handleCancel = () => {
    setModalOpen(false);
  };
  const handleSetCourseImage = (base64, extension) => {
    setCourseImage({ data: base64, extension });
  };
  const handleDeleteCourseImage = () => {
    setCourseImage(null);
  };
  const handlers = {
    cancel: handleCancel,
    confirm: handleConfirm
  };
  const names = {
    cancel: "Отмена",
    confirm: `${modalType === MODAL_TYPES.editCourse ? "Изменить" : "Создать"} курс`
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ModalForm,
    {
      width: "1240px",
      handlers,
      names,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          NameInput,
          {
            type: "text",
            $isValid: isValidName,
            $isChanged: isChangedName,
            value: courseName,
            onChange: handleChange,
            placeholder: "Введите название курса (обязательно)"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Textarea,
          {
            as: "textarea",
            onChange: handleTeaxtAreaChange,
            value: courseDescription
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(BottomContainer$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AddImage,
          {
            onSet: handleSetCourseImage,
            name: "Обложка курса",
            imageData: courseImage,
            onDelete: handleDeleteCourseImage,
            previewImageStyles: {
              maxWidth: "342px"
            }
          }
        ) })
      ]
    }
  );
}
const InputName$1 = st$1(InputWithState)`
  margin-bottom: 20px;
`;
st$1(DefaultBtn)`
  width: fit-content;
  min-height: 41px;
  padding: 0 24px 0 52px;
  margin-bottom: 20px;
  font-size: 15.397px;
  background-image: url(${imagesIcon});
  background-repeat: no-repeat;
  background-position: 17px 9px;
  background-size: 24px;
`;
const BottomContainer = st$1(FlexContainer)`
  justify-content: space-between;
`;
function CreateChapterForm() {
  const { data, updatingChapterData } = useTypedSelector((state) => state.course);
  const formType = useTypedSelector((state) => state.modal.modalType);
  const { setModalOpen, addChapter, setLoaderActive, changeChapter } = useActions();
  const [createChapter] = useCreateChapterMutation();
  const [updateChapter] = useUpdateChapterMutation();
  const [chapterName, setChapterName] = reactExports.useState("");
  const [isValidName, setValidName] = reactExports.useState(false);
  const [isChangedName, setChangedName] = reactExports.useState(false);
  const [isEditForm, setEditForm] = reactExports.useState(false);
  const [chapterImage, setChapterImage] = reactExports.useState(null);
  reactExports.useEffect(() => {
    if (formType === MODAL_TYPES.editChapter && updatingChapterData) {
      setEditForm(true);
      setChapterName(updatingChapterData.title);
      setValidName(true);
      setChangedName(true);
      setChapterImage(updatingChapterData.image);
    }
  }, [data.image, formType, updatingChapterData]);
  const handleChange = (event) => {
    setValidName(event.target.value.length > 1);
    setChapterName(event.target.value);
    if (!isChangedName) {
      setChangedName(true);
    }
  };
  const handleConfirm = () => {
    if (!isValidName) {
      setChangedName(true);
      return;
    }
    if ((data == null ? void 0 : data.id) && !isEditForm) {
      createChapter({
        title: chapterName,
        course_id: data.id,
        image: chapterImage
      }).then((res) => {
        if ("data" in res && res.data.result) {
          addChapter(res.data.data);
        }
        setModalOpen(false);
      }).catch((err) => {
        console.error(err);
      });
      setLoaderActive(true);
    }
    console.log(updatingChapterData);
    if (isEditForm && updatingChapterData && updatingChapterData.course_id) {
      updateChapter({
        course_id: updatingChapterData.course_id,
        id: Number(updatingChapterData.id),
        title: chapterName,
        image: chapterImage
      }).then((res) => {
        if ("data" in res) {
          changeChapter(res.data.data);
        }
        setLoaderActive(false);
        setModalOpen(false);
      }).catch((err) => console.error(err));
      setLoaderActive(true);
    }
  };
  const handleCancel = () => {
    setModalOpen(false);
  };
  const handlers = {
    cancel: handleCancel,
    confirm: handleConfirm
  };
  const handleSetChapterImage = (base64, extension) => {
    setChapterImage({ data: base64, extension });
  };
  const handleDeleteChapterImage = () => {
    setChapterImage(null);
  };
  const names = {
    cancel: "Отмена",
    confirm: `${isEditForm ? "Изменить" : "Создать"} главу`
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ModalForm,
    {
      handlers,
      names,
      width: "509px",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          InputName$1,
          {
            type: "text",
            $isValid: isValidName,
            $isChanged: isChangedName,
            value: chapterName,
            onChange: handleChange,
            placeholder: "Введите название главы (обязательно)"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(BottomContainer, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AddImage,
          {
            onSet: handleSetChapterImage,
            name: "Обложка главы",
            imageData: chapterImage,
            onDelete: handleDeleteChapterImage
          }
        ) })
      ]
    }
  );
}
const InputName = st$1(InputWithState)`
  margin-bottom: 20px;
`;
function CreateThemeForm() {
  const { setModalOpen, setLoaderActive } = useActions();
  const chapterId = useTypedSelector((state) => state.course.activeChapterId);
  const themeData = useTypedSelector((state) => state.course.updatingThemeData);
  const modalType = useTypedSelector((state) => state.modal.modalType);
  const [createTheme2] = useCreateThemeMutation();
  const [updateTheme] = useUpdateThemeMutation();
  const [themeName, setThemeName] = reactExports.useState("");
  const [isValidName, setValidName] = reactExports.useState(false);
  const [isChangedName, setChangedName] = reactExports.useState(false);
  reactExports.useEffect(() => {
    if (modalType === MODAL_TYPES.editTheme && themeData) {
      setThemeName(themeData.title);
      setValidName(true);
      setChangedName(false);
    } else if (modalType === MODAL_TYPES.editTheme) {
      alert("Что-то пошло не так...");
      setModalOpen(false);
    }
  }, [modalType, setModalOpen, themeData]);
  const handleChange = (event) => {
    setValidName(event.target.value.length > 1);
    setThemeName(event.target.value);
    if (!isChangedName) {
      setChangedName(true);
    }
  };
  const handleConfirm = () => {
    if (!isValidName) {
      setChangedName(true);
      return;
    }
    if (modalType === MODAL_TYPES.editTheme && themeData) {
      updateTheme({
        id: themeData.id,
        title: themeName,
        chapter_id: themeData == null ? void 0 : themeData.chapter_id
      }).then((res) => {
        if ("data" in res) {
          setModalOpen(false);
        }
      });
      setLoaderActive(true);
      return;
    }
    createTheme2({
      title: themeName,
      chapter_id: chapterId ? chapterId : 0
    }).then(() => {
      setModalOpen(false);
    }).catch((error) => {
      console.log(error);
      alert("Что-то пошло не так");
    });
    setLoaderActive(true);
  };
  const handleCancel = () => {
    setModalOpen(false);
  };
  const handlers = {
    cancel: handleCancel,
    confirm: handleConfirm
  };
  const names = {
    cancel: "Отмена",
    confirm: `${modalType === MODAL_TYPES.editTheme ? "Изменить" : "Создать"} тему`
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ModalForm,
    {
      handlers,
      names,
      width: "509px",
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        InputName,
        {
          type: "text",
          $isValid: isValidName,
          $isChanged: isChangedName,
          value: themeName,
          onChange: handleChange,
          placeholder: "Введите название темы (обязательно)"
        }
      )
    }
  );
}
const checklistIcon = "/assets/checklist.svg";
const Title$4 = st$1(Text$6)`
  margin-bottom: 20px;
  font-size: 92.5px;
`;
const LessonNameInput = st$1(InputWithState)`
  margin-bottom: 15px;
`;
st$1.div`
  width: 100%;
  min-height: 472px;
  padding: 25px;
  padding-left: 75px;
  margin-bottom: 15px;
  border: 1px solid ${(props) => props.theme.colors.greyEO};
  border-radius: ${(props) => props.theme.utils.br};
`;
const TestWrapper = st$1.div`
margin-bottom: 60px;
`;
const AddTest = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  width: fit-content;
`;
const AddTestIcon = st$1(Icon$2)`
  margin-right: 10px;
  background-image: url(${checklistIcon});
`;
const Divider$2 = st$1.div`
  position: relative;
  width: 100%;
  height: 1px;
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 100vw;
    height: 100%;
    background-color: ${(props) => props.theme.colors.greyF1};
    transform: translateX(-50%);
  }
`;
const addIcon = "/assets/addIconWhite.svg";
const Container$3 = st$1(FlexContainer)`
  flex-direction: column;
  padding-top: 40px;
  margin-bottom: 30px;
`;
const TestName = st$1(InputWithState)`
  margin-bottom: 30px;
`;
const Variants = st$1(FlexContainer)`
  flex-direction: column;
`;
const AddVariant = st$1(DefaultBtn)`
  width: fit-content;
  padding: 0 20px 0 50px;
  margin-bottom: 45px;
  background-image: url(${addIcon});
  background-repeat: no-repeat;
  background-position: 23px 50%;
  background-size: 24px;
`;
const DeleteTestBtn = st$1.button`
  display: flex;
  align-items: center;
  width: fit-content;
  padding: 0;
  margin: 0 0 45px;
  color: ${(props) => props.theme.colors.yRed};
  background-color: transparent;
`;
const DeleteTestBtnIcon = st$1(Icon$2)`
  margin-right: 5px;
  background-image: url(${deleteIcon$1});
`;
const Title$3 = st$1.h5`
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 10px;
  font-size: 18px;
  font-weight: 600;
  line-height: 120%;
  color: ${(props) => props.theme.colors.grey57};
`;
function Title$2({ value, children }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Title$3, { children: [
    value,
    children
  ] });
}
const Container$2 = st$1(FlexContainer)`
  flex-direction: column;
  margin-bottom: 15px;
  &:not(:last-child) {
    margin-bottom: 40px;
  }
`;
const VariantInput = st$1(InputWithState)`
  margin-bottom: 20px;
`;
const RadioGroup = st$1(FlexContainer)`
  align-items: center;
  margin-bottom: 20px;
`;
const CommentInput = st$1(Input$4)`
  color: ${(props) => props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed};

  &:focus {
    color: ${(props) => props.$isRight ? props.theme.colors.mainGreen : props.theme.colors.yRed}; 
  }
`;
const DeleteBtn$2 = st$1.button`
  background-color: transparent;
  padding: 0;
  margin: 0;
  margin-left: auto;
`;
const DeleteBtnIcon = st$1(Icon$2)`
  background-image: url(${deleteIcon$1});
`;
function DeleteBtn$1({ onClick: onClick2 = () => {
}, styles: styles2 = {} }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DeleteBtn$2,
    {
      style: styles2,
      onClick: onClick2,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteBtnIcon, {})
    }
  );
}
const Label$1 = st$1.label`
  display: flex;
  align-items: center;
  cursor: pointer;
`;
const RadioInput = st$1.input`
  display: none;

  &:checked + div::before {
    display: block;
  }
`;
const CustomRadioInput = st$1.div`
  width: 16px;
  height: 16px;
  margin-right: 14px;
  border-radius: 50%;
  position: relative;
  border: 1px solid #333;

  &::before {
    content: '';
    display: none;
    position: absolute;
    top: 50%;
    left: 50%;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background-color: #333;
    transform: translate(-50%, -50%);
  }
`;
function CustomRadioButton({
  onChange = () => {
  },
  name = "default",
  value,
  option,
  checked,
  styles: styles2 = {},
  radioStyles = {}
}) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Label$1, { style: styles2, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      RadioInput,
      {
        name,
        type: "radio",
        value,
        onChange,
        "data-option": option,
        checked
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CustomRadioInput, { style: radioStyles }),
    value
  ] });
}
function Variant({ data, number, testId }) {
  const { toggleAnswer, changeAnswer, changeAnswerComment, deleteAnswer } = useActions();
  const [isValid, setValid] = reactExports.useState(false);
  const [isChanged, setChanged] = reactExports.useState(false);
  const [defaultCommentValue, setDefaultCommentValue] = reactExports.useState("");
  reactExports.useEffect(() => {
    const trueComment = "Верно, потому что ";
    const falseComment = "Неверно, потому что ";
    changeAnswerComment({
      testId,
      answerId: data.id || "",
      value: ""
    });
    data.right_answer ? setDefaultCommentValue(trueComment) : setDefaultCommentValue(falseComment);
  }, [changeAnswerComment, data.id, data.right_answer, testId]);
  const handleSetRightAnswer = (isRight) => {
    const payload = {
      testId,
      answerId: data.id || "",
      isRight
    };
    toggleAnswer(payload);
  };
  const handleChangeAnswer = (event) => {
    changeAnswer({
      testId,
      answerId: data.id || "",
      value: event.target.value
    });
    if (event.target.value.length > 0) {
      setValid(true);
    }
    if (!isChanged) {
      setChanged(true);
    }
  };
  const handleChangeComment = (event) => {
    let value = event.target.value;
    if (!value.includes(defaultCommentValue)) {
      value = defaultCommentValue + value;
    }
    changeAnswerComment({
      testId,
      answerId: data.id || "",
      value
    });
  };
  const handleDeleteVariant = () => {
    deleteAnswer({
      testId,
      answerId: data.id || ""
    });
  };
  const radioFontStyles = {
    fontSize: "18px",
    fontWeight: "600"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$2, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title$2, { value: `Вариант ${number}`, children: number > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteBtn$1, { onClick: handleDeleteVariant }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      VariantInput,
      {
        type: "text",
        value: data.answer,
        onChange: handleChangeAnswer,
        $isChanged: isChanged,
        $isValid: isValid
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(RadioGroup, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CustomRadioButton,
        {
          styles: { marginRight: "25px", color: "#5B8930", ...radioFontStyles },
          name: data.id,
          value: "Верный",
          checked: data.right_answer,
          onChange: () => {
            handleSetRightAnswer(true);
          }
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        CustomRadioButton,
        {
          styles: { color: "#E03638", ...radioFontStyles },
          name: data.id,
          value: "Неверный",
          checked: !data.right_answer,
          onChange: () => {
            handleSetRightAnswer(false);
          }
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CommentInput,
      {
        type: "text",
        value: data.text || defaultCommentValue,
        $isRight: data.right_answer,
        onChange: handleChangeComment
      }
    )
  ] });
}
function CreateTestForm({ data }) {
  const { changeTestQuestion, addAnswer, deleteTest } = useActions();
  const [isChanged, setChanged] = reactExports.useState(false);
  const handleChangeTestName = (event) => {
    changeTestQuestion({ id: data.id, question: event.target.value });
    if (!isChanged) {
      setChanged(true);
    }
  };
  const handleAddVariant = () => {
    addAnswer({ id: data.id });
  };
  const handleDeleteTest = () => {
    deleteTest(data.id);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$3, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title$2, { value: "Заголовок теста (необязательно)" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      TestName,
      {
        type: "text",
        value: data.question,
        onChange: handleChangeTestName,
        $isValid: true,
        $isChanged: isChanged
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Variants, { children: data.answers.length > 0 && data.answers.map((answer, index) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Variant,
      {
        testId: data.id,
        data: answer,
        number: index + 1
      }
    )) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AddVariant, { onClick: handleAddVariant, children: "добавить вариант" }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DeleteTestBtn, { onClick: handleDeleteTest, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteTestBtnIcon, {}),
      "удалить тест"
    ] })
  ] });
}
var dist = { exports: {} };
/*!
 * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */
dist.exports;
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2(reactExports);
  }(self, (t2) => (() => {
    var e2 = { 703: (t3, e3, r3) => {
      var o3 = r3(414);
      function n3() {
      }
      function i2() {
      }
      i2.resetWarningCache = n3, t3.exports = function() {
        function t4(t5, e5, r5, n4, i3, s2) {
          if (s2 !== o3) {
            var a2 = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw a2.name = "Invariant Violation", a2;
          }
        }
        function e4() {
          return t4;
        }
        t4.isRequired = t4;
        var r4 = { array: t4, bigint: t4, bool: t4, func: t4, number: t4, object: t4, string: t4, symbol: t4, any: t4, arrayOf: e4, element: t4, elementType: t4, instanceOf: e4, node: t4, objectOf: e4, oneOf: e4, oneOfType: e4, shape: e4, exact: e4, checkPropTypes: i2, resetWarningCache: n3 };
        return r4.PropTypes = r4, r4;
      };
    }, 697: (t3, e3, r3) => {
      t3.exports = r3(703)();
    }, 414: (t3) => {
      t3.exports = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    }, 787: (e3) => {
      e3.exports = t2;
    } }, r2 = {};
    function o2(t3) {
      var n3 = r2[t3];
      if (void 0 !== n3)
        return n3.exports;
      var i2 = r2[t3] = { exports: {} };
      return e2[t3](i2, i2.exports, o2), i2.exports;
    }
    o2.n = (t3) => {
      var e3 = t3 && t3.__esModule ? () => t3.default : () => t3;
      return o2.d(e3, { a: e3 }), e3;
    }, o2.d = (t3, e3) => {
      for (var r3 in e3)
        o2.o(e3, r3) && !o2.o(t3, r3) && Object.defineProperty(t3, r3, { enumerable: true, get: e3[r3] });
    }, o2.o = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), o2.r = (t3) => {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
    };
    var n2 = {};
    return (() => {
      o2.r(n2), o2.d(n2, { CKEditor: () => to2, CKEditorContext: () => Xr });
      var t3 = o2(787), e3 = o2.n(t3), r3 = o2(697), i2 = o2.n(r3);
      const s2 = new Array(256).fill("").map((t4, e4) => ("0" + e4.toString(16)).slice(-2));
      class a2 {
        constructor(t4) {
          if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = "number" == typeof t4.crashNumberLimit ? t4.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = "number" == typeof t4.minimumNonErrorTimePeriod ? t4.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t5) => {
            const e4 = "error" in t5 ? t5.error : t5.reason;
            e4 instanceof Error && this._handleError(e4, t5);
          }, this._listeners = {}, !this._restart)
            throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
        destroy() {
          this._stopErrorHandling(), this._listeners = {};
        }
        on(t4, e4) {
          this._listeners[t4] || (this._listeners[t4] = []), this._listeners[t4].push(e4);
        }
        off(t4, e4) {
          this._listeners[t4] = this._listeners[t4].filter((t5) => t5 !== e4);
        }
        _fire(t4, ...e4) {
          const r4 = this._listeners[t4] || [];
          for (const t5 of r4)
            t5.apply(this, [null, ...e4]);
        }
        _startErrorHandling() {
          window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _stopErrorHandling() {
          window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _handleError(t4, e4) {
          if (this._shouldReactToError(t4)) {
            this.crashes.push({ message: t4.message, stack: t4.stack, filename: e4 instanceof ErrorEvent ? e4.filename : void 0, lineno: e4 instanceof ErrorEvent ? e4.lineno : void 0, colno: e4 instanceof ErrorEvent ? e4.colno : void 0, date: this._now() });
            const r4 = this._shouldRestart();
            this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: t4, causesRestart: r4 }), r4 ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
          }
        }
        _shouldReactToError(t4) {
          return t4.is && t4.is("CKEditorError") && void 0 !== t4.context && null !== t4.context && "ready" === this.state && this._isErrorComingFromThisItem(t4);
        }
        _shouldRestart() {
          if (this.crashes.length <= this._crashNumberLimit)
            return true;
          return (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
        }
      }
      function c2(t4, e4 = /* @__PURE__ */ new Set()) {
        const r4 = [t4], o3 = /* @__PURE__ */ new Set();
        let n3 = 0;
        for (; r4.length > n3; ) {
          const t5 = r4[n3++];
          if (!o3.has(t5) && u2(t5) && !e4.has(t5))
            if (o3.add(t5), Symbol.iterator in t5)
              try {
                for (const e5 of t5)
                  r4.push(e5);
              } catch (t6) {
              }
            else
              for (const e5 in t5)
                "defaultValue" !== e5 && r4.push(t5[e5]);
        }
        return o3;
      }
      function u2(t4) {
        const e4 = Object.prototype.toString.call(t4), r4 = typeof t4;
        return !("number" === r4 || "boolean" === r4 || "string" === r4 || "symbol" === r4 || "function" === r4 || "[object Date]" === e4 || "[object RegExp]" === e4 || "[object Module]" === e4 || null == t4 || t4._watchdogExcluded || t4 instanceof EventTarget || t4 instanceof Event);
      }
      function h2(t4, e4, r4 = /* @__PURE__ */ new Set()) {
        if (t4 === e4 && ("object" == typeof (o3 = t4) && null !== o3))
          return true;
        var o3;
        const n3 = c2(t4, r4), i3 = c2(e4, r4);
        for (const t5 of n3)
          if (i3.has(t5))
            return true;
        return false;
      }
      const d2 = function(t4) {
        var e4 = typeof t4;
        return null != t4 && ("object" == e4 || "function" == e4);
      };
      const l2 = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var p2 = "object" == typeof self && self && self.Object === Object && self;
      const f2 = l2 || p2 || Function("return this")();
      const _2 = function() {
        return f2.Date.now();
      };
      var y2 = /\s/;
      const g2 = function(t4) {
        for (var e4 = t4.length; e4-- && y2.test(t4.charAt(e4)); )
          ;
        return e4;
      };
      var b2 = /^\s+/;
      const v2 = function(t4) {
        return t4 ? t4.slice(0, g2(t4) + 1).replace(b2, "") : t4;
      };
      const m2 = f2.Symbol;
      var j2 = Object.prototype, w2 = j2.hasOwnProperty, x2 = j2.toString, E2 = m2 ? m2.toStringTag : void 0;
      const O2 = function(t4) {
        var e4 = w2.call(t4, E2), r4 = t4[E2];
        try {
          t4[E2] = void 0;
          var o3 = true;
        } catch (t5) {
        }
        var n3 = x2.call(t4);
        return o3 && (e4 ? t4[E2] = r4 : delete t4[E2]), n3;
      };
      var C2 = Object.prototype.toString;
      const P2 = function(t4) {
        return C2.call(t4);
      };
      var A2 = m2 ? m2.toStringTag : void 0;
      const W2 = function(t4) {
        return null == t4 ? void 0 === t4 ? "[object Undefined]" : "[object Null]" : A2 && A2 in Object(t4) ? O2(t4) : P2(t4);
      };
      const T2 = function(t4) {
        return null != t4 && "object" == typeof t4;
      };
      const S2 = function(t4) {
        return "symbol" == typeof t4 || T2(t4) && "[object Symbol]" == W2(t4);
      };
      var R2 = /^[-+]0x[0-9a-f]+$/i, I2 = /^0b[01]+$/i, D2 = /^0o[0-7]+$/i, z2 = parseInt;
      const M2 = function(t4) {
        if ("number" == typeof t4)
          return t4;
        if (S2(t4))
          return NaN;
        if (d2(t4)) {
          var e4 = "function" == typeof t4.valueOf ? t4.valueOf() : t4;
          t4 = d2(e4) ? e4 + "" : e4;
        }
        if ("string" != typeof t4)
          return 0 === t4 ? t4 : +t4;
        t4 = v2(t4);
        var r4 = I2.test(t4);
        return r4 || D2.test(t4) ? z2(t4.slice(2), r4 ? 2 : 8) : R2.test(t4) ? NaN : +t4;
      };
      var U2 = Math.max, N2 = Math.min;
      const F2 = function(t4, e4, r4) {
        var o3, n3, i3, s3, a3, c3, u3 = 0, h3 = false, l3 = false, p3 = true;
        if ("function" != typeof t4)
          throw new TypeError("Expected a function");
        function f3(e5) {
          var r5 = o3, i4 = n3;
          return o3 = n3 = void 0, u3 = e5, s3 = t4.apply(i4, r5);
        }
        function y3(t5) {
          var r5 = t5 - c3;
          return void 0 === c3 || r5 >= e4 || r5 < 0 || l3 && t5 - u3 >= i3;
        }
        function g3() {
          var t5 = _2();
          if (y3(t5))
            return b3(t5);
          a3 = setTimeout(g3, function(t6) {
            var r5 = e4 - (t6 - c3);
            return l3 ? N2(r5, i3 - (t6 - u3)) : r5;
          }(t5));
        }
        function b3(t5) {
          return a3 = void 0, p3 && o3 ? f3(t5) : (o3 = n3 = void 0, s3);
        }
        function v3() {
          var t5 = _2(), r5 = y3(t5);
          if (o3 = arguments, n3 = this, c3 = t5, r5) {
            if (void 0 === a3)
              return function(t6) {
                return u3 = t6, a3 = setTimeout(g3, e4), h3 ? f3(t6) : s3;
              }(c3);
            if (l3)
              return clearTimeout(a3), a3 = setTimeout(g3, e4), f3(c3);
          }
          return void 0 === a3 && (a3 = setTimeout(g3, e4)), s3;
        }
        return e4 = M2(e4) || 0, d2(r4) && (h3 = !!r4.leading, i3 = (l3 = "maxWait" in r4) ? U2(M2(r4.maxWait) || 0, e4) : i3, p3 = "trailing" in r4 ? !!r4.trailing : p3), v3.cancel = function() {
          void 0 !== a3 && clearTimeout(a3), u3 = 0, o3 = c3 = n3 = a3 = void 0;
        }, v3.flush = function() {
          return void 0 === a3 ? s3 : b3(_2());
        }, v3;
      };
      const q2 = function(t4, e4, r4) {
        var o3 = true, n3 = true;
        if ("function" != typeof t4)
          throw new TypeError("Expected a function");
        return d2(r4) && (o3 = "leading" in r4 ? !!r4.leading : o3, n3 = "trailing" in r4 ? !!r4.trailing : n3), F2(t4, e4, { leading: o3, maxWait: e4, trailing: n3 });
      };
      const L2 = function() {
        this.__data__ = [], this.size = 0;
      };
      const k2 = function(t4, e4) {
        return t4 === e4 || t4 != t4 && e4 != e4;
      };
      const B2 = function(t4, e4) {
        for (var r4 = t4.length; r4--; )
          if (k2(t4[r4][0], e4))
            return r4;
        return -1;
      };
      var $2 = Array.prototype.splice;
      const H2 = function(t4) {
        var e4 = this.__data__, r4 = B2(e4, t4);
        return !(r4 < 0) && (r4 == e4.length - 1 ? e4.pop() : $2.call(e4, r4, 1), --this.size, true);
      };
      const V2 = function(t4) {
        var e4 = this.__data__, r4 = B2(e4, t4);
        return r4 < 0 ? void 0 : e4[r4][1];
      };
      const K2 = function(t4) {
        return B2(this.__data__, t4) > -1;
      };
      const Q2 = function(t4, e4) {
        var r4 = this.__data__, o3 = B2(r4, t4);
        return o3 < 0 ? (++this.size, r4.push([t4, e4])) : r4[o3][1] = e4, this;
      };
      function G2(t4) {
        var e4 = -1, r4 = null == t4 ? 0 : t4.length;
        for (this.clear(); ++e4 < r4; ) {
          var o3 = t4[e4];
          this.set(o3[0], o3[1]);
        }
      }
      G2.prototype.clear = L2, G2.prototype.delete = H2, G2.prototype.get = V2, G2.prototype.has = K2, G2.prototype.set = Q2;
      const Y2 = G2;
      const J2 = function() {
        this.__data__ = new Y2(), this.size = 0;
      };
      const X2 = function(t4) {
        var e4 = this.__data__, r4 = e4.delete(t4);
        return this.size = e4.size, r4;
      };
      const Z2 = function(t4) {
        return this.__data__.get(t4);
      };
      const tt2 = function(t4) {
        return this.__data__.has(t4);
      };
      const et2 = function(t4) {
        if (!d2(t4))
          return false;
        var e4 = W2(t4);
        return "[object Function]" == e4 || "[object GeneratorFunction]" == e4 || "[object AsyncFunction]" == e4 || "[object Proxy]" == e4;
      };
      const rt2 = f2["__core-js_shared__"];
      var ot2 = function() {
        var t4 = /[^.]+$/.exec(rt2 && rt2.keys && rt2.keys.IE_PROTO || "");
        return t4 ? "Symbol(src)_1." + t4 : "";
      }();
      const nt2 = function(t4) {
        return !!ot2 && ot2 in t4;
      };
      var it2 = Function.prototype.toString;
      const st2 = function(t4) {
        if (null != t4) {
          try {
            return it2.call(t4);
          } catch (t5) {
          }
          try {
            return t4 + "";
          } catch (t5) {
          }
        }
        return "";
      };
      var at2 = /^\[object .+?Constructor\]$/, ct2 = Function.prototype, ut2 = Object.prototype, ht2 = ct2.toString, dt2 = ut2.hasOwnProperty, lt2 = RegExp("^" + ht2.call(dt2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      const pt2 = function(t4) {
        return !(!d2(t4) || nt2(t4)) && (et2(t4) ? lt2 : at2).test(st2(t4));
      };
      const ft2 = function(t4, e4) {
        return null == t4 ? void 0 : t4[e4];
      };
      const _t5 = function(t4, e4) {
        var r4 = ft2(t4, e4);
        return pt2(r4) ? r4 : void 0;
      };
      const yt2 = _t5(f2, "Map");
      const gt2 = _t5(Object, "create");
      const bt2 = function() {
        this.__data__ = gt2 ? gt2(null) : {}, this.size = 0;
      };
      const vt2 = function(t4) {
        var e4 = this.has(t4) && delete this.__data__[t4];
        return this.size -= e4 ? 1 : 0, e4;
      };
      var mt2 = Object.prototype.hasOwnProperty;
      const jt2 = function(t4) {
        var e4 = this.__data__;
        if (gt2) {
          var r4 = e4[t4];
          return "__lodash_hash_undefined__" === r4 ? void 0 : r4;
        }
        return mt2.call(e4, t4) ? e4[t4] : void 0;
      };
      var wt2 = Object.prototype.hasOwnProperty;
      const xt2 = function(t4) {
        var e4 = this.__data__;
        return gt2 ? void 0 !== e4[t4] : wt2.call(e4, t4);
      };
      const Et2 = function(t4, e4) {
        var r4 = this.__data__;
        return this.size += this.has(t4) ? 0 : 1, r4[t4] = gt2 && void 0 === e4 ? "__lodash_hash_undefined__" : e4, this;
      };
      function Ot2(t4) {
        var e4 = -1, r4 = null == t4 ? 0 : t4.length;
        for (this.clear(); ++e4 < r4; ) {
          var o3 = t4[e4];
          this.set(o3[0], o3[1]);
        }
      }
      Ot2.prototype.clear = bt2, Ot2.prototype.delete = vt2, Ot2.prototype.get = jt2, Ot2.prototype.has = xt2, Ot2.prototype.set = Et2;
      const Ct2 = Ot2;
      const Pt2 = function() {
        this.size = 0, this.__data__ = { hash: new Ct2(), map: new (yt2 || Y2)(), string: new Ct2() };
      };
      const At = function(t4) {
        var e4 = typeof t4;
        return "string" == e4 || "number" == e4 || "symbol" == e4 || "boolean" == e4 ? "__proto__" !== t4 : null === t4;
      };
      const Wt2 = function(t4, e4) {
        var r4 = t4.__data__;
        return At(e4) ? r4["string" == typeof e4 ? "string" : "hash"] : r4.map;
      };
      const Tt2 = function(t4) {
        var e4 = Wt2(this, t4).delete(t4);
        return this.size -= e4 ? 1 : 0, e4;
      };
      const St2 = function(t4) {
        return Wt2(this, t4).get(t4);
      };
      const Rt2 = function(t4) {
        return Wt2(this, t4).has(t4);
      };
      const It2 = function(t4, e4) {
        var r4 = Wt2(this, t4), o3 = r4.size;
        return r4.set(t4, e4), this.size += r4.size == o3 ? 0 : 1, this;
      };
      function Dt2(t4) {
        var e4 = -1, r4 = null == t4 ? 0 : t4.length;
        for (this.clear(); ++e4 < r4; ) {
          var o3 = t4[e4];
          this.set(o3[0], o3[1]);
        }
      }
      Dt2.prototype.clear = Pt2, Dt2.prototype.delete = Tt2, Dt2.prototype.get = St2, Dt2.prototype.has = Rt2, Dt2.prototype.set = It2;
      const zt2 = Dt2;
      const Mt2 = function(t4, e4) {
        var r4 = this.__data__;
        if (r4 instanceof Y2) {
          var o3 = r4.__data__;
          if (!yt2 || o3.length < 199)
            return o3.push([t4, e4]), this.size = ++r4.size, this;
          r4 = this.__data__ = new zt2(o3);
        }
        return r4.set(t4, e4), this.size = r4.size, this;
      };
      function Ut2(t4) {
        var e4 = this.__data__ = new Y2(t4);
        this.size = e4.size;
      }
      Ut2.prototype.clear = J2, Ut2.prototype.delete = X2, Ut2.prototype.get = Z2, Ut2.prototype.has = tt2, Ut2.prototype.set = Mt2;
      const Nt2 = Ut2;
      const Ft2 = function(t4, e4) {
        for (var r4 = -1, o3 = null == t4 ? 0 : t4.length; ++r4 < o3 && false !== e4(t4[r4], r4, t4); )
          ;
        return t4;
      };
      const qt2 = function() {
        try {
          var t4 = _t5(Object, "defineProperty");
          return t4({}, "", {}), t4;
        } catch (t5) {
        }
      }();
      const Lt2 = function(t4, e4, r4) {
        "__proto__" == e4 && qt2 ? qt2(t4, e4, { configurable: true, enumerable: true, value: r4, writable: true }) : t4[e4] = r4;
      };
      var kt2 = Object.prototype.hasOwnProperty;
      const Bt2 = function(t4, e4, r4) {
        var o3 = t4[e4];
        kt2.call(t4, e4) && k2(o3, r4) && (void 0 !== r4 || e4 in t4) || Lt2(t4, e4, r4);
      };
      const $t2 = function(t4, e4, r4, o3) {
        var n3 = !r4;
        r4 || (r4 = {});
        for (var i3 = -1, s3 = e4.length; ++i3 < s3; ) {
          var a3 = e4[i3], c3 = o3 ? o3(r4[a3], t4[a3], a3, r4, t4) : void 0;
          void 0 === c3 && (c3 = t4[a3]), n3 ? Lt2(r4, a3, c3) : Bt2(r4, a3, c3);
        }
        return r4;
      };
      const Ht2 = function(t4, e4) {
        for (var r4 = -1, o3 = Array(t4); ++r4 < t4; )
          o3[r4] = e4(r4);
        return o3;
      };
      const Vt2 = function(t4) {
        return T2(t4) && "[object Arguments]" == W2(t4);
      };
      var Kt2 = Object.prototype, Qt2 = Kt2.hasOwnProperty, Gt2 = Kt2.propertyIsEnumerable;
      const Yt2 = Vt2(function() {
        return arguments;
      }()) ? Vt2 : function(t4) {
        return T2(t4) && Qt2.call(t4, "callee") && !Gt2.call(t4, "callee");
      };
      const Jt2 = Array.isArray;
      const Xt2 = function() {
        return false;
      };
      var Zt2 = exports && !exports.nodeType && exports, te2 = Zt2 && true && module && !module.nodeType && module, ee2 = te2 && te2.exports === Zt2 ? f2.Buffer : void 0;
      const re2 = (ee2 ? ee2.isBuffer : void 0) || Xt2;
      var oe2 = /^(?:0|[1-9]\d*)$/;
      const ne2 = function(t4, e4) {
        var r4 = typeof t4;
        return !!(e4 = null == e4 ? 9007199254740991 : e4) && ("number" == r4 || "symbol" != r4 && oe2.test(t4)) && t4 > -1 && t4 % 1 == 0 && t4 < e4;
      };
      const ie2 = function(t4) {
        return "number" == typeof t4 && t4 > -1 && t4 % 1 == 0 && t4 <= 9007199254740991;
      };
      var se2 = {};
      se2["[object Float32Array]"] = se2["[object Float64Array]"] = se2["[object Int8Array]"] = se2["[object Int16Array]"] = se2["[object Int32Array]"] = se2["[object Uint8Array]"] = se2["[object Uint8ClampedArray]"] = se2["[object Uint16Array]"] = se2["[object Uint32Array]"] = true, se2["[object Arguments]"] = se2["[object Array]"] = se2["[object ArrayBuffer]"] = se2["[object Boolean]"] = se2["[object DataView]"] = se2["[object Date]"] = se2["[object Error]"] = se2["[object Function]"] = se2["[object Map]"] = se2["[object Number]"] = se2["[object Object]"] = se2["[object RegExp]"] = se2["[object Set]"] = se2["[object String]"] = se2["[object WeakMap]"] = false;
      const ae2 = function(t4) {
        return T2(t4) && ie2(t4.length) && !!se2[W2(t4)];
      };
      const ce2 = function(t4) {
        return function(e4) {
          return t4(e4);
        };
      };
      var ue2 = exports && !exports.nodeType && exports, he2 = ue2 && true && module && !module.nodeType && module, de2 = he2 && he2.exports === ue2 && l2.process;
      const le2 = function() {
        try {
          var t4 = he2 && he2.require && he2.require("util").types;
          return t4 || de2 && de2.binding && de2.binding("util");
        } catch (t5) {
        }
      }();
      var pe2 = le2 && le2.isTypedArray;
      const fe2 = pe2 ? ce2(pe2) : ae2;
      var _e2 = Object.prototype.hasOwnProperty;
      const ye2 = function(t4, e4) {
        var r4 = Jt2(t4), o3 = !r4 && Yt2(t4), n3 = !r4 && !o3 && re2(t4), i3 = !r4 && !o3 && !n3 && fe2(t4), s3 = r4 || o3 || n3 || i3, a3 = s3 ? Ht2(t4.length, String) : [], c3 = a3.length;
        for (var u3 in t4)
          !e4 && !_e2.call(t4, u3) || s3 && ("length" == u3 || n3 && ("offset" == u3 || "parent" == u3) || i3 && ("buffer" == u3 || "byteLength" == u3 || "byteOffset" == u3) || ne2(u3, c3)) || a3.push(u3);
        return a3;
      };
      var ge2 = Object.prototype;
      const be2 = function(t4) {
        var e4 = t4 && t4.constructor;
        return t4 === ("function" == typeof e4 && e4.prototype || ge2);
      };
      const ve2 = function(t4, e4) {
        return function(r4) {
          return t4(e4(r4));
        };
      };
      const me2 = ve2(Object.keys, Object);
      var je2 = Object.prototype.hasOwnProperty;
      const we2 = function(t4) {
        if (!be2(t4))
          return me2(t4);
        var e4 = [];
        for (var r4 in Object(t4))
          je2.call(t4, r4) && "constructor" != r4 && e4.push(r4);
        return e4;
      };
      const xe2 = function(t4) {
        return null != t4 && ie2(t4.length) && !et2(t4);
      };
      const Ee2 = function(t4) {
        return xe2(t4) ? ye2(t4) : we2(t4);
      };
      const Oe2 = function(t4, e4) {
        return t4 && $t2(e4, Ee2(e4), t4);
      };
      const Ce2 = function(t4) {
        var e4 = [];
        if (null != t4)
          for (var r4 in Object(t4))
            e4.push(r4);
        return e4;
      };
      var Pe2 = Object.prototype.hasOwnProperty;
      const Ae2 = function(t4) {
        if (!d2(t4))
          return Ce2(t4);
        var e4 = be2(t4), r4 = [];
        for (var o3 in t4)
          ("constructor" != o3 || !e4 && Pe2.call(t4, o3)) && r4.push(o3);
        return r4;
      };
      const We2 = function(t4) {
        return xe2(t4) ? ye2(t4, true) : Ae2(t4);
      };
      const Te2 = function(t4, e4) {
        return t4 && $t2(e4, We2(e4), t4);
      };
      var Se2 = exports && !exports.nodeType && exports, Re2 = Se2 && true && module && !module.nodeType && module, Ie2 = Re2 && Re2.exports === Se2 ? f2.Buffer : void 0, De2 = Ie2 ? Ie2.allocUnsafe : void 0;
      const ze2 = function(t4, e4) {
        if (e4)
          return t4.slice();
        var r4 = t4.length, o3 = De2 ? De2(r4) : new t4.constructor(r4);
        return t4.copy(o3), o3;
      };
      const Me2 = function(t4, e4) {
        var r4 = -1, o3 = t4.length;
        for (e4 || (e4 = Array(o3)); ++r4 < o3; )
          e4[r4] = t4[r4];
        return e4;
      };
      const Ue2 = function(t4, e4) {
        for (var r4 = -1, o3 = null == t4 ? 0 : t4.length, n3 = 0, i3 = []; ++r4 < o3; ) {
          var s3 = t4[r4];
          e4(s3, r4, t4) && (i3[n3++] = s3);
        }
        return i3;
      };
      const Ne2 = function() {
        return [];
      };
      var Fe2 = Object.prototype.propertyIsEnumerable, qe2 = Object.getOwnPropertySymbols;
      const Le2 = qe2 ? function(t4) {
        return null == t4 ? [] : (t4 = Object(t4), Ue2(qe2(t4), function(e4) {
          return Fe2.call(t4, e4);
        }));
      } : Ne2;
      const ke2 = function(t4, e4) {
        return $t2(t4, Le2(t4), e4);
      };
      const Be2 = function(t4, e4) {
        for (var r4 = -1, o3 = e4.length, n3 = t4.length; ++r4 < o3; )
          t4[n3 + r4] = e4[r4];
        return t4;
      };
      const $e2 = ve2(Object.getPrototypeOf, Object);
      const He2 = Object.getOwnPropertySymbols ? function(t4) {
        for (var e4 = []; t4; )
          Be2(e4, Le2(t4)), t4 = $e2(t4);
        return e4;
      } : Ne2;
      const Ve2 = function(t4, e4) {
        return $t2(t4, He2(t4), e4);
      };
      const Ke2 = function(t4, e4, r4) {
        var o3 = e4(t4);
        return Jt2(t4) ? o3 : Be2(o3, r4(t4));
      };
      const Qe2 = function(t4) {
        return Ke2(t4, Ee2, Le2);
      };
      const Ge2 = function(t4) {
        return Ke2(t4, We2, He2);
      };
      const Ye2 = _t5(f2, "DataView");
      const Je2 = _t5(f2, "Promise");
      const Xe2 = _t5(f2, "Set");
      const Ze2 = _t5(f2, "WeakMap");
      var tr = "[object Map]", er = "[object Promise]", rr = "[object Set]", or = "[object WeakMap]", nr = "[object DataView]", ir = st2(Ye2), sr = st2(yt2), ar = st2(Je2), cr = st2(Xe2), ur = st2(Ze2), hr = W2;
      (Ye2 && hr(new Ye2(new ArrayBuffer(1))) != nr || yt2 && hr(new yt2()) != tr || Je2 && hr(Je2.resolve()) != er || Xe2 && hr(new Xe2()) != rr || Ze2 && hr(new Ze2()) != or) && (hr = function(t4) {
        var e4 = W2(t4), r4 = "[object Object]" == e4 ? t4.constructor : void 0, o3 = r4 ? st2(r4) : "";
        if (o3)
          switch (o3) {
            case ir:
              return nr;
            case sr:
              return tr;
            case ar:
              return er;
            case cr:
              return rr;
            case ur:
              return or;
          }
        return e4;
      });
      const dr = hr;
      var lr = Object.prototype.hasOwnProperty;
      const pr = function(t4) {
        var e4 = t4.length, r4 = new t4.constructor(e4);
        return e4 && "string" == typeof t4[0] && lr.call(t4, "index") && (r4.index = t4.index, r4.input = t4.input), r4;
      };
      const fr = f2.Uint8Array;
      const _r = function(t4) {
        var e4 = new t4.constructor(t4.byteLength);
        return new fr(e4).set(new fr(t4)), e4;
      };
      const yr = function(t4, e4) {
        var r4 = e4 ? _r(t4.buffer) : t4.buffer;
        return new t4.constructor(r4, t4.byteOffset, t4.byteLength);
      };
      var gr = /\w*$/;
      const br = function(t4) {
        var e4 = new t4.constructor(t4.source, gr.exec(t4));
        return e4.lastIndex = t4.lastIndex, e4;
      };
      var vr = m2 ? m2.prototype : void 0, mr = vr ? vr.valueOf : void 0;
      const jr = function(t4) {
        return mr ? Object(mr.call(t4)) : {};
      };
      const wr = function(t4, e4) {
        var r4 = e4 ? _r(t4.buffer) : t4.buffer;
        return new t4.constructor(r4, t4.byteOffset, t4.length);
      };
      const xr = function(t4, e4, r4) {
        var o3 = t4.constructor;
        switch (e4) {
          case "[object ArrayBuffer]":
            return _r(t4);
          case "[object Boolean]":
          case "[object Date]":
            return new o3(+t4);
          case "[object DataView]":
            return yr(t4, r4);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return wr(t4, r4);
          case "[object Map]":
          case "[object Set]":
            return new o3();
          case "[object Number]":
          case "[object String]":
            return new o3(t4);
          case "[object RegExp]":
            return br(t4);
          case "[object Symbol]":
            return jr(t4);
        }
      };
      var Er = Object.create;
      const Or = function() {
        function t4() {
        }
        return function(e4) {
          if (!d2(e4))
            return {};
          if (Er)
            return Er(e4);
          t4.prototype = e4;
          var r4 = new t4();
          return t4.prototype = void 0, r4;
        };
      }();
      const Cr = function(t4) {
        return "function" != typeof t4.constructor || be2(t4) ? {} : Or($e2(t4));
      };
      const Pr = function(t4) {
        return T2(t4) && "[object Map]" == dr(t4);
      };
      var Ar = le2 && le2.isMap;
      const Wr = Ar ? ce2(Ar) : Pr;
      const Tr = function(t4) {
        return T2(t4) && "[object Set]" == dr(t4);
      };
      var Sr = le2 && le2.isSet;
      const Rr = Sr ? ce2(Sr) : Tr;
      var Ir = "[object Arguments]", Dr = "[object Function]", zr = "[object Object]", Mr = {};
      Mr[Ir] = Mr["[object Array]"] = Mr["[object ArrayBuffer]"] = Mr["[object DataView]"] = Mr["[object Boolean]"] = Mr["[object Date]"] = Mr["[object Float32Array]"] = Mr["[object Float64Array]"] = Mr["[object Int8Array]"] = Mr["[object Int16Array]"] = Mr["[object Int32Array]"] = Mr["[object Map]"] = Mr["[object Number]"] = Mr[zr] = Mr["[object RegExp]"] = Mr["[object Set]"] = Mr["[object String]"] = Mr["[object Symbol]"] = Mr["[object Uint8Array]"] = Mr["[object Uint8ClampedArray]"] = Mr["[object Uint16Array]"] = Mr["[object Uint32Array]"] = true, Mr["[object Error]"] = Mr[Dr] = Mr["[object WeakMap]"] = false;
      const Ur = function t4(e4, r4, o3, n3, i3, s3) {
        var a3, c3 = 1 & r4, u3 = 2 & r4, h3 = 4 & r4;
        if (o3 && (a3 = i3 ? o3(e4, n3, i3, s3) : o3(e4)), void 0 !== a3)
          return a3;
        if (!d2(e4))
          return e4;
        var l3 = Jt2(e4);
        if (l3) {
          if (a3 = pr(e4), !c3)
            return Me2(e4, a3);
        } else {
          var p3 = dr(e4), f3 = p3 == Dr || "[object GeneratorFunction]" == p3;
          if (re2(e4))
            return ze2(e4, c3);
          if (p3 == zr || p3 == Ir || f3 && !i3) {
            if (a3 = u3 || f3 ? {} : Cr(e4), !c3)
              return u3 ? Ve2(e4, Te2(a3, e4)) : ke2(e4, Oe2(a3, e4));
          } else {
            if (!Mr[p3])
              return i3 ? e4 : {};
            a3 = xr(e4, p3, c3);
          }
        }
        s3 || (s3 = new Nt2());
        var _3 = s3.get(e4);
        if (_3)
          return _3;
        s3.set(e4, a3), Rr(e4) ? e4.forEach(function(n4) {
          a3.add(t4(n4, r4, o3, n4, e4, s3));
        }) : Wr(e4) && e4.forEach(function(n4, i4) {
          a3.set(i4, t4(n4, r4, o3, i4, e4, s3));
        });
        var y3 = l3 ? void 0 : (h3 ? u3 ? Ge2 : Qe2 : u3 ? We2 : Ee2)(e4);
        return Ft2(y3 || e4, function(n4, i4) {
          y3 && (n4 = e4[i4 = n4]), Bt2(a3, i4, t4(n4, r4, o3, i4, e4, s3));
        }), a3;
      };
      const Nr = function(t4, e4) {
        return Ur(t4, 5, e4 = "function" == typeof e4 ? e4 : void 0);
      };
      var Fr = Function.prototype, qr = Object.prototype, Lr = Fr.toString, kr = qr.hasOwnProperty, Br = Lr.call(Object);
      const $r = function(t4) {
        if (!T2(t4) || "[object Object]" != W2(t4))
          return false;
        var e4 = $e2(t4);
        if (null === e4)
          return true;
        var r4 = kr.call(e4, "constructor") && e4.constructor;
        return "function" == typeof r4 && r4 instanceof r4 && Lr.call(r4) == Br;
      };
      const Hr = function(t4) {
        return T2(t4) && 1 === t4.nodeType && !$r(t4);
      };
      class Vr extends a2 {
        constructor(t4, e4 = {}) {
          super(e4), this._editor = null, this._throttledSave = q2(this._save.bind(this), "number" == typeof e4.saveInterval ? e4.saveInterval : 5e3), t4 && (this._creator = (e5, r4) => t4.create(e5, r4)), this._destructor = (t5) => t5.destroy();
        }
        get editor() {
          return this._editor;
        }
        get _item() {
          return this._editor;
        }
        setCreator(t4) {
          this._creator = t4;
        }
        setDestructor(t4) {
          this._destructor = t4;
        }
        _restart() {
          return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((t4) => {
            console.error("An error happened during the editor destroying.", t4);
          }).then(() => {
            if ("string" == typeof this._elementOrData)
              return this.create(this._data, this._config, this._config.context);
            {
              const t4 = Object.assign({}, this._config, { initialData: this._data });
              return this.create(this._elementOrData, t4, t4.context);
            }
          }).then(() => {
            this._fire("restart");
          });
        }
        create(t4 = this._elementOrData, e4 = this._config, r4) {
          return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = t4, this._config = this._cloneEditorConfiguration(e4) || {}, this._config.context = r4, this._creator(t4, this._config))).then((t5) => {
            this._editor = t5, t5.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = t5.model.document.version, this._data = this._getData(), this.state = "ready", this._fire("stateChange");
          });
        }
        destroy() {
          return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling(), this._throttledSave.flush();
            const t4 = this._editor;
            return this._editor = null, t4.model.document.off("change:data", this._throttledSave), this._destructor(t4);
          });
        }
        _save() {
          const t4 = this._editor.model.document.version;
          try {
            this._data = this._getData(), this._lastDocumentVersion = t4;
          } catch (t5) {
            console.error(t5, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
          }
        }
        _setExcludedProperties(t4) {
          this._excludedProps = t4;
        }
        _getData() {
          const t4 = {};
          for (const e4 of this._editor.model.document.getRootNames())
            t4[e4] = this._editor.data.get({ rootName: e4 });
          return t4;
        }
        _isErrorComingFromThisItem(t4) {
          return h2(this._editor, t4.context, this._excludedProps);
        }
        _cloneEditorConfiguration(t4) {
          return Nr(t4, (t5, e4) => Hr(t5) || "context" === e4 ? t5 : void 0);
        }
      }
      const Kr = Symbol("MainQueueId");
      class Qr extends a2 {
        constructor(t4, e4 = {}) {
          super(e4), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Gr(), this._watchdogConfig = e4, this._creator = (e5) => t4.create(e5), this._destructor = (t5) => t5.destroy(), this._actionQueues.onEmpty(() => {
            "initializing" === this.state && (this.state = "ready", this._fire("stateChange"));
          });
        }
        setCreator(t4) {
          this._creator = t4;
        }
        setDestructor(t4) {
          this._destructor = t4;
        }
        get context() {
          return this._context;
        }
        create(t4 = {}) {
          return this._actionQueues.enqueue(Kr, () => (this._contextConfig = t4, this._create()));
        }
        getItem(t4) {
          return this._getWatchdog(t4)._item;
        }
        getItemState(t4) {
          return this._getWatchdog(t4).state;
        }
        add(t4) {
          const e4 = Yr(t4);
          return Promise.all(e4.map((t5) => this._actionQueues.enqueue(t5.id, () => {
            if ("destroyed" === this.state)
              throw new Error("Cannot add items to destroyed watchdog.");
            if (!this._context)
              throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            let e5;
            if (this._watchdogs.has(t5.id))
              throw new Error(`Item with the given id is already added: '${t5.id}'.`);
            if ("editor" === t5.type)
              return e5 = new Vr(null, this._watchdogConfig), e5.setCreator(t5.creator), e5._setExcludedProperties(this._contextProps), t5.destructor && e5.setDestructor(t5.destructor), this._watchdogs.set(t5.id, e5), e5.on("error", (r4, { error: o3, causesRestart: n3 }) => {
                this._fire("itemError", { itemId: t5.id, error: o3 }), n3 && this._actionQueues.enqueue(t5.id, () => new Promise((r5) => {
                  const o4 = () => {
                    e5.off("restart", o4), this._fire("itemRestart", { itemId: t5.id }), r5();
                  };
                  e5.on("restart", o4);
                }));
              }), e5.create(t5.sourceElementOrData, t5.config, this._context);
            throw new Error(`Not supported item type: '${t5.type}'.`);
          })));
        }
        remove(t4) {
          const e4 = Yr(t4);
          return Promise.all(e4.map((t5) => this._actionQueues.enqueue(t5, () => {
            const e5 = this._getWatchdog(t5);
            return this._watchdogs.delete(t5), e5.destroy();
          })));
        }
        destroy() {
          return this._actionQueues.enqueue(Kr, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _restart() {
          return this._actionQueues.enqueue(Kr, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((t4) => {
            console.error("An error happened during destroying the context or items.", t4);
          }).then(() => this._create()).then(() => this._fire("restart"))));
        }
        _create() {
          return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((t4) => (this._context = t4, this._contextProps = c2(this._context), Promise.all(Array.from(this._watchdogs.values()).map((t5) => (t5._setExcludedProperties(this._contextProps), t5.create(void 0, void 0, this._context))))));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const t4 = this._context;
            return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((t5) => t5.destroy())).then(() => this._destructor(t4));
          });
        }
        _getWatchdog(t4) {
          const e4 = this._watchdogs.get(t4);
          if (!e4)
            throw new Error(`Item with the given id was not registered: ${t4}.`);
          return e4;
        }
        _isErrorComingFromThisItem(t4) {
          for (const e4 of this._watchdogs.values())
            if (e4._isErrorComingFromThisItem(t4))
              return false;
          return h2(this._context, t4.context);
        }
      }
      class Gr {
        constructor() {
          this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
        }
        onEmpty(t4) {
          this._onEmptyCallbacks.push(t4);
        }
        enqueue(t4, e4) {
          const r4 = t4 === Kr;
          this._activeActions++, this._queues.get(t4) || this._queues.set(t4, Promise.resolve());
          const o3 = (r4 ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Kr), this._queues.get(t4)])).then(e4), n3 = o3.catch(() => {
          });
          return this._queues.set(t4, n3), o3.finally(() => {
            this._activeActions--, this._queues.get(t4) === n3 && 0 === this._activeActions && this._onEmptyCallbacks.forEach((t5) => t5());
          });
        }
      }
      function Yr(t4) {
        return Array.isArray(t4) ? t4 : [t4];
      }
      const Jr = e3().createContext("contextWatchdog");
      class Xr extends e3().Component {
        constructor(t4, e4) {
          super(t4, e4), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);
        }
        shouldComponentUpdate(t4) {
          return this._shouldComponentUpdate(t4);
        }
        async _shouldComponentUpdate(t4) {
          return t4.id !== this.props.id && (this.contextWatchdog && await this.contextWatchdog.destroy(), await this._initializeContextWatchdog(t4.config)), t4.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t4.config), true) : this.props.children !== t4.children;
        }
        render() {
          return e3().createElement(Jr.Provider, { value: this.contextWatchdog }, this.props.children);
        }
        componentWillUnmount() {
          this._destroyContext();
        }
        async _initializeContextWatchdog(t4) {
          this.contextWatchdog = new Qr(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on("error", (t5, e4) => {
            this.props.onError(e4.error, { phase: "runtime", willContextRestart: e4.causesRestart });
          }), this.contextWatchdog.on("stateChange", () => {
            "ready" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);
          }), await this.contextWatchdog.create(t4).catch((t5) => {
            this.props.onError(t5, { phase: "initialization", willContextRestart: false });
          });
        }
        async _destroyContext() {
          this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);
        }
      }
      Xr.defaultProps = { isLayoutReady: true, onError: (t4, e4) => console.error(t4, e4) }, Xr.propTypes = { id: i2().string, isLayoutReady: i2().bool, context: i2().func, watchdogConfig: i2().object, config: i2().object, onReady: i2().func, onError: i2().func };
      const Zr = "Lock from React integration (@ckeditor/ckeditor5-react)";
      class to2 extends e3().Component {
        constructor(t4) {
          super(t4), this.editorDestructionInProgress = null, this.domContainer = e3().createRef(), this.watchdog = null;
          const { CKEDITOR_VERSION: r4 } = window;
          if (r4) {
            const [t5] = r4.split(".").map(Number);
            t5 < 37 && console.warn("The <CKEditor> component requires using CKEditor 5 in version 37 or higher.");
          } else
            console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
        }
        get editor() {
          return this.props.disableWatchdog ? this.instance : this.watchdog ? this.watchdog.editor : null;
        }
        shouldComponentUpdate(t4) {
          return !!this.editor && (t4.id !== this.props.id || (t4.disableWatchdog !== this.props.disableWatchdog || (this._shouldUpdateEditor(t4) && this.editor.data.set(t4.data), "disabled" in t4 && (t4.disabled ? this.editor.enableReadOnlyMode(Zr) : this.editor.disableReadOnlyMode(Zr)), false)));
        }
        async componentDidMount() {
          await this._initializeEditor();
        }
        async componentDidUpdate() {
          await this._destroyEditor(), await this._initializeEditor();
        }
        async componentWillUnmount() {
          await this._destroyEditor();
        }
        render() {
          return e3().createElement("div", { ref: this.domContainer });
        }
        async _initializeEditor() {
          await this.editorDestructionInProgress, this.props.disableWatchdog ? this.instance = await this._createEditor(this.domContainer.current, this._getConfig()) : this.watchdog || (this.context instanceof Qr ? this.watchdog = new eo2(this.context) : this.watchdog = new to2._EditorWatchdog(this.props.editor, this.props.watchdogConfig), this.watchdog.setCreator((t4, e4) => this._createEditor(t4, e4)), this.watchdog.on("error", (t4, { error: e4, causesRestart: r4 }) => {
            (this.props.onError || console.error)(e4, { phase: "runtime", willEditorRestart: r4 });
          }), await this.watchdog.create(this.domContainer.current, this._getConfig()).catch((t4) => {
            (this.props.onError || console.error)(t4, { phase: "initialization", willEditorRestart: false });
          }));
        }
        _createEditor(t4, e4) {
          return this.props.editor.create(t4, e4).then((t5) => {
            "disabled" in this.props && this.props.disabled && t5.enableReadOnlyMode(Zr);
            const e5 = t5.model.document, r4 = t5.editing.view.document;
            return e5.on("change:data", (e6) => {
              this.props.onChange && this.props.onChange(e6, t5);
            }), r4.on("focus", (e6) => {
              this.props.onFocus && this.props.onFocus(e6, t5);
            }), r4.on("blur", (e6) => {
              this.props.onBlur && this.props.onBlur(e6, t5);
            }), setTimeout(() => {
              this.props.onReady && this.props.onReady(t5);
            }), t5;
          });
        }
        async _destroyEditor() {
          this.editorDestructionInProgress = new Promise((t4) => {
            setTimeout(async () => this.watchdog ? (await this.watchdog.destroy(), this.watchdog = null, t4()) : this.instance ? (await this.instance.destroy(), this.instance = null, t4()) : void t4());
          });
        }
        _shouldUpdateEditor(t4) {
          return this.props.data !== t4.data && this.editor.data.get() !== t4.data;
        }
        _getConfig() {
          const t4 = this.props.config || {};
          return this.props.data && t4.initialData && console.warn("Editor data should be provided either using `config.initialData` or `data` properties. The config property is over the data value and the first one will be used when specified both."), { ...t4, initialData: t4.initialData || this.props.data || "" };
        }
      }
      to2.contextType = Jr, to2.propTypes = { editor: i2().func.isRequired, data: i2().string, config: i2().object, disableWatchdog: i2().bool, watchdogConfig: i2().object, onChange: i2().func, onReady: i2().func, onFocus: i2().func, onBlur: i2().func, onError: i2().func, disabled: i2().bool, id: i2().any }, to2._EditorWatchdog = Vr;
      class eo2 {
        constructor(t4) {
          this._contextWatchdog = t4, this._id = function() {
            const t5 = 4294967296 * Math.random() >>> 0, e4 = 4294967296 * Math.random() >>> 0, r4 = 4294967296 * Math.random() >>> 0, o3 = 4294967296 * Math.random() >>> 0;
            return "e" + s2[t5 >> 0 & 255] + s2[t5 >> 8 & 255] + s2[t5 >> 16 & 255] + s2[t5 >> 24 & 255] + s2[e4 >> 0 & 255] + s2[e4 >> 8 & 255] + s2[e4 >> 16 & 255] + s2[e4 >> 24 & 255] + s2[r4 >> 0 & 255] + s2[r4 >> 8 & 255] + s2[r4 >> 16 & 255] + s2[r4 >> 24 & 255] + s2[o3 >> 0 & 255] + s2[o3 >> 8 & 255] + s2[o3 >> 16 & 255] + s2[o3 >> 24 & 255];
          }();
        }
        setCreator(t4) {
          this._creator = t4;
        }
        create(t4, e4) {
          return this._contextWatchdog.add({ sourceElementOrData: t4, config: e4, creator: this._creator, id: this._id, type: "editor" });
        }
        on(t4, e4) {
          this._contextWatchdog.on("itemError", (t5, { itemId: r4, error: o3 }) => {
            r4 === this._id && e4(null, { error: o3, causesRestart: void 0 });
          });
        }
        destroy() {
          return "ready" === this._contextWatchdog.state ? this._contextWatchdog.remove(this._id) : Promise.resolve();
        }
        get editor() {
          return this._contextWatchdog.getItem(this._id);
        }
      }
    })(), n2;
  })());
})(dist, dist.exports);
var distExports = dist.exports;
var ckeditor = { exports: {} };
ckeditor.exports;
(function(module, exports) {
  !function(t2) {
    const e2 = t2.en = t2.en || {};
    e2.dictionary = Object.assign(e2.dictionary || {}, { "%0 of %1": "%0 of %1", Accept: "Accept", "Align cell text to the bottom": "Align cell text to the bottom", "Align cell text to the center": "Align cell text to the center", "Align cell text to the left": "Align cell text to the left", "Align cell text to the middle": "Align cell text to the middle", "Align cell text to the right": "Align cell text to the right", "Align cell text to the top": "Align cell text to the top", "Align table to the left": "Align table to the left", "Align table to the right": "Align table to the right", Alignment: "Alignment", Aquamarine: "Aquamarine", Background: "Background", Black: "Black", "Block quote": "Block quote", Blue: "Blue", Bold: "Bold", Border: "Border", "Break text": "Break text", "Bulleted List": "Bulleted List", "Bulleted list styles toolbar": "Bulleted list styles toolbar", Cancel: "Cancel", "Cannot access default workspace.": "Cannot access default workspace.", "Cannot determine a category for the uploaded file.": "Cannot determine a category for the uploaded file.", "Cannot upload file:": "Cannot upload file:", "Caption for image: %0": "Caption for image: %0", "Caption for the image": "Caption for the image", "Cell properties": "Cell properties", "Center table": "Center table", "Centered image": "Centered image", "Change image text alternative": "Change image text alternative", "Choose heading": "Choose heading", Circle: "Circle", Clear: "Clear", "Click to edit block": "Click to edit block", Code: "Code", Color: "Color", "Color picker": "Color picker", Column: "Column", "Could not insert image at the current position.": "Could not insert image at the current position.", "Could not obtain resized image URL.": "Could not obtain resized image URL.", Dashed: "Dashed", Decimal: "Decimal", "Decimal with leading zero": "Decimal with leading zero", "Decrease indent": "Decrease indent", "Delete column": "Delete column", "Delete row": "Delete row", "Dim grey": "Dim grey", Dimensions: "Dimensions", Disc: "Disc", Dotted: "Dotted", Double: "Double", Downloadable: "Downloadable", "Drag to move": "Drag to move", "Dropdown toolbar": "Dropdown toolbar", "Edit block": "Edit block", "Edit link": "Edit link", "Editor block content toolbar": "Editor block content toolbar", "Editor contextual toolbar": "Editor contextual toolbar", "Editor editing area: %0": "Editor editing area: %0", "Editor toolbar": "Editor toolbar", "Enter image caption": "Enter image caption", "Enter table caption": "Enter table caption", "Full size image": "Full size image", Green: "Green", Grey: "Grey", Groove: "Groove", "Header column": "Header column", "Header row": "Header row", Heading: "Heading", "Heading 1": "Heading 1", "Heading 2": "Heading 2", "Heading 3": "Heading 3", "Heading 4": "Heading 4", "Heading 5": "Heading 5", "Heading 6": "Heading 6", Height: "Height", HEX: "HEX", "Horizontal text alignment toolbar": "Horizontal text alignment toolbar", "Image resize list": "Image resize list", "Image toolbar": "Image toolbar", "image widget": "image widget", "In line": "In line", "Increase indent": "Increase indent", Insert: "Insert", "Insert column left": "Insert column left", "Insert column right": "Insert column right", "Insert image": "Insert image", "Insert image or file": "Insert image or file", "Insert image via URL": "Insert image via URL", "Insert media": "Insert media", "Insert paragraph after block": "Insert paragraph after block", "Insert paragraph before block": "Insert paragraph before block", "Insert row above": "Insert row above", "Insert row below": "Insert row below", "Insert table": "Insert table", "Inserting image failed": "Inserting image failed", Inset: "Inset", Italic: "Italic", "Justify cell text": "Justify cell text", "Left aligned image": "Left aligned image", "Light blue": "Light blue", "Light green": "Light green", "Light grey": "Light grey", Link: "Link", "Link image": "Link image", "Link URL": "Link URL", "List properties": "List properties", "Lower-latin": "Lower-latin", "Lower–roman": "Lower–roman", "Media toolbar": "Media toolbar", "Media URL": "Media URL", "media widget": "media widget", "Merge cell down": "Merge cell down", "Merge cell left": "Merge cell left", "Merge cell right": "Merge cell right", "Merge cell up": "Merge cell up", "Merge cells": "Merge cells", Next: "Next", "No results found": "No results found", "No searchable items": "No searchable items", None: "None", "Numbered List": "Numbered List", "Numbered list styles toolbar": "Numbered list styles toolbar", "Open file manager": "Open file manager", "Open in a new tab": "Open in a new tab", "Open link in new tab": "Open link in new tab", "Open media in new tab": "Open media in new tab", Orange: "Orange", Original: "Original", Outset: "Outset", Padding: "Padding", Paragraph: "Paragraph", "Paste the media URL in the input.": "Paste the media URL in the input.", "Press Enter to type after or press Shift + Enter to type before the widget": "Press Enter to type after or press Shift + Enter to type before the widget", Previous: "Previous", Purple: "Purple", Red: "Red", Redo: "Redo", "Remove color": "Remove color", "Resize image": "Resize image", "Resize image to %0": "Resize image to %0", "Resize image to the original size": "Resize image to the original size", "Restore default": "Restore default", "Reversed order": "Reversed order", "Rich Text Editor": "Rich Text Editor", Ridge: "Ridge", "Right aligned image": "Right aligned image", Row: "Row", Save: "Save", "Select all": "Select all", "Select column": "Select column", "Select row": "Select row", "Selecting resized image failed": "Selecting resized image failed", "Show more items": "Show more items", "Side image": "Side image", Solid: "Solid", "Split cell horizontally": "Split cell horizontally", "Split cell vertically": "Split cell vertically", Square: "Square", "Start at": "Start at", "Start index must be greater than 0.": "Start index must be greater than 0.", Strikethrough: "Strikethrough", Style: "Style", Subscript: "Subscript", Superscript: "Superscript", "Table alignment toolbar": "Table alignment toolbar", "Table cell text alignment": "Table cell text alignment", "Table properties": "Table properties", "Table toolbar": "Table toolbar", "Text alternative": "Text alternative", 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".': 'The color is invalid. Try "#FF0000" or "rgb(255,0,0)" or "red".', "The URL must not be empty.": "The URL must not be empty.", 'The value is invalid. Try "10px" or "2em" or simply "2".': 'The value is invalid. Try "10px" or "2em" or simply "2".', "This link has no URL": "This link has no URL", "This media URL is not supported.": "This media URL is not supported.", "Tip: Paste the URL into the content to embed faster.": "Tip: Paste the URL into the content to embed faster.", "To-do List": "To-do List", "Toggle caption off": "Toggle caption off", "Toggle caption on": "Toggle caption on", "Toggle the circle list style": "Toggle the circle list style", "Toggle the decimal list style": "Toggle the decimal list style", "Toggle the decimal with leading zero list style": "Toggle the decimal with leading zero list style", "Toggle the disc list style": "Toggle the disc list style", "Toggle the lower–latin list style": "Toggle the lower–latin list style", "Toggle the lower–roman list style": "Toggle the lower–roman list style", "Toggle the square list style": "Toggle the square list style", "Toggle the upper–latin list style": "Toggle the upper–latin list style", "Toggle the upper–roman list style": "Toggle the upper–roman list style", Turquoise: "Turquoise", "Type or paste your content here.": "Type or paste your content here.", "Type your title": "Type your title", Underline: "Underline", Undo: "Undo", Unlink: "Unlink", Update: "Update", "Update image URL": "Update image URL", "Upload failed": "Upload failed", "Upload in progress": "Upload in progress", "Upper-latin": "Upper-latin", "Upper-roman": "Upper-roman", "Vertical text alignment toolbar": "Vertical text alignment toolbar", White: "White", "Widget toolbar": "Widget toolbar", Width: "Width", "Wrap text": "Wrap text", Yellow: "Yellow" });
  }(window.CKEDITOR_TRANSLATIONS || (window.CKEDITOR_TRANSLATIONS = {})), /*!
   * @license Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   */
  function(t2, e2) {
    module.exports = e2();
  }(self, () => (() => {
    var t2 = { 4959: (t3, e3, n3) => {
      const o3 = n3(1103), i2 = {};
      for (const t4 of Object.keys(o3))
        i2[o3[t4]] = t4;
      const r2 = { rgb: { channels: 3, labels: "rgb" }, hsl: { channels: 3, labels: "hsl" }, hsv: { channels: 3, labels: "hsv" }, hwb: { channels: 3, labels: "hwb" }, cmyk: { channels: 4, labels: "cmyk" }, xyz: { channels: 3, labels: "xyz" }, lab: { channels: 3, labels: "lab" }, lch: { channels: 3, labels: "lch" }, hex: { channels: 1, labels: ["hex"] }, keyword: { channels: 1, labels: ["keyword"] }, ansi16: { channels: 1, labels: ["ansi16"] }, ansi256: { channels: 1, labels: ["ansi256"] }, hcg: { channels: 3, labels: ["h", "c", "g"] }, apple: { channels: 3, labels: ["r16", "g16", "b16"] }, gray: { channels: 1, labels: ["gray"] } };
      t3.exports = r2;
      for (const t4 of Object.keys(r2)) {
        if (!("channels" in r2[t4]))
          throw new Error("missing channels property: " + t4);
        if (!("labels" in r2[t4]))
          throw new Error("missing channel labels property: " + t4);
        if (r2[t4].labels.length !== r2[t4].channels)
          throw new Error("channel and label counts mismatch: " + t4);
        const { channels: e4, labels: n4 } = r2[t4];
        delete r2[t4].channels, delete r2[t4].labels, Object.defineProperty(r2[t4], "channels", { value: e4 }), Object.defineProperty(r2[t4], "labels", { value: n4 });
      }
      r2.rgb.hsl = function(t4) {
        const e4 = t4[0] / 255, n4 = t4[1] / 255, o4 = t4[2] / 255, i3 = Math.min(e4, n4, o4), r3 = Math.max(e4, n4, o4), s2 = r3 - i3;
        let a2, c2;
        r3 === i3 ? a2 = 0 : e4 === r3 ? a2 = (n4 - o4) / s2 : n4 === r3 ? a2 = 2 + (o4 - e4) / s2 : o4 === r3 && (a2 = 4 + (e4 - n4) / s2), a2 = Math.min(60 * a2, 360), a2 < 0 && (a2 += 360);
        const l2 = (i3 + r3) / 2;
        return c2 = r3 === i3 ? 0 : l2 <= 0.5 ? s2 / (r3 + i3) : s2 / (2 - r3 - i3), [a2, 100 * c2, 100 * l2];
      }, r2.rgb.hsv = function(t4) {
        let e4, n4, o4, i3, r3;
        const s2 = t4[0] / 255, a2 = t4[1] / 255, c2 = t4[2] / 255, l2 = Math.max(s2, a2, c2), d2 = l2 - Math.min(s2, a2, c2), h2 = function(t5) {
          return (l2 - t5) / 6 / d2 + 0.5;
        };
        return 0 === d2 ? (i3 = 0, r3 = 0) : (r3 = d2 / l2, e4 = h2(s2), n4 = h2(a2), o4 = h2(c2), s2 === l2 ? i3 = o4 - n4 : a2 === l2 ? i3 = 1 / 3 + e4 - o4 : c2 === l2 && (i3 = 2 / 3 + n4 - e4), i3 < 0 ? i3 += 1 : i3 > 1 && (i3 -= 1)), [360 * i3, 100 * r3, 100 * l2];
      }, r2.rgb.hwb = function(t4) {
        const e4 = t4[0], n4 = t4[1];
        let o4 = t4[2];
        const i3 = r2.rgb.hsl(t4)[0], s2 = 1 / 255 * Math.min(e4, Math.min(n4, o4));
        return o4 = 1 - 1 / 255 * Math.max(e4, Math.max(n4, o4)), [i3, 100 * s2, 100 * o4];
      }, r2.rgb.cmyk = function(t4) {
        const e4 = t4[0] / 255, n4 = t4[1] / 255, o4 = t4[2] / 255, i3 = Math.min(1 - e4, 1 - n4, 1 - o4);
        return [100 * ((1 - e4 - i3) / (1 - i3) || 0), 100 * ((1 - n4 - i3) / (1 - i3) || 0), 100 * ((1 - o4 - i3) / (1 - i3) || 0), 100 * i3];
      }, r2.rgb.keyword = function(t4) {
        const e4 = i2[t4];
        if (e4)
          return e4;
        let n4, r3 = 1 / 0;
        for (const e5 of Object.keys(o3)) {
          const i3 = o3[e5], c2 = (a2 = i3, ((s2 = t4)[0] - a2[0]) ** 2 + (s2[1] - a2[1]) ** 2 + (s2[2] - a2[2]) ** 2);
          c2 < r3 && (r3 = c2, n4 = e5);
        }
        var s2, a2;
        return n4;
      }, r2.keyword.rgb = function(t4) {
        return o3[t4];
      }, r2.rgb.xyz = function(t4) {
        let e4 = t4[0] / 255, n4 = t4[1] / 255, o4 = t4[2] / 255;
        e4 = e4 > 0.04045 ? ((e4 + 0.055) / 1.055) ** 2.4 : e4 / 12.92, n4 = n4 > 0.04045 ? ((n4 + 0.055) / 1.055) ** 2.4 : n4 / 12.92, o4 = o4 > 0.04045 ? ((o4 + 0.055) / 1.055) ** 2.4 : o4 / 12.92;
        return [100 * (0.4124 * e4 + 0.3576 * n4 + 0.1805 * o4), 100 * (0.2126 * e4 + 0.7152 * n4 + 0.0722 * o4), 100 * (0.0193 * e4 + 0.1192 * n4 + 0.9505 * o4)];
      }, r2.rgb.lab = function(t4) {
        const e4 = r2.rgb.xyz(t4);
        let n4 = e4[0], o4 = e4[1], i3 = e4[2];
        n4 /= 95.047, o4 /= 100, i3 /= 108.883, n4 = n4 > 8856e-6 ? n4 ** (1 / 3) : 7.787 * n4 + 16 / 116, o4 = o4 > 8856e-6 ? o4 ** (1 / 3) : 7.787 * o4 + 16 / 116, i3 = i3 > 8856e-6 ? i3 ** (1 / 3) : 7.787 * i3 + 16 / 116;
        return [116 * o4 - 16, 500 * (n4 - o4), 200 * (o4 - i3)];
      }, r2.hsl.rgb = function(t4) {
        const e4 = t4[0] / 360, n4 = t4[1] / 100, o4 = t4[2] / 100;
        let i3, r3, s2;
        if (0 === n4)
          return s2 = 255 * o4, [s2, s2, s2];
        i3 = o4 < 0.5 ? o4 * (1 + n4) : o4 + n4 - o4 * n4;
        const a2 = 2 * o4 - i3, c2 = [0, 0, 0];
        for (let t5 = 0; t5 < 3; t5++)
          r3 = e4 + 1 / 3 * -(t5 - 1), r3 < 0 && r3++, r3 > 1 && r3--, s2 = 6 * r3 < 1 ? a2 + 6 * (i3 - a2) * r3 : 2 * r3 < 1 ? i3 : 3 * r3 < 2 ? a2 + (i3 - a2) * (2 / 3 - r3) * 6 : a2, c2[t5] = 255 * s2;
        return c2;
      }, r2.hsl.hsv = function(t4) {
        const e4 = t4[0];
        let n4 = t4[1] / 100, o4 = t4[2] / 100, i3 = n4;
        const r3 = Math.max(o4, 0.01);
        o4 *= 2, n4 *= o4 <= 1 ? o4 : 2 - o4, i3 *= r3 <= 1 ? r3 : 2 - r3;
        return [e4, 100 * (0 === o4 ? 2 * i3 / (r3 + i3) : 2 * n4 / (o4 + n4)), 100 * ((o4 + n4) / 2)];
      }, r2.hsv.rgb = function(t4) {
        const e4 = t4[0] / 60, n4 = t4[1] / 100;
        let o4 = t4[2] / 100;
        const i3 = Math.floor(e4) % 6, r3 = e4 - Math.floor(e4), s2 = 255 * o4 * (1 - n4), a2 = 255 * o4 * (1 - n4 * r3), c2 = 255 * o4 * (1 - n4 * (1 - r3));
        switch (o4 *= 255, i3) {
          case 0:
            return [o4, c2, s2];
          case 1:
            return [a2, o4, s2];
          case 2:
            return [s2, o4, c2];
          case 3:
            return [s2, a2, o4];
          case 4:
            return [c2, s2, o4];
          case 5:
            return [o4, s2, a2];
        }
      }, r2.hsv.hsl = function(t4) {
        const e4 = t4[0], n4 = t4[1] / 100, o4 = t4[2] / 100, i3 = Math.max(o4, 0.01);
        let r3, s2;
        s2 = (2 - n4) * o4;
        const a2 = (2 - n4) * i3;
        return r3 = n4 * i3, r3 /= a2 <= 1 ? a2 : 2 - a2, r3 = r3 || 0, s2 /= 2, [e4, 100 * r3, 100 * s2];
      }, r2.hwb.rgb = function(t4) {
        const e4 = t4[0] / 360;
        let n4 = t4[1] / 100, o4 = t4[2] / 100;
        const i3 = n4 + o4;
        let r3;
        i3 > 1 && (n4 /= i3, o4 /= i3);
        const s2 = Math.floor(6 * e4), a2 = 1 - o4;
        r3 = 6 * e4 - s2, 0 != (1 & s2) && (r3 = 1 - r3);
        const c2 = n4 + r3 * (a2 - n4);
        let l2, d2, h2;
        switch (s2) {
          default:
          case 6:
          case 0:
            l2 = a2, d2 = c2, h2 = n4;
            break;
          case 1:
            l2 = c2, d2 = a2, h2 = n4;
            break;
          case 2:
            l2 = n4, d2 = a2, h2 = c2;
            break;
          case 3:
            l2 = n4, d2 = c2, h2 = a2;
            break;
          case 4:
            l2 = c2, d2 = n4, h2 = a2;
            break;
          case 5:
            l2 = a2, d2 = n4, h2 = c2;
        }
        return [255 * l2, 255 * d2, 255 * h2];
      }, r2.cmyk.rgb = function(t4) {
        const e4 = t4[0] / 100, n4 = t4[1] / 100, o4 = t4[2] / 100, i3 = t4[3] / 100;
        return [255 * (1 - Math.min(1, e4 * (1 - i3) + i3)), 255 * (1 - Math.min(1, n4 * (1 - i3) + i3)), 255 * (1 - Math.min(1, o4 * (1 - i3) + i3))];
      }, r2.xyz.rgb = function(t4) {
        const e4 = t4[0] / 100, n4 = t4[1] / 100, o4 = t4[2] / 100;
        let i3, r3, s2;
        return i3 = 3.2406 * e4 + -1.5372 * n4 + -0.4986 * o4, r3 = -0.9689 * e4 + 1.8758 * n4 + 0.0415 * o4, s2 = 0.0557 * e4 + -0.204 * n4 + 1.057 * o4, i3 = i3 > 31308e-7 ? 1.055 * i3 ** (1 / 2.4) - 0.055 : 12.92 * i3, r3 = r3 > 31308e-7 ? 1.055 * r3 ** (1 / 2.4) - 0.055 : 12.92 * r3, s2 = s2 > 31308e-7 ? 1.055 * s2 ** (1 / 2.4) - 0.055 : 12.92 * s2, i3 = Math.min(Math.max(0, i3), 1), r3 = Math.min(Math.max(0, r3), 1), s2 = Math.min(Math.max(0, s2), 1), [255 * i3, 255 * r3, 255 * s2];
      }, r2.xyz.lab = function(t4) {
        let e4 = t4[0], n4 = t4[1], o4 = t4[2];
        e4 /= 95.047, n4 /= 100, o4 /= 108.883, e4 = e4 > 8856e-6 ? e4 ** (1 / 3) : 7.787 * e4 + 16 / 116, n4 = n4 > 8856e-6 ? n4 ** (1 / 3) : 7.787 * n4 + 16 / 116, o4 = o4 > 8856e-6 ? o4 ** (1 / 3) : 7.787 * o4 + 16 / 116;
        return [116 * n4 - 16, 500 * (e4 - n4), 200 * (n4 - o4)];
      }, r2.lab.xyz = function(t4) {
        let e4, n4, o4;
        n4 = (t4[0] + 16) / 116, e4 = t4[1] / 500 + n4, o4 = n4 - t4[2] / 200;
        const i3 = n4 ** 3, r3 = e4 ** 3, s2 = o4 ** 3;
        return n4 = i3 > 8856e-6 ? i3 : (n4 - 16 / 116) / 7.787, e4 = r3 > 8856e-6 ? r3 : (e4 - 16 / 116) / 7.787, o4 = s2 > 8856e-6 ? s2 : (o4 - 16 / 116) / 7.787, e4 *= 95.047, n4 *= 100, o4 *= 108.883, [e4, n4, o4];
      }, r2.lab.lch = function(t4) {
        const e4 = t4[0], n4 = t4[1], o4 = t4[2];
        let i3;
        i3 = 360 * Math.atan2(o4, n4) / 2 / Math.PI, i3 < 0 && (i3 += 360);
        return [e4, Math.sqrt(n4 * n4 + o4 * o4), i3];
      }, r2.lch.lab = function(t4) {
        const e4 = t4[0], n4 = t4[1], o4 = t4[2] / 360 * 2 * Math.PI;
        return [e4, n4 * Math.cos(o4), n4 * Math.sin(o4)];
      }, r2.rgb.ansi16 = function(t4, e4 = null) {
        const [n4, o4, i3] = t4;
        let s2 = null === e4 ? r2.rgb.hsv(t4)[2] : e4;
        if (s2 = Math.round(s2 / 50), 0 === s2)
          return 30;
        let a2 = 30 + (Math.round(i3 / 255) << 2 | Math.round(o4 / 255) << 1 | Math.round(n4 / 255));
        return 2 === s2 && (a2 += 60), a2;
      }, r2.hsv.ansi16 = function(t4) {
        return r2.rgb.ansi16(r2.hsv.rgb(t4), t4[2]);
      }, r2.rgb.ansi256 = function(t4) {
        const e4 = t4[0], n4 = t4[1], o4 = t4[2];
        if (e4 === n4 && n4 === o4)
          return e4 < 8 ? 16 : e4 > 248 ? 231 : Math.round((e4 - 8) / 247 * 24) + 232;
        return 16 + 36 * Math.round(e4 / 255 * 5) + 6 * Math.round(n4 / 255 * 5) + Math.round(o4 / 255 * 5);
      }, r2.ansi16.rgb = function(t4) {
        let e4 = t4 % 10;
        if (0 === e4 || 7 === e4)
          return t4 > 50 && (e4 += 3.5), e4 = e4 / 10.5 * 255, [e4, e4, e4];
        const n4 = 0.5 * (1 + ~~(t4 > 50));
        return [(1 & e4) * n4 * 255, (e4 >> 1 & 1) * n4 * 255, (e4 >> 2 & 1) * n4 * 255];
      }, r2.ansi256.rgb = function(t4) {
        if (t4 >= 232) {
          const e5 = 10 * (t4 - 232) + 8;
          return [e5, e5, e5];
        }
        let e4;
        t4 -= 16;
        return [Math.floor(t4 / 36) / 5 * 255, Math.floor((e4 = t4 % 36) / 6) / 5 * 255, e4 % 6 / 5 * 255];
      }, r2.rgb.hex = function(t4) {
        const e4 = (((255 & Math.round(t4[0])) << 16) + ((255 & Math.round(t4[1])) << 8) + (255 & Math.round(t4[2]))).toString(16).toUpperCase();
        return "000000".substring(e4.length) + e4;
      }, r2.hex.rgb = function(t4) {
        const e4 = t4.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
        if (!e4)
          return [0, 0, 0];
        let n4 = e4[0];
        3 === e4[0].length && (n4 = n4.split("").map((t5) => t5 + t5).join(""));
        const o4 = parseInt(n4, 16);
        return [o4 >> 16 & 255, o4 >> 8 & 255, 255 & o4];
      }, r2.rgb.hcg = function(t4) {
        const e4 = t4[0] / 255, n4 = t4[1] / 255, o4 = t4[2] / 255, i3 = Math.max(Math.max(e4, n4), o4), r3 = Math.min(Math.min(e4, n4), o4), s2 = i3 - r3;
        let a2, c2;
        return a2 = s2 < 1 ? r3 / (1 - s2) : 0, c2 = s2 <= 0 ? 0 : i3 === e4 ? (n4 - o4) / s2 % 6 : i3 === n4 ? 2 + (o4 - e4) / s2 : 4 + (e4 - n4) / s2, c2 /= 6, c2 %= 1, [360 * c2, 100 * s2, 100 * a2];
      }, r2.hsl.hcg = function(t4) {
        const e4 = t4[1] / 100, n4 = t4[2] / 100, o4 = n4 < 0.5 ? 2 * e4 * n4 : 2 * e4 * (1 - n4);
        let i3 = 0;
        return o4 < 1 && (i3 = (n4 - 0.5 * o4) / (1 - o4)), [t4[0], 100 * o4, 100 * i3];
      }, r2.hsv.hcg = function(t4) {
        const e4 = t4[1] / 100, n4 = t4[2] / 100, o4 = e4 * n4;
        let i3 = 0;
        return o4 < 1 && (i3 = (n4 - o4) / (1 - o4)), [t4[0], 100 * o4, 100 * i3];
      }, r2.hcg.rgb = function(t4) {
        const e4 = t4[0] / 360, n4 = t4[1] / 100, o4 = t4[2] / 100;
        if (0 === n4)
          return [255 * o4, 255 * o4, 255 * o4];
        const i3 = [0, 0, 0], r3 = e4 % 1 * 6, s2 = r3 % 1, a2 = 1 - s2;
        let c2 = 0;
        switch (Math.floor(r3)) {
          case 0:
            i3[0] = 1, i3[1] = s2, i3[2] = 0;
            break;
          case 1:
            i3[0] = a2, i3[1] = 1, i3[2] = 0;
            break;
          case 2:
            i3[0] = 0, i3[1] = 1, i3[2] = s2;
            break;
          case 3:
            i3[0] = 0, i3[1] = a2, i3[2] = 1;
            break;
          case 4:
            i3[0] = s2, i3[1] = 0, i3[2] = 1;
            break;
          default:
            i3[0] = 1, i3[1] = 0, i3[2] = a2;
        }
        return c2 = (1 - n4) * o4, [255 * (n4 * i3[0] + c2), 255 * (n4 * i3[1] + c2), 255 * (n4 * i3[2] + c2)];
      }, r2.hcg.hsv = function(t4) {
        const e4 = t4[1] / 100, n4 = e4 + t4[2] / 100 * (1 - e4);
        let o4 = 0;
        return n4 > 0 && (o4 = e4 / n4), [t4[0], 100 * o4, 100 * n4];
      }, r2.hcg.hsl = function(t4) {
        const e4 = t4[1] / 100, n4 = t4[2] / 100 * (1 - e4) + 0.5 * e4;
        let o4 = 0;
        return n4 > 0 && n4 < 0.5 ? o4 = e4 / (2 * n4) : n4 >= 0.5 && n4 < 1 && (o4 = e4 / (2 * (1 - n4))), [t4[0], 100 * o4, 100 * n4];
      }, r2.hcg.hwb = function(t4) {
        const e4 = t4[1] / 100, n4 = e4 + t4[2] / 100 * (1 - e4);
        return [t4[0], 100 * (n4 - e4), 100 * (1 - n4)];
      }, r2.hwb.hcg = function(t4) {
        const e4 = t4[1] / 100, n4 = 1 - t4[2] / 100, o4 = n4 - e4;
        let i3 = 0;
        return o4 < 1 && (i3 = (n4 - o4) / (1 - o4)), [t4[0], 100 * o4, 100 * i3];
      }, r2.apple.rgb = function(t4) {
        return [t4[0] / 65535 * 255, t4[1] / 65535 * 255, t4[2] / 65535 * 255];
      }, r2.rgb.apple = function(t4) {
        return [t4[0] / 255 * 65535, t4[1] / 255 * 65535, t4[2] / 255 * 65535];
      }, r2.gray.rgb = function(t4) {
        return [t4[0] / 100 * 255, t4[0] / 100 * 255, t4[0] / 100 * 255];
      }, r2.gray.hsl = function(t4) {
        return [0, 0, t4[0]];
      }, r2.gray.hsv = r2.gray.hsl, r2.gray.hwb = function(t4) {
        return [0, 100, t4[0]];
      }, r2.gray.cmyk = function(t4) {
        return [0, 0, 0, t4[0]];
      }, r2.gray.lab = function(t4) {
        return [t4[0], 0, 0];
      }, r2.gray.hex = function(t4) {
        const e4 = 255 & Math.round(t4[0] / 100 * 255), n4 = ((e4 << 16) + (e4 << 8) + e4).toString(16).toUpperCase();
        return "000000".substring(n4.length) + n4;
      }, r2.rgb.gray = function(t4) {
        return [(t4[0] + t4[1] + t4[2]) / 3 / 255 * 100];
      };
    }, 841: (t3, e3, n3) => {
      const o3 = n3(4959), i2 = n3(9325), r2 = {};
      Object.keys(o3).forEach((t4) => {
        r2[t4] = {}, Object.defineProperty(r2[t4], "channels", { value: o3[t4].channels }), Object.defineProperty(r2[t4], "labels", { value: o3[t4].labels });
        const e4 = i2(t4);
        Object.keys(e4).forEach((n4) => {
          const o4 = e4[n4];
          r2[t4][n4] = function(t5) {
            const e5 = function(...e6) {
              const n5 = e6[0];
              if (null == n5)
                return n5;
              n5.length > 1 && (e6 = n5);
              const o5 = t5(e6);
              if ("object" == typeof o5)
                for (let t6 = o5.length, e7 = 0; e7 < t6; e7++)
                  o5[e7] = Math.round(o5[e7]);
              return o5;
            };
            return "conversion" in t5 && (e5.conversion = t5.conversion), e5;
          }(o4), r2[t4][n4].raw = function(t5) {
            const e5 = function(...e6) {
              const n5 = e6[0];
              return null == n5 ? n5 : (n5.length > 1 && (e6 = n5), t5(e6));
            };
            return "conversion" in t5 && (e5.conversion = t5.conversion), e5;
          }(o4);
        });
      }), t3.exports = r2;
    }, 9325: (t3, e3, n3) => {
      const o3 = n3(4959);
      function i2(t4) {
        const e4 = function() {
          const t5 = {}, e5 = Object.keys(o3);
          for (let n5 = e5.length, o4 = 0; o4 < n5; o4++)
            t5[e5[o4]] = { distance: -1, parent: null };
          return t5;
        }(), n4 = [t4];
        for (e4[t4].distance = 0; n4.length; ) {
          const t5 = n4.pop(), i3 = Object.keys(o3[t5]);
          for (let o4 = i3.length, r3 = 0; r3 < o4; r3++) {
            const o5 = i3[r3], s3 = e4[o5];
            -1 === s3.distance && (s3.distance = e4[t5].distance + 1, s3.parent = t5, n4.unshift(o5));
          }
        }
        return e4;
      }
      function r2(t4, e4) {
        return function(n4) {
          return e4(t4(n4));
        };
      }
      function s2(t4, e4) {
        const n4 = [e4[t4].parent, t4];
        let i3 = o3[e4[t4].parent][t4], s3 = e4[t4].parent;
        for (; e4[s3].parent; )
          n4.unshift(e4[s3].parent), i3 = r2(o3[e4[s3].parent][s3], i3), s3 = e4[s3].parent;
        return i3.conversion = n4, i3;
      }
      t3.exports = function(t4) {
        const e4 = i2(t4), n4 = {}, o4 = Object.keys(e4);
        for (let t5 = o4.length, i3 = 0; i3 < t5; i3++) {
          const t6 = o4[i3];
          null !== e4[t6].parent && (n4[t6] = s2(t6, e4));
        }
        return n4;
      };
    }, 1103: (t3) => {
      t3.exports = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
    }, 8603: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-content code{background-color:hsla(0,0%,78%,.3);border-radius:2px;padding:.15em}.ck.ck-editor__editable .ck-code_selected{background-color:hsla(0,0%,78%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-basic-styles/theme/code.css"], names: [], mappings: "AAKA,iBACC,kCAAuC,CAEvC,iBAAkB,CADlB,aAED,CAEA,0CACC,kCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content code {\n	background-color: hsla(0, 0%, 78%, 0.3);\n	padding: .15em;\n	border-radius: 2px;\n}\n\n.ck.ck-editor__editable .ck-code_selected  {\n	background-color: hsla(0, 0%, 78%, 0.5);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3062: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-content blockquote{border-left:5px solid #ccc;font-style:italic;margin-left:0;margin-right:0;overflow:hidden;padding-left:1.5em;padding-right:1.5em}.ck-content[dir=rtl] blockquote{border-left:0;border-right:5px solid #ccc}", "", { version: 3, sources: ["webpack://./../ckeditor5-block-quote/theme/blockquote.css"], names: [], mappings: "AAKA,uBAWC,0BAAsC,CADtC,iBAAkB,CAFlB,aAAc,CACd,cAAe,CAPf,eAAgB,CAIhB,kBAAmB,CADnB,mBAOD,CAEA,gCACC,aAAc,CACd,2BACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content blockquote {\n	/* See #12 */\n	overflow: hidden;\n\n	/* https://github.com/ckeditor/ckeditor5-block-quote/issues/15 */\n	padding-right: 1.5em;\n	padding-left: 1.5em;\n\n	margin-left: 0;\n	margin-right: 0;\n	font-style: italic;\n	border-left: solid 5px hsl(0, 0%, 80%);\n}\n\n.ck-content[dir="rtl"] blockquote {\n	border-left: 0;\n	border-right: solid 5px hsl(0, 0%, 80%);\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 903: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position{display:inline;pointer-events:none;position:relative}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{position:absolute;width:0}.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__selection-handle,.ck.ck-editor__editable .ck-widget:-webkit-drag>.ck-widget__type-around{display:none}.ck.ck-clipboard-drop-target-line{pointer-events:none;position:absolute}:root{--ck-clipboard-drop-target-dot-width:12px;--ck-clipboard-drop-target-dot-height:8px;--ck-clipboard-drop-target-color:var(--ck-color-focus-border)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);bottom:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);margin-left:-1px;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5)}.ck.ck-editor__editable .ck.ck-clipboard-drop-target-position span:after{border-color:var(--ck-clipboard-drop-target-color) transparent transparent transparent;border-style:solid;border-width:calc(var(--ck-clipboard-drop-target-dot-height)) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5);content:"";display:block;height:0;left:50%;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-height)*-.5);transform:translateX(-50%);width:0}.ck.ck-editor__editable .ck-widget.ck-clipboard-drop-target-range{outline:var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color)!important}.ck.ck-editor__editable .ck-widget:-webkit-drag{zoom:.6;outline:none!important}.ck.ck-clipboard-drop-target-line{background:var(--ck-clipboard-drop-target-color);border:1px solid var(--ck-clipboard-drop-target-color);height:0;margin-top:-1px}.ck.ck-clipboard-drop-target-line:before{border-style:solid;content:"";height:0;position:absolute;top:calc(var(--ck-clipboard-drop-target-dot-width)*-.5);width:0}[dir=ltr] .ck.ck-clipboard-drop-target-line:before{border-color:transparent transparent transparent var(--ck-clipboard-drop-target-color);border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0 calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height);left:-1px}[dir=rtl] .ck.ck-clipboard-drop-target-line:before{border-color:transparent var(--ck-clipboard-drop-target-color) transparent transparent;border-width:calc(var(--ck-clipboard-drop-target-dot-width)*.5) var(--ck-clipboard-drop-target-dot-height) calc(var(--ck-clipboard-drop-target-dot-width)*.5) 0;right:-1px}', "", { version: 3, sources: ["webpack://./../ckeditor5-clipboard/theme/clipboard.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-clipboard/clipboard.css"], names: [], mappings: "AASC,8DACC,cAAe,CAEf,mBAAoB,CADpB,iBAOD,CAJC,mEACC,iBAAkB,CAClB,OACD,CAWA,qJACC,YACD,CAIF,kCAEC,mBAAoB,CADpB,iBAED,CC9BA,MACC,yCAA0C,CAC1C,yCAA0C,CAC1C,6DACD,CAOE,mEAIC,gDAAiD,CADjD,sDAAuD,CAFvD,2DAA8D,CAI9D,gBAAiB,CAHjB,wDAqBD,CAfC,yEAWC,sFAAuF,CAEvF,kBAAmB,CADnB,qKAA0K,CAX1K,UAAW,CAIX,aAAc,CAFd,QAAS,CAIT,QAAS,CADT,iBAAkB,CAElB,wDAA2D,CAE3D,0BAA2B,CAR3B,OAYD,CAOF,kEACC,gGACD,CAKA,gDACC,OAAS,CACT,sBACD,CAGD,kCAGC,gDAAiD,CADjD,sDAAuD,CADvD,QAAS,CAGT,eAwBD,CAtBC,yCAMC,kBAAmB,CALnB,UAAW,CAIX,QAAS,CAHT,iBAAkB,CAClB,uDAA0D,CAC1D,OAiBD,CArBA,mDAYE,sFAAuF,CADvF,+JAAoK,CAFpK,SAYF,CArBA,mDAmBE,sFAAuF,CADvF,+JAAmK,CAFnK,UAKF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	/*\n	 * Vertical drop target (in text).\n	 */\n	& .ck.ck-clipboard-drop-target-position {\n		display: inline;\n		position: relative;\n		pointer-events: none;\n\n		& span {\n			position: absolute;\n			width: 0;\n		}\n	}\n\n	/*\n	 * Styles of the widget being dragged (its preview).\n	 */\n	& .ck-widget:-webkit-drag {\n		& > .ck-widget__selection-handle {\n			display: none;\n		}\n\n		& > .ck-widget__type-around {\n			display: none;\n		}\n	}\n}\n\n.ck.ck-clipboard-drop-target-line {\n	position: absolute;\n	pointer-events: none;\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-clipboard-drop-target-dot-width: 12px;
	--ck-clipboard-drop-target-dot-height: 8px;
	--ck-clipboard-drop-target-color: var(--ck-color-focus-border);
}

.ck.ck-editor__editable {
	/*
	 * Vertical drop target (in text).
	 */
	& .ck.ck-clipboard-drop-target-position {
		& span {
			bottom: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));
			border: 1px solid var(--ck-clipboard-drop-target-color);
			background: var(--ck-clipboard-drop-target-color);
			margin-left: -1px;

			/* The triangle above the marker */
			&::after {
				content: '';
				width: 0;
				height: 0;

				display: block;
				position: absolute;
				left: 50%;
				top: calc(-.5 * var(--ck-clipboard-drop-target-dot-height));

				transform: translateX(-50%);
				border-color: var(--ck-clipboard-drop-target-color) transparent transparent transparent;
				border-width: calc(var(--ck-clipboard-drop-target-dot-height)) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width));
				border-style: solid;
			}
		}
	}

	/*
	 * Styles of the widget that it a drop target.
	 */
	& .ck-widget.ck-clipboard-drop-target-range {
		outline: var(--ck-widget-outline-thickness) solid var(--ck-clipboard-drop-target-color) !important;
	}

	/*
	 * Styles of the widget being dragged (its preview).
	 */
	& .ck-widget:-webkit-drag {
		zoom: 0.6;
		outline: none !important;
	}
}

.ck.ck-clipboard-drop-target-line {
	height: 0;
	border: 1px solid var(--ck-clipboard-drop-target-color);
	background: var(--ck-clipboard-drop-target-color);
	margin-top: -1px;

	&::before {
		content: '';
		position: absolute;
		top: calc(-.5 * var(--ck-clipboard-drop-target-dot-width));
		width: 0;
		height: 0;
		border-style: solid;

		@mixin ck-dir ltr {
			left: -1px;

			border-width: calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0 calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height);
			border-color: transparent transparent transparent var(--ck-clipboard-drop-target-color);
		}

		@mixin ck-dir rtl {
			right: -1px;

			border-width:calc(.5 * var(--ck-clipboard-drop-target-dot-width)) var(--ck-clipboard-drop-target-dot-height) calc(.5 * var(--ck-clipboard-drop-target-dot-width)) 0;
			border-color: transparent var(--ck-clipboard-drop-target-color) transparent transparent;
		}
	}
}
`], sourceRoot: "" }]);
      const a2 = s2;
    }, 3143: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-editor{position:relative}.ck.ck-editor .ck-editor__top .ck-sticky-panel .ck-toolbar{z-index:var(--ck-z-modal)}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-editor__top .ck-sticky-panel .ck-toolbar{border-bottom-width:0}.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar{border-bottom-width:1px;border-radius:0}.ck-rounded-corners .ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar,.ck.ck-editor__top .ck-sticky-panel .ck-sticky-panel__content_sticky .ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:0}.ck.ck-editor__main>.ck-editor__editable{background:var(--ck-color-base-background);border-radius:0}.ck-rounded-corners .ck.ck-editor__main>.ck-editor__editable,.ck.ck-editor__main>.ck-editor__editable.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}.ck.ck-editor__main>.ck-editor__editable:not(.ck-focused){border-color:var(--ck-color-base-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-editor-classic/theme/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-editor-classic/classiceditor.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,cAIC,iBAMD,CAJC,2DAEC,yBACD,CCLC,gDCED,eDKC,CAPA,uICMA,qCAAsC,CDJpC,2BAA4B,CAC5B,4BAIF,CAPA,gDAMC,qBACD,CAEA,iFACC,uBAAwB,CCR1B,eDaC,CANA,yMCHA,qCAAsC,CDOpC,eAEF,CAKF,yCAEC,0CAA2C,CCpB3C,eD8BD,CAZA,yHCdE,qCAAsC,CDmBtC,wBAAyB,CACzB,yBAMF,CAHC,0DACC,wCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor {\n	/* All the elements within `.ck-editor` are positioned relatively to it.\n	 If any element needs to be positioned with respect to the <body>, etc.,\n	 it must land outside of the `.ck-editor` in DOM. */\n	position: relative;\n\n	& .ck-editor__top .ck-sticky-panel .ck-toolbar {\n		/* https://github.com/ckeditor/ckeditor5-editor-classic/issues/62 */\n		z-index: var(--ck-z-modal);\n	}\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../mixins/_rounded.css";

.ck.ck-editor__top {
	& .ck-sticky-panel {
		& .ck-toolbar {
			@mixin ck-rounded-corners {
				border-bottom-left-radius: 0;
				border-bottom-right-radius: 0;
			}

			border-bottom-width: 0;
		}

		& .ck-sticky-panel__content_sticky .ck-toolbar {
			border-bottom-width: 1px;

			@mixin ck-rounded-corners {
				border-radius: 0;
			}
		}
	}
}

/* Note: Use ck-editor__main to make sure these styles don't apply to other editor types */
.ck.ck-editor__main > .ck-editor__editable {
	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/113 */
	background: var(--ck-color-base-background);

	@mixin ck-rounded-corners {
		border-top-left-radius: 0;
		border-top-right-radius: 0;
	}

	&:not(.ck-focused) {
		border-color: var(--ck-color-base-border);
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4717: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck .ck-placeholder,.ck.ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{content:attr(data-placeholder);left:0;pointer-events:none;position:absolute;right:0}.ck.ck-read-only .ck-placeholder:before{display:none}.ck.ck-reset_all .ck-placeholder{position:relative}.ck .ck-placeholder:before,.ck.ck-placeholder:before{color:var(--ck-color-engine-placeholder-text);cursor:text}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/placeholder.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-engine/placeholder.css"], names: [], mappings: "AAMA,uCAEC,iBAWD,CATC,qDAIC,8BAA+B,CAF/B,MAAO,CAKP,mBAAoB,CANpB,iBAAkB,CAElB,OAKD,CAKA,wCACC,YACD,CAQD,iCACC,iBACD,CC5BC,qDAEC,6CAA8C,CAD9C,WAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder,\n.ck .ck-placeholder {\n	position: relative;\n\n	&::before {\n		position: absolute;\n		left: 0;\n		right: 0;\n		content: attr(data-placeholder);\n\n		/* See ckeditor/ckeditor5#469. */\n		pointer-events: none;\n	}\n}\n\n/* See ckeditor/ckeditor5#1987. */\n.ck.ck-read-only .ck-placeholder {\n	&::before {\n		display: none;\n	}\n}\n\n/*\n * Rules for the `ck-placeholder` are loaded before the rules for `ck-reset_all` in the base CKEditor 5 DLL build.\n * This fix overwrites the incorrectly set `position: static` from `ck-reset_all`.\n * See https://github.com/ckeditor/ckeditor5/issues/11418.\n */\n.ck.ck-reset_all .ck-placeholder {\n	position: relative;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* See ckeditor/ckeditor5#936. */\n.ck.ck-placeholder, .ck .ck-placeholder {\n	&::before {\n		cursor: text;\n		color: var(--ck-color-engine-placeholder-text);\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 9315: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-editor__editable span[data-ck-unsafe-element]{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-engine/theme/renderer.css"], names: [], mappings: "AAMA,qDACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Elements marked by the Renderer as hidden should be invisible in the editor. */\n.ck.ck-editor__editable span[data-ck-unsafe-element] {\n	display: none;\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 8733: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-heading_heading1{font-size:20px}.ck.ck-heading_heading2{font-size:17px}.ck.ck-heading_heading3{font-size:14px}.ck[class*=ck-heading_heading]{font-weight:700}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__button .ck-button__label{width:8em}.ck.ck-dropdown.ck-heading-dropdown .ck-dropdown__panel .ck-list__item{min-width:18em}", "", { version: 3, sources: ["webpack://./../ckeditor5-heading/theme/heading.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-heading/heading.css"], names: [], mappings: "AAKA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,wBACC,cACD,CAEA,+BACC,eACD,CCZC,2EACC,SACD,CAEA,uEACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-heading_heading1 {\n	font-size: 20px;\n}\n\n.ck.ck-heading_heading2 {\n	font-size: 17px;\n}\n\n.ck.ck-heading_heading3 {\n	font-size: 14px;\n}\n\n.ck[class*="ck-heading_heading"] {\n	font-weight: bold;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Resize dropdown's button label. */\n.ck.ck-dropdown.ck-heading-dropdown {\n	& .ck-dropdown__button .ck-button__label {\n		width: 8em;\n	}\n\n	& .ck-dropdown__panel .ck-list__item {\n		min-width: 18em;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3508: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-content .image{clear:both;display:table;margin:.9em auto;min-width:50px;text-align:center}.ck-content .image img{display:block;height:auto;margin:0 auto;max-width:100%;min-width:100%}.ck-content .image-inline{align-items:flex-start;display:inline-flex;max-width:100%}.ck-content .image-inline picture{display:flex}.ck-content .image-inline img,.ck-content .image-inline picture{flex-grow:1;flex-shrink:1;max-width:100%}.ck.ck-editor__editable .image>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}.ck.ck-editor__editable .image{z-index:1}.ck.ck-editor__editable .image.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline{z-index:1}.ck.ck-editor__editable .image-inline.ck-widget_selected{z-index:2}.ck.ck-editor__editable .image-inline.ck-widget_selected ::selection{display:none}.ck.ck-editor__editable .image-inline img{height:auto}.ck.ck-editor__editable td .image-inline img,.ck.ck-editor__editable th .image-inline img{max-width:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/image.css"], names: [], mappings: "AAMC,mBAEC,UAAW,CADX,aAAc,CAOd,gBAAkB,CAGlB,cAAe,CARf,iBA2BD,CAjBC,uBAEC,aAAc,CAad,WAAY,CAVZ,aAAc,CAGd,cAAe,CAGf,cAKD,CAGD,0BAYC,sBAAuB,CANvB,mBAAoB,CAGpB,cAoBD,CAdC,kCACC,YACD,CAGA,gEAGC,WAAY,CACZ,aAAc,CAGd,cACD,CAUD,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAKA,+BACC,SASD,CAHC,kDACC,SACD,CAMD,sCACC,SAkBD,CAZC,yDACC,SAUD,CAHC,qEACC,YACD,CAMF,0CACC,WACD,CAMC,0FACC,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content {\n	& .image {\n		display: table;\n		clear: both;\n		text-align: center;\n\n		/* Make sure there is some space between the content and the image. Center image by default. */\n		/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n	 	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n		margin: 0.9em auto;\n\n		/* Make sure the caption will be displayed properly (See: https://github.com/ckeditor/ckeditor5/issues/1870). */\n		min-width: 50px;\n\n		& img {\n			/* Prevent unnecessary margins caused by line-height (see #44). */\n			display: block;\n\n			/* Center the image if its width is smaller than the content\'s width. */\n			margin: 0 auto;\n\n			/* Make sure the image never exceeds the size of the parent container (ckeditor/ckeditor5-ui#67). */\n			max-width: 100%;\n\n			/* Make sure the image is never smaller than the parent container (See: https://github.com/ckeditor/ckeditor5/issues/9300). */\n			min-width: 100%;\n\n			/* Keep proportions of the block image if the height is set and the image is wider than the editor width.\n			See https://github.com/ckeditor/ckeditor5/issues/14542. */\n			height: auto;\n		}\n	}\n\n	& .image-inline {\n		/*\n		 * Normally, the .image-inline would have "display: inline-block" and "img { width: 100% }" (to follow the wrapper while resizing).\n		 * Unfortunately, together with "srcset", it gets automatically stretched up to the width of the editing root.\n		 * This strange behavior does not happen with inline-flex.\n		 */\n		display: inline-flex;\n\n		/* While being resized, don\'t allow the image to exceed the width of the editing root. */\n		max-width: 100%;\n\n		/* This is required by Safari to resize images in a sensible way. Without this, the browser breaks the ratio. */\n		align-items: flex-start;\n\n		/* When the picture is present it must act as a flex container to let the img resize properly */\n		& picture {\n			display: flex;\n		}\n\n		/* When the picture is present, it must act like a resizable img. */\n		& picture,\n		& img {\n			/* This is necessary for the img to span the entire .image-inline wrapper and to resize properly. */\n			flex-grow: 1;\n			flex-shrink: 1;\n\n			/* Prevents overflowing the editing root boundaries when an inline image is very wide. */\n			max-width: 100%;\n		}\n	}\n}\n\n.ck.ck-editor__editable {\n	/*\n	 * Inhertit the content styles padding of the <figcaption> in case the integration overrides `text-align: center`\n	 * of `.image` (e.g. to the left/right). This ensures the placeholder stays at the padding just like the native\n	 * caret does, and not at the edge of <figcaption>.\n	 */\n	& .image > figcaption.ck-placeholder::before {\n		padding-left: inherit;\n		padding-right: inherit;\n\n		/*\n		 * Make sure the image caption placeholder doesn\'t overflow the placeholder area.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9162.\n		 */\n		white-space: nowrap;\n		overflow: hidden;\n		text-overflow: ellipsis;\n	}\n\n	/*\n	 * See https://github.com/ckeditor/ckeditor5/issues/15115.\n	 */\n	& .image {\n		z-index: 1;\n\n		/*\n		 * Make sure the selected image always stays on top of its siblings.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9108.\n		 */\n		&.ck-widget_selected {\n			z-index: 2;\n		}\n	}\n\n	/*\n	 * See https://github.com/ckeditor/ckeditor5/issues/15115.\n	 */\n	& .image-inline {\n		z-index: 1;\n\n		/*\n		 * Make sure the selected inline image always stays on top of its siblings.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9108.\n		 */\n		&.ck-widget_selected {\n			z-index: 2;\n\n			/*\n			 * Make sure the native browser selection style is not displayed.\n			 * Inline image widgets have their own styles for the selected state and\n			 * leaving this up to the browser is asking for a visual collision.\n			 */\n			& ::selection {\n				display: none;\n			}\n		}\n	}\n\n	/* Keep proportions of the inline image if the height is set and the image is wider than the editor width.\n	See https://github.com/ckeditor/ckeditor5/issues/14542. */\n	& .image-inline img {\n		height: auto;\n	}\n\n	/* The inline image nested in the table should have its original size if not resized.\n	See https://github.com/ckeditor/ckeditor5/issues/9117. */\n	& td,\n	& th {\n		& .image-inline img {\n			max-width: none;\n		}\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 2640: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-color-image-caption-background:#f7f7f7;--ck-color-image-caption-text:#333;--ck-color-image-caption-highligted-background:#fd0}.ck-content .image>figcaption{background-color:var(--ck-color-image-caption-background);caption-side:bottom;color:var(--ck-color-image-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;word-break:break-word}.ck.ck-editor__editable .image>figcaption.image__caption_highlighted{animation:ck-image-caption-highlight .6s ease-out}@keyframes ck-image-caption-highlight{0%{background-color:var(--ck-color-image-caption-highligted-background)}to{background-color:var(--ck-color-image-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagecaption.css"], names: [], mappings: "AAKA,MACC,2CAAoD,CACpD,kCAA8C,CAC9C,mDACD,CAGA,8BAKC,yDAA0D,CAH1D,mBAAoB,CAEpB,wCAAyC,CAHzC,qBAAsB,CAMtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,qBAMD,CAGA,qEACC,iDACD,CAEA,sCACC,GACC,oEACD,CAEA,GACC,yDACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-image-caption-background: hsl(0, 0%, 97%);\n	--ck-color-image-caption-text: hsl(0, 0%, 20%);\n	--ck-color-image-caption-highligted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .image > figcaption {\n	display: table-caption;\n	caption-side: bottom;\n	word-break: break-word;\n	color: var(--ck-color-image-caption-text);\n	background-color: var(--ck-color-image-caption-background);\n	padding: .6em;\n	font-size: .75em;\n	outline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .image > figcaption.image__caption_highlighted {\n	animation: ck-image-caption-highlight .6s ease-out;\n}\n\n@keyframes ck-image-caption-highlight {\n	0% {\n		background-color: var(--ck-color-image-caption-highligted-background);\n	}\n\n	100% {\n		background-color: var(--ck-color-image-caption-background);\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3535: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-image-insert__panel{padding:var(--ck-spacing-large)}.ck.ck-image-insert__ck-finder-button{border:1px solid #ccc;border-radius:var(--ck-border-radius);display:block;margin:var(--ck-spacing-standard) auto;width:100%}.ck.ck-splitbutton>.ck-file-dialog-button.ck-button{border:none;margin:0;padding:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageinsert.css"], names: [], mappings: "AAKA,2BACC,+BACD,CAEA,sCAIC,qBAAiC,CACjC,qCAAsC,CAJtC,aAAc,CAEd,sCAAuC,CADvC,UAID,CAGA,oDAGC,WAAY,CADZ,QAAS,CADT,SAGD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert__panel {\n	padding: var(--ck-spacing-large);\n}\n\n.ck.ck-image-insert__ck-finder-button {\n	display: block;\n	width: 100%;\n	margin: var(--ck-spacing-standard) auto;\n	border: 1px solid hsl(0, 0%, 80%);\n	border-radius: var(--ck-border-radius);\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/7986 */\n.ck.ck-splitbutton > .ck-file-dialog-button.ck-button {\n	padding: 0;\n	margin: 0;\n	border: none;\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 1568: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-image-insert-form:focus{outline:none}.ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-image-insert-form__action-row{margin-top:var(--ck-spacing-standard)}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-image-insert-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row.ck-image-insert-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageinsertformrowview.css"], names: [], mappings: "AAMC,+BAEC,YACD,CAGD,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAmBD,CAhBC,iCACC,WACD,CAEA,kDACC,qCAUD,CARC,sIAEC,sBACD,CAEA,+EACC,0BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-image-insert-form {\n	&:focus {\n		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n		outline: none;\n	}\n}\n\n.ck.ck-form__row {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	justify-content: space-between;\n\n	/* Ignore labels that work as fieldset legends */\n	& > *:not(.ck-label) {\n		flex-grow: 1;\n	}\n\n	&.ck-image-insert-form__action-row {\n		margin-top: var(--ck-spacing-standard);\n\n		& .ck-button-save,\n		& .ck-button-cancel {\n			justify-content: center;\n		}\n\n		& .ck-button .ck-button__label {\n			color: var(--ck-color-text);\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 6270: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-content img.image_resized{height:auto}.ck-content .image.image_resized{box-sizing:border-box;display:block;max-width:100%}.ck-content .image.image_resized img{width:100%}.ck-content .image.image_resized>figcaption{display:block}.ck.ck-editor__editable td .image-inline.image_resized img,.ck.ck-editor__editable th .image-inline.image_resized img{max-width:100%}[dir=ltr] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon{margin-left:var(--ck-spacing-standard)}.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label{width:4em}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageresize.css"], names: [], mappings: "AAMA,8BACC,WACD,CAEA,iCAQC,qBAAsB,CADtB,aAAc,CANd,cAkBD,CATC,qCAEC,UACD,CAEA,4CAEC,aACD,CAQC,sHACC,cACD,CAIF,oFACC,uCACD,CAEA,oFACC,sCACD,CAEA,oEACC,SACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Preserve aspect ratio of the resized image after introducing image height attribute. */\n.ck-content img.image_resized {\n	height: auto;\n}\n\n.ck-content .image.image_resized {\n	max-width: 100%;\n	/*\n	The `<figure>` element for resized images must not use `display:table` as browsers do not support `max-width` for it well.\n	See https://stackoverflow.com/questions/4019604/chrome-safari-ignoring-max-width-in-table/14420691#14420691 for more.\n	Fortunately, since we control the width, there is no risk that the image will look bad.\n	*/\n	display: block;\n	box-sizing: border-box;\n\n	& img {\n		/* For resized images it is the `<figure>` element that determines the image width. */\n		width: 100%;\n	}\n\n	& > figcaption {\n		/* The `<figure>` element uses `display:block`, so `<figcaption>` also has to. */\n		display: block;\n	}\n}\n\n.ck.ck-editor__editable {\n	/* The resized inline image nested in the table should respect its parent size.\n	See https://github.com/ckeditor/ckeditor5/issues/9117. */\n	& td,\n	& th {\n		& .image-inline.image_resized img {\n			max-width: 100%;\n		}\n	}\n}\n\n[dir="ltr"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n	margin-right: var(--ck-spacing-standard);\n}\n\n[dir="rtl"] .ck.ck-button.ck-button_with-text.ck-resize-image-button .ck-button__icon {\n	margin-left: var(--ck-spacing-standard);\n}\n\n.ck.ck-dropdown .ck-button.ck-resize-image-button .ck-button__label {\n	width: 4em;\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 5083: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-image-style-spacing:1.5em;--ck-inline-image-style-spacing:calc(var(--ck-image-style-spacing)/2)}.ck-content .image-style-block-align-left,.ck-content .image-style-block-align-right{max-width:calc(100% - var(--ck-image-style-spacing))}.ck-content .image-style-align-left,.ck-content .image-style-align-right{clear:none}.ck-content .image-style-side{float:right;margin-left:var(--ck-image-style-spacing);max-width:50%}.ck-content .image-style-align-left{float:left;margin-right:var(--ck-image-style-spacing)}.ck-content .image-style-align-center{margin-left:auto;margin-right:auto}.ck-content .image-style-align-right{float:right;margin-left:var(--ck-image-style-spacing)}.ck-content .image-style-block-align-right{margin-left:auto;margin-right:0}.ck-content .image-style-block-align-left{margin-left:0;margin-right:auto}.ck-content p+.image-style-align-left,.ck-content p+.image-style-align-right,.ck-content p+.image-style-side{margin-top:0}.ck-content .image-inline.image-style-align-left,.ck-content .image-inline.image-style-align-right{margin-bottom:var(--ck-inline-image-style-spacing);margin-top:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-left{margin-right:var(--ck-inline-image-style-spacing)}.ck-content .image-inline.image-style-align-right{margin-left:var(--ck-inline-image-style-spacing)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-background)}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__action:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton.ck-splitbutton_flatten:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover):after{display:none}.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__action:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled),.ck.ck-splitbutton.ck-splitbutton_flatten.ck-splitbutton_open:hover>.ck-splitbutton__arrow:not(.ck-disabled):not(:hover){background-color:var(--ck-color-button-on-hover-background)}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imagestyle.css"], names: [], mappings: "AAKA,MACC,8BAA+B,CAC/B,qEACD,CAMC,qFAEC,oDACD,CAIA,yEAEC,UACD,CAEA,8BACC,WAAY,CACZ,yCAA0C,CAC1C,aACD,CAEA,oCACC,UAAW,CACX,0CACD,CAEA,sCACC,gBAAiB,CACjB,iBACD,CAEA,qCACC,WAAY,CACZ,yCACD,CAEA,2CAEC,gBAAiB,CADjB,cAED,CAEA,0CACC,aAAc,CACd,iBACD,CAGA,6GAGC,YACD,CAGC,mGAGC,kDAAmD,CADnD,+CAED,CAEA,iDACC,iDACD,CAEA,kDACC,gDACD,CAUC,0lBAGC,qDAKD,CAHC,8nBACC,YACD,CAKD,oVAGC,2DACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-image-style-spacing: 1.5em;\n	--ck-inline-image-style-spacing: calc(var(--ck-image-style-spacing) / 2);\n}\n\n.ck-content {\n	/* Provides a minimal side margin for the left and right aligned images, so that the user has a visual feedback\n	confirming successful application of the style if image width exceeds the editor's size.\n	See https://github.com/ckeditor/ckeditor5/issues/9342 */\n	& .image-style-block-align-left,\n	& .image-style-block-align-right {\n		max-width: calc(100% - var(--ck-image-style-spacing));\n	}\n\n	/* Allows displaying multiple floating images in the same line.\n	See https://github.com/ckeditor/ckeditor5/issues/9183#issuecomment-804988132 */\n	& .image-style-align-left,\n	& .image-style-align-right {\n		clear: none;\n	}\n\n	& .image-style-side {\n		float: right;\n		margin-left: var(--ck-image-style-spacing);\n		max-width: 50%;\n	}\n\n	& .image-style-align-left {\n		float: left;\n		margin-right: var(--ck-image-style-spacing);\n	}\n\n	& .image-style-align-center {\n		margin-left: auto;\n		margin-right: auto;\n	}\n\n	& .image-style-align-right {\n		float: right;\n		margin-left: var(--ck-image-style-spacing);\n	}\n\n	& .image-style-block-align-right {\n		margin-right: 0;\n		margin-left: auto;\n	}\n\n	& .image-style-block-align-left {\n		margin-left: 0;\n		margin-right: auto;\n	}\n\n	/* Simulates margin collapsing with the preceding paragraph, which does not work for the floating elements. */\n	& p + .image-style-align-left,\n	& p + .image-style-align-right,\n	& p + .image-style-side {\n		margin-top: 0;\n	}\n\n	& .image-inline {\n		&.image-style-align-left,\n		&.image-style-align-right {\n			margin-top: var(--ck-inline-image-style-spacing);\n			margin-bottom: var(--ck-inline-image-style-spacing);\n		}\n\n		&.image-style-align-left {\n			margin-right: var(--ck-inline-image-style-spacing);\n		}\n\n		&.image-style-align-right {\n			margin-left: var(--ck-inline-image-style-spacing);\n		}\n	}\n}\n\n.ck.ck-splitbutton {\n	/* The button should display as a regular drop-down if the action button\n	is forced to fire the same action as the arrow button. */\n	&.ck-splitbutton_flatten {\n		&:hover,\n		&.ck-splitbutton_open {\n			& > .ck-splitbutton__action:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n				background-color: var(--ck-color-button-on-background);\n\n				&::after {\n					display: none;\n				}\n			}\n		}\n\n		&.ck-splitbutton_open:hover {\n			& > .ck-splitbutton__action:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled),\n			& > .ck-splitbutton__arrow:not(.ck-disabled):not(:hover) {\n				background-color: var(--ck-color-button-on-hover-background);\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4036: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck-image-upload-complete-icon{border-radius:50%;display:block;position:absolute;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);z-index:1}.ck-image-upload-complete-icon:after{content:"";position:absolute}:root{--ck-color-image-upload-icon:#fff;--ck-color-image-upload-icon-background:#008a00;--ck-image-upload-icon-size:20;--ck-image-upload-icon-width:2px;--ck-image-upload-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck-image-upload-complete-icon{animation-delay:0ms,3s;animation-duration:.5s,.5s;animation-fill-mode:forwards,forwards;animation-name:ck-upload-complete-icon-show,ck-upload-complete-icon-hide;background:var(--ck-color-image-upload-icon-background);font-size:calc(1px*var(--ck-image-upload-icon-size));height:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size));opacity:0;overflow:hidden;width:calc(var(--ck-image-upload-icon-is-visible)*var(--ck-image-upload-icon-size))}.ck-image-upload-complete-icon:after{animation-delay:.5s;animation-duration:.5s;animation-fill-mode:forwards;animation-name:ck-upload-complete-icon-check;border-right:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);border-top:var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);box-sizing:border-box;height:0;left:25%;opacity:0;top:50%;transform:scaleX(-1) rotate(135deg);transform-origin:left top;width:0}@keyframes ck-upload-complete-icon-show{0%{opacity:0}to{opacity:1}}@keyframes ck-upload-complete-icon-hide{0%{opacity:1}to{opacity:0}}@keyframes ck-upload-complete-icon-check{0%{height:0;opacity:1;width:0}33%{height:0;width:.3em}to{height:.45em;opacity:1;width:.3em}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadicon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadicon.css"], names: [], mappings: "AAKA,+BAUC,iBAAkB,CATlB,aAAc,CACd,iBAAkB,CAOlB,sCAAwC,CADxC,oCAAsC,CAGtC,SAMD,CAJC,qCACC,UAAW,CACX,iBACD,CChBD,MACC,iCAA8C,CAC9C,+CAA4D,CAG5D,8BAA+B,CAC/B,gCAAiC,CACjC,4DACD,CAEA,+BAWC,sBAA4B,CAN5B,0BAAgC,CADhC,qCAAuC,CADvC,wEAA0E,CAD1E,uDAAwD,CAMxD,oDAAuD,CAWvD,oFAAuF,CAlBvF,SAAU,CAgBV,eAAgB,CAChB,mFA0BD,CAtBC,qCAgBC,mBAAsB,CADtB,sBAAyB,CAEzB,4BAA6B,CAH7B,4CAA6C,CAF7C,sFAAuF,CADvF,oFAAqF,CASrF,qBAAsB,CAdtB,QAAS,CAJT,QAAS,CAGT,SAAU,CADV,OAAQ,CAKR,mCAAoC,CACpC,yBAA0B,CAH1B,OAcD,CAGD,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,wCACC,GACC,SACD,CAEA,GACC,SACD,CACD,CAEA,yCACC,GAGC,QAAS,CAFT,SAAU,CACV,OAED,CACA,IAEC,QAAS,CADT,UAED,CACA,GAGC,YAAc,CAFd,SAAU,CACV,UAED,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-image-upload-complete-icon {\n	display: block;\n	position: absolute;\n\n	/*\n	 * Smaller images should have the icon closer to the border.\n	 * Match the icon position with the linked image indicator brought by the link image feature.\n	 */\n	top: min(var(--ck-spacing-medium), 6%);\n	right: min(var(--ck-spacing-medium), 6%);\n	border-radius: 50%;\n	z-index: 1;\n\n	&::after {\n		content: "";\n		position: absolute;\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-image-upload-icon: hsl(0, 0%, 100%);\n	--ck-color-image-upload-icon-background: hsl(120, 100%, 27%);\n\n	/* Match the icon size with the linked image indicator brought by the link image feature. */\n	--ck-image-upload-icon-size: 20;\n	--ck-image-upload-icon-width: 2px;\n	--ck-image-upload-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck-image-upload-complete-icon {\n	opacity: 0;\n	background: var(--ck-color-image-upload-icon-background);\n	animation-name: ck-upload-complete-icon-show, ck-upload-complete-icon-hide;\n	animation-fill-mode: forwards, forwards;\n	animation-duration: 500ms, 500ms;\n\n	/* To make animation scalable. */\n	font-size: calc(1px * var(--ck-image-upload-icon-size));\n\n	/* Hide completed upload icon after 3 seconds. */\n	animation-delay: 0ms, 3000ms;\n\n	/*\n	 * Use CSS math to simulate container queries.\n	 * https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n	 */\n	overflow: hidden;\n	width: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n	height: calc(var(--ck-image-upload-icon-is-visible) * var(--ck-image-upload-icon-size));\n\n	/* This is check icon element made from border-width mixed with animations. */\n	&::after {\n		/* Because of border transformation we need to "hard code" left position. */\n		left: 25%;\n\n		top: 50%;\n		opacity: 0;\n		height: 0;\n		width: 0;\n\n		transform: scaleX(-1) rotate(135deg);\n		transform-origin: left top;\n		border-top: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n		border-right: var(--ck-image-upload-icon-width) solid var(--ck-color-image-upload-icon);\n\n		animation-name: ck-upload-complete-icon-check;\n		animation-duration: 500ms;\n		animation-delay: 500ms;\n		animation-fill-mode: forwards;\n\n		/* #1095. While reset is not providing proper box-sizing for pseudoelements, we need to handle it. */\n		box-sizing: border-box;\n	}\n}\n\n@keyframes ck-upload-complete-icon-show {\n	from {\n		opacity: 0;\n	}\n\n	to {\n		opacity: 1;\n	}\n}\n\n@keyframes ck-upload-complete-icon-hide {\n	from {\n		opacity: 1;\n	}\n\n	to {\n		opacity: 0;\n	}\n}\n\n@keyframes ck-upload-complete-icon-check {\n	0% {\n		opacity: 1;\n		width: 0;\n		height: 0;\n	}\n	33% {\n		width: 0.3em;\n		height: 0;\n	}\n	100% {\n		opacity: 1;\n		width: 0.3em;\n		height: 0.45em;\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 3773: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck .ck-upload-placeholder-loader{align-items:center;display:flex;justify-content:center;left:0;position:absolute;top:0}.ck .ck-upload-placeholder-loader:before{content:"";position:relative}:root{--ck-color-upload-placeholder-loader:#b3b3b3;--ck-upload-placeholder-loader-size:32px;--ck-upload-placeholder-image-aspect-ratio:2.8}.ck .ck-image-upload-placeholder{margin:0;width:100%}.ck .ck-image-upload-placeholder.image-inline{width:calc(var(--ck-upload-placeholder-loader-size)*2*var(--ck-upload-placeholder-image-aspect-ratio))}.ck .ck-image-upload-placeholder img{aspect-ratio:var(--ck-upload-placeholder-image-aspect-ratio)}.ck .ck-upload-placeholder-loader{height:100%;width:100%}.ck .ck-upload-placeholder-loader:before{animation:ck-upload-placeholder-loader 1s linear infinite;border-radius:50%;border-right:2px solid transparent;border-top:3px solid var(--ck-color-upload-placeholder-loader);height:var(--ck-upload-placeholder-loader-size);width:var(--ck-upload-placeholder-loader-size)}@keyframes ck-upload-placeholder-loader{to{transform:rotate(1turn)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadloader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadloader.css"], names: [], mappings: "AAKA,kCAGC,kBAAmB,CADnB,YAAa,CAEb,sBAAuB,CAEvB,MAAO,CALP,iBAAkB,CAIlB,KAOD,CAJC,yCACC,UAAW,CACX,iBACD,CCXD,MACC,4CAAqD,CACrD,wCAAyC,CACzC,8CACD,CAEA,iCAGC,QAAS,CADT,UAgBD,CAbC,8CACC,sGACD,CAEA,qCAOC,4DACD,CAGD,kCAEC,WAAY,CADZ,UAWD,CARC,yCAMC,yDAA0D,CAH1D,iBAAkB,CAElB,kCAAmC,CADnC,8DAA+D,CAF/D,+CAAgD,CADhD,8CAMD,CAGD,wCACC,GACC,uBACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-upload-placeholder-loader {\n	position: absolute;\n	display: flex;\n	align-items: center;\n	justify-content: center;\n	top: 0;\n	left: 0;\n\n	&::before {\n		content: '';\n		position: relative;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-upload-placeholder-loader: hsl(0, 0%, 70%);\n	--ck-upload-placeholder-loader-size: 32px;\n	--ck-upload-placeholder-image-aspect-ratio: 2.8;\n}\n\n.ck .ck-image-upload-placeholder {\n	/* We need to control the full width of the SVG gray background. */\n	width: 100%;\n	margin: 0;\n\n	&.image-inline {\n		width: calc( 2 * var(--ck-upload-placeholder-loader-size) * var(--ck-upload-placeholder-image-aspect-ratio) );\n	}\n\n	& img {\n		/*\n		 * This is an arbitrary aspect for a 1x1 px GIF to display to the user. Not too tall, not too short.\n		 * There's nothing special about this number except that it should make the image placeholder look like\n		 * a real image during this short period after the upload started and before the image was read from the\n		 * file system (and a rich preview was loaded).\n		 */\n		aspect-ratio: var(--ck-upload-placeholder-image-aspect-ratio);\n	}\n}\n\n.ck .ck-upload-placeholder-loader {\n	width: 100%;\n	height: 100%;\n\n	&::before {\n		width: var(--ck-upload-placeholder-loader-size);\n		height: var(--ck-upload-placeholder-loader-size);\n		border-radius: 50%;\n		border-top: 3px solid var(--ck-color-upload-placeholder-loader);\n		border-right: 2px solid transparent;\n		animation: ck-upload-placeholder-loader 1s linear infinite;\n	}\n}\n\n@keyframes ck-upload-placeholder-loader {\n	to {\n		transform: rotate( 360deg );\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3689: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-editor__editable .image,.ck.ck-editor__editable .image-inline{position:relative}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{left:0;position:absolute;top:0}.ck.ck-editor__editable .image-inline.ck-appear,.ck.ck-editor__editable .image.ck-appear{animation:fadeIn .7s}.ck.ck-editor__editable .image .ck-progress-bar,.ck.ck-editor__editable .image-inline .ck-progress-bar{background:var(--ck-color-upload-bar-background);height:2px;transition:width .1s;width:0}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/imageuploadprogress.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-image/imageuploadprogress.css"], names: [], mappings: "AAMC,qEAEC,iBACD,CAGA,uGAIC,MAAO,CAFP,iBAAkB,CAClB,KAED,CCRC,yFACC,oBACD,CAID,uGAIC,gDAAiD,CAFjD,UAAW,CAGX,oBAAuB,CAFvB,OAGD,CAGD,kBACC,GAAO,SAAY,CACnB,GAAO,SAAY,CACpB", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	& .image,\n	& .image-inline {\n		position: relative;\n	}\n\n	/* Upload progress bar. */\n	& .image .ck-progress-bar,\n	& .image-inline .ck-progress-bar {\n		position: absolute;\n		top: 0;\n		left: 0;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	& .image,\n	& .image-inline {\n		/* Showing animation. */\n		&.ck-appear {\n			animation: fadeIn 700ms;\n		}\n	}\n\n	/* Upload progress bar. */\n	& .image .ck-progress-bar,\n	& .image-inline .ck-progress-bar {\n		height: 2px;\n		width: 0;\n		background: var(--ck-color-upload-bar-background);\n		transition: width 100ms;\n	}\n}\n\n@keyframes fadeIn {\n	from { opacity: 0; }\n	to   { opacity: 1; }\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 1905: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-text-alternative-form{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-text-alternative-form .ck-labeled-field-view{display:inline-block}.ck.ck-text-alternative-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-text-alternative-form{flex-wrap:wrap}.ck.ck-text-alternative-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-text-alternative-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./../ckeditor5-image/theme/textalternativeform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,6BACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,oDACC,oBACD,CAEA,uCACC,YACD,CCZA,oCDCD,6BAcE,cAUF,CARE,oDACC,eACD,CAEA,wCACC,cACD,CCrBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-text-alternative-form {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-labeled-field-view {\n		display: inline-block;\n	}\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 9773: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck .ck-link_selected{background:var(--ck-color-link-selected-background)}.ck .ck-link_selected span.image-inline{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background)}.ck .ck-fake-link-selection{background:var(--ck-color-link-fake-selection)}.ck .ck-fake-link-selection_collapsed{border-right:1px solid var(--ck-color-base-text);height:100%;margin-right:-1px;outline:1px solid hsla(0,0%,100%,.5)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/link.css"], names: [], mappings: "AAMA,sBACC,mDAMD,CAHC,wCACC,yFACD,CAOD,4BACC,8CACD,CAGA,sCAEC,gDAAiD,CADjD,WAAY,CAEZ,iBAAkB,CAClB,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/* Class added to span element surrounding currently selected link. */\n.ck .ck-link_selected {\n	background: var(--ck-color-link-selected-background);\n\n	/* Give linked inline images some outline to let the user know they are also part of the link. */\n	& span.image-inline {\n		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-link-selected-background);\n	}\n}\n\n/*\n * Classes used by the "fake visual selection" displayed in the content when an input\n * in the link UI has focus (the browser does not render the native selection in this state).\n */\n.ck .ck-fake-link-selection {\n	background: var(--ck-color-link-fake-selection);\n}\n\n/* A collapsed fake visual selection. */\n.ck .ck-fake-link-selection_collapsed {\n	height: 100%;\n	border-right: 1px solid var(--ck-color-base-text);\n	margin-right: -1px;\n	outline: solid 1px hsla(0, 0%, 100%, .5);\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 2347: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-link-actions{display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-link-actions .ck-link-actions__preview{display:inline-block}.ck.ck-link-actions .ck-link-actions__preview .ck-button__label{overflow:hidden}@media screen and (max-width:600px){.ck.ck-link-actions{flex-wrap:wrap}.ck.ck-link-actions .ck-link-actions__preview{flex-basis:100%}.ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){flex-basis:50%}}.ck.ck-link-actions .ck-button.ck-link-actions__preview{padding-left:0;padding-right:0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{color:var(--ck-color-link-default);cursor:pointer;max-width:var(--ck-input-width);min-width:3em;padding:0 var(--ck-spacing-medium);text-align:center;text-overflow:ellipsis}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label:hover{text-decoration:underline}.ck.ck-link-actions .ck-button.ck-link-actions__preview,.ck.ck-link-actions .ck-button.ck-link-actions__preview:active,.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus,.ck.ck-link-actions .ck-button.ck-link-actions__preview:hover{background:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:active{box-shadow:none}.ck.ck-link-actions .ck-button.ck-link-actions__preview:focus .ck-button__label{text-decoration:underline}[dir=ltr] .ck.ck-link-actions .ck-button:not(:first-child),[dir=rtl] .ck.ck-link-actions .ck-button:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-link-actions .ck-button.ck-link-actions__preview{margin:var(--ck-spacing-standard) var(--ck-spacing-standard) 0}.ck.ck-link-actions .ck-button.ck-link-actions__preview .ck-button__label{max-width:100%;min-width:0}[dir=ltr] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview),[dir=rtl] .ck.ck-link-actions .ck-button:not(.ck-link-actions__preview){margin-left:0}}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkactions.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkactions.css"], names: [], mappings: "AAOA,oBACC,YAAa,CACb,kBAAmB,CACnB,gBAqBD,CAnBC,8CACC,oBAKD,CAHC,gEACC,eACD,CCXD,oCDCD,oBAcE,cAUF,CARE,8CACC,eACD,CAEA,8DACC,cACD,CCrBD,CCIA,wDACC,cAAe,CACf,eAmCD,CAjCC,0EAEC,kCAAmC,CAEnC,cAAe,CAIf,+BAAgC,CAChC,aAAc,CARd,kCAAmC,CASnC,iBAAkB,CAPlB,sBAYD,CAHC,gFACC,yBACD,CAGD,mPAIC,eACD,CAEA,+DACC,eACD,CAGC,gFACC,yBACD,CAWD,qHACC,sCACD,CDtDD,oCC0DC,wDACC,8DAMD,CAJC,0EAEC,cAAe,CADf,WAED,CAGD,gJAME,aAEF,CDzED", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-actions {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-link-actions__preview {\n		display: inline-block;\n\n		& .ck-button__label {\n			overflow: hidden;\n		}\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-link-actions__preview {\n			flex-basis: 100%;\n		}\n\n		& .ck-button:not(.ck-link-actions__preview) {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_unselectable.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../mixins/_focus.css";
@import "../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";

.ck.ck-link-actions {
	& .ck-button.ck-link-actions__preview {
		padding-left: 0;
		padding-right: 0;

		& .ck-button__label {
			padding: 0 var(--ck-spacing-medium);
			color: var(--ck-color-link-default);
			text-overflow: ellipsis;
			cursor: pointer;

			/* Match the box model of the link editor form's input so the balloon
			does not change width when moving between actions and the form. */
			max-width: var(--ck-input-width);
			min-width: 3em;
			text-align: center;

			&:hover {
				text-decoration: underline;
			}
		}

		&,
		&:hover,
		&:focus,
		&:active {
			background: none;
		}

		&:active {
			box-shadow: none;
		}

		&:focus {
			& .ck-button__label {
				text-decoration: underline;
			}
		}
	}

	@mixin ck-dir ltr {
		& .ck-button:not(:first-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-button:not(:last-child) {
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-media-phone {
		& .ck-button.ck-link-actions__preview {
			margin: var(--ck-spacing-standard) var(--ck-spacing-standard) 0;

			& .ck-button__label {
				min-width: 0;
				max-width: 100%;
			}
		}

		& .ck-button:not(.ck-link-actions__preview) {
			@mixin ck-dir ltr {
				margin-left: 0;
			}

			@mixin ck-dir rtl {
				margin-left: 0;
			}
		}
	}
}
`], sourceRoot: "" }]);
      const a2 = s2;
    }, 7754: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-link-form{display:flex}.ck.ck-link-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-link-form{flex-wrap:wrap}.ck.ck-link-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-link-form .ck-button{flex-basis:50%}}.ck.ck-link-form_layout-vertical{display:block}.ck.ck-link-form_layout-vertical .ck-button.ck-button-cancel,.ck.ck-link-form_layout-vertical .ck-button.ck-button-save{margin-top:var(--ck-spacing-medium)}.ck.ck-link-form_layout-vertical{min-width:var(--ck-input-width);padding:0}.ck.ck-link-form_layout-vertical .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small)}.ck.ck-link-form_layout-vertical .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-link-form_layout-vertical>.ck-button{border-radius:0;margin:0;padding:var(--ck-spacing-standard);width:50%}.ck.ck-link-form_layout-vertical>.ck-button:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-link-form_layout-vertical>.ck-button,[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button{margin-left:0}[dir=rtl] .ck.ck-link-form_layout-vertical>.ck-button:last-of-type{border-right:1px solid var(--ck-color-base-border)}.ck.ck-link-form_layout-vertical .ck.ck-list{margin:var(--ck-spacing-standard) var(--ck-spacing-large)}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton{padding:0;width:100%}.ck.ck-link-form_layout-vertical .ck.ck-list .ck-button.ck-switchbutton:hover{background:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkform.css"], names: [], mappings: "AAOA,iBACC,YAiBD,CAfC,2BACC,YACD,CCNA,oCDCD,iBAQE,cAUF,CARE,wCACC,eACD,CAEA,4BACC,cACD,CCfD,CDuBD,iCACC,aAYD,CALE,wHAEC,mCACD,CE/BF,iCAEC,+BAAgC,CADhC,SAgDD,CA7CC,wDACC,8EAMD,CAJC,uEACC,WAAY,CACZ,UACD,CAGD,4CAIC,eAAgB,CAFhB,QAAS,CADT,kCAAmC,CAEnC,SAkBD,CAfC,wDACC,gDACD,CARD,4GAeE,aAMF,CAJE,mEACC,kDACD,CAKF,6CACC,yDAUD,CARC,wEACC,SAAU,CACV,UAKD,CAHC,8EACC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-link-form {\n	display: flex;\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n	display: block;\n\n	/*\n	 * Whether the form is in the responsive mode or not, if there are decorator buttons\n	 * keep the top margin of action buttons medium.\n	 */\n	& .ck-button {\n		&.ck-button-save,\n		&.ck-button-cancel {\n			margin-top: var(--ck-spacing-medium);\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/*\n * Style link form differently when manual decorators are available.\n * See: https://github.com/ckeditor/ckeditor5-link/issues/186.\n */\n.ck.ck-link-form_layout-vertical {\n	padding: 0;\n	min-width: var(--ck-input-width);\n\n	& .ck-labeled-field-view {\n		margin: var(--ck-spacing-large) var(--ck-spacing-large) var(--ck-spacing-small);\n\n		& .ck-input-text {\n			min-width: 0;\n			width: 100%;\n		}\n	}\n\n	& > .ck-button {\n		padding: var(--ck-spacing-standard);\n		margin: 0;\n		width: 50%;\n		border-radius: 0;\n\n		&:not(:focus) {\n			border-top: 1px solid var(--ck-color-base-border);\n		}\n\n		@mixin ck-dir ltr {\n			margin-left: 0;\n		}\n\n		@mixin ck-dir rtl {\n			margin-left: 0;\n\n			&:last-of-type {\n				border-right: 1px solid var(--ck-color-base-border);\n			}\n		}\n	}\n\n	/* Using additional `.ck` class for stronger CSS specificity than `.ck.ck-link-form > :not(:first-child)`. */\n	& .ck.ck-list {\n		margin: var(--ck-spacing-standard) var(--ck-spacing-large);\n\n		& .ck-button.ck-switchbutton {\n			padding: 0;\n			width: 100%;\n\n			&:hover {\n				background: none;\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 111: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{display:block;position:absolute}:root{--ck-link-image-indicator-icon-size:20;--ck-link-image-indicator-icon-is-visible:clamp(0px,100% - 50px,1px)}.ck.ck-editor__editable a span.image-inline:after,.ck.ck-editor__editable figure.image>a:after{background-color:rgba(0,0,0,.4);background-image:url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");background-position:50%;background-repeat:no-repeat;background-size:14px;border-radius:100%;content:"";height:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size));overflow:hidden;right:min(var(--ck-spacing-medium),6%);top:min(var(--ck-spacing-medium),6%);width:calc(var(--ck-link-image-indicator-icon-is-visible)*var(--ck-link-image-indicator-icon-size))}', "", { version: 3, sources: ["webpack://./../ckeditor5-link/theme/linkimage.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-link/linkimage.css"], names: [], mappings: "AASE,+FACC,aAAc,CACd,iBACD,CCPF,MAEC,sCAAuC,CACvC,oEACD,CAME,+FAUC,+BAAqC,CACrC,83BAA+3B,CAG/3B,uBAA2B,CAD3B,2BAA4B,CAD5B,oBAAqB,CAGrB,kBAAmB,CAdnB,UAAW,CAsBX,oGAAuG,CAFvG,eAAgB,CAbhB,sCAAwC,CADxC,oCAAsC,CAetC,mGAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-editor__editable {\n	/* Linked image indicator */\n	& figure.image > a,\n	& a span.image-inline {\n		&::after {\n			display: block;\n			position: absolute;\n		}\n	}\n}\n\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/* Match the icon size with the upload indicator brought by the image upload feature. */\n	--ck-link-image-indicator-icon-size: 20;\n	--ck-link-image-indicator-icon-is-visible: clamp(0px, 100% - 50px, 1px);\n}\n\n.ck.ck-editor__editable {\n	/* Linked image indicator */\n	& figure.image > a,\n	& a span.image-inline {\n		&::after {\n			content: "";\n\n			/*\n			 * Smaller images should have the icon closer to the border.\n			 * Match the icon position with the upload indicator brought by the image upload feature.\n			 */\n			top: min(var(--ck-spacing-medium), 6%);\n			right: min(var(--ck-spacing-medium), 6%);\n\n			background-color: hsla(0, 0%, 0%, .4);\n			background-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZmlsbD0iI2ZmZiIgZD0ibTExLjA3NyAxNSAuOTkxLTEuNDE2YS43NS43NSAwIDEgMSAxLjIyOS44NmwtMS4xNDggMS42NGEuNzQ4Ljc0OCAwIDAgMS0uMjE3LjIwNiA1LjI1MSA1LjI1MSAwIDAgMS04LjUwMy01Ljk1NS43NDEuNzQxIDAgMCAxIC4xMi0uMjc0bDEuMTQ3LTEuNjM5YS43NS43NSAwIDEgMSAxLjIyOC44Nkw0LjkzMyAxMC43bC4wMDYuMDAzYTMuNzUgMy43NSAwIDAgMCA2LjEzMiA0LjI5NGwuMDA2LjAwNHptNS40OTQtNS4zMzVhLjc0OC43NDggMCAwIDEtLjEyLjI3NGwtMS4xNDcgMS42MzlhLjc1Ljc1IDAgMSAxLTEuMjI4LS44NmwuODYtMS4yM2EzLjc1IDMuNzUgMCAwIDAtNi4xNDQtNC4zMDFsLS44NiAxLjIyOWEuNzUuNzUgMCAwIDEtMS4yMjktLjg2bDEuMTQ4LTEuNjRhLjc0OC43NDggMCAwIDEgLjIxNy0uMjA2IDUuMjUxIDUuMjUxIDAgMCAxIDguNTAzIDUuOTU1em0tNC41NjMtMi41MzJhLjc1Ljc1IDAgMCAxIC4xODQgMS4wNDVsLTMuMTU1IDQuNTA1YS43NS43NSAwIDEgMS0xLjIyOS0uODZsMy4xNTUtNC41MDZhLjc1Ljc1IDAgMCAxIDEuMDQ1LS4xODR6Ii8+PC9zdmc+");\n			background-size: 14px;\n			background-repeat: no-repeat;\n			background-position: center;\n			border-radius: 100%;\n\n			/*\n			* Use CSS math to simulate container queries.\n			* https://css-tricks.com/the-raven-technique-one-step-closer-to-container-queries/#what-about-showing-and-hiding-things\n			*/\n			overflow: hidden;\n			width: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n			height: calc(var(--ck-link-image-indicator-icon-is-visible) * var(--ck-link-image-indicator-icon-size));\n		}\n	}\n}\n\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 4721: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-collapsible.ck-collapsible_collapsed>.ck-collapsible__children{display:none}:root{--ck-collapsible-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-collapsible>.ck.ck-button{border-radius:0;color:inherit;font-weight:700;padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-collapsible>.ck.ck-button:focus{background:transparent}.ck.ck-collapsible>.ck.ck-button:active,.ck.ck-collapsible>.ck.ck-button:hover:not(:focus),.ck.ck-collapsible>.ck.ck-button:not(:focus){background:transparent;border-color:transparent;box-shadow:none}.ck.ck-collapsible>.ck.ck-button>.ck-icon{margin-right:var(--ck-spacing-medium);width:var(--ck-collapsible-arrow-size)}.ck.ck-collapsible>.ck-collapsible__children{padding:0 var(--ck-spacing-large) var(--ck-spacing-large)}.ck.ck-collapsible.ck-collapsible_collapsed>.ck.ck-button .ck-icon{transform:rotate(-90deg)}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/collapsible.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/collapsible.css"], names: [], mappings: "AAMC,sEACC,YACD,CCHD,MACC,yDACD,CAGC,iCAIC,eAAgB,CAChB,aAAc,CAHd,eAAiB,CACjB,wDAAyD,CAFzD,UAoBD,CAdC,uCACC,sBACD,CAEA,wIACC,sBAAuB,CACvB,wBAAyB,CACzB,eACD,CAEA,0CACC,qCAAsC,CACtC,sCACD,CAGD,6CACC,yDACD,CAGC,mEACC,wBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-collapsible.ck-collapsible_collapsed {\n	& > .ck-collapsible__children {\n		display: none;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-collapsible-arrow-size: calc(0.5 * var(--ck-icon-size));\n}\n\n.ck.ck-collapsible {\n	& > .ck.ck-button {\n		width: 100%;\n		font-weight: bold;\n		padding: var(--ck-spacing-medium) var(--ck-spacing-large);\n		border-radius: 0;\n		color: inherit;\n\n		&:focus {\n			background: transparent;\n		}\n\n		&:active, &:not(:focus), &:hover:not(:focus) {\n			background: transparent;\n			border-color: transparent;\n			box-shadow: none;\n		}\n\n		& > .ck-icon {\n			margin-right: var(--ck-spacing-medium);\n			width: var(--ck-collapsible-arrow-size);\n		}\n	}\n\n	& > .ck-collapsible__children {\n		padding: 0 var(--ck-spacing-large) var(--ck-spacing-large);\n	}\n\n	&.ck-collapsible_collapsed {\n		& > .ck.ck-button .ck-icon {\n			transform: rotate(-90deg);\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 5730: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-editor__editable .ck-list-bogus-paragraph{display:block}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/documentlist.css"], names: [], mappings: "AAKA,8CACC,aACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-editor__editable .ck-list-bogus-paragraph {\n	display: block;\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4564: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-content ol{list-style-type:decimal}.ck-content ol ol{list-style-type:lower-latin}.ck-content ol ol ol{list-style-type:lower-roman}.ck-content ol ol ol ol{list-style-type:upper-latin}.ck-content ol ol ol ol ol{list-style-type:upper-roman}.ck-content ul{list-style-type:disc}.ck-content ul ul{list-style-type:circle}.ck-content ul ul ul,.ck-content ul ul ul ul{list-style-type:square}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/list.css"], names: [], mappings: "AAKA,eACC,uBAiBD,CAfC,kBACC,2BAaD,CAXC,qBACC,2BASD,CAPC,wBACC,2BAKD,CAHC,2BACC,2BACD,CAMJ,eACC,oBAaD,CAXC,kBACC,sBASD,CAJE,6CACC,sBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content ol {\n	list-style-type: decimal;\n\n	& ol {\n		list-style-type: lower-latin;\n\n		& ol {\n			list-style-type: lower-roman;\n\n			& ol {\n				list-style-type: upper-latin;\n\n				& ol {\n					list-style-type: upper-roman;\n				}\n			}\n		}\n	}\n}\n\n.ck-content ul {\n	list-style-type: disc;\n\n	& ul {\n		list-style-type: circle;\n\n		& ul {\n			list-style-type: square;\n\n			& ul {\n				list-style-type: square;\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 6082: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-list-properties.ck-list-properties_without-styles{padding:var(--ck-spacing-large)}.ck.ck-list-properties.ck-list-properties_without-styles>*{min-width:14em}.ck.ck-list-properties.ck-list-properties_without-styles>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-list-styles-list{grid-template-columns:repeat(4,auto)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible{border-top:1px solid var(--ck-color-base-border)}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*{width:100%}.ck.ck-list-properties.ck-list-properties_with-numbered-properties>.ck-collapsible>.ck-collapsible__children>*+*{margin-top:var(--ck-spacing-standard)}.ck.ck-list-properties .ck.ck-numbered-list-properties__start-index .ck-input{min-width:auto;width:100%}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order{background:transparent;margin-bottom:calc(var(--ck-spacing-tiny)*-1);padding-left:0;padding-right:0}.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:active,.ck.ck-list-properties .ck.ck-numbered-list-properties__reversed-order:hover{background:none;border-color:transparent;box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/listproperties.css"], names: [], mappings: "AAOC,yDACC,+BASD,CAPC,2DACC,cAKD,CAHC,6DACC,qCACD,CASD,wFACC,oCACD,CAGA,mFACC,gDAWD,CARE,+GACC,UAKD,CAHC,iHACC,qCACD,CAMJ,8EACC,cAAe,CACf,UACD,CAEA,uEACC,sBAAuB,CAGvB,6CAAgD,CAFhD,cAAe,CACf,eAQD,CALC,2JAGC,eAAgB,CADhB,wBAAyB,CADzB,eAGD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-properties {\n	/* When there are no list styles and there is no collapsible. */\n	&.ck-list-properties_without-styles {\n		padding: var(--ck-spacing-large);\n\n		& > * {\n			min-width: 14em;\n\n			& + * {\n				margin-top: var(--ck-spacing-standard);\n			}\n		}\n	}\n\n	/*\n	 * When the numbered list property fields (start at, reversed) should be displayed,\n	 * more horizontal space is needed. Reconfigure the style grid to create that space.\n	 */\n	&.ck-list-properties_with-numbered-properties {\n		& > .ck-list-styles-list {\n			grid-template-columns: repeat( 4, auto );\n		}\n\n		/* When list styles are rendered and property fields are in a collapsible. */\n		& > .ck-collapsible {\n			border-top: 1px solid var(--ck-color-base-border);\n\n			& > .ck-collapsible__children {\n				& > * {\n					width: 100%;\n\n					& + * {\n						margin-top: var(--ck-spacing-standard);\n					}\n				}\n			}\n		}\n	}\n\n	& .ck.ck-numbered-list-properties__start-index .ck-input {\n		min-width: auto;\n		width: 100%;\n	}\n\n	& .ck.ck-numbered-list-properties__reversed-order {\n		background: transparent;\n		padding-left: 0;\n		padding-right: 0;\n		margin-bottom: calc(-1 * var(--ck-spacing-tiny));\n\n		&:active, &:hover {\n			box-shadow: none;\n			border-color: transparent;\n			background: none;\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 2417: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-list-styles-list{display:grid}:root{--ck-list-style-button-size:44px}.ck.ck-list-styles-list{column-gap:var(--ck-spacing-medium);grid-template-columns:repeat(3,auto);padding:var(--ck-spacing-large);row-gap:var(--ck-spacing-medium)}.ck.ck-list-styles-list .ck-button{box-sizing:content-box;margin:0;padding:0}.ck.ck-list-styles-list .ck-button,.ck.ck-list-styles-list .ck-button .ck-icon{height:var(--ck-list-style-button-size);width:var(--ck-list-style-button-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/liststyles.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-list/liststyles.css"], names: [], mappings: "AAKA,wBACC,YACD,CCFA,MACC,gCACD,CAEA,wBAGC,mCAAoC,CAFpC,oCAAwC,CAGxC,+BAAgC,CAFhC,gCA4BD,CAxBC,mCAiBC,sBAAuB,CAPvB,QAAS,CANT,SAmBD,CAJC,+EAhBA,uCAAwC,CADxC,sCAoBA", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-list-styles-list {\n	display: grid;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-list-style-button-size: 44px;\n}\n\n.ck.ck-list-styles-list {\n	grid-template-columns: repeat( 3, auto );\n	row-gap: var(--ck-spacing-medium);\n	column-gap: var(--ck-spacing-medium);\n	padding: var(--ck-spacing-large);\n\n	& .ck-button {\n		/* Make the button look like a thumbnail (the icon "takes it all"). */\n		width: var(--ck-list-style-button-size);\n		height: var(--ck-list-style-button-size);\n		padding: 0;\n\n		/*\n		 * Buttons are aligned by the grid so disable default button margins to not collide with the\n		 * gaps in the grid.\n		 */\n		margin: 0;\n\n		/*\n		 * Make sure the button border (which is displayed on focus, BTW) does not steal pixels\n		 * from the button dimensions and, as a result, decrease the size of the icon\n		 * (which becomes blurry as it scales down).\n		 */\n		box-sizing: content-box;\n\n		& .ck-icon {\n			width: var(--ck-list-style-button-size);\n			height: var(--ck-list-style-button-size);\n		}\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 1199: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ':root{--ck-todo-list-checkmark-size:16px}.ck-content .todo-list{list-style:none}.ck-content .todo-list li{margin-bottom:5px;position:relative}.ck-content .todo-list li .todo-list{margin-top:5px}.ck-content .todo-list .todo-list__label>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-content[dir=rtl] .todo-list .todo-list__label>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-content .todo-list .todo-list__label>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}.ck-content .todo-list .todo-list__label>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-content .todo-list .todo-list__label>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-content .todo-list .todo-list__label>input[checked]:after{border-color:#fff}.ck-content .todo-list .todo-list__label .todo-list__label__description{vertical-align:middle}.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}.ck-editor__editable.ck-content .todo-list .todo-list__label>input,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{cursor:pointer}.ck-editor__editable.ck-content .todo-list .todo-list__label>input:hover:before,.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:hover:before{box-shadow:0 0 0 5px rgba(0,0,0,.1)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input{-webkit-appearance:none;border:0;display:inline-block;height:var(--ck-todo-list-checkmark-size);left:-25px;margin-left:0;margin-right:-15px;position:relative;right:0;vertical-align:middle;width:var(--ck-todo-list-checkmark-size)}.ck-editor__editable.ck-content[dir=rtl] .todo-list .todo-list__label>span[contenteditable=false]>input{left:0;margin-left:-15px;margin-right:0;right:-25px}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:before{border:1px solid #333;border-radius:2px;box-sizing:border-box;content:"";display:block;height:100%;position:absolute;transition:box-shadow .25s ease-in-out;width:100%}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input:after{border-color:transparent;border-style:solid;border-width:0 calc(var(--ck-todo-list-checkmark-size)/8) calc(var(--ck-todo-list-checkmark-size)/8) 0;box-sizing:content-box;content:"";display:block;height:calc(var(--ck-todo-list-checkmark-size)/2.6);left:calc(var(--ck-todo-list-checkmark-size)/3);pointer-events:none;position:absolute;top:calc(var(--ck-todo-list-checkmark-size)/5.3);transform:rotate(45deg);width:calc(var(--ck-todo-list-checkmark-size)/5.3)}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:before{background:#26ab33;border-color:#26ab33}.ck-editor__editable.ck-content .todo-list .todo-list__label>span[contenteditable=false]>input[checked]:after{border-color:#fff}.ck-editor__editable.ck-content .todo-list .todo-list__label.todo-list__label_without-description input[type=checkbox]{position:absolute}', "", { version: 3, sources: ["webpack://./../ckeditor5-list/theme/todolist.css"], names: [], mappings: "AAKA,MACC,kCACD,CAwEA,uBACC,eAwBD,CAtBC,0BAEC,iBAAkB,CADlB,iBAMD,CAHC,qCACC,cACD,CAIA,+CAlFD,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAiFC,CAFA,wDAhEA,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAgEA,CA5DD,sDAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,sCAAwC,CAJxC,UAKD,CAEA,qDAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+DACC,kBAA8B,CAC9B,oBACD,CAEA,8DACC,iBACD,CAwBA,wEACC,qBACD,CAEA,mGACC,iBACD,CAYD,kKAEC,cAKD,CAHC,4LACC,mCACD,CAMD,+FApHA,uBAAwB,CAQxB,QAAS,CAPT,oBAAqB,CAGrB,yCAA0C,CAO1C,UAAW,CAGX,aAAc,CAFd,kBAAmB,CAVnB,iBAAkB,CAWlB,OAAQ,CARR,qBAAsB,CAFtB,wCAmHA,CAFA,wGAlGC,MAAO,CAGP,iBAAkB,CAFlB,cAAe,CACf,WAkGD,CA9FA,sGAOC,qBAAiC,CACjC,iBAAkB,CALlB,qBAAsB,CACtB,UAAW,CAHX,aAAc,CAKd,WAAY,CAJZ,iBAAkB,CAOlB,sCAAwC,CAJxC,UAKD,CAEA,qGAaC,wBAAyB,CADzB,kBAAmB,CAEnB,sGAA+G,CAX/G,sBAAuB,CAEvB,UAAW,CAJX,aAAc,CAUd,mDAAwD,CAHxD,+CAAoD,CAJpD,mBAAoB,CAFpB,iBAAkB,CAOlB,gDAAqD,CAMrD,uBAAwB,CALxB,kDAMD,CAGC,+GACC,kBAA8B,CAC9B,oBACD,CAEA,8GACC,iBACD,CA2DA,uHACC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-todo-list-checkmark-size: 16px;\n}\n\n@define-mixin todo-list-checkbox {\n	-webkit-appearance: none;\n	display: inline-block;\n	position: relative;\n	width: var(--ck-todo-list-checkmark-size);\n	height: var(--ck-todo-list-checkmark-size);\n	vertical-align: middle;\n\n	/* Needed on iOS */\n	border: 0;\n\n	/* LTR styles */\n	left: -25px;\n	margin-right: -15px;\n	right: 0;\n	margin-left: 0;\n\n	/* RTL styles */\n	@nest [dir=rtl]& {\n		left: 0;\n		margin-right: 0;\n		right: -25px;\n		margin-left: -15px;\n	}\n\n	&::before {\n		display: block;\n		position: absolute;\n		box-sizing: border-box;\n		content: '';\n		width: 100%;\n		height: 100%;\n		border: 1px solid hsl(0, 0%, 20%);\n		border-radius: 2px;\n		transition: 250ms ease-in-out box-shadow;\n	}\n\n	&::after {\n		display: block;\n		position: absolute;\n		box-sizing: content-box;\n		pointer-events: none;\n		content: '';\n\n		/* Calculate tick position, size and border-width proportional to the checkmark size. */\n		left: calc( var(--ck-todo-list-checkmark-size) / 3 );\n		top: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n		width: calc( var(--ck-todo-list-checkmark-size) / 5.3 );\n		height: calc( var(--ck-todo-list-checkmark-size) / 2.6 );\n		border-style: solid;\n		border-color: transparent;\n		border-width: 0 calc( var(--ck-todo-list-checkmark-size) / 8 ) calc( var(--ck-todo-list-checkmark-size) / 8 ) 0;\n		transform: rotate(45deg);\n	}\n\n	&[checked] {\n		&::before {\n			background: hsl(126, 64%, 41%);\n			border-color: hsl(126, 64%, 41%);\n		}\n\n		&::after {\n			border-color: hsl(0, 0%, 100%);\n		}\n	}\n}\n\n/*\n * To-do list content styles.\n */\n.ck-content .todo-list {\n	list-style: none;\n\n	& li {\n		position: relative;\n		margin-bottom: 5px;\n\n		& .todo-list {\n			margin-top: 5px;\n		}\n	}\n\n	& .todo-list__label {\n		& > input {\n			@mixin todo-list-checkbox;\n		}\n\n		& .todo-list__label__description {\n			vertical-align: middle;\n		}\n\n		&.todo-list__label_without-description input[type=checkbox] {\n			position: absolute;\n		}\n	}\n}\n\n/*\n * To-do list editing view styles.\n */\n.ck-editor__editable.ck-content .todo-list .todo-list__label {\n	/*\n	 * To-do list should be interactive only during the editing\n	 * (https://github.com/ckeditor/ckeditor5/issues/2090).\n	 */\n	& > input,\n	& > span[contenteditable=false] > input {\n		cursor: pointer;\n\n		&:hover::before {\n			box-shadow: 0 0 0 5px hsla(0, 0%, 0%, 0.1);\n		}\n	}\n\n	/*\n	 * Document Lists - editing view has an additional span around checkbox.\n	 */\n	& > span[contenteditable=false] > input {\n		@mixin todo-list-checkbox;\n	}\n\n	&.todo-list__label_without-description {\n		& input[type=checkbox] {\n			position: absolute;\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4652: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-content .media{clear:both;display:block;margin:.9em 0;min-width:15em}", "", { version: 3, sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembed.css"], names: [], mappings: "AAKA,mBAGC,UAAW,CASX,aAAc,CAJd,aAAe,CAQf,cACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-content .media {\n	/* Don\'t allow floated content overlap the media.\n	https://github.com/ckeditor/ckeditor5-media-embed/issues/53 */\n	clear: both;\n\n	/* Make sure there is some space between the content and the media. */\n	/* The first value should be equal to --ck-spacing-large variable if used in the editor context\n	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */\n	margin: 0.9em 0;\n\n	/* Make sure media is not overriden with Bootstrap default `flex` value.\n	See: https://github.com/ckeditor/ckeditor5/issues/1373. */\n	display: block;\n\n	/* Give the media some minimal width in the content to prevent them\n	from being "squashed" in tight spaces, e.g. in table cells (#44) */\n	min-width: 15em;\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 7442: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck-media__wrapper .ck-media__placeholder{align-items:center;display:flex;flex-direction:column}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url{max-width:100%;position:relative}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url .ck-media__placeholder__url__text{display:block;overflow:hidden}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon *,.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck-media__placeholder__icon *{display:none}.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper>:not(.ck-media__placeholder),.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder{pointer-events:none}:root{--ck-media-embed-placeholder-icon-size:3em;--ck-color-media-embed-placeholder-url-text:#757575;--ck-color-media-embed-placeholder-url-text-hover:var(--ck-color-base-text)}.ck-media__wrapper{margin:0 auto}.ck-media__wrapper .ck-media__placeholder{background:var(--ck-color-base-foreground);padding:calc(var(--ck-spacing-standard)*3)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon{background-position:50%;background-size:cover;height:var(--ck-media-embed-placeholder-icon-size);margin-bottom:var(--ck-spacing-large);min-width:var(--ck-media-embed-placeholder-icon-size)}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__icon .ck-icon{height:100%;width:100%}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text{color:var(--ck-color-media-embed-placeholder-url-text);font-style:italic;text-align:center;text-overflow:ellipsis;white-space:nowrap}.ck-media__wrapper .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:var(--ck-color-media-embed-placeholder-url-text-hover);cursor:pointer;text-decoration:underline}.ck-media__wrapper[data-oembed-url*="open.spotify.com"]{max-height:380px;max-width:300px}.ck-media__wrapper[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon,.ck-media__wrapper[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Im0yMDYuNDc3IDI2MC45LTI4Ljk4NyAyOC45ODdhNS4yMTggNS4yMTggMCAwIDAgMy43OCAxLjYxaDQ5LjYyMWMxLjY5NCAwIDMuMTktLjc5OCA0LjE0Ni0yLjAzN3oiIGZpbGw9IiM1Yzg4YzUiLz48cGF0aCBkPSJNMjI2Ljc0MiAyMjIuOTg4Yy05LjI2NiAwLTE2Ljc3NyA3LjE3LTE2Ljc3NyAxNi4wMTQuMDA3IDIuNzYyLjY2MyA1LjQ3NCAyLjA5MyA3Ljg3NS40My43MDMuODMgMS40MDggMS4xOSAyLjEwNy4zMzMuNTAyLjY1IDEuMDA1Ljk1IDEuNTA4LjM0My40NzcuNjczLjk1Ny45ODggMS40NCAxLjMxIDEuNzY5IDIuNSAzLjUwMiAzLjYzNyA1LjE2OC43OTMgMS4yNzUgMS42ODMgMi42NCAyLjQ2NiAzLjk5IDIuMzYzIDQuMDk0IDQuMDA3IDguMDkyIDQuNiAxMy45MTR2LjAxMmMuMTgyLjQxMi41MTYuNjY2Ljg3OS42NjcuNDAzLS4wMDEuNzY4LS4zMTQuOTMtLjc5OS42MDMtNS43NTYgMi4yMzgtOS43MjkgNC41ODUtMTMuNzk0Ljc4Mi0xLjM1IDEuNjczLTIuNzE1IDIuNDY1LTMuOTkgMS4xMzctMS42NjYgMi4zMjgtMy40IDMuNjM4LTUuMTY5LjMxNS0uNDgyLjY0NS0uOTYyLjk4OC0xLjQzOS4zLS41MDMuNjE3LTEuMDA2Ljk1LTEuNTA4LjM1OS0uNy43Ni0xLjQwNCAxLjE5LTIuMTA3IDEuNDI2LTIuNDAyIDItNS4xMTQgMi4wMDQtNy44NzUgMC04Ljg0NC03LjUxMS0xNi4wMTQtMTYuNzc2LTE2LjAxNHoiIGZpbGw9IiNkZDRiM2UiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PGVsbGlwc2Ugcnk9IjUuNTY0IiByeD0iNS44MjgiIGN5PSIyMzkuMDAyIiBjeD0iMjI2Ljc0MiIgZmlsbD0iIzgwMmQyNyIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMTkwLjMwMSAyMzcuMjgzYy00LjY3IDAtOC40NTcgMy44NTMtOC40NTcgOC42MDZzMy43ODYgOC42MDcgOC40NTcgOC42MDdjMy4wNDMgMCA0LjgwNi0uOTU4IDYuMzM3LTIuNTE2IDEuNTMtMS41NTcgMi4wODctMy45MTMgMi4wODctNi4yOSAwLS4zNjItLjAyMy0uNzIyLS4wNjQtMS4wNzloLTguMjU3djMuMDQzaDQuODVjLS4xOTcuNzU5LS41MzEgMS40NS0xLjA1OCAxLjk4Ni0uOTQyLjk1OC0yLjAyOCAxLjU0OC0zLjkwMSAxLjU0OC0yLjg3NiAwLTUuMjA4LTIuMzcyLTUuMjA4LTUuMjk5IDAtMi45MjYgMi4zMzItNS4yOTkgNS4yMDgtNS4yOTkgMS4zOTkgMCAyLjYxOC40MDcgMy41ODQgMS4yOTNsMi4zODEtMi4zOGMwLS4wMDItLjAwMy0uMDA0LS4wMDQtLjAwNS0xLjU4OC0xLjUyNC0zLjYyLTIuMjE1LTUuOTU1LTIuMjE1em00LjQzIDUuNjYuMDAzLjAwNnYtLjAwM3oiIGZpbGw9IiNmZmYiIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0ibTIxNS4xODQgMjUxLjkyOS03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVhNS4yMzMgNS4yMzMgMCAwIDAgLjQ0OS0yLjEyM3YtMzEuMTY1Yy0uNDY5LjY3NS0uOTM0IDEuMzQ5LTEuMzgyIDIuMDA1LS43OTIgMS4yNzUtMS42ODIgMi42NC0yLjQ2NSAzLjk5LTIuMzQ3IDQuMDY1LTMuOTgyIDguMDM4LTQuNTg1IDEzLjc5NC0uMTYyLjQ4NS0uNTI3Ljc5OC0uOTMuNzk5LS4zNjMtLjAwMS0uNjk3LS4yNTUtLjg3OS0uNjY3di0uMDEyYy0uNTkzLTUuODIyLTIuMjM3LTkuODItNC42LTEzLjkxNC0uNzgzLTEuMzUtMS42NzMtMi43MTUtMi40NjYtMy45OS0xLjEzNy0xLjY2Ni0yLjMyNy0zLjQtMy42MzctNS4xNjlsLS4wMDItLjAwM3oiIGZpbGw9IiNjM2MzYzMiLz48cGF0aCBkPSJtMjEyLjk4MyAyNDguNDk1LTM2Ljk1MiAzNi45NTN2LjgxMmE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOCA1LjIzOGgxLjAxNWwzNS42NjYtMzUuNjY2YTEzNi4yNzUgMTM2LjI3NSAwIDAgMC0yLjc2NC0zLjkgMzcuNTc1IDM3LjU3NSAwIDAgMC0uOTg5LTEuNDQgMzUuMTI3IDM1LjEyNyAwIDAgMC0uOTUtMS41MDhjLS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJtMjExLjk5OCAyNjEuMDgzLTYuMTUyIDYuMTUxIDI0LjI2NCAyNC4yNjRoLjc4MWE1LjIyNyA1LjIyNyAwIDAgMCA1LjIzOS01LjIzOHYtMS4wNDV6IiBmaWxsPSIjZmZmIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjwvZz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder{background:#4268b3}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAyNCIgaGVpZ2h0PSIxMDI0IiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPjxwYXRoIGQ9Ik05NjcuNDg0IDBINTYuNTE3QzI1LjMwNCAwIDAgMjUuMzA0IDAgNTYuNTE3djkxMC45NjZDMCA5OTguNjk0IDI1LjI5NyAxMDI0IDU2LjUyMiAxMDI0SDU0N1Y2MjhINDE0VjQ3M2gxMzNWMzU5LjAyOWMwLTEzMi4yNjIgODAuNzczLTIwNC4yODIgMTk4Ljc1Ni0yMDQuMjgyIDU2LjUxMyAwIDEwNS4wODYgNC4yMDggMTE5LjI0NCA2LjA4OVYyOTlsLTgxLjYxNi4wMzdjLTYzLjk5MyAwLTc2LjM4NCAzMC40OTItNzYuMzg0IDc1LjIzNlY0NzNoMTUzLjQ4N2wtMTkuOTg2IDE1NUg3MDd2Mzk2aDI2MC40ODRjMzEuMjEzIDAgNTYuNTE2LTI1LjMwMyA1Ni41MTYtNTYuNTE2VjU2LjUxNUMxMDI0IDI1LjMwMyA5OTguNjk3IDAgOTY3LjQ4NCAwIiBmaWxsPSIjRkZGRkZFIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#cdf}.ck-media__wrapper[data-oembed-url*="facebook.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder{background:linear-gradient(-135deg,#1400c7,#b800b1,#f50000)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTA0IiBoZWlnaHQ9IjUwNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGRlZnM+PHBhdGggaWQ9ImEiIGQ9Ik0wIC4xNTloNTAzLjg0MVY1MDMuOTRIMHoiLz48L2RlZnM+PGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj48bWFzayBpZD0iYiIgZmlsbD0iI2ZmZiI+PHVzZSB4bGluazpocmVmPSIjYSIvPjwvbWFzaz48cGF0aCBkPSJNMjUxLjkyMS4xNTljLTY4LjQxOCAwLTc2Ljk5Ny4yOS0xMDMuODY3IDEuNTE2LTI2LjgxNCAxLjIyMy00NS4xMjcgNS40ODItNjEuMTUxIDExLjcxLTE2LjU2NiA2LjQzNy0zMC42MTUgMTUuMDUxLTQ0LjYyMSAyOS4wNTYtMTQuMDA1IDE0LjAwNi0yMi42MTkgMjguMDU1LTI5LjA1NiA0NC42MjEtNi4yMjggMTYuMDI0LTEwLjQ4NyAzNC4zMzctMTEuNzEgNjEuMTUxQy4yOSAxNzUuMDgzIDAgMTgzLjY2MiAwIDI1Mi4wOGMwIDY4LjQxNy4yOSA3Ni45OTYgMS41MTYgMTAzLjg2NiAxLjIyMyAyNi44MTQgNS40ODIgNDUuMTI3IDExLjcxIDYxLjE1MSA2LjQzNyAxNi41NjYgMTUuMDUxIDMwLjYxNSAyOS4wNTYgNDQuNjIxIDE0LjAwNiAxNC4wMDUgMjguMDU1IDIyLjYxOSA0NC42MjEgMjkuMDU3IDE2LjAyNCA2LjIyNyAzNC4zMzcgMTAuNDg2IDYxLjE1MSAxMS43MDkgMjYuODcgMS4yMjYgMzUuNDQ5IDEuNTE2IDEwMy44NjcgMS41MTYgNjguNDE3IDAgNzYuOTk2LS4yOSAxMDMuODY2LTEuNTE2IDI2LjgxNC0xLjIyMyA0NS4xMjctNS40ODIgNjEuMTUxLTExLjcwOSAxNi41NjYtNi40MzggMzAuNjE1LTE1LjA1MiA0NC42MjEtMjkuMDU3IDE0LjAwNS0xNC4wMDYgMjIuNjE5LTI4LjA1NSAyOS4wNTctNDQuNjIxIDYuMjI3LTE2LjAyNCAxMC40ODYtMzQuMzM3IDExLjcwOS02MS4xNTEgMS4yMjYtMjYuODcgMS41MTYtMzUuNDQ5IDEuNTE2LTEwMy44NjYgMC02OC40MTgtLjI5LTc2Ljk5Ny0xLjUxNi0xMDMuODY3LTEuMjIzLTI2LjgxNC01LjQ4Mi00NS4xMjctMTEuNzA5LTYxLjE1MS02LjQzOC0xNi41NjYtMTUuMDUyLTMwLjYxNS0yOS4wNTctNDQuNjIxLTE0LjAwNi0xNC4wMDUtMjguMDU1LTIyLjYxOS00NC42MjEtMjkuMDU2LTE2LjAyNC02LjIyOC0zNC4zMzctMTAuNDg3LTYxLjE1MS0xMS43MUMzMjguOTE3LjQ0OSAzMjAuMzM4LjE1OSAyNTEuOTIxLjE1OVptMCA0NS4zOTFjNjcuMjY1IDAgNzUuMjMzLjI1NyAxMDEuNzk3IDEuNDY5IDI0LjU2MiAxLjEyIDM3LjkwMSA1LjIyNCA0Ni43NzggOC42NzQgMTEuNzU5IDQuNTcgMjAuMTUxIDEwLjAyOSAyOC45NjYgMTguODQ1IDguODE2IDguODE1IDE0LjI3NSAxNy4yMDcgMTguODQ1IDI4Ljk2NiAzLjQ1IDguODc3IDcuNTU0IDIyLjIxNiA4LjY3NCA0Ni43NzggMS4yMTIgMjYuNTY0IDEuNDY5IDM0LjUzMiAxLjQ2OSAxMDEuNzk4IDAgNjcuMjY1LS4yNTcgNzUuMjMzLTEuNDY5IDEwMS43OTctMS4xMiAyNC41NjItNS4yMjQgMzcuOTAxLTguNjc0IDQ2Ljc3OC00LjU3IDExLjc1OS0xMC4wMjkgMjAuMTUxLTE4Ljg0NSAyOC45NjYtOC44MTUgOC44MTYtMTcuMjA3IDE0LjI3NS0yOC45NjYgMTguODQ1LTguODc3IDMuNDUtMjIuMjE2IDcuNTU0LTQ2Ljc3OCA4LjY3NC0yNi41NiAxLjIxMi0zNC41MjcgMS40NjktMTAxLjc5NyAxLjQ2OS02Ny4yNzEgMC03NS4yMzctLjI1Ny0xMDEuNzk4LTEuNDY5LTI0LjU2Mi0xLjEyLTM3LjkwMS01LjIyNC00Ni43NzgtOC42NzQtMTEuNzU5LTQuNTctMjAuMTUxLTEwLjAyOS0yOC45NjYtMTguODQ1LTguODE1LTguODE1LTE0LjI3NS0xNy4yMDctMTguODQ1LTI4Ljk2Ni0zLjQ1LTguODc3LTcuNTU0LTIyLjIxNi04LjY3NC00Ni43NzgtMS4yMTItMjYuNTY0LTEuNDY5LTM0LjUzMi0xLjQ2OS0xMDEuNzk3IDAtNjcuMjY2LjI1Ny03NS4yMzQgMS40NjktMTAxLjc5OCAxLjEyLTI0LjU2MiA1LjIyNC0zNy45MDEgOC42NzQtNDYuNzc4IDQuNTctMTEuNzU5IDEwLjAyOS0yMC4xNTEgMTguODQ1LTI4Ljk2NiA4LjgxNS04LjgxNiAxNy4yMDctMTQuMjc1IDI4Ljk2Ni0xOC44NDUgOC44NzctMy40NSAyMi4yMTYtNy41NTQgNDYuNzc4LTguNjc0IDI2LjU2NC0xLjIxMiAzNC41MzItMS40NjkgMTAxLjc5OC0xLjQ2OVoiIGZpbGw9IiNGRkYiIG1hc2s9InVybCgjYikiLz48cGF0aCBkPSJNMjUxLjkyMSAzMzYuMDUzYy00Ni4zNzggMC04My45NzQtMzcuNTk2LTgzLjk3NC04My45NzMgMC00Ni4zNzggMzcuNTk2LTgzLjk3NCA4My45NzQtODMuOTc0IDQ2LjM3NyAwIDgzLjk3MyAzNy41OTYgODMuOTczIDgzLjk3NCAwIDQ2LjM3Ny0zNy41OTYgODMuOTczLTgzLjk3MyA4My45NzNabTAtMjEzLjMzOGMtNzEuNDQ3IDAtMTI5LjM2NSA1Ny45MTgtMTI5LjM2NSAxMjkuMzY1IDAgNzEuNDQ2IDU3LjkxOCAxMjkuMzY0IDEyOS4zNjUgMTI5LjM2NCA3MS40NDYgMCAxMjkuMzY0LTU3LjkxOCAxMjkuMzY0LTEyOS4zNjQgMC03MS40NDctNTcuOTE4LTEyOS4zNjUtMTI5LjM2NC0xMjkuMzY1Wk00MTYuNjI3IDExNy42MDRjMCAxNi42OTYtMTMuNTM1IDMwLjIzLTMwLjIzMSAzMC4yMy0xNi42OTUgMC0zMC4yMy0xMy41MzQtMzAuMjMtMzAuMjMgMC0xNi42OTYgMTMuNTM1LTMwLjIzMSAzMC4yMy0zMC4yMzEgMTYuNjk2IDAgMzAuMjMxIDEzLjUzNSAzMC4yMzEgMzAuMjMxIiBmaWxsPSIjRkZGIi8+PC9nPjwvc3ZnPg==)}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text{color:#ffe0fe}.ck-media__wrapper[data-oembed-url*="instagram.com"] .ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder{background:linear-gradient(90deg,#71c6f4,#0d70a5)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__icon{background-image:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0MDAgNDAwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0MDAgNDAwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNNDAwIDIwMGMwIDExMC41LTg5LjUgMjAwLTIwMCAyMDBTMCAzMTAuNSAwIDIwMCA4OS41IDAgMjAwIDBzMjAwIDg5LjUgMjAwIDIwMHpNMTYzLjQgMzA1LjVjODguNyAwIDEzNy4yLTczLjUgMTM3LjItMTM3LjIgMC0yLjEgMC00LjItLjEtNi4yIDkuNC02LjggMTcuNi0xNS4zIDI0LjEtMjUtOC42IDMuOC0xNy45IDYuNC0yNy43IDcuNiAxMC02IDE3LjYtMTUuNCAyMS4yLTI2LjctOS4zIDUuNS0xOS42IDkuNS0zMC42IDExLjctOC44LTkuNC0yMS4zLTE1LjItMzUuMi0xNS4yLTI2LjYgMC00OC4yIDIxLjYtNDguMiA0OC4yIDAgMy44LjQgNy41IDEuMyAxMS00MC4xLTItNzUuNi0yMS4yLTk5LjQtNTAuNC00LjEgNy4xLTYuNSAxNS40LTYuNSAyNC4yIDAgMTYuNyA4LjUgMzEuNSAyMS41IDQwLjEtNy45LS4yLTE1LjMtMi40LTIxLjgtNnYuNmMwIDIzLjQgMTYuNiA0Mi44IDM4LjcgNDcuMy00IDEuMS04LjMgMS43LTEyLjcgMS43LTMuMSAwLTYuMS0uMy05LjEtLjkgNi4xIDE5LjIgMjMuOSAzMy4xIDQ1IDMzLjUtMTYuNSAxMi45LTM3LjMgMjAuNi01OS45IDIwLjYtMy45IDAtNy43LS4yLTExLjUtLjcgMjEuMSAxMy44IDQ2LjUgMjEuOCA3My43IDIxLjgiIHN0eWxlPSJmaWxsOiNmZmYiLz48L3N2Zz4=)}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text{color:#b8e6ff}.ck-media__wrapper[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder .ck-media__placeholder__url__text:hover{color:#fff}', "", { version: 3, sources: ["webpack://./../ckeditor5-media-embed/theme/mediaembedediting.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-media-embed/mediaembedediting.css"], names: [], mappings: "AAMC,0CAGC,kBAAmB,CAFnB,YAAa,CACb,qBAcD,CAXC,sEAEC,cAAe,CAEf,iBAMD,CAJC,wGAEC,aAAc,CADd,eAED,CAWD,6kBACC,YACD,CAYF,2LACC,mBACD,CC1CA,MACC,0CAA2C,CAE3C,mDAA4D,CAC5D,2EACD,CAEA,mBACC,aA+FD,CA7FC,0CAEC,0CAA2C,CAD3C,0CA6BD,CA1BC,uEAIC,uBAA2B,CAC3B,qBAAsB,CAHtB,kDAAmD,CACnD,qCAAsC,CAFtC,qDAUD,CAJC,gFAEC,WAAY,CADZ,UAED,CAGD,4EACC,sDAAuD,CAGvD,iBAAkB,CADlB,iBAAkB,CAElB,sBAAuB,CAHvB,kBAUD,CALC,kFACC,4DAA6D,CAC7D,cAAe,CACf,yBACD,CAIF,wDAEC,gBAAiB,CADjB,eAED,CAEA,4UAIC,wvGACD,CAEA,2EACC,kBAaD,CAXC,wGACC,orBACD,CAEA,6GACC,UAKD,CAHC,mHACC,UACD,CAIF,4EACC,2DAcD,CAZC,yGACC,4jHACD,CAGA,8GACC,aAKD,CAHC,oHACC,UACD,CAIF,6EAEC,iDAaD,CAXC,0GACC,wiCACD,CAEA,+GACC,aAKD,CAHC,qHACC,UACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck-media__wrapper {\n	& .ck-media__placeholder {\n		display: flex;\n		flex-direction: column;\n		align-items: center;\n\n		& .ck-media__placeholder__url {\n			/* Otherwise the URL will overflow when the content is very narrow. */\n			max-width: 100%;\n\n			position: relative;\n\n			& .ck-media__placeholder__url__text {\n				overflow: hidden;\n				display: block;\n			}\n		}\n	}\n\n	&[data-oembed-url*="twitter.com"],\n	&[data-oembed-url*="google.com/maps"],\n	&[data-oembed-url*="goo.gl/maps"],\n	&[data-oembed-url*="maps.google.com"],\n	&[data-oembed-url*="maps.app.goo.gl"],\n	&[data-oembed-url*="facebook.com"],\n	&[data-oembed-url*="instagram.com"] {\n		& .ck-media__placeholder__icon * {\n			display: none;\n		}\n	}\n}\n\n/* Disable all mouse interaction as long as the editor is not read–only.\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/58 */\n.ck-editor__editable:not(.ck-read-only) .ck-media__wrapper > *:not(.ck-media__placeholder) {\n	pointer-events: none;\n}\n\n/* Disable all mouse interaction when the widget is not selected (e.g. to avoid opening links by accident).\n   https://github.com/ckeditor/ckeditor5-media-embed/issues/18 */\n.ck-editor__editable:not(.ck-read-only) .ck-widget:not(.ck-widget_selected) .ck-media__placeholder {\n	pointer-events: none;\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-media-embed-placeholder-icon-size: 3em;\n\n	--ck-color-media-embed-placeholder-url-text: hsl(0, 0%, 46%);\n	--ck-color-media-embed-placeholder-url-text-hover: var(--ck-color-base-text);\n}\n\n.ck-media__wrapper {\n	margin: 0 auto;\n\n	& .ck-media__placeholder {\n		padding: calc( 3 * var(--ck-spacing-standard) );\n		background: var(--ck-color-base-foreground);\n\n		& .ck-media__placeholder__icon {\n			min-width: var(--ck-media-embed-placeholder-icon-size);\n			height: var(--ck-media-embed-placeholder-icon-size);\n			margin-bottom: var(--ck-spacing-large);\n			background-position: center;\n			background-size: cover;\n\n			& .ck-icon {\n				width: 100%;\n				height: 100%;\n			}\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: var(--ck-color-media-embed-placeholder-url-text);\n			white-space: nowrap;\n			text-align: center;\n			font-style: italic;\n			text-overflow: ellipsis;\n\n			&:hover {\n				color: var(--ck-color-media-embed-placeholder-url-text-hover);\n				cursor: pointer;\n				text-decoration: underline;\n			}\n		}\n	}\n\n	&[data-oembed-url*="open.spotify.com"] {\n		max-width: 300px;\n		max-height: 380px;\n	}\n\n	&[data-oembed-url*="google.com/maps"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="goo.gl/maps"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="maps.google.com"] .ck-media__placeholder__icon,\n	&[data-oembed-url*="maps.app.goo.gl"] .ck-media__placeholder__icon {\n		background-image: url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNTAuMzc4IiBoZWlnaHQ9IjI1NC4xNjciIHZpZXdCb3g9IjAgMCA2Ni4yNDYgNjcuMjQ4Ij48ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTcyLjUzMSAtMjE4LjQ1NSkgc2NhbGUoLjk4MDEyKSI+PHJlY3Qgcnk9IjUuMjM4IiByeD0iNS4yMzgiIHk9IjIzMS4zOTkiIHg9IjE3Ni4wMzEiIGhlaWdodD0iNjAuMDk5IiB3aWR0aD0iNjAuMDk5IiBmaWxsPSIjMzRhNjY4IiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxwYXRoIGQ9Ik0yMDYuNDc3IDI2MC45bC0yOC45ODcgMjguOTg3YTUuMjE4IDUuMjE4IDAgMCAwIDMuNzggMS42MWg0OS42MjFjMS42OTQgMCAzLjE5LS43OTggNC4xNDYtMi4wMzd6IiBmaWxsPSIjNWM4OGM1Ii8+PHBhdGggZD0iTTIyNi43NDIgMjIyLjk4OGMtOS4yNjYgMC0xNi43NzcgNy4xNy0xNi43NzcgMTYuMDE0LjAwNyAyLjc2Mi42NjMgNS40NzQgMi4wOTMgNy44NzUuNDMuNzAzLjgzIDEuNDA4IDEuMTkgMi4xMDcuMzMzLjUwMi42NSAxLjAwNS45NSAxLjUwOC4zNDMuNDc3LjY3My45NTcuOTg4IDEuNDQgMS4zMSAxLjc2OSAyLjUgMy41MDIgMy42MzcgNS4xNjguNzkzIDEuMjc1IDEuNjgzIDIuNjQgMi40NjYgMy45OSAyLjM2MyA0LjA5NCA0LjAwNyA4LjA5MiA0LjYgMTMuOTE0di4wMTJjLjE4Mi40MTIuNTE2LjY2Ni44NzkuNjY3LjQwMy0uMDAxLjc2OC0uMzE0LjkzLS43OTkuNjAzLTUuNzU2IDIuMjM4LTkuNzI5IDQuNTg1LTEzLjc5NC43ODItMS4zNSAxLjY3My0yLjcxNSAyLjQ2NS0zLjk5IDEuMTM3LTEuNjY2IDIuMzI4LTMuNCAzLjYzOC01LjE2OS4zMTUtLjQ4Mi42NDUtLjk2Mi45ODgtMS40MzkuMy0uNTAzLjYxNy0xLjAwNi45NS0xLjUwOC4zNTktLjcuNzYtMS40MDQgMS4xOS0yLjEwNyAxLjQyNi0yLjQwMiAyLTUuMTE0IDIuMDA0LTcuODc1IDAtOC44NDQtNy41MTEtMTYuMDE0LTE2Ljc3Ni0xNi4wMTR6IiBmaWxsPSIjZGQ0YjNlIiBwYWludC1vcmRlcj0ibWFya2VycyBzdHJva2UgZmlsbCIvPjxlbGxpcHNlIHJ5PSI1LjU2NCIgcng9IjUuODI4IiBjeT0iMjM5LjAwMiIgY3g9IjIyNi43NDIiIGZpbGw9IiM4MDJkMjciIHBhaW50LW9yZGVyPSJtYXJrZXJzIHN0cm9rZSBmaWxsIi8+PHBhdGggZD0iTTE5MC4zMDEgMjM3LjI4M2MtNC42NyAwLTguNDU3IDMuODUzLTguNDU3IDguNjA2czMuNzg2IDguNjA3IDguNDU3IDguNjA3YzMuMDQzIDAgNC44MDYtLjk1OCA2LjMzNy0yLjUxNiAxLjUzLTEuNTU3IDIuMDg3LTMuOTEzIDIuMDg3LTYuMjkgMC0uMzYyLS4wMjMtLjcyMi0uMDY0LTEuMDc5aC04LjI1N3YzLjA0M2g0Ljg1Yy0uMTk3Ljc1OS0uNTMxIDEuNDUtMS4wNTggMS45ODYtLjk0Mi45NTgtMi4wMjggMS41NDgtMy45MDEgMS41NDgtMi44NzYgMC01LjIwOC0yLjM3Mi01LjIwOC01LjI5OSAwLTIuOTI2IDIuMzMyLTUuMjk5IDUuMjA4LTUuMjk5IDEuMzk5IDAgMi42MTguNDA3IDMuNTg0IDEuMjkzbDIuMzgxLTIuMzhjMC0uMDAyLS4wMDMtLjAwNC0uMDA0LS4wMDUtMS41ODgtMS41MjQtMy42Mi0yLjIxNS01Ljk1NS0yLjIxNXptNC40MyA1LjY2bC4wMDMuMDA2di0uMDAzeiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjE1LjE4NCAyNTEuOTI5bC03Ljk4IDcuOTc5IDI4LjQ3NyAyOC40NzVjLjI4Ny0uNjQ5LjQ0OS0xLjM2Ni40NDktMi4xMjN2LTMxLjE2NWMtLjQ2OS42NzUtLjkzNCAxLjM0OS0xLjM4MiAyLjAwNS0uNzkyIDEuMjc1LTEuNjgyIDIuNjQtMi40NjUgMy45OS0yLjM0NyA0LjA2NS0zLjk4MiA4LjAzOC00LjU4NSAxMy43OTQtLjE2Mi40ODUtLjUyNy43OTgtLjkzLjc5OS0uMzYzLS4wMDEtLjY5Ny0uMjU1LS44NzktLjY2N3YtLjAxMmMtLjU5My01LjgyMi0yLjIzNy05LjgyLTQuNi0xMy45MTQtLjc4My0xLjM1LTEuNjczLTIuNzE1LTIuNDY2LTMuOTktMS4xMzctMS42NjYtMi4zMjctMy40LTMuNjM3LTUuMTY5bC0uMDAyLS4wMDN6IiBmaWxsPSIjYzNjM2MzIi8+PHBhdGggZD0iTTIxMi45ODMgMjQ4LjQ5NWwtMzYuOTUyIDM2Ljk1M3YuODEyYTUuMjI3IDUuMjI3IDAgMCAwIDUuMjM4IDUuMjM4aDEuMDE1bDM1LjY2Ni0zNS42NjZhMTM2LjI3NSAxMzYuMjc1IDAgMCAwLTIuNzY0LTMuOSAzNy41NzUgMzcuNTc1IDAgMCAwLS45ODktMS40NGMtLjI5OS0uNTAzLS42MTYtMS4wMDYtLjk1LTEuNTA4LS4wODMtLjE2Mi0uMTc2LS4zMjYtLjI2NC0uNDg5eiIgZmlsbD0iI2ZkZGM0ZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48cGF0aCBkPSJNMjExLjk5OCAyNjEuMDgzbC02LjE1MiA2LjE1MSAyNC4yNjQgMjQuMjY0aC43ODFhNS4yMjcgNS4yMjcgMCAwIDAgNS4yMzktNS4yMzh2LTEuMDQ1eiIgZmlsbD0iI2ZmZiIgcGFpbnQtb3JkZXI9Im1hcmtlcnMgc3Ryb2tlIGZpbGwiLz48L2c+PC9zdmc+);\n	}\n\n	&[data-oembed-url*="facebook.com"] .ck-media__placeholder {\n		background: hsl(220, 46%, 48%);\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSIxMDI0cHgiIGhlaWdodD0iMTAyNHB4IiB2aWV3Qm94PSIwIDAgMTAyNCAxMDI0IiB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPiAgICAgICAgPHRpdGxlPkZpbGwgMTwvdGl0bGU+ICAgIDxkZXNjPkNyZWF0ZWQgd2l0aCBTa2V0Y2guPC9kZXNjPiAgICA8ZGVmcz48L2RlZnM+ICAgIDxnIGlkPSJQYWdlLTEiIHN0cm9rZT0ibm9uZSIgc3Ryb2tlLXdpZHRoPSIxIiBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPiAgICAgICAgPGcgaWQ9ImZMb2dvX1doaXRlIiBmaWxsPSIjRkZGRkZFIj4gICAgICAgICAgICA8cGF0aCBkPSJNOTY3LjQ4NCwwIEw1Ni41MTcsMCBDMjUuMzA0LDAgMCwyNS4zMDQgMCw1Ni41MTcgTDAsOTY3LjQ4MyBDMCw5OTguNjk0IDI1LjI5NywxMDI0IDU2LjUyMiwxMDI0IEw1NDcsMTAyNCBMNTQ3LDYyOCBMNDE0LDYyOCBMNDE0LDQ3MyBMNTQ3LDQ3MyBMNTQ3LDM1OS4wMjkgQzU0NywyMjYuNzY3IDYyNy43NzMsMTU0Ljc0NyA3NDUuNzU2LDE1NC43NDcgQzgwMi4yNjksMTU0Ljc0NyA4NTAuODQyLDE1OC45NTUgODY1LDE2MC44MzYgTDg2NSwyOTkgTDc4My4zODQsMjk5LjAzNyBDNzE5LjM5MSwyOTkuMDM3IDcwNywzMjkuNTI5IDcwNywzNzQuMjczIEw3MDcsNDczIEw4NjAuNDg3LDQ3MyBMODQwLjUwMSw2MjggTDcwNyw2MjggTDcwNywxMDI0IEw5NjcuNDg0LDEwMjQgQzk5OC42OTcsMTAyNCAxMDI0LDk5OC42OTcgMTAyNCw5NjcuNDg0IEwxMDI0LDU2LjUxNSBDMTAyNCwyNS4zMDMgOTk4LjY5NywwIDk2Ny40ODQsMCIgaWQ9IkZpbGwtMSI+PC9wYXRoPiAgICAgICAgPC9nPiAgICA8L2c+PC9zdmc+);\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: hsl(220, 100%, 90%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n\n	&[data-oembed-url*="instagram.com"] .ck-media__placeholder {\n		background: linear-gradient(-135deg,hsl(246, 100%, 39%),hsl(302, 100%, 36%),hsl(0, 100%, 48%));\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48c3ZnIHdpZHRoPSI1MDRweCIgaGVpZ2h0PSI1MDRweCIgdmlld0JveD0iMCAwIDUwNCA1MDQiIHZlcnNpb249IjEuMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+ICAgICAgICA8dGl0bGU+Z2x5cGgtbG9nb19NYXkyMDE2PC90aXRsZT4gICAgPGRlc2M+Q3JlYXRlZCB3aXRoIFNrZXRjaC48L2Rlc2M+ICAgIDxkZWZzPiAgICAgICAgPHBvbHlnb24gaWQ9InBhdGgtMSIgcG9pbnRzPSIwIDAuMTU5IDUwMy44NDEgMC4xNTkgNTAzLjg0MSA1MDMuOTQgMCA1MDMuOTQiPjwvcG9seWdvbj4gICAgPC9kZWZzPiAgICA8ZyBpZD0iZ2x5cGgtbG9nb19NYXkyMDE2IiBzdHJva2U9Im5vbmUiIHN0cm9rZS13aWR0aD0iMSIgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4gICAgICAgIDxnIGlkPSJHcm91cC0zIj4gICAgICAgICAgICA8bWFzayBpZD0ibWFzay0yIiBmaWxsPSJ3aGl0ZSI+ICAgICAgICAgICAgICAgIDx1c2UgeGxpbms6aHJlZj0iI3BhdGgtMSI+PC91c2U+ICAgICAgICAgICAgPC9tYXNrPiAgICAgICAgICAgIDxnIGlkPSJDbGlwLTIiPjwvZz4gICAgICAgICAgICA8cGF0aCBkPSJNMjUxLjkyMSwwLjE1OSBDMTgzLjUwMywwLjE1OSAxNzQuOTI0LDAuNDQ5IDE0OC4wNTQsMS42NzUgQzEyMS4yNCwyLjg5OCAxMDIuOTI3LDcuMTU3IDg2LjkwMywxMy4zODUgQzcwLjMzNywxOS44MjIgNTYuMjg4LDI4LjQzNiA0Mi4yODIsNDIuNDQxIEMyOC4yNzcsNTYuNDQ3IDE5LjY2Myw3MC40OTYgMTMuMjI2LDg3LjA2MiBDNi45OTgsMTAzLjA4NiAyLjczOSwxMjEuMzk5IDEuNTE2LDE0OC4yMTMgQzAuMjksMTc1LjA4MyAwLDE4My42NjIgMCwyNTIuMDggQzAsMzIwLjQ5NyAwLjI5LDMyOS4wNzYgMS41MTYsMzU1Ljk0NiBDMi43MzksMzgyLjc2IDYuOTk4LDQwMS4wNzMgMTMuMjI2LDQxNy4wOTcgQzE5LjY2Myw0MzMuNjYzIDI4LjI3Nyw0NDcuNzEyIDQyLjI4Miw0NjEuNzE4IEM1Ni4yODgsNDc1LjcyMyA3MC4zMzcsNDg0LjMzNyA4Ni45MDMsNDkwLjc3NSBDMTAyLjkyNyw0OTcuMDAyIDEyMS4yNCw1MDEuMjYxIDE0OC4wNTQsNTAyLjQ4NCBDMTc0LjkyNCw1MDMuNzEgMTgzLjUwMyw1MDQgMjUxLjkyMSw1MDQgQzMyMC4zMzgsNTA0IDMyOC45MTcsNTAzLjcxIDM1NS43ODcsNTAyLjQ4NCBDMzgyLjYwMSw1MDEuMjYxIDQwMC45MTQsNDk3LjAwMiA0MTYuOTM4LDQ5MC43NzUgQzQzMy41MDQsNDg0LjMzNyA0NDcuNTUzLDQ3NS43MjMgNDYxLjU1OSw0NjEuNzE4IEM0NzUuNTY0LDQ0Ny43MTIgNDg0LjE3OCw0MzMuNjYzIDQ5MC42MTYsNDE3LjA5NyBDNDk2Ljg0Myw0MDEuMDczIDUwMS4xMDIsMzgyLjc2IDUwMi4zMjUsMzU1Ljk0NiBDNTAzLjU1MSwzMjkuMDc2IDUwMy44NDEsMzIwLjQ5NyA1MDMuODQxLDI1Mi4wOCBDNTAzLjg0MSwxODMuNjYyIDUwMy41NTEsMTc1LjA4MyA1MDIuMzI1LDE0OC4yMTMgQzUwMS4xMDIsMTIxLjM5OSA0OTYuODQzLDEwMy4wODYgNDkwLjYxNiw4Ny4wNjIgQzQ4NC4xNzgsNzAuNDk2IDQ3NS41NjQsNTYuNDQ3IDQ2MS41NTksNDIuNDQxIEM0NDcuNTUzLDI4LjQzNiA0MzMuNTA0LDE5LjgyMiA0MTYuOTM4LDEzLjM4NSBDNDAwLjkxNCw3LjE1NyAzODIuNjAxLDIuODk4IDM1NS43ODcsMS42NzUgQzMyOC45MTcsMC40NDkgMzIwLjMzOCwwLjE1OSAyNTEuOTIxLDAuMTU5IFogTTI1MS45MjEsNDUuNTUgQzMxOS4xODYsNDUuNTUgMzI3LjE1NCw0NS44MDcgMzUzLjcxOCw0Ny4wMTkgQzM3OC4yOCw0OC4xMzkgMzkxLjYxOSw1Mi4yNDMgNDAwLjQ5Niw1NS42OTMgQzQxMi4yNTUsNjAuMjYzIDQyMC42NDcsNjUuNzIyIDQyOS40NjIsNzQuNTM4IEM0MzguMjc4LDgzLjM1MyA0NDMuNzM3LDkxLjc0NSA0NDguMzA3LDEwMy41MDQgQzQ1MS43NTcsMTEyLjM4MSA0NTUuODYxLDEyNS43MiA0NTYuOTgxLDE1MC4yODIgQzQ1OC4xOTMsMTc2Ljg0NiA0NTguNDUsMTg0LjgxNCA0NTguNDUsMjUyLjA4IEM0NTguNDUsMzE5LjM0NSA0NTguMTkzLDMyNy4zMTMgNDU2Ljk4MSwzNTMuODc3IEM0NTUuODYxLDM3OC40MzkgNDUxLjc1NywzOTEuNzc4IDQ0OC4zMDcsNDAwLjY1NSBDNDQzLjczNyw0MTIuNDE0IDQzOC4yNzgsNDIwLjgwNiA0MjkuNDYyLDQyOS42MjEgQzQyMC42NDcsNDM4LjQzNyA0MTIuMjU1LDQ0My44OTYgNDAwLjQ5Niw0NDguNDY2IEMzOTEuNjE5LDQ1MS45MTYgMzc4LjI4LDQ1Ni4wMiAzNTMuNzE4LDQ1Ny4xNCBDMzI3LjE1OCw0NTguMzUyIDMxOS4xOTEsNDU4LjYwOSAyNTEuOTIxLDQ1OC42MDkgQzE4NC42NSw0NTguNjA5IDE3Ni42ODQsNDU4LjM1MiAxNTAuMTIzLDQ1Ny4xNCBDMTI1LjU2MSw0NTYuMDIgMTEyLjIyMiw0NTEuOTE2IDEwMy4zNDUsNDQ4LjQ2NiBDOTEuNTg2LDQ0My44OTYgODMuMTk0LDQzOC40MzcgNzQuMzc5LDQyOS42MjEgQzY1LjU2NCw0MjAuODA2IDYwLjEwNCw0MTIuNDE0IDU1LjUzNCw0MDAuNjU1IEM1Mi4wODQsMzkxLjc3OCA0Ny45OCwzNzguNDM5IDQ2Ljg2LDM1My44NzcgQzQ1LjY0OCwzMjcuMzEzIDQ1LjM5MSwzMTkuMzQ1IDQ1LjM5MSwyNTIuMDggQzQ1LjM5MSwxODQuODE0IDQ1LjY0OCwxNzYuODQ2IDQ2Ljg2LDE1MC4yODIgQzQ3Ljk4LDEyNS43MiA1Mi4wODQsMTEyLjM4MSA1NS41MzQsMTAzLjUwNCBDNjAuMTA0LDkxLjc0NSA2NS41NjMsODMuMzUzIDc0LjM3OSw3NC41MzggQzgzLjE5NCw2NS43MjIgOTEuNTg2LDYwLjI2MyAxMDMuMzQ1LDU1LjY5MyBDMTEyLjIyMiw1Mi4yNDMgMTI1LjU2MSw0OC4xMzkgMTUwLjEyMyw0Ny4wMTkgQzE3Ni42ODcsNDUuODA3IDE4NC42NTUsNDUuNTUgMjUxLjkyMSw0NS41NSBaIiBpZD0iRmlsbC0xIiBmaWxsPSIjRkZGRkZGIiBtYXNrPSJ1cmwoI21hc2stMikiPjwvcGF0aD4gICAgICAgIDwvZz4gICAgICAgIDxwYXRoIGQ9Ik0yNTEuOTIxLDMzNi4wNTMgQzIwNS41NDMsMzM2LjA1MyAxNjcuOTQ3LDI5OC40NTcgMTY3Ljk0NywyNTIuMDggQzE2Ny45NDcsMjA1LjcwMiAyMDUuNTQzLDE2OC4xMDYgMjUxLjkyMSwxNjguMTA2IEMyOTguMjk4LDE2OC4xMDYgMzM1Ljg5NCwyMDUuNzAyIDMzNS44OTQsMjUyLjA4IEMzMzUuODk0LDI5OC40NTcgMjk4LjI5OCwzMzYuMDUzIDI1MS45MjEsMzM2LjA1MyBaIE0yNTEuOTIxLDEyMi43MTUgQzE4MC40NzQsMTIyLjcxNSAxMjIuNTU2LDE4MC42MzMgMTIyLjU1NiwyNTIuMDggQzEyMi41NTYsMzIzLjUyNiAxODAuNDc0LDM4MS40NDQgMjUxLjkyMSwzODEuNDQ0IEMzMjMuMzY3LDM4MS40NDQgMzgxLjI4NSwzMjMuNTI2IDM4MS4yODUsMjUyLjA4IEMzODEuMjg1LDE4MC42MzMgMzIzLjM2NywxMjIuNzE1IDI1MS45MjEsMTIyLjcxNSBaIiBpZD0iRmlsbC00IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgICAgICA8cGF0aCBkPSJNNDE2LjYyNywxMTcuNjA0IEM0MTYuNjI3LDEzNC4zIDQwMy4wOTIsMTQ3LjgzNCAzODYuMzk2LDE0Ny44MzQgQzM2OS43MDEsMTQ3LjgzNCAzNTYuMTY2LDEzNC4zIDM1Ni4xNjYsMTE3LjYwNCBDMzU2LjE2NiwxMDAuOTA4IDM2OS43MDEsODcuMzczIDM4Ni4zOTYsODcuMzczIEM0MDMuMDkyLDg3LjM3MyA0MTYuNjI3LDEwMC45MDggNDE2LjYyNywxMTcuNjA0IiBpZD0iRmlsbC01IiBmaWxsPSIjRkZGRkZGIj48L3BhdGg+ICAgIDwvZz48L3N2Zz4=);\n		}\n\n		/* stylelint-disable-next-line no-descending-specificity */\n		& .ck-media__placeholder__url__text {\n			color: hsl(302, 100%, 94%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n\n	&[data-oembed-url*="twitter.com"] .ck.ck-media__placeholder {\n		/* Use gradient to contrast with focused widget (ckeditor/ckeditor5-media-embed#22). */\n		background: linear-gradient( to right, hsl(201, 85%, 70%), hsl(201, 85%, 35%) );\n\n		& .ck-media__placeholder__icon {\n			background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48c3ZnIHZlcnNpb249IjEuMSIgaWQ9IldoaXRlIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCIgdmlld0JveD0iMCAwIDQwMCA0MDAiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDQwMCA0MDA7IiB4bWw6c3BhY2U9InByZXNlcnZlIj48c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7ZmlsbDojRkZGRkZGO308L3N0eWxlPjxwYXRoIGNsYXNzPSJzdDAiIGQ9Ik00MDAsMjAwYzAsMTEwLjUtODkuNSwyMDAtMjAwLDIwMFMwLDMxMC41LDAsMjAwUzg5LjUsMCwyMDAsMFM0MDAsODkuNSw0MDAsMjAweiBNMTYzLjQsMzA1LjVjODguNywwLDEzNy4yLTczLjUsMTM3LjItMTM3LjJjMC0yLjEsMC00LjItMC4xLTYuMmM5LjQtNi44LDE3LjYtMTUuMywyNC4xLTI1Yy04LjYsMy44LTE3LjksNi40LTI3LjcsNy42YzEwLTYsMTcuNi0xNS40LDIxLjItMjYuN2MtOS4zLDUuNS0xOS42LDkuNS0zMC42LDExLjdjLTguOC05LjQtMjEuMy0xNS4yLTM1LjItMTUuMmMtMjYuNiwwLTQ4LjIsMjEuNi00OC4yLDQ4LjJjMCwzLjgsMC40LDcuNSwxLjMsMTFjLTQwLjEtMi03NS42LTIxLjItOTkuNC01MC40Yy00LjEsNy4xLTYuNSwxNS40LTYuNSwyNC4yYzAsMTYuNyw4LjUsMzEuNSwyMS41LDQwLjFjLTcuOS0wLjItMTUuMy0yLjQtMjEuOC02YzAsMC4yLDAsMC40LDAsMC42YzAsMjMuNCwxNi42LDQyLjgsMzguNyw0Ny4zYy00LDEuMS04LjMsMS43LTEyLjcsMS43Yy0zLjEsMC02LjEtMC4zLTkuMS0wLjljNi4xLDE5LjIsMjMuOSwzMy4xLDQ1LDMzLjVjLTE2LjUsMTIuOS0zNy4zLDIwLjYtNTkuOSwyMC42Yy0zLjksMC03LjctMC4yLTExLjUtMC43QzExMC44LDI5Ny41LDEzNi4yLDMwNS41LDE2My40LDMwNS41Ii8+PC9zdmc+);\n		}\n\n		& .ck-media__placeholder__url__text {\n			color: hsl(201, 100%, 86%);\n\n			&:hover {\n				color: hsl(0, 0%, 100%);\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 9292: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-media-form{align-items:flex-start;display:flex;flex-direction:row;flex-wrap:nowrap}.ck.ck-media-form .ck-labeled-field-view{display:inline-block}.ck.ck-media-form .ck-label{display:none}@media screen and (max-width:600px){.ck.ck-media-form{flex-wrap:wrap}.ck.ck-media-form .ck-labeled-field-view{flex-basis:100%}.ck.ck-media-form .ck-button{flex-basis:50%}}", "", { version: 3, sources: ["webpack://./../ckeditor5-media-embed/theme/mediaform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css"], names: [], mappings: "AAOA,kBAEC,sBAAuB,CADvB,YAAa,CAEb,kBAAmB,CACnB,gBAqBD,CAnBC,yCACC,oBACD,CAEA,4BACC,YACD,CCbA,oCDCD,kBAeE,cAUF,CARE,yCACC,eACD,CAEA,6BACC,cACD,CCtBD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck.ck-media-form {\n	display: flex;\n	align-items: flex-start;\n	flex-direction: row;\n	flex-wrap: nowrap;\n\n	& .ck-labeled-field-view {\n		display: inline-block;\n	}\n\n	& .ck-label {\n		display: none;\n	}\n\n	@mixin ck-media-phone {\n		flex-wrap: wrap;\n\n		& .ck-labeled-field-view {\n			flex-basis: 100%;\n		}\n\n		& .ck-button {\n			flex-basis: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 7368: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-input-color{display:flex;flex-direction:row-reverse;width:100%}.ck.ck-input-color>input.ck.ck-input-text{flex-grow:1;min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown{min-width:auto}.ck.ck-input-color>div.ck.ck-dropdown>.ck-input-color__button .ck-dropdown__arrow{display:none}.ck.ck-input-color .ck.ck-input-color__button{display:flex}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview{overflow:hidden;position:relative}.ck.ck-input-color .ck.ck-input-color__button .ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{display:block;position:absolute}[dir=ltr] .ck.ck-input-color>.ck.ck-input-text{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-input-text{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-input-color>.ck.ck-input-text:focus{z-index:0}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{padding:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-left-radius:0;border-top-left-radius:0}[dir=ltr] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-left:1px solid transparent}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button{border-bottom-right-radius:0;border-top-right-radius:0}[dir=rtl] .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button:not(:focus){border-right:1px solid transparent}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button.ck-disabled{background:var(--ck-color-input-disabled-background)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border-radius:0}.ck-rounded-corners .ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview,.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview{border:1px solid var(--ck-color-input-border);height:20px;width:20px}.ck.ck-input-color>.ck.ck-dropdown>.ck.ck-button.ck-input-color__button>.ck.ck-input-color__button__preview>.ck.ck-input-color__button__preview__no-color-indicator{background:red;border-radius:2px;height:150%;left:50%;top:-30%;transform:rotate(45deg);transform-origin:50%;width:8%}.ck.ck-input-color .ck.ck-input-color__remove-color{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard);width:100%}.ck.ck-input-color .ck.ck-input-color__remove-color:not(:focus){border-bottom:1px solid var(--ck-color-input-border)}[dir=ltr] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-right-radius:0}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color{border-top-left-radius:0}.ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-input-color .ck.ck-input-color__remove-color .ck.ck-icon{margin-left:var(--ck-spacing-standard);margin-right:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/colorinput.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,YAAa,CACb,0BAA2B,CAF3B,UAgCD,CA5BC,0CAEC,WAAY,CADZ,cAED,CAEA,sCACC,cAMD,CAHC,kFACC,YACD,CAGD,8CAEC,YAWD,CATC,kFAEC,eAAgB,CADhB,iBAOD,CAJC,0IAEC,aAAc,CADd,iBAED,CC1BF,+CAGE,4BAA6B,CAD7B,yBAcF,CAhBA,+CAQE,2BAA4B,CAD5B,wBASF,CAHC,2CACC,SACD,CAIA,wEACC,SA0CD,CA3CA,kFAKE,2BAA4B,CAD5B,wBAuCF,CApCE,8FACC,iCACD,CATF,kFAcE,4BAA6B,CAD7B,yBA8BF,CA3BE,8FACC,kCACD,CAGD,oFACC,oDACD,CAEA,4GC1CF,eD2DE,CAjBA,+PCtCD,qCDuDC,CAjBA,4GAKC,6CAA8C,CAD9C,WAAY,CADZ,UAcD,CAVC,oKAKC,cAA6B,CAC7B,iBAAkB,CAHlB,WAAY,CADZ,QAAS,CADT,QAAS,CAMT,uBAAwB,CACxB,oBAAqB,CAJrB,QAKD,CAKH,oDAIC,2BAA4B,CAC5B,4BAA6B,CAH7B,qEAAwE,CADxE,UA0BD,CApBC,gEACC,oDACD,CATD,8DAYE,yBAeF,CA3BA,8DAgBE,wBAWF,CARC,gEACC,uCAMD,CAPA,0EAKE,sCAAuC,CADvC,cAGF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-input-color {\n	width: 100%;\n	display: flex;\n	flex-direction: row-reverse;\n\n	& > input.ck.ck-input-text {\n		min-width: auto;\n		flex-grow: 1;\n	}\n\n	& > div.ck.ck-dropdown {\n		min-width: auto;\n\n		/* This dropdown has no arrow but a color preview instead. */\n		& > .ck-input-color__button .ck-dropdown__arrow {\n			display: none;\n		}\n	}\n\n	& .ck.ck-input-color__button {\n		/* Resolving issue with misaligned buttons on Safari (see #10589) */\n		display: flex;\n\n		& .ck.ck-input-color__button__preview {\n			position: relative;\n			overflow: hidden;\n\n			& > .ck.ck-input-color__button__preview__no-color-indicator {\n				position: absolute;\n				display: block;\n			}\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n@import "../mixins/_rounded.css";\n\n.ck.ck-input-color {\n	& > .ck.ck-input-text {\n		@mixin ck-dir ltr {\n			border-top-right-radius: 0;\n			border-bottom-right-radius: 0;\n		}\n\n		@mixin ck-dir rtl {\n			border-top-left-radius: 0;\n			border-bottom-left-radius: 0;\n		}\n\n		/* Make sure the focused input is always on top of the dropdown button so its\n		   outline and border are never cropped (also when the input is read-only). */\n		&:focus {\n			z-index: 0;\n		}\n	}\n\n	& > .ck.ck-dropdown {\n		& > .ck.ck-button.ck-input-color__button {\n			padding: 0;\n\n			@mixin ck-dir ltr {\n				border-top-left-radius: 0;\n				border-bottom-left-radius: 0;\n\n				&:not(:focus) {\n					border-left: 1px solid transparent;\n				}\n			}\n\n			@mixin ck-dir rtl {\n				border-top-right-radius: 0;\n				border-bottom-right-radius: 0;\n\n				&:not(:focus) {\n					border-right: 1px solid transparent;\n				}\n			}\n\n			&.ck-disabled {\n				background: var(--ck-color-input-disabled-background);\n			}\n\n			& > .ck.ck-input-color__button__preview {\n				@mixin ck-rounded-corners;\n\n				width: 20px;\n				height: 20px;\n				border: 1px solid var(--ck-color-input-border);\n\n				& > .ck.ck-input-color__button__preview__no-color-indicator {\n					top: -30%;\n					left: 50%;\n					height: 150%;\n					width: 8%;\n					background: hsl(0, 100%, 50%);\n					border-radius: 2px;\n					transform: rotate(45deg);\n					transform-origin: 50%;\n				}\n			}\n		}\n	}\n\n	& .ck.ck-input-color__remove-color {\n		width: 100%;\n		padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n\n		border-bottom-left-radius: 0;\n		border-bottom-right-radius: 0;\n\n		&:not(:focus) {\n			border-bottom: 1px solid var(--ck-color-input-border);\n		}\n\n		@mixin ck-dir ltr {\n			border-top-right-radius: 0;\n		}\n\n		@mixin ck-dir rtl {\n			border-top-left-radius: 0;\n		}\n\n		& .ck.ck-icon {\n			margin-right: var(--ck-spacing-standard);\n\n			@mixin ck-dir rtl {\n				margin-right: 0;\n				margin-left: var(--ck-spacing-standard);\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4070: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-form{padding:0 0 var(--ck-spacing-large)}.ck.ck-form:focus{outline:none}.ck.ck-form .ck.ck-input-text{min-width:100%;width:0}.ck.ck-form .ck.ck-dropdown{min-width:100%}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button:not(:focus){border:1px solid var(--ck-color-base-border)}.ck.ck-form .ck.ck-dropdown .ck-dropdown__button .ck-button__label{width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/form.css"], names: [], mappings: "AAKA,YACC,mCAyBD,CAvBC,kBAEC,YACD,CAEA,8BACC,cAAe,CACf,OACD,CAEA,4BACC,cAWD,CARE,6DACC,4CACD,CAEA,mEACC,UACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form {\n	padding: 0 0 var(--ck-spacing-large);\n\n	&:focus {\n		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n		outline: none;\n	}\n\n	& .ck.ck-input-text {\n		min-width: 100%;\n		width: 0;\n	}\n\n	& .ck.ck-dropdown {\n		min-width: 100%;\n\n		& .ck-dropdown__button {\n			&:not(:focus) {\n				border: 1px solid var(--ck-color-base-border);\n			}\n\n			& .ck-button__label {\n				width: 100%;\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 9247: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-form__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__row>:not(.ck-label){flex-grow:1}.ck.ck-form__row.ck-table-form__action-row .ck-button-cancel,.ck.ck-form__row.ck-table-form__action-row .ck-button-save{justify-content:center}.ck.ck-form__row{padding:var(--ck-spacing-standard) var(--ck-spacing-large) 0}[dir=ltr] .ck.ck-form__row>:not(.ck-label)+*{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-form__row>:not(.ck-label)+*{margin-right:var(--ck-spacing-large)}.ck.ck-form__row>.ck-label{min-width:100%;width:100%}.ck.ck-form__row.ck-table-form__action-row{margin-top:var(--ck-spacing-large)}.ck.ck-form__row.ck-table-form__action-row .ck-button .ck-button__label{color:var(--ck-color-text)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/formrow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/formrow.css"], names: [], mappings: "AAKA,iBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAaD,CAVC,iCACC,WACD,CAGC,wHAEC,sBACD,CCbF,iBACC,4DA2BD,CAvBE,6CAEE,mCAMF,CARA,6CAME,oCAEF,CAGD,2BAEC,cAAe,CADf,UAED,CAEA,2CACC,kCAKD,CAHC,wEACC,0BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__row {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	justify-content: space-between;\n\n	/* Ignore labels that work as fieldset legends */\n	& > *:not(.ck-label) {\n		flex-grow: 1;\n	}\n\n	&.ck-table-form__action-row {\n		& .ck-button-save,\n		& .ck-button-cancel {\n			justify-content: center;\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-form__row {\n	padding: var(--ck-spacing-standard) var(--ck-spacing-large) 0;\n\n	/* Ignore labels that work as fieldset legends */\n	& > *:not(.ck-label) {\n		& + * {\n			@mixin ck-dir ltr {\n				margin-left: var(--ck-spacing-large);\n			}\n\n			@mixin ck-dir rtl {\n				margin-right: var(--ck-spacing-large);\n			}\n		}\n	}\n\n	& > .ck-label {\n		width: 100%;\n		min-width: 100%;\n	}\n\n	&.ck-table-form__action-row {\n		margin-top: var(--ck-spacing-large);\n\n		& .ck-button .ck-button__label {\n			color: var(--ck-color-text);\n		}\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 1613: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck .ck-insert-table-dropdown__grid{display:flex;flex-direction:row;flex-wrap:wrap}:root{--ck-insert-table-dropdown-padding:10px;--ck-insert-table-dropdown-box-height:11px;--ck-insert-table-dropdown-box-width:12px;--ck-insert-table-dropdown-box-margin:1px}.ck .ck-insert-table-dropdown__grid{padding:var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;width:calc(var(--ck-insert-table-dropdown-box-width)*10 + var(--ck-insert-table-dropdown-box-margin)*20 + var(--ck-insert-table-dropdown-padding)*2)}.ck .ck-insert-table-dropdown__label,.ck[dir=rtl] .ck-insert-table-dropdown__label{text-align:center}.ck .ck-insert-table-dropdown-grid-box{border:1px solid var(--ck-color-base-border);border-radius:1px;margin:var(--ck-insert-table-dropdown-box-margin);min-height:var(--ck-insert-table-dropdown-box-height);min-width:var(--ck-insert-table-dropdown-box-width);outline:none;transition:none}.ck .ck-insert-table-dropdown-grid-box:focus{box-shadow:none}.ck .ck-insert-table-dropdown-grid-box.ck-on{background:var(--ck-color-focus-outer-shadow);border-color:var(--ck-color-focus-border)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/inserttable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/inserttable.css"], names: [], mappings: "AAKA,oCACC,YAAa,CACb,kBAAmB,CACnB,cACD,CCJA,MACC,uCAAwC,CACxC,0CAA2C,CAC3C,yCAA0C,CAC1C,yCACD,CAEA,oCAGC,yFAA0F,CAD1F,oJAED,CAEA,mFAEC,iBACD,CAEA,uCAIC,4CAA6C,CAC7C,iBAAkB,CAFlB,iDAAkD,CADlD,qDAAsD,CADtD,mDAAoD,CAKpD,YAAa,CACb,eAUD,CARC,6CACC,eACD,CAEA,6CAEC,6CAA8C,CAD9C,yCAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-insert-table-dropdown__grid {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: wrap;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-insert-table-dropdown-padding: 10px;\n	--ck-insert-table-dropdown-box-height: 11px;\n	--ck-insert-table-dropdown-box-width: 12px;\n	--ck-insert-table-dropdown-box-margin: 1px;\n}\n\n.ck .ck-insert-table-dropdown__grid {\n	/* The width of a container should match 10 items in a row so there will be a 10x10 grid. */\n	width: calc(var(--ck-insert-table-dropdown-box-width) * 10 + var(--ck-insert-table-dropdown-box-margin) * 20 + var(--ck-insert-table-dropdown-padding) * 2);\n	padding: var(--ck-insert-table-dropdown-padding) var(--ck-insert-table-dropdown-padding) 0;\n}\n\n.ck .ck-insert-table-dropdown__label,\n.ck[dir=rtl] .ck-insert-table-dropdown__label {\n	text-align: center;\n}\n\n.ck .ck-insert-table-dropdown-grid-box {\n	min-width: var(--ck-insert-table-dropdown-box-width);\n	min-height: var(--ck-insert-table-dropdown-box-height);\n	margin: var(--ck-insert-table-dropdown-box-margin);\n	border: 1px solid var(--ck-color-base-border);\n	border-radius: 1px;\n	outline: none;\n	transition: none;\n\n	&:focus {\n		box-shadow: none;\n	}\n\n	&.ck-on {\n		border-color: var(--ck-color-focus-border);\n		background: var(--ck-color-focus-outer-shadow);\n	}\n}\n\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 6306: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-content .table{display:table;margin:.9em auto}.ck-content .table table{border:1px double #b3b3b3;border-collapse:collapse;border-spacing:0;height:100%;width:100%}.ck-content .table table td,.ck-content .table table th{border:1px solid #bfbfbf;min-width:2em;padding:.4em}.ck-content .table table th{background:rgba(0,0,0,.05);font-weight:700}.ck-content[dir=rtl] .table th{text-align:right}.ck-content[dir=ltr] .table th{text-align:left}.ck-editor__editable .ck-table-bogus-paragraph{display:inline-block;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/table.css"], names: [], mappings: "AAKA,mBAKC,aAAc,CADd,gBAiCD,CA9BC,yBAYC,yBAAkC,CAVlC,wBAAyB,CACzB,gBAAiB,CAKjB,WAAY,CADZ,UAsBD,CAfC,wDAQC,wBAAiC,CANjC,aAAc,CACd,YAMD,CAEA,4BAEC,0BAA+B,CAD/B,eAED,CAMF,+BACC,gBACD,CAEA,+BACC,eACD,CAEA,+CAKC,oBAAqB,CAMrB,UACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck-content .table {
	/* Give the table widget some air and center it horizontally */
	/* The first value should be equal to --ck-spacing-large variable if used in the editor context
	to avoid the content jumping (See https://github.com/ckeditor/ckeditor5/issues/9825). */
	margin: 0.9em auto;
	display: table;

	& table {
		/* The table cells should have slight borders */
		border-collapse: collapse;
		border-spacing: 0;

		/* Table width and height are set on the parent <figure>. Make sure the table inside stretches
		to the full dimensions of the container (https://github.com/ckeditor/ckeditor5/issues/6186). */
		width: 100%;
		height: 100%;

		/* The outer border of the table should be slightly darker than the inner lines.
		Also see https://github.com/ckeditor/ckeditor5-table/issues/50. */
		border: 1px double hsl(0, 0%, 70%);

		& td,
		& th {
			min-width: 2em;
			padding: .4em;

			/* The border is inherited from .ck-editor__nested-editable styles, so theoretically it's not necessary here.
			However, the border is a content style, so it should use .ck-content (so it works outside the editor).
			Hence, the duplication. See https://github.com/ckeditor/ckeditor5/issues/6314 */
			border: 1px solid hsl(0, 0%, 75%);
		}

		& th {
			font-weight: bold;
			background: hsla(0, 0%, 0%, 5%);
		}
	}
}

/* Text alignment of the table header should match the editor settings and override the native browser styling,
when content is available outside the editor. See https://github.com/ckeditor/ckeditor5/issues/6638 */
.ck-content[dir="rtl"] .table th {
	text-align: right;
}

.ck-content[dir="ltr"] .table th {
	text-align: left;
}

.ck-editor__editable .ck-table-bogus-paragraph {
	/*
	 * Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
	 * See https://github.com/ckeditor/ckeditor5/issues/6062.
	 */
	display: inline-block;

	/*
	 * Inline HTML elements nested in the span should always be dimensioned in relation to the whole cell width.
	 * See https://github.com/ckeditor/ckeditor5/issues/9117.
	 */
	width: 100%;
}
`], sourceRoot: "" }]);
      const a2 = s2;
    }, 2128: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-color-selector-caption-background:#f7f7f7;--ck-color-selector-caption-text:#333;--ck-color-selector-caption-highlighted-background:#fd0}.ck-content .table>figcaption{background-color:var(--ck-color-selector-caption-background);caption-side:top;color:var(--ck-color-selector-caption-text);display:table-caption;font-size:.75em;outline-offset:-1px;padding:.6em;text-align:center;word-break:break-word}.ck.ck-editor__editable .table>figcaption.table__caption_highlighted{animation:ck-table-caption-highlight .6s ease-out}.ck.ck-editor__editable .table>figcaption.ck-placeholder:before{overflow:hidden;padding-left:inherit;padding-right:inherit;text-overflow:ellipsis;white-space:nowrap}@keyframes ck-table-caption-highlight{0%{background-color:var(--ck-color-selector-caption-highlighted-background)}to{background-color:var(--ck-color-selector-caption-background)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecaption.css"], names: [], mappings: "AAKA,MACC,8CAAuD,CACvD,qCAAiD,CACjD,uDACD,CAGA,8BAMC,4DAA6D,CAJ7D,gBAAiB,CAGjB,2CAA4C,CAJ5C,qBAAsB,CAOtB,eAAgB,CAChB,mBAAoB,CAFpB,YAAa,CAHb,iBAAkB,CADlB,qBAOD,CAIC,qEACC,iDACD,CAEA,gEASC,eAAgB,CARhB,oBAAqB,CACrB,qBAAsB,CAQtB,sBAAuB,CAFvB,kBAGD,CAGD,sCACC,GACC,wEACD,CAEA,GACC,4DACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-selector-caption-background: hsl(0, 0%, 97%);\n	--ck-color-selector-caption-text: hsl(0, 0%, 20%);\n	--ck-color-selector-caption-highlighted-background: hsl(52deg 100% 50%);\n}\n\n/* Content styles */\n.ck-content .table > figcaption {\n	display: table-caption;\n	caption-side: top;\n	word-break: break-word;\n	text-align: center;\n	color: var(--ck-color-selector-caption-text);\n	background-color: var(--ck-color-selector-caption-background);\n	padding: .6em;\n	font-size: .75em;\n	outline-offset: -1px;\n}\n\n/* Editing styles */\n.ck.ck-editor__editable .table > figcaption {\n	&.table__caption_highlighted {\n		animation: ck-table-caption-highlight .6s ease-out;\n	}\n\n	&.ck-placeholder::before {\n		padding-left: inherit;\n		padding-right: inherit;\n\n		/*\n		 * Make sure the table caption placeholder doesn't overflow the placeholder area.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9162.\n		 */\n		white-space: nowrap;\n		overflow: hidden;\n		text-overflow: ellipsis;\n	}\n}\n\n@keyframes ck-table-caption-highlight {\n	0% {\n		background-color: var(--ck-color-selector-caption-highlighted-background);\n	}\n\n	100% {\n		background-color: var(--ck-color-selector-caption-background);\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 5087: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row{flex-wrap:wrap}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:first-of-type{flex-grow:0.57}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar:last-of-type{flex-grow:0.43}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar .ck-button{flex-grow:1}.ck.ck-table-cell-properties-form{width:320px}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__padding-row{align-self:flex-end;padding:0;width:25%}.ck.ck-table-cell-properties-form .ck-form__row.ck-table-cell-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecellproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tablecellproperties.css"], names: [], mappings: "AAOE,6FACC,cAiBD,CAdE,0HAEC,cACD,CAEA,yHAEC,cACD,CAEA,uHACC,WACD,CClBJ,kCACC,WAkBD,CAfE,2FACC,mBAAoB,CACpB,SAAU,CACV,SACD,CAGC,4GACC,eAAgB,CAGhB,qCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n	& .ck-form__row {\n		&.ck-table-cell-properties-form__alignment-row {\n			flex-wrap: wrap;\n\n			& .ck.ck-toolbar {\n				&:first-of-type {\n					/* 4 buttons out of 7 (h-alignment + v-alignment) = 0.57 */\n					flex-grow: 0.57;\n				}\n\n				&:last-of-type {\n					/* 3 buttons out of 7 (h-alignment + v-alignment) = 0.43 */\n					flex-grow: 0.43;\n				}\n\n				& .ck-button {\n					flex-grow: 1;\n				}\n			}\n		}\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-cell-properties-form {\n	width: 320px;\n\n	& .ck-form__row {\n		&.ck-table-cell-properties-form__padding-row {\n			align-self: flex-end;\n			padding: 0;\n			width: 25%;\n		}\n\n		&.ck-table-cell-properties-form__alignment-row {\n			& .ck.ck-toolbar {\n				background: none;\n\n				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n				margin-top: var(--ck-spacing-standard);\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4101: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-color-selector-column-resizer-hover:var(--ck-color-base-active);--ck-table-column-resizer-width:7px;--ck-table-column-resizer-position-offset:calc(var(--ck-table-column-resizer-width)*-0.5 - 0.5px)}.ck-content .table .ck-table-resized{table-layout:fixed}.ck-content .table table{overflow:hidden}.ck-content .table td,.ck-content .table th{overflow-wrap:break-word;position:relative}.ck.ck-editor__editable .table .ck-table-column-resizer{bottom:0;cursor:col-resize;position:absolute;right:var(--ck-table-column-resizer-position-offset);top:0;user-select:none;width:var(--ck-table-column-resizer-width);z-index:var(--ck-z-default)}.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer,.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer{display:none}.ck.ck-editor__editable .table .ck-table-column-resizer:hover,.ck.ck-editor__editable .table .ck-table-column-resizer__active{background-color:var(--ck-color-selector-column-resizer-hover);bottom:-999999px;opacity:.25;top:-999999px}.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer{left:var(--ck-table-column-resizer-position-offset);right:unset}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tablecolumnresize.css"], names: [], mappings: "AAKA,MACC,oEAAqE,CACrE,mCAAoC,CAIpC,iGACD,CAEA,qCACC,kBACD,CAEA,yBACC,eACD,CAEA,4CAIC,wBAAyB,CACzB,iBACD,CAEA,wDAGC,QAAS,CAGT,iBAAkB,CALlB,iBAAkB,CAGlB,oDAAqD,CAFrD,KAAM,CAKN,gBAAiB,CAFjB,0CAA2C,CAG3C,2BACD,CAQA,qJACC,YACD,CAEA,8HAEC,8DAA+D,CAO/D,gBAAiB,CANjB,WAAa,CAKb,aAED,CAEA,iEACC,mDAAoD,CACpD,WACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-selector-column-resizer-hover: var(--ck-color-base-active);\n	--ck-table-column-resizer-width: 7px;\n\n	/* The offset used for absolute positioning of the resizer element, so that it is placed exactly above the cell border.\n	   The value is: minus half the width of the resizer decreased additionaly by the half the width of the border (0.5px). */\n	--ck-table-column-resizer-position-offset: calc(var(--ck-table-column-resizer-width) * -0.5 - 0.5px);\n}\n\n.ck-content .table .ck-table-resized {\n	table-layout: fixed;\n}\n\n.ck-content .table table {\n	overflow: hidden;\n}\n\n.ck-content .table td,\n.ck-content .table th {\n	/* To prevent text overflowing beyond its cell when columns are resized by resize handler\n	(https://github.com/ckeditor/ckeditor5/pull/14379#issuecomment-1589460978). */\n	overflow-wrap: break-word;\n	position: relative;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer {\n	position: absolute;\n	top: 0;\n	bottom: 0;\n	right: var(--ck-table-column-resizer-position-offset);\n	width: var(--ck-table-column-resizer-width);\n	cursor: col-resize;\n	user-select: none;\n	z-index: var(--ck-z-default);\n}\n\n.ck.ck-editor__editable.ck-column-resize_disabled .table .ck-table-column-resizer {\n	display: none;\n}\n\n/* The resizer elements, which are extended to an extremely high height, break the drag & drop feature in Chrome. To make it work again,\n   all resizers must be hidden while the table is dragged. */\n.ck.ck-editor__editable .table[draggable] .ck-table-column-resizer {\n	display: none;\n}\n\n.ck.ck-editor__editable .table .ck-table-column-resizer:hover,\n.ck.ck-editor__editable .table .ck-table-column-resizer__active {\n	background-color: var(--ck-color-selector-column-resizer-hover);\n	opacity: 0.25;\n	/* The resizer element resides in each cell so to occupy the entire height of the table, which is unknown from a CSS point of view,\n	   it is extended to an extremely high height. Even for screens with a very high pixel density, the resizer will fulfill its role as\n	   it should, i.e. for a screen of 476 ppi the total height of the resizer will take over 350 sheets of A4 format, which is totally\n	   unrealistic height for a single table. */\n	top: -999999px;\n	bottom: -999999px;\n}\n\n.ck.ck-editor__editable[dir=rtl] .table .ck-table-column-resizer {\n	left: var(--ck-table-column-resizer-position-offset);\n	right: unset;\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3881: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-color-selector-focused-cell-background:rgba(158,201,250,.3)}.ck-widget.table td.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table td.ck-editor__nested-editable:focus,.ck-widget.table th.ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck-widget.table th.ck-editor__nested-editable:focus{background:var(--ck-color-selector-focused-cell-background);border-style:none;outline:1px solid var(--ck-color-focus-border);outline-offset:-1px}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableediting.css"], names: [], mappings: "AAKA,MACC,gEACD,CAKE,8QAGC,2DAA4D,CAK5D,iBAAkB,CAClB,8CAA+C,CAC/C,mBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-selector-focused-cell-background: hsla(212, 90%, 80%, .3);\n}\n\n.ck-widget.table {\n	& td,\n	& th {\n		&.ck-editor__nested-editable.ck-editor__nested-editable_focused,\n		&.ck-editor__nested-editable:focus {\n			/* A very slight background to highlight the focused cell */\n			background: var(--ck-color-selector-focused-cell-background);\n\n			/* Fixes the problem where surrounding cells cover the focused cell's border.\n			It does not fix the problem in all places but the UX is improved.\n			See https://github.com/ckeditor/ckeditor5-table/issues/29. */\n			border-style: none;\n			outline: 1px solid var(--ck-color-focus-border);\n			outline-offset: -1px; /* progressive enhancement - no IE support */\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 6237: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck.ck-table-form .ck-form__row.ck-table-form__background-row,.ck.ck-table-form .ck-form__row.ck-table-form__border-row{flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{align-items:center;flex-wrap:wrap}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view{align-items:center;display:flex;flex-direction:column-reverse}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-labeled-field-view .ck.ck-dropdown,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{flex-grow:0}.ck.ck-table-form .ck.ck-labeled-field-view{position:relative}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{bottom:calc(var(--ck-table-properties-error-arrow-size)*-1);left:50%;position:absolute;transform:translate(-50%,100%);z-index:1}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{content:"";left:50%;position:absolute;top:calc(var(--ck-table-properties-error-arrow-size)*-1);transform:translateX(-50%)}:root{--ck-table-properties-error-arrow-size:6px;--ck-table-properties-min-error-width:150px}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-labeled-field-view>.ck-label{font-size:var(--ck-font-size-tiny);text-align:center}.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-style,.ck.ck-table-form .ck-form__row.ck-table-form__border-row .ck-table-form__border-width{max-width:80px;min-width:80px;width:80px}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row{padding:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__height,.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimensions-row__width{margin:0}.ck.ck-table-form .ck-form__row.ck-table-form__dimensions-row .ck-table-form__dimension-operator{align-self:flex-end;display:inline-block;height:var(--ck-ui-component-min-height);line-height:var(--ck-ui-component-min-height);margin:0 var(--ck-spacing-small)}.ck.ck-table-form .ck.ck-labeled-field-view{padding-top:var(--ck-spacing-standard)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{border-radius:0}.ck-rounded-corners .ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status,.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{background:var(--ck-color-base-error);color:var(--ck-color-base-background);min-width:var(--ck-table-properties-min-error-width);padding:var(--ck-spacing-small) var(--ck-spacing-medium);text-align:center}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status:after{border-color:transparent transparent var(--ck-color-base-error) transparent;border-style:solid;border-width:0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size)}.ck.ck-table-form .ck.ck-labeled-field-view .ck.ck-labeled-field-view__status{animation:ck-table-form-labeled-view-status-appear .15s ease both}.ck.ck-table-form .ck.ck-labeled-field-view .ck-input.ck-error:not(:focus)+.ck.ck-labeled-field-view__status{display:none}@keyframes ck-table-form-labeled-view-status-appear{0%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableform.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAWE,wHACC,cACD,CAEA,8DAEC,kBAAmB,CADnB,cAgBD,CAbC,qFAGC,kBAAmB,CAFnB,YAAa,CACb,6BAMD,CAEA,sMACC,WACD,CAIF,4CAEC,iBAoBD,CAlBC,8EAGC,2DAAgE,CADhE,QAAS,CADT,iBAAkB,CAGlB,8BAA+B,CAG/B,SAUD,CAPC,oFACC,UAAW,CAGX,QAAS,CAFT,iBAAkB,CAClB,wDAA6D,CAE7D,0BACD,CChDH,MACC,0CAA2C,CAC3C,2CACD,CAMI,2FACC,kCAAmC,CACnC,iBACD,CAGD,8KAIC,cAAe,CADf,cAAe,CADf,UAGD,CAGD,8DACC,SAcD,CAZC,yMAEC,QACD,CAEA,iGACC,mBAAoB,CACpB,oBAAqB,CACrB,wCAAyC,CACzC,6CAA8C,CAC9C,gCACD,CAIF,4CACC,sCAyBD,CAvBC,8ECxCD,eDyDC,CAjBA,mMCpCA,qCDqDA,CAjBA,8EAGC,qCAAsC,CACtC,qCAAsC,CAEtC,oDAAqD,CADrD,wDAAyD,CAEzD,iBAUD,CAPC,oFACC,2EAA4E,CAE5E,kBAAmB,CADnB,kJAED,CAdD,8EAgBC,iEACD,CAGA,6GACC,YACD,CAIF,oDACC,GACC,SACD,CAEA,GACC,SACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-form {\n	& .ck-form__row {\n		&.ck-table-form__border-row {\n			flex-wrap: wrap;\n		}\n\n		&.ck-table-form__background-row {\n			flex-wrap: wrap;\n		}\n\n		&.ck-table-form__dimensions-row {\n			flex-wrap: wrap;\n			align-items: center;\n\n			& .ck-labeled-field-view {\n				display: flex;\n				flex-direction: column-reverse;\n				align-items: center;\n\n				& .ck.ck-dropdown {\n					flex-grow: 0;\n				}\n			}\n\n			& .ck-table-form__dimension-operator {\n				flex-grow: 0;\n			}\n		}\n	}\n\n	& .ck.ck-labeled-field-view {\n		/* Allow absolute positioning of the status (error) balloons. */\n		position: relative;\n\n		& .ck.ck-labeled-field-view__status {\n			position: absolute;\n			left: 50%;\n			bottom: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n			transform: translate(-50%,100%);\n\n			/* Make sure the balloon status stays on top of other form elements. */\n			z-index: 1;\n\n			/* The arrow pointing towards the field. */\n			&::after {\n				content: "";\n				position: absolute;\n				top: calc( -1 * var(--ck-table-properties-error-arrow-size) );\n				left: 50%;\n				transform: translateX( -50% );\n			}\n		}\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_rounded.css";\n\n:root {\n	--ck-table-properties-error-arrow-size: 6px;\n	--ck-table-properties-min-error-width: 150px;\n}\n\n.ck.ck-table-form {\n	& .ck-form__row {\n		&.ck-table-form__border-row {\n			& .ck-labeled-field-view {\n				& > .ck-label {\n					font-size: var(--ck-font-size-tiny);\n					text-align: center;\n				}\n			}\n\n			& .ck-table-form__border-style,\n			& .ck-table-form__border-width {\n				width: 80px;\n				min-width: 80px;\n				max-width: 80px;\n			}\n		}\n\n		&.ck-table-form__dimensions-row {\n			padding: 0;\n\n			& .ck-table-form__dimensions-row__width,\n			& .ck-table-form__dimensions-row__height {\n				margin: 0\n			}\n\n			& .ck-table-form__dimension-operator {\n				align-self: flex-end;\n				display: inline-block;\n				height: var(--ck-ui-component-min-height);\n				line-height: var(--ck-ui-component-min-height);\n				margin: 0 var(--ck-spacing-small);\n			}\n		}\n	}\n\n	& .ck.ck-labeled-field-view {\n		padding-top: var(--ck-spacing-standard);\n\n		& .ck.ck-labeled-field-view__status {\n			@mixin ck-rounded-corners;\n\n			background: var(--ck-color-base-error);\n			color: var(--ck-color-base-background);\n			padding: var(--ck-spacing-small) var(--ck-spacing-medium);\n			min-width: var(--ck-table-properties-min-error-width);\n			text-align: center;\n\n			/* The arrow pointing towards the field. */\n			&::after {\n				border-color: transparent transparent var(--ck-color-base-error) transparent;\n				border-width: 0 var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size) var(--ck-table-properties-error-arrow-size);\n				border-style: solid;\n			}\n\n			animation: ck-table-form-labeled-view-status-appear .15s ease both;\n		}\n\n		/* Hide the error balloon when the field is blurred. Makes the experience much more clear. */\n		& .ck-input.ck-error:not(:focus) + .ck.ck-labeled-field-view__status {\n			display: none;\n		}\n	}\n}\n\n@keyframes ck-table-form-labeled-view-status-appear {\n	0% {\n		opacity: 0;\n	}\n\n	100% {\n		opacity: 1;\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 7341: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-content:baseline;flex-basis:0;flex-wrap:wrap}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items{flex-wrap:nowrap}.ck.ck-table-properties-form{width:320px}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row{align-self:flex-end;padding:0}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar{background:none;margin-top:var(--ck-spacing-standard)}.ck.ck-table-properties-form .ck-form__row.ck-table-properties-form__alignment-row .ck.ck-toolbar .ck-toolbar__items>*{width:40px}", "", { version: 3, sources: ["webpack://./../ckeditor5-table/theme/tableproperties.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableproperties.css"], names: [], mappings: "AAOE,mFAGC,sBAAuB,CADvB,YAAa,CADb,cAOD,CAHC,qHACC,gBACD,CCTH,6BACC,WAmBD,CAhBE,mFACC,mBAAoB,CACpB,SAYD,CAVC,kGACC,eAAgB,CAGhB,qCAKD,CAHC,uHACC,UACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n	& .ck-form__row {\n		&.ck-table-properties-form__alignment-row {\n			flex-wrap: wrap;\n			flex-basis: 0;\n			align-content: baseline;\n\n			& .ck.ck-toolbar .ck-toolbar__items {\n				flex-wrap: nowrap;\n			}\n		}\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-table-properties-form {\n	width: 320px;\n\n	& .ck-form__row {\n		&.ck-table-properties-form__alignment-row {\n			align-self: flex-end;\n			padding: 0;\n\n			& .ck.ck-toolbar {\n				background: none;\n\n				/* Compensate for missing input label that would push the margin (toolbar has no inputs). */\n				margin-top: var(--ck-spacing-standard);\n\n				& .ck-toolbar__items > * {\n					width: 40px;\n				}\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 6945: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ':root{--ck-table-selected-cell-background:rgba(158,207,250,.3)}.ck.ck-editor__editable .table table td.ck-editor__editable_selected,.ck.ck-editor__editable .table table th.ck-editor__editable_selected{box-shadow:unset;caret-color:transparent;outline:unset;position:relative}.ck.ck-editor__editable .table table td.ck-editor__editable_selected:after,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:after{background-color:var(--ck-table-selected-cell-background);bottom:0;content:"";left:0;pointer-events:none;position:absolute;right:0;top:0}.ck.ck-editor__editable .table table td.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table td.ck-editor__editable_selected:focus,.ck.ck-editor__editable .table table th.ck-editor__editable_selected ::selection,.ck.ck-editor__editable .table table th.ck-editor__editable_selected:focus{background-color:transparent}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget{outline:unset}.ck.ck-editor__editable .table table td.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle,.ck.ck-editor__editable .table table th.ck-editor__editable_selected .ck-widget>.ck-widget__selection-handle{display:none}', "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-table/tableselection.css"], names: [], mappings: "AAKA,MACC,wDACD,CAGC,0IAKC,gBAAiB,CAFjB,uBAAwB,CACxB,aAAc,CAFd,iBAiCD,CA3BC,sJAGC,yDAA0D,CAK1D,QAAS,CAPT,UAAW,CAKX,MAAO,CAJP,mBAAoB,CAEpB,iBAAkB,CAGlB,OAAQ,CAFR,KAID,CAEA,wTAEC,4BACD,CAMA,gKACC,aAKD,CAHC,0NACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-table-selected-cell-background: hsla(208, 90%, 80%, .3);\n}\n\n.ck.ck-editor__editable .table table {\n	& td.ck-editor__editable_selected,\n	& th.ck-editor__editable_selected {\n		position: relative;\n		caret-color: transparent;\n		outline: unset;\n		box-shadow: unset;\n\n		/* https://github.com/ckeditor/ckeditor5/issues/6446 */\n		&:after {\n			content: '';\n			pointer-events: none;\n			background-color: var(--ck-table-selected-cell-background);\n			position: absolute;\n			top: 0;\n			left: 0;\n			right: 0;\n			bottom: 0;\n		}\n\n		& ::selection,\n		&:focus {\n			background-color: transparent;\n		}\n\n		/*\n		 * To reduce the amount of noise, all widgets in the table selection have no outline and no selection handle.\n		 * See https://github.com/ckeditor/ckeditor5/issues/9491.\n		 */\n		& .ck-widget {\n			outline: unset;\n\n			& > .ck-widget__selection-handle {\n				display: none;\n			}\n		}\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 8157: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-autocomplete{position:relative}.ck.ck-autocomplete>.ck-search__results{position:absolute;z-index:var(--ck-z-modal)}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{bottom:100%}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{bottom:auto;top:100%}.ck.ck-autocomplete>.ck-search__results{border-radius:0}.ck-rounded-corners .ck.ck-autocomplete>.ck-search__results,.ck.ck-autocomplete>.ck-search__results.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-autocomplete>.ck-search__results{background:var(--ck-color-base-background);border:1px solid var(--ck-color-dropdown-panel-border);box-shadow:var(--ck-drop-shadow),0 0;max-height:200px;min-width:auto;overflow-y:auto}.ck.ck-autocomplete>.ck-search__results.ck-search__results_n{border-bottom-left-radius:0;border-bottom-right-radius:0;margin-bottom:-1px}.ck.ck-autocomplete>.ck-search__results.ck-search__results_s{border-top-left-radius:0;border-top-right-radius:0;margin-top:-1px}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/autocomplete/autocomplete.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/autocomplete/autocomplete.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,oBACC,iBAeD,CAbC,wCACC,iBAAkB,CAClB,yBAUD,CARC,6DACC,WACD,CAEA,6DAEC,WAAY,CADZ,QAED,CCVD,wCCEA,eDuBA,CAzBA,uHCMC,qCDmBD,CAzBA,wCAMC,0CAA2C,CAC3C,sDAAuD,CEPxD,oCAA8B,CFI7B,gBAAiB,CAIjB,cAAe,CAHf,eAoBD,CAfC,6DACC,2BAA4B,CAC5B,4BAA6B,CAG7B,kBACD,CAEA,6DACC,wBAAyB,CACzB,yBAA0B,CAG1B,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-autocomplete {\n	position: relative;\n\n	& > .ck-search__results {\n		position: absolute;\n		z-index: var(--ck-z-modal);\n\n		&.ck-search__results_n {\n			bottom: 100%;\n		}\n\n		&.ck-search__results_s {\n			top: 100%;\n			bottom: auto;\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_rounded.css";\n@import "@ckeditor/ckeditor5-theme-lark/theme/mixins/_shadow.css";\n\n.ck.ck-autocomplete {\n	& > .ck-search__results {\n		@mixin ck-rounded-corners;\n		@mixin ck-drop-shadow;\n\n		max-height: 200px;\n		overflow-y: auto;\n		background: var(--ck-color-base-background);\n		border: 1px solid var(--ck-color-dropdown-panel-border);\n		min-width: auto;\n\n		&.ck-search__results_n {\n			border-bottom-left-radius: 0;\n			border-bottom-right-radius: 0;\n\n			/* Prevent duplicated borders between the input and the results pane. */\n			margin-bottom: -1px;\n		}\n\n		&.ck-search__results_s {\n			border-top-left-radius: 0;\n			border-top-right-radius: 0;\n\n			/* Prevent duplicated borders between the input and the results pane. */\n			margin-top: -1px;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4906: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-button,a.ck.ck-button{align-items:center;display:inline-flex;justify-content:left;position:relative;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{display:none}.ck.ck-button.ck-button_with-text .ck-button__label,a.ck.ck-button.ck-button_with-text .ck-button__label{display:inline-block}.ck.ck-button:not(.ck-button_with-text),a.ck.ck-button:not(.ck-button_with-text){justify-content:center}.ck.ck-button,a.ck.ck-button{background:var(--ck-color-button-default-background)}.ck.ck-button:not(.ck-disabled):hover,a.ck.ck-button:not(.ck-disabled):hover{background:var(--ck-color-button-default-hover-background)}.ck.ck-button:not(.ck-disabled):active,a.ck.ck-button:not(.ck-disabled):active{background:var(--ck-color-button-default-active-background)}.ck.ck-button.ck-disabled,a.ck.ck-button.ck-disabled{background:var(--ck-color-button-default-disabled-background)}.ck.ck-button,a.ck.ck-button{border-radius:0}.ck-rounded-corners .ck.ck-button,.ck-rounded-corners a.ck.ck-button,.ck.ck-button.ck-rounded-corners,a.ck.ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-button,a.ck.ck-button{-webkit-appearance:none;border:1px solid transparent;cursor:default;font-size:inherit;line-height:1;min-height:var(--ck-ui-component-min-height);min-width:var(--ck-ui-component-min-height);padding:var(--ck-spacing-tiny);text-align:center;transition:box-shadow .2s ease-in-out,border .2s ease-in-out;vertical-align:middle;white-space:nowrap}.ck.ck-button:active,.ck.ck-button:focus,a.ck.ck-button:active,a.ck.ck-button:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-button .ck-button__icon use,.ck.ck-button .ck-button__icon use *,a.ck.ck-button .ck-button__icon use,a.ck.ck-button .ck-button__icon use *{color:inherit}.ck.ck-button .ck-button__label,a.ck.ck-button .ck-button__label{color:inherit;cursor:inherit;font-size:inherit;font-weight:inherit;vertical-align:middle}[dir=ltr] .ck.ck-button .ck-button__label,[dir=ltr] a.ck.ck-button .ck-button__label{text-align:left}[dir=rtl] .ck.ck-button .ck-button__label,[dir=rtl] a.ck.ck-button .ck-button__label{text-align:right}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{color:inherit}[dir=ltr] .ck.ck-button .ck-button__keystroke,[dir=ltr] a.ck.ck-button .ck-button__keystroke{margin-left:var(--ck-spacing-large)}[dir=rtl] .ck.ck-button .ck-button__keystroke,[dir=rtl] a.ck.ck-button .ck-button__keystroke{margin-right:var(--ck-spacing-large)}.ck.ck-button .ck-button__keystroke,a.ck.ck-button .ck-button__keystroke{font-weight:700;opacity:.7}.ck.ck-button.ck-disabled:active,.ck.ck-button.ck-disabled:focus,a.ck.ck-button.ck-disabled:active,a.ck.ck-button.ck-disabled:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-button.ck-disabled .ck-button__icon,.ck.ck-button.ck-disabled .ck-button__label,a.ck.ck-button.ck-disabled .ck-button__icon,a.ck.ck-button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-disabled .ck-button__keystroke,a.ck.ck-button.ck-disabled .ck-button__keystroke{opacity:.3}.ck.ck-button.ck-button_with-text,a.ck.ck-button.ck-button_with-text{padding:var(--ck-spacing-tiny) var(--ck-spacing-standard)}[dir=ltr] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=ltr] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:calc(var(--ck-spacing-small)*-1);margin-right:var(--ck-spacing-small)}[dir=rtl] .ck.ck-button.ck-button_with-text .ck-button__icon,[dir=rtl] a.ck.ck-button.ck-button_with-text .ck-button__icon{margin-left:var(--ck-spacing-small);margin-right:calc(var(--ck-spacing-small)*-1)}.ck.ck-button.ck-button_with-keystroke .ck-button__label,a.ck.ck-button.ck-button_with-keystroke .ck-button__label{flex-grow:1}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{background:var(--ck-color-button-on-background)}.ck.ck-button.ck-on:not(.ck-disabled):hover,a.ck.ck-button.ck-on:not(.ck-disabled):hover{background:var(--ck-color-button-on-hover-background)}.ck.ck-button.ck-on:not(.ck-disabled):active,a.ck.ck-button.ck-on:not(.ck-disabled):active{background:var(--ck-color-button-on-active-background)}.ck.ck-button.ck-on.ck-disabled,a.ck.ck-button.ck-on.ck-disabled{background:var(--ck-color-button-on-disabled-background)}.ck.ck-button.ck-on,a.ck.ck-button.ck-on{color:var(--ck-color-button-on-color)}.ck.ck-button.ck-button-save,a.ck.ck-button.ck-button-save{color:var(--ck-color-button-save)}.ck.ck-button.ck-button-cancel,a.ck.ck-button.ck-button-cancel{color:var(--ck-color-button-cancel)}.ck.ck-button-action,a.ck.ck-button-action{background:var(--ck-color-button-action-background)}.ck.ck-button-action:not(.ck-disabled):hover,a.ck.ck-button-action:not(.ck-disabled):hover{background:var(--ck-color-button-action-hover-background)}.ck.ck-button-action:not(.ck-disabled):active,a.ck.ck-button-action:not(.ck-disabled):active{background:var(--ck-color-button-action-active-background)}.ck.ck-button-action.ck-disabled,a.ck.ck-button-action.ck-disabled{background:var(--ck-color-button-action-disabled-background)}.ck.ck-button-action,a.ck.ck-button-action{color:var(--ck-color-button-action-text)}.ck.ck-button-bold,a.ck.ck-button-bold{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/button.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/button.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/mixins/_button.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AAOA,6BAMC,kBAAmB,CADnB,mBAAoB,CAEpB,oBAAqB,CAHrB,iBAAkB,CCFlB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDkBD,CAdC,iEACC,YACD,CAGC,yGACC,oBACD,CAID,iFACC,sBACD,CEjBD,6BCAC,oDD4ID,CCzIE,6EACC,0DACD,CAEA,+EACC,2DACD,CAID,qDACC,6DACD,CDfD,6BEDC,eF6ID,CA5IA,wIEGE,qCFyIF,CA5IA,6BA6BC,uBAAwB,CANxB,4BAA6B,CAjB7B,cAAe,CAcf,iBAAkB,CAHlB,aAAc,CAJd,4CAA6C,CAD7C,2CAA4C,CAJ5C,8BAA+B,CAC/B,iBAAkB,CAiBlB,4DAA8D,CAnB9D,qBAAsB,CAFtB,kBAuID,CA7GC,oFGhCA,2BAA2B,CCF3B,2CAA8B,CDC9B,YHqCA,CAIC,kJAEC,aACD,CAGD,iEAIC,aAAc,CACd,cAAe,CAHf,iBAAkB,CAClB,mBAAoB,CAMpB,qBASD,CAlBA,qFAYE,eAMF,CAlBA,qFAgBE,gBAEF,CAEA,yEACC,aAYD,CAbA,6FAIE,mCASF,CAbA,6FAQE,oCAKF,CAbA,yEAWC,eAAiB,CACjB,UACD,CAIC,oIIrFD,oDJyFC,CAOA,gLKhGD,kCLkGC,CAEA,iGACC,UACD,CAGD,qEACC,yDAcD,CAXC,2HAEE,4CAA+C,CAC/C,oCAOF,CAVA,2HAQE,mCAAoC,CADpC,6CAGF,CAKA,mHACC,WACD,CAID,yCC/HA,+CDmIA,CChIC,yFACC,qDACD,CAEA,2FACC,sDACD,CAID,iEACC,wDACD,CDgHA,yCAGC,qCACD,CAEA,2DACC,iCACD,CAEA,+DACC,mCACD,CAID,2CC/IC,mDDoJD,CCjJE,2FACC,yDACD,CAEA,6FACC,0DACD,CAID,mEACC,4DACD,CDgID,2CAIC,wCACD,CAEA,uCAEC,eACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-button,\na.ck.ck-button {\n	@mixin ck-unselectable;\n\n	position: relative;\n	display: inline-flex;\n	align-items: center;\n	justify-content: left;\n\n	& .ck-button__label {\n		display: none;\n	}\n\n	&.ck-button_with-text {\n		& .ck-button__label {\n			display: inline-block;\n		}\n	}\n\n	/* Center the icon horizontally in a button without text. */\n	&:not(.ck-button_with-text)  {\n		justify-content: center;\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_focus.css";
@import "../../../mixins/_shadow.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../mixins/_button.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-button,
a.ck.ck-button {
	@mixin ck-button-colors --ck-color-button-default;
	@mixin ck-rounded-corners;

	white-space: nowrap;
	cursor: default;
	vertical-align: middle;
	padding: var(--ck-spacing-tiny);
	text-align: center;

	/* A very important piece of styling. Go to variable declaration to learn more. */
	min-width: var(--ck-ui-component-min-height);
	min-height: var(--ck-ui-component-min-height);

	/* Normalize the height of the line. Removing this will break consistent height
	among text and text-less buttons (with icons). */
	line-height: 1;

	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	/* Avoid flickering when the foucs border shows up. */
	border: 1px solid transparent;

	/* Apply some smooth transition to the box-shadow and border. */
	transition: box-shadow .2s ease-in-out, border .2s ease-in-out;

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/189 */
	-webkit-appearance: none;

	&:active,
	&:focus {
		@mixin ck-focus-ring;
		@mixin ck-box-shadow var(--ck-focus-outer-shadow);
	}

	/* Allow icon coloring using the text "color" property. */
	& .ck-button__icon {
		& use,
		& use * {
			color: inherit;
		}
	}

	& .ck-button__label {
		/* Enable font size inheritance, which allows fluid UI scaling. */
		font-size: inherit;
		font-weight: inherit;
		color: inherit;
		cursor: inherit;

		/* Must be consistent with .ck-icon's vertical align. Otherwise, buttons with and
		without labels (but with icons) have different sizes in Chrome */
		vertical-align: middle;

		@mixin ck-dir ltr {
			text-align: left;
		}

		@mixin ck-dir rtl {
			text-align: right;
		}
	}

	& .ck-button__keystroke {
		color: inherit;

		@mixin ck-dir ltr {
			margin-left: var(--ck-spacing-large);
		}

		@mixin ck-dir rtl {
			margin-right: var(--ck-spacing-large);
		}

		font-weight: bold;
		opacity: .7;
	}

	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
	&.ck-disabled {
		&:active,
		&:focus {
			/* The disabled button should have a slightly less visible shadow when focused. */
			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);
		}

		& .ck-button__icon {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */
		& .ck-button__label {
			@mixin ck-disabled;
		}

		& .ck-button__keystroke {
			opacity: .3;
		}
	}

	&.ck-button_with-text {
		padding: var(--ck-spacing-tiny) var(--ck-spacing-standard);

		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__icon {
			@mixin ck-dir ltr {
				margin-left: calc(-1 * var(--ck-spacing-small));
				margin-right: var(--ck-spacing-small);
			}

			@mixin ck-dir rtl {
				margin-right: calc(-1 * var(--ck-spacing-small));
				margin-left: var(--ck-spacing-small);
			}
		}
	}

	&.ck-button_with-keystroke {
		/* stylelint-disable-next-line no-descending-specificity */
		& .ck-button__label {
			flex-grow: 1;
		}
	}

	/* A style of the button which is currently on, e.g. its feature is active. */
	&.ck-on {
		@mixin ck-button-colors --ck-color-button-on;

		color: var(--ck-color-button-on-color);
	}

	&.ck-button-save {
		color: var(--ck-color-button-save);
	}

	&.ck-button-cancel {
		color: var(--ck-color-button-cancel);
	}
}

/* A style of the button which handles the primary action. */
.ck.ck-button-action,
a.ck.ck-button-action {
	@mixin ck-button-colors --ck-color-button-action;

	color: var(--ck-color-button-action-text);
}

.ck.ck-button-bold,
a.ck.ck-button-bold {
	font-weight: bold;
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements a button of given background color.\n *\n * @param {String} $background - Background color of the button.\n * @param {String} $border - Border color of the button.\n */\n@define-mixin ck-button-colors $prefix {\n	background: var($(prefix)-background);\n\n	&:not(.ck-disabled) {\n		&:hover {\n			background: var($(prefix)-hover-background);\n		}\n\n		&:active {\n			background: var($(prefix)-active-background);\n		}\n	}\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/98 */\n	&.ck-disabled {\n		background: var($(prefix)-disabled-background);\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 5332: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{display:block}:root{--ck-switch-button-toggle-width:2.6153846154em;--ck-switch-button-toggle-inner-size:calc(1.07692em + 1px);--ck-switch-button-translation:calc(var(--ck-switch-button-toggle-width) - var(--ck-switch-button-toggle-inner-size) - 2px);--ck-switch-button-inner-hover-shadow:0 0 0 5px var(--ck-color-switch-button-inner-shadow)}.ck.ck-button.ck-switchbutton,.ck.ck-button.ck-switchbutton.ck-on:active,.ck.ck-button.ck-switchbutton.ck-on:focus,.ck.ck-button.ck-switchbutton.ck-on:hover,.ck.ck-button.ck-switchbutton:active,.ck.ck-button.ck-switchbutton:focus,.ck.ck-button.ck-switchbutton:hover{background:transparent;color:inherit}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__label{margin-right:calc(var(--ck-spacing-large)*2)}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__label{margin-left:calc(var(--ck-spacing-large)*2)}.ck.ck-button.ck-switchbutton .ck-button__toggle{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle,.ck.ck-button.ck-switchbutton .ck-button__toggle.ck-rounded-corners{border-radius:var(--ck-border-radius)}[dir=ltr] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-left:auto}[dir=rtl] .ck.ck-button.ck-switchbutton .ck-button__toggle{margin-right:auto}.ck.ck-button.ck-switchbutton .ck-button__toggle{background:var(--ck-color-switch-button-off-background);border:1px solid transparent;transition:background .4s ease,box-shadow .2s ease-in-out,outline .2s ease-in-out;width:var(--ck-switch-button-toggle-width)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{border-radius:0}.ck-rounded-corners .ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner,.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner.ck-rounded-corners{border-radius:var(--ck-border-radius);border-radius:calc(var(--ck-border-radius)*.5)}.ck.ck-button.ck-switchbutton .ck-button__toggle .ck-button__toggle__inner{background:var(--ck-color-switch-button-inner-background);height:var(--ck-switch-button-toggle-inner-size);transition:all .3s ease;width:var(--ck-switch-button-toggle-inner-size)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover{background:var(--ck-color-switch-button-off-hover-background)}.ck.ck-button.ck-switchbutton .ck-button__toggle:hover .ck-button__toggle__inner{box-shadow:var(--ck-switch-button-inner-hover-shadow)}.ck.ck-button.ck-switchbutton.ck-disabled .ck-button__toggle{opacity:var(--ck-disabled-opacity)}.ck.ck-button.ck-switchbutton:focus{border-color:transparent;box-shadow:none;outline:none}.ck.ck-button.ck-switchbutton:focus .ck-button__toggle{box-shadow:0 0 0 1px var(--ck-color-base-background),0 0 0 5px var(--ck-color-focus-outer-shadow);outline:var(--ck-focus-ring);outline-offset:1px}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle{background:var(--ck-color-switch-button-on-background)}.ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle:hover{background:var(--ck-color-switch-button-on-hover-background)}[dir=ltr] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(var( --ck-switch-button-translation ))}[dir=rtl] .ck.ck-button.ck-switchbutton.ck-on .ck-button__toggle .ck-button__toggle__inner{transform:translateX(calc(var( --ck-switch-button-translation )*-1))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/button/switchbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css"], names: [], mappings: "AASE,4HACC,aACD,CCCF,MAEC,8CAA+C,CAE/C,0DAAgE,CAChE,2HAIC,CACD,0FACD,CAOC,0QAEC,sBAAuB,CADvB,aAED,CAEA,0DAGE,4CAOF,CAVA,0DAQE,2CAEF,CAEA,iDCpCA,eD4EA,CAxCA,yIChCC,qCDwED,CAxCA,2DAKE,gBAmCF,CAxCA,2DAUE,iBA8BF,CAxCA,iDAkBC,uDAAwD,CAFxD,4BAA6B,CAD7B,iFAAsF,CAEtF,0CAuBD,CApBC,2ECxDD,eDmEC,CAXA,6LCpDA,qCAAsC,CDsDpC,8CASF,CAXA,2EAOC,yDAA0D,CAD1D,gDAAiD,CAIjD,uBAA0B,CAL1B,+CAMD,CAEA,uDACC,6DAKD,CAHC,iFACC,qDACD,CAIF,6DEhFA,kCFkFA,CAGA,oCACC,wBAAyB,CAEzB,eAAgB,CADhB,YAQD,CALC,uDACC,iGAAmG,CAEnG,4BAA6B,CAD7B,kBAED,CAKA,uDACC,sDAkBD,CAhBC,6DACC,4DACD,CAEA,2FAKE,2DAMF,CAXA,2FASE,oEAEF", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-button.ck-switchbutton {\n	& .ck-button__toggle {\n		display: block;\n\n		& .ck-button__toggle__inner {\n			display: block;\n		}\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n/* Note: To avoid rendering issues (aliasing) but to preserve the responsive nature\nof the component, floating–point numbers have been used which, for the default font size\n(see: --ck-font-size-base), will generate simple integers. */\n:root {\n	/* 34px at 13px font-size */\n	--ck-switch-button-toggle-width: 2.6153846154em;\n	/* 14px at 13px font-size */\n	--ck-switch-button-toggle-inner-size: calc(1.0769230769em + 1px);\n	--ck-switch-button-translation: calc(\n		var(--ck-switch-button-toggle-width) -\n		var(--ck-switch-button-toggle-inner-size) -\n		2px /* Border */\n	);\n	--ck-switch-button-inner-hover-shadow: 0 0 0 5px var(--ck-color-switch-button-inner-shadow);\n}\n\n.ck.ck-button.ck-switchbutton {\n	/* Unlike a regular button, the switch button text color and background should never change.\n	 * Changing toggle switch (background, outline) is enough to carry the information about the\n	 * state of the entire component (https://github.com/ckeditor/ckeditor5/issues/12519)\n	 */\n	&, &:hover, &:focus, &:active, &.ck-on:hover, &.ck-on:focus, &.ck-on:active {\n		color: inherit;\n		background: transparent;\n	}\n\n	& .ck-button__label {\n		@mixin ck-dir ltr {\n			/* Separate the label from the switch */\n			margin-right: calc(2 * var(--ck-spacing-large));\n		}\n\n		@mixin ck-dir rtl {\n			/* Separate the label from the switch */\n			margin-left: calc(2 * var(--ck-spacing-large));\n		}\n	}\n\n	& .ck-button__toggle {\n		@mixin ck-rounded-corners;\n\n		@mixin ck-dir ltr {\n			/* Make sure the toggle is always to the right as far as possible. */\n			margin-left: auto;\n		}\n\n		@mixin ck-dir rtl {\n			/* Make sure the toggle is always to the left as far as possible. */\n			margin-right: auto;\n		}\n\n		/* Apply some smooth transition to the box-shadow and border. */\n		/* Gently animate the background color of the toggle switch */\n		transition: background 400ms ease, box-shadow .2s ease-in-out, outline .2s ease-in-out;\n		border: 1px solid transparent;\n		width: var(--ck-switch-button-toggle-width);\n		background: var(--ck-color-switch-button-off-background);\n\n		& .ck-button__toggle__inner {\n			@mixin ck-rounded-corners {\n				border-radius: calc(.5 * var(--ck-border-radius));\n			}\n\n			width: var(--ck-switch-button-toggle-inner-size);\n			height: var(--ck-switch-button-toggle-inner-size);\n			background: var(--ck-color-switch-button-inner-background);\n\n			/* Gently animate the inner part of the toggle switch */\n			transition: all 300ms ease;\n		}\n\n		&:hover {\n			background: var(--ck-color-switch-button-off-hover-background);\n\n			& .ck-button__toggle__inner {\n				box-shadow: var(--ck-switch-button-inner-hover-shadow);\n			}\n		}\n	}\n\n	&.ck-disabled .ck-button__toggle {\n		@mixin ck-disabled;\n	}\n\n	/* Overriding default .ck-button:focus styles + an outline around the toogle */\n	&:focus {\n		border-color: transparent;\n		outline: none;\n		box-shadow: none;\n\n		& .ck-button__toggle {\n			box-shadow: 0 0 0 1px var(--ck-color-base-background), 0 0 0 5px var(--ck-color-focus-outer-shadow);\n			outline-offset: 1px;\n			outline: var(--ck-focus-ring);\n		}\n	}\n\n	/* stylelint-disable-next-line no-descending-specificity */\n	&.ck-on {\n		& .ck-button__toggle {\n			background: var(--ck-color-switch-button-on-background);\n\n			&:hover {\n				background: var(--ck-color-switch-button-on-hover-background);\n			}\n\n			& .ck-button__toggle__inner {\n				/*\n				* Move the toggle switch to the right. It will be animated.\n				*/\n				@mixin ck-dir ltr {\n					transform: translateX( var( --ck-switch-button-translation ) );\n				}\n\n				@mixin ck-dir rtl {\n					transform: translateX( calc( -1 * var( --ck-switch-button-translation ) ) );\n				}\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 6781: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-color-grid{display:grid}:root{--ck-color-grid-tile-size:24px;--ck-color-color-grid-check-icon:#166fd4}.ck.ck-color-grid{grid-gap:5px;padding:8px}.ck.ck-color-grid__tile{border:0;height:var(--ck-color-grid-tile-size);min-height:var(--ck-color-grid-tile-size);min-width:var(--ck-color-grid-tile-size);padding:0;transition:box-shadow .2s ease;width:var(--ck-color-grid-tile-size)}.ck.ck-color-grid__tile.ck-disabled{cursor:unset;transition:unset}.ck.ck-color-grid__tile.ck-color-selector__color-tile_bordered{box-shadow:0 0 0 1px var(--ck-color-base-border)}.ck.ck-color-grid__tile .ck.ck-icon{color:var(--ck-color-color-grid-check-icon);display:none}.ck.ck-color-grid__tile.ck-on{box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-base-text)}.ck.ck-color-grid__tile.ck-on .ck.ck-icon{display:block}.ck.ck-color-grid__tile.ck-on,.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){border:0}.ck.ck-color-grid__tile:focus:not(.ck-disabled),.ck.ck-color-grid__tile:hover:not(.ck-disabled){box-shadow:inset 0 0 0 1px var(--ck-color-base-background),0 0 0 2px var(--ck-color-focus-border)}.ck.ck-color-grid__label{padding:0 var(--ck-spacing-standard)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorgrid/colorgrid.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorgrid/colorgrid.css"], names: [], mappings: "AAKA,kBACC,YACD,CCAA,MACC,8BAA+B,CAK/B,wCACD,CAEA,kBACC,YAAa,CACb,WACD,CAEA,wBAOC,QAAS,CALT,qCAAsC,CAEtC,yCAA0C,CAD1C,wCAAyC,CAEzC,SAAU,CACV,8BAA+B,CAL/B,oCAyCD,CAjCC,oCACC,YAAa,CACb,gBACD,CAEA,+DACC,gDACD,CAEA,oCAEC,2CAA4C,CAD5C,YAED,CAEA,8BACC,8FAKD,CAHC,0CACC,aACD,CAGD,8HAIC,QACD,CAEA,gGAEC,iGACD,CAGD,yBACC,oCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-color-grid {\n	display: grid;\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-grid-tile-size: 24px;

	/* Not using global colors here because these may change but some colors in a pallette
	 * require special treatment. For instance, this ensures no matter what the UI text color is,
	 * the check icon will look good on the black color tile. */
	--ck-color-color-grid-check-icon: hsl(212, 81%, 46%);
}

.ck.ck-color-grid {
	grid-gap: 5px;
	padding: 8px;
}

.ck.ck-color-grid__tile {
	width: var(--ck-color-grid-tile-size);
	height: var(--ck-color-grid-tile-size);
	min-width: var(--ck-color-grid-tile-size);
	min-height: var(--ck-color-grid-tile-size);
	padding: 0;
	transition: .2s ease box-shadow;
	border: 0;

	&.ck-disabled {
		cursor: unset;
		transition: unset;
	}

	&.ck-color-selector__color-tile_bordered {
		box-shadow: 0 0 0 1px var(--ck-color-base-border);
	}

	& .ck.ck-icon {
		display: none;
		color: var(--ck-color-color-grid-check-icon);
	}

	&.ck-on {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-base-text);

		& .ck.ck-icon {
			display: block;
		}
	}

	&.ck-on,
	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		/* Disable the default .ck-button's border ring. */
		border: 0;
	}

	&:focus:not( .ck-disabled ),
	&:hover:not( .ck-disabled ) {
		box-shadow: inset 0 0 0 1px var(--ck-color-base-background), 0 0 0 2px var(--ck-color-focus-border);
	}
}

.ck.ck-color-grid__label {
	padding: 0 var(--ck-spacing-standard);
}
`], sourceRoot: "" }]);
      const a2 = s2;
    }, 3398: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".color-picker-hex-input{width:max-content}.color-picker-hex-input .ck.ck-input{min-width:unset}.ck.ck-color-picker__row{display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between;margin:var(--ck-spacing-large) 0 0;width:unset}.ck.ck-color-picker__row .ck.ck-labeled-field-view{padding-top:unset}.ck.ck-color-picker__row .ck.ck-input-text{width:unset}.ck.ck-color-picker__row .ck-color-picker__hash-view{padding-right:var(--ck-spacing-medium);padding-top:var(--ck-spacing-tiny)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorpicker/colorpicker.css"], names: [], mappings: "AAKA,wBACC,iBAKD,CAHC,qCACC,eACD,CAGD,yBACC,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CACjB,6BAA8B,CAC9B,kCAAmC,CACnC,WAcD,CAZC,mDACC,iBACD,CAEA,2CACC,WACD,CAEA,qDAEC,sCAAuC,CADvC,kCAED", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.color-picker-hex-input {\n	width: max-content;\n\n	& .ck.ck-input {\n		min-width: unset;\n	}\n}\n\n.ck.ck-color-picker__row {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	justify-content: space-between;\n	margin: var(--ck-spacing-large) 0 0;\n	width: unset;\n\n	& .ck.ck-labeled-field-view {\n		padding-top: unset;\n	}\n\n	& .ck.ck-input-text {\n		width: unset;\n	}\n\n	& .ck-color-picker__hash-view {\n		padding-top: var(--ck-spacing-tiny);\n		padding-right: var(--ck-spacing-medium);\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4157: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{align-items:center;display:flex}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{justify-content:flex-start}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{display:flex;flex-direction:row;justify-content:space-around}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-cancel,.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar .ck-button-save{flex:1}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker,.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__remove-color{width:100%}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker{border-bottom-left-radius:0;border-bottom-right-radius:0;padding:calc(var(--ck-spacing-standard)/2) var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker:not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-color-selector .ck-color-grids-fragment .ck-button.ck-color-selector__color-picker .ck.ck-icon{margin-left:var(--ck-spacing-standard)}.ck.ck-color-selector .ck-color-grids-fragment label.ck.ck-color-grid__label{font-weight:unset}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker{padding:8px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker{height:100px;min-width:180px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation){border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue){border-radius:0 0 var(--ck-border-radius) var(--ck-border-radius)}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(hue-pointer),.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-picker .hex-color-picker::part(saturation-pointer){height:15px;width:15px}.ck.ck-color-selector .ck-color-picker-fragment .ck.ck-color-selector_action-bar{padding:0 8px 8px}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/colorselector/colorselector.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/colorselector/colorselector.css"], names: [], mappings: "AAUE,oLAGC,kBAAmB,CADnB,YAMD,CARA,wMAME,0BAEF,CAKA,iFACC,YAAa,CACb,kBAAmB,CACnB,4BAMD,CAJC,oMAEC,MACD,CCrBD,oLAEC,UACD,CAEA,0FAEC,2BAA4B,CAC5B,4BAA6B,CAF7B,qEAiBD,CAbC,sGACC,gDACD,CAEA,gHAEE,uCAMF,CARA,gHAME,sCAEF,CAGD,6EACC,iBACD,CAKA,oEACC,WAoBD,CAlBC,sFACC,YAAa,CACb,eAeD,CAbC,wGACC,iEACD,CAEA,iGACC,iEACD,CAEA,yNAGC,WAAY,CADZ,UAED,CAIF,iFACC,iBACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n	/* View fragment with color grids. */\n	& .ck-color-grids-fragment {\n		& .ck-button.ck-color-selector__remove-color,\n		& .ck-button.ck-color-selector__color-picker {\n			display: flex;\n			align-items: center;\n\n			@mixin ck-dir rtl {\n				justify-content: flex-start;\n			}\n		}\n	}\n\n	/* View fragment with a color picker. */\n	& .ck-color-picker-fragment {\n		& .ck.ck-color-selector_action-bar {\n			display: flex;\n			flex-direction: row;\n			justify-content: space-around;\n\n			& .ck-button-save,\n			& .ck-button-cancel {\n				flex: 1\n			}\n		}\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-color-selector {\n	/* View fragment with color grids. */\n	& .ck-color-grids-fragment {\n		& .ck-button.ck-color-selector__remove-color,\n		& .ck-button.ck-color-selector__color-picker {\n			width: 100%;\n		}\n\n		& .ck-button.ck-color-selector__color-picker {\n			padding: calc(var(--ck-spacing-standard) / 2) var(--ck-spacing-standard);\n			border-bottom-left-radius: 0;\n			border-bottom-right-radius: 0;\n\n			&:not(:focus) {\n				border-top: 1px solid var(--ck-color-base-border);\n			}\n\n			& .ck.ck-icon {\n				@mixin ck-dir ltr {\n					margin-right: var(--ck-spacing-standard);\n				}\n\n				@mixin ck-dir rtl {\n					margin-left: var(--ck-spacing-standard);\n				}\n			}\n		}\n\n		& label.ck.ck-color-grid__label {\n			font-weight: unset;\n		}\n	}\n\n	/* View fragment with a color picker. */\n	& .ck-color-picker-fragment {\n		& .ck.ck-color-picker {\n			padding: 8px;\n\n			& .hex-color-picker {\n				height: 100px;\n				min-width: 180px;\n\n				&::part(saturation) {\n					border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n				}\n\n				&::part(hue) {\n					border-radius: 0 0 var(--ck-border-radius) var(--ck-border-radius);\n				}\n\n				&::part(saturation-pointer),\n				&::part(hue-pointer) {\n					width: 15px;\n					height: 15px;\n				}\n			}\n		}\n\n		& .ck.ck-color-selector_action-bar {\n			padding: 0 8px 8px;\n		}\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 5485: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-dropdown-max-width:75vw}.ck.ck-dropdown{display:inline-block;position:relative}.ck.ck-dropdown .ck-dropdown__arrow{pointer-events:none;z-index:var(--ck-z-default)}.ck.ck-dropdown .ck-button.ck-dropdown__button{width:100%}.ck.ck-dropdown .ck-dropdown__panel{display:none;max-width:var(--ck-dropdown-max-width);position:absolute;z-index:var(--ck-z-modal)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel-visible{display:inline-block}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw{bottom:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{bottom:auto;top:100%}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_ne,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_se{left:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sw{right:0}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_n,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_s{left:50%;transform:translateX(-50%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nmw,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_smw{left:75%;transform:translateX(-75%)}.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_nme,.ck.ck-dropdown .ck-dropdown__panel.ck-dropdown__panel_sme{left:25%;transform:translateX(-25%)}.ck.ck-toolbar .ck-dropdown__panel{z-index:calc(var(--ck-z-modal) + 1)}:root{--ck-dropdown-arrow-size:calc(var(--ck-icon-size)*0.5)}.ck.ck-dropdown{font-size:inherit}.ck.ck-dropdown .ck-dropdown__arrow{width:var(--ck-dropdown-arrow-size)}[dir=ltr] .ck.ck-dropdown .ck-dropdown__arrow{margin-left:var(--ck-spacing-standard);right:var(--ck-spacing-standard)}[dir=rtl] .ck.ck-dropdown .ck-dropdown__arrow{left:var(--ck-spacing-standard);margin-right:var(--ck-spacing-small)}.ck.ck-dropdown.ck-disabled .ck-dropdown__arrow{opacity:var(--ck-disabled-opacity)}[dir=ltr] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-left:var(--ck-spacing-small)}[dir=rtl] .ck.ck-dropdown .ck-button.ck-dropdown__button:not(.ck-button_with-text){padding-right:var(--ck-spacing-small)}.ck.ck-dropdown .ck-button.ck-dropdown__button .ck-button__label{overflow:hidden;text-overflow:ellipsis;width:7em}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-disabled .ck-button__label{opacity:var(--ck-disabled-opacity)}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on{border-bottom-left-radius:0;border-bottom-right-radius:0}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-dropdown__button_label-width_auto .ck-button__label{width:auto}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active{box-shadow:none}.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-off:active:focus,.ck.ck-dropdown .ck-button.ck-dropdown__button.ck-on:active:focus{box-shadow:var(--ck-focus-outer-shadow),0 0}.ck.ck-dropdown__panel{border-radius:0}.ck-rounded-corners .ck.ck-dropdown__panel,.ck.ck-dropdown__panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-dropdown__panel{background:var(--ck-color-dropdown-panel-background);border:1px solid var(--ck-color-dropdown-panel-border);bottom:0;box-shadow:var(--ck-drop-shadow),0 0;min-width:100%}.ck.ck-dropdown__panel.ck-dropdown__panel_se{border-top-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_sw{border-top-right-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_ne{border-bottom-left-radius:0}.ck.ck-dropdown__panel.ck-dropdown__panel_nw{border-bottom-right-radius:0}.ck.ck-dropdown__panel:focus{outline:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/dropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,MACC,4BACD,CAEA,gBACC,oBAAqB,CACrB,iBA2ED,CAzEC,oCACC,mBAAoB,CACpB,2BACD,CAGA,+CACC,UACD,CAEA,oCACC,YAAa,CAEb,sCAAuC,CAEvC,iBAAkB,CAHlB,yBA4DD,CAvDC,+DACC,oBACD,CAEA,mSAKC,WACD,CAEA,mSAUC,WAAY,CADZ,QAED,CAEA,oHAEC,MACD,CAEA,oHAEC,OACD,CAEA,kHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAEA,sHAGC,QAAS,CACT,0BACD,CAQF,mCACC,mCACD,CCpFA,MACC,sDACD,CAEA,gBAEC,iBA2ED,CAzEC,oCACC,mCACD,CAGC,8CAIC,sCAAuC,CAHvC,gCAID,CAIA,8CACC,+BAAgC,CAGhC,oCACD,CAGD,gDC/BA,kCDiCA,CAIE,mFAEC,oCACD,CAIA,mFAEC,qCACD,CAID,iEAEC,eAAgB,CAChB,sBAAuB,CAFvB,SAGD,CAGA,6EC1DD,kCD4DC,CAGA,qDACC,2BAA4B,CAC5B,4BACD,CAEA,sGACC,UACD,CAGA,yHAEC,eAKD,CAHC,qIE7EF,2CF+EE,CAKH,uBGlFC,eHkHD,CAhCA,qFG9EE,qCH8GF,CAhCA,uBAIC,oDAAqD,CACrD,sDAAuD,CACvD,QAAS,CE1FT,oCAA8B,CF6F9B,cAuBD,CAnBC,6CACC,wBACD,CAEA,6CACC,yBACD,CAEA,6CACC,2BACD,CAEA,6CACC,4BACD,CAEA,6BACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-dropdown-max-width: 75vw;\n}\n\n.ck.ck-dropdown {\n	display: inline-block;\n	position: relative;\n\n	& .ck-dropdown__arrow {\n		pointer-events: none;\n		z-index: var(--ck-z-default);\n	}\n\n	/* Dropdown button should span horizontally, e.g. in vertical toolbars */\n	& .ck-button.ck-dropdown__button {\n		width: 100%;\n	}\n\n	& .ck-dropdown__panel {\n		display: none;\n		z-index: var(--ck-z-modal);\n		max-width: var(--ck-dropdown-max-width);\n\n		position: absolute;\n\n		&.ck-dropdown__panel-visible {\n			display: inline-block;\n		}\n\n		&.ck-dropdown__panel_ne,\n		&.ck-dropdown__panel_nw,\n		&.ck-dropdown__panel_n,\n		&.ck-dropdown__panel_nmw,\n		&.ck-dropdown__panel_nme {\n			bottom: 100%;\n		}\n\n		&.ck-dropdown__panel_se,\n		&.ck-dropdown__panel_sw,\n		&.ck-dropdown__panel_smw,\n		&.ck-dropdown__panel_sme,\n		&.ck-dropdown__panel_s {\n			/*\n			 * Using transform: translate3d( 0, 100%, 0 ) causes blurry dropdown on Chrome 67-78+ on non-retina displays.\n			 * See https://github.com/ckeditor/ckeditor5/issues/1053.\n			 */\n			top: 100%;\n			bottom: auto;\n		}\n\n		&.ck-dropdown__panel_ne,\n		&.ck-dropdown__panel_se {\n			left: 0px;\n		}\n\n		&.ck-dropdown__panel_nw,\n		&.ck-dropdown__panel_sw {\n			right: 0px;\n		}\n\n		&.ck-dropdown__panel_s,\n		&.ck-dropdown__panel_n {\n			/* Positioning panels relative to the center of the button */\n			left: 50%;\n			transform: translateX(-50%);\n		}\n\n		&.ck-dropdown__panel_nmw,\n		&.ck-dropdown__panel_smw {\n			/* Positioning panels relative to the middle-west of the button */\n			left: 75%;\n			transform: translateX(-75%);\n		}\n\n		&.ck-dropdown__panel_nme,\n		&.ck-dropdown__panel_sme {\n			/* Positioning panels relative to the middle-east of the button */\n			left: 25%;\n			transform: translateX(-25%);\n		}\n	}\n}\n\n/*\n * Toolbar dropdown panels should be always above the UI (eg. other dropdown panels) from the editor's content.\n * See https://github.com/ckeditor/ckeditor5/issues/7874\n */\n.ck.ck-toolbar .ck-dropdown__panel {\n	z-index: calc( var(--ck-z-modal) + 1 );\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "../../../mixins/_disabled.css";
@import "../../../mixins/_shadow.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

:root {
	--ck-dropdown-arrow-size: calc(0.5 * var(--ck-icon-size));
}

.ck.ck-dropdown {
	/* Enable font size inheritance, which allows fluid UI scaling. */
	font-size: inherit;

	& .ck-dropdown__arrow {
		width: var(--ck-dropdown-arrow-size);
	}

	@mixin ck-dir ltr {
		& .ck-dropdown__arrow {
			right: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-left: var(--ck-spacing-standard);
		}
	}

	@mixin ck-dir rtl {
		& .ck-dropdown__arrow {
			left: var(--ck-spacing-standard);

			/* A space to accommodate the triangle. */
			margin-right: var(--ck-spacing-small);
		}
	}

	&.ck-disabled .ck-dropdown__arrow {
		@mixin ck-disabled;
	}

	& .ck-button.ck-dropdown__button {
		@mixin ck-dir ltr {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-left: var(--ck-spacing-small);
			}
		}

		@mixin ck-dir rtl {
			&:not(.ck-button_with-text) {
				/* Make sure dropdowns with just an icon have the right inner spacing */
				padding-right: var(--ck-spacing-small);
			}
		}

		/* #23 */
		& .ck-button__label {
			width: 7em;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/70 */
		&.ck-disabled .ck-button__label {
			@mixin ck-disabled;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/816 */
		&.ck-on {
			border-bottom-left-radius: 0;
			border-bottom-right-radius: 0;
		}

		&.ck-dropdown__button_label-width_auto .ck-button__label {
			width: auto;
		}

		/* https://github.com/ckeditor/ckeditor5/issues/8699 */
		&.ck-off:active,
		&.ck-on:active {
			box-shadow: none;

			&:focus {
				@mixin ck-box-shadow var(--ck-focus-outer-shadow);
			}
		}
	}
}

.ck.ck-dropdown__panel {
	@mixin ck-rounded-corners;
	@mixin ck-drop-shadow;

	background: var(--ck-color-dropdown-panel-background);
	border: 1px solid var(--ck-color-dropdown-panel-border);
	bottom: 0;

	/* Make sure the panel is at least as wide as the drop-down's button. */
	min-width: 100%;

	/* Disabled corner border radius to be consistent with the .dropdown__button
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-dropdown__panel_se {
		border-top-left-radius: 0;
	}

	&.ck-dropdown__panel_sw {
		border-top-right-radius: 0;
	}

	&.ck-dropdown__panel_ne {
		border-bottom-left-radius: 0;
	}

	&.ck-dropdown__panel_nw {
		border-bottom-right-radius: 0;
	}

	&:focus {
		outline: none;
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which indicates that an element holding it is disabled.\n */\n@define-mixin ck-disabled {\n	opacity: var(--ck-disabled-opacity);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3949: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-dropdown .ck-dropdown__panel .ck-list{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list,.ck.ck-dropdown .ck-dropdown__panel .ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:first-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-bottom-left-radius:0;border-bottom-right-radius:0;border-top-left-radius:0}.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button{border-radius:0}.ck-rounded-corners .ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button,.ck.ck-dropdown .ck-dropdown__panel .ck-list .ck-list__item:last-child .ck-button.ck-rounded-corners{border-radius:var(--ck-border-radius);border-top-left-radius:0;border-top-right-radius:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/listdropdown.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,6CCIC,eDqBD,CAzBA,iICQE,qCAAsC,CDJtC,wBAqBF,CAfE,mFCND,eDYC,CANA,6MCFA,qCAAsC,CDKpC,2BAA4B,CAC5B,4BAA6B,CAF7B,wBAIF,CAEA,kFCdD,eDmBC,CALA,2MCVA,qCAAsC,CDYpC,wBAAyB,CACzB,yBAEF", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-dropdown .ck-dropdown__panel .ck-list {\n	/* Disabled radius of top-left border to be consistent with .dropdown__button\n	https://github.com/ckeditor/ckeditor5/issues/816 */\n	@mixin ck-rounded-corners {\n		border-top-left-radius: 0;\n	}\n\n	/* Make sure the button belonging to the first/last child of the list goes well with the\n	border radius of the entire panel. */\n	& .ck-list__item {\n		&:first-child .ck-button {\n			@mixin ck-rounded-corners {\n				border-top-left-radius: 0;\n				border-bottom-left-radius: 0;\n				border-bottom-right-radius: 0;\n			}\n		}\n\n		&:last-child .ck-button {\n			@mixin ck-rounded-corners {\n				border-top-left-radius: 0;\n				border-top-right-radius: 0;\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 7686: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck.ck-splitbutton{font-size:inherit}.ck.ck-splitbutton .ck-splitbutton__action:focus{z-index:calc(var(--ck-z-default) + 1)}:root{--ck-color-split-button-hover-background:#ebebeb;--ck-color-split-button-hover-border:#b3b3b3}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-right-radius:unset;border-top-right-radius:unset}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__action{border-bottom-left-radius:unset;border-top-left-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow{min-width:unset}[dir=ltr] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-left-radius:unset;border-top-left-radius:unset}[dir=rtl] .ck.ck-splitbutton>.ck-splitbutton__arrow{border-bottom-right-radius:unset;border-top-right-radius:unset}.ck.ck-splitbutton>.ck-splitbutton__arrow svg{width:var(--ck-dropdown-arrow-size)}.ck.ck-splitbutton>.ck-splitbutton__arrow:not(:focus){border-bottom-width:0;border-top-width:0}.ck.ck-splitbutton.ck-splitbutton_open>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover),.ck.ck-splitbutton:hover>.ck-button:not(.ck-on):not(.ck-disabled):not(:hover){background:var(--ck-color-split-button-hover-background)}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{background-color:var(--ck-color-split-button-hover-border);content:"";height:100%;position:absolute;width:1px}.ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:focus:after,.ck.ck-splitbutton:hover>.ck-splitbutton__arrow:focus:after{--ck-color-split-button-hover-border:var(--ck-color-focus-border)}[dir=ltr] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=ltr] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{left:-1px}[dir=rtl] .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow:not(.ck-disabled):after,[dir=rtl] .ck.ck-splitbutton:hover>.ck-splitbutton__arrow:not(.ck-disabled):after{right:-1px}.ck.ck-splitbutton.ck-splitbutton_open{border-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__action,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__action{border-bottom-left-radius:0}.ck-rounded-corners .ck.ck-splitbutton.ck-splitbutton_open>.ck-splitbutton__arrow,.ck.ck-splitbutton.ck-splitbutton_open.ck-rounded-corners>.ck-splitbutton__arrow{border-bottom-right-radius:0}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/splitbutton.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAKA,mBAEC,iBAKD,CAHC,iDACC,qCACD,CCJD,MACC,gDAAyD,CACzD,4CACD,CAMC,oIAKE,gCAAiC,CADjC,6BASF,CAbA,oIAWE,+BAAgC,CADhC,4BAGF,CAEA,0CAGC,eAiBD,CApBA,oDAQE,+BAAgC,CADhC,4BAaF,CApBA,oDAcE,gCAAiC,CADjC,6BAOF,CAHC,8CACC,mCACD,CAKD,sDAEC,qBAAwB,CADxB,kBAED,CAQC,0KACC,wDACD,CAIA,8JAKC,0DAA2D,CAJ3D,UAAW,CAGX,WAAY,CAFZ,iBAAkB,CAClB,SAGD,CAGA,sIACC,iEACD,CAGC,kLACC,SACD,CAIA,kLACC,UACD,CAMF,uCCzFA,eDmGA,CAVA,qHCrFC,qCD+FD,CARE,qKACC,2BACD,CAEA,mKACC,4BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-splitbutton {\n	/* Enable font size inheritance, which allows fluid UI scaling. */\n	font-size: inherit;\n\n	& .ck-splitbutton__action:focus {\n		z-index: calc(var(--ck-z-default) + 1);\n	}\n}\n\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";

:root {
	--ck-color-split-button-hover-background: hsl(0, 0%, 92%);
	--ck-color-split-button-hover-border: hsl(0, 0%, 70%);
}

.ck.ck-splitbutton {
	/*
	 * Note: ck-rounded and ck-dir mixins don't go together (because they both use @nest).
	 */
	&:hover > .ck-splitbutton__action,
	&.ck-splitbutton_open > .ck-splitbutton__action {
		@nest [dir="ltr"] & {
			/* Don't round the action button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the action button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}
	}

	& > .ck-splitbutton__arrow {
		/* It's a text-less button and since the icon is positioned absolutely in such situation,
		it must get some arbitrary min-width. */
		min-width: unset;

		@nest [dir="ltr"] & {
			/* Don't round the arrow button on the left side */
			border-top-left-radius: unset;
			border-bottom-left-radius: unset;
		}

		@nest [dir="rtl"] & {
			/* Don't round the arrow button on the right side */
			border-top-right-radius: unset;
			border-bottom-right-radius: unset;
		}

		& svg {
			width: var(--ck-dropdown-arrow-size);
		}
	}

	/* Make sure the divider stretches 100% height of the button
	https://github.com/ckeditor/ckeditor5/issues/10936 */
	& > .ck-splitbutton__arrow:not(:focus) {
		border-top-width: 0px;
		border-bottom-width: 0px;
	}

	/* When the split button is "open" (the arrow is on) or being hovered, it should get some styling
	as a whole. The background of both buttons should stand out and there should be a visual
	separation between both buttons. */
	&.ck-splitbutton_open,
	&:hover {
		/* When the split button hovered as a whole, not as individual buttons. */
		& > .ck-button:not(.ck-on):not(.ck-disabled):not(:hover) {
			background: var(--ck-color-split-button-hover-background);
		}

		/* Splitbutton separator needs to be set with the ::after pseudoselector
		to display properly the borders on focus */
		& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
			content: '';
			position: absolute;
			width: 1px;
			height: 100%;
			background-color: var(--ck-color-split-button-hover-border);
		}

		/* Make sure the divider between the buttons looks fine when the button is focused */
		& > .ck-splitbutton__arrow:focus::after {
			--ck-color-split-button-hover-border: var(--ck-color-focus-border);
		}

		@nest [dir="ltr"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				left: -1px;
			}
		}

		@nest [dir="rtl"] & {
			& > .ck-splitbutton__arrow:not(.ck-disabled)::after {
				right: -1px;
			}
		}
	}

	/* Don't round the bottom left and right corners of the buttons when "open"
	https://github.com/ckeditor/ckeditor5/issues/816 */
	&.ck-splitbutton_open {
		@mixin ck-rounded-corners {
			& > .ck-splitbutton__action {
				border-bottom-left-radius: 0;
			}

			& > .ck-splitbutton__arrow {
				border-bottom-right-radius: 0;
			}
		}
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 7339: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-toolbar-dropdown-max-width:60vw}.ck.ck-toolbar-dropdown>.ck-dropdown__panel{max-width:var(--ck-toolbar-dropdown-max-width);width:max-content}.ck.ck-toolbar-dropdown>.ck-dropdown__panel .ck-button:focus{z-index:calc(var(--ck-z-default) + 1)}.ck.ck-toolbar-dropdown .ck-toolbar{border:0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/dropdown/toolbardropdown.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/dropdown/toolbardropdown.css"], names: [], mappings: "AAKA,MACC,oCACD,CAEA,4CAGC,8CAA+C,CAD/C,iBAQD,CAJE,6DACC,qCACD,CCZF,oCACC,QACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-toolbar-dropdown-max-width: 60vw;\n}\n\n.ck.ck-toolbar-dropdown > .ck-dropdown__panel {\n	/* https://github.com/ckeditor/ckeditor5/issues/5586 */\n	width: max-content;\n	max-width: var(--ck-toolbar-dropdown-max-width);\n\n	& .ck-button {\n		&:focus {\n			z-index: calc(var(--ck-z-default) + 1);\n		}\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-toolbar-dropdown .ck-toolbar {\n	border: 0;\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 9688: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-color-editable-blur-selection:#d9d9d9}.ck.ck-editor__editable:not(.ck-editor__nested-editable){border-radius:0}.ck-rounded-corners .ck.ck-editor__editable:not(.ck-editor__nested-editable),.ck.ck-editor__editable.ck-rounded-corners:not(.ck-editor__nested-editable){border-radius:var(--ck-border-radius)}.ck.ck-editor__editable.ck-focused:not(.ck-editor__nested-editable){border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck.ck-editor__editable_inline{border:1px solid transparent;overflow:auto;padding:0 var(--ck-spacing-standard)}.ck.ck-editor__editable_inline[dir=ltr]{text-align:left}.ck.ck-editor__editable_inline[dir=rtl]{text-align:right}.ck.ck-editor__editable_inline>:first-child{margin-top:var(--ck-spacing-large)}.ck.ck-editor__editable_inline>:last-child{margin-bottom:var(--ck-spacing-large)}.ck.ck-editor__editable_inline.ck-blurred ::selection{background:var(--ck-color-editable-blur-selection)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_n]:after{border-bottom-color:var(--ck-color-panel-background)}.ck.ck-balloon-panel.ck-toolbar-container[class*=arrow_s]:after{border-top-color:var(--ck-color-panel-background)}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/editorui/editorui.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAWA,MACC,0CACD,CAEA,yDCJC,eDWD,CAPA,yJCAE,qCDOF,CAJC,oEEPA,2BAA2B,CCF3B,qCAA8B,CDC9B,YFWA,CAGD,+BAGC,4BAA6B,CAF7B,aAAc,CACd,oCA6BD,CA1BC,wCACC,eACD,CAEA,wCACC,gBACD,CAGA,4CACC,kCACD,CAGA,2CAKC,qCACD,CAGA,sDACC,kDACD,CAKA,gEACC,oDACD,CAIA,gEACC,iDACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_disabled.css";\n@import "../../../mixins/_shadow.css";\n@import "../../../mixins/_focus.css";\n@import "../../mixins/_button.css";\n\n:root {\n	--ck-color-editable-blur-selection: hsl(0, 0%, 85%);\n}\n\n.ck.ck-editor__editable:not(.ck-editor__nested-editable) {\n	@mixin ck-rounded-corners;\n\n	&.ck-focused {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-inner-shadow);\n	}\n}\n\n.ck.ck-editor__editable_inline {\n	overflow: auto;\n	padding: 0 var(--ck-spacing-standard);\n	border: 1px solid transparent;\n\n	&[dir="ltr"] {\n		text-align: left;\n	}\n\n	&[dir="rtl"] {\n		text-align: right;\n	}\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/116 */\n	& > *:first-child {\n		margin-top: var(--ck-spacing-large);\n	}\n\n	/* https://github.com/ckeditor/ckeditor5/issues/847 */\n	& > *:last-child {\n		/*\n		 * This value should match with the default margins of the block elements (like .media or .image)\n		 * to avoid a content jumping when the fake selection container shows up (See https://github.com/ckeditor/ckeditor5/issues/9825).\n		 */\n		margin-bottom: var(--ck-spacing-large);\n	}\n\n	/* https://github.com/ckeditor/ckeditor5/issues/6517 */\n	&.ck-blurred ::selection {\n		background: var(--ck-color-editable-blur-selection);\n	}\n}\n\n/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/111 */\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_n"] {\n	&::after {\n		border-bottom-color: var(--ck-color-panel-background);\n	}\n}\n\n.ck.ck-balloon-panel.ck-toolbar-container[class*="arrow_s"] {\n	&::after {\n		border-top-color: var(--ck-color-panel-background);\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 8847: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-form__header{align-items:center;display:flex;flex-direction:row;flex-wrap:nowrap;justify-content:space-between}.ck.ck-form__header .ck-icon{margin-right:var(--ck-spacing-medium)}.ck.ck-form__header h2.ck-form__header__label{flex-grow:1}:root{--ck-form-header-height:38px}.ck.ck-form__header{border-bottom:1px solid var(--ck-color-base-border);height:var(--ck-form-header-height);line-height:var(--ck-form-header-height);padding:var(--ck-spacing-small) var(--ck-spacing-large)}.ck.ck-form__header .ck-form__header__label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/formheader/formheader.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/formheader/formheader.css"], names: [], mappings: "AAKA,oBAIC,kBAAmB,CAHnB,YAAa,CACb,kBAAmB,CACnB,gBAAiB,CAEjB,6BASD,CAPC,6BACC,qCACD,CAEA,8CACC,WACD,CCbD,MACC,4BACD,CAEA,oBAIC,mDAAoD,CAFpD,mCAAoC,CACpC,wCAAyC,CAFzC,uDAQD,CAHC,4CACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-form__header {\n	display: flex;\n	flex-direction: row;\n	flex-wrap: nowrap;\n	align-items: center;\n	justify-content: space-between;\n\n	& .ck-icon {\n		margin-right: var(--ck-spacing-medium);\n	}\n\n	& h2.ck-form__header__label {\n		flex-grow: 1;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-form-header-height: 38px;\n}\n\n.ck.ck-form__header {\n	padding: var(--ck-spacing-small) var(--ck-spacing-large);\n	height: var(--ck-form-header-height);\n	line-height: var(--ck-form-header-height);\n	border-bottom: 1px solid var(--ck-color-base-border);\n\n	& .ck-form__header__label {\n		font-weight: bold;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 8960: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-highlighted-text mark{background:var(--ck-color-highlight-background);font-size:inherit;font-weight:inherit;line-height:inherit;vertical-align:initial}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/highlightedtext/highlightedtext.css"], names: [], mappings: "AAKA,6BACC,+CAAgD,CAIhD,iBAAkB,CAFlB,mBAAoB,CACpB,mBAAoB,CAFpB,sBAID", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-highlighted-text mark {\n	background: var(--ck-color-highlight-background);\n	vertical-align: initial;\n	font-weight: inherit;\n	line-height: inherit;\n	font-size: inherit;\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 6574: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-icon{vertical-align:middle}:root{--ck-icon-size:calc(var(--ck-line-height-base)*var(--ck-font-size-normal))}.ck.ck-icon{font-size:.8333350694em;height:var(--ck-icon-size);width:var(--ck-icon-size);will-change:transform}.ck.ck-icon,.ck.ck-icon *{cursor:inherit}.ck.ck-icon.ck-icon_inherit-color,.ck.ck-icon.ck-icon_inherit-color *{color:inherit}.ck.ck-icon.ck-icon_inherit-color :not([fill]){fill:currentColor}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/icon/icon.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/icon/icon.css"], names: [], mappings: "AAKA,YACC,qBACD,CCFA,MACC,0EACD,CAEA,YAKC,uBAAwB,CAHxB,0BAA2B,CAD3B,yBAA0B,CAU1B,qBAoBD,CAlBC,0BALA,cAQA,CAMC,sEACC,aAMD,CAJC,+CAEC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-icon {\n	vertical-align: middle;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-icon-size: calc(var(--ck-line-height-base) * var(--ck-font-size-normal));\n}\n\n.ck.ck-icon {\n	width: var(--ck-icon-size);\n	height: var(--ck-icon-size);\n\n	/* Multiplied by the height of the line in "px" should give SVG "viewport" dimensions */\n	font-size: .8333350694em;\n\n	/* Inherit cursor style (#5). */\n	cursor: inherit;\n\n	/* This will prevent blurry icons on Firefox. See #340. */\n	will-change: transform;\n\n	& * {\n		/* Inherit cursor style (#5). */\n		cursor: inherit;\n	}\n\n	/* Allows dynamic coloring of an icon by inheriting its color from the parent. */\n	&.ck-icon_inherit-color {\n		color: inherit;\n\n		& * {\n			color: inherit;\n\n			&:not([fill]) {\n				/* Needed by FF. */\n				fill: currentColor;\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 4879: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-input-width:18em;--ck-input-text-width:var(--ck-input-width)}.ck.ck-input{border-radius:0}.ck-rounded-corners .ck.ck-input,.ck.ck-input.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-input{background:var(--ck-color-input-background);border:1px solid var(--ck-color-input-border);min-height:var(--ck-ui-component-min-height);min-width:var(--ck-input-width);padding:var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);transition:box-shadow .1s ease-in-out,border .1s ease-in-out}.ck.ck-input:focus{border:var(--ck-focus-ring);box-shadow:var(--ck-focus-outer-shadow),0 0;outline:none}.ck.ck-input[readonly]{background:var(--ck-color-input-disabled-background);border:1px solid var(--ck-color-input-disabled-border);color:var(--ck-color-input-disabled-text)}.ck.ck-input[readonly]:focus{box-shadow:var(--ck-focus-disabled-outer-shadow),0 0}.ck.ck-input.ck-error{animation:ck-input-shake .3s ease both;border-color:var(--ck-color-input-error-border)}.ck.ck-input.ck-error:focus{box-shadow:var(--ck-focus-error-outer-shadow),0 0}@keyframes ck-input-shake{20%{transform:translateX(-2px)}40%{transform:translateX(2px)}60%{transform:translateX(-1px)}80%{transform:translateX(1px)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/input/input.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AASA,MACC,qBAAsB,CAGtB,2CACD,CAEA,aCLC,eD2CD,CAtCA,iECDE,qCDuCF,CAtCA,aAGC,2CAA4C,CAC5C,6CAA8C,CAK9C,4CAA6C,CAH7C,+BAAgC,CADhC,6DAA8D,CAO9D,4DA0BD,CAxBC,mBEnBA,2BAA2B,CCF3B,2CAA8B,CDC9B,YFuBA,CAEA,uBAEC,oDAAqD,CADrD,sDAAuD,CAEvD,yCAMD,CAJC,6BG/BD,oDHkCC,CAGD,sBAEC,sCAAuC,CADvC,+CAMD,CAHC,4BGzCD,iDH2CC,CAIF,0BACC,IACC,0BACD,CAEA,IACC,yBACD,CAEA,IACC,0BACD,CAEA,IACC,yBACD,CACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_focus.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-input-width: 18em;\n\n	/* Backward compatibility. */\n	--ck-input-text-width: var(--ck-input-width);\n}\n\n.ck.ck-input {\n	@mixin ck-rounded-corners;\n\n	background: var(--ck-color-input-background);\n	border: 1px solid var(--ck-color-input-border);\n	padding: var(--ck-spacing-extra-tiny) var(--ck-spacing-medium);\n	min-width: var(--ck-input-width);\n\n	/* This is important to stay of the same height as surrounding buttons */\n	min-height: var(--ck-ui-component-min-height);\n\n	/* Apply some smooth transition to the box-shadow and border. */\n	transition: box-shadow .1s ease-in-out, border .1s ease-in-out;\n\n	&:focus {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-focus-outer-shadow);\n	}\n\n	&[readonly] {\n		border: 1px solid var(--ck-color-input-disabled-border);\n		background: var(--ck-color-input-disabled-background);\n		color: var(--ck-color-input-disabled-text);\n\n		&:focus {\n			/* The read-only input should have a slightly less visible shadow when focused. */\n			@mixin ck-box-shadow var(--ck-focus-disabled-outer-shadow);\n		}\n	}\n\n	&.ck-error {\n		border-color: var(--ck-color-input-error-border);\n		animation: ck-input-shake .3s ease both;\n\n		&:focus {\n			@mixin ck-box-shadow var(--ck-focus-error-outer-shadow);\n		}\n	}\n}\n\n@keyframes ck-input-shake {\n	20% {\n		transform: translateX(-2px);\n	}\n\n	40% {\n		transform: translateX(2px);\n	}\n\n	60% {\n		transform: translateX(-1px);\n	}\n\n	80% {\n		transform: translateX(1px);\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3662: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-label{display:block}.ck.ck-voice-label{display:none}.ck.ck-label{font-weight:700}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/label/label.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/label/label.css"], names: [], mappings: "AAKA,aACC,aACD,CAEA,mBACC,YACD,CCNA,aACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n	display: block;\n}\n\n.ck.ck-voice-label {\n	display: none;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-label {\n	font-weight: bold;\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 2577: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{display:flex;position:relative}.ck.ck-labeled-field-view .ck.ck-label{display:block;position:absolute}:root{--ck-labeled-field-view-transition:.1s cubic-bezier(0,0,0.24,0.95);--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-spacing-medium);--ck-labeled-field-label-default-position-x:var(--ck-spacing-medium);--ck-labeled-field-label-default-position-y:calc(var(--ck-font-size-base)*0.6);--ck-color-labeled-field-label-background:var(--ck-color-base-background)}.ck.ck-labeled-field-view{border-radius:0}.ck-rounded-corners .ck.ck-labeled-field-view,.ck.ck-labeled-field-view.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper{width:100%}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{top:0}[dir=ltr] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{left:0}[dir=rtl] .ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{right:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:var(--ck-color-labeled-field-label-background);font-weight:400;line-height:normal;max-width:100%;overflow:hidden;padding:0 calc(var(--ck-font-size-tiny)*.5);pointer-events:none;text-overflow:ellipsis;transform:translate(var(--ck-spacing-medium),-6px) scale(.75);transform-origin:0 0;transition:transform var(--ck-labeled-field-view-transition),padding var(--ck-labeled-field-view-transition),background var(--ck-labeled-field-view-transition)}.ck.ck-labeled-field-view.ck-error .ck-input:not([readonly])+.ck.ck-label,.ck.ck-labeled-field-view.ck-error>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view .ck-labeled-field-view__status{font-size:var(--ck-font-size-small);margin-top:var(--ck-spacing-small);white-space:normal}.ck.ck-labeled-field-view .ck-labeled-field-view__status.ck-labeled-field-view__status_error{color:var(--ck-color-base-error)}.ck.ck-labeled-field-view.ck-disabled>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{color:var(--ck-color-input-disabled-text)}[dir=ltr] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=ltr] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(var(--ck-labeled-field-label-default-position-x),var(--ck-labeled-field-label-default-position-y)) scale(1)}[dir=rtl] .ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,[dir=rtl] .ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{transform:translate(calc(var(--ck-labeled-field-label-default-position-x)*-1),var(--ck-labeled-field-label-default-position-y)) scale(1)}.ck.ck-labeled-field-view.ck-disabled.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label,.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck.ck-label{background:transparent;max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width));padding:0}.ck.ck-labeled-field-view>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck.ck-button{background:transparent}.ck.ck-labeled-field-view.ck-labeled-field-view_empty>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown>.ck-button>.ck-button__label{opacity:0}.ck.ck-labeled-field-view.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder)>.ck.ck-labeled-field-view__input-wrapper>.ck-dropdown+.ck-label{max-width:calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard))}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/labeledfield/labeledfieldview.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAMC,mEACC,YAAa,CACb,iBACD,CAEA,uCACC,aAAc,CACd,iBACD,CCND,MACC,kEAAsE,CACtE,gFAAiF,CACjF,oEAAqE,CACrE,8EAAiF,CACjF,yEACD,CAEA,0BCLC,eD8GD,CAzGA,2FCDE,qCD0GF,CAtGC,mEACC,UAmCD,CAjCC,gFACC,KA+BD,CAhCA,0FAIE,MA4BF,CAhCA,0FAQE,OAwBF,CAhCA,gFAiBC,yDAA0D,CAG1D,eAAmB,CADnB,kBAAoB,CAOpB,cAAe,CAFf,eAAgB,CANhB,2CAA8C,CAP9C,mBAAoB,CAYpB,sBAAuB,CARvB,6DAA+D,CAH/D,oBAAqB,CAgBrB,+JAID,CAQA,mKACC,gCACD,CAGD,yDACC,mCAAoC,CACpC,kCAAmC,CAInC,kBAKD,CAHC,6FACC,gCACD,CAID,4OAEC,yCACD,CAIA,oUAGE,+HAYF,CAfA,oUAOE,wIAQF,CAfA,gTAaC,sBAAuB,CAFvB,iEAAkE,CAGlE,SACD,CAKA,8FACC,sBACD,CAGA,yIACC,SACD,CAGA,kMACC,8HACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-labeled-field-view {\n	& > .ck.ck-labeled-field-view__input-wrapper {\n		display: flex;\n		position: relative;\n	}\n\n	& .ck.ck-label {\n		display: block;\n		position: absolute;\n	}\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";
@import "../../../mixins/_rounded.css";

:root {
	--ck-labeled-field-view-transition: .1s cubic-bezier(0, 0, 0.24, 0.95);
	--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-x: var(--ck-spacing-medium);
	--ck-labeled-field-label-default-position-y: calc(0.6 * var(--ck-font-size-base));
	--ck-color-labeled-field-label-background: var(--ck-color-base-background);
}

.ck.ck-labeled-field-view {
	@mixin ck-rounded-corners;

	& > .ck.ck-labeled-field-view__input-wrapper {
		width: 100%;

		& > .ck.ck-label {
			top: 0px;

			@mixin ck-dir ltr {
				left: 0px;
			}

			@mixin ck-dir rtl {
				right: 0px;
			}

			pointer-events: none;
			transform-origin: 0 0;

			/* By default, display the label scaled down above the field. */
			transform: translate(var(--ck-spacing-medium), -6px) scale(.75);

			background: var(--ck-color-labeled-field-label-background);
			padding: 0 calc(.5 * var(--ck-font-size-tiny));
			line-height: initial;
			font-weight: normal;

			/* Prevent overflow when the label is longer than the input */
			text-overflow: ellipsis;
			overflow: hidden;

			max-width: 100%;

			transition:
				transform var(--ck-labeled-field-view-transition),
				padding var(--ck-labeled-field-view-transition),
				background var(--ck-labeled-field-view-transition);
		}
	}

	&.ck-error {
		& > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
			color: var(--ck-color-base-error);
		}

		& .ck-input:not([readonly]) + .ck.ck-label {
			color: var(--ck-color-base-error);
		}
	}

	& .ck-labeled-field-view__status {
		font-size: var(--ck-font-size-small);
		margin-top: var(--ck-spacing-small);

		/* Let the info wrap to the next line to avoid stretching the layout horizontally.
		The status could be very long. */
		white-space: normal;

		&.ck-labeled-field-view__status_error {
			color: var(--ck-color-base-error);
		}
	}

	/* Disabled fields and fields that have no focus should fade out. */
	&.ck-disabled > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		color: var(--ck-color-input-disabled-text);
	}

	/* Fields that are disabled or not focused and without a placeholder should have full-sized labels. */
	/* stylelint-disable-next-line no-descending-specificity */
	&.ck-disabled.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label,
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck.ck-label {
		@mixin ck-dir ltr {
			transform: translate(var(--ck-labeled-field-label-default-position-x), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		@mixin ck-dir rtl {
			transform: translate(calc(-1 * var(--ck-labeled-field-label-default-position-x)), var(--ck-labeled-field-label-default-position-y)) scale(1);
		}

		/* Compensate for the default translate position. */
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width));

		background: transparent;
		padding: 0;
	}

	/*------ DropdownView integration ----------------------------------------------------------------------------------- */

	/* Make sure dropdown' background color in any of dropdown's state does not collide with labeled field. */
	& > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck.ck-button {
		background: transparent;
	}

	/* When the dropdown is "empty", the labeled field label replaces its label. */
	&.ck-labeled-field-view_empty > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown > .ck-button > .ck-button__label {
		opacity: 0;
	}

	/* Make sure the label of the empty, unfocused input does not cover the dropdown arrow. */
	&.ck-labeled-field-view_empty:not(.ck-labeled-field-view_focused):not(.ck-labeled-field-view_placeholder) > .ck.ck-labeled-field-view__input-wrapper > .ck-dropdown + .ck-label {
		max-width: calc(var(--ck-labeled-field-empty-unfocused-max-width) - var(--ck-dropdown-arrow-size) - var(--ck-spacing-standard));
	}
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 1046: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-list{display:flex;flex-direction:column;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-list .ck-list__item,.ck.ck-list .ck-list__separator{display:block}.ck.ck-list .ck-list__item>:focus{position:relative;z-index:var(--ck-z-default)}.ck.ck-list{border-radius:0}.ck-rounded-corners .ck.ck-list,.ck.ck-list.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-list{background:var(--ck-color-list-background);list-style-type:none}.ck.ck-list__item{cursor:default;min-width:12em}.ck.ck-list__item .ck-button{border-radius:0;min-height:unset;padding:calc(var(--ck-line-height-base)*.2*var(--ck-font-size-base)) calc(var(--ck-line-height-base)*.4*var(--ck-font-size-base));text-align:left;width:100%}.ck.ck-list__item .ck-button .ck-button__label{line-height:calc(var(--ck-line-height-base)*1.2*var(--ck-font-size-base))}.ck.ck-list__item .ck-button:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on{background:var(--ck-color-list-button-on-background);color:var(--ck-color-list-button-on-text)}.ck.ck-list__item .ck-button.ck-on:active{box-shadow:none}.ck.ck-list__item .ck-button.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-on-background-focus)}.ck.ck-list__item .ck-button.ck-on:focus:not(.ck-switchbutton):not(.ck-disabled){border-color:var(--ck-color-base-background)}.ck.ck-list__item .ck-button:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background)}.ck.ck-list__item .ck-switchbutton.ck-on{background:var(--ck-color-list-background);color:inherit}.ck.ck-list__item .ck-switchbutton.ck-on:hover:not(.ck-disabled){background:var(--ck-color-list-button-hover-background);color:inherit}.ck-list .ck-list__group{padding-top:var(--ck-spacing-medium);:not(.ck-hidden)~&{border-top:1px solid var(--ck-color-base-border)}}.ck-list .ck-list__group>span{font-size:11px;font-weight:700;padding:var(--ck-spacing-medium)}.ck.ck-list__separator{background:var(--ck-color-base-border);height:1px;width:100%}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/list/list.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/list/list.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,YAGC,YAAa,CACb,qBAAsB,CCFtB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBDaD,CAZC,2DAEC,aACD,CAKA,kCACC,iBAAkB,CAClB,2BACD,CEfD,YCEC,eDGD,CALA,+DCME,qCDDF,CALA,YAIC,0CAA2C,CAD3C,oBAED,CAEA,kBACC,cAAe,CACf,cA2DD,CAzDC,6BAIC,eAAgB,CAHhB,gBAAiB,CAQjB,iIAEiE,CARjE,eAAgB,CADhB,UAwCD,CA7BC,+CAEC,yEACD,CAEA,oCACC,eACD,CAEA,mCACC,oDAAqD,CACrD,yCAaD,CAXC,0CACC,eACD,CAEA,2DACC,0DACD,CAEA,iFACC,4CACD,CAGD,qDACC,uDACD,CAMA,yCACC,0CAA2C,CAC3C,aAMD,CAJC,iEACC,uDAAwD,CACxD,aACD,CAKH,yBACC,oCAAqC,CAGrC,mBACC,gDACD,CAOD,CALC,8BACC,cAAe,CACf,eAAiB,CACjB,gCACD,CAGD,uBAGC,sCAAuC,CAFvC,UAAW,CACX,UAED", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-list {\n	@mixin ck-unselectable;\n\n	display: flex;\n	flex-direction: column;\n\n	& .ck-list__item,\n	& .ck-list__separator {\n		display: block;\n	}\n\n	/* Make sure that whatever child of the list item gets focus, it remains on the\n	top. Thanks to that, styles like box-shadow, outline, etc. are not masked by\n	adjacent list items. */\n	& .ck-list__item > *:focus {\n		position: relative;\n		z-index: var(--ck-z-default);\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_disabled.css";
@import "../../../mixins/_rounded.css";
@import "../../../mixins/_shadow.css";

.ck.ck-list {
	@mixin ck-rounded-corners;

	list-style-type: none;
	background: var(--ck-color-list-background);
}

.ck.ck-list__item {
	cursor: default;
	min-width: 12em;

	& .ck-button {
		min-height: unset;
		width: 100%;
		text-align: left;
		border-radius: 0;

		/* List items should have the same height. Use absolute units to make sure it is so
		   because e.g. different heading styles may have different height
		   https://github.com/ckeditor/ckeditor5-heading/issues/63 */
		padding:
			calc(.2 * var(--ck-line-height-base) * var(--ck-font-size-base))
			calc(.4 * var(--ck-line-height-base) * var(--ck-font-size-base));

		& .ck-button__label {
			/* https://github.com/ckeditor/ckeditor5-heading/issues/63 */
			line-height: calc(1.2 * var(--ck-line-height-base) * var(--ck-font-size-base));
		}

		&:active {
			box-shadow: none;
		}

		&.ck-on {
			background: var(--ck-color-list-button-on-background);
			color: var(--ck-color-list-button-on-text);

			&:active {
				box-shadow: none;
			}

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-on-background-focus);
			}

			&:focus:not(.ck-switchbutton):not(.ck-disabled) {
				border-color: var(--ck-color-base-background);
			}
		}

		&:hover:not(.ck-disabled) {
			background: var(--ck-color-list-button-hover-background);
		}
	}

	/* It's unnecessary to change the background/text of a switch toggle; it has different ways
	of conveying its state (like the switcher) */
	& .ck-switchbutton {
		&.ck-on {
			background: var(--ck-color-list-background);
			color: inherit;

			&:hover:not(.ck-disabled) {
				background: var(--ck-color-list-button-hover-background);
				color: inherit;
			}
		}
	}
}

.ck-list .ck-list__group {
	padding-top: var(--ck-spacing-medium);

	/* The group should have a border when it's not the first item. */
	*:not(.ck-hidden) ~ & {
		border-top: 1px solid var(--ck-color-base-border);
	}

	& > span {
		font-size: 11px;
		font-weight: bold;
		padding: var(--ck-spacing-medium);
	}
}

.ck.ck-list__separator {
	height: 1px;
	width: 100%;
	background: var(--ck-color-base-border);
}
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 8793: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ':root{--ck-balloon-panel-arrow-z-index:calc(var(--ck-z-default) - 3)}.ck.ck-balloon-panel{display:none;position:absolute;z-index:var(--ck-z-modal)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{content:"";position:absolute}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_n]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_n]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel[class*=arrow_s]:before{z-index:var(--ck-balloon-panel-arrow-z-index)}.ck.ck-balloon-panel[class*=arrow_s]:after{z-index:calc(var(--ck-balloon-panel-arrow-z-index) + 1)}.ck.ck-balloon-panel.ck-balloon-panel_visible{display:block}:root{--ck-balloon-border-width:1px;--ck-balloon-arrow-offset:2px;--ck-balloon-arrow-height:10px;--ck-balloon-arrow-half-width:8px;--ck-balloon-arrow-drop-shadow:0 2px 2px var(--ck-color-shadow-drop)}.ck.ck-balloon-panel{border-radius:0}.ck-rounded-corners .ck.ck-balloon-panel,.ck.ck-balloon-panel.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-balloon-panel{background:var(--ck-color-panel-background);border:var(--ck-balloon-border-width) solid var(--ck-color-panel-border);box-shadow:var(--ck-drop-shadow),0 0;min-height:15px}.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:after,.ck.ck-balloon-panel.ck-balloon-panel_with-arrow:before{border-style:solid;height:0;width:0}.ck.ck-balloon-panel[class*=arrow_n]:after,.ck.ck-balloon-panel[class*=arrow_n]:before{border-width:0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_n]:before{border-color:transparent transparent var(--ck-color-panel-border) transparent;margin-top:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_n]:after{border-color:transparent transparent var(--ck-color-panel-background) transparent;margin-top:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_s]:after,.ck.ck-balloon-panel[class*=arrow_s]:before{border-width:var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width)}.ck.ck-balloon-panel[class*=arrow_s]:before{border-color:var(--ck-color-panel-border) transparent transparent;filter:drop-shadow(var(--ck-balloon-arrow-drop-shadow));margin-bottom:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_s]:after{border-color:var(--ck-color-panel-background) transparent transparent transparent;margin-bottom:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_e]:after,.ck.ck-balloon-panel[class*=arrow_e]:before{border-width:var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height)}.ck.ck-balloon-panel[class*=arrow_e]:before{border-color:transparent transparent transparent var(--ck-color-panel-border);margin-right:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_e]:after{border-color:transparent transparent transparent var(--ck-color-panel-background);margin-right:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel[class*=arrow_w]:after,.ck.ck-balloon-panel[class*=arrow_w]:before{border-width:var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0}.ck.ck-balloon-panel[class*=arrow_w]:before{border-color:transparent var(--ck-color-panel-border) transparent transparent;margin-left:calc(var(--ck-balloon-border-width)*-1)}.ck.ck-balloon-panel[class*=arrow_w]:after{border-color:transparent var(--ck-color-panel-background) transparent transparent;margin-left:calc(var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width))}.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_n:before{left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nw:before{left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_ne:before{right:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_s:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:50%;margin-left:calc(var(--ck-balloon-arrow-half-width)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_se:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);right:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_sme:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_smw:before{bottom:calc(var(--ck-balloon-arrow-height)*-1);left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nme:before{margin-right:calc(var(--ck-balloon-arrow-half-width)*2);right:25%;top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_nmw:before{left:25%;margin-left:calc(var(--ck-balloon-arrow-half-width)*2);top:calc(var(--ck-balloon-arrow-height)*-1)}.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_e:before{margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);right:calc(var(--ck-balloon-arrow-height)*-1);top:50%}.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:after,.ck.ck-balloon-panel.ck-balloon-panel_arrow_w:before{left:calc(var(--ck-balloon-arrow-height)*-1);margin-top:calc(var(--ck-balloon-arrow-half-width)*-1);top:50%}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonpanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MAEC,8DACD,CAEA,qBACC,YAAa,CACb,iBAAkB,CAElB,yBAyCD,CAtCE,+GAEC,UAAW,CACX,iBACD,CAEA,wDACC,6CACD,CAEA,uDACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAIA,4CACC,6CACD,CAEA,2CACC,uDACD,CAGD,8CACC,aACD,CC9CD,MACC,6BAA8B,CAC9B,6BAA8B,CAC9B,8BAA+B,CAC/B,iCAAkC,CAClC,oEACD,CAEA,qBCLC,eDmMD,CA9LA,iFCDE,qCD+LF,CA9LA,qBAMC,2CAA4C,CAC5C,wEAAyE,CEdzE,oCAA8B,CFW9B,eA0LD,CApLE,+GAIC,kBAAmB,CADnB,QAAS,CADT,OAGD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,kDACD,CAEA,2CACC,iFAAkF,CAClF,gFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,iEAAkE,CAClE,uDAAwD,CACxD,qDACD,CAEA,2CACC,iFAAkF,CAClF,mFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,oDACD,CAEA,2CACC,iFAAkF,CAClF,kFACD,CAIA,uFAEC,mHACD,CAEA,4CACC,6EAA8E,CAC9E,mDACD,CAEA,2CACC,iFAAkF,CAClF,iFACD,CAIA,yGAEC,QAAS,CACT,uDAA0D,CAC1D,2CACD,CAIA,2GAEC,+CAAkD,CAClD,2CACD,CAIA,2GAEC,gDAAmD,CACnD,2CACD,CAIA,yGAIC,8CAAiD,CAFjD,QAAS,CACT,uDAED,CAIA,2GAGC,8CAAiD,CADjD,+CAED,CAIA,2GAGC,8CAAiD,CADjD,gDAED,CAIA,6GAIC,8CAAiD,CADjD,uDAA0D,CAD1D,SAGD,CAIA,6GAIC,8CAAiD,CAFjD,QAAS,CACT,sDAED,CAIA,6GAGC,uDAA0D,CAD1D,SAAU,CAEV,2CACD,CAIA,6GAEC,QAAS,CACT,sDAAyD,CACzD,2CACD,CAIA,yGAGC,sDAAyD,CADzD,6CAAgD,CAEhD,OACD,CAIA,yGAEC,4CAA+C,CAC/C,sDAAyD,CACzD,OACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/* Make sure the balloon arrow does not float over its children. */\n	--ck-balloon-panel-arrow-z-index: calc(var(--ck-z-default) - 3);\n}\n\n.ck.ck-balloon-panel {\n	display: none;\n	position: absolute;\n\n	z-index: var(--ck-z-modal);\n\n	&.ck-balloon-panel_with-arrow {\n		&::before,\n		&::after {\n			content: "";\n			position: absolute;\n		}\n\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&[class*="arrow_n"] {\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&[class*="arrow_s"] {\n		&::before {\n			z-index: var(--ck-balloon-panel-arrow-z-index);\n		}\n\n		&::after {\n			z-index: calc(var(--ck-balloon-panel-arrow-z-index) + 1);\n		}\n	}\n\n	&.ck-balloon-panel_visible {\n		display: block;\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-balloon-border-width: 1px;\n	--ck-balloon-arrow-offset: 2px;\n	--ck-balloon-arrow-height: 10px;\n	--ck-balloon-arrow-half-width: 8px;\n	--ck-balloon-arrow-drop-shadow: 0 2px 2px var(--ck-color-shadow-drop);\n}\n\n.ck.ck-balloon-panel {\n	@mixin ck-rounded-corners;\n	@mixin ck-drop-shadow;\n\n	min-height: 15px;\n\n	background: var(--ck-color-panel-background);\n	border: var(--ck-balloon-border-width) solid var(--ck-color-panel-border);\n\n	&.ck-balloon-panel_with-arrow {\n		&::before,\n		&::after {\n			width: 0;\n			height: 0;\n			border-style: solid;\n		}\n	}\n\n	&[class*="arrow_n"] {\n		&::before,\n		&::after {\n			border-width: 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width);\n		}\n\n		&::before {\n			border-color: transparent transparent var(--ck-color-panel-border) transparent;\n			margin-top: calc( -1 * var(--ck-balloon-border-width) );\n		}\n\n		&::after {\n			border-color: transparent transparent var(--ck-color-panel-background) transparent;\n			margin-top: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n		}\n	}\n\n	&[class*="arrow_s"] {\n		&::before,\n		&::after {\n			border-width: var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width);\n		}\n\n		&::before {\n			border-color: var(--ck-color-panel-border) transparent transparent;\n			filter: drop-shadow(var(--ck-balloon-arrow-drop-shadow));\n			margin-bottom: calc( -1 * var(--ck-balloon-border-width) );\n		}\n\n		&::after {\n			border-color: var(--ck-color-panel-background) transparent transparent transparent;\n			margin-bottom: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n		}\n	}\n\n	&[class*="arrow_e"] {\n		&::before,\n		&::after {\n			border-width: var(--ck-balloon-arrow-half-width) 0 var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height);\n		}\n\n		&::before {\n			border-color: transparent transparent transparent var(--ck-color-panel-border);\n			margin-right: calc( -1 * var(--ck-balloon-border-width) );\n		}\n\n		&::after {\n			border-color: transparent transparent transparent var(--ck-color-panel-background);\n			margin-right: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n		}\n	}\n\n	&[class*="arrow_w"] {\n		&::before,\n		&::after {\n			border-width: var(--ck-balloon-arrow-half-width) var(--ck-balloon-arrow-height) var(--ck-balloon-arrow-half-width) 0;\n		}\n\n		&::before {\n			border-color: transparent var(--ck-color-panel-border) transparent transparent;\n			margin-left: calc( -1 * var(--ck-balloon-border-width) );\n		}\n\n		&::after {\n			border-color: transparent var(--ck-color-panel-background) transparent transparent;\n			margin-left: calc( var(--ck-balloon-arrow-offset) - var(--ck-balloon-border-width) );\n		}\n	}\n\n	&.ck-balloon-panel_arrow_n {\n		&::before,\n		&::after {\n			left: 50%;\n			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nw {\n		&::before,\n		&::after {\n			left: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_ne {\n		&::before,\n		&::after {\n			right: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_s {\n		&::before,\n		&::after {\n			left: 50%;\n			margin-left: calc(-1 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_sw {\n		&::before,\n		&::after {\n			left: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_se {\n		&::before,\n		&::after {\n			right: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_sme {\n		&::before,\n		&::after {\n			right: 25%;\n			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_smw {\n		&::before,\n		&::after {\n			left: 25%;\n			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n			bottom: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nme {\n		&::before,\n		&::after {\n			right: 25%;\n			margin-right: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_nmw {\n		&::before,\n		&::after {\n			left: 25%;\n			margin-left: calc(2 * var(--ck-balloon-arrow-half-width));\n			top: calc(-1 * var(--ck-balloon-arrow-height));\n		}\n	}\n\n	&.ck-balloon-panel_arrow_e {\n		&::before,\n		&::after {\n			right: calc(-1 * var(--ck-balloon-arrow-height));\n			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n			top: 50%;\n		}\n	}\n\n	&.ck-balloon-panel_arrow_w {\n		&::before,\n		&::after {\n			left: calc(-1 * var(--ck-balloon-arrow-height));\n			margin-top: calc(-1 * var(--ck-balloon-arrow-half-width));\n			top: 50%;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4650: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck .ck-balloon-rotator__navigation{align-items:center;display:flex;justify-content:center}.ck .ck-balloon-rotator__content .ck-toolbar{justify-content:center}.ck .ck-balloon-rotator__navigation{background:var(--ck-color-toolbar-background);border-bottom:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation>*{margin-bottom:var(--ck-spacing-small);margin-right:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck .ck-balloon-rotator__navigation .ck-balloon-rotator__counter{margin-left:var(--ck-spacing-small);margin-right:var(--ck-spacing-standard)}.ck .ck-balloon-rotator__content .ck.ck-annotation-wrapper{box-shadow:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/balloonrotator.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/balloonrotator.css"], names: [], mappings: "AAKA,oCAEC,kBAAmB,CADnB,YAAa,CAEb,sBACD,CAKA,6CACC,sBACD,CCXA,oCACC,6CAA8C,CAC9C,sDAAuD,CACvD,iCAgBD,CAbC,sCAGC,qCAAsC,CAFtC,oCAAqC,CACrC,kCAED,CAGA,iEAIC,mCAAoC,CAHpC,uCAID,CAMA,2DACC,eACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n	display: flex;\n	align-items: center;\n	justify-content: center;\n}\n\n/* Buttons inside a toolbar should be centered when rotator bar is wider.\n * See: https://github.com/ckeditor/ckeditor5-ui/issues/495\n */\n.ck .ck-balloon-rotator__content .ck-toolbar {\n	justify-content: center;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-balloon-rotator__navigation {\n	background: var(--ck-color-toolbar-background);\n	border-bottom: 1px solid var(--ck-color-toolbar-border);\n	padding: 0 var(--ck-spacing-small);\n\n	/* Let's keep similar appearance to `ck-toolbar`. */\n	& > * {\n		margin-right: var(--ck-spacing-small);\n		margin-top: var(--ck-spacing-small);\n		margin-bottom: var(--ck-spacing-small);\n	}\n\n	/* Gives counter more breath than buttons. */\n	& .ck-balloon-rotator__counter {\n		margin-right: var(--ck-spacing-standard);\n\n		/* We need to use smaller margin because of previous button's right margin. */\n		margin-left: var(--ck-spacing-small);\n	}\n}\n\n.ck .ck-balloon-rotator__content {\n\n	/* Disable default annotation shadow inside rotator with fake panels. */\n	& .ck.ck-annotation-wrapper {\n		box-shadow: none;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 7676: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck .ck-fake-panel{position:absolute;z-index:calc(var(--ck-z-modal) - 1)}.ck .ck-fake-panel div{position:absolute}.ck .ck-fake-panel div:first-child{z-index:2}.ck .ck-fake-panel div:nth-child(2){z-index:1}:root{--ck-balloon-fake-panel-offset-horizontal:6px;--ck-balloon-fake-panel-offset-vertical:6px}.ck .ck-fake-panel div{background:var(--ck-color-panel-background);border:1px solid var(--ck-color-panel-border);border-radius:var(--ck-border-radius);box-shadow:var(--ck-drop-shadow),0 0;height:100%;min-height:15px;width:100%}.ck .ck-fake-panel div:first-child{margin-left:var(--ck-balloon-fake-panel-offset-horizontal);margin-top:var(--ck-balloon-fake-panel-offset-vertical)}.ck .ck-fake-panel div:nth-child(2){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*2);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*2)}.ck .ck-fake-panel div:nth-child(3){margin-left:calc(var(--ck-balloon-fake-panel-offset-horizontal)*3);margin-top:calc(var(--ck-balloon-fake-panel-offset-vertical)*3)}.ck .ck-balloon-panel_arrow_s+.ck-fake-panel,.ck .ck-balloon-panel_arrow_se+.ck-fake-panel,.ck .ck-balloon-panel_arrow_sw+.ck-fake-panel{--ck-balloon-fake-panel-offset-vertical:-6px}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/fakepanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,mBACC,iBAAkB,CAGlB,mCACD,CAEA,uBACC,iBACD,CAEA,mCACC,SACD,CAEA,oCACC,SACD,CCfA,MACC,6CAA8C,CAC9C,2CACD,CAGA,uBAKC,2CAA4C,CAC5C,6CAA8C,CAC9C,qCAAsC,CCXtC,oCAA8B,CDc9B,WAAY,CAPZ,eAAgB,CAMhB,UAED,CAEA,mCACC,0DAA2D,CAC3D,uDACD,CAEA,oCACC,kEAAqE,CACrE,+DACD,CACA,oCACC,kEAAqE,CACrE,+DACD,CAGA,yIAGC,4CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-fake-panel {\n	position: absolute;\n\n	/* Fake panels should be placed under main balloon content. */\n	z-index: calc(var(--ck-z-modal) - 1);\n}\n\n.ck .ck-fake-panel div {\n	position: absolute;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n	z-index: 2;\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n	z-index: 1;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n:root {\n	--ck-balloon-fake-panel-offset-horizontal: 6px;\n	--ck-balloon-fake-panel-offset-vertical: 6px;\n}\n\n/* Let\'s use `.ck-balloon-panel` appearance. See: balloonpanel.css. */\n.ck .ck-fake-panel div {\n	@mixin ck-drop-shadow;\n\n	min-height: 15px;\n\n	background: var(--ck-color-panel-background);\n	border: 1px solid var(--ck-color-panel-border);\n	border-radius: var(--ck-border-radius);\n\n	width: 100%;\n	height: 100%;\n}\n\n.ck .ck-fake-panel div:nth-child( 1 ) {\n	margin-left: var(--ck-balloon-fake-panel-offset-horizontal);\n	margin-top: var(--ck-balloon-fake-panel-offset-vertical);\n}\n\n.ck .ck-fake-panel div:nth-child( 2 ) {\n	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 2);\n	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 2);\n}\n.ck .ck-fake-panel div:nth-child( 3 ) {\n	margin-left: calc(var(--ck-balloon-fake-panel-offset-horizontal) * 3);\n	margin-top: calc(var(--ck-balloon-fake-panel-offset-vertical) * 3);\n}\n\n/* If balloon is positioned above element, we need to move fake panel to the top. */\n.ck .ck-balloon-panel_arrow_s + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_se + .ck-fake-panel,\n.ck .ck-balloon-panel_arrow_sw + .ck-fake-panel {\n	--ck-balloon-fake-panel-offset-vertical: -6px;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 5868: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-sticky-panel .ck-sticky-panel__content_sticky{position:fixed;top:0;z-index:var(--ck-z-modal)}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky_bottom-limit{position:absolute;top:auto}.ck.ck-sticky-panel .ck-sticky-panel__content_sticky{border-top-left-radius:0;border-top-right-radius:0;border-width:0 1px 1px;box-shadow:var(--ck-drop-shadow),0 0}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/panel/stickypanel.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAMC,qDAEC,cAAe,CACf,KAAM,CAFN,yBAGD,CAEA,kEAEC,iBAAkB,CADlB,QAED,CCPA,qDAIC,wBAAyB,CACzB,yBAA0B,CAF1B,sBAAuB,CCFxB,oCDKA", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-sticky-panel {\n	& .ck-sticky-panel__content_sticky {\n		z-index: var(--ck-z-modal); /* #315 */\n		position: fixed;\n		top: 0;\n	}\n\n	& .ck-sticky-panel__content_sticky_bottom-limit {\n		top: auto;\n		position: absolute;\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_shadow.css";\n\n.ck.ck-sticky-panel {\n	& .ck-sticky-panel__content_sticky {\n		@mixin ck-drop-shadow;\n\n		border-width: 0 1px 1px;\n		border-top-left-radius: 0;\n		border-top-right-radius: 0;\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 6764: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck-vertical-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck-vertical-form .ck-button:focus:after{display:none}@media screen and (max-width:600px){.ck.ck-responsive-form .ck-button:after{bottom:-1px;content:"";position:absolute;right:-1px;top:-1px;width:0;z-index:1}.ck.ck-responsive-form .ck-button:focus:after{display:none}}.ck-vertical-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form{padding:var(--ck-spacing-large)}.ck.ck-responsive-form:focus{outline:none}[dir=ltr] .ck.ck-responsive-form>:not(:first-child),[dir=rtl] .ck.ck-responsive-form>:not(:last-child){margin-left:var(--ck-spacing-standard)}@media screen and (max-width:600px){.ck.ck-responsive-form{padding:0;width:calc(var(--ck-input-width)*.8)}.ck.ck-responsive-form .ck-labeled-field-view{margin:var(--ck-spacing-large) var(--ck-spacing-large) 0}.ck.ck-responsive-form .ck-labeled-field-view .ck-input-text{min-width:0;width:100%}.ck.ck-responsive-form .ck-labeled-field-view .ck-labeled-field-view__error{white-space:normal}.ck.ck-responsive-form>.ck-button:nth-last-child(2):after{border-right:1px solid var(--ck-color-base-border)}.ck.ck-responsive-form>.ck-button:last-child,.ck.ck-responsive-form>.ck-button:nth-last-child(2){border-radius:0;margin-top:var(--ck-spacing-large);padding:var(--ck-spacing-standard)}.ck.ck-responsive-form>.ck-button:last-child:not(:focus),.ck.ck-responsive-form>.ck-button:nth-last-child(2):not(:focus){border-top:1px solid var(--ck-color-base-border)}[dir=ltr] .ck.ck-responsive-form>.ck-button:last-child,[dir=ltr] .ck.ck-responsive-form>.ck-button:nth-last-child(2),[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2){margin-left:0}[dir=rtl] .ck.ck-responsive-form>.ck-button:last-child:last-of-type,[dir=rtl] .ck.ck-responsive-form>.ck-button:nth-last-child(2):last-of-type{border-right:1px solid var(--ck-color-base-border)}}', "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/responsive-form/responsiveform.css", "webpack://./../ckeditor5-ui/theme/mixins/_rwd.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/responsive-form/responsiveform.css"], names: [], mappings: "AAQC,mCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,yCACC,YACD,CCdA,oCDoBE,wCAMC,WAAY,CALZ,UAAW,CAEX,iBAAkB,CAClB,UAAW,CACX,QAAS,CAHT,OAAQ,CAKR,SACD,CAEA,8CACC,YACD,CC9BF,CCAD,qDACC,kDACD,CAEA,uBACC,+BAmED,CAjEC,6BAEC,YACD,CASC,uGACC,sCACD,CDvBD,oCCMD,uBAqBE,SAAU,CACV,oCA8CF,CA5CE,8CACC,wDAWD,CATC,6DACC,WAAY,CACZ,UACD,CAGA,4EACC,kBACD,CAKA,0DACC,kDACD,CAGD,iGAIC,eAAgB,CADhB,kCAAmC,CADnC,kCAmBD,CAfC,yHACC,gDACD,CARD,0OAeE,aAMF,CAJE,+IACC,kDACD,CDpEH", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n\n.ck-vertical-form .ck-button {\n	&::after {\n		content: "";\n		width: 0;\n		position: absolute;\n		right: -1px;\n		top: -1px;\n		bottom: -1px;\n		z-index: 1;\n	}\n\n	&:focus::after {\n		display: none;\n	}\n}\n\n.ck.ck-responsive-form {\n	@mixin ck-media-phone {\n		& .ck-button {\n			&::after {\n				content: "";\n				width: 0;\n				position: absolute;\n				right: -1px;\n				top: -1px;\n				bottom: -1px;\n				z-index: 1;\n			}\n\n			&:focus::after {\n				display: none;\n			}\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@define-mixin ck-media-phone {\n	@media screen and (max-width: 600px) {\n		@mixin-content;\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_rwd.css";\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck-vertical-form > .ck-button:nth-last-child(2)::after {\n	border-right: 1px solid var(--ck-color-base-border);\n}\n\n.ck.ck-responsive-form {\n	padding: var(--ck-spacing-large);\n\n	&:focus {\n		/* See: https://github.com/ckeditor/ckeditor5/issues/4773 */\n		outline: none;\n	}\n\n	@mixin ck-dir ltr {\n		& > :not(:first-child) {\n			margin-left: var(--ck-spacing-standard);\n		}\n	}\n\n	@mixin ck-dir rtl {\n		& > :not(:last-child) {\n			margin-left: var(--ck-spacing-standard);\n		}\n	}\n\n	@mixin ck-media-phone {\n		padding: 0;\n		width: calc(.8 * var(--ck-input-width));\n\n		& .ck-labeled-field-view {\n			margin: var(--ck-spacing-large) var(--ck-spacing-large) 0;\n\n			& .ck-input-text {\n				min-width: 0;\n				width: 100%;\n			}\n\n			/* Let the long error messages wrap in the narrow form. */\n			& .ck-labeled-field-view__error {\n				white-space: normal;\n			}\n		}\n\n		/* Styles for two last buttons in the form (save&cancel, edit&unlink, etc.). */\n		& > .ck-button:nth-last-child(2) {\n			&::after {\n				border-right: 1px solid var(--ck-color-base-border);\n			}\n		}\n\n		& > .ck-button:nth-last-child(1),\n		& > .ck-button:nth-last-child(2) {\n			padding: var(--ck-spacing-standard);\n			margin-top: var(--ck-spacing-large);\n			border-radius: 0;\n\n			&:not(:focus) {\n				border-top: 1px solid var(--ck-color-base-border);\n			}\n\n			@mixin ck-dir ltr {\n				margin-left: 0;\n			}\n\n			@mixin ck-dir rtl {\n				margin-left: 0;\n\n				&:last-of-type {\n					border-right: 1px solid var(--ck-color-base-border);\n				}\n			}\n		}\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 6770: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{position:absolute;top:50%;transform:translateY(-50%)}[dir=ltr] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{left:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view>.ck-labeled-field-view__input-wrapper>.ck-icon{right:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view .ck-search__reset{position:absolute;top:50%;transform:translateY(-50%)}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{display:block}.ck.ck-search>.ck-search__results>.ck-search__info:not(.ck-hidden)~*{display:none}:root{--ck-search-field-view-horizontal-spacing:calc(var(--ck-icon-size) + var(--ck-spacing-medium))}.ck.ck-search>.ck-labeled-field-view .ck-input{width:100%}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon{--ck-labeled-field-label-default-position-x:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon>.ck-labeled-field-view__input-wrapper>.ck-icon{opacity:.5;pointer-events:none}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input,[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-icon .ck-input:not(.ck-input-text_empty){padding-left:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset{--ck-labeled-field-empty-unfocused-max-width:100% - 2 * var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset.ck-labeled-field-view_empty{--ck-labeled-field-empty-unfocused-max-width:100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{background:none;min-height:auto;min-width:auto;opacity:.5;padding:0}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{right:var(--ck-spacing-medium)}[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset{left:var(--ck-spacing-medium)}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-search__reset:hover{opacity:1}.ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{width:100%}[dir=ltr] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input:not(.ck-input-text_empty),[dir=rtl] .ck.ck-search>.ck-labeled-field-view.ck-search__query_with-reset .ck-input{padding-right:var(--ck-search-field-view-horizontal-spacing)}.ck.ck-search>.ck-search__results{min-width:100%}.ck.ck-search>.ck-search__results>.ck-search__info{padding:var(--ck-spacing-medium) var(--ck-spacing-large);width:100%}.ck.ck-search>.ck-search__results>.ck-search__info *{white-space:normal}.ck.ck-search>.ck-search__results>.ck-search__info>span:first-child{font-weight:700}.ck.ck-search>.ck-search__results>.ck-search__info>span:last-child{margin-top:var(--ck-spacing-medium)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/search/search.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/search/search.css"], names: [], mappings: "AASE,oFACC,iBAAkB,CAClB,OAAQ,CACR,0BASD,CAZA,8FAME,6BAMF,CAZA,8FAUE,8BAEF,CAEA,uDACC,iBAAkB,CAClB,OAAQ,CACR,0BACD,CAKC,oEACC,aACD,CAGA,qEACC,YACD,CChCH,MACC,8FACD,CAIE,+CACC,UACD,CAEA,gEACC,0FAoBD,CAlBC,+GACC,UAAW,CACX,mBACD,CAEA,0EACC,UAWD,CAJE,kMACC,2DACD,CAKH,iEACC,sGAwCD,CAtCC,6FACC,6HACD,CAEA,mFAIC,eAAgB,CAFhB,eAAgB,CADhB,cAAe,CAIf,UAAW,CACX,SAaD,CAnBA,6FASE,8BAUF,CAnBA,6FAaE,6BAMF,CAHC,yFACC,SACD,CAGD,2EACC,UAWD,CAZA,oMAUE,4DAEF,CAIF,kCACC,cAkBD,CAhBC,mDAEC,wDAAyD,CADzD,UAcD,CAXC,qDACC,kBACD,CAEA,oEACC,eACD,CAEA,mEACC,mCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n.ck.ck-search {\n	& > .ck-labeled-field-view {\n		& > .ck-labeled-field-view__input-wrapper > .ck-icon {\n			position: absolute;\n			top: 50%;\n			transform: translateY(-50%);\n\n			@mixin ck-dir ltr {\n				left: var(--ck-spacing-medium);\n			}\n\n			@mixin ck-dir rtl {\n				right: var(--ck-spacing-medium);\n			}\n		}\n\n		& .ck-search__reset {\n			position: absolute;\n			top: 50%;\n			transform: translateY(-50%);\n		}\n	}\n\n	& > .ck-search__results {\n		& > .ck-search__info {\n			& > span:first-child {\n				display: block;\n			}\n\n			/* Hide the filtered view when nothing was found */\n			&:not(.ck-hidden) ~ * {\n				display: none;\n			}\n		}\n	}\n}\n', '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";\n\n:root {\n	--ck-search-field-view-horizontal-spacing: calc(var(--ck-icon-size) + var(--ck-spacing-medium));\n}\n\n.ck.ck-search {\n	& > .ck-labeled-field-view {\n		& .ck-input {\n			width: 100%;\n		}\n\n		&.ck-search__query_with-icon {\n			--ck-labeled-field-label-default-position-x: var(--ck-search-field-view-horizontal-spacing);\n\n			& > .ck-labeled-field-view__input-wrapper > .ck-icon {\n				opacity: .5;\n				pointer-events: none;\n			}\n\n			& .ck-input {\n				width: 100%;\n\n				@mixin ck-dir ltr {\n					padding-left: var(--ck-search-field-view-horizontal-spacing);\n				}\n\n				@mixin ck-dir rtl {\n					&:not(.ck-input-text_empty) {\n						padding-left: var(--ck-search-field-view-horizontal-spacing);\n					}\n				}\n			}\n		}\n\n		&.ck-search__query_with-reset {\n			--ck-labeled-field-empty-unfocused-max-width: 100% - 2 * var(--ck-search-field-view-horizontal-spacing);\n\n			&.ck-labeled-field-view_empty {\n				--ck-labeled-field-empty-unfocused-max-width: 100% - var(--ck-search-field-view-horizontal-spacing) - var(--ck-spacing-medium);\n			}\n\n			& .ck-search__reset {\n				min-width: auto;\n				min-height: auto;\n\n				background: none;\n				opacity: .5;\n				padding: 0;\n\n				@mixin ck-dir ltr {\n					right: var(--ck-spacing-medium);\n				}\n\n				@mixin ck-dir rtl {\n					left: var(--ck-spacing-medium);\n				}\n\n				&:hover {\n					opacity: 1;\n				}\n			}\n\n			& .ck-input {\n				width: 100%;\n\n				@mixin ck-dir ltr {\n					&:not(.ck-input-text_empty) {\n						padding-right: var(--ck-search-field-view-horizontal-spacing);\n					}\n				}\n\n				@mixin ck-dir rtl {\n					padding-right: var(--ck-search-field-view-horizontal-spacing);\n				}\n			}\n		}\n	}\n\n	& > .ck-search__results {\n		min-width: 100%;\n\n		& > .ck-search__info {\n			width: 100%;\n			padding: var(--ck-spacing-medium) var(--ck-spacing-large);\n\n			& * {\n				white-space: normal;\n			}\n\n			& > span:first-child {\n				font-weight: bold;\n			}\n\n			& > span:last-child {\n				margin-top: var(--ck-spacing-medium);\n			}\n		}\n	}\n}\n\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 498: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-spinner-container{display:block;position:relative}.ck.ck-spinner{left:0;margin:0 auto;position:absolute;right:0;top:50%;transform:translateY(-50%);z-index:1}:root{--ck-toolbar-spinner-size:18px}.ck.ck-spinner-container{animation:rotate 1.5s linear infinite}.ck.ck-spinner,.ck.ck-spinner-container{height:var(--ck-toolbar-spinner-size);width:var(--ck-toolbar-spinner-size)}.ck.ck-spinner{border:2px solid var(--ck-color-text);border-radius:50%;border-top:2px solid transparent}@keyframes rotate{to{transform:rotate(1turn)}}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/spinner/spinner.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/spinner/spinner.css"], names: [], mappings: "AASA,yBACC,aAAc,CACd,iBACD,CAEA,eAGC,MAAO,CAEP,aAAc,CAJd,iBAAkB,CAGlB,OAAQ,CAFR,OAAQ,CAIR,0BAA2B,CAC3B,SACD,CCjBA,MACC,8BACD,CAEA,yBAGC,qCACD,CAEA,wCAJC,qCAAsC,CADtC,oCAWD,CANA,eAKC,qCAA6B,CAF7B,iBAAkB,CAElB,gCACD,CAEA,kBACC,GACC,uBACD,CACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-toolbar-spinner-size: 18px;\n}\n\n.ck.ck-spinner-container {\n	display: block;\n	position: relative;\n}\n\n.ck.ck-spinner {\n	position: absolute;\n	top: 50%;\n	left: 0;\n	right: 0;\n	margin: 0 auto;\n	transform: translateY(-50%);\n	z-index: 1;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-toolbar-spinner-size: 18px;\n}\n\n.ck.ck-spinner-container {\n	width: var(--ck-toolbar-spinner-size);\n	height: var(--ck-toolbar-spinner-size);\n	animation: 1.5s infinite rotate linear;\n}\n\n.ck.ck-spinner {\n	width: var(--ck-toolbar-spinner-size);\n	height: var(--ck-toolbar-spinner-size);\n	border-radius: 50%;\n	border: 2px solid var(--ck-color-text);\n	border-top-color: transparent;\n}\n\n@keyframes rotate {\n	to {\n		transform: rotate(360deg)\n	}\n}\n\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 8182: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-textarea{overflow-x:hidden}", "", { version: 3, sources: ["webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/textarea/textarea.css"], names: [], mappings: "AASA,aACC,iBACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/*\n * This fixes a problem in Firefox when the initial height of the complement does not match the number of rows.\n * This bug is especially visible when rows=1.\n */\n.ck-textarea {\n	overflow-x: hidden\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 9695: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-block-toolbar-button{position:absolute;z-index:var(--ck-z-default)}:root{--ck-color-block-toolbar-button:var(--ck-color-text);--ck-block-toolbar-button-size:var(--ck-font-size-normal)}.ck.ck-block-toolbar-button{color:var(--ck-color-block-toolbar-button);font-size:var(--ck-block-toolbar-size)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/blocktoolbar.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/blocktoolbar.css"], names: [], mappings: "AAKA,4BACC,iBAAkB,CAClB,2BACD,CCHA,MACC,oDAAqD,CACrD,yDACD,CAEA,4BACC,0CAA2C,CAC3C,sCACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-block-toolbar-button {\n	position: absolute;\n	z-index: var(--ck-z-default);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-block-toolbar-button: var(--ck-color-text);\n	--ck-block-toolbar-button-size: var(--ck-font-size-normal);\n}\n\n.ck.ck-block-toolbar-button {\n	color: var(--ck-color-block-toolbar-button);\n	font-size: var(--ck-block-toolbar-size);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 5542: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-toolbar{align-items:center;display:flex;flex-flow:row nowrap;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;user-select:none}.ck.ck-toolbar>.ck-toolbar__items{align-items:center;display:flex;flex-flow:row wrap;flex-grow:1}.ck.ck-toolbar .ck.ck-toolbar__separator{display:inline-block}.ck.ck-toolbar .ck.ck-toolbar__separator:first-child,.ck.ck-toolbar .ck.ck-toolbar__separator:last-child{display:none}.ck.ck-toolbar .ck-toolbar__line-break{flex-basis:100%}.ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items{flex-direction:column}.ck.ck-toolbar.ck-toolbar_floating>.ck-toolbar__items{flex-wrap:nowrap}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck-dropdown__button .ck-dropdown__arrow{display:none}.ck.ck-toolbar{border-radius:0}.ck-rounded-corners .ck.ck-toolbar,.ck.ck-toolbar.ck-rounded-corners{border-radius:var(--ck-border-radius)}.ck.ck-toolbar{background:var(--ck-color-toolbar-background);border:1px solid var(--ck-color-toolbar-border);padding:0 var(--ck-spacing-small)}.ck.ck-toolbar .ck.ck-toolbar__separator{align-self:stretch;background:var(--ck-color-toolbar-border);margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small);min-width:1px;width:1px}.ck.ck-toolbar .ck-toolbar__line-break{height:0}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break){margin-right:var(--ck-spacing-small)}.ck.ck-toolbar>.ck-toolbar__items:empty+.ck.ck-toolbar__separator{display:none}.ck.ck-toolbar>.ck-toolbar__items>:not(.ck-toolbar__line-break),.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown{margin-bottom:var(--ck-spacing-small);margin-top:var(--ck-spacing-small)}.ck.ck-toolbar.ck-toolbar_vertical{padding:0}.ck.ck-toolbar.ck-toolbar_vertical>.ck-toolbar__items>.ck{border-radius:0;margin:0;width:100%}.ck.ck-toolbar.ck-toolbar_compact{padding:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>*{margin:0}.ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>:not(:first-child):not(:last-child){border-radius:0}.ck.ck-toolbar>.ck.ck-toolbar__grouped-dropdown>.ck.ck-button.ck-dropdown__button{padding-left:var(--ck-spacing-tiny)}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-dropdown__panel{min-width:auto}.ck.ck-toolbar .ck-toolbar__nested-toolbar-dropdown>.ck-button>.ck-button__label{max-width:7em;width:auto}.ck.ck-toolbar:focus{outline:none}.ck-toolbar-container .ck.ck-toolbar{border:0}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck{margin-right:0}.ck.ck-toolbar[dir=rtl]:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck,[dir=rtl] .ck.ck-toolbar:not(.ck-toolbar_compact)>.ck-toolbar__items>.ck{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-left:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:first-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=rtl]>.ck-toolbar__items>.ck:last-child,[dir=rtl] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=rtl]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=rtl]>.ck.ck-toolbar__separator,[dir=rtl] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=rtl] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-left:var(--ck-spacing-small)}.ck.ck-toolbar[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar>.ck-toolbar__items>.ck:last-child{margin-right:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:first-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:first-child{border-bottom-right-radius:0;border-top-right-radius:0}.ck.ck-toolbar.ck-toolbar_compact[dir=ltr]>.ck-toolbar__items>.ck:last-child,[dir=ltr] .ck.ck-toolbar.ck-toolbar_compact>.ck-toolbar__items>.ck:last-child{border-bottom-left-radius:0;border-top-left-radius:0}.ck.ck-toolbar.ck-toolbar_grouping[dir=ltr]>.ck-toolbar__items:not(:empty):not(:only-child),.ck.ck-toolbar[dir=ltr]>.ck.ck-toolbar__separator,[dir=ltr] .ck.ck-toolbar.ck-toolbar_grouping>.ck-toolbar__items:not(:empty):not(:only-child),[dir=ltr] .ck.ck-toolbar>.ck.ck-toolbar__separator{margin-right:var(--ck-spacing-small)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/toolbar/toolbar.css", "webpack://./../ckeditor5-ui/theme/mixins/_unselectable.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/toolbar/toolbar.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_rounded.css"], names: [], mappings: "AAOA,eAKC,kBAAmB,CAFnB,YAAa,CACb,oBAAqB,CCFrB,qBAAsB,CACtB,wBAAyB,CACzB,oBAAqB,CACrB,gBD6CD,CA3CC,kCAGC,kBAAmB,CAFnB,YAAa,CACb,kBAAmB,CAEnB,WAED,CAEA,yCACC,oBAWD,CAJC,yGAEC,YACD,CAGD,uCACC,eACD,CAEA,sDACC,gBACD,CAEA,sDACC,qBACD,CAEA,sDACC,gBACD,CAGC,yFACC,YACD,CE/CF,eCGC,eDwGD,CA3GA,qECOE,qCDoGF,CA3GA,eAGC,6CAA8C,CAE9C,+CAAgD,CADhD,iCAuGD,CApGC,yCACC,kBAAmB,CAGnB,yCAA0C,CAO1C,qCAAsC,CADtC,kCAAmC,CAPnC,aAAc,CADd,SAUD,CAEA,uCACC,QACD,CAGC,gEAEC,oCACD,CAIA,kEACC,YACD,CAGD,gHAIC,qCAAsC,CADtC,kCAED,CAEA,mCAEC,SAaD,CAVC,0DAQC,eAAgB,CAHhB,QAAS,CAHT,UAOD,CAGD,kCAEC,SAWD,CATC,uDAEC,QAMD,CAHC,yFACC,eACD,CASD,kFACC,mCACD,CAMA,wEACC,cACD,CAEA,iFACC,aAAc,CACd,UACD,CAGD,qBACC,YACD,CAtGD,qCAyGE,QAEF,CAYC,+FACC,cACD,CAEA,iJAEC,mCACD,CAEA,qHACC,aACD,CAIC,6JAEC,2BAA4B,CAD5B,wBAED,CAGA,2JAEC,4BAA6B,CAD7B,yBAED,CASD,8RACC,mCACD,CAWA,qHACC,cACD,CAIC,6JAEC,4BAA6B,CAD7B,yBAED,CAGA,2JAEC,2BAA4B,CAD5B,wBAED,CASD,8RACC,oCACD", sourcesContent: ['/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../mixins/_unselectable.css";\n\n.ck.ck-toolbar {\n	@mixin ck-unselectable;\n\n	display: flex;\n	flex-flow: row nowrap;\n	align-items: center;\n\n	& > .ck-toolbar__items {\n		display: flex;\n		flex-flow: row wrap;\n		align-items: center;\n		flex-grow: 1;\n\n	}\n\n	& .ck.ck-toolbar__separator {\n		display: inline-block;\n\n		/*\n		 * A leading or trailing separator makes no sense (separates from nothing on one side).\n		 * For instance, it can happen when toolbar items (also separators) are getting grouped one by one and\n		 * moved to another toolbar in the dropdown.\n		 */\n		&:first-child,\n		&:last-child {\n			display: none;\n		}\n	}\n\n	& .ck-toolbar__line-break {\n		flex-basis: 100%;\n	}\n\n	&.ck-toolbar_grouping > .ck-toolbar__items {\n		flex-wrap: nowrap;\n	}\n\n	&.ck-toolbar_vertical > .ck-toolbar__items {\n		flex-direction: column;\n	}\n\n	&.ck-toolbar_floating > .ck-toolbar__items {\n		flex-wrap: nowrap;\n	}\n\n	& > .ck.ck-toolbar__grouped-dropdown {\n		& > .ck-dropdown__button .ck-dropdown__arrow {\n			display: none;\n		}\n	}\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Makes element unselectable.\n */\n@define-mixin ck-unselectable {\n	-moz-user-select: none;\n	-webkit-user-select: none;\n	-ms-user-select: none;\n	user-select: none\n}\n", `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

@import "../../../mixins/_rounded.css";
@import "@ckeditor/ckeditor5-ui/theme/mixins/_dir.css";

.ck.ck-toolbar {
	@mixin ck-rounded-corners;

	background: var(--ck-color-toolbar-background);
	padding: 0 var(--ck-spacing-small);
	border: 1px solid var(--ck-color-toolbar-border);

	& .ck.ck-toolbar__separator {
		align-self: stretch;
		width: 1px;
		min-width: 1px;
		background: var(--ck-color-toolbar-border);

		/*
		 * These margins make the separators look better in balloon toolbars (when aligned with the "tip").
		 * See https://github.com/ckeditor/ckeditor5/issues/7493.
		 */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	& .ck-toolbar__line-break {
		height: 0;
	}

	& > .ck-toolbar__items {
		& > *:not(.ck-toolbar__line-break) {
			/* (#11) Separate toolbar items. */
			margin-right: var(--ck-spacing-small);
		}

		/* Don't display a separator after an empty items container, for instance,
		when all items were grouped */
		&:empty + .ck.ck-toolbar__separator {
			display: none;
		}
	}

	& > .ck-toolbar__items > *:not(.ck-toolbar__line-break),
	& > .ck.ck-toolbar__grouped-dropdown {
		/* Make sure items wrapped to the next line have v-spacing */
		margin-top: var(--ck-spacing-small);
		margin-bottom: var(--ck-spacing-small);
	}

	&.ck-toolbar_vertical {
		/* Items in a vertical toolbar span the entire width. */
		padding: 0;

		/* Specificity matters here. See https://github.com/ckeditor/ckeditor5-theme-lark/issues/168. */
		& > .ck-toolbar__items > .ck {
			/* Items in a vertical toolbar should span the horizontal space. */
			width: 100%;

			/* Items in a vertical toolbar should have no margin. */
			margin: 0;

			/* Items in a vertical toolbar span the entire width so rounded corners are pointless. */
			border-radius: 0;
		}
	}

	&.ck-toolbar_compact {
		/* No spacing around items. */
		padding: 0;

		& > .ck-toolbar__items > * {
			/* Compact toolbar items have no spacing between them. */
			margin: 0;

			/* "Middle" children should have no rounded corners. */
			&:not(:first-child):not(:last-child) {
				border-radius: 0;
			}
		}
	}

	& > .ck.ck-toolbar__grouped-dropdown {
		/*
		 * Dropdown button has asymmetric padding to fit the arrow.
		 * This button has no arrow so let's revert that padding back to normal.
		 */
		& > .ck.ck-button.ck-dropdown__button {
			padding-left: var(--ck-spacing-tiny);
		}
	}

	/* A drop-down containing the nested toolbar with configured items. */
	& .ck-toolbar__nested-toolbar-dropdown {
		/* Prevent empty space in the panel when the dropdown label is visible and long but the toolbar has few items. */
		& > .ck-dropdown__panel {
			min-width: auto;
		}

		& > .ck-button > .ck-button__label {
			max-width: 7em;
			width: auto;
		}
	}

	&:focus {
		outline: none;
	}

	@nest .ck-toolbar-container & {
		border: 0;
	}
}

/* stylelint-disable */

/*
 * Styles for RTL toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="rtl"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="rtl"] {
	& > .ck-toolbar__items > .ck {
		margin-right: 0;
	}

	&:not(.ck-toolbar_compact) > .ck-toolbar__items > .ck {
		/* (#11) Separate toolbar items. */
		margin-left: var(--ck-spacing-small);
	}

	& > .ck-toolbar__items > .ck:last-child {
		margin-left: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-left: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-left: var(--ck-spacing-small);
	}
}

/*
 * Styles for LTR toolbars.
 *
 * Note: In some cases (e.g. a decoupled editor), the toolbar has its own "dir"
 * because its parent is not controlled by the editor framework.
 */
[dir="ltr"] .ck.ck-toolbar,
.ck.ck-toolbar[dir="ltr"] {
	& > .ck-toolbar__items > .ck:last-child {
		margin-right: 0;
	}

	&.ck-toolbar_compact > .ck-toolbar__items > .ck {
		/* No rounded corners on the right side of the first child. */
		&:first-child {
			border-top-right-radius: 0;
			border-bottom-right-radius: 0;
		}

		/* No rounded corners on the left side of the last child. */
		&:last-child {
			border-top-left-radius: 0;
			border-bottom-left-radius: 0;
		}
	}

	/* Separate the the separator form the grouping dropdown when some items are grouped. */
	& > .ck.ck-toolbar__separator {
		margin-right: var(--ck-spacing-small);
	}

	/* Some spacing between the items and the separator before the grouped items dropdown. */
	&.ck-toolbar_grouping > .ck-toolbar__items:not(:empty):not(:only-child) {
		margin-right: var(--ck-spacing-small);
	}
}

/* stylelint-enable */
`, "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Implements rounded corner interface for .ck-rounded-corners class.\n *\n * @see $ck-border-radius\n */\n@define-mixin ck-rounded-corners {\n	border-radius: 0;\n\n	@nest .ck-rounded-corners &,\n	&.ck-rounded-corners {\n		border-radius: var(--ck-border-radius);\n		@mixin-content;\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3332: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck.ck-balloon-panel.ck-tooltip{--ck-balloon-border-width:0px;--ck-balloon-arrow-offset:0px;--ck-balloon-arrow-half-width:4px;--ck-balloon-arrow-height:4px;--ck-tooltip-text-padding:4px;--ck-color-panel-background:var(--ck-color-tooltip-background);padding:0 var(--ck-spacing-medium);pointer-events:none;z-index:calc(var(--ck-z-modal) + 100)}.ck.ck-balloon-panel.ck-tooltip .ck-tooltip__text{color:var(--ck-color-tooltip-text);font-size:.9em;line-height:1.5}.ck.ck-balloon-panel.ck-tooltip.ck-tooltip_multi-line .ck-tooltip__text{display:inline-block;padding:var(--ck-tooltip-text-padding) 0;white-space:break-spaces}.ck.ck-balloon-panel.ck-tooltip{box-shadow:none}.ck.ck-balloon-panel.ck-tooltip:before{display:none}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/components/tooltip/tooltip.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/components/tooltip/tooltip.css"], names: [], mappings: "AAKA,gCCGC,6BAA8B,CAC9B,6BAA8B,CAC9B,iCAAkC,CAClC,6BAA8B,CAC9B,6BAA8B,CAC9B,8DAA+D,CAE/D,kCAAmC,CDRnC,mBAAoB,CAEpB,qCACD,CCOC,kDAGC,kCAAmC,CAFnC,cAAe,CACf,eAED,CAEA,wEAEC,oBAAqB,CACrB,wCAAyC,CAFzC,wBAGD,CApBD,gCAuBC,eAMD,CAHC,uCACC,YACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-balloon-panel.ck-tooltip {\n	/* Keep tooltips transparent for any interactions. */\n	pointer-events: none;\n\n	z-index: calc( var(--ck-z-modal) + 100 );\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../../../mixins/_rounded.css";\n\n.ck.ck-balloon-panel.ck-tooltip {\n	--ck-balloon-border-width: 0px;\n	--ck-balloon-arrow-offset: 0px;\n	--ck-balloon-arrow-half-width: 4px;\n	--ck-balloon-arrow-height: 4px;\n	--ck-tooltip-text-padding: 4px;\n	--ck-color-panel-background: var(--ck-color-tooltip-background);\n\n	padding: 0 var(--ck-spacing-medium);\n\n	& .ck-tooltip__text {\n		font-size: .9em;\n		line-height: 1.5;\n		color: var(--ck-color-tooltip-text);\n	}\n\n	&.ck-tooltip_multi-line .ck-tooltip__text {\n		white-space: break-spaces;\n		display: inline-block;\n		padding: var(--ck-tooltip-text-padding) 0;\n	}\n\n	/* Reset balloon panel styles */\n	box-shadow: none;\n\n	/* Hide the default shadow of the .ck-balloon-panel tip */\n	&::before {\n		display: none;\n	}\n}\n'], sourceRoot: "" }]);
      const a2 = s2;
    }, 4793: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck-hidden{display:none!important}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{box-sizing:border-box;height:auto;position:static;width:auto}:root{--ck-z-default:1;--ck-z-modal:calc(var(--ck-z-default) + 999)}.ck-transitions-disabled,.ck-transitions-disabled *{transition:none!important}:root{--ck-powered-by-line-height:10px;--ck-powered-by-padding-vertical:2px;--ck-powered-by-padding-horizontal:4px;--ck-powered-by-text-color:#4f4f4f;--ck-powered-by-border-radius:var(--ck-border-radius);--ck-powered-by-background:#fff;--ck-powered-by-border-color:var(--ck-color-focus-border)}.ck.ck-balloon-panel.ck-powered-by-balloon{--ck-border-radius:var(--ck-powered-by-border-radius);background:var(--ck-powered-by-background);box-shadow:none;min-height:unset;z-index:calc(var(--ck-z-modal) - 1)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by{line-height:var(--ck-powered-by-line-height)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by a{align-items:center;cursor:pointer;display:flex;filter:grayscale(80%);line-height:var(--ck-powered-by-line-height);opacity:.66;padding:var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal)}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-powered-by__label{color:var(--ck-powered-by-text-color);cursor:pointer;font-size:7.5px;font-weight:700;letter-spacing:-.2px;line-height:normal;margin-right:4px;padding-left:2px;text-transform:uppercase}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by .ck-icon{cursor:pointer;display:block}.ck.ck-balloon-panel.ck-powered-by-balloon .ck.ck-powered-by:hover a{filter:grayscale(0);opacity:1}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_inside]{border-color:transparent}.ck.ck-balloon-panel.ck-powered-by-balloon[class*=position_border]{border:var(--ck-focus-ring);border-color:var(--ck-powered-by-border-color)}:root{--ck-color-base-foreground:#fafafa;--ck-color-base-background:#fff;--ck-color-base-border:#ccced1;--ck-color-base-action:#53a336;--ck-color-base-focus:#6cb5f9;--ck-color-base-text:#333;--ck-color-base-active:#2977ff;--ck-color-base-active-focus:#0d65ff;--ck-color-base-error:#db3700;--ck-color-focus-border-coordinates:218,81.8%,56.9%;--ck-color-focus-border:hsl(var(--ck-color-focus-border-coordinates));--ck-color-focus-outer-shadow:#cae1fc;--ck-color-focus-disabled-shadow:rgba(119,186,248,.3);--ck-color-focus-error-shadow:rgba(255,64,31,.3);--ck-color-text:var(--ck-color-base-text);--ck-color-shadow-drop:rgba(0,0,0,.15);--ck-color-shadow-drop-active:rgba(0,0,0,.2);--ck-color-shadow-inner:rgba(0,0,0,.1);--ck-color-button-default-background:transparent;--ck-color-button-default-hover-background:#f0f0f0;--ck-color-button-default-active-background:#f0f0f0;--ck-color-button-default-disabled-background:transparent;--ck-color-button-on-background:#f0f7ff;--ck-color-button-on-hover-background:#dbecff;--ck-color-button-on-active-background:#dbecff;--ck-color-button-on-disabled-background:#f0f2f4;--ck-color-button-on-color:#2977ff;--ck-color-button-action-background:var(--ck-color-base-action);--ck-color-button-action-hover-background:#4d9d30;--ck-color-button-action-active-background:#4d9d30;--ck-color-button-action-disabled-background:#7ec365;--ck-color-button-action-text:var(--ck-color-base-background);--ck-color-button-save:#008a00;--ck-color-button-cancel:#db3700;--ck-color-switch-button-off-background:#939393;--ck-color-switch-button-off-hover-background:#7d7d7d;--ck-color-switch-button-on-background:var(--ck-color-button-action-background);--ck-color-switch-button-on-hover-background:#4d9d30;--ck-color-switch-button-inner-background:var(--ck-color-base-background);--ck-color-switch-button-inner-shadow:rgba(0,0,0,.1);--ck-color-dropdown-panel-background:var(--ck-color-base-background);--ck-color-dropdown-panel-border:var(--ck-color-base-border);--ck-color-input-background:var(--ck-color-base-background);--ck-color-input-border:var(--ck-color-base-border);--ck-color-input-error-border:var(--ck-color-base-error);--ck-color-input-text:var(--ck-color-base-text);--ck-color-input-disabled-background:#f2f2f2;--ck-color-input-disabled-border:var(--ck-color-base-border);--ck-color-input-disabled-text:#757575;--ck-color-list-background:var(--ck-color-base-background);--ck-color-list-button-hover-background:var(--ck-color-button-default-hover-background);--ck-color-list-button-on-background:var(--ck-color-button-on-color);--ck-color-list-button-on-background-focus:var(--ck-color-button-on-color);--ck-color-list-button-on-text:var(--ck-color-base-background);--ck-color-panel-background:var(--ck-color-base-background);--ck-color-panel-border:var(--ck-color-base-border);--ck-color-toolbar-background:var(--ck-color-base-background);--ck-color-toolbar-border:var(--ck-color-base-border);--ck-color-tooltip-background:var(--ck-color-base-text);--ck-color-tooltip-text:var(--ck-color-base-background);--ck-color-engine-placeholder-text:#707070;--ck-color-upload-bar-background:#6cb5f9;--ck-color-link-default:#0000f0;--ck-color-link-selected-background:rgba(31,176,255,.1);--ck-color-link-fake-selection:rgba(31,176,255,.3);--ck-color-highlight-background:#ff0;--ck-disabled-opacity:.5;--ck-focus-outer-shadow-geometry:0 0 0 3px;--ck-focus-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);--ck-focus-disabled-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);--ck-focus-error-outer-shadow:var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);--ck-focus-ring:1px solid var(--ck-color-focus-border);--ck-font-size-base:13px;--ck-line-height-base:1.84615;--ck-font-face:Helvetica,Arial,Tahoma,Verdana,Sans-Serif;--ck-font-size-tiny:0.7em;--ck-font-size-small:0.75em;--ck-font-size-normal:1em;--ck-font-size-big:1.4em;--ck-font-size-large:1.8em;--ck-ui-component-min-height:2.3em}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset,.ck.ck-reset_all{word-wrap:break-word;background:transparent;border:0;margin:0;padding:0;text-decoration:none;transition:none;vertical-align:middle}.ck-reset_all :not(.ck-reset_all-excluded *),.ck.ck-reset_all{border-collapse:collapse;color:var(--ck-color-text);cursor:auto;float:none;font:normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);text-align:left;white-space:nowrap}.ck-reset_all .ck-rtl :not(.ck-reset_all-excluded *){text-align:right}.ck-reset_all iframe:not(.ck-reset_all-excluded *){vertical-align:inherit}.ck-reset_all textarea:not(.ck-reset_all-excluded *){white-space:pre-wrap}.ck-reset_all input[type=password]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text]:not(.ck-reset_all-excluded *),.ck-reset_all textarea:not(.ck-reset_all-excluded *){cursor:text}.ck-reset_all input[type=password][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all input[type=text][disabled]:not(.ck-reset_all-excluded *),.ck-reset_all textarea[disabled]:not(.ck-reset_all-excluded *){cursor:default}.ck-reset_all fieldset:not(.ck-reset_all-excluded *){border:2px groove #dfdee3;padding:10px}.ck-reset_all button:not(.ck-reset_all-excluded *)::-moz-focus-inner{border:0;padding:0}.ck[dir=rtl],.ck[dir=rtl] .ck{text-align:right}:root{--ck-border-radius:2px;--ck-inner-shadow:2px 2px 3px var(--ck-color-shadow-inner) inset;--ck-drop-shadow:0 1px 2px 1px var(--ck-color-shadow-drop);--ck-drop-shadow-active:0 3px 6px 1px var(--ck-color-shadow-drop-active);--ck-spacing-unit:0.6em;--ck-spacing-large:calc(var(--ck-spacing-unit)*1.5);--ck-spacing-standard:var(--ck-spacing-unit);--ck-spacing-medium:calc(var(--ck-spacing-unit)*0.8);--ck-spacing-small:calc(var(--ck-spacing-unit)*0.5);--ck-spacing-tiny:calc(var(--ck-spacing-unit)*0.3);--ck-spacing-extra-tiny:calc(var(--ck-spacing-unit)*0.16)}", "", { version: 3, sources: ["webpack://./../ckeditor5-ui/theme/globals/_hidden.css", "webpack://./../ckeditor5-ui/theme/globals/_reset.css", "webpack://./../ckeditor5-ui/theme/globals/_zindex.css", "webpack://./../ckeditor5-ui/theme/globals/_transition.css", "webpack://./../ckeditor5-ui/theme/globals/_poweredby.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_colors.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_disabled.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_fonts.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_reset.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_rounded.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_shadow.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-ui/globals/_spacing.css"], names: [], mappings: "AAQA,WAGC,sBACD,CCPA,2EAGC,qBAAsB,CAEtB,WAAY,CACZ,eAAgB,CAFhB,UAGD,CCPA,MACC,gBAAiB,CACjB,4CACD,CCAA,oDAEC,yBACD,CCNA,MACC,gCAAiC,CACjC,oCAAqC,CACrC,sCAAuC,CACvC,kCAA2C,CAC3C,qDAAsD,CACtD,+BAA4C,CAC5C,yDACD,CAEA,2CACC,qDAAsD,CAGtD,0CAA2C,CAD3C,eAAgB,CAEhB,gBAAiB,CACjB,mCAiDD,CA/CC,6DACC,4CAoCD,CAlCC,+DAGC,kBAAmB,CAFnB,cAAe,CACf,YAAa,CAGb,qBAAsB,CACtB,4CAA6C,CAF7C,WAAY,CAGZ,qFACD,CAEA,mFASC,qCAAsC,CAFtC,cAAe,CANf,eAAgB,CAIhB,eAAiB,CAHjB,oBAAqB,CAMrB,kBAAmB,CAFnB,gBAAiB,CAHjB,gBAAiB,CACjB,wBAOD,CAEA,sEAEC,cAAe,CADf,aAED,CAGC,qEACC,mBAAqB,CACrB,SACD,CAIF,mEACC,wBACD,CAEA,mEACC,2BAA4B,CAC5B,8CACD,CChED,MACC,kCAAmD,CACnD,+BAAoD,CACpD,8BAAkD,CAClD,8BAAuD,CACvD,6BAAmD,CACnD,yBAA+C,CAC/C,8BAAsD,CACtD,oCAA4D,CAC5D,6BAAkD,CAIlD,mDAA4D,CAC5D,qEAA+E,CAC/E,qCAA4D,CAC5D,qDAA8D,CAC9D,gDAAyD,CACzD,yCAAqD,CACrD,sCAAsD,CACtD,4CAA0D,CAC1D,sCAAsD,CAItD,gDAAuD,CACvD,kDAAiE,CACjE,mDAAkE,CAClE,yDAA8D,CAE9D,uCAA6D,CAC7D,6CAAoE,CACpE,8CAAoE,CACpE,gDAAiE,CACjE,kCAAyD,CAGzD,+DAAsE,CACtE,iDAAsE,CACtE,kDAAsE,CACtE,oDAAoE,CACpE,6DAAsE,CAEtE,8BAAoD,CACpD,gCAAqD,CAErD,+CAA8D,CAC9D,qDAAiE,CACjE,+EAAqF,CACrF,oDAAuE,CACvE,yEAA8E,CAC9E,oDAAgE,CAIhE,oEAA2E,CAC3E,4DAAoE,CAIpE,2DAAoE,CACpE,mDAA6D,CAC7D,wDAAgE,CAChE,+CAA0D,CAC1D,4CAA2D,CAC3D,4DAAoE,CACpE,sCAAsD,CAItD,0DAAmE,CACnE,uFAA6F,CAC7F,oEAA2E,CAC3E,0EAA+E,CAC/E,8DAAsE,CAItE,2DAAoE,CACpE,mDAA6D,CAI7D,6DAAsE,CACtE,qDAA+D,CAI/D,uDAAgE,CAChE,uDAAiE,CAIjE,0CAAyD,CAIzD,wCAA2D,CAI3D,+BAAoD,CACpD,uDAAmE,CACnE,kDAAgE,CAIhE,oCAAwD,CCvGxD,wBAAyB,CCAzB,0CAA2C,CAK3C,gGAAiG,CAKjG,4GAA6G,CAK7G,sGAAuG,CAKvG,sDAAuD,CCvBvD,wBAAyB,CACzB,6BAA8B,CAC9B,wDAA6D,CAE7D,yBAA0B,CAC1B,2BAA4B,CAC5B,yBAA0B,CAC1B,wBAAyB,CACzB,0BAA2B,CCJ3B,kCJuGD,CIjGA,2EAaC,oBAAqB,CANrB,sBAAuB,CADvB,QAAS,CAFT,QAAS,CACT,SAAU,CAGV,oBAAqB,CAErB,eAAgB,CADhB,qBAKD,CAKA,8DAGC,wBAAyB,CAEzB,0BAA2B,CAG3B,WAAY,CACZ,UAAW,CALX,iGAAkG,CAElG,eAAgB,CAChB,kBAGD,CAGC,qDACC,gBACD,CAEA,mDAEC,sBACD,CAEA,qDACC,oBACD,CAEA,mLAGC,WACD,CAEA,iNAGC,cACD,CAEA,qDAEC,yBAAoC,CADpC,YAED,CAEA,qEAGC,QAAQ,CADR,SAED,CAMD,8BAEC,gBACD,CCnFA,MACC,sBAAuB,CCAvB,gEAAiE,CAKjE,0DAA2D,CAK3D,wEAAyE,CCbzE,uBAA8B,CAC9B,mDAA2D,CAC3D,4CAAkD,CAClD,oDAA4D,CAC5D,mDAA2D,CAC3D,kDAA2D,CAC3D,yDFFD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class which hides an element in DOM.\n */\n.ck-hidden {\n	/* Override selector specificity. Otherwise, all elements with some display\n	style defined will override this one, which is not a desired result. */\n	display: none !important;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n	box-sizing: border-box;\n	width: auto;\n	height: auto;\n	position: static;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-z-default: 1;\n	--ck-z-modal: calc( var(--ck-z-default) + 999 );\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A class that disables all transitions of the element and its children.\n */\n.ck-transitions-disabled,\n.ck-transitions-disabled * {\n	transition: none !important;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-powered-by-line-height: 10px;\n	--ck-powered-by-padding-vertical: 2px;\n	--ck-powered-by-padding-horizontal: 4px;\n	--ck-powered-by-text-color: hsl(0, 0%, 31%);\n	--ck-powered-by-border-radius: var(--ck-border-radius);\n	--ck-powered-by-background: hsl(0, 0%, 100%);\n	--ck-powered-by-border-color: var(--ck-color-focus-border);\n}\n\n.ck.ck-balloon-panel.ck-powered-by-balloon {\n	--ck-border-radius: var(--ck-powered-by-border-radius);\n\n	box-shadow: none;\n	background: var(--ck-powered-by-background);\n	min-height: unset;\n	z-index: calc( var(--ck-z-modal) - 1 );\n\n	& .ck.ck-powered-by {\n		line-height: var(--ck-powered-by-line-height);\n\n		& a {\n			cursor: pointer;\n			display: flex;\n			align-items: center;\n			opacity: .66;\n			filter: grayscale(80%);\n			line-height: var(--ck-powered-by-line-height);\n			padding: var(--ck-powered-by-padding-vertical) var(--ck-powered-by-padding-horizontal);\n		}\n\n		& .ck-powered-by__label {\n			font-size: 7.5px;\n			letter-spacing: -.2px;\n			padding-left: 2px;\n			text-transform: uppercase;\n			font-weight: bold;\n			margin-right: 4px;\n			cursor: pointer;\n			line-height: normal;\n			color: var(--ck-powered-by-text-color);\n\n		}\n\n		& .ck-icon {\n			display: block;\n			cursor: pointer;\n		}\n\n		&:hover {\n			& a {\n				filter: grayscale(0%);\n				opacity: 1;\n			}\n		}\n	}\n\n	&[class*="position_inside"] {\n		border-color: transparent;\n	}\n\n	&[class*="position_border"] {\n		border: var(--ck-focus-ring);\n		border-color: var(--ck-powered-by-border-color);\n	}\n}\n\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-base-foreground: 								hsl(0, 0%, 98%);\n	--ck-color-base-background: 								hsl(0, 0%, 100%);\n	--ck-color-base-border: 									hsl(220, 6%, 81%);\n	--ck-color-base-action: 									hsl(104, 50.2%, 42.5%);\n	--ck-color-base-focus: 										hsl(209, 92%, 70%);\n	--ck-color-base-text: 										hsl(0, 0%, 20%);\n	--ck-color-base-active: 									hsl(218.1, 100%, 58%);\n	--ck-color-base-active-focus:								hsl(218.2, 100%, 52.5%);\n	--ck-color-base-error:										hsl(15, 100%, 43%);\n\n	/* -- Generic colors ------------------------------------------------------------------------ */\n\n	--ck-color-focus-border-coordinates: 						218, 81.8%, 56.9%;\n	--ck-color-focus-border: 									hsl(var(--ck-color-focus-border-coordinates));\n	--ck-color-focus-outer-shadow:								hsl(212.4, 89.3%, 89%);\n	--ck-color-focus-disabled-shadow:							hsla(209, 90%, 72%,.3);\n	--ck-color-focus-error-shadow:								hsla(9,100%,56%,.3);\n	--ck-color-text: 											var(--ck-color-base-text);\n	--ck-color-shadow-drop: 									hsla(0, 0%, 0%, 0.15);\n	--ck-color-shadow-drop-active:								hsla(0, 0%, 0%, 0.2);\n	--ck-color-shadow-inner: 									hsla(0, 0%, 0%, 0.1);\n\n	/* -- Buttons ------------------------------------------------------------------------------- */\n\n	--ck-color-button-default-background: 						transparent;\n	--ck-color-button-default-hover-background: 				hsl(0, 0%, 94.1%);\n	--ck-color-button-default-active-background: 				hsl(0, 0%, 94.1%);\n	--ck-color-button-default-disabled-background: 				transparent;\n\n	--ck-color-button-on-background: 							hsl(212, 100%, 97.1%);\n	--ck-color-button-on-hover-background: 						hsl(211.7, 100%, 92.9%);\n	--ck-color-button-on-active-background: 					hsl(211.7, 100%, 92.9%);\n	--ck-color-button-on-disabled-background: 					hsl(211, 15%, 95%);\n	--ck-color-button-on-color:									hsl(218.1, 100%, 58%);\n\n\n	--ck-color-button-action-background: 						var(--ck-color-base-action);\n	--ck-color-button-action-hover-background: 					hsl(104, 53.2%, 40.2%);\n	--ck-color-button-action-active-background: 				hsl(104, 53.2%, 40.2%);\n	--ck-color-button-action-disabled-background: 				hsl(104, 44%, 58%);\n	--ck-color-button-action-text: 								var(--ck-color-base-background);\n\n	--ck-color-button-save: 									hsl(120, 100%, 27%);\n	--ck-color-button-cancel: 									hsl(15, 100%, 43%);\n\n	--ck-color-switch-button-off-background:					hsl(0, 0%, 57.6%);\n	--ck-color-switch-button-off-hover-background:				hsl(0, 0%, 49%);\n	--ck-color-switch-button-on-background:						var(--ck-color-button-action-background);\n	--ck-color-switch-button-on-hover-background:				hsl(104, 53.2%, 40.2%);\n	--ck-color-switch-button-inner-background:					var(--ck-color-base-background);\n	--ck-color-switch-button-inner-shadow:						hsla(0, 0%, 0%, 0.1);\n\n	/* -- Dropdown ------------------------------------------------------------------------------ */\n\n	--ck-color-dropdown-panel-background: 						var(--ck-color-base-background);\n	--ck-color-dropdown-panel-border: 							var(--ck-color-base-border);\n\n	/* -- Input --------------------------------------------------------------------------------- */\n\n	--ck-color-input-background: 								var(--ck-color-base-background);\n	--ck-color-input-border: 									var(--ck-color-base-border);\n	--ck-color-input-error-border:								var(--ck-color-base-error);\n	--ck-color-input-text: 										var(--ck-color-base-text);\n	--ck-color-input-disabled-background: 						hsl(0, 0%, 95%);\n	--ck-color-input-disabled-border: 							var(--ck-color-base-border);\n	--ck-color-input-disabled-text: 							hsl(0, 0%, 46%);\n\n	/* -- List ---------------------------------------------------------------------------------- */\n\n	--ck-color-list-background: 								var(--ck-color-base-background);\n	--ck-color-list-button-hover-background: 					var(--ck-color-button-default-hover-background);\n	--ck-color-list-button-on-background: 						var(--ck-color-button-on-color);\n	--ck-color-list-button-on-background-focus: 				var(--ck-color-button-on-color);\n	--ck-color-list-button-on-text:								var(--ck-color-base-background);\n\n	/* -- Panel --------------------------------------------------------------------------------- */\n\n	--ck-color-panel-background: 								var(--ck-color-base-background);\n	--ck-color-panel-border: 									var(--ck-color-base-border);\n\n	/* -- Toolbar ------------------------------------------------------------------------------- */\n\n	--ck-color-toolbar-background: 								var(--ck-color-base-background);\n	--ck-color-toolbar-border: 									var(--ck-color-base-border);\n\n	/* -- Tooltip ------------------------------------------------------------------------------- */\n\n	--ck-color-tooltip-background: 								var(--ck-color-base-text);\n	--ck-color-tooltip-text: 									var(--ck-color-base-background);\n\n	/* -- Engine -------------------------------------------------------------------------------- */\n\n	--ck-color-engine-placeholder-text: 						hsl(0, 0%, 44%);\n\n	/* -- Upload -------------------------------------------------------------------------------- */\n\n	--ck-color-upload-bar-background:		 					hsl(209, 92%, 70%);\n\n	/* -- Link -------------------------------------------------------------------------------- */\n\n	--ck-color-link-default:									hsl(240, 100%, 47%);\n	--ck-color-link-selected-background:						hsla(201, 100%, 56%, 0.1);\n	--ck-color-link-fake-selection:								hsla(201, 100%, 56%, 0.3);\n\n	/* -- Search result highlight ---------------------------------------------------------------- */\n\n	--ck-color-highlight-background:							hsl(60, 100%, 50%)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * An opacity value of disabled UI item.\n	 */\n	--ck-disabled-opacity: .5;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * The geometry of the of focused element's outer shadow.\n	 */\n	--ck-focus-outer-shadow-geometry: 0 0 0 3px;\n\n	/**\n	 * A visual style of focused element's outer shadow.\n	 */\n	--ck-focus-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-outer-shadow);\n\n	/**\n	 * A visual style of focused element's outer shadow (when disabled).\n	 */\n	--ck-focus-disabled-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-disabled-shadow);\n\n	/**\n	 * A visual style of focused element's outer shadow (when has errors).\n	 */\n	--ck-focus-error-outer-shadow: var(--ck-focus-outer-shadow-geometry) var(--ck-color-focus-error-shadow);\n\n	/**\n	 * A visual style of focused element's border or outline.\n	 */\n	--ck-focus-ring: 1px solid var(--ck-color-focus-border);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-font-size-base: 13px;\n	--ck-line-height-base: 1.84615;\n	--ck-font-face: Helvetica, Arial, Tahoma, Verdana, Sans-Serif;\n\n	--ck-font-size-tiny: 0.7em;\n	--ck-font-size-small: 0.75em;\n	--ck-font-size-normal: 1em;\n	--ck-font-size-big: 1.4em;\n	--ck-font-size-large: 1.8em;\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/* This is super-important. This is **manually** adjusted so a button without an icon\n	is never smaller than a button with icon, additionally making sure that text-less buttons\n	are perfect squares. The value is also shared by other components which should stay "in-line"\n	with buttons. */\n	--ck-ui-component-min-height: 2.3em;\n}\n\n/**\n * Resets an element, ignoring its children.\n */\n.ck.ck-reset,\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n	/* Do not include inheritable rules here. */\n	margin: 0;\n	padding: 0;\n	border: 0;\n	background: transparent;\n	text-decoration: none;\n	vertical-align: middle;\n	transition: none;\n\n	/* https://github.com/ckeditor/ckeditor5-theme-lark/issues/105 */\n	word-wrap: break-word;\n}\n\n/**\n * Resets an element AND its children.\n */\n.ck.ck-reset_all,\n.ck-reset_all *:not(.ck-reset_all-excluded *) {\n	/* These are rule inherited by all children elements. */\n	border-collapse: collapse;\n	font: normal normal normal var(--ck-font-size-base)/var(--ck-line-height-base) var(--ck-font-face);\n	color: var(--ck-color-text);\n	text-align: left;\n	white-space: nowrap;\n	cursor: auto;\n	float: none;\n}\n\n.ck-reset_all {\n	& .ck-rtl *:not(.ck-reset_all-excluded *) {\n		text-align: right;\n	}\n\n	& iframe:not(.ck-reset_all-excluded *) {\n		/* For IE */\n		vertical-align: inherit;\n	}\n\n	& textarea:not(.ck-reset_all-excluded *) {\n		white-space: pre-wrap;\n	}\n\n	& textarea:not(.ck-reset_all-excluded *),\n	& input[type="text"]:not(.ck-reset_all-excluded *),\n	& input[type="password"]:not(.ck-reset_all-excluded *) {\n		cursor: text;\n	}\n\n	& textarea[disabled]:not(.ck-reset_all-excluded *),\n	& input[type="text"][disabled]:not(.ck-reset_all-excluded *),\n	& input[type="password"][disabled]:not(.ck-reset_all-excluded *) {\n		cursor: default;\n	}\n\n	& fieldset:not(.ck-reset_all-excluded *) {\n		padding: 10px;\n		border: 2px groove hsl(255, 7%, 88%);\n	}\n\n	& button:not(.ck-reset_all-excluded *)::-moz-focus-inner {\n		/* See http://stackoverflow.com/questions/5517744/remove-extra-button-spacing-padding-in-firefox */\n		padding: 0;\n		border: 0\n	}\n}\n\n/**\n * Default UI rules for RTL languages.\n */\n.ck[dir="rtl"],\n.ck[dir="rtl"] .ck {\n	text-align: right;\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * Default border-radius value.\n */\n:root{\n	--ck-border-radius: 2px;\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	/**\n	 * A visual style of element's inner shadow (i.e. input).\n	 */\n	--ck-inner-shadow: 2px 2px 3px var(--ck-color-shadow-inner) inset;\n\n	/**\n	 * A visual style of element's drop shadow (i.e. panel).\n	 */\n	--ck-drop-shadow: 0 1px 2px 1px var(--ck-color-shadow-drop);\n\n	/**\n	 * A visual style of element's active shadow (i.e. comment or suggestion).\n	 */\n	--ck-drop-shadow-active: 0 3px 6px 1px var(--ck-color-shadow-drop-active);\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-spacing-unit: 						0.6em;\n	--ck-spacing-large: 					calc(var(--ck-spacing-unit) * 1.5);\n	--ck-spacing-standard: 					var(--ck-spacing-unit);\n	--ck-spacing-medium: 					calc(var(--ck-spacing-unit) * 0.8);\n	--ck-spacing-small: 					calc(var(--ck-spacing-unit) * 0.5);\n	--ck-spacing-tiny: 						calc(var(--ck-spacing-unit) * 0.3);\n	--ck-spacing-extra-tiny: 				calc(var(--ck-spacing-unit) * 0.16);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 3488: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ":root{--ck-color-resizer:var(--ck-color-focus-border);--ck-color-resizer-tooltip-background:#262626;--ck-color-resizer-tooltip-text:#f2f2f2;--ck-resizer-border-radius:var(--ck-border-radius);--ck-resizer-tooltip-offset:10px;--ck-resizer-tooltip-height:calc(var(--ck-spacing-small)*2 + 10px)}.ck .ck-widget,.ck .ck-widget.ck-widget_with-selection-handle{position:relative}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{position:absolute}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{display:block}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{visibility:visible}.ck .ck-size-view{background:var(--ck-color-resizer-tooltip-background);border:1px solid var(--ck-color-resizer-tooltip-text);border-radius:var(--ck-resizer-border-radius);color:var(--ck-color-resizer-tooltip-text);display:block;font-size:var(--ck-font-size-tiny);height:var(--ck-resizer-tooltip-height);line-height:var(--ck-resizer-tooltip-height);padding:0 var(--ck-spacing-small)}.ck .ck-size-view.ck-orientation-above-center,.ck .ck-size-view.ck-orientation-bottom-left,.ck .ck-size-view.ck-orientation-bottom-right,.ck .ck-size-view.ck-orientation-top-left,.ck .ck-size-view.ck-orientation-top-right{position:absolute}.ck .ck-size-view.ck-orientation-top-left{left:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-top-right{right:var(--ck-resizer-tooltip-offset);top:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-right{bottom:var(--ck-resizer-tooltip-offset);right:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-bottom-left{bottom:var(--ck-resizer-tooltip-offset);left:var(--ck-resizer-tooltip-offset)}.ck .ck-size-view.ck-orientation-above-center{left:50%;top:calc(var(--ck-resizer-tooltip-height)*-1);transform:translate(-50%)}:root{--ck-widget-outline-thickness:3px;--ck-widget-handler-icon-size:16px;--ck-widget-handler-animation-duration:200ms;--ck-widget-handler-animation-curve:ease;--ck-color-widget-blurred-border:#dedede;--ck-color-widget-hover-border:#ffc83d;--ck-color-widget-editable-focus-background:var(--ck-color-base-background);--ck-color-widget-drag-handler-icon-color:var(--ck-color-base-background)}.ck .ck-widget{outline-color:transparent;outline-style:solid;outline-width:var(--ck-widget-outline-thickness);transition:outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_selected,.ck .ck-widget.ck-widget_selected:hover{outline:var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border)}.ck .ck-widget:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-editor__nested-editable{border:1px solid transparent}.ck .ck-editor__nested-editable.ck-editor__nested-editable_focused,.ck .ck-editor__nested-editable:focus{background-color:var(--ck-color-widget-editable-focus-background);border:var(--ck-focus-ring);box-shadow:var(--ck-inner-shadow),0 0;outline:none}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{background-color:transparent;border-radius:var(--ck-border-radius) var(--ck-border-radius) 0 0;box-sizing:border-box;left:calc(0px - var(--ck-widget-outline-thickness));opacity:0;padding:4px;top:0;transform:translateY(-100%);transition:background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon{color:var(--ck-color-widget-drag-handler-icon-color);height:var(--ck-widget-handler-icon-size);width:var(--ck-widget-handler-icon-size)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:0;transition:opacity .3s var(--ck-widget-handler-animation-curve)}.ck .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover .ck-icon .ck-icon__selected-indicator{opacity:1}.ck .ck-widget.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle{background-color:var(--ck-color-widget-hover-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{background-color:var(--ck-color-focus-border);opacity:1}.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator,.ck .ck-widget.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle .ck-icon .ck-icon__selected-indicator{opacity:1}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle{left:auto;right:calc(0px - var(--ck-widget-outline-thickness))}.ck.ck-editor__editable.ck-read-only .ck-widget{transition:none}.ck.ck-editor__editable.ck-read-only .ck-widget:not(.ck-widget_selected){--ck-widget-outline-thickness:0px}.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle,.ck.ck-editor__editable.ck-read-only .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected:hover{outline-color:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle:hover>.ck-widget__selection-handle:hover,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle,.ck.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected.ck-widget_with-selection-handle>.ck-widget__selection-handle:hover{background:var(--ck-color-widget-blurred-border)}.ck.ck-editor__editable blockquote>.ck-widget.ck-widget_with-selection-handle:first-child,.ck.ck-editor__editable>.ck-widget.ck-widget_with-selection-handle:first-child{margin-top:calc(1em + var(--ck-widget-handler-icon-size))}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widget.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widget.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_focus.css", "webpack://./../ckeditor5-theme-lark/theme/mixins/_shadow.css"], names: [], mappings: "AAKA,MACC,+CAAgD,CAChD,6CAAsD,CACtD,uCAAgD,CAEhD,kDAAmD,CACnD,gCAAiC,CACjC,kEACD,CAOA,8DAEC,iBAqBD,CAnBC,4EACC,iBAOD,CALC,qFAGC,aACD,CASD,iLACC,kBACD,CAGD,kBACC,qDAAsD,CAEtD,qDAAsD,CACtD,6CAA8C,CAF9C,0CAA2C,CAI3C,aAAc,CADd,kCAAmC,CAGnC,uCAAwC,CACxC,4CAA6C,CAF7C,iCAsCD,CAlCC,8NAKC,iBACD,CAEA,0CAEC,qCAAsC,CADtC,oCAED,CAEA,2CAEC,sCAAuC,CADvC,oCAED,CAEA,8CACC,uCAAwC,CACxC,sCACD,CAEA,6CACC,uCAAwC,CACxC,qCACD,CAGA,8CAEC,QAAS,CADT,6CAAgD,CAEhD,yBACD,CCjFD,MACC,iCAAkC,CAClC,kCAAmC,CACnC,4CAA6C,CAC7C,wCAAyC,CAEzC,wCAAiD,CACjD,sCAAkD,CAClD,2EAA4E,CAC5E,yEACD,CAEA,eAGC,yBAA0B,CAD1B,mBAAoB,CADpB,gDAAiD,CAGjD,6GAUD,CARC,0EAEC,6EACD,CAEA,qBACC,iDACD,CAGD,gCACC,4BAWD,CAPC,yGAKC,iEAAkE,CCnCnE,2BAA2B,CCF3B,qCAA8B,CDC9B,YDqCA,CAIA,4EAKC,4BAA6B,CAa7B,iEAAkE,CAhBlE,qBAAsB,CAoBtB,mDAAoD,CAhBpD,SAAU,CALV,WAAY,CAsBZ,KAAM,CAFN,2BAA4B,CAT5B,6SAgCD,CAnBC,qFAIC,oDAAqD,CADrD,yCAA0C,CAD1C,wCAWD,CANC,kHACC,SAAU,CAGV,+DACD,CAID,wHACC,SACD,CAID,kFAEC,oDAAqD,CADrD,SAED,CAKC,oMAEC,6CAA8C,CAD9C,SAOD,CAHC,gRACC,SACD,CAOH,qFACC,SAAU,CACV,oDACD,CAGA,gDAEC,eAkBD,CAhBC,yEAOC,iCACD,CAGC,gOAEC,gDACD,CAOD,wIAEC,mDAQD,CALE,ghBAEC,gDACD,CAKH,yKAOC,yDACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-color-resizer: var(--ck-color-focus-border);\n	--ck-color-resizer-tooltip-background: hsl(0, 0%, 15%);\n	--ck-color-resizer-tooltip-text: hsl(0, 0%, 95%);\n\n	--ck-resizer-border-radius: var(--ck-border-radius);\n	--ck-resizer-tooltip-offset: 10px;\n	--ck-resizer-tooltip-height: calc(var(--ck-spacing-small) * 2 + 10px);\n}\n\n.ck .ck-widget {\n	/* This is neccessary for type around UI to be positioned properly. */\n	position: relative;\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n	/* Make the widget wrapper a relative positioning container for the drag handle. */\n	position: relative;\n\n	& .ck-widget__selection-handle {\n		position: absolute;\n\n		& .ck-icon {\n			/* Make sure the icon in not a subject to font-size or line-height to avoid\n			unnecessary spacing around it. */\n			display: block;\n		}\n	}\n\n	/* Show the selection handle on mouse hover over the widget, but not for nested widgets. */\n	&:hover > .ck-widget__selection-handle {\n		visibility: visible;\n	}\n\n	/* Show the selection handle when the widget is selected, but not for nested widgets. */\n	&.ck-widget_selected > .ck-widget__selection-handle {\n		visibility: visible;\n	}\n}\n\n.ck .ck-size-view {\n	background: var(--ck-color-resizer-tooltip-background);\n	color: var(--ck-color-resizer-tooltip-text);\n	border: 1px solid var(--ck-color-resizer-tooltip-text);\n	border-radius: var(--ck-resizer-border-radius);\n	font-size: var(--ck-font-size-tiny);\n	display: block;\n	padding: 0 var(--ck-spacing-small);\n	height: var(--ck-resizer-tooltip-height);\n	line-height: var(--ck-resizer-tooltip-height);\n\n	&.ck-orientation-top-left,\n	&.ck-orientation-top-right,\n	&.ck-orientation-bottom-right,\n	&.ck-orientation-bottom-left,\n	&.ck-orientation-above-center {\n		position: absolute;\n	}\n\n	&.ck-orientation-top-left {\n		top: var(--ck-resizer-tooltip-offset);\n		left: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-top-right {\n		top: var(--ck-resizer-tooltip-offset);\n		right: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-bottom-right {\n		bottom: var(--ck-resizer-tooltip-offset);\n		right: var(--ck-resizer-tooltip-offset);\n	}\n\n	&.ck-orientation-bottom-left {\n		bottom: var(--ck-resizer-tooltip-offset);\n		left: var(--ck-resizer-tooltip-offset);\n	}\n\n	/* Class applied if the widget is too small to contain the size label */\n	&.ck-orientation-above-center {\n		top: calc(var(--ck-resizer-tooltip-height) * -1);\n		left: 50%;\n		transform: translate(-50%);\n	}\n}\n", '/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n@import "../mixins/_focus.css";\n@import "../mixins/_shadow.css";\n\n:root {\n	--ck-widget-outline-thickness: 3px;\n	--ck-widget-handler-icon-size: 16px;\n	--ck-widget-handler-animation-duration: 200ms;\n	--ck-widget-handler-animation-curve: ease;\n\n	--ck-color-widget-blurred-border: hsl(0, 0%, 87%);\n	--ck-color-widget-hover-border: hsl(43, 100%, 62%);\n	--ck-color-widget-editable-focus-background: var(--ck-color-base-background);\n	--ck-color-widget-drag-handler-icon-color: var(--ck-color-base-background);\n}\n\n.ck .ck-widget {\n	outline-width: var(--ck-widget-outline-thickness);\n	outline-style: solid;\n	outline-color: transparent;\n	transition: outline-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		outline: var(--ck-widget-outline-thickness) solid var(--ck-color-focus-border);\n	}\n\n	&:hover {\n		outline-color: var(--ck-color-widget-hover-border);\n	}\n}\n\n.ck .ck-editor__nested-editable {\n	border: 1px solid transparent;\n\n	/* The :focus style is applied before .ck-editor__nested-editable_focused class is rendered in the view.\n	These styles show a different border for a blink of an eye, so `:focus` need to have same styles applied. */\n	&.ck-editor__nested-editable_focused,\n	&:focus {\n		@mixin ck-focus-ring;\n		@mixin ck-box-shadow var(--ck-inner-shadow);\n\n		background-color: var(--ck-color-widget-editable-focus-background);\n	}\n}\n\n.ck .ck-widget.ck-widget_with-selection-handle {\n	& .ck-widget__selection-handle {\n		padding: 4px;\n		box-sizing: border-box;\n\n		/* Background and opacity will be animated as the handler shows up or the widget gets selected. */\n		background-color: transparent;\n		opacity: 0;\n\n		/* Transition:\n		   * background-color for the .ck-widget_selected state change,\n		   * visibility for hiding the handler,\n		   * opacity for the proper look of the icon when the handler disappears. */\n		transition:\n			background-color var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n			visibility var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),\n			opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);\n\n		/* Make only top corners round. */\n		border-radius: var(--ck-border-radius) var(--ck-border-radius) 0 0;\n\n		/* Place the drag handler outside the widget wrapper. */\n		transform: translateY(-100%);\n		left: calc(0px - var(--ck-widget-outline-thickness));\n		top: 0;\n\n		& .ck-icon {\n			/* Make sure the dimensions of the icon are independent of the fon-size of the content. */\n			width: var(--ck-widget-handler-icon-size);\n			height: var(--ck-widget-handler-icon-size);\n			color: var(--ck-color-widget-drag-handler-icon-color);\n\n			/* The "selected" part of the icon is invisible by default */\n			& .ck-icon__selected-indicator {\n				opacity: 0;\n\n				/* Note: The animation is longer on purpose. Simply feels better. */\n				transition: opacity 300ms var(--ck-widget-handler-animation-curve);\n			}\n		}\n\n		/* Advertise using the look of the icon that once clicked the handler, the widget will be selected. */\n		&:hover .ck-icon .ck-icon__selected-indicator {\n			opacity: 1;\n		}\n	}\n\n	/* Show the selection handler on mouse hover over the widget, but not for nested widgets. */\n	&:hover > .ck-widget__selection-handle {\n		opacity: 1;\n		background-color: var(--ck-color-widget-hover-border);\n	}\n\n	/* Show the selection handler when the widget is selected, but not for nested widgets. */\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		& > .ck-widget__selection-handle {\n			opacity: 1;\n			background-color: var(--ck-color-focus-border);\n\n			/* When the widget is selected, notify the user using the proper look of the icon. */\n			& .ck-icon .ck-icon__selected-indicator {\n				opacity: 1;\n			}\n		}\n	}\n}\n\n/* In a RTL environment, align the selection handler to the right side of the widget */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__selection-handle {\n	left: auto;\n	right: calc(0px - var(--ck-widget-outline-thickness));\n}\n\n/* https://github.com/ckeditor/ckeditor5/issues/6415 */\n.ck.ck-editor__editable.ck-read-only .ck-widget {\n	/* Prevent the :hover outline from showing up because of the used outline-color transition. */\n	transition: none;\n\n	&:not(.ck-widget_selected) {\n		/* Disable visual effects of hover/active widget when CKEditor is in readOnly mode.\n		 * See: https://github.com/ckeditor/ckeditor5/issues/1261\n		 *\n		 * Leave the unit because this custom property is used in calc() by other features.\n		 * See: https://github.com/ckeditor/ckeditor5/issues/6775\n		 */\n		--ck-widget-outline-thickness: 0px;\n	}\n\n	&.ck-widget_with-selection-handle {\n		& .ck-widget__selection-handle,\n		& .ck-widget__selection-handle:hover {\n			background: var(--ck-color-widget-blurred-border);\n		}\n	}\n}\n\n/* Style the widget when it\'s selected but the editable it belongs to lost focus. */\n/* stylelint-disable-next-line no-descending-specificity */\n.ck.ck-editor__editable.ck-blurred .ck-widget {\n	&.ck-widget_selected,\n	&.ck-widget_selected:hover {\n		outline-color: var(--ck-color-widget-blurred-border);\n\n		&.ck-widget_with-selection-handle {\n			& > .ck-widget__selection-handle,\n			& > .ck-widget__selection-handle:hover {\n				background: var(--ck-color-widget-blurred-border);\n			}\n		}\n	}\n}\n\n.ck.ck-editor__editable > .ck-widget.ck-widget_with-selection-handle:first-child,\n.ck.ck-editor__editable blockquote > .ck-widget.ck-widget_with-selection-handle:first-child {\n	/* Do not crop selection handler if a widget is a first-child in the blockquote or in the root editable.\n	In fact, anything with overflow: hidden.\n	https://github.com/ckeditor/ckeditor5-block-quote/issues/28\n	https://github.com/ckeditor/ckeditor5-widget/issues/44\n	https://github.com/ckeditor/ckeditor5-widget/issues/66 */\n	margin-top: calc(1em + var(--ck-widget-handler-icon-size));\n}\n', "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A visual style of focused element's border.\n */\n@define-mixin ck-focus-ring {\n	/* Disable native outline. */\n	outline: none;\n	border: var(--ck-focus-ring)\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n/**\n * A helper to combine multiple shadows.\n */\n@define-mixin ck-box-shadow $shadowA, $shadowB: 0 0 {\n	box-shadow: $shadowA, $shadowB;\n}\n\n/**\n * Gives an element a drop shadow so it looks like a floating panel.\n */\n@define-mixin ck-drop-shadow {\n	@mixin ck-box-shadow var(--ck-drop-shadow);\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 8506: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, ".ck .ck-widget_with-resizer{position:relative}.ck .ck-widget__resizer{display:none;left:0;pointer-events:none;position:absolute;top:0}.ck-focused .ck-widget_with-resizer.ck-widget_selected>.ck-widget__resizer{display:block}.ck .ck-widget__resizer__handle{pointer-events:all;position:absolute}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{cursor:nwse-resize}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left,.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{cursor:nesw-resize}:root{--ck-resizer-size:10px;--ck-resizer-offset:calc(var(--ck-resizer-size)/-2 - 2px);--ck-resizer-border-width:1px}.ck .ck-widget__resizer{outline:1px solid var(--ck-color-resizer)}.ck .ck-widget__resizer__handle{background:var(--ck-color-focus-border);border:var(--ck-resizer-border-width) solid #fff;border-radius:var(--ck-resizer-border-radius);height:var(--ck-resizer-size);width:var(--ck-resizer-size)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-left{left:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-top-right{right:var(--ck-resizer-offset);top:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-right{bottom:var(--ck-resizer-offset);right:var(--ck-resizer-offset)}.ck .ck-widget__resizer__handle.ck-widget__resizer__handle-bottom-left{bottom:var(--ck-resizer-offset);left:var(--ck-resizer-offset)}", "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgetresize.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgetresize.css"], names: [], mappings: "AAKA,4BAEC,iBACD,CAEA,wBACC,YAAa,CAMb,MAAO,CAFP,mBAAoB,CAHpB,iBAAkB,CAMlB,KACD,CAGC,2EACC,aACD,CAGD,gCAIC,kBAAmB,CAHnB,iBAcD,CATC,4IAEC,kBACD,CAEA,4IAEC,kBACD,CCpCD,MACC,sBAAuB,CAGvB,yDAAiE,CACjE,6BACD,CAEA,wBACC,yCACD,CAEA,gCAGC,uCAAwC,CACxC,gDAA6D,CAC7D,6CAA8C,CAH9C,6BAA8B,CAD9B,4BAyBD,CAnBC,oEAEC,6BAA8B,CAD9B,4BAED,CAEA,qEAEC,8BAA+B,CAD/B,4BAED,CAEA,wEACC,+BAAgC,CAChC,8BACD,CAEA,uEACC,+BAAgC,CAChC,6BACD", sourcesContent: ["/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n.ck .ck-widget_with-resizer {\n	/* Make the widget wrapper a relative positioning container for the drag handle. */\n	position: relative;\n}\n\n.ck .ck-widget__resizer {\n	display: none;\n	position: absolute;\n\n	/* The wrapper itself should not interfere with the pointer device, only the handles should. */\n	pointer-events: none;\n\n	left: 0;\n	top: 0;\n}\n\n.ck-focused .ck-widget_with-resizer.ck-widget_selected {\n	& > .ck-widget__resizer {\n		display: block;\n	}\n}\n\n.ck .ck-widget__resizer__handle {\n	position: absolute;\n\n	/* Resizers are the only UI elements that should interfere with a pointer device. */\n	pointer-events: all;\n\n	&.ck-widget__resizer__handle-top-left,\n	&.ck-widget__resizer__handle-bottom-right {\n		cursor: nwse-resize;\n	}\n\n	&.ck-widget__resizer__handle-top-right,\n	&.ck-widget__resizer__handle-bottom-left {\n		cursor: nesw-resize;\n	}\n}\n", "/*\n * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n:root {\n	--ck-resizer-size: 10px;\n\n	/* Set the resizer with a 50% offset. */\n	--ck-resizer-offset: calc( ( var(--ck-resizer-size) / -2 ) - 2px);\n	--ck-resizer-border-width: 1px;\n}\n\n.ck .ck-widget__resizer {\n	outline: 1px solid var(--ck-color-resizer);\n}\n\n.ck .ck-widget__resizer__handle {\n	width: var(--ck-resizer-size);\n	height: var(--ck-resizer-size);\n	background: var(--ck-color-focus-border);\n	border: var(--ck-resizer-border-width) solid hsl(0, 0%, 100%);\n	border-radius: var(--ck-resizer-border-radius);\n\n	&.ck-widget__resizer__handle-top-left {\n		top: var(--ck-resizer-offset);\n		left: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-top-right {\n		top: var(--ck-resizer-offset);\n		right: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-bottom-right {\n		bottom: var(--ck-resizer-offset);\n		right: var(--ck-resizer-offset);\n	}\n\n	&.ck-widget__resizer__handle-bottom-left {\n		bottom: var(--ck-resizer-offset);\n		left: var(--ck-resizer-offset);\n	}\n}\n"], sourceRoot: "" }]);
      const a2 = s2;
    }, 4921: (t3, e3, n3) => {
      n3.d(e3, { Z: () => a2 });
      var o3 = n3(1799), i2 = n3.n(o3), r2 = n3(2609), s2 = n3.n(r2)()(i2());
      s2.push([t3.id, '.ck .ck-widget .ck-widget__type-around__button{display:block;overflow:hidden;position:absolute;z-index:var(--ck-z-default)}.ck .ck-widget .ck-widget__type-around__button svg{left:50%;position:absolute;top:50%;z-index:calc(var(--ck-z-default) + 2)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_before{left:min(10%,30px);top:calc(var(--ck-widget-outline-thickness)*-.5);transform:translateY(-50%)}.ck .ck-widget .ck-widget__type-around__button.ck-widget__type-around__button_after{bottom:calc(var(--ck-widget-outline-thickness)*-.5);right:min(10%,30px);transform:translateY(50%)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{content:"";display:block;left:1px;position:absolute;top:1px;z-index:calc(var(--ck-z-default) + 1)}.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:none;left:0;position:absolute;right:0}.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__fake-caret{left:calc(var(--ck-widget-outline-thickness)*-1);right:calc(var(--ck-widget-outline-thickness)*-1)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__fake-caret{display:block;top:calc(var(--ck-widget-outline-thickness)*-1 - 1px)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__fake-caret{bottom:calc(var(--ck-widget-outline-thickness)*-1 - 1px);display:block}.ck.ck-editor__editable.ck-read-only .ck-widget__type-around,.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around,.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around{display:none}:root{--ck-widget-type-around-button-size:20px;--ck-color-widget-type-around-button-active:var(--ck-color-focus-border);--ck-color-widget-type-around-button-hover:var(--ck-color-widget-hover-border);--ck-color-widget-type-around-button-blurred-editable:var(--ck-color-widget-blurred-border);--ck-color-widget-type-around-button-radar-start-alpha:0;--ck-color-widget-type-around-button-radar-end-alpha:.3;--ck-color-widget-type-around-button-icon:var(--ck-color-base-background)}.ck .ck-widget .ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button);border-radius:100px;height:var(--ck-widget-type-around-button-size);opacity:0;pointer-events:none;transition:opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve),background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);width:var(--ck-widget-type-around-button-size)}.ck .ck-widget .ck-widget__type-around__button svg{height:8px;margin-top:1px;transform:translate(-50%,-50%);transition:transform .5s ease;width:10px}.ck .ck-widget .ck-widget__type-around__button svg *{stroke-dasharray:10;stroke-dashoffset:0;fill:none;stroke:var(--ck-color-widget-type-around-button-icon);stroke-width:1.5px;stroke-linecap:round;stroke-linejoin:round}.ck .ck-widget .ck-widget__type-around__button svg line{stroke-dasharray:7}.ck .ck-widget .ck-widget__type-around__button:hover{animation:ck-widget-type-around-button-sonar 1s ease infinite}.ck .ck-widget .ck-widget__type-around__button:hover svg polyline{animation:ck-widget-type-around-arrow-dash 2s linear}.ck .ck-widget .ck-widget__type-around__button:hover svg line{animation:ck-widget-type-around-arrow-tip-dash 2s linear}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:1;pointer-events:auto}.ck .ck-widget:not(.ck-widget_selected)>.ck-widget__type-around>.ck-widget__type-around__button{background:var(--ck-color-widget-type-around-button-hover)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover{background:var(--ck-color-widget-type-around-button-active)}.ck .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:after,.ck .ck-widget>.ck-widget__type-around>.ck-widget__type-around__button:hover:after{background:linear-gradient(135deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.3));border-radius:100px;height:calc(var(--ck-widget-type-around-button-size) - 2px);width:calc(var(--ck-widget-type-around-button-size) - 2px)}.ck .ck-widget.ck-widget_with-selection-handle>.ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:20px}.ck .ck-widget .ck-widget__type-around__fake-caret{animation:ck-widget-type-around-fake-caret-pulse 1s linear infinite normal forwards;background:var(--ck-color-base-text);height:1px;outline:1px solid hsla(0,0%,100%,.5);pointer-events:none}.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_after,.ck .ck-widget.ck-widget_selected.ck-widget_type-around_show-fake-caret_before{outline-color:transparent}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected:hover,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected:hover{outline-color:var(--ck-color-widget-hover-border)}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after>.ck-widget__type-around>.ck-widget__type-around__button,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_after.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_selected.ck-widget_with-resizer>.ck-widget__resizer,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected:hover>.ck-widget__selection-handle,.ck .ck-widget.ck-widget_type-around_show-fake-caret_before.ck-widget_with-selection-handle.ck-widget_selected>.ck-widget__selection-handle{opacity:0}.ck[dir=rtl] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around>.ck-widget__type-around__button_before{margin-left:0;margin-right:20px}.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button,.ck-editor__nested-editable.ck-editor__editable_selected .ck-widget:hover>.ck-widget__type-around>.ck-widget__type-around__button{opacity:0;pointer-events:none}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover){background:var(--ck-color-widget-type-around-button-blurred-editable)}.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected>.ck-widget__type-around>.ck-widget__type-around__button:not(:hover) svg *{stroke:#999}@keyframes ck-widget-type-around-arrow-dash{0%{stroke-dashoffset:10}20%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-arrow-tip-dash{0%,20%{stroke-dashoffset:7}40%,to{stroke-dashoffset:0}}@keyframes ck-widget-type-around-button-sonar{0%{box-shadow:0 0 0 0 hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}50%{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-end-alpha))}to{box-shadow:0 0 0 5px hsla(var(--ck-color-focus-border-coordinates),var(--ck-color-widget-type-around-button-radar-start-alpha))}}@keyframes ck-widget-type-around-fake-caret-pulse{0%{opacity:1}49%{opacity:1}50%{opacity:0}99%{opacity:0}to{opacity:1}}', "", { version: 3, sources: ["webpack://./../ckeditor5-widget/theme/widgettypearound.css", "webpack://./../ckeditor5-theme-lark/theme/ckeditor5-widget/widgettypearound.css"], names: [], mappings: "AASC,+CACC,aAAc,CAEd,eAAgB,CADhB,iBAAkB,CAElB,2BAwBD,CAtBC,mDAGC,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAEA,qFAGC,kBAAoB,CADpB,gDAAoD,CAGpD,0BACD,CAEA,oFAEC,mDAAuD,CACvD,mBAAqB,CAErB,yBACD,CAUA,mLACC,UAAW,CACX,aAAc,CAGd,QAAS,CAFT,iBAAkB,CAClB,OAAQ,CAER,qCACD,CAMD,2EACC,YAAa,CAEb,MAAO,CADP,iBAAkB,CAElB,OACD,CAOA,iFACC,gDAAqD,CACrD,iDACD,CAKA,wHAEC,aAAc,CADd,qDAED,CAKA,uHACC,wDAA6D,CAC7D,aACD,CAoBD,mOACC,YACD,CC3GA,MACC,wCAAyC,CACzC,wEAAyE,CACzE,8EAA+E,CAC/E,2FAA4F,CAC5F,wDAAyD,CACzD,uDAAwD,CACxD,yEACD,CAgBC,+CAGC,oDAAqD,CACrD,mBAAoB,CAFpB,+CAAgD,CAVjD,SAAU,CACV,mBAAoB,CAYnB,uMAAyM,CAJzM,8CAkDD,CA1CC,mDAEC,UAAW,CAGX,cAAe,CAFf,8BAA+B,CAC/B,6BAA8B,CAH9B,UAoBD,CAdC,qDACC,mBAAoB,CACpB,mBAAoB,CAEpB,SAAU,CACV,qDAAsD,CACtD,kBAAmB,CACnB,oBAAqB,CACrB,qBACD,CAEA,wDACC,kBACD,CAGD,qDAIC,6DAcD,CARE,kEACC,oDACD,CAEA,8DACC,wDACD,CAUF,uKAvED,SAAU,CACV,mBAwEC,CAOD,gGACC,0DACD,CAOA,uKAEC,2DAQD,CANC,mLAIC,uEAAkF,CADlF,mBAAoB,CADpB,2DAA4D,CAD5D,0DAID,CAOD,8GACC,gBACD,CAKA,mDAGC,mFAAoF,CAOpF,oCAAqC,CARrC,UAAW,CAOX,oCAAwC,CARxC,mBAUD,CAOC,6JAEC,yBACD,CAUA,yKACC,iDACD,CAMA,uOAlJD,SAAU,CACV,mBAmJC,CAoBA,6yBACC,SACD,CASF,uHACC,aAAc,CACd,iBACD,CAYG,iRAlMF,SAAU,CACV,mBAmME,CAQH,kIACC,qEAKD,CAHC,wIACC,WACD,CAGD,4CACC,GACC,oBACD,CACA,OACC,mBACD,CACD,CAEA,gDACC,OACC,mBACD,CACA,OACC,mBACD,CACD,CAEA,8CACC,GACC,6HACD,CACA,IACC,6HACD,CACA,GACC,+HACD,CACD,CAEA,kDACC,GACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,IACC,SACD,CACA,GACC,SACD,CACD", sourcesContent: [`/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		display: block;
		position: absolute;
		overflow: hidden;
		z-index: var(--ck-z-default);

		& svg {
			position: absolute;
			top: 50%;
			left: 50%;
			z-index: calc(var(--ck-z-default) + 2);
		}

		&.ck-widget__type-around__button_before {
			/* Place it in the middle of the outline */
			top: calc(-0.5 * var(--ck-widget-outline-thickness));
			left: min(10%, 30px);

			transform: translateY(-50%);
		}

		&.ck-widget__type-around__button_after {
			/* Place it in the middle of the outline */
			bottom: calc(-0.5 * var(--ck-widget-outline-thickness));
			right: min(10%, 30px);

			transform: translateY(50%);
		}
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		&::after {
			content: "";
			display: block;
			position: absolute;
			top: 1px;
			left: 1px;
			z-index: calc(var(--ck-z-default) + 1);
		}
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		display: none;
		position: absolute;
		left: 0;
		right: 0;
	}

	/*
	 * When the widget is hovered the "fake caret" would normally be narrower than the
	 * extra outline displayed around the widget. Let's extend the "fake caret" to match
	 * the full width of the widget.
	 */
	&:hover > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		left: calc( -1 * var(--ck-widget-outline-thickness) );
		right: calc( -1 * var(--ck-widget-outline-thickness) );
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed before the widget (backward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_before > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		top: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}

	/*
	 * Styles for the horizontal "fake caret" when it should be displayed after the widget (forward keyboard navigation).
	 */
	&.ck-widget_type-around_show-fake-caret_after > .ck-widget__type-around > .ck-widget__type-around__fake-caret {
		bottom: calc( -1 * var(--ck-widget-outline-thickness) - 1px );
		display: block;
	}
}

/*
 * Integration with the read-only mode of the editor.
 */
.ck.ck-editor__editable.ck-read-only .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the restricted editing mode (feature) of the editor.
 */
.ck.ck-editor__editable.ck-restricted-editing_mode_restricted .ck-widget__type-around {
	display: none;
}

/*
 * Integration with the #isEnabled property of the WidgetTypeAround plugin.
 */
.ck.ck-editor__editable.ck-widget__type-around_disabled .ck-widget__type-around {
	display: none;
}
`, `/*
 * Copyright (c) 2003-2023, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

:root {
	--ck-widget-type-around-button-size: 20px;
	--ck-color-widget-type-around-button-active: var(--ck-color-focus-border);
	--ck-color-widget-type-around-button-hover: var(--ck-color-widget-hover-border);
	--ck-color-widget-type-around-button-blurred-editable: var(--ck-color-widget-blurred-border);
	--ck-color-widget-type-around-button-radar-start-alpha: 0;
	--ck-color-widget-type-around-button-radar-end-alpha: .3;
	--ck-color-widget-type-around-button-icon: var(--ck-color-base-background);
}

@define-mixin ck-widget-type-around-button-visible {
	opacity: 1;
	pointer-events: auto;
}

@define-mixin ck-widget-type-around-button-hidden {
	opacity: 0;
	pointer-events: none;
}

.ck .ck-widget {
	/*
	 * Styles of the type around buttons
	 */
	& .ck-widget__type-around__button {
		width: var(--ck-widget-type-around-button-size);
		height: var(--ck-widget-type-around-button-size);
		background: var(--ck-color-widget-type-around-button);
		border-radius: 100px;
		transition: opacity var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve), background var(--ck-widget-handler-animation-duration) var(--ck-widget-handler-animation-curve);

		@mixin ck-widget-type-around-button-hidden;

		& svg {
			width: 10px;
			height: 8px;
			transform: translate(-50%,-50%);
			transition: transform .5s ease;
			margin-top: 1px;

			& * {
				stroke-dasharray: 10;
				stroke-dashoffset: 0;

				fill: none;
				stroke: var(--ck-color-widget-type-around-button-icon);
				stroke-width: 1.5px;
				stroke-linecap: round;
				stroke-linejoin: round;
			}

			& line {
				stroke-dasharray: 7;
			}
		}

		&:hover {
			/*
			 * Display the "sonar" around the button when hovered.
			 */
			animation: ck-widget-type-around-button-sonar 1s ease infinite;

			/*
			 * Animate active button's icon.
			 */
			& svg {
				& polyline {
					animation: ck-widget-type-around-arrow-dash 2s linear;
				}

				& line {
					animation: ck-widget-type-around-arrow-tip-dash 2s linear;
				}
			}
		}
	}

	/*
	 * Show type around buttons when the widget gets selected or being hovered.
	 */
	&.ck-widget_selected,
	&:hover {
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-visible;
		}
	}

	/*
	 * Styles for the buttons when the widget is NOT selected (but the buttons are visible
	 * and still can be hovered).
	 */
	&:not(.ck-widget_selected) > .ck-widget__type-around > .ck-widget__type-around__button {
		background: var(--ck-color-widget-type-around-button-hover);
	}

	/*
	 * Styles for the buttons when:
	 * - the widget is selected,
	 * - or the button is being hovered (regardless of the widget state).
	 */
	&.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button,
	& > .ck-widget__type-around > .ck-widget__type-around__button:hover {
		background: var(--ck-color-widget-type-around-button-active);

		&::after {
			width: calc(var(--ck-widget-type-around-button-size) - 2px);
			height: calc(var(--ck-widget-type-around-button-size) - 2px);
			border-radius: 100px;
			background: linear-gradient(135deg, hsla(0,0%,100%,0) 0%, hsla(0,0%,100%,.3) 100%);
		}
	}

	/*
	 * Styles for the "before" button when the widget has a selection handle. Because some space
	 * is consumed by the handle, the button must be moved slightly to the right to let it breathe.
	 */
	&.ck-widget_with-selection-handle > .ck-widget__type-around > .ck-widget__type-around__button_before {
		margin-left: 20px;
	}

	/*
	 * Styles for the horizontal "fake caret" which is displayed when the user navigates using the keyboard.
	 */
	& .ck-widget__type-around__fake-caret {
		pointer-events: none;
		height: 1px;
		animation: ck-widget-type-around-fake-caret-pulse linear 1s infinite normal forwards;

		/*
		 * The semi-transparent-outline+background combo improves the contrast
		 * when the background underneath the fake caret is dark.
		 */
		outline: solid 1px hsla(0, 0%, 100%, .5);
		background: var(--ck-color-base-text);
	}

	/*
	 * Styles of the widget when the "fake caret" is blinking (e.g. upon keyboard navigation).
	 * Despite the widget being physically selected in the model, its outline should disappear.
	 */
	&.ck-widget_selected {
		&.ck-widget_type-around_show-fake-caret_before,
		&.ck-widget_type-around_show-fake-caret_after {
			outline-color: transparent;
		}
	}

	&.ck-widget_type-around_show-fake-caret_before,
	&.ck-widget_type-around_show-fake-caret_after {
		/*
		 * When the "fake caret" is visible we simulate that the widget is not selected
		 * (despite being physically selected), so the outline color should be for the
		 * unselected widget.
		 */
		&.ck-widget_selected:hover {
			outline-color: var(--ck-color-widget-hover-border);
		}

		/*
		 * Styles of the type around buttons when the "fake caret" is blinking (e.g. upon keyboard navigation).
		 * In this state, the type around buttons would collide with the fake carets so they should disappear.
		 */
		& > .ck-widget__type-around > .ck-widget__type-around__button {
			@mixin ck-widget-type-around-button-hidden;
		}

		/*
		 * Fake horizontal caret integration with the selection handle. When the caret is visible, simply
		 * hide the handle because it intersects with the caret (and does not make much sense anyway).
		 */
		&.ck-widget_with-selection-handle {
			&.ck-widget_selected,
			&.ck-widget_selected:hover {
				& > .ck-widget__selection-handle {
					opacity: 0
				}
			}
		}

		/*
		 * Fake horizontal caret integration with the resize UI. When the caret is visible, simply
		 * hide the resize UI because it creates too much noise. It can be visible when the user
		 * hovers the widget, though.
		 */
		&.ck-widget_selected.ck-widget_with-resizer > .ck-widget__resizer {
			opacity: 0
		}
	}
}

/*
 * Styles for the "before" button when the widget has a selection handle in an RTL environment.
 * The selection handler is aligned to the right side of the widget so there is no need to create
 * additional space for it next to the "before" button.
 */
.ck[dir="rtl"] .ck-widget.ck-widget_with-selection-handle .ck-widget__type-around > .ck-widget__type-around__button_before {
	margin-left: 0;
	margin-right: 20px;
}

/*
 * Hide type around buttons when the widget is selected as a child of a selected
 * nested editable (e.g. mulit-cell table selection).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/7263.
 */
.ck-editor__nested-editable.ck-editor__editable_selected {
	& .ck-widget {
		&.ck-widget_selected,
		&:hover {
			& > .ck-widget__type-around > .ck-widget__type-around__button {
				@mixin ck-widget-type-around-button-hidden;
			}
		}
	}
}

/*
 * Styles for the buttons when the widget is selected but the user clicked outside of the editor (blurred the editor).
 */
.ck-editor__editable.ck-blurred .ck-widget.ck-widget_selected > .ck-widget__type-around > .ck-widget__type-around__button:not(:hover) {
	background: var(--ck-color-widget-type-around-button-blurred-editable);

	& svg * {
		stroke: hsl(0,0%,60%);
	}
}

@keyframes ck-widget-type-around-arrow-dash {
	0% {
		stroke-dashoffset: 10;
	}
	20%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-arrow-tip-dash {
	0%, 20% {
		stroke-dashoffset: 7;
	}
	40%, 100% {
		stroke-dashoffset: 0;
	}
}

@keyframes ck-widget-type-around-button-sonar {
	0% {
		box-shadow: 0 0 0 0 hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
	50% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-end-alpha));
	}
	100% {
		box-shadow: 0 0 0 5px hsla(var(--ck-color-focus-border-coordinates), var(--ck-color-widget-type-around-button-radar-start-alpha));
	}
}

@keyframes ck-widget-type-around-fake-caret-pulse {
	0% {
		opacity: 1;
	}
	49% {
		opacity: 1;
	}
	50% {
		opacity: 0;
	}
	99% {
		opacity: 0;
	}
	100% {
		opacity: 1;
	}
}
`], sourceRoot: "" }]);
      const a2 = s2;
    }, 2609: (t3) => {
      t3.exports = function(t4) {
        var e3 = [];
        return e3.toString = function() {
          return this.map(function(e4) {
            var n3 = t4(e4);
            return e4[2] ? "@media ".concat(e4[2], " {").concat(n3, "}") : n3;
          }).join("");
        }, e3.i = function(t5, n3, o3) {
          "string" == typeof t5 && (t5 = [[null, t5, ""]]);
          var i2 = {};
          if (o3)
            for (var r2 = 0; r2 < this.length; r2++) {
              var s2 = this[r2][0];
              null != s2 && (i2[s2] = true);
            }
          for (var a2 = 0; a2 < t5.length; a2++) {
            var c2 = [].concat(t5[a2]);
            o3 && i2[c2[0]] || (n3 && (c2[2] ? c2[2] = "".concat(n3, " and ").concat(c2[2]) : c2[2] = n3), e3.push(c2));
          }
        }, e3;
      };
    }, 1799: (t3) => {
      function e3(t4, e4) {
        return function(t5) {
          if (Array.isArray(t5))
            return t5;
        }(t4) || function(t5, e5) {
          var n4 = t5 && ("undefined" != typeof Symbol && t5[Symbol.iterator] || t5["@@iterator"]);
          if (null == n4)
            return;
          var o3, i2, r2 = [], s2 = true, a2 = false;
          try {
            for (n4 = n4.call(t5); !(s2 = (o3 = n4.next()).done) && (r2.push(o3.value), !e5 || r2.length !== e5); s2 = true)
              ;
          } catch (t6) {
            a2 = true, i2 = t6;
          } finally {
            try {
              s2 || null == n4.return || n4.return();
            } finally {
              if (a2)
                throw i2;
            }
          }
          return r2;
        }(t4, e4) || function(t5, e5) {
          if (!t5)
            return;
          if ("string" == typeof t5)
            return n3(t5, e5);
          var o3 = Object.prototype.toString.call(t5).slice(8, -1);
          "Object" === o3 && t5.constructor && (o3 = t5.constructor.name);
          if ("Map" === o3 || "Set" === o3)
            return Array.from(t5);
          if ("Arguments" === o3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o3))
            return n3(t5, e5);
        }(t4, e4) || function() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function n3(t4, e4) {
        (null == e4 || e4 > t4.length) && (e4 = t4.length);
        for (var n4 = 0, o3 = new Array(e4); n4 < e4; n4++)
          o3[n4] = t4[n4];
        return o3;
      }
      t3.exports = function(t4) {
        var n4 = e3(t4, 4), o3 = n4[1], i2 = n4[3];
        if (!i2)
          return o3;
        if ("function" == typeof btoa) {
          var r2 = btoa(unescape(encodeURIComponent(JSON.stringify(i2)))), s2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(r2), a2 = "/*# ".concat(s2, " */"), c2 = i2.sources.map(function(t5) {
            return "/*# sourceURL=".concat(i2.sourceRoot || "").concat(t5, " */");
          });
          return [o3].concat(c2).concat([a2]).join("\n");
        }
        return [o3].join("\n");
      };
    }, 6062: (t3, e3, n3) => {
      var o3, i2 = function() {
        return void 0 === o3 && (o3 = Boolean(window && document && document.all && !window.atob)), o3;
      }, r2 = function() {
        var t4 = {};
        return function(e4) {
          if (void 0 === t4[e4]) {
            var n4 = document.querySelector(e4);
            if (window.HTMLIFrameElement && n4 instanceof window.HTMLIFrameElement)
              try {
                n4 = n4.contentDocument.head;
              } catch (t5) {
                n4 = null;
              }
            t4[e4] = n4;
          }
          return t4[e4];
        };
      }(), s2 = [];
      function a2(t4) {
        for (var e4 = -1, n4 = 0; n4 < s2.length; n4++)
          if (s2[n4].identifier === t4) {
            e4 = n4;
            break;
          }
        return e4;
      }
      function c2(t4, e4) {
        for (var n4 = {}, o4 = [], i3 = 0; i3 < t4.length; i3++) {
          var r3 = t4[i3], c3 = e4.base ? r3[0] + e4.base : r3[0], l3 = n4[c3] || 0, d3 = "".concat(c3, " ").concat(l3);
          n4[c3] = l3 + 1;
          var h3 = a2(d3), u3 = { css: r3[1], media: r3[2], sourceMap: r3[3] };
          -1 !== h3 ? (s2[h3].references++, s2[h3].updater(u3)) : s2.push({ identifier: d3, updater: f2(u3, e4), references: 1 }), o4.push(d3);
        }
        return o4;
      }
      function l2(t4) {
        var e4 = document.createElement("style"), o4 = t4.attributes || {};
        if (void 0 === o4.nonce) {
          var i3 = n3.nc;
          i3 && (o4.nonce = i3);
        }
        if (Object.keys(o4).forEach(function(t5) {
          e4.setAttribute(t5, o4[t5]);
        }), "function" == typeof t4.insert)
          t4.insert(e4);
        else {
          var s3 = r2(t4.insert || "head");
          if (!s3)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          s3.appendChild(e4);
        }
        return e4;
      }
      var d2, h2 = (d2 = [], function(t4, e4) {
        return d2[t4] = e4, d2.filter(Boolean).join("\n");
      });
      function u2(t4, e4, n4, o4) {
        var i3 = n4 ? "" : o4.media ? "@media ".concat(o4.media, " {").concat(o4.css, "}") : o4.css;
        if (t4.styleSheet)
          t4.styleSheet.cssText = h2(e4, i3);
        else {
          var r3 = document.createTextNode(i3), s3 = t4.childNodes;
          s3[e4] && t4.removeChild(s3[e4]), s3.length ? t4.insertBefore(r3, s3[e4]) : t4.appendChild(r3);
        }
      }
      function g2(t4, e4, n4) {
        var o4 = n4.css, i3 = n4.media, r3 = n4.sourceMap;
        if (i3 ? t4.setAttribute("media", i3) : t4.removeAttribute("media"), r3 && "undefined" != typeof btoa && (o4 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r3)))), " */")), t4.styleSheet)
          t4.styleSheet.cssText = o4;
        else {
          for (; t4.firstChild; )
            t4.removeChild(t4.firstChild);
          t4.appendChild(document.createTextNode(o4));
        }
      }
      var p2 = null, m2 = 0;
      function f2(t4, e4) {
        var n4, o4, i3;
        if (e4.singleton) {
          var r3 = m2++;
          n4 = p2 || (p2 = l2(e4)), o4 = u2.bind(null, n4, r3, false), i3 = u2.bind(null, n4, r3, true);
        } else
          n4 = l2(e4), o4 = g2.bind(null, n4, e4), i3 = function() {
            !function(t5) {
              if (null === t5.parentNode)
                return false;
              t5.parentNode.removeChild(t5);
            }(n4);
          };
        return o4(t4), function(e5) {
          if (e5) {
            if (e5.css === t4.css && e5.media === t4.media && e5.sourceMap === t4.sourceMap)
              return;
            o4(t4 = e5);
          } else
            i3();
        };
      }
      t3.exports = function(t4, e4) {
        (e4 = e4 || {}).singleton || "boolean" == typeof e4.singleton || (e4.singleton = i2());
        var n4 = c2(t4 = t4 || [], e4);
        return function(t5) {
          if (t5 = t5 || [], "[object Array]" === Object.prototype.toString.call(t5)) {
            for (var o4 = 0; o4 < n4.length; o4++) {
              var i3 = a2(n4[o4]);
              s2[i3].references--;
            }
            for (var r3 = c2(t5, e4), l3 = 0; l3 < n4.length; l3++) {
              var d3 = a2(n4[l3]);
              0 === s2[d3].references && (s2[d3].updater(), s2.splice(d3, 1));
            }
            n4 = r3;
          }
        };
      };
    } }, e2 = {};
    function n2(o3) {
      var i2 = e2[o3];
      if (void 0 !== i2)
        return i2.exports;
      var r2 = e2[o3] = { id: o3, exports: {} };
      return t2[o3](r2, r2.exports, n2), r2.exports;
    }
    n2.n = (t3) => {
      var e3 = t3 && t3.__esModule ? () => t3.default : () => t3;
      return n2.d(e3, { a: e3 }), e3;
    }, n2.d = (t3, e3) => {
      for (var o3 in e3)
        n2.o(e3, o3) && !n2.o(t3, o3) && Object.defineProperty(t3, o3, { enumerable: true, get: e3[o3] });
    }, n2.o = (t3, e3) => Object.prototype.hasOwnProperty.call(t3, e3), n2.nc = void 0;
    var o2 = {};
    return (() => {
      function t3({ emitter: t4, activator: e4, callback: n3, contextElements: o3 }) {
        t4.listenTo(document, "mousedown", (t5, i3) => {
          if (!e4())
            return;
          const r3 = "function" == typeof i3.composedPath ? i3.composedPath() : [], s3 = "function" == typeof o3 ? o3() : o3;
          for (const t6 of s3)
            if (t6.contains(i3.target) || r3.includes(t6))
              return;
          n3();
        });
      }
      function e3(t4) {
        return class extends t4 {
          disableCssTransitions() {
            this._isCssTransitionsDisabled = true;
          }
          enableCssTransitions() {
            this._isCssTransitionsDisabled = false;
          }
          constructor(...t5) {
            super(...t5), this.set("_isCssTransitionsDisabled", false), this.initializeCssTransitionDisablerMixin();
          }
          initializeCssTransitionDisablerMixin() {
            this.extendTemplate({ attributes: { class: [this.bindTemplate.if("_isCssTransitionsDisabled", "ck-transitions-disabled")] } });
          }
        };
      }
      function i2({ view: t4 }) {
        t4.listenTo(t4.element, "submit", (e4, n3) => {
          n3.preventDefault(), t4.fire("submit");
        }, { useCapture: true });
      }
      n2.d(o2, { default: () => uD });
      const r2 = function() {
        try {
          return navigator.userAgent.toLowerCase();
        } catch (t4) {
          return "";
        }
      }();
      var s2;
      const a2 = { isMac: c2(r2), isWindows: (s2 = r2, s2.indexOf("windows") > -1), isGecko: function(t4) {
        return !!t4.match(/gecko\/\d+/);
      }(r2), isSafari: function(t4) {
        return t4.indexOf(" applewebkit/") > -1 && -1 === t4.indexOf("chrome");
      }(r2), isiOS: function(t4) {
        return !!t4.match(/iphone|ipad/i) || c2(t4) && navigator.maxTouchPoints > 0;
      }(r2), isAndroid: function(t4) {
        return t4.indexOf("android") > -1;
      }(r2), isBlink: function(t4) {
        return t4.indexOf("chrome/") > -1 && t4.indexOf("edge/") < 0;
      }(r2), features: { isRegExpUnicodePropertySupported: function() {
        let t4 = false;
        try {
          t4 = 0 === "ć".search(new RegExp("[\\p{L}]", "u"));
        } catch (t5) {
        }
        return t4;
      }() } };
      function c2(t4) {
        return t4.indexOf("macintosh") > -1;
      }
      function l2(t4, e4, n3, o3) {
        n3 = n3 || function(t5, e5) {
          return t5 === e5;
        };
        const i3 = Array.isArray(t4) ? t4 : Array.prototype.slice.call(t4), r3 = Array.isArray(e4) ? e4 : Array.prototype.slice.call(e4), s3 = function(t5, e5, n4) {
          const o4 = d2(t5, e5, n4);
          if (-1 === o4)
            return { firstIndex: -1, lastIndexOld: -1, lastIndexNew: -1 };
          const i4 = h2(t5, o4), r4 = h2(e5, o4), s4 = d2(i4, r4, n4), a4 = t5.length - s4, c3 = e5.length - s4;
          return { firstIndex: o4, lastIndexOld: a4, lastIndexNew: c3 };
        }(i3, r3, n3), a3 = o3 ? function(t5, e5) {
          const { firstIndex: n4, lastIndexOld: o4, lastIndexNew: i4 } = t5;
          if (-1 === n4)
            return Array(e5).fill("equal");
          let r4 = [];
          n4 > 0 && (r4 = r4.concat(Array(n4).fill("equal")));
          i4 - n4 > 0 && (r4 = r4.concat(Array(i4 - n4).fill("insert")));
          o4 - n4 > 0 && (r4 = r4.concat(Array(o4 - n4).fill("delete")));
          i4 < e5 && (r4 = r4.concat(Array(e5 - i4).fill("equal")));
          return r4;
        }(s3, r3.length) : function(t5, e5) {
          const n4 = [], { firstIndex: o4, lastIndexOld: i4, lastIndexNew: r4 } = e5;
          r4 - o4 > 0 && n4.push({ index: o4, type: "insert", values: t5.slice(o4, r4) });
          i4 - o4 > 0 && n4.push({ index: o4 + (r4 - o4), type: "delete", howMany: i4 - o4 });
          return n4;
        }(r3, s3);
        return a3;
      }
      function d2(t4, e4, n3) {
        for (let o3 = 0; o3 < Math.max(t4.length, e4.length); o3++)
          if (void 0 === t4[o3] || void 0 === e4[o3] || !n3(t4[o3], e4[o3]))
            return o3;
        return -1;
      }
      function h2(t4, e4) {
        return t4.slice(e4).reverse();
      }
      function u2(t4, e4, n3) {
        n3 = n3 || function(t5, e5) {
          return t5 === e5;
        };
        const o3 = t4.length, i3 = e4.length;
        if (o3 > 200 || i3 > 200 || o3 + i3 > 300)
          return u2.fastDiff(t4, e4, n3, true);
        let r3, s3;
        if (i3 < o3) {
          const n4 = t4;
          t4 = e4, e4 = n4, r3 = "delete", s3 = "insert";
        } else
          r3 = "insert", s3 = "delete";
        const a3 = t4.length, c3 = e4.length, l3 = c3 - a3, d3 = {}, h3 = {};
        function g3(o4) {
          const i4 = (void 0 !== h3[o4 - 1] ? h3[o4 - 1] : -1) + 1, l4 = void 0 !== h3[o4 + 1] ? h3[o4 + 1] : -1, u3 = i4 > l4 ? -1 : 1;
          d3[o4 + u3] && (d3[o4] = d3[o4 + u3].slice(0)), d3[o4] || (d3[o4] = []), d3[o4].push(i4 > l4 ? r3 : s3);
          let g4 = Math.max(i4, l4), p4 = g4 - o4;
          for (; p4 < a3 && g4 < c3 && n3(t4[p4], e4[g4]); )
            p4++, g4++, d3[o4].push("equal");
          return g4;
        }
        let p3, m3 = 0;
        do {
          for (p3 = -m3; p3 < l3; p3++)
            h3[p3] = g3(p3);
          for (p3 = l3 + m3; p3 > l3; p3--)
            h3[p3] = g3(p3);
          h3[l3] = g3(l3), m3++;
        } while (h3[l3] !== c3);
        return d3[l3].slice(1);
      }
      u2.fastDiff = l2;
      const g2 = function() {
        return function t4() {
          t4.called = true;
        };
      };
      class p2 {
        constructor(t4, e4) {
          this.source = t4, this.name = e4, this.path = [], this.stop = g2(), this.off = g2();
        }
      }
      const m2 = new Array(256).fill("").map((t4, e4) => ("0" + e4.toString(16)).slice(-2));
      function f2() {
        const t4 = 4294967296 * Math.random() >>> 0, e4 = 4294967296 * Math.random() >>> 0, n3 = 4294967296 * Math.random() >>> 0, o3 = 4294967296 * Math.random() >>> 0;
        return "e" + m2[t4 >> 0 & 255] + m2[t4 >> 8 & 255] + m2[t4 >> 16 & 255] + m2[t4 >> 24 & 255] + m2[e4 >> 0 & 255] + m2[e4 >> 8 & 255] + m2[e4 >> 16 & 255] + m2[e4 >> 24 & 255] + m2[n3 >> 0 & 255] + m2[n3 >> 8 & 255] + m2[n3 >> 16 & 255] + m2[n3 >> 24 & 255] + m2[o3 >> 0 & 255] + m2[o3 >> 8 & 255] + m2[o3 >> 16 & 255] + m2[o3 >> 24 & 255];
      }
      const k2 = { get(t4 = "normal") {
        return "number" != typeof t4 ? this[t4] || this.normal : t4;
      }, highest: 1e5, high: 1e3, normal: 0, low: -1e3, lowest: -1e5 };
      function b2(t4, e4) {
        const n3 = k2.get(e4.priority);
        for (let o3 = 0; o3 < t4.length; o3++)
          if (k2.get(t4[o3].priority) < n3)
            return void t4.splice(o3, 0, e4);
        t4.push(e4);
      }
      const w2 = "https://ckeditor.com/docs/ckeditor5/latest/support/error-codes.html";
      class A2 extends Error {
        constructor(t4, e4, n3) {
          super(function(t5, e5) {
            const n4 = /* @__PURE__ */ new WeakSet(), o3 = (t6, e6) => {
              if ("object" == typeof e6 && null !== e6) {
                if (n4.has(e6))
                  return `[object ${e6.constructor.name}]`;
                n4.add(e6);
              }
              return e6;
            }, i3 = e5 ? ` ${JSON.stringify(e5, o3)}` : "", r3 = v2(t5);
            return t5 + i3 + r3;
          }(t4, n3)), this.name = "CKEditorError", this.context = e4, this.data = n3;
        }
        is(t4) {
          return "CKEditorError" === t4;
        }
        static rethrowUnexpectedError(t4, e4) {
          if (t4.is && t4.is("CKEditorError"))
            throw t4;
          const n3 = new A2(t4.message, e4);
          throw n3.stack = t4.stack, n3;
        }
      }
      function C2(t4, e4) {
        console.warn(...y2(t4, e4));
      }
      function _2(t4, e4) {
        console.error(...y2(t4, e4));
      }
      function v2(t4) {
        return `
Read more: ${w2}#error-${t4}`;
      }
      function y2(t4, e4) {
        const n3 = v2(t4);
        return e4 ? [t4, e4, n3] : [t4, n3];
      }
      const x2 = "40.0.0", E2 = new Date(2023, 9, 4);
      if (globalThis.CKEDITOR_VERSION)
        throw new A2("ckeditor-duplicated-modules", null);
      globalThis.CKEDITOR_VERSION = x2;
      const D2 = Symbol("listeningTo"), S2 = Symbol("emitterId"), I2 = Symbol("delegations"), T2 = M2(Object);
      function M2(t4) {
        if (!t4)
          return T2;
        return class extends t4 {
          on(t5, e4, n3) {
            this.listenTo(this, t5, e4, n3);
          }
          once(t5, e4, n3) {
            let o3 = false;
            this.listenTo(this, t5, (t6, ...n4) => {
              o3 || (o3 = true, t6.off(), e4.call(this, t6, ...n4));
            }, n3);
          }
          off(t5, e4) {
            this.stopListening(this, t5, e4);
          }
          listenTo(t5, e4, n3, o3 = {}) {
            let i3, r3;
            this[D2] || (this[D2] = {});
            const s3 = this[D2];
            N2(t5) || B2(t5);
            const a3 = N2(t5);
            (i3 = s3[a3]) || (i3 = s3[a3] = { emitter: t5, callbacks: {} }), (r3 = i3.callbacks[e4]) || (r3 = i3.callbacks[e4] = []), r3.push(n3), function(t6, e5, n4, o4, i4) {
              e5._addEventListener ? e5._addEventListener(n4, o4, i4) : t6._addEventListener.call(e5, n4, o4, i4);
            }(this, t5, e4, n3, o3);
          }
          stopListening(t5, e4, n3) {
            const o3 = this[D2];
            let i3 = t5 && N2(t5);
            const r3 = o3 && i3 ? o3[i3] : void 0, s3 = r3 && e4 ? r3.callbacks[e4] : void 0;
            if (!(!o3 || t5 && !r3 || e4 && !s3))
              if (n3) {
                j2(this, t5, e4, n3);
                -1 !== s3.indexOf(n3) && (1 === s3.length ? delete r3.callbacks[e4] : j2(this, t5, e4, n3));
              } else if (s3) {
                for (; n3 = s3.pop(); )
                  j2(this, t5, e4, n3);
                delete r3.callbacks[e4];
              } else if (r3) {
                for (e4 in r3.callbacks)
                  this.stopListening(t5, e4);
                delete o3[i3];
              } else {
                for (i3 in o3)
                  this.stopListening(o3[i3].emitter);
                delete this[D2];
              }
          }
          fire(t5, ...e4) {
            try {
              const n3 = t5 instanceof p2 ? t5 : new p2(this, t5), o3 = n3.name;
              let i3 = O2(this, o3);
              if (n3.path.push(this), i3) {
                const t6 = [n3, ...e4];
                i3 = Array.from(i3);
                for (let e5 = 0; e5 < i3.length && (i3[e5].callback.apply(this, t6), n3.off.called && (delete n3.off.called, this._removeEventListener(o3, i3[e5].callback)), !n3.stop.called); e5++)
                  ;
              }
              const r3 = this[I2];
              if (r3) {
                const t6 = r3.get(o3), i4 = r3.get("*");
                t6 && L2(t6, n3, e4), i4 && L2(i4, n3, e4);
              }
              return n3.return;
            } catch (t6) {
              A2.rethrowUnexpectedError(t6, this);
            }
          }
          delegate(...t5) {
            return { to: (e4, n3) => {
              this[I2] || (this[I2] = /* @__PURE__ */ new Map()), t5.forEach((t6) => {
                const o3 = this[I2].get(t6);
                o3 ? o3.set(e4, n3) : this[I2].set(t6, /* @__PURE__ */ new Map([[e4, n3]]));
              });
            } };
          }
          stopDelegating(t5, e4) {
            if (this[I2])
              if (t5)
                if (e4) {
                  const n3 = this[I2].get(t5);
                  n3 && n3.delete(e4);
                } else
                  this[I2].delete(t5);
              else
                this[I2].clear();
          }
          _addEventListener(t5, e4, n3) {
            !function(t6, e5) {
              const n4 = P2(t6);
              if (n4[e5])
                return;
              let o4 = e5, i4 = null;
              const r3 = [];
              for (; "" !== o4 && !n4[o4]; )
                n4[o4] = { callbacks: [], childEvents: [] }, r3.push(n4[o4]), i4 && n4[o4].childEvents.push(i4), i4 = o4, o4 = o4.substr(0, o4.lastIndexOf(":"));
              if ("" !== o4) {
                for (const t7 of r3)
                  t7.callbacks = n4[o4].callbacks.slice();
                n4[o4].childEvents.push(i4);
              }
            }(this, t5);
            const o3 = z2(this, t5), i3 = { callback: e4, priority: k2.get(n3.priority) };
            for (const t6 of o3)
              b2(t6, i3);
          }
          _removeEventListener(t5, e4) {
            const n3 = z2(this, t5);
            for (const t6 of n3)
              for (let n4 = 0; n4 < t6.length; n4++)
                t6[n4].callback == e4 && (t6.splice(n4, 1), n4--);
          }
        };
      }
      function B2(t4, e4) {
        t4[S2] || (t4[S2] = e4 || f2());
      }
      function N2(t4) {
        return t4[S2];
      }
      function P2(t4) {
        return t4._events || Object.defineProperty(t4, "_events", { value: {} }), t4._events;
      }
      function z2(t4, e4) {
        const n3 = P2(t4)[e4];
        if (!n3)
          return [];
        let o3 = [n3.callbacks];
        for (let e5 = 0; e5 < n3.childEvents.length; e5++) {
          const i3 = z2(t4, n3.childEvents[e5]);
          o3 = o3.concat(i3);
        }
        return o3;
      }
      function O2(t4, e4) {
        let n3;
        return t4._events && (n3 = t4._events[e4]) && n3.callbacks.length ? n3.callbacks : e4.indexOf(":") > -1 ? O2(t4, e4.substr(0, e4.lastIndexOf(":"))) : null;
      }
      function L2(t4, e4, n3) {
        for (let [o3, i3] of t4) {
          i3 ? "function" == typeof i3 && (i3 = i3(e4.name)) : i3 = e4.name;
          const t5 = new p2(e4.source, i3);
          t5.path = [...e4.path], o3.fire(t5, ...n3);
        }
      }
      function j2(t4, e4, n3, o3) {
        e4._removeEventListener ? e4._removeEventListener(n3, o3) : t4._removeEventListener.call(e4, n3, o3);
      }
      ["on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t4) => {
        M2[t4] = T2.prototype[t4];
      });
      const R2 = function(t4) {
        var e4 = typeof t4;
        return null != t4 && ("object" == e4 || "function" == e4);
      }, F2 = Symbol("observableProperties"), V2 = Symbol("boundObservables"), H2 = Symbol("boundProperties"), U2 = Symbol("decoratedMethods"), q2 = Symbol("decoratedOriginal"), G2 = W2(M2());
      function W2(t4) {
        if (!t4)
          return G2;
        return class extends t4 {
          set(t5, e4) {
            if (R2(t5))
              return void Object.keys(t5).forEach((e5) => {
                this.set(e5, t5[e5]);
              }, this);
            K2(this);
            const n3 = this[F2];
            if (t5 in this && !n3.has(t5))
              throw new A2("observable-set-cannot-override", this);
            Object.defineProperty(this, t5, { enumerable: true, configurable: true, get: () => n3.get(t5), set(e5) {
              const o3 = n3.get(t5);
              let i3 = this.fire(`set:${t5}`, t5, e5, o3);
              void 0 === i3 && (i3 = e5), o3 === i3 && n3.has(t5) || (n3.set(t5, i3), this.fire(`change:${t5}`, t5, i3, o3));
            } }), this[t5] = e4;
          }
          bind(...t5) {
            if (!t5.length || !Z2(t5))
              throw new A2("observable-bind-wrong-properties", this);
            if (new Set(t5).size !== t5.length)
              throw new A2("observable-bind-duplicate-properties", this);
            K2(this);
            const e4 = this[H2];
            t5.forEach((t6) => {
              if (e4.has(t6))
                throw new A2("observable-bind-rebind", this);
            });
            const n3 = /* @__PURE__ */ new Map();
            return t5.forEach((t6) => {
              const o3 = { property: t6, to: [] };
              e4.set(t6, o3), n3.set(t6, o3);
            }), { to: Y2, toMany: $2, _observable: this, _bindProperties: t5, _to: [], _bindings: n3 };
          }
          unbind(...t5) {
            if (!this[F2])
              return;
            const e4 = this[H2], n3 = this[V2];
            if (t5.length) {
              if (!Z2(t5))
                throw new A2("observable-unbind-wrong-properties", this);
              t5.forEach((t6) => {
                const o3 = e4.get(t6);
                o3 && (o3.to.forEach(([t7, e5]) => {
                  const i3 = n3.get(t7), r3 = i3[e5];
                  r3.delete(o3), r3.size || delete i3[e5], Object.keys(i3).length || (n3.delete(t7), this.stopListening(t7, "change"));
                }), e4.delete(t6));
              });
            } else
              n3.forEach((t6, e5) => {
                this.stopListening(e5, "change");
              }), n3.clear(), e4.clear();
          }
          decorate(t5) {
            K2(this);
            const e4 = this[t5];
            if (!e4)
              throw new A2("observablemixin-cannot-decorate-undefined", this, { object: this, methodName: t5 });
            this.on(t5, (t6, n3) => {
              t6.return = e4.apply(this, n3);
            }), this[t5] = function(...e5) {
              return this.fire(t5, e5);
            }, this[t5][q2] = e4, this[U2] || (this[U2] = []), this[U2].push(t5);
          }
          stopListening(t5, e4, n3) {
            if (!t5 && this[U2]) {
              for (const t6 of this[U2])
                this[t6] = this[t6][q2];
              delete this[U2];
            }
            super.stopListening(t5, e4, n3);
          }
        };
      }
      function K2(t4) {
        t4[F2] || (Object.defineProperty(t4, F2, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(t4, V2, { value: /* @__PURE__ */ new Map() }), Object.defineProperty(t4, H2, { value: /* @__PURE__ */ new Map() }));
      }
      function Y2(...t4) {
        const e4 = function(...t5) {
          if (!t5.length)
            throw new A2("observable-bind-to-parse-error", null);
          const e5 = { to: [] };
          let n4;
          "function" == typeof t5[t5.length - 1] && (e5.callback = t5.pop());
          return t5.forEach((t6) => {
            if ("string" == typeof t6)
              n4.properties.push(t6);
            else {
              if ("object" != typeof t6)
                throw new A2("observable-bind-to-parse-error", null);
              n4 = { observable: t6, properties: [] }, e5.to.push(n4);
            }
          }), e5;
        }(...t4), n3 = Array.from(this._bindings.keys()), o3 = n3.length;
        if (!e4.callback && e4.to.length > 1)
          throw new A2("observable-bind-to-no-callback", this);
        if (o3 > 1 && e4.callback)
          throw new A2("observable-bind-to-extra-callback", this);
        var i3;
        e4.to.forEach((t5) => {
          if (t5.properties.length && t5.properties.length !== o3)
            throw new A2("observable-bind-to-properties-length", this);
          t5.properties.length || (t5.properties = this._bindProperties);
        }), this._to = e4.to, e4.callback && (this._bindings.get(n3[0]).callback = e4.callback), i3 = this._observable, this._to.forEach((t5) => {
          const e5 = i3[V2];
          let n4;
          e5.get(t5.observable) || i3.listenTo(t5.observable, "change", (o4, r3) => {
            n4 = e5.get(t5.observable)[r3], n4 && n4.forEach((t6) => {
              Q2(i3, t6.property);
            });
          });
        }), function(t5) {
          let e5;
          t5._bindings.forEach((n4, o4) => {
            t5._to.forEach((i4) => {
              e5 = i4.properties[n4.callback ? 0 : t5._bindProperties.indexOf(o4)], n4.to.push([i4.observable, e5]), function(t6, e6, n5, o5) {
                const i5 = t6[V2], r3 = i5.get(n5), s3 = r3 || {};
                s3[o5] || (s3[o5] = /* @__PURE__ */ new Set());
                s3[o5].add(e6), r3 || i5.set(n5, s3);
              }(t5._observable, n4, i4.observable, e5);
            });
          });
        }(this), this._bindProperties.forEach((t5) => {
          Q2(this._observable, t5);
        });
      }
      function $2(t4, e4, n3) {
        if (this._bindings.size > 1)
          throw new A2("observable-bind-to-many-not-one-binding", this);
        this.to(...function(t5, e5) {
          const n4 = t5.map((t6) => [t6, e5]);
          return Array.prototype.concat.apply([], n4);
        }(t4, e4), n3);
      }
      function Z2(t4) {
        return t4.every((t5) => "string" == typeof t5);
      }
      function Q2(t4, e4) {
        const n3 = t4[H2].get(e4);
        let o3;
        n3.callback ? o3 = n3.callback.apply(t4, n3.to.map((t5) => t5[0][t5[1]])) : (o3 = n3.to[0], o3 = o3[0][o3[1]]), Object.prototype.hasOwnProperty.call(t4, e4) ? t4[e4] = o3 : t4.set(e4, o3);
      }
      ["set", "bind", "unbind", "decorate", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t4) => {
        W2[t4] = G2.prototype[t4];
      });
      class J2 {
        constructor() {
          this._replacedElements = [];
        }
        replace(t4, e4) {
          this._replacedElements.push({ element: t4, newElement: e4 }), t4.style.display = "none", e4 && t4.parentNode.insertBefore(e4, t4.nextSibling);
        }
        restore() {
          this._replacedElements.forEach(({ element: t4, newElement: e4 }) => {
            t4.style.display = "", e4 && e4.remove();
          }), this._replacedElements = [];
        }
      }
      function X2(t4) {
        let e4 = 0;
        for (const n3 of t4)
          e4++;
        return e4;
      }
      function tt2(t4, e4) {
        const n3 = Math.min(t4.length, e4.length);
        for (let o3 = 0; o3 < n3; o3++)
          if (t4[o3] != e4[o3])
            return o3;
        return t4.length == e4.length ? "same" : t4.length < e4.length ? "prefix" : "extension";
      }
      function et2(t4) {
        return !(!t4 || !t4[Symbol.iterator]);
      }
      const nt2 = "object" == typeof commonjsGlobal && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var ot2 = "object" == typeof self && self && self.Object === Object && self;
      const it2 = nt2 || ot2 || Function("return this")();
      const rt2 = it2.Symbol;
      var st2 = Object.prototype, at2 = st2.hasOwnProperty, ct2 = st2.toString, lt2 = rt2 ? rt2.toStringTag : void 0;
      const dt2 = function(t4) {
        var e4 = at2.call(t4, lt2), n3 = t4[lt2];
        try {
          t4[lt2] = void 0;
          var o3 = true;
        } catch (t5) {
        }
        var i3 = ct2.call(t4);
        return o3 && (e4 ? t4[lt2] = n3 : delete t4[lt2]), i3;
      };
      var ht2 = Object.prototype.toString;
      const ut2 = function(t4) {
        return ht2.call(t4);
      };
      var gt2 = rt2 ? rt2.toStringTag : void 0;
      const pt2 = function(t4) {
        return null == t4 ? void 0 === t4 ? "[object Undefined]" : "[object Null]" : gt2 && gt2 in Object(t4) ? dt2(t4) : ut2(t4);
      };
      const mt2 = Array.isArray;
      const ft2 = function(t4) {
        return null != t4 && "object" == typeof t4;
      };
      const kt2 = function(t4) {
        return "string" == typeof t4 || !mt2(t4) && ft2(t4) && "[object String]" == pt2(t4);
      };
      function bt2(t4, e4, n3 = {}, o3 = []) {
        const i3 = n3 && n3.xmlns, r3 = i3 ? t4.createElementNS(i3, e4) : t4.createElement(e4);
        for (const t5 in n3)
          r3.setAttribute(t5, n3[t5]);
        !kt2(o3) && et2(o3) || (o3 = [o3]);
        for (let e5 of o3)
          kt2(e5) && (e5 = t4.createTextNode(e5)), r3.appendChild(e5);
        return r3;
      }
      const wt2 = function(t4, e4) {
        return function(n3) {
          return t4(e4(n3));
        };
      };
      const At = wt2(Object.getPrototypeOf, Object);
      var Ct2 = Function.prototype, _t5 = Object.prototype, vt2 = Ct2.toString, yt2 = _t5.hasOwnProperty, xt2 = vt2.call(Object);
      const Et2 = function(t4) {
        if (!ft2(t4) || "[object Object]" != pt2(t4))
          return false;
        var e4 = At(t4);
        if (null === e4)
          return true;
        var n3 = yt2.call(e4, "constructor") && e4.constructor;
        return "function" == typeof n3 && n3 instanceof n3 && vt2.call(n3) == xt2;
      };
      const Dt2 = function() {
        this.__data__ = [], this.size = 0;
      };
      const St2 = function(t4, e4) {
        return t4 === e4 || t4 != t4 && e4 != e4;
      };
      const It2 = function(t4, e4) {
        for (var n3 = t4.length; n3--; )
          if (St2(t4[n3][0], e4))
            return n3;
        return -1;
      };
      var Tt2 = Array.prototype.splice;
      const Mt2 = function(t4) {
        var e4 = this.__data__, n3 = It2(e4, t4);
        return !(n3 < 0) && (n3 == e4.length - 1 ? e4.pop() : Tt2.call(e4, n3, 1), --this.size, true);
      };
      const Bt2 = function(t4) {
        var e4 = this.__data__, n3 = It2(e4, t4);
        return n3 < 0 ? void 0 : e4[n3][1];
      };
      const Nt2 = function(t4) {
        return It2(this.__data__, t4) > -1;
      };
      const Pt2 = function(t4, e4) {
        var n3 = this.__data__, o3 = It2(n3, t4);
        return o3 < 0 ? (++this.size, n3.push([t4, e4])) : n3[o3][1] = e4, this;
      };
      function zt2(t4) {
        var e4 = -1, n3 = null == t4 ? 0 : t4.length;
        for (this.clear(); ++e4 < n3; ) {
          var o3 = t4[e4];
          this.set(o3[0], o3[1]);
        }
      }
      zt2.prototype.clear = Dt2, zt2.prototype.delete = Mt2, zt2.prototype.get = Bt2, zt2.prototype.has = Nt2, zt2.prototype.set = Pt2;
      const Ot2 = zt2;
      const Lt2 = function() {
        this.__data__ = new Ot2(), this.size = 0;
      };
      const jt2 = function(t4) {
        var e4 = this.__data__, n3 = e4.delete(t4);
        return this.size = e4.size, n3;
      };
      const Rt2 = function(t4) {
        return this.__data__.get(t4);
      };
      const Ft2 = function(t4) {
        return this.__data__.has(t4);
      };
      const Vt2 = function(t4) {
        if (!R2(t4))
          return false;
        var e4 = pt2(t4);
        return "[object Function]" == e4 || "[object GeneratorFunction]" == e4 || "[object AsyncFunction]" == e4 || "[object Proxy]" == e4;
      };
      const Ht2 = it2["__core-js_shared__"];
      var Ut2 = function() {
        var t4 = /[^.]+$/.exec(Ht2 && Ht2.keys && Ht2.keys.IE_PROTO || "");
        return t4 ? "Symbol(src)_1." + t4 : "";
      }();
      const qt2 = function(t4) {
        return !!Ut2 && Ut2 in t4;
      };
      var Gt2 = Function.prototype.toString;
      const Wt2 = function(t4) {
        if (null != t4) {
          try {
            return Gt2.call(t4);
          } catch (t5) {
          }
          try {
            return t4 + "";
          } catch (t5) {
          }
        }
        return "";
      };
      var Kt2 = /^\[object .+?Constructor\]$/, Yt2 = Function.prototype, $t2 = Object.prototype, Zt2 = Yt2.toString, Qt2 = $t2.hasOwnProperty, Jt2 = RegExp("^" + Zt2.call(Qt2).replace(/[\\^$.*+?()[\]{}|]/g, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      const Xt2 = function(t4) {
        return !(!R2(t4) || qt2(t4)) && (Vt2(t4) ? Jt2 : Kt2).test(Wt2(t4));
      };
      const te2 = function(t4, e4) {
        return null == t4 ? void 0 : t4[e4];
      };
      const ee2 = function(t4, e4) {
        var n3 = te2(t4, e4);
        return Xt2(n3) ? n3 : void 0;
      };
      const ne2 = ee2(it2, "Map");
      const oe2 = ee2(Object, "create");
      const ie2 = function() {
        this.__data__ = oe2 ? oe2(null) : {}, this.size = 0;
      };
      const re2 = function(t4) {
        var e4 = this.has(t4) && delete this.__data__[t4];
        return this.size -= e4 ? 1 : 0, e4;
      };
      var se2 = Object.prototype.hasOwnProperty;
      const ae2 = function(t4) {
        var e4 = this.__data__;
        if (oe2) {
          var n3 = e4[t4];
          return "__lodash_hash_undefined__" === n3 ? void 0 : n3;
        }
        return se2.call(e4, t4) ? e4[t4] : void 0;
      };
      var ce2 = Object.prototype.hasOwnProperty;
      const le2 = function(t4) {
        var e4 = this.__data__;
        return oe2 ? void 0 !== e4[t4] : ce2.call(e4, t4);
      };
      const de2 = function(t4, e4) {
        var n3 = this.__data__;
        return this.size += this.has(t4) ? 0 : 1, n3[t4] = oe2 && void 0 === e4 ? "__lodash_hash_undefined__" : e4, this;
      };
      function he2(t4) {
        var e4 = -1, n3 = null == t4 ? 0 : t4.length;
        for (this.clear(); ++e4 < n3; ) {
          var o3 = t4[e4];
          this.set(o3[0], o3[1]);
        }
      }
      he2.prototype.clear = ie2, he2.prototype.delete = re2, he2.prototype.get = ae2, he2.prototype.has = le2, he2.prototype.set = de2;
      const ue2 = he2;
      const ge2 = function() {
        this.size = 0, this.__data__ = { hash: new ue2(), map: new (ne2 || Ot2)(), string: new ue2() };
      };
      const pe2 = function(t4) {
        var e4 = typeof t4;
        return "string" == e4 || "number" == e4 || "symbol" == e4 || "boolean" == e4 ? "__proto__" !== t4 : null === t4;
      };
      const me2 = function(t4, e4) {
        var n3 = t4.__data__;
        return pe2(e4) ? n3["string" == typeof e4 ? "string" : "hash"] : n3.map;
      };
      const fe2 = function(t4) {
        var e4 = me2(this, t4).delete(t4);
        return this.size -= e4 ? 1 : 0, e4;
      };
      const ke2 = function(t4) {
        return me2(this, t4).get(t4);
      };
      const be2 = function(t4) {
        return me2(this, t4).has(t4);
      };
      const we2 = function(t4, e4) {
        var n3 = me2(this, t4), o3 = n3.size;
        return n3.set(t4, e4), this.size += n3.size == o3 ? 0 : 1, this;
      };
      function Ae2(t4) {
        var e4 = -1, n3 = null == t4 ? 0 : t4.length;
        for (this.clear(); ++e4 < n3; ) {
          var o3 = t4[e4];
          this.set(o3[0], o3[1]);
        }
      }
      Ae2.prototype.clear = ge2, Ae2.prototype.delete = fe2, Ae2.prototype.get = ke2, Ae2.prototype.has = be2, Ae2.prototype.set = we2;
      const Ce2 = Ae2;
      const _e2 = function(t4, e4) {
        var n3 = this.__data__;
        if (n3 instanceof Ot2) {
          var o3 = n3.__data__;
          if (!ne2 || o3.length < 199)
            return o3.push([t4, e4]), this.size = ++n3.size, this;
          n3 = this.__data__ = new Ce2(o3);
        }
        return n3.set(t4, e4), this.size = n3.size, this;
      };
      function ve2(t4) {
        var e4 = this.__data__ = new Ot2(t4);
        this.size = e4.size;
      }
      ve2.prototype.clear = Lt2, ve2.prototype.delete = jt2, ve2.prototype.get = Rt2, ve2.prototype.has = Ft2, ve2.prototype.set = _e2;
      const ye2 = ve2;
      const xe2 = function(t4, e4) {
        for (var n3 = -1, o3 = null == t4 ? 0 : t4.length; ++n3 < o3 && false !== e4(t4[n3], n3, t4); )
          ;
        return t4;
      };
      const Ee2 = function() {
        try {
          var t4 = ee2(Object, "defineProperty");
          return t4({}, "", {}), t4;
        } catch (t5) {
        }
      }();
      const De2 = function(t4, e4, n3) {
        "__proto__" == e4 && Ee2 ? Ee2(t4, e4, { configurable: true, enumerable: true, value: n3, writable: true }) : t4[e4] = n3;
      };
      var Se2 = Object.prototype.hasOwnProperty;
      const Ie2 = function(t4, e4, n3) {
        var o3 = t4[e4];
        Se2.call(t4, e4) && St2(o3, n3) && (void 0 !== n3 || e4 in t4) || De2(t4, e4, n3);
      };
      const Te2 = function(t4, e4, n3, o3) {
        var i3 = !n3;
        n3 || (n3 = {});
        for (var r3 = -1, s3 = e4.length; ++r3 < s3; ) {
          var a3 = e4[r3], c3 = o3 ? o3(n3[a3], t4[a3], a3, n3, t4) : void 0;
          void 0 === c3 && (c3 = t4[a3]), i3 ? De2(n3, a3, c3) : Ie2(n3, a3, c3);
        }
        return n3;
      };
      const Me2 = function(t4, e4) {
        for (var n3 = -1, o3 = Array(t4); ++n3 < t4; )
          o3[n3] = e4(n3);
        return o3;
      };
      const Be2 = function(t4) {
        return ft2(t4) && "[object Arguments]" == pt2(t4);
      };
      var Ne2 = Object.prototype, Pe2 = Ne2.hasOwnProperty, ze2 = Ne2.propertyIsEnumerable;
      const Oe2 = Be2(function() {
        return arguments;
      }()) ? Be2 : function(t4) {
        return ft2(t4) && Pe2.call(t4, "callee") && !ze2.call(t4, "callee");
      };
      const Le2 = function() {
        return false;
      };
      var je2 = exports && !exports.nodeType && exports, Re2 = je2 && true && module && !module.nodeType && module, Fe2 = Re2 && Re2.exports === je2 ? it2.Buffer : void 0;
      const Ve2 = (Fe2 ? Fe2.isBuffer : void 0) || Le2;
      var He2 = /^(?:0|[1-9]\d*)$/;
      const Ue2 = function(t4, e4) {
        var n3 = typeof t4;
        return !!(e4 = null == e4 ? 9007199254740991 : e4) && ("number" == n3 || "symbol" != n3 && He2.test(t4)) && t4 > -1 && t4 % 1 == 0 && t4 < e4;
      };
      const qe2 = function(t4) {
        return "number" == typeof t4 && t4 > -1 && t4 % 1 == 0 && t4 <= 9007199254740991;
      };
      var Ge2 = {};
      Ge2["[object Float32Array]"] = Ge2["[object Float64Array]"] = Ge2["[object Int8Array]"] = Ge2["[object Int16Array]"] = Ge2["[object Int32Array]"] = Ge2["[object Uint8Array]"] = Ge2["[object Uint8ClampedArray]"] = Ge2["[object Uint16Array]"] = Ge2["[object Uint32Array]"] = true, Ge2["[object Arguments]"] = Ge2["[object Array]"] = Ge2["[object ArrayBuffer]"] = Ge2["[object Boolean]"] = Ge2["[object DataView]"] = Ge2["[object Date]"] = Ge2["[object Error]"] = Ge2["[object Function]"] = Ge2["[object Map]"] = Ge2["[object Number]"] = Ge2["[object Object]"] = Ge2["[object RegExp]"] = Ge2["[object Set]"] = Ge2["[object String]"] = Ge2["[object WeakMap]"] = false;
      const We2 = function(t4) {
        return ft2(t4) && qe2(t4.length) && !!Ge2[pt2(t4)];
      };
      const Ke2 = function(t4) {
        return function(e4) {
          return t4(e4);
        };
      };
      var Ye2 = exports && !exports.nodeType && exports, $e2 = Ye2 && true && module && !module.nodeType && module, Ze2 = $e2 && $e2.exports === Ye2 && nt2.process;
      const Qe2 = function() {
        try {
          var t4 = $e2 && $e2.require && $e2.require("util").types;
          return t4 || Ze2 && Ze2.binding && Ze2.binding("util");
        } catch (t5) {
        }
      }();
      var Je2 = Qe2 && Qe2.isTypedArray;
      const Xe2 = Je2 ? Ke2(Je2) : We2;
      var tn2 = Object.prototype.hasOwnProperty;
      const en2 = function(t4, e4) {
        var n3 = mt2(t4), o3 = !n3 && Oe2(t4), i3 = !n3 && !o3 && Ve2(t4), r3 = !n3 && !o3 && !i3 && Xe2(t4), s3 = n3 || o3 || i3 || r3, a3 = s3 ? Me2(t4.length, String) : [], c3 = a3.length;
        for (var l3 in t4)
          !e4 && !tn2.call(t4, l3) || s3 && ("length" == l3 || i3 && ("offset" == l3 || "parent" == l3) || r3 && ("buffer" == l3 || "byteLength" == l3 || "byteOffset" == l3) || Ue2(l3, c3)) || a3.push(l3);
        return a3;
      };
      var nn2 = Object.prototype;
      const on2 = function(t4) {
        var e4 = t4 && t4.constructor;
        return t4 === ("function" == typeof e4 && e4.prototype || nn2);
      };
      const rn2 = wt2(Object.keys, Object);
      var sn = Object.prototype.hasOwnProperty;
      const an2 = function(t4) {
        if (!on2(t4))
          return rn2(t4);
        var e4 = [];
        for (var n3 in Object(t4))
          sn.call(t4, n3) && "constructor" != n3 && e4.push(n3);
        return e4;
      };
      const cn2 = function(t4) {
        return null != t4 && qe2(t4.length) && !Vt2(t4);
      };
      const ln = function(t4) {
        return cn2(t4) ? en2(t4) : an2(t4);
      };
      const dn = function(t4, e4) {
        return t4 && Te2(e4, ln(e4), t4);
      };
      const hn = function(t4) {
        var e4 = [];
        if (null != t4)
          for (var n3 in Object(t4))
            e4.push(n3);
        return e4;
      };
      var un2 = Object.prototype.hasOwnProperty;
      const gn = function(t4) {
        if (!R2(t4))
          return hn(t4);
        var e4 = on2(t4), n3 = [];
        for (var o3 in t4)
          ("constructor" != o3 || !e4 && un2.call(t4, o3)) && n3.push(o3);
        return n3;
      };
      const pn2 = function(t4) {
        return cn2(t4) ? en2(t4, true) : gn(t4);
      };
      const mn = function(t4, e4) {
        return t4 && Te2(e4, pn2(e4), t4);
      };
      var fn2 = exports && !exports.nodeType && exports, kn = fn2 && true && module && !module.nodeType && module, bn = kn && kn.exports === fn2 ? it2.Buffer : void 0, wn = bn ? bn.allocUnsafe : void 0;
      const An = function(t4, e4) {
        if (e4)
          return t4.slice();
        var n3 = t4.length, o3 = wn ? wn(n3) : new t4.constructor(n3);
        return t4.copy(o3), o3;
      };
      const Cn = function(t4, e4) {
        var n3 = -1, o3 = t4.length;
        for (e4 || (e4 = Array(o3)); ++n3 < o3; )
          e4[n3] = t4[n3];
        return e4;
      };
      const _n = function(t4, e4) {
        for (var n3 = -1, o3 = null == t4 ? 0 : t4.length, i3 = 0, r3 = []; ++n3 < o3; ) {
          var s3 = t4[n3];
          e4(s3, n3, t4) && (r3[i3++] = s3);
        }
        return r3;
      };
      const vn = function() {
        return [];
      };
      var yn = Object.prototype.propertyIsEnumerable, xn = Object.getOwnPropertySymbols;
      const En = xn ? function(t4) {
        return null == t4 ? [] : (t4 = Object(t4), _n(xn(t4), function(e4) {
          return yn.call(t4, e4);
        }));
      } : vn;
      const Dn = function(t4, e4) {
        return Te2(t4, En(t4), e4);
      };
      const Sn = function(t4, e4) {
        for (var n3 = -1, o3 = e4.length, i3 = t4.length; ++n3 < o3; )
          t4[i3 + n3] = e4[n3];
        return t4;
      };
      const In = Object.getOwnPropertySymbols ? function(t4) {
        for (var e4 = []; t4; )
          Sn(e4, En(t4)), t4 = At(t4);
        return e4;
      } : vn;
      const Tn = function(t4, e4) {
        return Te2(t4, In(t4), e4);
      };
      const Mn = function(t4, e4, n3) {
        var o3 = e4(t4);
        return mt2(t4) ? o3 : Sn(o3, n3(t4));
      };
      const Bn = function(t4) {
        return Mn(t4, ln, En);
      };
      const Nn = function(t4) {
        return Mn(t4, pn2, In);
      };
      const Pn = ee2(it2, "DataView");
      const zn = ee2(it2, "Promise");
      const On = ee2(it2, "Set");
      const Ln = ee2(it2, "WeakMap");
      var jn = "[object Map]", Rn = "[object Promise]", Fn = "[object Set]", Vn = "[object WeakMap]", Hn = "[object DataView]", Un = Wt2(Pn), qn = Wt2(ne2), Gn = Wt2(zn), Wn = Wt2(On), Kn = Wt2(Ln), Yn = pt2;
      (Pn && Yn(new Pn(new ArrayBuffer(1))) != Hn || ne2 && Yn(new ne2()) != jn || zn && Yn(zn.resolve()) != Rn || On && Yn(new On()) != Fn || Ln && Yn(new Ln()) != Vn) && (Yn = function(t4) {
        var e4 = pt2(t4), n3 = "[object Object]" == e4 ? t4.constructor : void 0, o3 = n3 ? Wt2(n3) : "";
        if (o3)
          switch (o3) {
            case Un:
              return Hn;
            case qn:
              return jn;
            case Gn:
              return Rn;
            case Wn:
              return Fn;
            case Kn:
              return Vn;
          }
        return e4;
      });
      const $n = Yn;
      var Zn = Object.prototype.hasOwnProperty;
      const Qn = function(t4) {
        var e4 = t4.length, n3 = new t4.constructor(e4);
        return e4 && "string" == typeof t4[0] && Zn.call(t4, "index") && (n3.index = t4.index, n3.input = t4.input), n3;
      };
      const Jn = it2.Uint8Array;
      const Xn = function(t4) {
        var e4 = new t4.constructor(t4.byteLength);
        return new Jn(e4).set(new Jn(t4)), e4;
      };
      const to2 = function(t4, e4) {
        var n3 = e4 ? Xn(t4.buffer) : t4.buffer;
        return new t4.constructor(n3, t4.byteOffset, t4.byteLength);
      };
      var eo2 = /\w*$/;
      const no2 = function(t4) {
        var e4 = new t4.constructor(t4.source, eo2.exec(t4));
        return e4.lastIndex = t4.lastIndex, e4;
      };
      var oo2 = rt2 ? rt2.prototype : void 0, io2 = oo2 ? oo2.valueOf : void 0;
      const ro2 = function(t4) {
        return io2 ? Object(io2.call(t4)) : {};
      };
      const so2 = function(t4, e4) {
        var n3 = e4 ? Xn(t4.buffer) : t4.buffer;
        return new t4.constructor(n3, t4.byteOffset, t4.length);
      };
      const ao2 = function(t4, e4, n3) {
        var o3 = t4.constructor;
        switch (e4) {
          case "[object ArrayBuffer]":
            return Xn(t4);
          case "[object Boolean]":
          case "[object Date]":
            return new o3(+t4);
          case "[object DataView]":
            return to2(t4, n3);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return so2(t4, n3);
          case "[object Map]":
          case "[object Set]":
            return new o3();
          case "[object Number]":
          case "[object String]":
            return new o3(t4);
          case "[object RegExp]":
            return no2(t4);
          case "[object Symbol]":
            return ro2(t4);
        }
      };
      var co2 = Object.create;
      const lo2 = function() {
        function t4() {
        }
        return function(e4) {
          if (!R2(e4))
            return {};
          if (co2)
            return co2(e4);
          t4.prototype = e4;
          var n3 = new t4();
          return t4.prototype = void 0, n3;
        };
      }();
      const ho2 = function(t4) {
        return "function" != typeof t4.constructor || on2(t4) ? {} : lo2(At(t4));
      };
      const uo2 = function(t4) {
        return ft2(t4) && "[object Map]" == $n(t4);
      };
      var go2 = Qe2 && Qe2.isMap;
      const po2 = go2 ? Ke2(go2) : uo2;
      const mo2 = function(t4) {
        return ft2(t4) && "[object Set]" == $n(t4);
      };
      var fo2 = Qe2 && Qe2.isSet;
      const ko2 = fo2 ? Ke2(fo2) : mo2;
      var bo2 = "[object Arguments]", wo2 = "[object Function]", Ao2 = "[object Object]", Co2 = {};
      Co2[bo2] = Co2["[object Array]"] = Co2["[object ArrayBuffer]"] = Co2["[object DataView]"] = Co2["[object Boolean]"] = Co2["[object Date]"] = Co2["[object Float32Array]"] = Co2["[object Float64Array]"] = Co2["[object Int8Array]"] = Co2["[object Int16Array]"] = Co2["[object Int32Array]"] = Co2["[object Map]"] = Co2["[object Number]"] = Co2[Ao2] = Co2["[object RegExp]"] = Co2["[object Set]"] = Co2["[object String]"] = Co2["[object Symbol]"] = Co2["[object Uint8Array]"] = Co2["[object Uint8ClampedArray]"] = Co2["[object Uint16Array]"] = Co2["[object Uint32Array]"] = true, Co2["[object Error]"] = Co2[wo2] = Co2["[object WeakMap]"] = false;
      const _o2 = function t4(e4, n3, o3, i3, r3, s3) {
        var a3, c3 = 1 & n3, l3 = 2 & n3, d3 = 4 & n3;
        if (o3 && (a3 = r3 ? o3(e4, i3, r3, s3) : o3(e4)), void 0 !== a3)
          return a3;
        if (!R2(e4))
          return e4;
        var h3 = mt2(e4);
        if (h3) {
          if (a3 = Qn(e4), !c3)
            return Cn(e4, a3);
        } else {
          var u3 = $n(e4), g3 = u3 == wo2 || "[object GeneratorFunction]" == u3;
          if (Ve2(e4))
            return An(e4, c3);
          if (u3 == Ao2 || u3 == bo2 || g3 && !r3) {
            if (a3 = l3 || g3 ? {} : ho2(e4), !c3)
              return l3 ? Tn(e4, mn(a3, e4)) : Dn(e4, dn(a3, e4));
          } else {
            if (!Co2[u3])
              return r3 ? e4 : {};
            a3 = ao2(e4, u3, c3);
          }
        }
        s3 || (s3 = new ye2());
        var p3 = s3.get(e4);
        if (p3)
          return p3;
        s3.set(e4, a3), ko2(e4) ? e4.forEach(function(i4) {
          a3.add(t4(i4, n3, o3, i4, e4, s3));
        }) : po2(e4) && e4.forEach(function(i4, r4) {
          a3.set(r4, t4(i4, n3, o3, r4, e4, s3));
        });
        var m3 = h3 ? void 0 : (d3 ? l3 ? Nn : Bn : l3 ? pn2 : ln)(e4);
        return xe2(m3 || e4, function(i4, r4) {
          m3 && (i4 = e4[r4 = i4]), Ie2(a3, r4, t4(i4, n3, o3, r4, e4, s3));
        }), a3;
      };
      const vo2 = function(t4, e4) {
        return _o2(t4, 5, e4 = "function" == typeof e4 ? e4 : void 0);
      };
      const yo2 = function(t4) {
        return ft2(t4) && 1 === t4.nodeType && !Et2(t4);
      };
      class xo2 {
        constructor(t4, e4) {
          this._config = {}, e4 && this.define(Eo2(e4)), t4 && this._setObjectToTarget(this._config, t4);
        }
        set(t4, e4) {
          this._setToTarget(this._config, t4, e4);
        }
        define(t4, e4) {
          this._setToTarget(this._config, t4, e4, true);
        }
        get(t4) {
          return this._getFromSource(this._config, t4);
        }
        *names() {
          for (const t4 of Object.keys(this._config))
            yield t4;
        }
        _setToTarget(t4, e4, n3, o3 = false) {
          if (Et2(e4))
            return void this._setObjectToTarget(t4, e4, o3);
          const i3 = e4.split(".");
          e4 = i3.pop();
          for (const e5 of i3)
            Et2(t4[e5]) || (t4[e5] = {}), t4 = t4[e5];
          if (Et2(n3))
            return Et2(t4[e4]) || (t4[e4] = {}), t4 = t4[e4], void this._setObjectToTarget(t4, n3, o3);
          o3 && void 0 !== t4[e4] || (t4[e4] = n3);
        }
        _getFromSource(t4, e4) {
          const n3 = e4.split(".");
          e4 = n3.pop();
          for (const e5 of n3) {
            if (!Et2(t4[e5])) {
              t4 = null;
              break;
            }
            t4 = t4[e5];
          }
          return t4 ? Eo2(t4[e4]) : void 0;
        }
        _setObjectToTarget(t4, e4, n3) {
          Object.keys(e4).forEach((o3) => {
            this._setToTarget(t4, o3, e4[o3], n3);
          });
        }
      }
      function Eo2(t4) {
        return vo2(t4, Do2);
      }
      function Do2(t4) {
        return yo2(t4) ? t4 : void 0;
      }
      function So2(t4) {
        if (t4) {
          if (t4.defaultView)
            return t4 instanceof t4.defaultView.Document;
          if (t4.ownerDocument && t4.ownerDocument.defaultView)
            return t4 instanceof t4.ownerDocument.defaultView.Node;
        }
        return false;
      }
      function Io2(t4) {
        const e4 = Object.prototype.toString.apply(t4);
        return "[object Window]" == e4 || "[object global]" == e4;
      }
      const To2 = Mo2(M2());
      function Mo2(t4) {
        if (!t4)
          return To2;
        return class extends t4 {
          listenTo(t5, e4, n3, o3 = {}) {
            if (So2(t5) || Io2(t5)) {
              const i3 = { capture: !!o3.useCapture, passive: !!o3.usePassive }, r3 = this._getProxyEmitter(t5, i3) || new Bo2(t5, i3);
              this.listenTo(r3, e4, n3, o3);
            } else
              super.listenTo(t5, e4, n3, o3);
          }
          stopListening(t5, e4, n3) {
            if (So2(t5) || Io2(t5)) {
              const o3 = this._getAllProxyEmitters(t5);
              for (const t6 of o3)
                this.stopListening(t6, e4, n3);
            } else
              super.stopListening(t5, e4, n3);
          }
          _getProxyEmitter(t5, e4) {
            return function(t6, e5) {
              const n3 = t6[D2];
              return n3 && n3[e5] ? n3[e5].emitter : null;
            }(this, No2(t5, e4));
          }
          _getAllProxyEmitters(t5) {
            return [{ capture: false, passive: false }, { capture: false, passive: true }, { capture: true, passive: false }, { capture: true, passive: true }].map((e4) => this._getProxyEmitter(t5, e4)).filter((t6) => !!t6);
          }
        };
      }
      ["_getProxyEmitter", "_getAllProxyEmitters", "on", "once", "off", "listenTo", "stopListening", "fire", "delegate", "stopDelegating", "_addEventListener", "_removeEventListener"].forEach((t4) => {
        Mo2[t4] = To2.prototype[t4];
      });
      class Bo2 extends M2() {
        constructor(t4, e4) {
          super(), B2(this, No2(t4, e4)), this._domNode = t4, this._options = e4;
        }
        attach(t4) {
          if (this._domListeners && this._domListeners[t4])
            return;
          const e4 = this._createDomListener(t4);
          this._domNode.addEventListener(t4, e4, this._options), this._domListeners || (this._domListeners = {}), this._domListeners[t4] = e4;
        }
        detach(t4) {
          let e4;
          !this._domListeners[t4] || (e4 = this._events[t4]) && e4.callbacks.length || this._domListeners[t4].removeListener();
        }
        _addEventListener(t4, e4, n3) {
          this.attach(t4), M2().prototype._addEventListener.call(this, t4, e4, n3);
        }
        _removeEventListener(t4, e4) {
          M2().prototype._removeEventListener.call(this, t4, e4), this.detach(t4);
        }
        _createDomListener(t4) {
          const e4 = (e5) => {
            this.fire(t4, e5);
          };
          return e4.removeListener = () => {
            this._domNode.removeEventListener(t4, e4, this._options), delete this._domListeners[t4];
          }, e4;
        }
      }
      function No2(t4, e4) {
        let n3 = function(t5) {
          return t5["data-ck-expando"] || (t5["data-ck-expando"] = f2());
        }(t4);
        for (const t5 of Object.keys(e4).sort())
          e4[t5] && (n3 += "-" + t5);
        return n3;
      }
      let Po2;
      try {
        Po2 = { window, document };
      } catch (t4) {
        Po2 = { window: {}, document: {} };
      }
      const zo2 = Po2;
      function Oo2(t4) {
        return "[object Text]" == Object.prototype.toString.call(t4);
      }
      function Lo2(t4) {
        return "[object Range]" == Object.prototype.toString.apply(t4);
      }
      function jo2(t4) {
        const e4 = t4.ownerDocument.defaultView.getComputedStyle(t4);
        return { top: parseInt(e4.borderTopWidth, 10), right: parseInt(e4.borderRightWidth, 10), bottom: parseInt(e4.borderBottomWidth, 10), left: parseInt(e4.borderLeftWidth, 10) };
      }
      function Ro2(t4) {
        return t4 && t4.parentNode ? t4.offsetParent === zo2.document.body ? null : t4.offsetParent : null;
      }
      const Fo2 = ["top", "right", "bottom", "left", "width", "height"];
      class Vo2 {
        constructor(t4) {
          const e4 = Lo2(t4);
          if (Object.defineProperty(this, "_source", { value: t4._source || t4, writable: true, enumerable: false }), qo2(t4) || e4)
            if (e4) {
              const e5 = Vo2.getDomRangeRects(t4);
              Ho2(this, Vo2.getBoundingRect(e5));
            } else
              Ho2(this, t4.getBoundingClientRect());
          else if (Io2(t4)) {
            const { innerWidth: e5, innerHeight: n3 } = t4;
            Ho2(this, { top: 0, right: e5, bottom: n3, left: 0, width: e5, height: n3 });
          } else
            Ho2(this, t4);
        }
        clone() {
          return new Vo2(this);
        }
        moveTo(t4, e4) {
          return this.top = e4, this.right = t4 + this.width, this.bottom = e4 + this.height, this.left = t4, this;
        }
        moveBy(t4, e4) {
          return this.top += e4, this.right += t4, this.left += t4, this.bottom += e4, this;
        }
        getIntersection(t4) {
          const e4 = { top: Math.max(this.top, t4.top), right: Math.min(this.right, t4.right), bottom: Math.min(this.bottom, t4.bottom), left: Math.max(this.left, t4.left), width: 0, height: 0 };
          if (e4.width = e4.right - e4.left, e4.height = e4.bottom - e4.top, e4.width < 0 || e4.height < 0)
            return null;
          {
            const t5 = new Vo2(e4);
            return t5._source = this._source, t5;
          }
        }
        getIntersectionArea(t4) {
          const e4 = this.getIntersection(t4);
          return e4 ? e4.getArea() : 0;
        }
        getArea() {
          return this.width * this.height;
        }
        getVisible() {
          const t4 = this._source;
          let e4 = this.clone();
          if (Uo2(t4))
            return e4;
          let n3, o3 = t4, i3 = t4.parentNode || t4.commonAncestorContainer;
          for (; i3 && !Uo2(i3); ) {
            const t5 = "visible" === ((r3 = i3) instanceof HTMLElement ? r3.ownerDocument.defaultView.getComputedStyle(r3).overflow : "visible");
            o3 instanceof HTMLElement && "absolute" === Go2(o3) && (n3 = o3);
            const s3 = Go2(i3);
            if (t5 || n3 && ("relative" === s3 && t5 || "relative" !== s3)) {
              o3 = i3, i3 = i3.parentNode;
              continue;
            }
            const a3 = new Vo2(i3), c3 = e4.getIntersection(a3);
            if (!c3)
              return null;
            c3.getArea() < e4.getArea() && (e4 = c3), o3 = i3, i3 = i3.parentNode;
          }
          var r3;
          return e4;
        }
        isEqual(t4) {
          for (const e4 of Fo2)
            if (this[e4] !== t4[e4])
              return false;
          return true;
        }
        contains(t4) {
          const e4 = this.getIntersection(t4);
          return !(!e4 || !e4.isEqual(t4));
        }
        toAbsoluteRect() {
          const { scrollX: t4, scrollY: e4 } = zo2.window, n3 = this.clone().moveBy(t4, e4);
          if (qo2(n3._source)) {
            const t5 = Ro2(n3._source);
            t5 && function(t6, e5) {
              const n4 = new Vo2(e5), o3 = jo2(e5);
              let i3 = 0, r3 = 0;
              i3 -= n4.left, r3 -= n4.top, i3 += e5.scrollLeft, r3 += e5.scrollTop, i3 -= o3.left, r3 -= o3.top, t6.moveBy(i3, r3);
            }(n3, t5);
          }
          return n3;
        }
        excludeScrollbarsAndBorders() {
          const t4 = this._source;
          let e4, n3, o3;
          if (Io2(t4))
            e4 = t4.innerWidth - t4.document.documentElement.clientWidth, n3 = t4.innerHeight - t4.document.documentElement.clientHeight, o3 = t4.getComputedStyle(t4.document.documentElement).direction;
          else {
            const i3 = jo2(t4);
            e4 = t4.offsetWidth - t4.clientWidth - i3.left - i3.right, n3 = t4.offsetHeight - t4.clientHeight - i3.top - i3.bottom, o3 = t4.ownerDocument.defaultView.getComputedStyle(t4).direction, this.left += i3.left, this.top += i3.top, this.right -= i3.right, this.bottom -= i3.bottom, this.width = this.right - this.left, this.height = this.bottom - this.top;
          }
          return this.width -= e4, "ltr" === o3 ? this.right -= e4 : this.left += e4, this.height -= n3, this.bottom -= n3, this;
        }
        static getDomRangeRects(t4) {
          const e4 = [], n3 = Array.from(t4.getClientRects());
          if (n3.length)
            for (const t5 of n3)
              e4.push(new Vo2(t5));
          else {
            let n4 = t4.startContainer;
            Oo2(n4) && (n4 = n4.parentNode);
            const o3 = new Vo2(n4.getBoundingClientRect());
            o3.right = o3.left, o3.width = 0, e4.push(o3);
          }
          return e4;
        }
        static getBoundingRect(t4) {
          const e4 = { left: Number.POSITIVE_INFINITY, top: Number.POSITIVE_INFINITY, right: Number.NEGATIVE_INFINITY, bottom: Number.NEGATIVE_INFINITY, width: 0, height: 0 };
          let n3 = 0;
          for (const o3 of t4)
            n3++, e4.left = Math.min(e4.left, o3.left), e4.top = Math.min(e4.top, o3.top), e4.right = Math.max(e4.right, o3.right), e4.bottom = Math.max(e4.bottom, o3.bottom);
          return 0 == n3 ? null : (e4.width = e4.right - e4.left, e4.height = e4.bottom - e4.top, new Vo2(e4));
        }
      }
      function Ho2(t4, e4) {
        for (const n3 of Fo2)
          t4[n3] = e4[n3];
      }
      function Uo2(t4) {
        return !!qo2(t4) && t4 === t4.ownerDocument.body;
      }
      function qo2(t4) {
        return null !== t4 && "object" == typeof t4 && 1 === t4.nodeType && "function" == typeof t4.getBoundingClientRect;
      }
      function Go2(t4) {
        return t4 instanceof HTMLElement ? t4.ownerDocument.defaultView.getComputedStyle(t4).position : "static";
      }
      const Wo2 = class {
        constructor(t4, e4) {
          Wo2._observerInstance || Wo2._createObserver(), this._element = t4, this._callback = e4, Wo2._addElementCallback(t4, e4), Wo2._observerInstance.observe(t4);
        }
        get element() {
          return this._element;
        }
        destroy() {
          Wo2._deleteElementCallback(this._element, this._callback);
        }
        static _addElementCallback(t4, e4) {
          Wo2._elementCallbacks || (Wo2._elementCallbacks = /* @__PURE__ */ new Map());
          let n3 = Wo2._elementCallbacks.get(t4);
          n3 || (n3 = /* @__PURE__ */ new Set(), Wo2._elementCallbacks.set(t4, n3)), n3.add(e4);
        }
        static _deleteElementCallback(t4, e4) {
          const n3 = Wo2._getElementCallbacks(t4);
          n3 && (n3.delete(e4), n3.size || (Wo2._elementCallbacks.delete(t4), Wo2._observerInstance.unobserve(t4))), Wo2._elementCallbacks && !Wo2._elementCallbacks.size && (Wo2._observerInstance = null, Wo2._elementCallbacks = null);
        }
        static _getElementCallbacks(t4) {
          return Wo2._elementCallbacks ? Wo2._elementCallbacks.get(t4) : null;
        }
        static _createObserver() {
          Wo2._observerInstance = new zo2.window.ResizeObserver((t4) => {
            for (const e4 of t4) {
              const t5 = Wo2._getElementCallbacks(e4.target);
              if (t5)
                for (const n3 of t5)
                  n3(e4);
            }
          });
        }
      };
      let Ko2 = Wo2;
      function Yo2(t4, e4) {
        t4 instanceof HTMLTextAreaElement && (t4.value = e4), t4.innerHTML = e4;
      }
      function $o2(t4) {
        return (e4) => e4 + t4;
      }
      function Zo2(t4) {
        let e4 = 0;
        for (; t4.previousSibling; )
          t4 = t4.previousSibling, e4++;
        return e4;
      }
      function Qo2(t4, e4, n3) {
        t4.insertBefore(n3, t4.childNodes[e4] || null);
      }
      function Jo2(t4) {
        return t4 && t4.nodeType === Node.COMMENT_NODE;
      }
      function Xo2(t4) {
        return !!(t4 && t4.getClientRects && t4.getClientRects().length);
      }
      Ko2._observerInstance = null, Ko2._elementCallbacks = null;
      var ti2 = Math.pow;
      function ei2({ element: t4, target: e4, positions: n3, limiter: o3, fitInViewport: i3, viewportOffsetConfig: r3 }) {
        Vt2(e4) && (e4 = e4()), Vt2(o3) && (o3 = o3());
        const s3 = Ro2(t4), a3 = function(t5) {
          t5 = Object.assign({ top: 0, bottom: 0, left: 0, right: 0 }, t5);
          const e5 = new Vo2(zo2.window);
          return e5.top += t5.top, e5.height -= t5.top, e5.bottom -= t5.bottom, e5.height -= t5.bottom, e5;
        }(r3), c3 = new Vo2(t4), l3 = ni2(e4, a3);
        let d3;
        if (!l3 || !a3.getIntersection(l3))
          return null;
        const h3 = { targetRect: l3, elementRect: c3, positionedElementAncestor: s3, viewportRect: a3 };
        if (o3 || i3) {
          if (o3) {
            const t5 = ni2(o3, a3);
            t5 && (h3.limiterRect = t5);
          }
          d3 = function(t5, e5) {
            const { elementRect: n4 } = e5, o4 = n4.getArea(), i4 = t5.map((t6) => new oi2(t6, e5)).filter((t6) => !!t6.name);
            let r4 = 0, s4 = null;
            for (const t6 of i4) {
              const { limiterIntersectionArea: e6, viewportIntersectionArea: n5 } = t6;
              if (e6 === o4)
                return t6;
              const i5 = ti2(n5, 2) + ti2(e6, 2);
              i5 > r4 && (r4 = i5, s4 = t6);
            }
            return s4;
          }(n3, h3);
        } else
          d3 = new oi2(n3[0], h3);
        return d3;
      }
      function ni2(t4, e4) {
        const n3 = new Vo2(t4).getVisible();
        return n3 ? n3.getIntersection(e4) : null;
      }
      class oi2 {
        constructor(t4, e4) {
          const n3 = t4(e4.targetRect, e4.elementRect, e4.viewportRect, e4.limiterRect);
          if (!n3)
            return;
          const { left: o3, top: i3, name: r3, config: s3 } = n3;
          this.name = r3, this.config = s3, this._positioningFunctionCoordinates = { left: o3, top: i3 }, this._options = e4;
        }
        get left() {
          return this._absoluteRect.left;
        }
        get top() {
          return this._absoluteRect.top;
        }
        get limiterIntersectionArea() {
          const t4 = this._options.limiterRect;
          return t4 ? t4.getIntersectionArea(this._rect) : 0;
        }
        get viewportIntersectionArea() {
          return this._options.viewportRect.getIntersectionArea(this._rect);
        }
        get _rect() {
          return this._cachedRect || (this._cachedRect = this._options.elementRect.clone().moveTo(this._positioningFunctionCoordinates.left, this._positioningFunctionCoordinates.top)), this._cachedRect;
        }
        get _absoluteRect() {
          return this._cachedAbsoluteRect || (this._cachedAbsoluteRect = this._rect.toAbsoluteRect()), this._cachedAbsoluteRect;
        }
      }
      function ii2(t4) {
        const e4 = t4.parentNode;
        e4 && e4.removeChild(t4);
      }
      function ri2({ window: t4, rect: e4, alignToTop: n3, forceScroll: o3, viewportOffset: i3 }) {
        const r3 = e4.clone().moveBy(0, i3.bottom), s3 = e4.clone().moveBy(0, -i3.top), a3 = new Vo2(t4).excludeScrollbarsAndBorders(), c3 = n3 && o3, l3 = [s3, r3].every((t5) => a3.contains(t5));
        let { scrollX: d3, scrollY: h3 } = t4;
        const u3 = d3, g3 = h3;
        c3 ? h3 -= a3.top - e4.top + i3.top : l3 || (ci2(s3, a3) ? h3 -= a3.top - e4.top + i3.top : ai2(r3, a3) && (h3 += n3 ? e4.top - a3.top - i3.top : e4.bottom - a3.bottom + i3.bottom)), l3 || (li2(e4, a3) ? d3 -= a3.left - e4.left + i3.left : di2(e4, a3) && (d3 += e4.right - a3.right + i3.right)), d3 == u3 && h3 === g3 || t4.scrollTo(d3, h3);
      }
      function si2({ parent: t4, getRect: e4, alignToTop: n3, forceScroll: o3, ancestorOffset: i3 = 0, limiterElement: r3 }) {
        const s3 = hi2(t4), a3 = n3 && o3;
        let c3, l3, d3;
        const h3 = r3 || s3.document.body;
        for (; t4 != h3; )
          l3 = e4(), c3 = new Vo2(t4).excludeScrollbarsAndBorders(), d3 = c3.contains(l3), a3 ? t4.scrollTop -= c3.top - l3.top + i3 : d3 || (ci2(l3, c3) ? t4.scrollTop -= c3.top - l3.top + i3 : ai2(l3, c3) && (t4.scrollTop += n3 ? l3.top - c3.top - i3 : l3.bottom - c3.bottom + i3)), d3 || (li2(l3, c3) ? t4.scrollLeft -= c3.left - l3.left + i3 : di2(l3, c3) && (t4.scrollLeft += l3.right - c3.right + i3)), t4 = t4.parentNode;
      }
      function ai2(t4, e4) {
        return t4.bottom > e4.bottom;
      }
      function ci2(t4, e4) {
        return t4.top < e4.top;
      }
      function li2(t4, e4) {
        return t4.left < e4.left;
      }
      function di2(t4, e4) {
        return t4.right > e4.right;
      }
      function hi2(t4) {
        return Lo2(t4) ? t4.startContainer.ownerDocument.defaultView : t4.ownerDocument.defaultView;
      }
      function ui2(t4) {
        if (Lo2(t4)) {
          let e4 = t4.commonAncestorContainer;
          return Oo2(e4) && (e4 = e4.parentNode), e4;
        }
        return t4.parentNode;
      }
      function gi2(t4, e4) {
        const n3 = hi2(t4), o3 = new Vo2(t4);
        if (n3 === e4)
          return o3;
        {
          let t5 = n3;
          for (; t5 != e4; ) {
            const e5 = t5.frameElement, n4 = new Vo2(e5).excludeScrollbarsAndBorders();
            o3.moveBy(n4.left, n4.top), t5 = t5.parent;
          }
        }
        return o3;
      }
      const pi2 = { ctrl: "⌃", cmd: "⌘", alt: "⌥", shift: "⇧" }, mi2 = { ctrl: "Ctrl+", alt: "Alt+", shift: "Shift+" }, fi2 = function() {
        const t4 = { arrowleft: 37, arrowup: 38, arrowright: 39, arrowdown: 40, backspace: 8, delete: 46, enter: 13, space: 32, esc: 27, tab: 9, ctrl: 1114112, shift: 2228224, alt: 4456448, cmd: 8912896 };
        for (let e4 = 65; e4 <= 90; e4++) {
          t4[String.fromCharCode(e4).toLowerCase()] = e4;
        }
        for (let e4 = 48; e4 <= 57; e4++)
          t4[e4 - 48] = e4;
        for (let e4 = 112; e4 <= 123; e4++)
          t4["f" + (e4 - 111)] = e4;
        for (const e4 of "`-=[];',./\\")
          t4[e4] = e4.charCodeAt(0);
        return t4;
      }(), ki2 = Object.fromEntries(Object.entries(fi2).map(([t4, e4]) => [e4, t4.charAt(0).toUpperCase() + t4.slice(1)]));
      function bi2(t4) {
        let e4;
        if ("string" == typeof t4) {
          if (e4 = fi2[t4.toLowerCase()], !e4)
            throw new A2("keyboard-unknown-key", null, { key: t4 });
        } else
          e4 = t4.keyCode + (t4.altKey ? fi2.alt : 0) + (t4.ctrlKey ? fi2.ctrl : 0) + (t4.shiftKey ? fi2.shift : 0) + (t4.metaKey ? fi2.cmd : 0);
        return e4;
      }
      function wi2(t4) {
        return "string" == typeof t4 && (t4 = function(t5) {
          return t5.split("+").map((t6) => t6.trim());
        }(t4)), t4.map((t5) => "string" == typeof t5 ? function(t6) {
          if (t6.endsWith("!"))
            return bi2(t6.slice(0, -1));
          const e4 = bi2(t6);
          return (a2.isMac || a2.isiOS) && e4 == fi2.ctrl ? fi2.cmd : e4;
        }(t5) : t5).reduce((t5, e4) => e4 + t5, 0);
      }
      function Ai2(t4) {
        let e4 = wi2(t4);
        return Object.entries(a2.isMac || a2.isiOS ? pi2 : mi2).reduce((t5, [n3, o3]) => (0 != (e4 & fi2[n3]) && (e4 &= ~fi2[n3], t5 += o3), t5), "") + (e4 ? ki2[e4] : "");
      }
      function Ci2(t4, e4) {
        const n3 = "ltr" === e4;
        switch (t4) {
          case fi2.arrowleft:
            return n3 ? "left" : "right";
          case fi2.arrowright:
            return n3 ? "right" : "left";
          case fi2.arrowup:
            return "up";
          case fi2.arrowdown:
            return "down";
        }
      }
      function _i(t4) {
        return Array.isArray(t4) ? t4 : [t4];
      }
      function vi2(t4, e4, n3 = 1) {
        if ("number" != typeof n3)
          throw new A2("translation-service-quantity-not-a-number", null, { quantity: n3 });
        const o3 = Object.keys(zo2.window.CKEDITOR_TRANSLATIONS).length;
        1 === o3 && (t4 = Object.keys(zo2.window.CKEDITOR_TRANSLATIONS)[0]);
        const i3 = e4.id || e4.string;
        if (0 === o3 || !function(t5, e5) {
          return !!zo2.window.CKEDITOR_TRANSLATIONS[t5] && !!zo2.window.CKEDITOR_TRANSLATIONS[t5].dictionary[e5];
        }(t4, i3))
          return 1 !== n3 ? e4.plural : e4.string;
        const r3 = zo2.window.CKEDITOR_TRANSLATIONS[t4].dictionary, s3 = zo2.window.CKEDITOR_TRANSLATIONS[t4].getPluralForm || ((t5) => 1 === t5 ? 0 : 1), a3 = r3[i3];
        if ("string" == typeof a3)
          return a3;
        return a3[Number(s3(n3))];
      }
      zo2.window.CKEDITOR_TRANSLATIONS || (zo2.window.CKEDITOR_TRANSLATIONS = {});
      const yi2 = ["ar", "ara", "fa", "per", "fas", "he", "heb", "ku", "kur", "ug", "uig"];
      function xi2(t4) {
        return yi2.includes(t4) ? "rtl" : "ltr";
      }
      class Ei2 {
        constructor({ uiLanguage: t4 = "en", contentLanguage: e4 } = {}) {
          this.uiLanguage = t4, this.contentLanguage = e4 || this.uiLanguage, this.uiLanguageDirection = xi2(this.uiLanguage), this.contentLanguageDirection = xi2(this.contentLanguage), this.t = (t5, e5) => this._t(t5, e5);
        }
        get language() {
          return console.warn("locale-deprecated-language-property: The Locale#language property has been deprecated and will be removed in the near future. Please use #uiLanguage and #contentLanguage properties instead."), this.uiLanguage;
        }
        _t(t4, e4 = []) {
          e4 = _i(e4), "string" == typeof t4 && (t4 = { string: t4 });
          const n3 = !!t4.plural ? e4[0] : 1;
          return function(t5, e5) {
            return t5.replace(/%(\d+)/g, (t6, n4) => n4 < e5.length ? e5[n4] : t6);
          }(vi2(this.uiLanguage, t4, n3), e4);
        }
      }
      class Di2 extends M2() {
        constructor(t4 = {}, e4 = {}) {
          super();
          const n3 = et2(t4);
          if (n3 || (e4 = t4), this._items = [], this._itemMap = /* @__PURE__ */ new Map(), this._idProperty = e4.idProperty || "id", this._bindToExternalToInternalMap = /* @__PURE__ */ new WeakMap(), this._bindToInternalToExternalMap = /* @__PURE__ */ new WeakMap(), this._skippedIndexesFromExternal = [], n3)
            for (const e5 of t4)
              this._items.push(e5), this._itemMap.set(this._getItemIdBeforeAdding(e5), e5);
        }
        get length() {
          return this._items.length;
        }
        get first() {
          return this._items[0] || null;
        }
        get last() {
          return this._items[this.length - 1] || null;
        }
        add(t4, e4) {
          return this.addMany([t4], e4);
        }
        addMany(t4, e4) {
          if (void 0 === e4)
            e4 = this._items.length;
          else if (e4 > this._items.length || e4 < 0)
            throw new A2("collection-add-item-invalid-index", this);
          let n3 = 0;
          for (const o3 of t4) {
            const t5 = this._getItemIdBeforeAdding(o3), i3 = e4 + n3;
            this._items.splice(i3, 0, o3), this._itemMap.set(t5, o3), this.fire("add", o3, i3), n3++;
          }
          return this.fire("change", { added: t4, removed: [], index: e4 }), this;
        }
        get(t4) {
          let e4;
          if ("string" == typeof t4)
            e4 = this._itemMap.get(t4);
          else {
            if ("number" != typeof t4)
              throw new A2("collection-get-invalid-arg", this);
            e4 = this._items[t4];
          }
          return e4 || null;
        }
        has(t4) {
          if ("string" == typeof t4)
            return this._itemMap.has(t4);
          {
            const e4 = t4[this._idProperty];
            return e4 && this._itemMap.has(e4);
          }
        }
        getIndex(t4) {
          let e4;
          return e4 = "string" == typeof t4 ? this._itemMap.get(t4) : t4, e4 ? this._items.indexOf(e4) : -1;
        }
        remove(t4) {
          const [e4, n3] = this._remove(t4);
          return this.fire("change", { added: [], removed: [e4], index: n3 }), e4;
        }
        map(t4, e4) {
          return this._items.map(t4, e4);
        }
        find(t4, e4) {
          return this._items.find(t4, e4);
        }
        filter(t4, e4) {
          return this._items.filter(t4, e4);
        }
        clear() {
          this._bindToCollection && (this.stopListening(this._bindToCollection), this._bindToCollection = null);
          const t4 = Array.from(this._items);
          for (; this.length; )
            this._remove(0);
          this.fire("change", { added: [], removed: t4, index: 0 });
        }
        bindTo(t4) {
          if (this._bindToCollection)
            throw new A2("collection-bind-to-rebind", this);
          return this._bindToCollection = t4, { as: (t5) => {
            this._setUpBindToBinding((e4) => new t5(e4));
          }, using: (t5) => {
            "function" == typeof t5 ? this._setUpBindToBinding(t5) : this._setUpBindToBinding((e4) => e4[t5]);
          } };
        }
        _setUpBindToBinding(t4) {
          const e4 = this._bindToCollection, n3 = (n4, o3, i3) => {
            const r3 = e4._bindToCollection == this, s3 = e4._bindToInternalToExternalMap.get(o3);
            if (r3 && s3)
              this._bindToExternalToInternalMap.set(o3, s3), this._bindToInternalToExternalMap.set(s3, o3);
            else {
              const n5 = t4(o3);
              if (!n5)
                return void this._skippedIndexesFromExternal.push(i3);
              let r4 = i3;
              for (const t5 of this._skippedIndexesFromExternal)
                i3 > t5 && r4--;
              for (const t5 of e4._skippedIndexesFromExternal)
                r4 >= t5 && r4++;
              this._bindToExternalToInternalMap.set(o3, n5), this._bindToInternalToExternalMap.set(n5, o3), this.add(n5, r4);
              for (let t5 = 0; t5 < e4._skippedIndexesFromExternal.length; t5++)
                r4 <= e4._skippedIndexesFromExternal[t5] && e4._skippedIndexesFromExternal[t5]++;
            }
          };
          for (const t5 of e4)
            n3(0, t5, e4.getIndex(t5));
          this.listenTo(e4, "add", n3), this.listenTo(e4, "remove", (t5, e5, n4) => {
            const o3 = this._bindToExternalToInternalMap.get(e5);
            o3 && this.remove(o3), this._skippedIndexesFromExternal = this._skippedIndexesFromExternal.reduce((t6, e6) => (n4 < e6 && t6.push(e6 - 1), n4 > e6 && t6.push(e6), t6), []);
          });
        }
        _getItemIdBeforeAdding(t4) {
          const e4 = this._idProperty;
          let n3;
          if (e4 in t4) {
            if (n3 = t4[e4], "string" != typeof n3)
              throw new A2("collection-add-invalid-id", this);
            if (this.get(n3))
              throw new A2("collection-add-item-already-exists", this);
          } else
            t4[e4] = n3 = f2();
          return n3;
        }
        _remove(t4) {
          let e4, n3, o3, i3 = false;
          const r3 = this._idProperty;
          if ("string" == typeof t4 ? (n3 = t4, o3 = this._itemMap.get(n3), i3 = !o3, o3 && (e4 = this._items.indexOf(o3))) : "number" == typeof t4 ? (e4 = t4, o3 = this._items[e4], i3 = !o3, o3 && (n3 = o3[r3])) : (o3 = t4, n3 = o3[r3], e4 = this._items.indexOf(o3), i3 = -1 == e4 || !this._itemMap.get(n3)), i3)
            throw new A2("collection-remove-404", this);
          this._items.splice(e4, 1), this._itemMap.delete(n3);
          const s3 = this._bindToInternalToExternalMap.get(o3);
          return this._bindToInternalToExternalMap.delete(o3), this._bindToExternalToInternalMap.delete(s3), this.fire("remove", o3, e4), [o3, e4];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
      }
      function Si2(t4) {
        const e4 = t4.next();
        return e4.done ? null : e4.value;
      }
      class Ii2 extends Mo2(W2()) {
        constructor() {
          super(), this._elements = /* @__PURE__ */ new Set(), this._nextEventLoopTimeout = null, this.set("isFocused", false), this.set("focusedElement", null);
        }
        add(t4) {
          if (this._elements.has(t4))
            throw new A2("focustracker-add-element-already-exist", this);
          this.listenTo(t4, "focus", () => this._focus(t4), { useCapture: true }), this.listenTo(t4, "blur", () => this._blur(), { useCapture: true }), this._elements.add(t4);
        }
        remove(t4) {
          t4 === this.focusedElement && this._blur(), this._elements.has(t4) && (this.stopListening(t4), this._elements.delete(t4));
        }
        destroy() {
          this.stopListening();
        }
        _focus(t4) {
          clearTimeout(this._nextEventLoopTimeout), this.focusedElement = t4, this.isFocused = true;
        }
        _blur() {
          clearTimeout(this._nextEventLoopTimeout), this._nextEventLoopTimeout = setTimeout(() => {
            this.focusedElement = null, this.isFocused = false;
          }, 0);
        }
      }
      class Ti2 {
        constructor() {
          this._listener = new (Mo2())();
        }
        listenTo(t4) {
          this._listener.listenTo(t4, "keydown", (t5, e4) => {
            this._listener.fire("_keydown:" + bi2(e4), e4);
          });
        }
        set(t4, e4, n3 = {}) {
          const o3 = wi2(t4), i3 = n3.priority;
          this._listener.listenTo(this._listener, "_keydown:" + o3, (t5, n4) => {
            e4(n4, () => {
              n4.preventDefault(), n4.stopPropagation(), t5.stop();
            }), t5.return = true;
          }, { priority: i3 });
        }
        press(t4) {
          return !!this._listener.fire("_keydown:" + bi2(t4), t4);
        }
        stopListening(t4) {
          this._listener.stopListening(t4);
        }
        destroy() {
          this.stopListening();
        }
      }
      function Mi2(t4) {
        return et2(t4) ? new Map(t4) : function(t5) {
          const e4 = /* @__PURE__ */ new Map();
          for (const n3 in t5)
            e4.set(n3, t5[n3]);
          return e4;
        }(t4);
      }
      function Bi2(t4, e4) {
        let n3;
        function o3(...i3) {
          o3.cancel(), n3 = setTimeout(() => t4(...i3), e4);
        }
        return o3.cancel = () => {
          clearTimeout(n3);
        }, o3;
      }
      function Ni2(t4, e4) {
        return !!(n3 = t4.charAt(e4 - 1)) && 1 == n3.length && /[\ud800-\udbff]/.test(n3) && function(t5) {
          return !!t5 && 1 == t5.length && /[\udc00-\udfff]/.test(t5);
        }(t4.charAt(e4));
        var n3;
      }
      function Pi2(t4, e4) {
        return !!(n3 = t4.charAt(e4)) && 1 == n3.length && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(n3);
        var n3;
      }
      const zi2 = function() {
        const t4 = [new RegExp("\\p{Emoji}[\\u{E0020}-\\u{E007E}]+\\u{E007F}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}?\\u{20E3}", "u"), new RegExp("\\p{Emoji}\\u{FE0F}", "u"), new RegExp("(?=\\p{General_Category=Other_Symbol})\\p{Emoji}\\p{Emoji_Modifier}*", "u")], e4 = new RegExp("\\p{Regional_Indicator}{2}", "u").source, n3 = "(?:" + t4.map((t5) => t5.source).join("|") + ")";
        return new RegExp(`${e4}|${n3}(?:‍${n3})*`, "ug");
      }();
      function Oi2(t4, e4) {
        const n3 = String(t4).matchAll(zi2);
        return Array.from(n3).some((t5) => t5.index < e4 && e4 < t5.index + t5[0].length);
      }
      class Li2 extends Di2 {
        constructor(t4 = []) {
          super(t4, { idProperty: "viewUid" }), this.on("add", (t5, e4, n3) => {
            this._renderViewIntoCollectionParent(e4, n3);
          }), this.on("remove", (t5, e4) => {
            e4.element && this._parentElement && e4.element.remove();
          }), this._parentElement = null;
        }
        destroy() {
          this.map((t4) => t4.destroy());
        }
        setParent(t4) {
          this._parentElement = t4;
          for (const t5 of this)
            this._renderViewIntoCollectionParent(t5);
        }
        delegate(...t4) {
          if (!t4.length || !t4.every((t5) => "string" == typeof t5))
            throw new A2("ui-viewcollection-delegate-wrong-events", this);
          return { to: (e4) => {
            for (const n3 of this)
              for (const o3 of t4)
                n3.delegate(o3).to(e4);
            this.on("add", (n3, o3) => {
              for (const n4 of t4)
                o3.delegate(n4).to(e4);
            }), this.on("remove", (n3, o3) => {
              for (const n4 of t4)
                o3.stopDelegating(n4, e4);
            });
          } };
        }
        _renderViewIntoCollectionParent(t4, e4) {
          t4.isRendered || t4.render(), t4.element && this._parentElement && this._parentElement.insertBefore(t4.element, this._parentElement.children[e4]);
        }
        remove(t4) {
          return super.remove(t4);
        }
      }
      var ji2 = n2(6062), Ri2 = n2.n(ji2), Fi2 = n2(4793), Vi2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Fi2.Z, Vi2);
      Fi2.Z.locals;
      class Hi2 extends Mo2(W2()) {
        constructor(t4) {
          super(), this.element = null, this.isRendered = false, this.locale = t4, this.t = t4 && t4.t, this._viewCollections = new Di2(), this._unboundChildren = this.createCollection(), this._viewCollections.on("add", (e4, n3) => {
            n3.locale = t4, n3.t = t4 && t4.t;
          }), this.decorate("render");
        }
        get bindTemplate() {
          return this._bindTemplate ? this._bindTemplate : this._bindTemplate = Ui2.bind(this, this);
        }
        createCollection(t4) {
          const e4 = new Li2(t4);
          return this._viewCollections.add(e4), e4;
        }
        registerChild(t4) {
          et2(t4) || (t4 = [t4]);
          for (const e4 of t4)
            this._unboundChildren.add(e4);
        }
        deregisterChild(t4) {
          et2(t4) || (t4 = [t4]);
          for (const e4 of t4)
            this._unboundChildren.remove(e4);
        }
        setTemplate(t4) {
          this.template = new Ui2(t4);
        }
        extendTemplate(t4) {
          Ui2.extend(this.template, t4);
        }
        render() {
          if (this.isRendered)
            throw new A2("ui-view-render-already-rendered", this);
          this.template && (this.element = this.template.render(), this.registerChild(this.template.getViews())), this.isRendered = true;
        }
        destroy() {
          this.stopListening(), this._viewCollections.map((t4) => t4.destroy()), this.template && this.template._revertData && this.template.revert(this.element);
        }
      }
      class Ui2 extends M2() {
        constructor(t4) {
          super(), Object.assign(this, Xi2(Ji2(t4))), this._isRendered = false, this._revertData = null;
        }
        render() {
          const t4 = this._renderNode({ intoFragment: true });
          return this._isRendered = true, t4;
        }
        apply(t4) {
          return this._revertData = { children: [], bindings: [], attributes: {} }, this._renderNode({ node: t4, intoFragment: false, isApplying: true, revertData: this._revertData }), t4;
        }
        revert(t4) {
          if (!this._revertData)
            throw new A2("ui-template-revert-not-applied", [this, t4]);
          this._revertTemplateFromNode(t4, this._revertData);
        }
        *getViews() {
          yield* function* t4(e4) {
            if (e4.children)
              for (const n3 of e4.children)
                rr(n3) ? yield n3 : sr(n3) && (yield* t4(n3));
          }(this);
        }
        static bind(t4, e4) {
          return { to: (n3, o3) => new Gi2({ eventNameOrFunction: n3, attribute: n3, observable: t4, emitter: e4, callback: o3 }), if: (n3, o3, i3) => new Wi2({ observable: t4, emitter: e4, attribute: n3, valueIfTrue: o3, callback: i3 }) };
        }
        static extend(t4, e4) {
          if (t4._isRendered)
            throw new A2("template-extend-render", [this, t4]);
          or(t4, Xi2(Ji2(e4)));
        }
        _renderNode(t4) {
          let e4;
          if (e4 = t4.node ? this.tag && this.text : this.tag ? this.text : !this.text, e4)
            throw new A2("ui-template-wrong-syntax", this);
          return this.text ? this._renderText(t4) : this._renderElement(t4);
        }
        _renderElement(t4) {
          let e4 = t4.node;
          return e4 || (e4 = t4.node = document.createElementNS(this.ns || "http://www.w3.org/1999/xhtml", this.tag)), this._renderAttributes(t4), this._renderElementChildren(t4), this._setUpListeners(t4), e4;
        }
        _renderText(t4) {
          let e4 = t4.node;
          return e4 ? t4.revertData.text = e4.textContent : e4 = t4.node = document.createTextNode(""), Ki2(this.text) ? this._bindToObservable({ schema: this.text, updater: $i2(e4), data: t4 }) : e4.textContent = this.text.join(""), e4;
        }
        _renderAttributes(t4) {
          if (!this.attributes)
            return;
          const e4 = t4.node, n3 = t4.revertData;
          for (const o3 in this.attributes) {
            const i3 = e4.getAttribute(o3), r3 = this.attributes[o3];
            n3 && (n3.attributes[o3] = i3);
            const s3 = cr(r3) ? r3[0].ns : null;
            if (Ki2(r3)) {
              const a3 = cr(r3) ? r3[0].value : r3;
              n3 && lr(o3) && a3.unshift(i3), this._bindToObservable({ schema: a3, updater: Zi2(e4, o3, s3), data: t4 });
            } else if ("style" == o3 && "string" != typeof r3[0])
              this._renderStyleAttribute(r3[0], t4);
            else {
              n3 && i3 && lr(o3) && r3.unshift(i3);
              const t5 = r3.map((t6) => t6 && t6.value || t6).reduce((t6, e5) => t6.concat(e5), []).reduce(er, "");
              ir(t5) || e4.setAttributeNS(s3, o3, t5);
            }
          }
        }
        _renderStyleAttribute(t4, e4) {
          const n3 = e4.node;
          for (const o3 in t4) {
            const i3 = t4[o3];
            Ki2(i3) ? this._bindToObservable({ schema: [i3], updater: Qi2(n3, o3), data: e4 }) : n3.style[o3] = i3;
          }
        }
        _renderElementChildren(t4) {
          const e4 = t4.node, n3 = t4.intoFragment ? document.createDocumentFragment() : e4, o3 = t4.isApplying;
          let i3 = 0;
          for (const r3 of this.children)
            if (ar(r3)) {
              if (!o3) {
                r3.setParent(e4);
                for (const t5 of r3)
                  n3.appendChild(t5.element);
              }
            } else if (rr(r3))
              o3 || (r3.isRendered || r3.render(), n3.appendChild(r3.element));
            else if (So2(r3))
              n3.appendChild(r3);
            else if (o3) {
              const e5 = { children: [], bindings: [], attributes: {} };
              t4.revertData.children.push(e5), r3._renderNode({ intoFragment: false, node: n3.childNodes[i3++], isApplying: true, revertData: e5 });
            } else
              n3.appendChild(r3.render());
          t4.intoFragment && e4.appendChild(n3);
        }
        _setUpListeners(t4) {
          if (this.eventListeners)
            for (const e4 in this.eventListeners) {
              const n3 = this.eventListeners[e4].map((n4) => {
                const [o3, i3] = e4.split("@");
                return n4.activateDomEventListener(o3, i3, t4);
              });
              t4.revertData && t4.revertData.bindings.push(n3);
            }
        }
        _bindToObservable({ schema: t4, updater: e4, data: n3 }) {
          const o3 = n3.revertData;
          Yi2(t4, e4, n3);
          const i3 = t4.filter((t5) => !ir(t5)).filter((t5) => t5.observable).map((o4) => o4.activateAttributeListener(t4, e4, n3));
          o3 && o3.bindings.push(i3);
        }
        _revertTemplateFromNode(t4, e4) {
          for (const t5 of e4.bindings)
            for (const e5 of t5)
              e5();
          if (e4.text)
            return void (t4.textContent = e4.text);
          const n3 = t4;
          for (const t5 in e4.attributes) {
            const o3 = e4.attributes[t5];
            null === o3 ? n3.removeAttribute(t5) : n3.setAttribute(t5, o3);
          }
          for (let t5 = 0; t5 < e4.children.length; ++t5)
            this._revertTemplateFromNode(n3.childNodes[t5], e4.children[t5]);
        }
      }
      class qi2 {
        constructor(t4) {
          this.attribute = t4.attribute, this.observable = t4.observable, this.emitter = t4.emitter, this.callback = t4.callback;
        }
        getValue(t4) {
          const e4 = this.observable[this.attribute];
          return this.callback ? this.callback(e4, t4) : e4;
        }
        activateAttributeListener(t4, e4, n3) {
          const o3 = () => Yi2(t4, e4, n3);
          return this.emitter.listenTo(this.observable, `change:${this.attribute}`, o3), () => {
            this.emitter.stopListening(this.observable, `change:${this.attribute}`, o3);
          };
        }
      }
      class Gi2 extends qi2 {
        constructor(t4) {
          super(t4), this.eventNameOrFunction = t4.eventNameOrFunction;
        }
        activateDomEventListener(t4, e4, n3) {
          const o3 = (t5, n4) => {
            e4 && !n4.target.matches(e4) || ("function" == typeof this.eventNameOrFunction ? this.eventNameOrFunction(n4) : this.observable.fire(this.eventNameOrFunction, n4));
          };
          return this.emitter.listenTo(n3.node, t4, o3), () => {
            this.emitter.stopListening(n3.node, t4, o3);
          };
        }
      }
      class Wi2 extends qi2 {
        constructor(t4) {
          super(t4), this.valueIfTrue = t4.valueIfTrue;
        }
        getValue(t4) {
          return !ir(super.getValue(t4)) && (this.valueIfTrue || true);
        }
      }
      function Ki2(t4) {
        return !!t4 && (t4.value && (t4 = t4.value), Array.isArray(t4) ? t4.some(Ki2) : t4 instanceof qi2);
      }
      function Yi2(t4, e4, { node: n3 }) {
        const o3 = function(t5, e5) {
          return t5.map((t6) => t6 instanceof qi2 ? t6.getValue(e5) : t6);
        }(t4, n3);
        let i3;
        i3 = 1 == t4.length && t4[0] instanceof Wi2 ? o3[0] : o3.reduce(er, ""), ir(i3) ? e4.remove() : e4.set(i3);
      }
      function $i2(t4) {
        return { set(e4) {
          t4.textContent = e4;
        }, remove() {
          t4.textContent = "";
        } };
      }
      function Zi2(t4, e4, n3) {
        return { set(o3) {
          t4.setAttributeNS(n3, e4, o3);
        }, remove() {
          t4.removeAttributeNS(n3, e4);
        } };
      }
      function Qi2(t4, e4) {
        return { set(n3) {
          t4.style[e4] = n3;
        }, remove() {
          t4.style[e4] = null;
        } };
      }
      function Ji2(t4) {
        return vo2(t4, (t5) => {
          if (t5 && (t5 instanceof qi2 || sr(t5) || rr(t5) || ar(t5)))
            return t5;
        });
      }
      function Xi2(t4) {
        if ("string" == typeof t4 ? t4 = function(t5) {
          return { text: [t5] };
        }(t4) : t4.text && function(t5) {
          t5.text = _i(t5.text);
        }(t4), t4.on && (t4.eventListeners = function(t5) {
          for (const e4 in t5)
            tr(t5, e4);
          return t5;
        }(t4.on), delete t4.on), !t4.text) {
          t4.attributes && function(t5) {
            for (const e5 in t5)
              t5[e5].value && (t5[e5].value = _i(t5[e5].value)), tr(t5, e5);
          }(t4.attributes);
          const e4 = [];
          if (t4.children)
            if (ar(t4.children))
              e4.push(t4.children);
            else
              for (const n3 of t4.children)
                sr(n3) || rr(n3) || So2(n3) ? e4.push(n3) : e4.push(new Ui2(n3));
          t4.children = e4;
        }
        return t4;
      }
      function tr(t4, e4) {
        t4[e4] = _i(t4[e4]);
      }
      function er(t4, e4) {
        return ir(e4) ? t4 : ir(t4) ? e4 : `${t4} ${e4}`;
      }
      function nr(t4, e4) {
        for (const n3 in e4)
          t4[n3] ? t4[n3].push(...e4[n3]) : t4[n3] = e4[n3];
      }
      function or(t4, e4) {
        if (e4.attributes && (t4.attributes || (t4.attributes = {}), nr(t4.attributes, e4.attributes)), e4.eventListeners && (t4.eventListeners || (t4.eventListeners = {}), nr(t4.eventListeners, e4.eventListeners)), e4.text && t4.text.push(...e4.text), e4.children && e4.children.length) {
          if (t4.children.length != e4.children.length)
            throw new A2("ui-template-extend-children-mismatch", t4);
          let n3 = 0;
          for (const o3 of e4.children)
            or(t4.children[n3++], o3);
        }
      }
      function ir(t4) {
        return !t4 && 0 !== t4;
      }
      function rr(t4) {
        return t4 instanceof Hi2;
      }
      function sr(t4) {
        return t4 instanceof Ui2;
      }
      function ar(t4) {
        return t4 instanceof Li2;
      }
      function cr(t4) {
        return R2(t4[0]) && t4[0].ns;
      }
      function lr(t4) {
        return "class" == t4 || "style" == t4;
      }
      class dr extends Li2 {
        constructor(t4, e4 = []) {
          super(e4), this.locale = t4;
        }
        get bodyCollectionContainer() {
          return this._bodyCollectionContainer;
        }
        attachToDom() {
          this._bodyCollectionContainer = new Ui2({ tag: "div", attributes: { class: ["ck", "ck-reset_all", "ck-body", "ck-rounded-corners"], dir: this.locale.uiLanguageDirection }, children: this }).render();
          let t4 = document.querySelector(".ck-body-wrapper");
          t4 || (t4 = bt2(document, "div", { class: "ck-body-wrapper" }), document.body.appendChild(t4)), t4.appendChild(this._bodyCollectionContainer);
        }
        detachFromDom() {
          super.destroy(), this._bodyCollectionContainer && this._bodyCollectionContainer.remove();
          const t4 = document.querySelector(".ck-body-wrapper");
          t4 && 0 == t4.childElementCount && t4.remove();
        }
      }
      var hr = n2(6574), ur = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(hr.Z, ur);
      hr.Z.locals;
      const gr = class extends Hi2 {
        constructor() {
          super();
          const t4 = this.bindTemplate;
          this.set("content", ""), this.set("viewBox", "0 0 20 20"), this.set("fillColor", ""), this.set("isColorInherited", true), this.set("isVisible", true), this.setTemplate({ tag: "svg", ns: "http://www.w3.org/2000/svg", attributes: { class: ["ck", "ck-icon", t4.if("isVisible", "ck-hidden", (t5) => !t5), "ck-reset_all-excluded", t4.if("isColorInherited", "ck-icon_inherit-color")], viewBox: t4.to("viewBox") } });
        }
        render() {
          super.render(), this._updateXMLContent(), this._colorFillPaths(), this.on("change:content", () => {
            this._updateXMLContent(), this._colorFillPaths();
          }), this.on("change:fillColor", () => {
            this._colorFillPaths();
          });
        }
        _updateXMLContent() {
          if (this.content) {
            const t4 = new DOMParser().parseFromString(this.content.trim(), "image/svg+xml").querySelector("svg"), e4 = t4.getAttribute("viewBox");
            e4 && (this.viewBox = e4);
            for (const { name: e5, value: n3 } of Array.from(t4.attributes))
              gr.presentationalAttributeNames.includes(e5) && this.element.setAttribute(e5, n3);
            for (; this.element.firstChild; )
              this.element.removeChild(this.element.firstChild);
            for (; t4.childNodes.length > 0; )
              this.element.appendChild(t4.childNodes[0]);
          }
        }
        _colorFillPaths() {
          this.fillColor && this.element.querySelectorAll(".ck-icon__fill").forEach((t4) => {
            t4.style.fill = this.fillColor;
          });
        }
      };
      let pr = gr;
      pr.presentationalAttributeNames = ["alignment-baseline", "baseline-shift", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-rendering", "cursor", "direction", "display", "dominant-baseline", "fill", "fill-opacity", "fill-rule", "filter", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "image-rendering", "letter-spacing", "lighting-color", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "overflow", "paint-order", "pointer-events", "shape-rendering", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-anchor", "text-decoration", "text-overflow", "text-rendering", "transform", "unicode-bidi", "vector-effect", "visibility", "white-space", "word-spacing", "writing-mode"];
      class mr extends Hi2 {
        constructor() {
          super(), this.set({ style: void 0, text: void 0, id: void 0 });
          const t4 = this.bindTemplate;
          this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__label"], style: t4.to("style"), id: t4.to("id") }, children: [{ text: t4.to("text") }] });
        }
      }
      var fr = n2(4906), kr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(fr.Z, kr);
      fr.Z.locals;
      class br extends Hi2 {
        constructor(t4, e4 = new mr()) {
          super(t4), this._focusDelayed = null;
          const n3 = this.bindTemplate, o3 = f2();
          this.set("ariaChecked", void 0), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", `ck-editor__aria-label_${o3}`), this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", true), this.set("isOn", false), this.set("isVisible", true), this.set("isToggleable", false), this.set("keystroke", void 0), this.set("label", void 0), this.set("role", void 0), this.set("tabindex", -1), this.set("tooltip", false), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.set("withKeystroke", false), this.children = this.createCollection(), this.labelView = this._setupLabelView(e4), this.iconView = new pr(), this.iconView.extendTemplate({ attributes: { class: "ck-button__icon" } }), this.keystrokeView = this._createKeystrokeView(), this.bind("_tooltipString").to(this, "tooltip", this, "label", this, "keystroke", this._getTooltipString.bind(this));
          const i3 = { tag: "button", attributes: { class: ["ck", "ck-button", n3.to("class"), n3.if("isEnabled", "ck-disabled", (t5) => !t5), n3.if("isVisible", "ck-hidden", (t5) => !t5), n3.to("isOn", (t5) => t5 ? "ck-on" : "ck-off"), n3.if("withText", "ck-button_with-text"), n3.if("withKeystroke", "ck-button_with-keystroke")], role: n3.to("role"), type: n3.to("type", (t5) => t5 || "button"), tabindex: n3.to("tabindex"), "aria-label": n3.to("ariaLabel"), "aria-labelledby": n3.to("ariaLabelledBy"), "aria-disabled": n3.if("isEnabled", true, (t5) => !t5), "aria-checked": n3.to("isOn"), "aria-pressed": n3.to("isOn", (t5) => !!this.isToggleable && String(!!t5)), "data-cke-tooltip-text": n3.to("_tooltipString"), "data-cke-tooltip-position": n3.to("tooltipPosition") }, children: this.children, on: { click: n3.to((t5) => {
            this.isEnabled ? this.fire("execute") : t5.preventDefault();
          }) } };
          a2.isSafari && (this._focusDelayed || (this._focusDelayed = Bi2(() => this.focus(), 0)), i3.on.mousedown = n3.to(() => {
            this._focusDelayed();
          }), i3.on.mouseup = n3.to(() => {
            this._focusDelayed.cancel();
          })), this.setTemplate(i3);
        }
        render() {
          super.render(), this.icon && (this.iconView.bind("content").to(this, "icon"), this.children.add(this.iconView)), this.children.add(this.labelView), this.withKeystroke && this.keystroke && this.children.add(this.keystrokeView);
        }
        focus() {
          this.element.focus();
        }
        destroy() {
          this._focusDelayed && this._focusDelayed.cancel(), super.destroy();
        }
        _setupLabelView(t4) {
          return t4.bind("text", "style", "id").to(this, "label", "labelStyle", "ariaLabelledBy"), t4;
        }
        _createKeystrokeView() {
          const t4 = new Hi2();
          return t4.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__keystroke"] }, children: [{ text: this.bindTemplate.to("keystroke", (t5) => Ai2(t5)) }] }), t4;
        }
        _getTooltipString(t4, e4, n3) {
          return t4 ? "string" == typeof t4 ? t4 : (n3 && (n3 = Ai2(n3)), t4 instanceof Function ? t4(e4, n3) : `${e4}${n3 ? ` (${n3})` : ""}`) : "";
        }
      }
      var wr = n2(5332), Ar = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(wr.Z, Ar);
      wr.Z.locals;
      class Cr extends br {
        constructor(t4) {
          super(t4), this.isToggleable = true, this.toggleSwitchView = this._createToggleView(), this.extendTemplate({ attributes: { class: "ck-switchbutton" } });
        }
        render() {
          super.render(), this.children.add(this.toggleSwitchView);
        }
        _createToggleView() {
          const t4 = new Hi2();
          return t4.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-button__toggle"] }, children: [{ tag: "span", attributes: { class: ["ck", "ck-button__toggle__inner"] } }] }), t4;
        }
      }
      var _r = n2(6781), vr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(_r.Z, vr);
      _r.Z.locals;
      n2(1103);
      n2(841);
      var yr = n2(3662), xr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(yr.Z, xr);
      yr.Z.locals;
      class Er extends Hi2 {
        constructor(t4) {
          super(t4), this.set("text", void 0), this.set("for", void 0), this.id = `ck-editor__label_${f2()}`;
          const e4 = this.bindTemplate;
          this.setTemplate({ tag: "label", attributes: { class: ["ck", "ck-label"], id: this.id, for: e4.to("for") }, children: [{ text: e4.to("text") }] });
        }
      }
      var Dr = n2(2577), Sr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Dr.Z, Sr);
      Dr.Z.locals;
      class Ir extends Hi2 {
        constructor(t4, e4) {
          super(t4);
          const n3 = `ck-labeled-field-view-${f2()}`, o3 = `ck-labeled-field-view-status-${f2()}`;
          this.fieldView = e4(this, n3, o3), this.set("label", void 0), this.set("isEnabled", true), this.set("isEmpty", true), this.set("isFocused", false), this.set("errorText", null), this.set("infoText", null), this.set("class", void 0), this.set("placeholder", void 0), this.labelView = this._createLabelView(n3), this.statusView = this._createStatusView(o3), this.fieldWrapperChildren = this.createCollection([this.fieldView, this.labelView]), this.bind("_statusText").to(this, "errorText", this, "infoText", (t5, e5) => t5 || e5);
          const i3 = this.bindTemplate;
          this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view", i3.to("class"), i3.if("isEnabled", "ck-disabled", (t5) => !t5), i3.if("isEmpty", "ck-labeled-field-view_empty"), i3.if("isFocused", "ck-labeled-field-view_focused"), i3.if("placeholder", "ck-labeled-field-view_placeholder"), i3.if("errorText", "ck-error")] }, children: [{ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__input-wrapper"] }, children: this.fieldWrapperChildren }, this.statusView] });
        }
        _createLabelView(t4) {
          const e4 = new Er(this.locale);
          return e4.for = t4, e4.bind("text").to(this, "label"), e4;
        }
        _createStatusView(t4) {
          const e4 = new Hi2(this.locale), n3 = this.bindTemplate;
          return e4.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-labeled-field-view__status", n3.if("errorText", "ck-labeled-field-view__status_error"), n3.if("_statusText", "ck-hidden", (t5) => !t5)], id: t4, role: n3.if("errorText", "alert") }, children: [{ text: n3.to("_statusText") }] }), e4;
        }
        focus(t4) {
          this.fieldView.focus(t4);
        }
      }
      class Tr extends Hi2 {
        constructor(t4) {
          super(t4), this.set("value", void 0), this.set("id", void 0), this.set("placeholder", void 0), this.set("isReadOnly", false), this.set("hasError", false), this.set("ariaDescribedById", void 0), this.focusTracker = new Ii2(), this.bind("isFocused").to(this.focusTracker), this.set("isEmpty", true);
          const e4 = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck", "ck-input", e4.if("isFocused", "ck-input_focused"), e4.if("isEmpty", "ck-input-text_empty"), e4.if("hasError", "ck-error")], id: e4.to("id"), placeholder: e4.to("placeholder"), readonly: e4.to("isReadOnly"), "aria-invalid": e4.if("hasError", true), "aria-describedby": e4.to("ariaDescribedById") }, on: { input: e4.to((...t5) => {
            this.fire("input", ...t5), this._updateIsEmpty();
          }), change: e4.to(this._updateIsEmpty.bind(this)) } });
        }
        render() {
          super.render(), this.focusTracker.add(this.element), this._setDomElementValue(this.value), this._updateIsEmpty(), this.on("change:value", (t4, e4, n3) => {
            this._setDomElementValue(n3), this._updateIsEmpty();
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy();
        }
        select() {
          this.element.select();
        }
        focus() {
          this.element.focus();
        }
        reset() {
          this.value = this.element.value = "", this._updateIsEmpty();
        }
        _updateIsEmpty() {
          this.isEmpty = !this.element.value;
        }
        _setDomElementValue(t4) {
          this.element.value = t4 || 0 === t4 ? t4 : "";
        }
      }
      var Mr = n2(4879), Br = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Mr.Z, Br);
      Mr.Z.locals;
      class Nr extends Tr {
        constructor(t4) {
          super(t4), this.set("inputMode", "text");
          const e4 = this.bindTemplate;
          this.extendTemplate({ attributes: { inputmode: e4.to("inputMode") } });
        }
      }
      class Pr extends Nr {
        constructor(t4) {
          super(t4), this.extendTemplate({ attributes: { type: "text", class: ["ck-input-text"] } });
        }
      }
      var zr = n2(8182), Or = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(zr.Z, Or);
      zr.Z.locals;
      class Lr extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = this.bindTemplate;
          this.set("isVisible", false), this.set("position", "se"), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-dropdown__panel", e4.to("position", (t5) => `ck-dropdown__panel_${t5}`), e4.if("isVisible", "ck-dropdown__panel-visible")], tabindex: "-1" }, children: this.children, on: { selectstart: e4.to((t5) => {
            "input" !== t5.target.tagName.toLocaleLowerCase() && t5.preventDefault();
          }) } });
        }
        focus() {
          if (this.children.length) {
            const t4 = this.children.first;
            "function" == typeof t4.focus ? t4.focus() : C2("ui-dropdown-panel-focus-child-missing-focus", { childView: this.children.first, dropdownPanel: this });
          }
        }
        focusLast() {
          if (this.children.length) {
            const t4 = this.children.last;
            "function" == typeof t4.focusLast ? t4.focusLast() : t4.focus();
          }
        }
      }
      var jr = n2(5485), Rr = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(jr.Z, Rr);
      jr.Z.locals;
      const Fr = class extends Hi2 {
        constructor(t4, e4, n3) {
          super(t4);
          const o3 = this.bindTemplate;
          this.buttonView = e4, this.panelView = n3, this.set("isOpen", false), this.set("isEnabled", true), this.set("class", void 0), this.set("id", void 0), this.set("panelPosition", "auto"), this.keystrokes = new Ti2(), this.focusTracker = new Ii2(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-dropdown", o3.to("class"), o3.if("isEnabled", "ck-disabled", (t5) => !t5)], id: o3.to("id"), "aria-describedby": o3.to("ariaDescribedById") }, children: [e4, n3] }), e4.extendTemplate({ attributes: { class: ["ck-dropdown__button"], "data-cke-tooltip-disabled": o3.to("isOpen") } });
        }
        render() {
          super.render(), this.focusTracker.add(this.buttonView.element), this.focusTracker.add(this.panelView.element), this.listenTo(this.buttonView, "open", () => {
            this.isOpen = !this.isOpen;
          }), this.panelView.bind("isVisible").to(this, "isOpen"), this.on("change:isOpen", (t5, e4, n3) => {
            if (n3)
              if ("auto" === this.panelPosition) {
                const t6 = Fr._getOptimalPosition({ element: this.panelView.element, target: this.buttonView.element, fitInViewport: true, positions: this._panelPositions });
                this.panelView.position = t6 ? t6.name : this._panelPositions[0].name;
              } else
                this.panelView.position = this.panelPosition;
          }), this.keystrokes.listenTo(this.element);
          const t4 = (t5, e4) => {
            this.isOpen && (this.isOpen = false, e4());
          };
          this.keystrokes.set("arrowdown", (t5, e4) => {
            this.buttonView.isEnabled && !this.isOpen && (this.isOpen = true, e4());
          }), this.keystrokes.set("arrowright", (t5, e4) => {
            this.isOpen && e4();
          }), this.keystrokes.set("arrowleft", t4), this.keystrokes.set("esc", t4);
        }
        focus() {
          this.buttonView.focus();
        }
        get _panelPositions() {
          const { south: t4, north: e4, southEast: n3, southWest: o3, northEast: i3, northWest: r3, southMiddleEast: s3, southMiddleWest: a3, northMiddleEast: c3, northMiddleWest: l3 } = Fr.defaultPanelPositions;
          return "rtl" !== this.locale.uiLanguageDirection ? [n3, o3, s3, a3, t4, i3, r3, c3, l3, e4] : [o3, n3, a3, s3, t4, r3, i3, l3, c3, e4];
        }
      };
      let Vr = Fr;
      Vr.defaultPanelPositions = { south: (t4, e4) => ({ top: t4.bottom, left: t4.left - (e4.width - t4.width) / 2, name: "s" }), southEast: (t4) => ({ top: t4.bottom, left: t4.left, name: "se" }), southWest: (t4, e4) => ({ top: t4.bottom, left: t4.left - e4.width + t4.width, name: "sw" }), southMiddleEast: (t4, e4) => ({ top: t4.bottom, left: t4.left - (e4.width - t4.width) / 4, name: "sme" }), southMiddleWest: (t4, e4) => ({ top: t4.bottom, left: t4.left - 3 * (e4.width - t4.width) / 4, name: "smw" }), north: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left - (e4.width - t4.width) / 2, name: "n" }), northEast: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left, name: "ne" }), northWest: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left - e4.width + t4.width, name: "nw" }), northMiddleEast: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left - (e4.width - t4.width) / 4, name: "nme" }), northMiddleWest: (t4, e4) => ({ top: t4.top - e4.height, left: t4.left - 3 * (e4.width - t4.width) / 4, name: "nmw" }) }, Vr._getOptimalPosition = ei2;
      const Hr = '<svg viewBox="0 0 10 10" xmlns="http://www.w3.org/2000/svg"><path d="M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z"/></svg>';
      class Ur extends br {
        constructor(t4) {
          super(t4), this.arrowView = this._createArrowView(), this.extendTemplate({ attributes: { "aria-haspopup": true, "aria-expanded": this.bindTemplate.to("isOn", (t5) => String(t5)) } }), this.delegate("execute").to(this, "open");
        }
        render() {
          super.render(), this.children.add(this.arrowView);
        }
        _createArrowView() {
          const t4 = new pr();
          return t4.content = Hr, t4.extendTemplate({ attributes: { class: "ck-dropdown__arrow" } }), t4;
        }
      }
      class qr extends M2() {
        constructor(t4) {
          if (super(), this.focusables = t4.focusables, this.focusTracker = t4.focusTracker, this.keystrokeHandler = t4.keystrokeHandler, this.actions = t4.actions, t4.actions && t4.keystrokeHandler)
            for (const e4 in t4.actions) {
              let n3 = t4.actions[e4];
              "string" == typeof n3 && (n3 = [n3]);
              for (const o3 of n3)
                t4.keystrokeHandler.set(o3, (t5, n4) => {
                  this[e4](), n4();
                });
            }
          this.on("forwardCycle", () => this.focusFirst(), { priority: "low" }), this.on("backwardCycle", () => this.focusLast(), { priority: "low" });
        }
        get first() {
          return this.focusables.find(Gr) || null;
        }
        get last() {
          return this.focusables.filter(Gr).slice(-1)[0] || null;
        }
        get next() {
          return this._getFocusableItem(1);
        }
        get previous() {
          return this._getFocusableItem(-1);
        }
        get current() {
          let t4 = null;
          return null === this.focusTracker.focusedElement ? null : (this.focusables.find((e4, n3) => {
            const o3 = e4.element === this.focusTracker.focusedElement;
            return o3 && (t4 = n3), o3;
          }), t4);
        }
        focusFirst() {
          this._focus(this.first, 1);
        }
        focusLast() {
          this._focus(this.last, -1);
        }
        focusNext() {
          const t4 = this.next;
          t4 && this.focusables.getIndex(t4) === this.current || (t4 === this.first ? this.fire("forwardCycle") : this._focus(t4, 1));
        }
        focusPrevious() {
          const t4 = this.previous;
          t4 && this.focusables.getIndex(t4) === this.current || (t4 === this.last ? this.fire("backwardCycle") : this._focus(t4, -1));
        }
        _focus(t4, e4) {
          t4 && t4.focus(e4);
        }
        _getFocusableItem(t4) {
          const e4 = this.current, n3 = this.focusables.length;
          if (!n3)
            return null;
          if (null === e4)
            return this[1 === t4 ? "first" : "last"];
          let o3 = (e4 + n3 + t4) % n3;
          do {
            const e5 = this.focusables.get(o3);
            if (Gr(e5))
              return e5;
            o3 = (o3 + n3 + t4) % n3;
          } while (o3 !== e4);
          return null;
        }
      }
      function Gr(t4) {
        return !(!("focus" in t4) || !Xo2(t4.element));
      }
      class Wr extends Hi2 {
        constructor(t4) {
          super(t4), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__separator"] } });
        }
      }
      class Kr extends Hi2 {
        constructor(t4) {
          super(t4), this.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-toolbar__line-break"] } });
        }
      }
      function Yr(t4) {
        return Array.isArray(t4) ? { items: t4, removeItems: [] } : t4 ? Object.assign({ items: [], removeItems: [] }, t4) : { items: [], removeItems: [] };
      }
      class $r extends W2() {
        constructor(t4) {
          super(), this._disableStack = /* @__PURE__ */ new Set(), this.editor = t4, this.set("isEnabled", true);
        }
        forceDisabled(t4) {
          this._disableStack.add(t4), 1 == this._disableStack.size && (this.on("set:isEnabled", Zr, { priority: "highest" }), this.isEnabled = false);
        }
        clearForceDisabled(t4) {
          this._disableStack.delete(t4), 0 == this._disableStack.size && (this.off("set:isEnabled", Zr), this.isEnabled = true);
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return false;
        }
      }
      function Zr(t4) {
        t4.return = false, t4.stop();
      }
      class Qr extends W2() {
        constructor(t4) {
          super(), this.editor = t4, this.set("value", void 0), this.set("isEnabled", false), this._affectsData = true, this._isEnabledBasedOnSelection = true, this._disableStack = /* @__PURE__ */ new Set(), this.decorate("execute"), this.listenTo(this.editor.model.document, "change", () => {
            this.refresh();
          }), this.listenTo(t4, "change:isReadOnly", () => {
            this.refresh();
          }), this.on("set:isEnabled", (e4) => {
            if (!this.affectsData)
              return;
            const n3 = t4.model.document.selection, o3 = !("$graveyard" == n3.getFirstPosition().root.rootName) && t4.model.canEditAt(n3);
            (t4.isReadOnly || this._isEnabledBasedOnSelection && !o3) && (e4.return = false, e4.stop());
          }, { priority: "highest" }), this.on("execute", (t5) => {
            this.isEnabled || t5.stop();
          }, { priority: "high" });
        }
        get affectsData() {
          return this._affectsData;
        }
        set affectsData(t4) {
          this._affectsData = t4;
        }
        refresh() {
          this.isEnabled = true;
        }
        forceDisabled(t4) {
          this._disableStack.add(t4), 1 == this._disableStack.size && (this.on("set:isEnabled", Jr, { priority: "highest" }), this.isEnabled = false);
        }
        clearForceDisabled(t4) {
          this._disableStack.delete(t4), 0 == this._disableStack.size && (this.off("set:isEnabled", Jr), this.refresh());
        }
        execute(...t4) {
        }
        destroy() {
          this.stopListening();
        }
      }
      function Jr(t4) {
        t4.return = false, t4.stop();
      }
      class Xr extends Qr {
        constructor() {
          super(...arguments), this._childCommandsDefinitions = [];
        }
        refresh() {
        }
        execute(...t4) {
          const e4 = this._getFirstEnabledCommand();
          return !!e4 && e4.execute(t4);
        }
        registerChildCommand(t4, e4 = {}) {
          b2(this._childCommandsDefinitions, { command: t4, priority: e4.priority || "normal" }), t4.on("change:isEnabled", () => this._checkEnabled()), this._checkEnabled();
        }
        _checkEnabled() {
          this.isEnabled = !!this._getFirstEnabledCommand();
        }
        _getFirstEnabledCommand() {
          const t4 = this._childCommandsDefinitions.find(({ command: t5 }) => t5.isEnabled);
          return t4 && t4.command;
        }
      }
      class ts extends M2() {
        constructor(t4, e4 = [], n3 = []) {
          super(), this._plugins = /* @__PURE__ */ new Map(), this._context = t4, this._availablePlugins = /* @__PURE__ */ new Map();
          for (const t5 of e4)
            t5.pluginName && this._availablePlugins.set(t5.pluginName, t5);
          this._contextPlugins = /* @__PURE__ */ new Map();
          for (const [t5, e5] of n3)
            this._contextPlugins.set(t5, e5), this._contextPlugins.set(e5, t5), t5.pluginName && this._availablePlugins.set(t5.pluginName, t5);
        }
        *[Symbol.iterator]() {
          for (const t4 of this._plugins)
            "function" == typeof t4[0] && (yield t4);
        }
        get(t4) {
          const e4 = this._plugins.get(t4);
          if (!e4) {
            let e5 = t4;
            throw "function" == typeof t4 && (e5 = t4.pluginName || t4.name), new A2("plugincollection-plugin-not-loaded", this._context, { plugin: e5 });
          }
          return e4;
        }
        has(t4) {
          return this._plugins.has(t4);
        }
        init(t4, e4 = [], n3 = []) {
          const o3 = this, i3 = this._context;
          !function t5(e5, n4 = /* @__PURE__ */ new Set()) {
            e5.forEach((e6) => {
              a3(e6) && (n4.has(e6) || (n4.add(e6), e6.pluginName && !o3._availablePlugins.has(e6.pluginName) && o3._availablePlugins.set(e6.pluginName, e6), e6.requires && t5(e6.requires, n4)));
            });
          }(t4), h3(t4);
          const r3 = [...function t5(e5, n4 = /* @__PURE__ */ new Set()) {
            return e5.map((t6) => a3(t6) ? t6 : o3._availablePlugins.get(t6)).reduce((e6, o4) => n4.has(o4) ? e6 : (n4.add(o4), o4.requires && (h3(o4.requires, o4), t5(o4.requires, n4).forEach((t6) => e6.add(t6))), e6.add(o4)), /* @__PURE__ */ new Set());
          }(t4.filter((t5) => !l3(t5, e4)))];
          !function(t5, e5) {
            for (const n4 of e5) {
              if ("function" != typeof n4)
                throw new A2("plugincollection-replace-plugin-invalid-type", null, { pluginItem: n4 });
              const e6 = n4.pluginName;
              if (!e6)
                throw new A2("plugincollection-replace-plugin-missing-name", null, { pluginItem: n4 });
              if (n4.requires && n4.requires.length)
                throw new A2("plugincollection-plugin-for-replacing-cannot-have-dependencies", null, { pluginName: e6 });
              const i4 = o3._availablePlugins.get(e6);
              if (!i4)
                throw new A2("plugincollection-plugin-for-replacing-not-exist", null, { pluginName: e6 });
              const r4 = t5.indexOf(i4);
              if (-1 === r4) {
                if (o3._contextPlugins.has(i4))
                  return;
                throw new A2("plugincollection-plugin-for-replacing-not-loaded", null, { pluginName: e6 });
              }
              if (i4.requires && i4.requires.length)
                throw new A2("plugincollection-replaced-plugin-cannot-have-dependencies", null, { pluginName: e6 });
              t5.splice(r4, 1, n4), o3._availablePlugins.set(e6, n4);
            }
          }(r3, n3);
          const s3 = r3.map((t5) => {
            let e5 = o3._contextPlugins.get(t5);
            return e5 = e5 || new t5(i3), o3._add(t5, e5), e5;
          });
          return u3(s3, "init").then(() => u3(s3, "afterInit")).then(() => s3);
          function a3(t5) {
            return "function" == typeof t5;
          }
          function c3(t5) {
            return a3(t5) && !!t5.isContextPlugin;
          }
          function l3(t5, e5) {
            return e5.some((e6) => e6 === t5 || (d3(t5) === e6 || d3(e6) === t5));
          }
          function d3(t5) {
            return a3(t5) ? t5.pluginName || t5.name : t5;
          }
          function h3(t5, n4 = null) {
            t5.map((t6) => a3(t6) ? t6 : o3._availablePlugins.get(t6) || t6).forEach((t6) => {
              !function(t7, e5) {
                if (a3(t7))
                  return;
                if (e5)
                  throw new A2("plugincollection-soft-required", i3, { missingPlugin: t7, requiredBy: d3(e5) });
                throw new A2("plugincollection-plugin-not-found", i3, { plugin: t7 });
              }(t6, n4), function(t7, e5) {
                if (!c3(e5))
                  return;
                if (c3(t7))
                  return;
                throw new A2("plugincollection-context-required", i3, { plugin: d3(t7), requiredBy: d3(e5) });
              }(t6, n4), function(t7, n5) {
                if (!n5)
                  return;
                if (!l3(t7, e4))
                  return;
                throw new A2("plugincollection-required", i3, { plugin: d3(t7), requiredBy: d3(n5) });
              }(t6, n4);
            });
          }
          function u3(t5, e5) {
            return t5.reduce((t6, n4) => n4[e5] ? o3._contextPlugins.has(n4) ? t6 : t6.then(n4[e5].bind(n4)) : t6, Promise.resolve());
          }
        }
        destroy() {
          const t4 = [];
          for (const [, e4] of this)
            "function" != typeof e4.destroy || this._contextPlugins.has(e4) || t4.push(e4.destroy());
          return Promise.all(t4);
        }
        _add(t4, e4) {
          this._plugins.set(t4, e4);
          const n3 = t4.pluginName;
          if (n3) {
            if (this._plugins.has(n3))
              throw new A2("plugincollection-plugin-name-conflict", null, { pluginName: n3, plugin1: this._plugins.get(n3).constructor, plugin2: t4 });
            this._plugins.set(n3, e4);
          }
        }
      }
      class es {
        constructor(t4) {
          this._contextOwner = null, this.config = new xo2(t4, this.constructor.defaultConfig);
          const e4 = this.constructor.builtinPlugins;
          this.config.define("plugins", e4), this.plugins = new ts(this, e4);
          const n3 = this.config.get("language") || {};
          this.locale = new Ei2({ uiLanguage: "string" == typeof n3 ? n3 : n3.ui, contentLanguage: this.config.get("language.content") }), this.t = this.locale.t, this.editors = new Di2();
        }
        initPlugins() {
          const t4 = this.config.get("plugins") || [], e4 = this.config.get("substitutePlugins") || [];
          for (const n3 of t4.concat(e4)) {
            if ("function" != typeof n3)
              throw new A2("context-initplugins-constructor-only", null, { Plugin: n3 });
            if (true !== n3.isContextPlugin)
              throw new A2("context-initplugins-invalid-plugin", null, { Plugin: n3 });
          }
          return this.plugins.init(t4, [], e4);
        }
        destroy() {
          return Promise.all(Array.from(this.editors, (t4) => t4.destroy())).then(() => this.plugins.destroy());
        }
        _addEditor(t4, e4) {
          if (this._contextOwner)
            throw new A2("context-addeditor-private-context");
          this.editors.add(t4), e4 && (this._contextOwner = t4);
        }
        _removeEditor(t4) {
          return this.editors.has(t4) && this.editors.remove(t4), this._contextOwner === t4 ? this.destroy() : Promise.resolve();
        }
        _getEditorConfig() {
          const t4 = {};
          for (const e4 of this.config.names())
            ["plugins", "removePlugins", "extraPlugins"].includes(e4) || (t4[e4] = this.config.get(e4));
          return t4;
        }
        static create(t4) {
          return new Promise((e4) => {
            const n3 = new this(t4);
            e4(n3.initPlugins().then(() => n3));
          });
        }
      }
      class ns extends W2() {
        constructor(t4) {
          super(), this.context = t4;
        }
        destroy() {
          this.stopListening();
        }
        static get isContextPlugin() {
          return true;
        }
      }
      class os extends Ti2 {
        constructor(t4) {
          super(), this.editor = t4;
        }
        set(t4, e4, n3 = {}) {
          if ("string" == typeof e4) {
            const t5 = e4;
            e4 = (e5, n4) => {
              this.editor.execute(t5), n4();
            };
          }
          super.set(t4, e4, n3);
        }
      }
      var is2 = n2(4717), rs = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(is2.Z, rs);
      is2.Z.locals;
      const ss = /* @__PURE__ */ new WeakMap();
      let as = false;
      function cs({ view: t4, element: e4, text: n3, isDirectHost: o3 = true, keepOnFocus: i3 = false }) {
        const r3 = t4.document;
        function s3(n4) {
          ss.get(r3).set(e4, { text: n4, isDirectHost: o3, keepOnFocus: i3, hostElement: o3 ? e4 : null }), t4.change((t5) => ds(r3, t5));
        }
        ss.has(r3) || (ss.set(r3, /* @__PURE__ */ new Map()), r3.registerPostFixer((t5) => ds(r3, t5)), r3.on("change:isComposing", () => {
          t4.change((t5) => ds(r3, t5));
        }, { priority: "high" })), e4.is("editableElement") && e4.on("change:placeholder", (t5, e5, n4) => {
          s3(n4);
        }), e4.placeholder ? s3(e4.placeholder) : n3 && s3(n3), n3 && function() {
          as || C2("enableplaceholder-deprecated-text-option");
          as = true;
        }();
      }
      function ls(t4, e4) {
        return !!e4.hasClass("ck-placeholder") && (t4.removeClass("ck-placeholder", e4), true);
      }
      function ds(t4, e4) {
        const n3 = ss.get(t4), o3 = [];
        let i3 = false;
        for (const [t5, r3] of n3)
          r3.isDirectHost && (o3.push(t5), hs(e4, t5, r3) && (i3 = true));
        for (const [t5, r3] of n3) {
          if (r3.isDirectHost)
            continue;
          const n4 = us(t5);
          n4 && (o3.includes(n4) || (r3.hostElement = n4, hs(e4, t5, r3) && (i3 = true)));
        }
        return i3;
      }
      function hs(t4, e4, n3) {
        const { text: o3, isDirectHost: i3, hostElement: r3 } = n3;
        let s3 = false;
        r3.getAttribute("data-placeholder") !== o3 && (t4.setAttribute("data-placeholder", o3, r3), s3 = true);
        return (i3 || 1 == e4.childCount) && function(t5, e5) {
          if (!t5.isAttached())
            return false;
          if (Array.from(t5.getChildren()).some((t6) => !t6.is("uiElement")))
            return false;
          const n4 = t5.document, o4 = n4.selection.anchor;
          return !(n4.isComposing && o4 && o4.parent === t5 || !e5 && n4.isFocused && (!o4 || o4.parent === t5));
        }(r3, n3.keepOnFocus) ? function(t5, e5) {
          return !e5.hasClass("ck-placeholder") && (t5.addClass("ck-placeholder", e5), true);
        }(t4, r3) && (s3 = true) : ls(t4, r3) && (s3 = true), s3;
      }
      function us(t4) {
        if (t4.childCount) {
          const e4 = t4.getChild(0);
          if (e4.is("element") && !e4.is("uiElement") && !e4.is("attributeElement"))
            return e4;
        }
        return null;
      }
      class gs {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      const ps = function(t4) {
        return _o2(t4, 4);
      };
      class ms extends M2(gs) {
        constructor(t4) {
          super(), this.document = t4, this.parent = null;
        }
        get index() {
          let t4;
          if (!this.parent)
            return null;
          if (-1 == (t4 = this.parent.getChildIndex(this)))
            throw new A2("view-node-not-found-in-parent", this);
          return t4;
        }
        get nextSibling() {
          const t4 = this.index;
          return null !== t4 && this.parent.getChild(t4 + 1) || null;
        }
        get previousSibling() {
          const t4 = this.index;
          return null !== t4 && this.parent.getChild(t4 - 1) || null;
        }
        get root() {
          let t4 = this;
          for (; t4.parent; )
            t4 = t4.parent;
          return t4;
        }
        isAttached() {
          return this.root.is("rootElement");
        }
        getPath() {
          const t4 = [];
          let e4 = this;
          for (; e4.parent; )
            t4.unshift(e4.index), e4 = e4.parent;
          return t4;
        }
        getAncestors(t4 = {}) {
          const e4 = [];
          let n3 = t4.includeSelf ? this : this.parent;
          for (; n3; )
            e4[t4.parentFirst ? "push" : "unshift"](n3), n3 = n3.parent;
          return e4;
        }
        getCommonAncestor(t4, e4 = {}) {
          const n3 = this.getAncestors(e4), o3 = t4.getAncestors(e4);
          let i3 = 0;
          for (; n3[i3] == o3[i3] && n3[i3]; )
            i3++;
          return 0 === i3 ? null : n3[i3 - 1];
        }
        isBefore(t4) {
          if (this == t4)
            return false;
          if (this.root !== t4.root)
            return false;
          const e4 = this.getPath(), n3 = t4.getPath(), o3 = tt2(e4, n3);
          switch (o3) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return e4[o3] < n3[o3];
          }
        }
        isAfter(t4) {
          return this != t4 && (this.root === t4.root && !this.isBefore(t4));
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _fireChange(t4, e4) {
          this.fire(`change:${t4}`, e4), this.parent && this.parent._fireChange(t4, e4);
        }
        toJSON() {
          const t4 = ps(this);
          return delete t4.parent, t4;
        }
      }
      ms.prototype.is = function(t4) {
        return "node" === t4 || "view:node" === t4;
      };
      class fs extends ms {
        constructor(t4, e4) {
          super(t4), this._textData = e4;
        }
        get data() {
          return this._textData;
        }
        get _data() {
          return this.data;
        }
        set _data(t4) {
          this._fireChange("text", this), this._textData = t4;
        }
        isSimilar(t4) {
          return t4 instanceof fs && (this === t4 || this.data === t4.data);
        }
        _clone() {
          return new fs(this.document, this.data);
        }
      }
      fs.prototype.is = function(t4) {
        return "$text" === t4 || "view:$text" === t4 || "text" === t4 || "view:text" === t4 || "node" === t4 || "view:node" === t4;
      };
      class ks extends gs {
        constructor(t4, e4, n3) {
          if (super(), this.textNode = t4, e4 < 0 || e4 > t4.data.length)
            throw new A2("view-textproxy-wrong-offsetintext", this);
          if (n3 < 0 || e4 + n3 > t4.data.length)
            throw new A2("view-textproxy-wrong-length", this);
          this.data = t4.data.substring(e4, e4 + n3), this.offsetInText = e4;
        }
        get offsetSize() {
          return this.data.length;
        }
        get isPartial() {
          return this.data.length !== this.textNode.data.length;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        get document() {
          return this.textNode.document;
        }
        getAncestors(t4 = {}) {
          const e4 = [];
          let n3 = t4.includeSelf ? this.textNode : this.parent;
          for (; null !== n3; )
            e4[t4.parentFirst ? "push" : "unshift"](n3), n3 = n3.parent;
          return e4;
        }
      }
      ks.prototype.is = function(t4) {
        return "$textProxy" === t4 || "view:$textProxy" === t4 || "textProxy" === t4 || "view:textProxy" === t4;
      };
      class bs {
        constructor(...t4) {
          this._patterns = [], this.add(...t4);
        }
        add(...t4) {
          for (let e4 of t4)
            ("string" == typeof e4 || e4 instanceof RegExp) && (e4 = { name: e4 }), this._patterns.push(e4);
        }
        match(...t4) {
          for (const e4 of t4)
            for (const t5 of this._patterns) {
              const n3 = ws(e4, t5);
              if (n3)
                return { element: e4, pattern: t5, match: n3 };
            }
          return null;
        }
        matchAll(...t4) {
          const e4 = [];
          for (const n3 of t4)
            for (const t5 of this._patterns) {
              const o3 = ws(n3, t5);
              o3 && e4.push({ element: n3, pattern: t5, match: o3 });
            }
          return e4.length > 0 ? e4 : null;
        }
        getElementName() {
          if (1 !== this._patterns.length)
            return null;
          const t4 = this._patterns[0], e4 = t4.name;
          return "function" == typeof t4 || !e4 || e4 instanceof RegExp ? null : e4;
        }
      }
      function ws(t4, e4) {
        if ("function" == typeof e4)
          return e4(t4);
        const n3 = {};
        return e4.name && (n3.name = function(t5, e5) {
          if (t5 instanceof RegExp)
            return !!e5.match(t5);
          return t5 === e5;
        }(e4.name, t4.name), !n3.name) || e4.attributes && (n3.attributes = function(t5, e5) {
          const n4 = new Set(e5.getAttributeKeys());
          Et2(t5) ? (void 0 !== t5.style && C2("matcher-pattern-deprecated-attributes-style-key", t5), void 0 !== t5.class && C2("matcher-pattern-deprecated-attributes-class-key", t5)) : (n4.delete("style"), n4.delete("class"));
          return As(t5, n4, (t6) => e5.getAttribute(t6));
        }(e4.attributes, t4), !n3.attributes) || e4.classes && (n3.classes = function(t5, e5) {
          return As(t5, e5.getClassNames(), () => {
          });
        }(e4.classes, t4), !n3.classes) || e4.styles && (n3.styles = function(t5, e5) {
          return As(t5, e5.getStyleNames(true), (t6) => e5.getStyle(t6));
        }(e4.styles, t4), !n3.styles) ? null : n3;
      }
      function As(t4, e4, n3) {
        const o3 = function(t5) {
          if (Array.isArray(t5))
            return t5.map((t6) => Et2(t6) ? (void 0 !== t6.key && void 0 !== t6.value || C2("matcher-pattern-missing-key-or-value", t6), [t6.key, t6.value]) : [t6, true]);
          if (Et2(t5))
            return Object.entries(t5);
          return [[t5, true]];
        }(t4), i3 = Array.from(e4), r3 = [];
        if (o3.forEach(([t5, e5]) => {
          i3.forEach((o4) => {
            (function(t6, e6) {
              return true === t6 || t6 === e6 || t6 instanceof RegExp && e6.match(t6);
            })(t5, o4) && function(t6, e6, n4) {
              if (true === t6)
                return true;
              const o5 = n4(e6);
              return t6 === o5 || t6 instanceof RegExp && !!String(o5).match(t6);
            }(e5, o4, n3) && r3.push(o4);
          });
        }), o3.length && !(r3.length < o3.length))
          return r3;
      }
      const Cs = function(t4) {
        return "symbol" == typeof t4 || ft2(t4) && "[object Symbol]" == pt2(t4);
      };
      var _s = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, vs = /^\w*$/;
      const ys = function(t4, e4) {
        if (mt2(t4))
          return false;
        var n3 = typeof t4;
        return !("number" != n3 && "symbol" != n3 && "boolean" != n3 && null != t4 && !Cs(t4)) || (vs.test(t4) || !_s.test(t4) || null != e4 && t4 in Object(e4));
      };
      function xs(t4, e4) {
        if ("function" != typeof t4 || null != e4 && "function" != typeof e4)
          throw new TypeError("Expected a function");
        var n3 = function() {
          var o3 = arguments, i3 = e4 ? e4.apply(this, o3) : o3[0], r3 = n3.cache;
          if (r3.has(i3))
            return r3.get(i3);
          var s3 = t4.apply(this, o3);
          return n3.cache = r3.set(i3, s3) || r3, s3;
        };
        return n3.cache = new (xs.Cache || Ce2)(), n3;
      }
      xs.Cache = Ce2;
      const Es = xs;
      const Ds = function(t4) {
        var e4 = Es(t4, function(t5) {
          return 500 === n3.size && n3.clear(), t5;
        }), n3 = e4.cache;
        return e4;
      };
      var Ss = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Is = /\\(\\)?/g, Ts = Ds(function(t4) {
        var e4 = [];
        return 46 === t4.charCodeAt(0) && e4.push(""), t4.replace(Ss, function(t5, n3, o3, i3) {
          e4.push(o3 ? i3.replace(Is, "$1") : n3 || t5);
        }), e4;
      });
      const Ms = Ts;
      const Bs = function(t4, e4) {
        for (var n3 = -1, o3 = null == t4 ? 0 : t4.length, i3 = Array(o3); ++n3 < o3; )
          i3[n3] = e4(t4[n3], n3, t4);
        return i3;
      };
      var Ns = rt2 ? rt2.prototype : void 0, Ps = Ns ? Ns.toString : void 0;
      const zs = function t4(e4) {
        if ("string" == typeof e4)
          return e4;
        if (mt2(e4))
          return Bs(e4, t4) + "";
        if (Cs(e4))
          return Ps ? Ps.call(e4) : "";
        var n3 = e4 + "";
        return "0" == n3 && 1 / e4 == -Infinity ? "-0" : n3;
      };
      const Os = function(t4) {
        return null == t4 ? "" : zs(t4);
      };
      const Ls = function(t4, e4) {
        return mt2(t4) ? t4 : ys(t4, e4) ? [t4] : Ms(Os(t4));
      };
      const js = function(t4) {
        var e4 = null == t4 ? 0 : t4.length;
        return e4 ? t4[e4 - 1] : void 0;
      };
      const Rs = function(t4) {
        if ("string" == typeof t4 || Cs(t4))
          return t4;
        var e4 = t4 + "";
        return "0" == e4 && 1 / t4 == -Infinity ? "-0" : e4;
      };
      const Fs = function(t4, e4) {
        for (var n3 = 0, o3 = (e4 = Ls(e4, t4)).length; null != t4 && n3 < o3; )
          t4 = t4[Rs(e4[n3++])];
        return n3 && n3 == o3 ? t4 : void 0;
      };
      const Vs = function(t4, e4, n3) {
        var o3 = -1, i3 = t4.length;
        e4 < 0 && (e4 = -e4 > i3 ? 0 : i3 + e4), (n3 = n3 > i3 ? i3 : n3) < 0 && (n3 += i3), i3 = e4 > n3 ? 0 : n3 - e4 >>> 0, e4 >>>= 0;
        for (var r3 = Array(i3); ++o3 < i3; )
          r3[o3] = t4[o3 + e4];
        return r3;
      };
      const Hs = function(t4, e4) {
        return e4.length < 2 ? t4 : Fs(t4, Vs(e4, 0, -1));
      };
      const Us = function(t4, e4) {
        return e4 = Ls(e4, t4), null == (t4 = Hs(t4, e4)) || delete t4[Rs(js(e4))];
      };
      const qs = function(t4, e4) {
        return null == t4 || Us(t4, e4);
      };
      const Gs = function(t4, e4, n3) {
        var o3 = null == t4 ? void 0 : Fs(t4, e4);
        return void 0 === o3 ? n3 : o3;
      };
      const Ws = function(t4, e4, n3) {
        (void 0 !== n3 && !St2(t4[e4], n3) || void 0 === n3 && !(e4 in t4)) && De2(t4, e4, n3);
      };
      const Ks = function(t4) {
        return function(e4, n3, o3) {
          for (var i3 = -1, r3 = Object(e4), s3 = o3(e4), a3 = s3.length; a3--; ) {
            var c3 = s3[t4 ? a3 : ++i3];
            if (false === n3(r3[c3], c3, r3))
              break;
          }
          return e4;
        };
      }();
      const Ys = function(t4) {
        return ft2(t4) && cn2(t4);
      };
      const $s = function(t4, e4) {
        if (("constructor" !== e4 || "function" != typeof t4[e4]) && "__proto__" != e4)
          return t4[e4];
      };
      const Zs = function(t4) {
        return Te2(t4, pn2(t4));
      };
      const Qs = function(t4, e4, n3, o3, i3, r3, s3) {
        var a3 = $s(t4, n3), c3 = $s(e4, n3), l3 = s3.get(c3);
        if (l3)
          Ws(t4, n3, l3);
        else {
          var d3 = r3 ? r3(a3, c3, n3 + "", t4, e4, s3) : void 0, h3 = void 0 === d3;
          if (h3) {
            var u3 = mt2(c3), g3 = !u3 && Ve2(c3), p3 = !u3 && !g3 && Xe2(c3);
            d3 = c3, u3 || g3 || p3 ? mt2(a3) ? d3 = a3 : Ys(a3) ? d3 = Cn(a3) : g3 ? (h3 = false, d3 = An(c3, true)) : p3 ? (h3 = false, d3 = so2(c3, true)) : d3 = [] : Et2(c3) || Oe2(c3) ? (d3 = a3, Oe2(a3) ? d3 = Zs(a3) : R2(a3) && !Vt2(a3) || (d3 = ho2(c3))) : h3 = false;
          }
          h3 && (s3.set(c3, d3), i3(d3, c3, o3, r3, s3), s3.delete(c3)), Ws(t4, n3, d3);
        }
      };
      const Js = function t4(e4, n3, o3, i3, r3) {
        e4 !== n3 && Ks(n3, function(s3, a3) {
          if (r3 || (r3 = new ye2()), R2(s3))
            Qs(e4, n3, a3, o3, t4, i3, r3);
          else {
            var c3 = i3 ? i3($s(e4, a3), s3, a3 + "", e4, n3, r3) : void 0;
            void 0 === c3 && (c3 = s3), Ws(e4, a3, c3);
          }
        }, pn2);
      };
      const Xs = function(t4) {
        return t4;
      };
      const ta2 = function(t4, e4, n3) {
        switch (n3.length) {
          case 0:
            return t4.call(e4);
          case 1:
            return t4.call(e4, n3[0]);
          case 2:
            return t4.call(e4, n3[0], n3[1]);
          case 3:
            return t4.call(e4, n3[0], n3[1], n3[2]);
        }
        return t4.apply(e4, n3);
      };
      var ea2 = Math.max;
      const na = function(t4, e4, n3) {
        return e4 = ea2(void 0 === e4 ? t4.length - 1 : e4, 0), function() {
          for (var o3 = arguments, i3 = -1, r3 = ea2(o3.length - e4, 0), s3 = Array(r3); ++i3 < r3; )
            s3[i3] = o3[e4 + i3];
          i3 = -1;
          for (var a3 = Array(e4 + 1); ++i3 < e4; )
            a3[i3] = o3[i3];
          return a3[e4] = n3(s3), ta2(t4, this, a3);
        };
      };
      const oa2 = function(t4) {
        return function() {
          return t4;
        };
      };
      const ia2 = Ee2 ? function(t4, e4) {
        return Ee2(t4, "toString", { configurable: true, enumerable: false, value: oa2(e4), writable: true });
      } : Xs;
      var ra2 = Date.now;
      const sa2 = function(t4) {
        var e4 = 0, n3 = 0;
        return function() {
          var o3 = ra2(), i3 = 16 - (o3 - n3);
          if (n3 = o3, i3 > 0) {
            if (++e4 >= 800)
              return arguments[0];
          } else
            e4 = 0;
          return t4.apply(void 0, arguments);
        };
      };
      const aa2 = sa2(ia2);
      const ca2 = function(t4, e4) {
        return aa2(na(t4, e4, Xs), t4 + "");
      };
      const la2 = function(t4, e4, n3) {
        if (!R2(n3))
          return false;
        var o3 = typeof e4;
        return !!("number" == o3 ? cn2(n3) && Ue2(e4, n3.length) : "string" == o3 && e4 in n3) && St2(n3[e4], t4);
      };
      const da2 = function(t4) {
        return ca2(function(e4, n3) {
          var o3 = -1, i3 = n3.length, r3 = i3 > 1 ? n3[i3 - 1] : void 0, s3 = i3 > 2 ? n3[2] : void 0;
          for (r3 = t4.length > 3 && "function" == typeof r3 ? (i3--, r3) : void 0, s3 && la2(n3[0], n3[1], s3) && (r3 = i3 < 3 ? void 0 : r3, i3 = 1), e4 = Object(e4); ++o3 < i3; ) {
            var a3 = n3[o3];
            a3 && t4(e4, a3, o3, r3);
          }
          return e4;
        });
      };
      const ha2 = da2(function(t4, e4, n3) {
        Js(t4, e4, n3);
      });
      const ua2 = function(t4, e4, n3, o3) {
        if (!R2(t4))
          return t4;
        for (var i3 = -1, r3 = (e4 = Ls(e4, t4)).length, s3 = r3 - 1, a3 = t4; null != a3 && ++i3 < r3; ) {
          var c3 = Rs(e4[i3]), l3 = n3;
          if ("__proto__" === c3 || "constructor" === c3 || "prototype" === c3)
            return t4;
          if (i3 != s3) {
            var d3 = a3[c3];
            void 0 === (l3 = o3 ? o3(d3, c3, a3) : void 0) && (l3 = R2(d3) ? d3 : Ue2(e4[i3 + 1]) ? [] : {});
          }
          Ie2(a3, c3, l3), a3 = a3[c3];
        }
        return t4;
      };
      const ga = function(t4, e4, n3) {
        return null == t4 ? t4 : ua2(t4, e4, n3);
      };
      class pa2 {
        constructor(t4) {
          this._styles = {}, this._styleProcessor = t4;
        }
        get isEmpty() {
          const t4 = Object.entries(this._styles);
          return !Array.from(t4).length;
        }
        get size() {
          return this.isEmpty ? 0 : this.getStyleNames().length;
        }
        setTo(t4) {
          this.clear();
          const e4 = Array.from(function(t5) {
            let e5 = null, n3 = 0, o3 = 0, i3 = null;
            const r3 = /* @__PURE__ */ new Map();
            if ("" === t5)
              return r3;
            ";" != t5.charAt(t5.length - 1) && (t5 += ";");
            for (let s3 = 0; s3 < t5.length; s3++) {
              const a3 = t5.charAt(s3);
              if (null === e5)
                switch (a3) {
                  case ":":
                    i3 || (i3 = t5.substr(n3, s3 - n3), o3 = s3 + 1);
                    break;
                  case '"':
                  case "'":
                    e5 = a3;
                    break;
                  case ";": {
                    const e6 = t5.substr(o3, s3 - o3);
                    i3 && r3.set(i3.trim(), e6.trim()), i3 = null, n3 = s3 + 1;
                    break;
                  }
                }
              else
                a3 === e5 && (e5 = null);
            }
            return r3;
          }(t4).entries());
          for (const [t5, n3] of e4)
            this._styleProcessor.toNormalizedForm(t5, n3, this._styles);
        }
        has(t4) {
          if (this.isEmpty)
            return false;
          const e4 = this._styleProcessor.getReducedForm(t4, this._styles).find(([e5]) => e5 === t4);
          return Array.isArray(e4);
        }
        set(t4, e4) {
          if (R2(t4))
            for (const [e5, n3] of Object.entries(t4))
              this._styleProcessor.toNormalizedForm(e5, n3, this._styles);
          else
            this._styleProcessor.toNormalizedForm(t4, e4, this._styles);
        }
        remove(t4) {
          const e4 = fa2(t4);
          qs(this._styles, e4), delete this._styles[t4], this._cleanEmptyObjectsOnPath(e4);
        }
        getNormalized(t4) {
          return this._styleProcessor.getNormalized(t4, this._styles);
        }
        toString() {
          return this.isEmpty ? "" : this._getStylesEntries().map((t4) => t4.join(":")).sort().join(";") + ";";
        }
        getAsString(t4) {
          if (this.isEmpty)
            return;
          if (this._styles[t4] && !R2(this._styles[t4]))
            return this._styles[t4];
          const e4 = this._styleProcessor.getReducedForm(t4, this._styles).find(([e5]) => e5 === t4);
          return Array.isArray(e4) ? e4[1] : void 0;
        }
        getStyleNames(t4 = false) {
          if (this.isEmpty)
            return [];
          if (t4)
            return this._styleProcessor.getStyleNames(this._styles);
          return this._getStylesEntries().map(([t5]) => t5);
        }
        clear() {
          this._styles = {};
        }
        _getStylesEntries() {
          const t4 = [], e4 = Object.keys(this._styles);
          for (const n3 of e4)
            t4.push(...this._styleProcessor.getReducedForm(n3, this._styles));
          return t4;
        }
        _cleanEmptyObjectsOnPath(t4) {
          const e4 = t4.split(".");
          if (!(e4.length > 1))
            return;
          const n3 = e4.splice(0, e4.length - 1).join("."), o3 = Gs(this._styles, n3);
          if (!o3)
            return;
          !Array.from(Object.keys(o3)).length && this.remove(n3);
        }
      }
      class ma2 {
        constructor() {
          this._normalizers = /* @__PURE__ */ new Map(), this._extractors = /* @__PURE__ */ new Map(), this._reducers = /* @__PURE__ */ new Map(), this._consumables = /* @__PURE__ */ new Map();
        }
        toNormalizedForm(t4, e4, n3) {
          if (R2(e4))
            ka2(n3, fa2(t4), e4);
          else if (this._normalizers.has(t4)) {
            const o3 = this._normalizers.get(t4), { path: i3, value: r3 } = o3(e4);
            ka2(n3, i3, r3);
          } else
            ka2(n3, t4, e4);
        }
        getNormalized(t4, e4) {
          if (!t4)
            return ha2({}, e4);
          if (void 0 !== e4[t4])
            return e4[t4];
          if (this._extractors.has(t4)) {
            const n3 = this._extractors.get(t4);
            if ("string" == typeof n3)
              return Gs(e4, n3);
            const o3 = n3(t4, e4);
            if (o3)
              return o3;
          }
          return Gs(e4, fa2(t4));
        }
        getReducedForm(t4, e4) {
          const n3 = this.getNormalized(t4, e4);
          if (void 0 === n3)
            return [];
          if (this._reducers.has(t4)) {
            return this._reducers.get(t4)(n3);
          }
          return [[t4, n3]];
        }
        getStyleNames(t4) {
          const e4 = Array.from(this._consumables.keys()).filter((e5) => {
            const n4 = this.getNormalized(e5, t4);
            return n4 && "object" == typeof n4 ? Object.keys(n4).length : n4;
          }), n3 = /* @__PURE__ */ new Set([...e4, ...Object.keys(t4)]);
          return Array.from(n3.values());
        }
        getRelatedStyles(t4) {
          return this._consumables.get(t4) || [];
        }
        setNormalizer(t4, e4) {
          this._normalizers.set(t4, e4);
        }
        setExtractor(t4, e4) {
          this._extractors.set(t4, e4);
        }
        setReducer(t4, e4) {
          this._reducers.set(t4, e4);
        }
        setStyleRelation(t4, e4) {
          this._mapStyleNames(t4, e4);
          for (const n3 of e4)
            this._mapStyleNames(n3, [t4]);
        }
        _mapStyleNames(t4, e4) {
          this._consumables.has(t4) || this._consumables.set(t4, []), this._consumables.get(t4).push(...e4);
        }
      }
      function fa2(t4) {
        return t4.replace("-", ".");
      }
      function ka2(t4, e4, n3) {
        let o3 = n3;
        R2(n3) && (o3 = ha2({}, Gs(t4, e4), n3)), ga(t4, e4, o3);
      }
      class ba extends ms {
        constructor(t4, e4, n3, o3) {
          if (super(t4), this._unsafeAttributesToRender = [], this._customProperties = /* @__PURE__ */ new Map(), this.name = e4, this._attrs = function(t5) {
            const e5 = Mi2(t5);
            for (const [t6, n4] of e5)
              null === n4 ? e5.delete(t6) : "string" != typeof n4 && e5.set(t6, String(n4));
            return e5;
          }(n3), this._children = [], o3 && this._insertChild(0, o3), this._classes = /* @__PURE__ */ new Set(), this._attrs.has("class")) {
            const t5 = this._attrs.get("class");
            wa2(this._classes, t5), this._attrs.delete("class");
          }
          this._styles = new pa2(this.document.stylesProcessor), this._attrs.has("style") && (this._styles.setTo(this._attrs.get("style")), this._attrs.delete("style"));
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return 0 === this._children.length;
        }
        getChild(t4) {
          return this._children[t4];
        }
        getChildIndex(t4) {
          return this._children.indexOf(t4);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        *getAttributeKeys() {
          this._classes.size > 0 && (yield "class"), this._styles.isEmpty || (yield "style"), yield* this._attrs.keys();
        }
        *getAttributes() {
          yield* this._attrs.entries(), this._classes.size > 0 && (yield ["class", this.getAttribute("class")]), this._styles.isEmpty || (yield ["style", this.getAttribute("style")]);
        }
        getAttribute(t4) {
          if ("class" == t4)
            return this._classes.size > 0 ? [...this._classes].join(" ") : void 0;
          if ("style" == t4) {
            const t5 = this._styles.toString();
            return "" == t5 ? void 0 : t5;
          }
          return this._attrs.get(t4);
        }
        hasAttribute(t4) {
          return "class" == t4 ? this._classes.size > 0 : "style" == t4 ? !this._styles.isEmpty : this._attrs.has(t4);
        }
        isSimilar(t4) {
          if (!(t4 instanceof ba))
            return false;
          if (this === t4)
            return true;
          if (this.name != t4.name)
            return false;
          if (this._attrs.size !== t4._attrs.size || this._classes.size !== t4._classes.size || this._styles.size !== t4._styles.size)
            return false;
          for (const [e4, n3] of this._attrs)
            if (!t4._attrs.has(e4) || t4._attrs.get(e4) !== n3)
              return false;
          for (const e4 of this._classes)
            if (!t4._classes.has(e4))
              return false;
          for (const e4 of this._styles.getStyleNames())
            if (!t4._styles.has(e4) || t4._styles.getAsString(e4) !== this._styles.getAsString(e4))
              return false;
          return true;
        }
        hasClass(...t4) {
          for (const e4 of t4)
            if (!this._classes.has(e4))
              return false;
          return true;
        }
        getClassNames() {
          return this._classes.keys();
        }
        getStyle(t4) {
          return this._styles.getAsString(t4);
        }
        getNormalizedStyle(t4) {
          return this._styles.getNormalized(t4);
        }
        getStyleNames(t4) {
          return this._styles.getStyleNames(t4);
        }
        hasStyle(...t4) {
          for (const e4 of t4)
            if (!this._styles.has(e4))
              return false;
          return true;
        }
        findAncestor(...t4) {
          const e4 = new bs(...t4);
          let n3 = this.parent;
          for (; n3 && !n3.is("documentFragment"); ) {
            if (e4.match(n3))
              return n3;
            n3 = n3.parent;
          }
          return null;
        }
        getCustomProperty(t4) {
          return this._customProperties.get(t4);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        getIdentity() {
          const t4 = Array.from(this._classes).sort().join(","), e4 = this._styles.toString(), n3 = Array.from(this._attrs).map((t5) => `${t5[0]}="${t5[1]}"`).sort().join(" ");
          return this.name + ("" == t4 ? "" : ` class="${t4}"`) + (e4 ? ` style="${e4}"` : "") + ("" == n3 ? "" : ` ${n3}`);
        }
        shouldRenderUnsafeAttribute(t4) {
          return this._unsafeAttributesToRender.includes(t4);
        }
        _clone(t4 = false) {
          const e4 = [];
          if (t4)
            for (const n4 of this.getChildren())
              e4.push(n4._clone(t4));
          const n3 = new this.constructor(this.document, this.name, this._attrs, e4);
          return n3._classes = new Set(this._classes), n3._styles.set(this._styles.getNormalized()), n3._customProperties = new Map(this._customProperties), n3.getFillerOffset = this.getFillerOffset, n3._unsafeAttributesToRender = this._unsafeAttributesToRender, n3;
        }
        _appendChild(t4) {
          return this._insertChild(this.childCount, t4);
        }
        _insertChild(t4, e4) {
          this._fireChange("children", this);
          let n3 = 0;
          const o3 = function(t5, e5) {
            if ("string" == typeof e5)
              return [new fs(t5, e5)];
            et2(e5) || (e5 = [e5]);
            return Array.from(e5).map((e6) => "string" == typeof e6 ? new fs(t5, e6) : e6 instanceof ks ? new fs(t5, e6.data) : e6);
          }(this.document, e4);
          for (const e5 of o3)
            null !== e5.parent && e5._remove(), e5.parent = this, e5.document = this.document, this._children.splice(t4, 0, e5), t4++, n3++;
          return n3;
        }
        _removeChildren(t4, e4 = 1) {
          this._fireChange("children", this);
          for (let n3 = t4; n3 < t4 + e4; n3++)
            this._children[n3].parent = null;
          return this._children.splice(t4, e4);
        }
        _setAttribute(t4, e4) {
          const n3 = String(e4);
          this._fireChange("attributes", this), "class" == t4 ? wa2(this._classes, n3) : "style" == t4 ? this._styles.setTo(n3) : this._attrs.set(t4, n3);
        }
        _removeAttribute(t4) {
          return this._fireChange("attributes", this), "class" == t4 ? this._classes.size > 0 && (this._classes.clear(), true) : "style" == t4 ? !this._styles.isEmpty && (this._styles.clear(), true) : this._attrs.delete(t4);
        }
        _addClass(t4) {
          this._fireChange("attributes", this);
          for (const e4 of _i(t4))
            this._classes.add(e4);
        }
        _removeClass(t4) {
          this._fireChange("attributes", this);
          for (const e4 of _i(t4))
            this._classes.delete(e4);
        }
        _setStyle(t4, e4) {
          this._fireChange("attributes", this), "string" != typeof t4 ? this._styles.set(t4) : this._styles.set(t4, e4);
        }
        _removeStyle(t4) {
          this._fireChange("attributes", this);
          for (const e4 of _i(t4))
            this._styles.remove(e4);
        }
        _setCustomProperty(t4, e4) {
          this._customProperties.set(t4, e4);
        }
        _removeCustomProperty(t4) {
          return this._customProperties.delete(t4);
        }
      }
      function wa2(t4, e4) {
        const n3 = e4.split(/\s+/);
        t4.clear(), n3.forEach((e5) => t4.add(e5));
      }
      ba.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("element" === t4 || "view:element" === t4) : "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
      };
      class Aa2 extends ba {
        constructor(t4, e4, n3, o3) {
          super(t4, e4, n3, o3), this.getFillerOffset = Ca2;
        }
      }
      function Ca2() {
        const t4 = [...this.getChildren()], e4 = t4[this.childCount - 1];
        if (e4 && e4.is("element", "br"))
          return this.childCount;
        for (const e5 of t4)
          if (!e5.is("uiElement"))
            return null;
        return this.childCount;
      }
      Aa2.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4) : "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
      };
      class _a extends W2(Aa2) {
        constructor(t4, e4, n3, o3) {
          super(t4, e4, n3, o3), this.set("isReadOnly", false), this.set("isFocused", false), this.set("placeholder", void 0), this.bind("isReadOnly").to(t4), this.bind("isFocused").to(t4, "isFocused", (e5) => e5 && t4.selection.editableElement == this), this.listenTo(t4.selection, "change", () => {
            this.isFocused = t4.isFocused && t4.selection.editableElement == this;
          });
        }
        destroy() {
          this.stopListening();
        }
      }
      _a.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("editableElement" === t4 || "view:editableElement" === t4 || "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4) : "editableElement" === t4 || "view:editableElement" === t4 || "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
      };
      const va2 = Symbol("rootName");
      class ya2 extends _a {
        constructor(t4, e4) {
          super(t4, e4), this.rootName = "main";
        }
        get rootName() {
          return this.getCustomProperty(va2);
        }
        set rootName(t4) {
          this._setCustomProperty(va2, t4);
        }
        set _name(t4) {
          this.name = t4;
        }
      }
      ya2.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("rootElement" === t4 || "view:rootElement" === t4 || "editableElement" === t4 || "view:editableElement" === t4 || "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4) : "rootElement" === t4 || "view:rootElement" === t4 || "editableElement" === t4 || "view:editableElement" === t4 || "containerElement" === t4 || "view:containerElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
      };
      class xa {
        constructor(t4 = {}) {
          if (!t4.boundaries && !t4.startPosition)
            throw new A2("view-tree-walker-no-start-position", null);
          if (t4.direction && "forward" != t4.direction && "backward" != t4.direction)
            throw new A2("view-tree-walker-unknown-direction", t4.startPosition, { direction: t4.direction });
          this.boundaries = t4.boundaries || null, t4.startPosition ? this._position = Ea2._createAt(t4.startPosition) : this._position = Ea2._createAt(t4.boundaries["backward" == t4.direction ? "end" : "start"]), this.direction = t4.direction || "forward", this.singleCharacters = !!t4.singleCharacters, this.shallow = !!t4.shallow, this.ignoreElementEnd = !!t4.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(t4) {
          let e4, n3;
          do {
            n3 = this.position, e4 = this.next();
          } while (!e4.done && t4(e4.value));
          e4.done || (this._position = n3);
        }
        next() {
          return "forward" == this.direction ? this._next() : this._previous();
        }
        _next() {
          let t4 = this.position.clone();
          const e4 = this.position, n3 = t4.parent;
          if (null === n3.parent && t4.offset === n3.childCount)
            return { done: true, value: void 0 };
          if (n3 === this._boundaryEndParent && t4.offset == this.boundaries.end.offset)
            return { done: true, value: void 0 };
          let o3;
          if (n3 instanceof fs) {
            if (t4.isAtEnd)
              return this._position = Ea2._createAfter(n3), this._next();
            o3 = n3.data[t4.offset];
          } else
            o3 = n3.getChild(t4.offset);
          if (o3 instanceof ba) {
            if (this.shallow) {
              if (this.boundaries && this.boundaries.end.isBefore(t4))
                return { done: true, value: void 0 };
              t4.offset++;
            } else
              t4 = new Ea2(o3, 0);
            return this._position = t4, this._formatReturnValue("elementStart", o3, e4, t4, 1);
          }
          if (o3 instanceof fs) {
            if (this.singleCharacters)
              return t4 = new Ea2(o3, 0), this._position = t4, this._next();
            let n4, i3 = o3.data.length;
            return o3 == this._boundaryEndParent ? (i3 = this.boundaries.end.offset, n4 = new ks(o3, 0, i3), t4 = Ea2._createAfter(n4)) : (n4 = new ks(o3, 0, o3.data.length), t4.offset++), this._position = t4, this._formatReturnValue("text", n4, e4, t4, i3);
          }
          if ("string" == typeof o3) {
            let o4;
            if (this.singleCharacters)
              o4 = 1;
            else {
              o4 = (n3 === this._boundaryEndParent ? this.boundaries.end.offset : n3.data.length) - t4.offset;
            }
            const i3 = new ks(n3, t4.offset, o4);
            return t4.offset += o4, this._position = t4, this._formatReturnValue("text", i3, e4, t4, o4);
          }
          return t4 = Ea2._createAfter(n3), this._position = t4, this.ignoreElementEnd ? this._next() : this._formatReturnValue("elementEnd", n3, e4, t4);
        }
        _previous() {
          let t4 = this.position.clone();
          const e4 = this.position, n3 = t4.parent;
          if (null === n3.parent && 0 === t4.offset)
            return { done: true, value: void 0 };
          if (n3 == this._boundaryStartParent && t4.offset == this.boundaries.start.offset)
            return { done: true, value: void 0 };
          let o3;
          if (n3 instanceof fs) {
            if (t4.isAtStart)
              return this._position = Ea2._createBefore(n3), this._previous();
            o3 = n3.data[t4.offset - 1];
          } else
            o3 = n3.getChild(t4.offset - 1);
          if (o3 instanceof ba)
            return this.shallow ? (t4.offset--, this._position = t4, this._formatReturnValue("elementStart", o3, e4, t4, 1)) : (t4 = new Ea2(o3, o3.childCount), this._position = t4, this.ignoreElementEnd ? this._previous() : this._formatReturnValue("elementEnd", o3, e4, t4));
          if (o3 instanceof fs) {
            if (this.singleCharacters)
              return t4 = new Ea2(o3, o3.data.length), this._position = t4, this._previous();
            let n4, i3 = o3.data.length;
            if (o3 == this._boundaryStartParent) {
              const e5 = this.boundaries.start.offset;
              n4 = new ks(o3, e5, o3.data.length - e5), i3 = n4.data.length, t4 = Ea2._createBefore(n4);
            } else
              n4 = new ks(o3, 0, o3.data.length), t4.offset--;
            return this._position = t4, this._formatReturnValue("text", n4, e4, t4, i3);
          }
          if ("string" == typeof o3) {
            let o4;
            if (this.singleCharacters)
              o4 = 1;
            else {
              const e5 = n3 === this._boundaryStartParent ? this.boundaries.start.offset : 0;
              o4 = t4.offset - e5;
            }
            t4.offset -= o4;
            const i3 = new ks(n3, t4.offset, o4);
            return this._position = t4, this._formatReturnValue("text", i3, e4, t4, o4);
          }
          return t4 = Ea2._createBefore(n3), this._position = t4, this._formatReturnValue("elementStart", n3, e4, t4, 1);
        }
        _formatReturnValue(t4, e4, n3, o3, i3) {
          return e4 instanceof ks && (e4.offsetInText + e4.data.length == e4.textNode.data.length && ("forward" != this.direction || this.boundaries && this.boundaries.end.isEqual(this.position) ? n3 = Ea2._createAfter(e4.textNode) : (o3 = Ea2._createAfter(e4.textNode), this._position = o3)), 0 === e4.offsetInText && ("backward" != this.direction || this.boundaries && this.boundaries.start.isEqual(this.position) ? n3 = Ea2._createBefore(e4.textNode) : (o3 = Ea2._createBefore(e4.textNode), this._position = o3))), { done: false, value: { type: t4, item: e4, previousPosition: n3, nextPosition: o3, length: i3 } };
        }
      }
      class Ea2 extends gs {
        constructor(t4, e4) {
          super(), this.parent = t4, this.offset = e4;
        }
        get nodeAfter() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset) || null;
        }
        get nodeBefore() {
          return this.parent.is("$text") ? null : this.parent.getChild(this.offset - 1) || null;
        }
        get isAtStart() {
          return 0 === this.offset;
        }
        get isAtEnd() {
          const t4 = this.parent.is("$text") ? this.parent.data.length : this.parent.childCount;
          return this.offset === t4;
        }
        get root() {
          return this.parent.root;
        }
        get editableElement() {
          let t4 = this.parent;
          for (; !(t4 instanceof _a); ) {
            if (!t4.parent)
              return null;
            t4 = t4.parent;
          }
          return t4;
        }
        getShiftedBy(t4) {
          const e4 = Ea2._createAt(this), n3 = e4.offset + t4;
          return e4.offset = n3 < 0 ? 0 : n3, e4;
        }
        getLastMatchingPosition(t4, e4 = {}) {
          e4.startPosition = this;
          const n3 = new xa(e4);
          return n3.skip(t4), n3.position;
        }
        getAncestors() {
          return this.parent.is("documentFragment") ? [this.parent] : this.parent.getAncestors({ includeSelf: true });
        }
        getCommonAncestor(t4) {
          const e4 = this.getAncestors(), n3 = t4.getAncestors();
          let o3 = 0;
          for (; e4[o3] == n3[o3] && e4[o3]; )
            o3++;
          return 0 === o3 ? null : e4[o3 - 1];
        }
        isEqual(t4) {
          return this.parent == t4.parent && this.offset == t4.offset;
        }
        isBefore(t4) {
          return "before" == this.compareWith(t4);
        }
        isAfter(t4) {
          return "after" == this.compareWith(t4);
        }
        compareWith(t4) {
          if (this.root !== t4.root)
            return "different";
          if (this.isEqual(t4))
            return "same";
          const e4 = this.parent.is("node") ? this.parent.getPath() : [], n3 = t4.parent.is("node") ? t4.parent.getPath() : [];
          e4.push(this.offset), n3.push(t4.offset);
          const o3 = tt2(e4, n3);
          switch (o3) {
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return e4[o3] < n3[o3] ? "before" : "after";
          }
        }
        getWalker(t4 = {}) {
          return t4.startPosition = this, new xa(t4);
        }
        clone() {
          return new Ea2(this.parent, this.offset);
        }
        static _createAt(t4, e4) {
          if (t4 instanceof Ea2)
            return new this(t4.parent, t4.offset);
          {
            const n3 = t4;
            if ("end" == e4)
              e4 = n3.is("$text") ? n3.data.length : n3.childCount;
            else {
              if ("before" == e4)
                return this._createBefore(n3);
              if ("after" == e4)
                return this._createAfter(n3);
              if (0 !== e4 && !e4)
                throw new A2("view-createpositionat-offset-required", n3);
            }
            return new Ea2(n3, e4);
          }
        }
        static _createAfter(t4) {
          if (t4.is("$textProxy"))
            return new Ea2(t4.textNode, t4.offsetInText + t4.data.length);
          if (!t4.parent)
            throw new A2("view-position-after-root", t4, { root: t4 });
          return new Ea2(t4.parent, t4.index + 1);
        }
        static _createBefore(t4) {
          if (t4.is("$textProxy"))
            return new Ea2(t4.textNode, t4.offsetInText);
          if (!t4.parent)
            throw new A2("view-position-before-root", t4, { root: t4 });
          return new Ea2(t4.parent, t4.index);
        }
      }
      Ea2.prototype.is = function(t4) {
        return "position" === t4 || "view:position" === t4;
      };
      class Da2 extends gs {
        constructor(t4, e4 = null) {
          super(), this.start = t4.clone(), this.end = e4 ? e4.clone() : t4.clone();
        }
        *[Symbol.iterator]() {
          yield* new xa({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return this.start.parent === this.end.parent;
        }
        get root() {
          return this.start.root;
        }
        getEnlarged() {
          let t4 = this.start.getLastMatchingPosition(Sa2, { direction: "backward" }), e4 = this.end.getLastMatchingPosition(Sa2);
          return t4.parent.is("$text") && t4.isAtStart && (t4 = Ea2._createBefore(t4.parent)), e4.parent.is("$text") && e4.isAtEnd && (e4 = Ea2._createAfter(e4.parent)), new Da2(t4, e4);
        }
        getTrimmed() {
          let t4 = this.start.getLastMatchingPosition(Sa2);
          if (t4.isAfter(this.end) || t4.isEqual(this.end))
            return new Da2(t4, t4);
          let e4 = this.end.getLastMatchingPosition(Sa2, { direction: "backward" });
          const n3 = t4.nodeAfter, o3 = e4.nodeBefore;
          return n3 && n3.is("$text") && (t4 = new Ea2(n3, 0)), o3 && o3.is("$text") && (e4 = new Ea2(o3, o3.data.length)), new Da2(t4, e4);
        }
        isEqual(t4) {
          return this == t4 || this.start.isEqual(t4.start) && this.end.isEqual(t4.end);
        }
        containsPosition(t4) {
          return t4.isAfter(this.start) && t4.isBefore(this.end);
        }
        containsRange(t4, e4 = false) {
          t4.isCollapsed && (e4 = false);
          const n3 = this.containsPosition(t4.start) || e4 && this.start.isEqual(t4.start), o3 = this.containsPosition(t4.end) || e4 && this.end.isEqual(t4.end);
          return n3 && o3;
        }
        getDifference(t4) {
          const e4 = [];
          return this.isIntersecting(t4) ? (this.containsPosition(t4.start) && e4.push(new Da2(this.start, t4.start)), this.containsPosition(t4.end) && e4.push(new Da2(t4.end, this.end))) : e4.push(this.clone()), e4;
        }
        getIntersection(t4) {
          if (this.isIntersecting(t4)) {
            let e4 = this.start, n3 = this.end;
            return this.containsPosition(t4.start) && (e4 = t4.start), this.containsPosition(t4.end) && (n3 = t4.end), new Da2(e4, n3);
          }
          return null;
        }
        getWalker(t4 = {}) {
          return t4.boundaries = this, new xa(t4);
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed)
            return null;
          let t4 = this.start.nodeAfter, e4 = this.end.nodeBefore;
          return this.start.parent.is("$text") && this.start.isAtEnd && this.start.parent.nextSibling && (t4 = this.start.parent.nextSibling), this.end.parent.is("$text") && this.end.isAtStart && this.end.parent.previousSibling && (e4 = this.end.parent.previousSibling), t4 && t4.is("element") && t4 === e4 ? t4 : null;
        }
        clone() {
          return new Da2(this.start, this.end);
        }
        *getItems(t4 = {}) {
          t4.boundaries = this, t4.ignoreElementEnd = true;
          const e4 = new xa(t4);
          for (const t5 of e4)
            yield t5.item;
        }
        *getPositions(t4 = {}) {
          t4.boundaries = this;
          const e4 = new xa(t4);
          yield e4.position;
          for (const t5 of e4)
            yield t5.nextPosition;
        }
        isIntersecting(t4) {
          return this.start.isBefore(t4.end) && this.end.isAfter(t4.start);
        }
        static _createFromParentsAndOffsets(t4, e4, n3, o3) {
          return new this(new Ea2(t4, e4), new Ea2(n3, o3));
        }
        static _createFromPositionAndShift(t4, e4) {
          const n3 = t4, o3 = t4.getShiftedBy(e4);
          return e4 > 0 ? new this(n3, o3) : new this(o3, n3);
        }
        static _createIn(t4) {
          return this._createFromParentsAndOffsets(t4, 0, t4, t4.childCount);
        }
        static _createOn(t4) {
          const e4 = t4.is("$textProxy") ? t4.offsetSize : 1;
          return this._createFromPositionAndShift(Ea2._createBefore(t4), e4);
        }
      }
      function Sa2(t4) {
        return !(!t4.item.is("attributeElement") && !t4.item.is("uiElement"));
      }
      Da2.prototype.is = function(t4) {
        return "range" === t4 || "view:range" === t4;
      };
      class Ia2 extends M2(gs) {
        constructor(...t4) {
          super(), this._ranges = [], this._lastRangeBackward = false, this._isFake = false, this._fakeSelectionLabel = "", t4.length && this.setTo(...t4);
        }
        get isFake() {
          return this._isFake;
        }
        get fakeSelectionLabel() {
          return this._fakeSelectionLabel;
        }
        get anchor() {
          if (!this._ranges.length)
            return null;
          const t4 = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? t4.end : t4.start).clone();
        }
        get focus() {
          if (!this._ranges.length)
            return null;
          const t4 = this._ranges[this._ranges.length - 1];
          return (this._lastRangeBackward ? t4.start : t4.end).clone();
        }
        get isCollapsed() {
          return 1 === this.rangeCount && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        get editableElement() {
          return this.anchor ? this.anchor.editableElement : null;
        }
        *getRanges() {
          for (const t4 of this._ranges)
            yield t4.clone();
        }
        getFirstRange() {
          let t4 = null;
          for (const e4 of this._ranges)
            t4 && !e4.start.isBefore(t4.start) || (t4 = e4);
          return t4 ? t4.clone() : null;
        }
        getLastRange() {
          let t4 = null;
          for (const e4 of this._ranges)
            t4 && !e4.end.isAfter(t4.end) || (t4 = e4);
          return t4 ? t4.clone() : null;
        }
        getFirstPosition() {
          const t4 = this.getFirstRange();
          return t4 ? t4.start.clone() : null;
        }
        getLastPosition() {
          const t4 = this.getLastRange();
          return t4 ? t4.end.clone() : null;
        }
        isEqual(t4) {
          if (this.isFake != t4.isFake)
            return false;
          if (this.isFake && this.fakeSelectionLabel != t4.fakeSelectionLabel)
            return false;
          if (this.rangeCount != t4.rangeCount)
            return false;
          if (0 === this.rangeCount)
            return true;
          if (!this.anchor.isEqual(t4.anchor) || !this.focus.isEqual(t4.focus))
            return false;
          for (const e4 of this._ranges) {
            let n3 = false;
            for (const o3 of t4._ranges)
              if (e4.isEqual(o3)) {
                n3 = true;
                break;
              }
            if (!n3)
              return false;
          }
          return true;
        }
        isSimilar(t4) {
          if (this.isBackward != t4.isBackward)
            return false;
          const e4 = X2(this.getRanges());
          if (e4 != X2(t4.getRanges()))
            return false;
          if (0 == e4)
            return true;
          for (let e5 of this.getRanges()) {
            e5 = e5.getTrimmed();
            let n3 = false;
            for (let o3 of t4.getRanges())
              if (o3 = o3.getTrimmed(), e5.start.isEqual(o3.start) && e5.end.isEqual(o3.end)) {
                n3 = true;
                break;
              }
            if (!n3)
              return false;
          }
          return true;
        }
        getSelectedElement() {
          return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
        }
        setTo(...t4) {
          let [e4, n3, o3] = t4;
          if ("object" == typeof n3 && (o3 = n3, n3 = void 0), null === e4)
            this._setRanges([]), this._setFakeOptions(o3);
          else if (e4 instanceof Ia2 || e4 instanceof Ta2)
            this._setRanges(e4.getRanges(), e4.isBackward), this._setFakeOptions({ fake: e4.isFake, label: e4.fakeSelectionLabel });
          else if (e4 instanceof Da2)
            this._setRanges([e4], o3 && o3.backward), this._setFakeOptions(o3);
          else if (e4 instanceof Ea2)
            this._setRanges([new Da2(e4)]), this._setFakeOptions(o3);
          else if (e4 instanceof ms) {
            const t5 = !!o3 && !!o3.backward;
            let i3;
            if (void 0 === n3)
              throw new A2("view-selection-setto-required-second-parameter", this);
            i3 = "in" == n3 ? Da2._createIn(e4) : "on" == n3 ? Da2._createOn(e4) : new Da2(Ea2._createAt(e4, n3)), this._setRanges([i3], t5), this._setFakeOptions(o3);
          } else {
            if (!et2(e4))
              throw new A2("view-selection-setto-not-selectable", this);
            this._setRanges(e4, o3 && o3.backward), this._setFakeOptions(o3);
          }
          this.fire("change");
        }
        setFocus(t4, e4) {
          if (null === this.anchor)
            throw new A2("view-selection-setfocus-no-ranges", this);
          const n3 = Ea2._createAt(t4, e4);
          if ("same" == n3.compareWith(this.focus))
            return;
          const o3 = this.anchor;
          this._ranges.pop(), "before" == n3.compareWith(o3) ? this._addRange(new Da2(n3, o3), true) : this._addRange(new Da2(o3, n3)), this.fire("change");
        }
        _setRanges(t4, e4 = false) {
          t4 = Array.from(t4), this._ranges = [];
          for (const e5 of t4)
            this._addRange(e5);
          this._lastRangeBackward = !!e4;
        }
        _setFakeOptions(t4 = {}) {
          this._isFake = !!t4.fake, this._fakeSelectionLabel = t4.fake && t4.label || "";
        }
        _addRange(t4, e4 = false) {
          if (!(t4 instanceof Da2))
            throw new A2("view-selection-add-range-not-range", this);
          this._pushRange(t4), this._lastRangeBackward = !!e4;
        }
        _pushRange(t4) {
          for (const e4 of this._ranges)
            if (t4.isIntersecting(e4))
              throw new A2("view-selection-range-intersects", this, { addedRange: t4, intersectingRange: e4 });
          this._ranges.push(new Da2(t4.start, t4.end));
        }
      }
      Ia2.prototype.is = function(t4) {
        return "selection" === t4 || "view:selection" === t4;
      };
      class Ta2 extends M2(gs) {
        constructor(...t4) {
          super(), this._selection = new Ia2(), this._selection.delegate("change").to(this), t4.length && this._selection.setTo(...t4);
        }
        get isFake() {
          return this._selection.isFake;
        }
        get fakeSelectionLabel() {
          return this._selection.fakeSelectionLabel;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get editableElement() {
          return this._selection.editableElement;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        *getRanges() {
          yield* this._selection.getRanges();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        isEqual(t4) {
          return this._selection.isEqual(t4);
        }
        isSimilar(t4) {
          return this._selection.isSimilar(t4);
        }
        _setTo(...t4) {
          this._selection.setTo(...t4);
        }
        _setFocus(t4, e4) {
          this._selection.setFocus(t4, e4);
        }
      }
      Ta2.prototype.is = function(t4) {
        return "selection" === t4 || "documentSelection" == t4 || "view:selection" == t4 || "view:documentSelection" == t4;
      };
      class Ma2 extends p2 {
        constructor(t4, e4, n3) {
          super(t4, e4), this.startRange = n3, this._eventPhase = "none", this._currentTarget = null;
        }
        get eventPhase() {
          return this._eventPhase;
        }
        get currentTarget() {
          return this._currentTarget;
        }
      }
      const Ba2 = Symbol("bubbling contexts");
      function Na2(t4) {
        return class extends t4 {
          fire(t5, ...e4) {
            try {
              const n3 = t5 instanceof p2 ? t5 : new p2(this, t5), o3 = La2(this);
              if (!o3.size)
                return;
              if (Pa2(n3, "capturing", this), za2(o3, "$capture", n3, ...e4))
                return n3.return;
              const i3 = n3.startRange || this.selection.getFirstRange(), r3 = i3 ? i3.getContainedElement() : null, s3 = !!r3 && Boolean(Oa2(o3, r3));
              let a3 = r3 || function(t6) {
                if (!t6)
                  return null;
                const e5 = t6.start.parent, n4 = t6.end.parent, o4 = e5.getPath(), i4 = n4.getPath();
                return o4.length > i4.length ? e5 : n4;
              }(i3);
              if (Pa2(n3, "atTarget", a3), !s3) {
                if (za2(o3, "$text", n3, ...e4))
                  return n3.return;
                Pa2(n3, "bubbling", a3);
              }
              for (; a3; ) {
                if (a3.is("rootElement")) {
                  if (za2(o3, "$root", n3, ...e4))
                    return n3.return;
                } else if (a3.is("element") && za2(o3, a3.name, n3, ...e4))
                  return n3.return;
                if (za2(o3, a3, n3, ...e4))
                  return n3.return;
                a3 = a3.parent, Pa2(n3, "bubbling", a3);
              }
              return Pa2(n3, "bubbling", this), za2(o3, "$document", n3, ...e4), n3.return;
            } catch (t6) {
              A2.rethrowUnexpectedError(t6, this);
            }
          }
          _addEventListener(t5, e4, n3) {
            const o3 = _i(n3.context || "$document"), i3 = La2(this);
            for (const r3 of o3) {
              let o4 = i3.get(r3);
              o4 || (o4 = new (M2())(), i3.set(r3, o4)), this.listenTo(o4, t5, e4, n3);
            }
          }
          _removeEventListener(t5, e4) {
            const n3 = La2(this);
            for (const o3 of n3.values())
              this.stopListening(o3, t5, e4);
          }
        };
      }
      {
        const t4 = Na2(Object);
        ["fire", "_addEventListener", "_removeEventListener"].forEach((e4) => {
          Na2[e4] = t4.prototype[e4];
        });
      }
      function Pa2(t4, e4, n3) {
        t4 instanceof Ma2 && (t4._eventPhase = e4, t4._currentTarget = n3);
      }
      function za2(t4, e4, n3, ...o3) {
        const i3 = "string" == typeof e4 ? t4.get(e4) : Oa2(t4, e4);
        return !!i3 && (i3.fire(n3, ...o3), n3.stop.called);
      }
      function Oa2(t4, e4) {
        for (const [n3, o3] of t4)
          if ("function" == typeof n3 && n3(e4))
            return o3;
        return null;
      }
      function La2(t4) {
        return t4[Ba2] || (t4[Ba2] = /* @__PURE__ */ new Map()), t4[Ba2];
      }
      class ja2 extends Na2(W2()) {
        constructor(t4) {
          super(), this._postFixers = /* @__PURE__ */ new Set(), this.selection = new Ta2(), this.roots = new Di2({ idProperty: "rootName" }), this.stylesProcessor = t4, this.set("isReadOnly", false), this.set("isFocused", false), this.set("isSelecting", false), this.set("isComposing", false);
        }
        getRoot(t4 = "main") {
          return this.roots.get(t4);
        }
        registerPostFixer(t4) {
          this._postFixers.add(t4);
        }
        destroy() {
          this.roots.map((t4) => t4.destroy()), this.stopListening();
        }
        _callPostFixers(t4) {
          let e4 = false;
          do {
            for (const n3 of this._postFixers)
              if (e4 = n3(t4), e4)
                break;
          } while (e4);
        }
      }
      class Ra2 extends ba {
        constructor(t4, e4, n3, o3) {
          super(t4, e4, n3, o3), this._priority = 10, this._id = null, this._clonesGroup = null, this.getFillerOffset = Fa2;
        }
        get priority() {
          return this._priority;
        }
        get id() {
          return this._id;
        }
        getElementsWithSameId() {
          if (null === this.id)
            throw new A2("attribute-element-get-elements-with-same-id-no-id", this);
          return new Set(this._clonesGroup);
        }
        isSimilar(t4) {
          return null !== this.id || null !== t4.id ? this.id === t4.id : super.isSimilar(t4) && this.priority == t4.priority;
        }
        _clone(t4 = false) {
          const e4 = super._clone(t4);
          return e4._priority = this._priority, e4._id = this._id, e4;
        }
      }
      function Fa2() {
        if (Va2(this))
          return null;
        let t4 = this.parent;
        for (; t4 && t4.is("attributeElement"); ) {
          if (Va2(t4) > 1)
            return null;
          t4 = t4.parent;
        }
        return !t4 || Va2(t4) > 1 ? null : this.childCount;
      }
      function Va2(t4) {
        return Array.from(t4.getChildren()).filter((t5) => !t5.is("uiElement")).length;
      }
      Ra2.DEFAULT_PRIORITY = 10, Ra2.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("attributeElement" === t4 || "view:attributeElement" === t4 || "element" === t4 || "view:element" === t4) : "attributeElement" === t4 || "view:attributeElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
      };
      class Ha2 extends ba {
        constructor(t4, e4, n3, o3) {
          super(t4, e4, n3, o3), this.getFillerOffset = Ua2;
        }
        _insertChild(t4, e4) {
          if (e4 && (e4 instanceof ms || Array.from(e4).length > 0))
            throw new A2("view-emptyelement-cannot-add", [this, e4]);
          return 0;
        }
      }
      function Ua2() {
        return null;
      }
      Ha2.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("emptyElement" === t4 || "view:emptyElement" === t4 || "element" === t4 || "view:element" === t4) : "emptyElement" === t4 || "view:emptyElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
      };
      class qa2 extends ba {
        constructor(t4, e4, n3, o3) {
          super(t4, e4, n3, o3), this.getFillerOffset = Wa2;
        }
        _insertChild(t4, e4) {
          if (e4 && (e4 instanceof ms || Array.from(e4).length > 0))
            throw new A2("view-uielement-cannot-add", [this, e4]);
          return 0;
        }
        render(t4, e4) {
          return this.toDomElement(t4);
        }
        toDomElement(t4) {
          const e4 = t4.createElement(this.name);
          for (const t5 of this.getAttributeKeys())
            e4.setAttribute(t5, this.getAttribute(t5));
          return e4;
        }
      }
      function Ga2(t4) {
        t4.document.on("arrowKey", (e4, n3) => function(t5, e5, n4) {
          if (e5.keyCode == fi2.arrowright) {
            const t6 = e5.domTarget.ownerDocument.defaultView.getSelection(), o3 = 1 == t6.rangeCount && t6.getRangeAt(0).collapsed;
            if (o3 || e5.shiftKey) {
              const e6 = t6.focusNode, i3 = t6.focusOffset, r3 = n4.domPositionToView(e6, i3);
              if (null === r3)
                return;
              let s3 = false;
              const a3 = r3.getLastMatchingPosition((t7) => (t7.item.is("uiElement") && (s3 = true), !(!t7.item.is("uiElement") && !t7.item.is("attributeElement"))));
              if (s3) {
                const e7 = n4.viewPositionToDom(a3);
                o3 ? t6.collapse(e7.parent, e7.offset) : t6.extend(e7.parent, e7.offset);
              }
            }
          }
        }(0, n3, t4.domConverter), { priority: "low" });
      }
      function Wa2() {
        return null;
      }
      qa2.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("uiElement" === t4 || "view:uiElement" === t4 || "element" === t4 || "view:element" === t4) : "uiElement" === t4 || "view:uiElement" === t4 || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
      };
      class Ka2 extends ba {
        constructor(t4, e4, n3, o3) {
          super(t4, e4, n3, o3), this.getFillerOffset = Ya2;
        }
        _insertChild(t4, e4) {
          if (e4 && (e4 instanceof ms || Array.from(e4).length > 0))
            throw new A2("view-rawelement-cannot-add", [this, e4]);
          return 0;
        }
        render(t4, e4) {
        }
      }
      function Ya2() {
        return null;
      }
      Ka2.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("rawElement" === t4 || "view:rawElement" === t4 || "element" === t4 || "view:element" === t4) : "rawElement" === t4 || "view:rawElement" === t4 || t4 === this.name || t4 === "view:" + this.name || "element" === t4 || "view:element" === t4 || "node" === t4 || "view:node" === t4;
      };
      class $a extends M2(gs) {
        constructor(t4, e4) {
          super(), this._children = [], this._customProperties = /* @__PURE__ */ new Map(), this.document = t4, e4 && this._insertChild(0, e4);
        }
        [Symbol.iterator]() {
          return this._children[Symbol.iterator]();
        }
        get childCount() {
          return this._children.length;
        }
        get isEmpty() {
          return 0 === this.childCount;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get name() {
        }
        getCustomProperty(t4) {
          return this._customProperties.get(t4);
        }
        *getCustomProperties() {
          yield* this._customProperties.entries();
        }
        _appendChild(t4) {
          return this._insertChild(this.childCount, t4);
        }
        getChild(t4) {
          return this._children[t4];
        }
        getChildIndex(t4) {
          return this._children.indexOf(t4);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        _insertChild(t4, e4) {
          this._fireChange("children", this);
          let n3 = 0;
          const o3 = function(t5, e5) {
            if ("string" == typeof e5)
              return [new fs(t5, e5)];
            et2(e5) || (e5 = [e5]);
            return Array.from(e5).map((e6) => "string" == typeof e6 ? new fs(t5, e6) : e6 instanceof ks ? new fs(t5, e6.data) : e6);
          }(this.document, e4);
          for (const e5 of o3)
            null !== e5.parent && e5._remove(), e5.parent = this, this._children.splice(t4, 0, e5), t4++, n3++;
          return n3;
        }
        _removeChildren(t4, e4 = 1) {
          this._fireChange("children", this);
          for (let n3 = t4; n3 < t4 + e4; n3++)
            this._children[n3].parent = null;
          return this._children.splice(t4, e4);
        }
        _fireChange(t4, e4) {
          this.fire("change:" + t4, e4);
        }
        _setCustomProperty(t4, e4) {
          this._customProperties.set(t4, e4);
        }
        _removeCustomProperty(t4) {
          return this._customProperties.delete(t4);
        }
      }
      $a.prototype.is = function(t4) {
        return "documentFragment" === t4 || "view:documentFragment" === t4;
      };
      class Za2 {
        constructor(t4) {
          this._cloneGroups = /* @__PURE__ */ new Map(), this._slotFactory = null, this.document = t4;
        }
        setSelection(...t4) {
          this.document.selection._setTo(...t4);
        }
        setSelectionFocus(t4, e4) {
          this.document.selection._setFocus(t4, e4);
        }
        createDocumentFragment(t4) {
          return new $a(this.document, t4);
        }
        createText(t4) {
          return new fs(this.document, t4);
        }
        createAttributeElement(t4, e4, n3 = {}) {
          const o3 = new Ra2(this.document, t4, e4);
          return "number" == typeof n3.priority && (o3._priority = n3.priority), n3.id && (o3._id = n3.id), n3.renderUnsafeAttributes && o3._unsafeAttributesToRender.push(...n3.renderUnsafeAttributes), o3;
        }
        createContainerElement(t4, e4, n3 = {}, o3 = {}) {
          let i3 = null;
          Et2(n3) ? o3 = n3 : i3 = n3;
          const r3 = new Aa2(this.document, t4, e4, i3);
          return o3.renderUnsafeAttributes && r3._unsafeAttributesToRender.push(...o3.renderUnsafeAttributes), r3;
        }
        createEditableElement(t4, e4, n3 = {}) {
          const o3 = new _a(this.document, t4, e4);
          return n3.renderUnsafeAttributes && o3._unsafeAttributesToRender.push(...n3.renderUnsafeAttributes), o3;
        }
        createEmptyElement(t4, e4, n3 = {}) {
          const o3 = new Ha2(this.document, t4, e4);
          return n3.renderUnsafeAttributes && o3._unsafeAttributesToRender.push(...n3.renderUnsafeAttributes), o3;
        }
        createUIElement(t4, e4, n3) {
          const o3 = new qa2(this.document, t4, e4);
          return n3 && (o3.render = n3), o3;
        }
        createRawElement(t4, e4, n3, o3 = {}) {
          const i3 = new Ka2(this.document, t4, e4);
          return n3 && (i3.render = n3), o3.renderUnsafeAttributes && i3._unsafeAttributesToRender.push(...o3.renderUnsafeAttributes), i3;
        }
        setAttribute(t4, e4, n3) {
          n3._setAttribute(t4, e4);
        }
        removeAttribute(t4, e4) {
          e4._removeAttribute(t4);
        }
        addClass(t4, e4) {
          e4._addClass(t4);
        }
        removeClass(t4, e4) {
          e4._removeClass(t4);
        }
        setStyle(t4, e4, n3) {
          Et2(t4) && void 0 === n3 ? e4._setStyle(t4) : n3._setStyle(t4, e4);
        }
        removeStyle(t4, e4) {
          e4._removeStyle(t4);
        }
        setCustomProperty(t4, e4, n3) {
          n3._setCustomProperty(t4, e4);
        }
        removeCustomProperty(t4, e4) {
          return e4._removeCustomProperty(t4);
        }
        breakAttributes(t4) {
          return t4 instanceof Ea2 ? this._breakAttributes(t4) : this._breakAttributesRange(t4);
        }
        breakContainer(t4) {
          const e4 = t4.parent;
          if (!e4.is("containerElement"))
            throw new A2("view-writer-break-non-container-element", this.document);
          if (!e4.parent)
            throw new A2("view-writer-break-root", this.document);
          if (t4.isAtStart)
            return Ea2._createBefore(e4);
          if (!t4.isAtEnd) {
            const n3 = e4._clone(false);
            this.insert(Ea2._createAfter(e4), n3);
            const o3 = new Da2(t4, Ea2._createAt(e4, "end")), i3 = new Ea2(n3, 0);
            this.move(o3, i3);
          }
          return Ea2._createAfter(e4);
        }
        mergeAttributes(t4) {
          const e4 = t4.offset, n3 = t4.parent;
          if (n3.is("$text"))
            return t4;
          if (n3.is("attributeElement") && 0 === n3.childCount) {
            const t5 = n3.parent, e5 = n3.index;
            return n3._remove(), this._removeFromClonedElementsGroup(n3), this.mergeAttributes(new Ea2(t5, e5));
          }
          const o3 = n3.getChild(e4 - 1), i3 = n3.getChild(e4);
          if (!o3 || !i3)
            return t4;
          if (o3.is("$text") && i3.is("$text"))
            return ec2(o3, i3);
          if (o3.is("attributeElement") && i3.is("attributeElement") && o3.isSimilar(i3)) {
            const t5 = o3.childCount;
            return o3._appendChild(i3.getChildren()), i3._remove(), this._removeFromClonedElementsGroup(i3), this.mergeAttributes(new Ea2(o3, t5));
          }
          return t4;
        }
        mergeContainers(t4) {
          const e4 = t4.nodeBefore, n3 = t4.nodeAfter;
          if (!(e4 && n3 && e4.is("containerElement") && n3.is("containerElement")))
            throw new A2("view-writer-merge-containers-invalid-position", this.document);
          const o3 = e4.getChild(e4.childCount - 1), i3 = o3 instanceof fs ? Ea2._createAt(o3, "end") : Ea2._createAt(e4, "end");
          return this.move(Da2._createIn(n3), Ea2._createAt(e4, "end")), this.remove(Da2._createOn(n3)), i3;
        }
        insert(t4, e4) {
          oc2(e4 = et2(e4) ? [...e4] : [e4], this.document);
          const n3 = e4.reduce((t5, e5) => {
            const n4 = t5[t5.length - 1], o4 = !e5.is("uiElement");
            return n4 && n4.breakAttributes == o4 ? n4.nodes.push(e5) : t5.push({ breakAttributes: o4, nodes: [e5] }), t5;
          }, []);
          let o3 = null, i3 = t4;
          for (const { nodes: t5, breakAttributes: e5 } of n3) {
            const n4 = this._insertNodes(i3, t5, e5);
            o3 || (o3 = n4.start), i3 = n4.end;
          }
          return o3 ? new Da2(o3, i3) : new Da2(t4);
        }
        remove(t4) {
          const e4 = t4 instanceof Da2 ? t4 : Da2._createOn(t4);
          if (rc2(e4, this.document), e4.isCollapsed)
            return new $a(this.document);
          const { start: n3, end: o3 } = this._breakAttributesRange(e4, true), i3 = n3.parent, r3 = o3.offset - n3.offset, s3 = i3._removeChildren(n3.offset, r3);
          for (const t5 of s3)
            this._removeFromClonedElementsGroup(t5);
          const a3 = this.mergeAttributes(n3);
          return e4.start = a3, e4.end = a3.clone(), new $a(this.document, s3);
        }
        clear(t4, e4) {
          rc2(t4, this.document);
          const n3 = t4.getWalker({ direction: "backward", ignoreElementEnd: true });
          for (const o3 of n3) {
            const n4 = o3.item;
            let i3;
            if (n4.is("element") && e4.isSimilar(n4))
              i3 = Da2._createOn(n4);
            else if (!o3.nextPosition.isAfter(t4.start) && n4.is("$textProxy")) {
              const t5 = n4.getAncestors().find((t6) => t6.is("element") && e4.isSimilar(t6));
              t5 && (i3 = Da2._createIn(t5));
            }
            i3 && (i3.end.isAfter(t4.end) && (i3.end = t4.end), i3.start.isBefore(t4.start) && (i3.start = t4.start), this.remove(i3));
          }
        }
        move(t4, e4) {
          let n3;
          if (e4.isAfter(t4.end)) {
            const o3 = (e4 = this._breakAttributes(e4, true)).parent, i3 = o3.childCount;
            t4 = this._breakAttributesRange(t4, true), n3 = this.remove(t4), e4.offset += o3.childCount - i3;
          } else
            n3 = this.remove(t4);
          return this.insert(e4, n3);
        }
        wrap(t4, e4) {
          if (!(e4 instanceof Ra2))
            throw new A2("view-writer-wrap-invalid-attribute", this.document);
          if (rc2(t4, this.document), t4.isCollapsed) {
            let o3 = t4.start;
            o3.parent.is("element") && (n3 = o3.parent, !Array.from(n3.getChildren()).some((t5) => !t5.is("uiElement"))) && (o3 = o3.getLastMatchingPosition((t5) => t5.item.is("uiElement"))), o3 = this._wrapPosition(o3, e4);
            const i3 = this.document.selection;
            return i3.isCollapsed && i3.getFirstPosition().isEqual(t4.start) && this.setSelection(o3), new Da2(o3);
          }
          return this._wrapRange(t4, e4);
          var n3;
        }
        unwrap(t4, e4) {
          if (!(e4 instanceof Ra2))
            throw new A2("view-writer-unwrap-invalid-attribute", this.document);
          if (rc2(t4, this.document), t4.isCollapsed)
            return t4;
          const { start: n3, end: o3 } = this._breakAttributesRange(t4, true), i3 = n3.parent, r3 = this._unwrapChildren(i3, n3.offset, o3.offset, e4), s3 = this.mergeAttributes(r3.start);
          s3.isEqual(r3.start) || r3.end.offset--;
          const a3 = this.mergeAttributes(r3.end);
          return new Da2(s3, a3);
        }
        rename(t4, e4) {
          const n3 = new Aa2(this.document, t4, e4.getAttributes());
          return this.insert(Ea2._createAfter(e4), n3), this.move(Da2._createIn(e4), Ea2._createAt(n3, 0)), this.remove(Da2._createOn(e4)), n3;
        }
        clearClonedElementsGroup(t4) {
          this._cloneGroups.delete(t4);
        }
        createPositionAt(t4, e4) {
          return Ea2._createAt(t4, e4);
        }
        createPositionAfter(t4) {
          return Ea2._createAfter(t4);
        }
        createPositionBefore(t4) {
          return Ea2._createBefore(t4);
        }
        createRange(t4, e4) {
          return new Da2(t4, e4);
        }
        createRangeOn(t4) {
          return Da2._createOn(t4);
        }
        createRangeIn(t4) {
          return Da2._createIn(t4);
        }
        createSelection(...t4) {
          return new Ia2(...t4);
        }
        createSlot(t4 = "children") {
          if (!this._slotFactory)
            throw new A2("view-writer-invalid-create-slot-context", this.document);
          return this._slotFactory(this, t4);
        }
        _registerSlotFactory(t4) {
          this._slotFactory = t4;
        }
        _clearSlotFactory() {
          this._slotFactory = null;
        }
        _insertNodes(t4, e4, n3) {
          let o3, i3;
          if (o3 = n3 ? Qa2(t4) : t4.parent.is("$text") ? t4.parent.parent : t4.parent, !o3)
            throw new A2("view-writer-invalid-position-container", this.document);
          i3 = n3 ? this._breakAttributes(t4, true) : t4.parent.is("$text") ? tc2(t4) : t4;
          const r3 = o3._insertChild(i3.offset, e4);
          for (const t5 of e4)
            this._addToClonedElementsGroup(t5);
          const s3 = i3.getShiftedBy(r3), a3 = this.mergeAttributes(i3);
          a3.isEqual(i3) || s3.offset--;
          const c3 = this.mergeAttributes(s3);
          return new Da2(a3, c3);
        }
        _wrapChildren(t4, e4, n3, o3) {
          let i3 = e4;
          const r3 = [];
          for (; i3 < n3; ) {
            const e5 = t4.getChild(i3), n4 = e5.is("$text"), s4 = e5.is("attributeElement");
            if (s4 && this._wrapAttributeElement(o3, e5))
              r3.push(new Ea2(t4, i3));
            else if (n4 || !s4 || Ja2(o3, e5)) {
              const n5 = o3._clone();
              e5._remove(), n5._appendChild(e5), t4._insertChild(i3, n5), this._addToClonedElementsGroup(n5), r3.push(new Ea2(t4, i3));
            } else
              this._wrapChildren(e5, 0, e5.childCount, o3);
            i3++;
          }
          let s3 = 0;
          for (const t5 of r3) {
            if (t5.offset -= s3, t5.offset == e4)
              continue;
            this.mergeAttributes(t5).isEqual(t5) || (s3++, n3--);
          }
          return Da2._createFromParentsAndOffsets(t4, e4, t4, n3);
        }
        _unwrapChildren(t4, e4, n3, o3) {
          let i3 = e4;
          const r3 = [];
          for (; i3 < n3; ) {
            const e5 = t4.getChild(i3);
            if (e5.is("attributeElement"))
              if (e5.isSimilar(o3)) {
                const o4 = e5.getChildren(), s4 = e5.childCount;
                e5._remove(), t4._insertChild(i3, o4), this._removeFromClonedElementsGroup(e5), r3.push(new Ea2(t4, i3), new Ea2(t4, i3 + s4)), i3 += s4, n3 += s4 - 1;
              } else
                this._unwrapAttributeElement(o3, e5) ? (r3.push(new Ea2(t4, i3), new Ea2(t4, i3 + 1)), i3++) : (this._unwrapChildren(e5, 0, e5.childCount, o3), i3++);
            else
              i3++;
          }
          let s3 = 0;
          for (const t5 of r3) {
            if (t5.offset -= s3, t5.offset == e4 || t5.offset == n3)
              continue;
            this.mergeAttributes(t5).isEqual(t5) || (s3++, n3--);
          }
          return Da2._createFromParentsAndOffsets(t4, e4, t4, n3);
        }
        _wrapRange(t4, e4) {
          const { start: n3, end: o3 } = this._breakAttributesRange(t4, true), i3 = n3.parent, r3 = this._wrapChildren(i3, n3.offset, o3.offset, e4), s3 = this.mergeAttributes(r3.start);
          s3.isEqual(r3.start) || r3.end.offset--;
          const a3 = this.mergeAttributes(r3.end);
          return new Da2(s3, a3);
        }
        _wrapPosition(t4, e4) {
          if (e4.isSimilar(t4.parent))
            return Xa2(t4.clone());
          t4.parent.is("$text") && (t4 = tc2(t4));
          const n3 = this.createAttributeElement("_wrapPosition-fake-element");
          n3._priority = Number.POSITIVE_INFINITY, n3.isSimilar = () => false, t4.parent._insertChild(t4.offset, n3);
          const o3 = new Da2(t4, t4.getShiftedBy(1));
          this.wrap(o3, e4);
          const i3 = new Ea2(n3.parent, n3.index);
          n3._remove();
          const r3 = i3.nodeBefore, s3 = i3.nodeAfter;
          return r3 instanceof fs && s3 instanceof fs ? ec2(r3, s3) : Xa2(i3);
        }
        _wrapAttributeElement(t4, e4) {
          if (!sc2(t4, e4))
            return false;
          if (t4.name !== e4.name || t4.priority !== e4.priority)
            return false;
          for (const n3 of t4.getAttributeKeys())
            if ("class" !== n3 && "style" !== n3 && e4.hasAttribute(n3) && e4.getAttribute(n3) !== t4.getAttribute(n3))
              return false;
          for (const n3 of t4.getStyleNames())
            if (e4.hasStyle(n3) && e4.getStyle(n3) !== t4.getStyle(n3))
              return false;
          for (const n3 of t4.getAttributeKeys())
            "class" !== n3 && "style" !== n3 && (e4.hasAttribute(n3) || this.setAttribute(n3, t4.getAttribute(n3), e4));
          for (const n3 of t4.getStyleNames())
            e4.hasStyle(n3) || this.setStyle(n3, t4.getStyle(n3), e4);
          for (const n3 of t4.getClassNames())
            e4.hasClass(n3) || this.addClass(n3, e4);
          return true;
        }
        _unwrapAttributeElement(t4, e4) {
          if (!sc2(t4, e4))
            return false;
          if (t4.name !== e4.name || t4.priority !== e4.priority)
            return false;
          for (const n3 of t4.getAttributeKeys())
            if ("class" !== n3 && "style" !== n3 && (!e4.hasAttribute(n3) || e4.getAttribute(n3) !== t4.getAttribute(n3)))
              return false;
          if (!e4.hasClass(...t4.getClassNames()))
            return false;
          for (const n3 of t4.getStyleNames())
            if (!e4.hasStyle(n3) || e4.getStyle(n3) !== t4.getStyle(n3))
              return false;
          for (const n3 of t4.getAttributeKeys())
            "class" !== n3 && "style" !== n3 && this.removeAttribute(n3, e4);
          return this.removeClass(Array.from(t4.getClassNames()), e4), this.removeStyle(Array.from(t4.getStyleNames()), e4), true;
        }
        _breakAttributesRange(t4, e4 = false) {
          const n3 = t4.start, o3 = t4.end;
          if (rc2(t4, this.document), t4.isCollapsed) {
            const n4 = this._breakAttributes(t4.start, e4);
            return new Da2(n4, n4);
          }
          const i3 = this._breakAttributes(o3, e4), r3 = i3.parent.childCount, s3 = this._breakAttributes(n3, e4);
          return i3.offset += i3.parent.childCount - r3, new Da2(s3, i3);
        }
        _breakAttributes(t4, e4 = false) {
          const n3 = t4.offset, o3 = t4.parent;
          if (t4.parent.is("emptyElement"))
            throw new A2("view-writer-cannot-break-empty-element", this.document);
          if (t4.parent.is("uiElement"))
            throw new A2("view-writer-cannot-break-ui-element", this.document);
          if (t4.parent.is("rawElement"))
            throw new A2("view-writer-cannot-break-raw-element", this.document);
          if (!e4 && o3.is("$text") && ic2(o3.parent))
            return t4.clone();
          if (ic2(o3))
            return t4.clone();
          if (o3.is("$text"))
            return this._breakAttributes(tc2(t4), e4);
          if (n3 == o3.childCount) {
            const t5 = new Ea2(o3.parent, o3.index + 1);
            return this._breakAttributes(t5, e4);
          }
          if (0 === n3) {
            const t5 = new Ea2(o3.parent, o3.index);
            return this._breakAttributes(t5, e4);
          }
          {
            const t5 = o3.index + 1, i3 = o3._clone();
            o3.parent._insertChild(t5, i3), this._addToClonedElementsGroup(i3);
            const r3 = o3.childCount - n3, s3 = o3._removeChildren(n3, r3);
            i3._appendChild(s3);
            const a3 = new Ea2(o3.parent, t5);
            return this._breakAttributes(a3, e4);
          }
        }
        _addToClonedElementsGroup(t4) {
          if (!t4.root.is("rootElement"))
            return;
          if (t4.is("element"))
            for (const e5 of t4.getChildren())
              this._addToClonedElementsGroup(e5);
          const e4 = t4.id;
          if (!e4)
            return;
          let n3 = this._cloneGroups.get(e4);
          n3 || (n3 = /* @__PURE__ */ new Set(), this._cloneGroups.set(e4, n3)), n3.add(t4), t4._clonesGroup = n3;
        }
        _removeFromClonedElementsGroup(t4) {
          if (t4.is("element"))
            for (const e5 of t4.getChildren())
              this._removeFromClonedElementsGroup(e5);
          const e4 = t4.id;
          if (!e4)
            return;
          const n3 = this._cloneGroups.get(e4);
          n3 && n3.delete(t4);
        }
      }
      function Qa2(t4) {
        let e4 = t4.parent;
        for (; !ic2(e4); ) {
          if (!e4)
            return;
          e4 = e4.parent;
        }
        return e4;
      }
      function Ja2(t4, e4) {
        return t4.priority < e4.priority || !(t4.priority > e4.priority) && t4.getIdentity() < e4.getIdentity();
      }
      function Xa2(t4) {
        const e4 = t4.nodeBefore;
        if (e4 && e4.is("$text"))
          return new Ea2(e4, e4.data.length);
        const n3 = t4.nodeAfter;
        return n3 && n3.is("$text") ? new Ea2(n3, 0) : t4;
      }
      function tc2(t4) {
        if (t4.offset == t4.parent.data.length)
          return new Ea2(t4.parent.parent, t4.parent.index + 1);
        if (0 === t4.offset)
          return new Ea2(t4.parent.parent, t4.parent.index);
        const e4 = t4.parent.data.slice(t4.offset);
        return t4.parent._data = t4.parent.data.slice(0, t4.offset), t4.parent.parent._insertChild(t4.parent.index + 1, new fs(t4.root.document, e4)), new Ea2(t4.parent.parent, t4.parent.index + 1);
      }
      function ec2(t4, e4) {
        const n3 = t4.data.length;
        return t4._data += e4.data, e4._remove(), new Ea2(t4, n3);
      }
      const nc2 = [fs, Ra2, Aa2, Ha2, Ka2, qa2];
      function oc2(t4, e4) {
        for (const n3 of t4) {
          if (!nc2.some((t5) => n3 instanceof t5))
            throw new A2("view-writer-insert-invalid-node-type", e4);
          n3.is("$text") || oc2(n3.getChildren(), e4);
        }
      }
      function ic2(t4) {
        return t4 && (t4.is("containerElement") || t4.is("documentFragment"));
      }
      function rc2(t4, e4) {
        const n3 = Qa2(t4.start), o3 = Qa2(t4.end);
        if (!n3 || !o3 || n3 !== o3)
          throw new A2("view-writer-invalid-range-container", e4);
      }
      function sc2(t4, e4) {
        return null === t4.id && null === e4.id;
      }
      const ac2 = (t4) => t4.createTextNode(" "), cc2 = (t4) => {
        const e4 = t4.createElement("span");
        return e4.dataset.ckeFiller = "true", e4.innerText = " ", e4;
      }, lc2 = (t4) => {
        const e4 = t4.createElement("br");
        return e4.dataset.ckeFiller = "true", e4;
      }, dc2 = 7, hc2 = "⁠".repeat(dc2);
      function uc2(t4) {
        return "string" == typeof t4 ? t4.substr(0, dc2) === hc2 : Oo2(t4) && t4.data.substr(0, dc2) === hc2;
      }
      function gc2(t4) {
        return t4.data.length == dc2 && uc2(t4);
      }
      function pc2(t4) {
        const e4 = "string" == typeof t4 ? t4 : t4.data;
        return uc2(t4) ? e4.slice(dc2) : e4;
      }
      function mc2(t4, e4) {
        if (e4.keyCode == fi2.arrowleft) {
          const t5 = e4.domTarget.ownerDocument.defaultView.getSelection();
          if (1 == t5.rangeCount && t5.getRangeAt(0).collapsed) {
            const e5 = t5.getRangeAt(0).startContainer, n3 = t5.getRangeAt(0).startOffset;
            uc2(e5) && n3 <= dc2 && t5.collapse(e5, 0);
          }
        }
      }
      var fc2 = n2(9315), kc2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(fc2.Z, kc2);
      fc2.Z.locals;
      class bc2 extends W2() {
        constructor(t4, e4) {
          super(), this.domDocuments = /* @__PURE__ */ new Set(), this.markedAttributes = /* @__PURE__ */ new Set(), this.markedChildren = /* @__PURE__ */ new Set(), this.markedTexts = /* @__PURE__ */ new Set(), this._inlineFiller = null, this._fakeSelectionContainer = null, this.domConverter = t4, this.selection = e4, this.set("isFocused", false), this.set("isSelecting", false), a2.isBlink && !a2.isAndroid && this.on("change:isSelecting", () => {
            this.isSelecting || this.render();
          }), this.set("isComposing", false), this.on("change:isComposing", () => {
            this.isComposing || this.render();
          });
        }
        markToSync(t4, e4) {
          if ("text" === t4)
            this.domConverter.mapViewToDom(e4.parent) && this.markedTexts.add(e4);
          else {
            if (!this.domConverter.mapViewToDom(e4))
              return;
            if ("attributes" === t4)
              this.markedAttributes.add(e4);
            else {
              if ("children" !== t4) {
                throw new A2("view-renderer-unknown-type", this);
              }
              this.markedChildren.add(e4);
            }
          }
        }
        render() {
          if (this.isComposing && !a2.isAndroid)
            return;
          let t4 = null;
          const e4 = !(a2.isBlink && !a2.isAndroid) || !this.isSelecting;
          for (const t5 of this.markedChildren)
            this._updateChildrenMappings(t5);
          e4 ? (this._inlineFiller && !this._isSelectionInInlineFiller() && this._removeInlineFiller(), this._inlineFiller ? t4 = this._getInlineFillerPosition() : this._needsInlineFillerAtSelection() && (t4 = this.selection.getFirstPosition(), this.markedChildren.add(t4.parent))) : this._inlineFiller && this._inlineFiller.parentNode && (t4 = this.domConverter.domPositionToView(this._inlineFiller), t4 && t4.parent.is("$text") && (t4 = Ea2._createBefore(t4.parent)));
          for (const t5 of this.markedAttributes)
            this._updateAttrs(t5);
          for (const e5 of this.markedChildren)
            this._updateChildren(e5, { inlineFillerPosition: t4 });
          for (const e5 of this.markedTexts)
            !this.markedChildren.has(e5.parent) && this.domConverter.mapViewToDom(e5.parent) && this._updateText(e5, { inlineFillerPosition: t4 });
          if (e4)
            if (t4) {
              const e5 = this.domConverter.viewPositionToDom(t4), n3 = e5.parent.ownerDocument;
              uc2(e5.parent) ? this._inlineFiller = e5.parent : this._inlineFiller = wc2(n3, e5.parent, e5.offset);
            } else
              this._inlineFiller = null;
          this._updateFocus(), this._updateSelection(), this.markedTexts.clear(), this.markedAttributes.clear(), this.markedChildren.clear();
        }
        _updateChildrenMappings(t4) {
          const e4 = this.domConverter.mapViewToDom(t4);
          if (!e4)
            return;
          const n3 = Array.from(e4.childNodes), o3 = Array.from(this.domConverter.viewChildrenToDom(t4, { withChildren: false })), i3 = this._diffNodeLists(n3, o3), r3 = this._findUpdateActions(i3, n3, o3, Ac2);
          if (-1 !== r3.indexOf("update")) {
            const e5 = { equal: 0, insert: 0, delete: 0 };
            for (const i4 of r3)
              if ("update" === i4) {
                const i5 = e5.equal + e5.insert, r4 = e5.equal + e5.delete, s3 = t4.getChild(i5);
                !s3 || s3.is("uiElement") || s3.is("rawElement") || this._updateElementMappings(s3, n3[r4]), ii2(o3[i5]), e5.equal++;
              } else
                e5[i4]++;
          }
        }
        _updateElementMappings(t4, e4) {
          this.domConverter.unbindDomElement(e4), this.domConverter.bindElements(e4, t4), this.markedChildren.add(t4), this.markedAttributes.add(t4);
        }
        _getInlineFillerPosition() {
          const t4 = this.selection.getFirstPosition();
          return t4.parent.is("$text") ? Ea2._createBefore(t4.parent) : t4;
        }
        _isSelectionInInlineFiller() {
          if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
            return false;
          const t4 = this.selection.getFirstPosition(), e4 = this.domConverter.viewPositionToDom(t4);
          return !!(e4 && Oo2(e4.parent) && uc2(e4.parent));
        }
        _removeInlineFiller() {
          const t4 = this._inlineFiller;
          if (!uc2(t4))
            throw new A2("view-renderer-filler-was-lost", this);
          gc2(t4) ? t4.remove() : t4.data = t4.data.substr(dc2), this._inlineFiller = null;
        }
        _needsInlineFillerAtSelection() {
          if (1 != this.selection.rangeCount || !this.selection.isCollapsed)
            return false;
          const t4 = this.selection.getFirstPosition(), e4 = t4.parent, n3 = t4.offset;
          if (!this.domConverter.mapViewToDom(e4.root))
            return false;
          if (!e4.is("element"))
            return false;
          if (!function(t5) {
            if ("false" == t5.getAttribute("contenteditable"))
              return false;
            const e5 = t5.findAncestor((t6) => t6.hasAttribute("contenteditable"));
            return !e5 || "true" == e5.getAttribute("contenteditable");
          }(e4))
            return false;
          if (n3 === e4.getFillerOffset())
            return false;
          const o3 = t4.nodeBefore, i3 = t4.nodeAfter;
          return !(o3 instanceof fs || i3 instanceof fs) && (!a2.isAndroid || !o3 && !i3);
        }
        _updateText(t4, e4) {
          const n3 = this.domConverter.findCorrespondingDomText(t4);
          let o3 = this.domConverter.viewToDom(t4).data;
          const i3 = e4.inlineFillerPosition;
          i3 && i3.parent == t4.parent && i3.offset == t4.index && (o3 = hc2 + o3), vc2(n3, o3);
        }
        _updateAttrs(t4) {
          const e4 = this.domConverter.mapViewToDom(t4);
          if (!e4)
            return;
          const n3 = Array.from(e4.attributes).map((t5) => t5.name), o3 = t4.getAttributeKeys();
          for (const n4 of o3)
            this.domConverter.setDomElementAttribute(e4, n4, t4.getAttribute(n4), t4);
          for (const o4 of n3)
            t4.hasAttribute(o4) || this.domConverter.removeDomElementAttribute(e4, o4);
        }
        _updateChildren(t4, e4) {
          const n3 = this.domConverter.mapViewToDom(t4);
          if (!n3)
            return;
          if (a2.isAndroid) {
            let t5 = null;
            for (const e5 of Array.from(n3.childNodes)) {
              if (t5 && Oo2(t5) && Oo2(e5)) {
                n3.normalize();
                break;
              }
              t5 = e5;
            }
          }
          const o3 = e4.inlineFillerPosition, i3 = n3.childNodes, r3 = Array.from(this.domConverter.viewChildrenToDom(t4, { bind: true }));
          o3 && o3.parent === t4 && wc2(n3.ownerDocument, r3, o3.offset);
          const s3 = this._diffNodeLists(i3, r3), c3 = this._findUpdateActions(s3, i3, r3, Cc2);
          let l3 = 0;
          const d3 = /* @__PURE__ */ new Set();
          for (const t5 of c3)
            "delete" === t5 ? (d3.add(i3[l3]), ii2(i3[l3])) : "equal" !== t5 && "update" !== t5 || l3++;
          l3 = 0;
          for (const t5 of c3)
            "insert" === t5 ? (Qo2(n3, l3, r3[l3]), l3++) : "update" === t5 ? (vc2(i3[l3], r3[l3].data), l3++) : "equal" === t5 && (this._markDescendantTextToSync(this.domConverter.domToView(r3[l3])), l3++);
          for (const t5 of d3)
            t5.parentNode || this.domConverter.unbindDomElement(t5);
        }
        _diffNodeLists(t4, e4) {
          return t4 = function(t5, e5) {
            const n3 = Array.from(t5);
            if (0 == n3.length || !e5)
              return n3;
            const o3 = n3[n3.length - 1];
            o3 == e5 && n3.pop();
            return n3;
          }(t4, this._fakeSelectionContainer), u2(t4, e4, _c.bind(null, this.domConverter));
        }
        _findUpdateActions(t4, e4, n3, o3) {
          if (-1 === t4.indexOf("insert") || -1 === t4.indexOf("delete"))
            return t4;
          let i3 = [], r3 = [], s3 = [];
          const a3 = { equal: 0, insert: 0, delete: 0 };
          for (const c3 of t4)
            "insert" === c3 ? s3.push(n3[a3.equal + a3.insert]) : "delete" === c3 ? r3.push(e4[a3.equal + a3.delete]) : (i3 = i3.concat(u2(r3, s3, o3).map((t5) => "equal" === t5 ? "update" : t5)), i3.push("equal"), r3 = [], s3 = []), a3[c3]++;
          return i3.concat(u2(r3, s3, o3).map((t5) => "equal" === t5 ? "update" : t5));
        }
        _markDescendantTextToSync(t4) {
          if (t4) {
            if (t4.is("$text"))
              this.markedTexts.add(t4);
            else if (t4.is("element"))
              for (const e4 of t4.getChildren())
                this._markDescendantTextToSync(e4);
          }
        }
        _updateSelection() {
          if (a2.isBlink && !a2.isAndroid && this.isSelecting && !this.markedChildren.size)
            return;
          if (0 === this.selection.rangeCount)
            return this._removeDomSelection(), void this._removeFakeSelection();
          const t4 = this.domConverter.mapViewToDom(this.selection.editableElement);
          this.isFocused && t4 && (this.selection.isFake ? this._updateFakeSelection(t4) : this._fakeSelectionContainer && this._fakeSelectionContainer.isConnected ? (this._removeFakeSelection(), this._updateDomSelection(t4)) : this.isComposing && a2.isAndroid || this._updateDomSelection(t4));
        }
        _updateFakeSelection(t4) {
          const e4 = t4.ownerDocument;
          this._fakeSelectionContainer || (this._fakeSelectionContainer = function(t5) {
            const e5 = t5.createElement("div");
            return e5.className = "ck-fake-selection-container", Object.assign(e5.style, { position: "fixed", top: 0, left: "-9999px", width: "42px" }), e5.textContent = " ", e5;
          }(e4));
          const n3 = this._fakeSelectionContainer;
          if (this.domConverter.bindFakeSelection(n3, this.selection), !this._fakeSelectionNeedsUpdate(t4))
            return;
          n3.parentElement && n3.parentElement == t4 || t4.appendChild(n3), n3.textContent = this.selection.fakeSelectionLabel || " ";
          const o3 = e4.getSelection(), i3 = e4.createRange();
          o3.removeAllRanges(), i3.selectNodeContents(n3), o3.addRange(i3);
        }
        _updateDomSelection(t4) {
          const e4 = t4.ownerDocument.defaultView.getSelection();
          if (!this._domSelectionNeedsUpdate(e4))
            return;
          const n3 = this.domConverter.viewPositionToDom(this.selection.anchor), o3 = this.domConverter.viewPositionToDom(this.selection.focus);
          e4.setBaseAndExtent(n3.parent, n3.offset, o3.parent, o3.offset), a2.isGecko && function(t5, e5) {
            const n4 = t5.parent;
            if (n4.nodeType != Node.ELEMENT_NODE || t5.offset != n4.childNodes.length - 1)
              return;
            const o4 = n4.childNodes[t5.offset];
            o4 && "BR" == o4.tagName && e5.addRange(e5.getRangeAt(0));
          }(o3, e4);
        }
        _domSelectionNeedsUpdate(t4) {
          if (!this.domConverter.isDomSelectionCorrect(t4))
            return true;
          const e4 = t4 && this.domConverter.domSelectionToView(t4);
          return (!e4 || !this.selection.isEqual(e4)) && !(!this.selection.isCollapsed && this.selection.isSimilar(e4));
        }
        _fakeSelectionNeedsUpdate(t4) {
          const e4 = this._fakeSelectionContainer, n3 = t4.ownerDocument.getSelection();
          return !e4 || e4.parentElement !== t4 || (n3.anchorNode !== e4 && !e4.contains(n3.anchorNode) || e4.textContent !== this.selection.fakeSelectionLabel);
        }
        _removeDomSelection() {
          for (const t4 of this.domDocuments) {
            const e4 = t4.getSelection();
            if (e4.rangeCount) {
              const n3 = t4.activeElement, o3 = this.domConverter.mapDomToView(n3);
              n3 && o3 && e4.removeAllRanges();
            }
          }
        }
        _removeFakeSelection() {
          const t4 = this._fakeSelectionContainer;
          t4 && t4.remove();
        }
        _updateFocus() {
          if (this.isFocused) {
            const t4 = this.selection.editableElement;
            t4 && this.domConverter.focus(t4);
          }
        }
      }
      function wc2(t4, e4, n3) {
        const o3 = e4 instanceof Array ? e4 : e4.childNodes, i3 = o3[n3];
        if (Oo2(i3))
          return i3.data = hc2 + i3.data, i3;
        {
          const i4 = t4.createTextNode(hc2);
          return Array.isArray(e4) ? o3.splice(n3, 0, i4) : Qo2(e4, n3, i4), i4;
        }
      }
      function Ac2(t4, e4) {
        return So2(t4) && So2(e4) && !Oo2(t4) && !Oo2(e4) && !Jo2(t4) && !Jo2(e4) && t4.tagName.toLowerCase() === e4.tagName.toLowerCase();
      }
      function Cc2(t4, e4) {
        return So2(t4) && So2(e4) && Oo2(t4) && Oo2(e4);
      }
      function _c(t4, e4, n3) {
        return e4 === n3 || (Oo2(e4) && Oo2(n3) ? e4.data === n3.data : !(!t4.isBlockFiller(e4) || !t4.isBlockFiller(n3)));
      }
      function vc2(t4, e4) {
        const n3 = t4.data;
        if (n3 == e4)
          return;
        const o3 = l2(n3, e4);
        for (const e5 of o3)
          "insert" === e5.type ? t4.insertData(e5.index, e5.values.join("")) : t4.deleteData(e5.index, e5.howMany);
      }
      const yc2 = lc2(zo2.document), xc2 = ac2(zo2.document), Ec2 = cc2(zo2.document), Dc2 = "data-ck-unsafe-attribute-", Sc2 = "data-ck-unsafe-element";
      class Ic2 {
        constructor(t4, { blockFillerMode: e4, renderingMode: n3 = "editing" } = {}) {
          this._domToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToDomMapping = /* @__PURE__ */ new WeakMap(), this._fakeSelectionMapping = /* @__PURE__ */ new WeakMap(), this._rawContentElementMatcher = new bs(), this._inlineObjectElementMatcher = new bs(), this.document = t4, this.renderingMode = n3, this.blockFillerMode = e4 || ("editing" === n3 ? "br" : "nbsp"), this.preElements = ["pre"], this.blockElements = ["address", "article", "aside", "blockquote", "caption", "center", "dd", "details", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "legend", "li", "main", "menu", "nav", "ol", "p", "pre", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "tr", "ul"], this.inlineObjectElements = ["object", "iframe", "input", "button", "textarea", "select", "option", "video", "embed", "audio", "img", "canvas"], this.unsafeElements = ["script", "style"], this._domDocument = "editing" === this.renderingMode ? zo2.document : zo2.document.implementation.createHTMLDocument("");
        }
        bindFakeSelection(t4, e4) {
          this._fakeSelectionMapping.set(t4, new Ia2(e4));
        }
        fakeSelectionToView(t4) {
          return this._fakeSelectionMapping.get(t4);
        }
        bindElements(t4, e4) {
          this._domToViewMapping.set(t4, e4), this._viewToDomMapping.set(e4, t4);
        }
        unbindDomElement(t4) {
          const e4 = this._domToViewMapping.get(t4);
          if (e4) {
            this._domToViewMapping.delete(t4), this._viewToDomMapping.delete(e4);
            for (const e5 of Array.from(t4.children))
              this.unbindDomElement(e5);
          }
        }
        bindDocumentFragments(t4, e4) {
          this._domToViewMapping.set(t4, e4), this._viewToDomMapping.set(e4, t4);
        }
        shouldRenderAttribute(t4, e4, n3) {
          return "data" === this.renderingMode || !(t4 = t4.toLowerCase()).startsWith("on") && (("srcdoc" !== t4 || !e4.match(/\bon\S+\s*=|javascript:|<\s*\/*script/i)) && ("img" === n3 && ("src" === t4 || "srcset" === t4) || ("source" === n3 && "srcset" === t4 || !e4.match(/^\s*(javascript:|data:(image\/svg|text\/x?html))/i))));
        }
        setContentOf(t4, e4) {
          if ("data" === this.renderingMode)
            return void (t4.innerHTML = e4);
          const n3 = new DOMParser().parseFromString(e4, "text/html"), o3 = n3.createDocumentFragment(), i3 = n3.body.childNodes;
          for (; i3.length > 0; )
            o3.appendChild(i3[0]);
          const r3 = n3.createTreeWalker(o3, NodeFilter.SHOW_ELEMENT), s3 = [];
          let a3;
          for (; a3 = r3.nextNode(); )
            s3.push(a3);
          for (const t5 of s3) {
            for (const e6 of t5.getAttributeNames())
              this.setDomElementAttribute(t5, e6, t5.getAttribute(e6));
            const e5 = t5.tagName.toLowerCase();
            this._shouldRenameElement(e5) && (Nc2(e5), t5.replaceWith(this._createReplacementDomElement(e5, t5)));
          }
          for (; t4.firstChild; )
            t4.firstChild.remove();
          t4.append(o3);
        }
        viewToDom(t4, e4 = {}) {
          if (t4.is("$text")) {
            const e5 = this._processDataFromViewText(t4);
            return this._domDocument.createTextNode(e5);
          }
          {
            if (this.mapViewToDom(t4))
              return this.mapViewToDom(t4);
            let n3;
            if (t4.is("documentFragment"))
              n3 = this._domDocument.createDocumentFragment(), e4.bind && this.bindDocumentFragments(n3, t4);
            else {
              if (t4.is("uiElement"))
                return n3 = "$comment" === t4.name ? this._domDocument.createComment(t4.getCustomProperty("$rawContent")) : t4.render(this._domDocument, this), e4.bind && this.bindElements(n3, t4), n3;
              this._shouldRenameElement(t4.name) ? (Nc2(t4.name), n3 = this._createReplacementDomElement(t4.name)) : n3 = t4.hasAttribute("xmlns") ? this._domDocument.createElementNS(t4.getAttribute("xmlns"), t4.name) : this._domDocument.createElement(t4.name), t4.is("rawElement") && t4.render(n3, this), e4.bind && this.bindElements(n3, t4);
              for (const e5 of t4.getAttributeKeys())
                this.setDomElementAttribute(n3, e5, t4.getAttribute(e5), t4);
            }
            if (false !== e4.withChildren)
              for (const o3 of this.viewChildrenToDom(t4, e4))
                n3.appendChild(o3);
            return n3;
          }
        }
        setDomElementAttribute(t4, e4, n3, o3) {
          const i3 = this.shouldRenderAttribute(e4, n3, t4.tagName.toLowerCase()) || o3 && o3.shouldRenderUnsafeAttribute(e4);
          i3 || C2("domconverter-unsafe-attribute-detected", { domElement: t4, key: e4, value: n3 }), function(t5) {
            try {
              zo2.document.createAttribute(t5);
            } catch (t6) {
              return false;
            }
            return true;
          }(e4) ? (t4.hasAttribute(e4) && !i3 ? t4.removeAttribute(e4) : t4.hasAttribute(Dc2 + e4) && i3 && t4.removeAttribute(Dc2 + e4), t4.setAttribute(i3 ? e4 : Dc2 + e4, n3)) : C2("domconverter-invalid-attribute-detected", { domElement: t4, key: e4, value: n3 });
        }
        removeDomElementAttribute(t4, e4) {
          e4 != Sc2 && (t4.removeAttribute(e4), t4.removeAttribute(Dc2 + e4));
        }
        *viewChildrenToDom(t4, e4 = {}) {
          const n3 = t4.getFillerOffset && t4.getFillerOffset();
          let o3 = 0;
          for (const i3 of t4.getChildren()) {
            n3 === o3 && (yield this._getBlockFiller());
            const t5 = i3.is("element") && !!i3.getCustomProperty("dataPipeline:transparentRendering") && !Si2(i3.getAttributes());
            t5 && "data" == this.renderingMode ? yield* this.viewChildrenToDom(i3, e4) : (t5 && C2("domconverter-transparent-rendering-unsupported-in-editing-pipeline", { viewElement: i3 }), yield this.viewToDom(i3, e4)), o3++;
          }
          n3 === o3 && (yield this._getBlockFiller());
        }
        viewRangeToDom(t4) {
          const e4 = this.viewPositionToDom(t4.start), n3 = this.viewPositionToDom(t4.end), o3 = this._domDocument.createRange();
          return o3.setStart(e4.parent, e4.offset), o3.setEnd(n3.parent, n3.offset), o3;
        }
        viewPositionToDom(t4) {
          const e4 = t4.parent;
          if (e4.is("$text")) {
            const n3 = this.findCorrespondingDomText(e4);
            if (!n3)
              return null;
            let o3 = t4.offset;
            return uc2(n3) && (o3 += dc2), { parent: n3, offset: o3 };
          }
          {
            let n3, o3, i3;
            if (0 === t4.offset) {
              if (n3 = this.mapViewToDom(e4), !n3)
                return null;
              i3 = n3.childNodes[0];
            } else {
              const e5 = t4.nodeBefore;
              if (o3 = e5.is("$text") ? this.findCorrespondingDomText(e5) : this.mapViewToDom(e5), !o3)
                return null;
              n3 = o3.parentNode, i3 = o3.nextSibling;
            }
            if (Oo2(i3) && uc2(i3))
              return { parent: i3, offset: dc2 };
            return { parent: n3, offset: o3 ? Zo2(o3) + 1 : 0 };
          }
        }
        domToView(t4, e4 = {}) {
          const n3 = [], o3 = this._domToView(t4, e4, n3), i3 = o3.next().value;
          return i3 ? (o3.next(), this._processDomInlineNodes(null, n3, e4), i3.is("$text") && 0 == i3.data.length ? null : i3) : null;
        }
        *domChildrenToView(t4, e4 = {}, n3 = []) {
          for (let o3 = 0; o3 < t4.childNodes.length; o3++) {
            const i3 = t4.childNodes[o3], r3 = this._domToView(i3, e4, n3), s3 = r3.next().value;
            null !== s3 && (this._isBlockViewElement(s3) && this._processDomInlineNodes(t4, n3, e4), yield s3, r3.next());
          }
          this._processDomInlineNodes(t4, n3, e4);
        }
        domSelectionToView(t4) {
          if (function(t5) {
            if (!a2.isGecko)
              return false;
            if (!t5.rangeCount)
              return false;
            const e5 = t5.getRangeAt(0).startContainer;
            try {
              Object.prototype.toString.call(e5);
            } catch (t6) {
              return true;
            }
            return false;
          }(t4))
            return new Ia2([]);
          if (1 === t4.rangeCount) {
            let e5 = t4.getRangeAt(0).startContainer;
            Oo2(e5) && (e5 = e5.parentNode);
            const n4 = this.fakeSelectionToView(e5);
            if (n4)
              return n4;
          }
          const e4 = this.isDomSelectionBackward(t4), n3 = [];
          for (let e5 = 0; e5 < t4.rangeCount; e5++) {
            const o3 = t4.getRangeAt(e5), i3 = this.domRangeToView(o3);
            i3 && n3.push(i3);
          }
          return new Ia2(n3, { backward: e4 });
        }
        domRangeToView(t4) {
          const e4 = this.domPositionToView(t4.startContainer, t4.startOffset), n3 = this.domPositionToView(t4.endContainer, t4.endOffset);
          return e4 && n3 ? new Da2(e4, n3) : null;
        }
        domPositionToView(t4, e4 = 0) {
          if (this.isBlockFiller(t4))
            return this.domPositionToView(t4.parentNode, Zo2(t4));
          const n3 = this.mapDomToView(t4);
          if (n3 && (n3.is("uiElement") || n3.is("rawElement")))
            return Ea2._createBefore(n3);
          if (Oo2(t4)) {
            if (gc2(t4))
              return this.domPositionToView(t4.parentNode, Zo2(t4));
            const n4 = this.findCorrespondingViewText(t4);
            let o3 = e4;
            return n4 ? (uc2(t4) && (o3 -= dc2, o3 = o3 < 0 ? 0 : o3), new Ea2(n4, o3)) : null;
          }
          if (0 === e4) {
            const e5 = this.mapDomToView(t4);
            if (e5)
              return new Ea2(e5, 0);
          } else {
            const n4 = t4.childNodes[e4 - 1];
            if (Oo2(n4) && gc2(n4) || n4 && this.isBlockFiller(n4))
              return this.domPositionToView(n4.parentNode, Zo2(n4));
            const o3 = Oo2(n4) ? this.findCorrespondingViewText(n4) : this.mapDomToView(n4);
            if (o3 && o3.parent)
              return new Ea2(o3.parent, o3.index + 1);
          }
          return null;
        }
        mapDomToView(t4) {
          return this.getHostViewElement(t4) || this._domToViewMapping.get(t4);
        }
        findCorrespondingViewText(t4) {
          if (gc2(t4))
            return null;
          const e4 = this.getHostViewElement(t4);
          if (e4)
            return e4;
          const n3 = t4.previousSibling;
          if (n3) {
            if (!this.isElement(n3))
              return null;
            const t5 = this.mapDomToView(n3);
            if (t5) {
              const e5 = t5.nextSibling;
              return e5 instanceof fs ? e5 : null;
            }
          } else {
            const e5 = this.mapDomToView(t4.parentNode);
            if (e5) {
              const t5 = e5.getChild(0);
              return t5 instanceof fs ? t5 : null;
            }
          }
          return null;
        }
        mapViewToDom(t4) {
          return this._viewToDomMapping.get(t4);
        }
        findCorrespondingDomText(t4) {
          const e4 = t4.previousSibling;
          return e4 && this.mapViewToDom(e4) ? this.mapViewToDom(e4).nextSibling : !e4 && t4.parent && this.mapViewToDom(t4.parent) ? this.mapViewToDom(t4.parent).childNodes[0] : null;
        }
        focus(t4) {
          const e4 = this.mapViewToDom(t4);
          if (e4 && e4.ownerDocument.activeElement !== e4) {
            const { scrollX: t5, scrollY: n3 } = zo2.window, o3 = [];
            Mc2(e4, (t6) => {
              const { scrollLeft: e5, scrollTop: n4 } = t6;
              o3.push([e5, n4]);
            }), e4.focus(), Mc2(e4, (t6) => {
              const [e5, n4] = o3.shift();
              t6.scrollLeft = e5, t6.scrollTop = n4;
            }), zo2.window.scrollTo(t5, n3);
          }
        }
        _clearDomSelection() {
          const t4 = this.mapViewToDom(this.document.selection.editableElement);
          if (!t4)
            return;
          const e4 = t4.ownerDocument.defaultView.getSelection(), n3 = this.domSelectionToView(e4);
          n3 && n3.rangeCount > 0 && e4.removeAllRanges();
        }
        isElement(t4) {
          return t4 && t4.nodeType == Node.ELEMENT_NODE;
        }
        isDocumentFragment(t4) {
          return t4 && t4.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
        }
        isBlockFiller(t4) {
          return "br" == this.blockFillerMode ? t4.isEqualNode(yc2) : !("BR" !== t4.tagName || !Bc2(t4, this.blockElements) || 1 !== t4.parentNode.childNodes.length) || (t4.isEqualNode(Ec2) || function(t5, e4) {
            const n3 = t5.isEqualNode(xc2);
            return n3 && Bc2(t5, e4) && 1 === t5.parentNode.childNodes.length;
          }(t4, this.blockElements));
        }
        isDomSelectionBackward(t4) {
          if (t4.isCollapsed)
            return false;
          const e4 = this._domDocument.createRange();
          try {
            e4.setStart(t4.anchorNode, t4.anchorOffset), e4.setEnd(t4.focusNode, t4.focusOffset);
          } catch (t5) {
            return false;
          }
          const n3 = e4.collapsed;
          return e4.detach(), n3;
        }
        getHostViewElement(t4) {
          const e4 = function(t5) {
            const e5 = [];
            let n3 = t5;
            for (; n3 && n3.nodeType != Node.DOCUMENT_NODE; )
              e5.unshift(n3), n3 = n3.parentNode;
            return e5;
          }(t4);
          for (e4.pop(); e4.length; ) {
            const t5 = e4.pop(), n3 = this._domToViewMapping.get(t5);
            if (n3 && (n3.is("uiElement") || n3.is("rawElement")))
              return n3;
          }
          return null;
        }
        isDomSelectionCorrect(t4) {
          return this._isDomSelectionPositionCorrect(t4.anchorNode, t4.anchorOffset) && this._isDomSelectionPositionCorrect(t4.focusNode, t4.focusOffset);
        }
        registerRawContentMatcher(t4) {
          this._rawContentElementMatcher.add(t4);
        }
        registerInlineObjectMatcher(t4) {
          this._inlineObjectElementMatcher.add(t4);
        }
        _getBlockFiller() {
          switch (this.blockFillerMode) {
            case "nbsp":
              return ac2(this._domDocument);
            case "markedNbsp":
              return cc2(this._domDocument);
            case "br":
              return lc2(this._domDocument);
          }
        }
        _isDomSelectionPositionCorrect(t4, e4) {
          if (Oo2(t4) && uc2(t4) && e4 < dc2)
            return false;
          if (this.isElement(t4) && uc2(t4.childNodes[e4]))
            return false;
          const n3 = this.mapDomToView(t4);
          return !n3 || !n3.is("uiElement") && !n3.is("rawElement");
        }
        *_domToView(t4, e4, n3) {
          if (this.isBlockFiller(t4))
            return null;
          const o3 = this.getHostViewElement(t4);
          if (o3)
            return o3;
          if (Jo2(t4) && e4.skipComments)
            return null;
          if (Oo2(t4)) {
            if (gc2(t4))
              return null;
            {
              const e5 = t4.data;
              if ("" === e5)
                return null;
              const o4 = new fs(this.document, e5);
              return n3.push(o4), o4;
            }
          }
          {
            let o4 = this.mapDomToView(t4);
            if (o4)
              return this._isInlineObjectElement(o4) && n3.push(o4), o4;
            if (this.isDocumentFragment(t4))
              o4 = new $a(this.document), e4.bind && this.bindDocumentFragments(t4, o4);
            else {
              o4 = this._createViewElement(t4, e4), e4.bind && this.bindElements(t4, o4);
              const i4 = t4.attributes;
              if (i4)
                for (let t5 = i4.length, e5 = 0; e5 < t5; e5++)
                  o4._setAttribute(i4[e5].name, i4[e5].value);
              if (this._isViewElementWithRawContent(o4, e4))
                return o4._setCustomProperty("$rawContent", t4.innerHTML), this._isBlockViewElement(o4) || n3.push(o4), o4;
              if (Jo2(t4))
                return o4._setCustomProperty("$rawContent", t4.data), o4;
            }
            yield o4;
            const i3 = [];
            if (false !== e4.withChildren)
              for (const n4 of this.domChildrenToView(t4, e4, i3))
                o4._appendChild(n4);
            if (this._isInlineObjectElement(o4))
              n3.push(o4);
            else
              for (const t5 of i3)
                n3.push(t5);
          }
        }
        _processDomInlineNodes(t4, e4, n3) {
          if (!e4.length)
            return;
          if (t4 && !this.isDocumentFragment(t4) && !this._isBlockDomElement(t4))
            return;
          let o3 = false;
          for (let t5 = 0; t5 < e4.length; t5++) {
            const i3 = e4[t5];
            if (!i3.is("$text")) {
              o3 = false;
              continue;
            }
            let r3, s3 = false;
            if (Tc2(i3, this.preElements))
              r3 = pc2(i3.data);
            else {
              r3 = i3.data.replace(/[ \n\t\r]{1,}/g, " "), s3 = /[^\S\u00A0]/.test(r3.charAt(r3.length - 1));
              const a3 = t5 > 0 ? e4[t5 - 1] : null, c3 = t5 + 1 < e4.length ? e4[t5 + 1] : null, l3 = !a3 || a3.is("element") && "br" == a3.name || o3, d3 = !c3 && !uc2(i3.data);
              false !== n3.withChildren && (l3 && (r3 = r3.replace(/^ /, "")), d3 && (r3 = r3.replace(/ $/, ""))), r3 = pc2(r3), r3 = r3.replace(/ \u00A0/g, "  ");
              const h3 = c3 && c3.is("element") && "br" != c3.name, u3 = c3 && c3.is("$text") && " " == c3.data.charAt(0);
              (/[ \u00A0]\u00A0$/.test(r3) || !c3 || h3 || u3) && (r3 = r3.replace(/\u00A0$/, " ")), (l3 || a3 && a3.is("element") && "br" != a3.name) && (r3 = r3.replace(/^\u00A0/, " "));
            }
            0 == r3.length && i3.parent ? (i3._remove(), e4.splice(t5, 1), t5--) : (i3._data = r3, o3 = s3);
          }
          e4.length = 0;
        }
        _processDataFromViewText(t4) {
          let e4 = t4.data;
          if (t4.getAncestors().some((t5) => this.preElements.includes(t5.name)))
            return e4;
          if (" " == e4.charAt(0)) {
            const n3 = this._getTouchingInlineViewNode(t4, false);
            !(n3 && n3.is("$textProxy") && this._nodeEndsWithSpace(n3)) && n3 || (e4 = " " + e4.substr(1));
          }
          if (" " == e4.charAt(e4.length - 1)) {
            const n3 = this._getTouchingInlineViewNode(t4, true), o3 = n3 && n3.is("$textProxy") && " " == n3.data.charAt(0);
            " " != e4.charAt(e4.length - 2) && n3 && !o3 || (e4 = e4.substr(0, e4.length - 1) + " ");
          }
          return e4.replace(/ {2}/g, "  ");
        }
        _nodeEndsWithSpace(t4) {
          if (t4.getAncestors().some((t5) => this.preElements.includes(t5.name)))
            return false;
          const e4 = this._processDataFromViewText(t4);
          return " " == e4.charAt(e4.length - 1);
        }
        _getTouchingInlineViewNode(t4, e4) {
          const n3 = new xa({ startPosition: e4 ? Ea2._createAfter(t4) : Ea2._createBefore(t4), direction: e4 ? "forward" : "backward" });
          for (const t5 of n3) {
            if (t5.item.is("element", "br"))
              return null;
            if (this._isInlineObjectElement(t5.item))
              return t5.item;
            if (t5.item.is("containerElement"))
              return null;
            if (t5.item.is("$textProxy"))
              return t5.item;
          }
          return null;
        }
        _isBlockDomElement(t4) {
          return this.isElement(t4) && this.blockElements.includes(t4.tagName.toLowerCase());
        }
        _isBlockViewElement(t4) {
          return t4.is("element") && this.blockElements.includes(t4.name);
        }
        _isInlineObjectElement(t4) {
          return !!t4.is("element") && ("br" == t4.name || this.inlineObjectElements.includes(t4.name) || !!this._inlineObjectElementMatcher.match(t4));
        }
        _createViewElement(t4, e4) {
          if (Jo2(t4))
            return new qa2(this.document, "$comment");
          const n3 = e4.keepOriginalCase ? t4.tagName : t4.tagName.toLowerCase();
          return new ba(this.document, n3);
        }
        _isViewElementWithRawContent(t4, e4) {
          return false !== e4.withChildren && t4.is("element") && !!this._rawContentElementMatcher.match(t4);
        }
        _shouldRenameElement(t4) {
          const e4 = t4.toLowerCase();
          return "editing" === this.renderingMode && this.unsafeElements.includes(e4);
        }
        _createReplacementDomElement(t4, e4) {
          const n3 = this._domDocument.createElement("span");
          if (n3.setAttribute(Sc2, t4), e4) {
            for (; e4.firstChild; )
              n3.appendChild(e4.firstChild);
            for (const t5 of e4.getAttributeNames())
              n3.setAttribute(t5, e4.getAttribute(t5));
          }
          return n3;
        }
      }
      function Tc2(t4, e4) {
        return t4.getAncestors().some((t5) => t5.is("element") && e4.includes(t5.name));
      }
      function Mc2(t4, e4) {
        let n3 = t4;
        for (; n3; )
          e4(n3), n3 = n3.parentElement;
      }
      function Bc2(t4, e4) {
        const n3 = t4.parentNode;
        return !!n3 && !!n3.tagName && e4.includes(n3.tagName.toLowerCase());
      }
      function Nc2(t4) {
        "script" === t4 && C2("domconverter-unsafe-script-element-detected"), "style" === t4 && C2("domconverter-unsafe-style-element-detected");
      }
      class Pc2 extends Mo2() {
        constructor(t4) {
          super(), this._isEnabled = false, this.view = t4, this.document = t4.document;
        }
        get isEnabled() {
          return this._isEnabled;
        }
        enable() {
          this._isEnabled = true;
        }
        disable() {
          this._isEnabled = false;
        }
        destroy() {
          this.disable(), this.stopListening();
        }
        checkShouldIgnoreEventFromTarget(t4) {
          return t4 && 3 === t4.nodeType && (t4 = t4.parentNode), !(!t4 || 1 !== t4.nodeType) && t4.matches("[data-cke-ignore-events], [data-cke-ignore-events] *");
        }
      }
      const zc2 = da2(function(t4, e4) {
        Te2(e4, pn2(e4), t4);
      });
      class Oc2 {
        constructor(t4, e4, n3) {
          this.view = t4, this.document = t4.document, this.domEvent = e4, this.domTarget = e4.target, zc2(this, n3);
        }
        get target() {
          return this.view.domConverter.mapDomToView(this.domTarget);
        }
        preventDefault() {
          this.domEvent.preventDefault();
        }
        stopPropagation() {
          this.domEvent.stopPropagation();
        }
      }
      class Lc2 extends Pc2 {
        constructor() {
          super(...arguments), this.useCapture = false;
        }
        observe(t4) {
          ("string" == typeof this.domEventType ? [this.domEventType] : this.domEventType).forEach((e4) => {
            this.listenTo(t4, e4, (t5, e5) => {
              this.isEnabled && !this.checkShouldIgnoreEventFromTarget(e5.target) && this.onDomEvent(e5);
            }, { useCapture: this.useCapture });
          });
        }
        stopObserving(t4) {
          this.stopListening(t4);
        }
        fire(t4, e4, n3) {
          this.isEnabled && this.document.fire(t4, new Oc2(this.view, e4, n3));
        }
      }
      class jc2 extends Lc2 {
        constructor() {
          super(...arguments), this.domEventType = ["keydown", "keyup"];
        }
        onDomEvent(t4) {
          const e4 = { keyCode: t4.keyCode, altKey: t4.altKey, ctrlKey: t4.ctrlKey, shiftKey: t4.shiftKey, metaKey: t4.metaKey, get keystroke() {
            return bi2(this);
          } };
          this.fire(t4.type, t4, e4);
        }
      }
      const Rc2 = function() {
        return it2.Date.now();
      };
      var Fc2 = /\s/;
      const Vc2 = function(t4) {
        for (var e4 = t4.length; e4-- && Fc2.test(t4.charAt(e4)); )
          ;
        return e4;
      };
      var Hc2 = /^\s+/;
      const Uc2 = function(t4) {
        return t4 ? t4.slice(0, Vc2(t4) + 1).replace(Hc2, "") : t4;
      };
      var qc2 = /^[-+]0x[0-9a-f]+$/i, Gc2 = /^0b[01]+$/i, Wc2 = /^0o[0-7]+$/i, Kc2 = parseInt;
      const Yc2 = function(t4) {
        if ("number" == typeof t4)
          return t4;
        if (Cs(t4))
          return NaN;
        if (R2(t4)) {
          var e4 = "function" == typeof t4.valueOf ? t4.valueOf() : t4;
          t4 = R2(e4) ? e4 + "" : e4;
        }
        if ("string" != typeof t4)
          return 0 === t4 ? t4 : +t4;
        t4 = Uc2(t4);
        var n3 = Gc2.test(t4);
        return n3 || Wc2.test(t4) ? Kc2(t4.slice(2), n3 ? 2 : 8) : qc2.test(t4) ? NaN : +t4;
      };
      var $c2 = Math.max, Zc2 = Math.min;
      const Qc2 = function(t4, e4, n3) {
        var o3, i3, r3, s3, a3, c3, l3 = 0, d3 = false, h3 = false, u3 = true;
        if ("function" != typeof t4)
          throw new TypeError("Expected a function");
        function g3(e5) {
          var n4 = o3, r4 = i3;
          return o3 = i3 = void 0, l3 = e5, s3 = t4.apply(r4, n4);
        }
        function p3(t5) {
          var n4 = t5 - c3;
          return void 0 === c3 || n4 >= e4 || n4 < 0 || h3 && t5 - l3 >= r3;
        }
        function m3() {
          var t5 = Rc2();
          if (p3(t5))
            return f3(t5);
          a3 = setTimeout(m3, function(t6) {
            var n4 = e4 - (t6 - c3);
            return h3 ? Zc2(n4, r3 - (t6 - l3)) : n4;
          }(t5));
        }
        function f3(t5) {
          return a3 = void 0, u3 && o3 ? g3(t5) : (o3 = i3 = void 0, s3);
        }
        function k3() {
          var t5 = Rc2(), n4 = p3(t5);
          if (o3 = arguments, i3 = this, c3 = t5, n4) {
            if (void 0 === a3)
              return function(t6) {
                return l3 = t6, a3 = setTimeout(m3, e4), d3 ? g3(t6) : s3;
              }(c3);
            if (h3)
              return clearTimeout(a3), a3 = setTimeout(m3, e4), g3(c3);
          }
          return void 0 === a3 && (a3 = setTimeout(m3, e4)), s3;
        }
        return e4 = Yc2(e4) || 0, R2(n3) && (d3 = !!n3.leading, r3 = (h3 = "maxWait" in n3) ? $c2(Yc2(n3.maxWait) || 0, e4) : r3, u3 = "trailing" in n3 ? !!n3.trailing : u3), k3.cancel = function() {
          void 0 !== a3 && clearTimeout(a3), l3 = 0, o3 = c3 = i3 = a3 = void 0;
        }, k3.flush = function() {
          return void 0 === a3 ? s3 : f3(Rc2());
        }, k3;
      };
      class Jc2 extends Pc2 {
        constructor(t4) {
          super(t4), this._fireSelectionChangeDoneDebounced = Qc2((t5) => {
            this.document.fire("selectionChangeDone", t5);
          }, 200);
        }
        observe() {
          const t4 = this.document;
          t4.on("arrowKey", (e4, n3) => {
            t4.selection.isFake && this.isEnabled && n3.preventDefault();
          }, { context: "$capture" }), t4.on("arrowKey", (e4, n3) => {
            t4.selection.isFake && this.isEnabled && this._handleSelectionMove(n3.keyCode);
          }, { priority: "lowest" });
        }
        stopObserving() {
        }
        destroy() {
          super.destroy(), this._fireSelectionChangeDoneDebounced.cancel();
        }
        _handleSelectionMove(t4) {
          const e4 = this.document.selection, n3 = new Ia2(e4.getRanges(), { backward: e4.isBackward, fake: false });
          t4 != fi2.arrowleft && t4 != fi2.arrowup || n3.setTo(n3.getFirstPosition()), t4 != fi2.arrowright && t4 != fi2.arrowdown || n3.setTo(n3.getLastPosition());
          const o3 = { oldSelection: e4, newSelection: n3, domSelection: null };
          this.document.fire("selectionChange", o3), this._fireSelectionChangeDoneDebounced(o3);
        }
      }
      const Xc2 = function(t4) {
        return this.__data__.set(t4, "__lodash_hash_undefined__"), this;
      };
      const tl2 = function(t4) {
        return this.__data__.has(t4);
      };
      function el2(t4) {
        var e4 = -1, n3 = null == t4 ? 0 : t4.length;
        for (this.__data__ = new Ce2(); ++e4 < n3; )
          this.add(t4[e4]);
      }
      el2.prototype.add = el2.prototype.push = Xc2, el2.prototype.has = tl2;
      const nl2 = el2;
      const ol2 = function(t4, e4) {
        for (var n3 = -1, o3 = null == t4 ? 0 : t4.length; ++n3 < o3; )
          if (e4(t4[n3], n3, t4))
            return true;
        return false;
      };
      const il2 = function(t4, e4) {
        return t4.has(e4);
      };
      const rl2 = function(t4, e4, n3, o3, i3, r3) {
        var s3 = 1 & n3, a3 = t4.length, c3 = e4.length;
        if (a3 != c3 && !(s3 && c3 > a3))
          return false;
        var l3 = r3.get(t4), d3 = r3.get(e4);
        if (l3 && d3)
          return l3 == e4 && d3 == t4;
        var h3 = -1, u3 = true, g3 = 2 & n3 ? new nl2() : void 0;
        for (r3.set(t4, e4), r3.set(e4, t4); ++h3 < a3; ) {
          var p3 = t4[h3], m3 = e4[h3];
          if (o3)
            var f3 = s3 ? o3(m3, p3, h3, e4, t4, r3) : o3(p3, m3, h3, t4, e4, r3);
          if (void 0 !== f3) {
            if (f3)
              continue;
            u3 = false;
            break;
          }
          if (g3) {
            if (!ol2(e4, function(t5, e5) {
              if (!il2(g3, e5) && (p3 === t5 || i3(p3, t5, n3, o3, r3)))
                return g3.push(e5);
            })) {
              u3 = false;
              break;
            }
          } else if (p3 !== m3 && !i3(p3, m3, n3, o3, r3)) {
            u3 = false;
            break;
          }
        }
        return r3.delete(t4), r3.delete(e4), u3;
      };
      const sl2 = function(t4) {
        var e4 = -1, n3 = Array(t4.size);
        return t4.forEach(function(t5, o3) {
          n3[++e4] = [o3, t5];
        }), n3;
      };
      const al2 = function(t4) {
        var e4 = -1, n3 = Array(t4.size);
        return t4.forEach(function(t5) {
          n3[++e4] = t5;
        }), n3;
      };
      var cl2 = rt2 ? rt2.prototype : void 0, ll2 = cl2 ? cl2.valueOf : void 0;
      const dl2 = function(t4, e4, n3, o3, i3, r3, s3) {
        switch (n3) {
          case "[object DataView]":
            if (t4.byteLength != e4.byteLength || t4.byteOffset != e4.byteOffset)
              return false;
            t4 = t4.buffer, e4 = e4.buffer;
          case "[object ArrayBuffer]":
            return !(t4.byteLength != e4.byteLength || !r3(new Jn(t4), new Jn(e4)));
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return St2(+t4, +e4);
          case "[object Error]":
            return t4.name == e4.name && t4.message == e4.message;
          case "[object RegExp]":
          case "[object String]":
            return t4 == e4 + "";
          case "[object Map]":
            var a3 = sl2;
          case "[object Set]":
            var c3 = 1 & o3;
            if (a3 || (a3 = al2), t4.size != e4.size && !c3)
              return false;
            var l3 = s3.get(t4);
            if (l3)
              return l3 == e4;
            o3 |= 2, s3.set(t4, e4);
            var d3 = rl2(a3(t4), a3(e4), o3, i3, r3, s3);
            return s3.delete(t4), d3;
          case "[object Symbol]":
            if (ll2)
              return ll2.call(t4) == ll2.call(e4);
        }
        return false;
      };
      var hl2 = Object.prototype.hasOwnProperty;
      const ul2 = function(t4, e4, n3, o3, i3, r3) {
        var s3 = 1 & n3, a3 = Bn(t4), c3 = a3.length;
        if (c3 != Bn(e4).length && !s3)
          return false;
        for (var l3 = c3; l3--; ) {
          var d3 = a3[l3];
          if (!(s3 ? d3 in e4 : hl2.call(e4, d3)))
            return false;
        }
        var h3 = r3.get(t4), u3 = r3.get(e4);
        if (h3 && u3)
          return h3 == e4 && u3 == t4;
        var g3 = true;
        r3.set(t4, e4), r3.set(e4, t4);
        for (var p3 = s3; ++l3 < c3; ) {
          var m3 = t4[d3 = a3[l3]], f3 = e4[d3];
          if (o3)
            var k3 = s3 ? o3(f3, m3, d3, e4, t4, r3) : o3(m3, f3, d3, t4, e4, r3);
          if (!(void 0 === k3 ? m3 === f3 || i3(m3, f3, n3, o3, r3) : k3)) {
            g3 = false;
            break;
          }
          p3 || (p3 = "constructor" == d3);
        }
        if (g3 && !p3) {
          var b3 = t4.constructor, w3 = e4.constructor;
          b3 == w3 || !("constructor" in t4) || !("constructor" in e4) || "function" == typeof b3 && b3 instanceof b3 && "function" == typeof w3 && w3 instanceof w3 || (g3 = false);
        }
        return r3.delete(t4), r3.delete(e4), g3;
      };
      var gl2 = "[object Arguments]", pl2 = "[object Array]", ml2 = "[object Object]", fl2 = Object.prototype.hasOwnProperty;
      const kl2 = function(t4, e4, n3, o3, i3, r3) {
        var s3 = mt2(t4), a3 = mt2(e4), c3 = s3 ? pl2 : $n(t4), l3 = a3 ? pl2 : $n(e4), d3 = (c3 = c3 == gl2 ? ml2 : c3) == ml2, h3 = (l3 = l3 == gl2 ? ml2 : l3) == ml2, u3 = c3 == l3;
        if (u3 && Ve2(t4)) {
          if (!Ve2(e4))
            return false;
          s3 = true, d3 = false;
        }
        if (u3 && !d3)
          return r3 || (r3 = new ye2()), s3 || Xe2(t4) ? rl2(t4, e4, n3, o3, i3, r3) : dl2(t4, e4, c3, n3, o3, i3, r3);
        if (!(1 & n3)) {
          var g3 = d3 && fl2.call(t4, "__wrapped__"), p3 = h3 && fl2.call(e4, "__wrapped__");
          if (g3 || p3) {
            var m3 = g3 ? t4.value() : t4, f3 = p3 ? e4.value() : e4;
            return r3 || (r3 = new ye2()), i3(m3, f3, n3, o3, r3);
          }
        }
        return !!u3 && (r3 || (r3 = new ye2()), ul2(t4, e4, n3, o3, i3, r3));
      };
      const bl2 = function t4(e4, n3, o3, i3, r3) {
        return e4 === n3 || (null == e4 || null == n3 || !ft2(e4) && !ft2(n3) ? e4 != e4 && n3 != n3 : kl2(e4, n3, o3, i3, t4, r3));
      };
      const wl = function(t4, e4, n3) {
        var o3 = (n3 = "function" == typeof n3 ? n3 : void 0) ? n3(t4, e4) : void 0;
        return void 0 === o3 ? bl2(t4, e4, void 0, n3) : !!o3;
      };
      class Al extends Pc2 {
        constructor(t4) {
          super(t4), this._config = { childList: true, characterData: true, subtree: true }, this.domConverter = t4.domConverter, this.renderer = t4._renderer, this._domElements = /* @__PURE__ */ new Set(), this._mutationObserver = new window.MutationObserver(this._onMutations.bind(this));
        }
        flush() {
          this._onMutations(this._mutationObserver.takeRecords());
        }
        observe(t4) {
          this._domElements.add(t4), this.isEnabled && this._mutationObserver.observe(t4, this._config);
        }
        stopObserving(t4) {
          if (this._domElements.delete(t4), this.isEnabled) {
            this._mutationObserver.disconnect();
            for (const t5 of this._domElements)
              this._mutationObserver.observe(t5, this._config);
          }
        }
        enable() {
          super.enable();
          for (const t4 of this._domElements)
            this._mutationObserver.observe(t4, this._config);
        }
        disable() {
          super.disable(), this._mutationObserver.disconnect();
        }
        destroy() {
          super.destroy(), this._mutationObserver.disconnect();
        }
        _onMutations(t4) {
          if (0 === t4.length)
            return;
          const e4 = this.domConverter, n3 = /* @__PURE__ */ new Set(), o3 = /* @__PURE__ */ new Set();
          for (const n4 of t4) {
            const t5 = e4.mapDomToView(n4.target);
            t5 && (t5.is("uiElement") || t5.is("rawElement") || "childList" !== n4.type || this._isBogusBrMutation(n4) || o3.add(t5));
          }
          for (const i4 of t4) {
            const t5 = e4.mapDomToView(i4.target);
            if ((!t5 || !t5.is("uiElement") && !t5.is("rawElement")) && "characterData" === i4.type) {
              const t6 = e4.findCorrespondingViewText(i4.target);
              t6 && !o3.has(t6.parent) ? n3.add(t6) : !t6 && uc2(i4.target) && o3.add(e4.mapDomToView(i4.target.parentNode));
            }
          }
          let i3 = false;
          for (const t5 of n3)
            i3 = true, this.renderer.markToSync("text", t5);
          for (const t5 of o3) {
            const n4 = e4.mapViewToDom(t5), o4 = Array.from(t5.getChildren()), r3 = Array.from(e4.domChildrenToView(n4, { withChildren: false }));
            wl(o4, r3, Cl) || (i3 = true, this.renderer.markToSync("children", t5));
          }
          i3 && this.view.forceRender();
        }
        _isBogusBrMutation(t4) {
          let e4 = null;
          return null === t4.nextSibling && 0 === t4.removedNodes.length && 1 == t4.addedNodes.length && (e4 = this.domConverter.domToView(t4.addedNodes[0], { withChildren: false })), e4 && e4.is("element", "br");
        }
      }
      function Cl(t4, e4) {
        if (!Array.isArray(t4))
          return t4 === e4 || !(!t4.is("$text") || !e4.is("$text")) && t4.data === e4.data;
      }
      class _l extends Lc2 {
        constructor(t4) {
          super(t4), this._isFocusChanging = false, this.domEventType = ["focus", "blur"], this.useCapture = true;
          const e4 = this.document;
          e4.on("focus", () => {
            this._isFocusChanging = true, this._renderTimeoutId = setTimeout(() => {
              this.flush(), t4.change(() => {
              });
            }, 50);
          }), e4.on("blur", (n3, o3) => {
            const i3 = e4.selection.editableElement;
            null !== i3 && i3 !== o3.target || (e4.isFocused = false, this._isFocusChanging = false, t4.change(() => {
            }));
          });
        }
        flush() {
          this._isFocusChanging && (this._isFocusChanging = false, this.document.isFocused = true);
        }
        onDomEvent(t4) {
          this.fire(t4.type, t4);
        }
        destroy() {
          this._renderTimeoutId && clearTimeout(this._renderTimeoutId), super.destroy();
        }
      }
      class vl2 extends Pc2 {
        constructor(t4) {
          super(t4), this.mutationObserver = t4.getObserver(Al), this.focusObserver = t4.getObserver(_l), this.selection = this.document.selection, this.domConverter = t4.domConverter, this._documents = /* @__PURE__ */ new WeakSet(), this._fireSelectionChangeDoneDebounced = Qc2((t5) => {
            this.document.fire("selectionChangeDone", t5);
          }, 200), this._clearInfiniteLoopInterval = setInterval(() => this._clearInfiniteLoop(), 1e3), this._documentIsSelectingInactivityTimeoutDebounced = Qc2(() => this.document.isSelecting = false, 5e3), this._loopbackCounter = 0;
        }
        observe(t4) {
          const e4 = t4.ownerDocument, n3 = () => {
            this.document.isSelecting && (this._handleSelectionChange(null, e4), this.document.isSelecting = false, this._documentIsSelectingInactivityTimeoutDebounced.cancel());
          };
          this.listenTo(t4, "selectstart", () => {
            this.document.isSelecting = true, this._documentIsSelectingInactivityTimeoutDebounced();
          }, { priority: "highest" }), this.listenTo(t4, "keydown", n3, { priority: "highest", useCapture: true }), this.listenTo(t4, "keyup", n3, { priority: "highest", useCapture: true }), this._documents.has(e4) || (this.listenTo(e4, "mouseup", n3, { priority: "highest", useCapture: true }), this.listenTo(e4, "selectionchange", (t5, n4) => {
            this.document.isComposing && !a2.isAndroid || (this._handleSelectionChange(n4, e4), this._documentIsSelectingInactivityTimeoutDebounced());
          }), this._documents.add(e4));
        }
        stopObserving(t4) {
          this.stopListening(t4);
        }
        destroy() {
          super.destroy(), clearInterval(this._clearInfiniteLoopInterval), this._fireSelectionChangeDoneDebounced.cancel(), this._documentIsSelectingInactivityTimeoutDebounced.cancel();
        }
        _reportInfiniteLoop() {
        }
        _handleSelectionChange(t4, e4) {
          if (!this.isEnabled)
            return;
          const n3 = e4.defaultView.getSelection();
          if (this.checkShouldIgnoreEventFromTarget(n3.anchorNode))
            return;
          this.mutationObserver.flush();
          const o3 = this.domConverter.domSelectionToView(n3);
          if (0 != o3.rangeCount) {
            if (this.view.hasDomSelection = true, this.focusObserver.flush(), !this.selection.isEqual(o3) || !this.domConverter.isDomSelectionCorrect(n3))
              if (++this._loopbackCounter > 60)
                this._reportInfiniteLoop();
              else if (this.selection.isSimilar(o3))
                this.view.forceRender();
              else {
                const t5 = { oldSelection: this.selection, newSelection: o3, domSelection: n3 };
                this.document.fire("selectionChange", t5), this._fireSelectionChangeDoneDebounced(t5);
              }
          } else
            this.view.hasDomSelection = false;
        }
        _clearInfiniteLoop() {
          this._loopbackCounter = 0;
        }
      }
      class yl extends Lc2 {
        constructor(t4) {
          super(t4), this.domEventType = ["compositionstart", "compositionupdate", "compositionend"];
          const e4 = this.document;
          e4.on("compositionstart", () => {
            e4.isComposing = true;
          }, { priority: "low" }), e4.on("compositionend", () => {
            e4.isComposing = false;
          }, { priority: "low" });
        }
        onDomEvent(t4) {
          this.fire(t4.type, t4, { data: t4.data });
        }
      }
      class xl {
        constructor(t4, e4 = {}) {
          this._files = e4.cacheFiles ? El(t4) : null, this._native = t4;
        }
        get files() {
          return this._files || (this._files = El(this._native)), this._files;
        }
        get types() {
          return this._native.types;
        }
        getData(t4) {
          return this._native.getData(t4);
        }
        setData(t4, e4) {
          this._native.setData(t4, e4);
        }
        set effectAllowed(t4) {
          this._native.effectAllowed = t4;
        }
        get effectAllowed() {
          return this._native.effectAllowed;
        }
        set dropEffect(t4) {
          this._native.dropEffect = t4;
        }
        get dropEffect() {
          return this._native.dropEffect;
        }
        setDragImage(t4, e4, n3) {
          this._native.setDragImage(t4, e4, n3);
        }
        get isCanceled() {
          return "none" == this._native.dropEffect || !!this._native.mozUserCancelled;
        }
      }
      function El(t4) {
        const e4 = Array.from(t4.files || []), n3 = Array.from(t4.items || []);
        return e4.length ? e4 : n3.filter((t5) => "file" === t5.kind).map((t5) => t5.getAsFile());
      }
      class Dl extends Lc2 {
        constructor() {
          super(...arguments), this.domEventType = "beforeinput";
        }
        onDomEvent(t4) {
          const e4 = t4.getTargetRanges(), n3 = this.view, o3 = n3.document;
          let i3 = null, r3 = null, s3 = [];
          if (t4.dataTransfer && (i3 = new xl(t4.dataTransfer)), null !== t4.data ? r3 = t4.data : i3 && (r3 = i3.getData("text/plain")), o3.selection.isFake)
            s3 = Array.from(o3.selection.getRanges());
          else if (e4.length)
            s3 = e4.map((t5) => {
              const e5 = n3.domConverter.domPositionToView(t5.startContainer, t5.startOffset), o4 = n3.domConverter.domPositionToView(t5.endContainer, t5.endOffset);
              return e5 ? n3.createRange(e5, o4) : o4 ? n3.createRange(o4) : void 0;
            }).filter((t5) => !!t5);
          else if (a2.isAndroid) {
            const e5 = t4.target.ownerDocument.defaultView.getSelection();
            s3 = Array.from(n3.domConverter.domSelectionToView(e5).getRanges());
          }
          if (a2.isAndroid && "insertCompositionText" == t4.inputType && r3 && r3.endsWith("\n"))
            this.fire(t4.type, t4, { inputType: "insertParagraph", targetRanges: [n3.createRange(s3[0].end)] });
          else if ("insertText" == t4.inputType && r3 && r3.includes("\n")) {
            const e5 = r3.split(/\n{1,2}/g);
            let n4 = s3;
            for (let r4 = 0; r4 < e5.length; r4++) {
              const s4 = e5[r4];
              "" != s4 && (this.fire(t4.type, t4, { data: s4, dataTransfer: i3, targetRanges: n4, inputType: t4.inputType, isComposing: t4.isComposing }), n4 = [o3.selection.getFirstRange()]), r4 + 1 < e5.length && (this.fire(t4.type, t4, { inputType: "insertParagraph", targetRanges: n4 }), n4 = [o3.selection.getFirstRange()]);
            }
          } else
            this.fire(t4.type, t4, { data: r3, dataTransfer: i3, targetRanges: s3, inputType: t4.inputType, isComposing: t4.isComposing });
        }
      }
      class Sl extends Pc2 {
        constructor(t4) {
          super(t4), this.document.on("keydown", (t5, e4) => {
            if (this.isEnabled && ((n3 = e4.keyCode) == fi2.arrowright || n3 == fi2.arrowleft || n3 == fi2.arrowup || n3 == fi2.arrowdown)) {
              const n4 = new Ma2(this.document, "arrowKey", this.document.selection.getFirstRange());
              this.document.fire(n4, e4), n4.stop.called && t5.stop();
            }
            var n3;
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class Il extends Pc2 {
        constructor(t4) {
          super(t4);
          const e4 = this.document;
          e4.on("keydown", (t5, n3) => {
            if (!this.isEnabled || n3.keyCode != fi2.tab || n3.ctrlKey)
              return;
            const o3 = new Ma2(e4, "tab", e4.selection.getFirstRange());
            e4.fire(o3, n3), o3.stop.called && t5.stop();
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      const Tl = function(t4) {
        return _o2(t4, 5);
      };
      class Ml extends W2() {
        constructor(t4) {
          super(), this.domRoots = /* @__PURE__ */ new Map(), this._initialDomRootAttributes = /* @__PURE__ */ new WeakMap(), this._observers = /* @__PURE__ */ new Map(), this._ongoingChange = false, this._postFixersInProgress = false, this._renderingDisabled = false, this._hasChangedSinceTheLastRendering = false, this.document = new ja2(t4), this.domConverter = new Ic2(this.document), this.set("isRenderingInProgress", false), this.set("hasDomSelection", false), this._renderer = new bc2(this.domConverter, this.document.selection), this._renderer.bind("isFocused", "isSelecting", "isComposing").to(this.document, "isFocused", "isSelecting", "isComposing"), this._writer = new Za2(this.document), this.addObserver(Al), this.addObserver(_l), this.addObserver(vl2), this.addObserver(jc2), this.addObserver(Jc2), this.addObserver(yl), this.addObserver(Sl), this.addObserver(Dl), this.addObserver(Il), this.document.on("arrowKey", mc2, { priority: "low" }), Ga2(this), this.on("render", () => {
            this._render(), this.document.fire("layoutChanged"), this._hasChangedSinceTheLastRendering = false;
          }), this.listenTo(this.document.selection, "change", () => {
            this._hasChangedSinceTheLastRendering = true;
          }), this.listenTo(this.document, "change:isFocused", () => {
            this._hasChangedSinceTheLastRendering = true;
          }), a2.isiOS && this.listenTo(this.document, "blur", (t5, e4) => {
            this.domConverter.mapDomToView(e4.domEvent.relatedTarget) || this.domConverter._clearDomSelection();
          });
        }
        attachDomRoot(t4, e4 = "main") {
          const n3 = this.document.getRoot(e4);
          n3._name = t4.tagName.toLowerCase();
          const o3 = {};
          for (const { name: e5, value: i4 } of Array.from(t4.attributes))
            o3[e5] = i4, "class" === e5 ? this._writer.addClass(i4.split(" "), n3) : this._writer.setAttribute(e5, i4, n3);
          this._initialDomRootAttributes.set(t4, o3);
          const i3 = () => {
            this._writer.setAttribute("contenteditable", (!n3.isReadOnly).toString(), n3), n3.isReadOnly ? this._writer.addClass("ck-read-only", n3) : this._writer.removeClass("ck-read-only", n3);
          };
          i3(), this.domRoots.set(e4, t4), this.domConverter.bindElements(t4, n3), this._renderer.markToSync("children", n3), this._renderer.markToSync("attributes", n3), this._renderer.domDocuments.add(t4.ownerDocument), n3.on("change:children", (t5, e5) => this._renderer.markToSync("children", e5)), n3.on("change:attributes", (t5, e5) => this._renderer.markToSync("attributes", e5)), n3.on("change:text", (t5, e5) => this._renderer.markToSync("text", e5)), n3.on("change:isReadOnly", () => this.change(i3)), n3.on("change", () => {
            this._hasChangedSinceTheLastRendering = true;
          });
          for (const n4 of this._observers.values())
            n4.observe(t4, e4);
        }
        detachDomRoot(t4) {
          const e4 = this.domRoots.get(t4);
          Array.from(e4.attributes).forEach(({ name: t5 }) => e4.removeAttribute(t5));
          const n3 = this._initialDomRootAttributes.get(e4);
          for (const t5 in n3)
            e4.setAttribute(t5, n3[t5]);
          this.domRoots.delete(t4), this.domConverter.unbindDomElement(e4);
          for (const t5 of this._observers.values())
            t5.stopObserving(e4);
        }
        getDomRoot(t4 = "main") {
          return this.domRoots.get(t4);
        }
        addObserver(t4) {
          let e4 = this._observers.get(t4);
          if (e4)
            return e4;
          e4 = new t4(this), this._observers.set(t4, e4);
          for (const [t5, n3] of this.domRoots)
            e4.observe(n3, t5);
          return e4.enable(), e4;
        }
        getObserver(t4) {
          return this._observers.get(t4);
        }
        disableObservers() {
          for (const t4 of this._observers.values())
            t4.disable();
        }
        enableObservers() {
          for (const t4 of this._observers.values())
            t4.enable();
        }
        scrollToTheSelection({ alignToTop: t4, forceScroll: e4, viewportOffset: n3 = 20, ancestorOffset: o3 = 20 } = {}) {
          const i3 = this.document.selection.getFirstRange();
          if (!i3)
            return;
          const r3 = Tl({ alignToTop: t4, forceScroll: e4, viewportOffset: n3, ancestorOffset: o3 });
          "number" == typeof n3 && (n3 = { top: n3, bottom: n3, left: n3, right: n3 });
          const s3 = { target: this.domConverter.viewRangeToDom(i3), viewportOffset: n3, ancestorOffset: o3, alignToTop: t4, forceScroll: e4 };
          this.fire("scrollToTheSelection", s3, r3), function({ target: t5, viewportOffset: e5 = 0, ancestorOffset: n4 = 0, alignToTop: o4, forceScroll: i4 }) {
            const r4 = hi2(t5);
            let s4 = r4, a3 = null;
            for (e5 = function(t6) {
              return "number" == typeof t6 ? { top: t6, bottom: t6, left: t6, right: t6 } : t6;
            }(e5); s4; ) {
              let c3;
              c3 = ui2(s4 == r4 ? t5 : a3), si2({ parent: c3, getRect: () => gi2(t5, s4), alignToTop: o4, ancestorOffset: n4, forceScroll: i4 });
              const l3 = gi2(t5, s4);
              if (ri2({ window: s4, rect: l3, viewportOffset: e5, alignToTop: o4, forceScroll: i4 }), s4.parent != s4) {
                if (a3 = s4.frameElement, s4 = s4.parent, !a3)
                  return;
              } else
                s4 = null;
            }
          }(s3);
        }
        focus() {
          if (!this.document.isFocused) {
            const t4 = this.document.selection.editableElement;
            t4 && (this.domConverter.focus(t4), this.forceRender());
          }
        }
        change(t4) {
          if (this.isRenderingInProgress || this._postFixersInProgress)
            throw new A2("cannot-change-view-tree", this);
          try {
            if (this._ongoingChange)
              return t4(this._writer);
            this._ongoingChange = true;
            const e4 = t4(this._writer);
            return this._ongoingChange = false, !this._renderingDisabled && this._hasChangedSinceTheLastRendering && (this._postFixersInProgress = true, this.document._callPostFixers(this._writer), this._postFixersInProgress = false, this.fire("render")), e4;
          } catch (t5) {
            A2.rethrowUnexpectedError(t5, this);
          }
        }
        forceRender() {
          this._hasChangedSinceTheLastRendering = true, this.getObserver(_l).flush(), this.change(() => {
          });
        }
        destroy() {
          for (const t4 of this._observers.values())
            t4.destroy();
          this.document.destroy(), this.stopListening();
        }
        createPositionAt(t4, e4) {
          return Ea2._createAt(t4, e4);
        }
        createPositionAfter(t4) {
          return Ea2._createAfter(t4);
        }
        createPositionBefore(t4) {
          return Ea2._createBefore(t4);
        }
        createRange(t4, e4) {
          return new Da2(t4, e4);
        }
        createRangeOn(t4) {
          return Da2._createOn(t4);
        }
        createRangeIn(t4) {
          return Da2._createIn(t4);
        }
        createSelection(...t4) {
          return new Ia2(...t4);
        }
        _disableRendering(t4) {
          this._renderingDisabled = t4, 0 == t4 && this.change(() => {
          });
        }
        _render() {
          this.isRenderingInProgress = true, this.disableObservers(), this._renderer.render(), this.enableObservers(), this.isRenderingInProgress = false;
        }
      }
      class Bl {
        is() {
          throw new Error("is() method is abstract");
        }
      }
      class Nl extends Bl {
        constructor(t4) {
          super(), this.parent = null, this._attrs = Mi2(t4);
        }
        get document() {
          return null;
        }
        get index() {
          let t4;
          if (!this.parent)
            return null;
          if (null === (t4 = this.parent.getChildIndex(this)))
            throw new A2("model-node-not-found-in-parent", this);
          return t4;
        }
        get startOffset() {
          let t4;
          if (!this.parent)
            return null;
          if (null === (t4 = this.parent.getChildStartOffset(this)))
            throw new A2("model-node-not-found-in-parent", this);
          return t4;
        }
        get offsetSize() {
          return 1;
        }
        get endOffset() {
          return this.parent ? this.startOffset + this.offsetSize : null;
        }
        get nextSibling() {
          const t4 = this.index;
          return null !== t4 && this.parent.getChild(t4 + 1) || null;
        }
        get previousSibling() {
          const t4 = this.index;
          return null !== t4 && this.parent.getChild(t4 - 1) || null;
        }
        get root() {
          let t4 = this;
          for (; t4.parent; )
            t4 = t4.parent;
          return t4;
        }
        isAttached() {
          return null !== this.parent && this.root.isAttached();
        }
        getPath() {
          const t4 = [];
          let e4 = this;
          for (; e4.parent; )
            t4.unshift(e4.startOffset), e4 = e4.parent;
          return t4;
        }
        getAncestors(t4 = {}) {
          const e4 = [];
          let n3 = t4.includeSelf ? this : this.parent;
          for (; n3; )
            e4[t4.parentFirst ? "push" : "unshift"](n3), n3 = n3.parent;
          return e4;
        }
        getCommonAncestor(t4, e4 = {}) {
          const n3 = this.getAncestors(e4), o3 = t4.getAncestors(e4);
          let i3 = 0;
          for (; n3[i3] == o3[i3] && n3[i3]; )
            i3++;
          return 0 === i3 ? null : n3[i3 - 1];
        }
        isBefore(t4) {
          if (this == t4)
            return false;
          if (this.root !== t4.root)
            return false;
          const e4 = this.getPath(), n3 = t4.getPath(), o3 = tt2(e4, n3);
          switch (o3) {
            case "prefix":
              return true;
            case "extension":
              return false;
            default:
              return e4[o3] < n3[o3];
          }
        }
        isAfter(t4) {
          return this != t4 && (this.root === t4.root && !this.isBefore(t4));
        }
        hasAttribute(t4) {
          return this._attrs.has(t4);
        }
        getAttribute(t4) {
          return this._attrs.get(t4);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        toJSON() {
          const t4 = {};
          return this._attrs.size && (t4.attributes = Array.from(this._attrs).reduce((t5, e4) => (t5[e4[0]] = e4[1], t5), {})), t4;
        }
        _clone(t4) {
          return new this.constructor(this._attrs);
        }
        _remove() {
          this.parent._removeChildren(this.index);
        }
        _setAttribute(t4, e4) {
          this._attrs.set(t4, e4);
        }
        _setAttributesTo(t4) {
          this._attrs = Mi2(t4);
        }
        _removeAttribute(t4) {
          return this._attrs.delete(t4);
        }
        _clearAttributes() {
          this._attrs.clear();
        }
      }
      Nl.prototype.is = function(t4) {
        return "node" === t4 || "model:node" === t4;
      };
      class Pl {
        constructor(t4) {
          this._nodes = [], t4 && this._insertNodes(0, t4);
        }
        [Symbol.iterator]() {
          return this._nodes[Symbol.iterator]();
        }
        get length() {
          return this._nodes.length;
        }
        get maxOffset() {
          return this._nodes.reduce((t4, e4) => t4 + e4.offsetSize, 0);
        }
        getNode(t4) {
          return this._nodes[t4] || null;
        }
        getNodeIndex(t4) {
          const e4 = this._nodes.indexOf(t4);
          return -1 == e4 ? null : e4;
        }
        getNodeStartOffset(t4) {
          const e4 = this.getNodeIndex(t4);
          return null === e4 ? null : this._nodes.slice(0, e4).reduce((t5, e5) => t5 + e5.offsetSize, 0);
        }
        indexToOffset(t4) {
          if (t4 == this._nodes.length)
            return this.maxOffset;
          const e4 = this._nodes[t4];
          if (!e4)
            throw new A2("model-nodelist-index-out-of-bounds", this);
          return this.getNodeStartOffset(e4);
        }
        offsetToIndex(t4) {
          let e4 = 0;
          for (const n3 of this._nodes) {
            if (t4 >= e4 && t4 < e4 + n3.offsetSize)
              return this.getNodeIndex(n3);
            e4 += n3.offsetSize;
          }
          if (e4 != t4)
            throw new A2("model-nodelist-offset-out-of-bounds", this, { offset: t4, nodeList: this });
          return this.length;
        }
        _insertNodes(t4, e4) {
          for (const t5 of e4)
            if (!(t5 instanceof Nl))
              throw new A2("model-nodelist-insertnodes-not-node", this);
          this._nodes = function(t5, e5, n3, o3) {
            if (Math.max(e5.length, t5.length) > 1e4)
              return t5.slice(0, n3).concat(e5).concat(t5.slice(n3 + o3, t5.length));
            {
              const i3 = Array.from(t5);
              return i3.splice(n3, o3, ...e5), i3;
            }
          }(this._nodes, Array.from(e4), t4, 0);
        }
        _removeNodes(t4, e4 = 1) {
          return this._nodes.splice(t4, e4);
        }
        toJSON() {
          return this._nodes.map((t4) => t4.toJSON());
        }
      }
      class zl extends Nl {
        constructor(t4, e4) {
          super(e4), this._data = t4 || "";
        }
        get offsetSize() {
          return this.data.length;
        }
        get data() {
          return this._data;
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.data = this.data, t4;
        }
        _clone() {
          return new zl(this.data, this.getAttributes());
        }
        static fromJSON(t4) {
          return new zl(t4.data, t4.attributes);
        }
      }
      zl.prototype.is = function(t4) {
        return "$text" === t4 || "model:$text" === t4 || "text" === t4 || "model:text" === t4 || "node" === t4 || "model:node" === t4;
      };
      class Ol extends Bl {
        constructor(t4, e4, n3) {
          if (super(), this.textNode = t4, e4 < 0 || e4 > t4.offsetSize)
            throw new A2("model-textproxy-wrong-offsetintext", this);
          if (n3 < 0 || e4 + n3 > t4.offsetSize)
            throw new A2("model-textproxy-wrong-length", this);
          this.data = t4.data.substring(e4, e4 + n3), this.offsetInText = e4;
        }
        get startOffset() {
          return null !== this.textNode.startOffset ? this.textNode.startOffset + this.offsetInText : null;
        }
        get offsetSize() {
          return this.data.length;
        }
        get endOffset() {
          return null !== this.startOffset ? this.startOffset + this.offsetSize : null;
        }
        get isPartial() {
          return this.offsetSize !== this.textNode.offsetSize;
        }
        get parent() {
          return this.textNode.parent;
        }
        get root() {
          return this.textNode.root;
        }
        getPath() {
          const t4 = this.textNode.getPath();
          return t4.length > 0 && (t4[t4.length - 1] += this.offsetInText), t4;
        }
        getAncestors(t4 = {}) {
          const e4 = [];
          let n3 = t4.includeSelf ? this : this.parent;
          for (; n3; )
            e4[t4.parentFirst ? "push" : "unshift"](n3), n3 = n3.parent;
          return e4;
        }
        hasAttribute(t4) {
          return this.textNode.hasAttribute(t4);
        }
        getAttribute(t4) {
          return this.textNode.getAttribute(t4);
        }
        getAttributes() {
          return this.textNode.getAttributes();
        }
        getAttributeKeys() {
          return this.textNode.getAttributeKeys();
        }
      }
      Ol.prototype.is = function(t4) {
        return "$textProxy" === t4 || "model:$textProxy" === t4 || "textProxy" === t4 || "model:textProxy" === t4;
      };
      class Ll extends Nl {
        constructor(t4, e4, n3) {
          super(e4), this._children = new Pl(), this.name = t4, n3 && this._insertChild(0, n3);
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return 0 === this.childCount;
        }
        getChild(t4) {
          return this._children.getNode(t4);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t4) {
          return this._children.getNodeIndex(t4);
        }
        getChildStartOffset(t4) {
          return this._children.getNodeStartOffset(t4);
        }
        offsetToIndex(t4) {
          return this._children.offsetToIndex(t4);
        }
        getNodeByPath(t4) {
          let e4 = this;
          for (const n3 of t4)
            e4 = e4.getChild(e4.offsetToIndex(n3));
          return e4;
        }
        findAncestor(t4, e4 = {}) {
          let n3 = e4.includeSelf ? this : this.parent;
          for (; n3; ) {
            if (n3.name === t4)
              return n3;
            n3 = n3.parent;
          }
          return null;
        }
        toJSON() {
          const t4 = super.toJSON();
          if (t4.name = this.name, this._children.length > 0) {
            t4.children = [];
            for (const e4 of this._children)
              t4.children.push(e4.toJSON());
          }
          return t4;
        }
        _clone(t4 = false) {
          const e4 = t4 ? Array.from(this._children).map((t5) => t5._clone(true)) : void 0;
          return new Ll(this.name, this.getAttributes(), e4);
        }
        _appendChild(t4) {
          this._insertChild(this.childCount, t4);
        }
        _insertChild(t4, e4) {
          const n3 = function(t5) {
            if ("string" == typeof t5)
              return [new zl(t5)];
            et2(t5) || (t5 = [t5]);
            return Array.from(t5).map((t6) => "string" == typeof t6 ? new zl(t6) : t6 instanceof Ol ? new zl(t6.data, t6.getAttributes()) : t6);
          }(e4);
          for (const t5 of n3)
            null !== t5.parent && t5._remove(), t5.parent = this;
          this._children._insertNodes(t4, n3);
        }
        _removeChildren(t4, e4 = 1) {
          const n3 = this._children._removeNodes(t4, e4);
          for (const t5 of n3)
            t5.parent = null;
          return n3;
        }
        static fromJSON(t4) {
          let e4;
          if (t4.children) {
            e4 = [];
            for (const n3 of t4.children)
              n3.name ? e4.push(Ll.fromJSON(n3)) : e4.push(zl.fromJSON(n3));
          }
          return new Ll(t4.name, t4.attributes, e4);
        }
      }
      Ll.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("element" === t4 || "model:element" === t4) : "element" === t4 || "model:element" === t4 || "node" === t4 || "model:node" === t4;
      };
      class jl2 {
        constructor(t4) {
          if (!t4 || !t4.boundaries && !t4.startPosition)
            throw new A2("model-tree-walker-no-start-position", null);
          const e4 = t4.direction || "forward";
          if ("forward" != e4 && "backward" != e4)
            throw new A2("model-tree-walker-unknown-direction", t4, { direction: e4 });
          this.direction = e4, this.boundaries = t4.boundaries || null, t4.startPosition ? this._position = t4.startPosition.clone() : this._position = Fl._createAt(this.boundaries["backward" == this.direction ? "end" : "start"]), this.position.stickiness = "toNone", this.singleCharacters = !!t4.singleCharacters, this.shallow = !!t4.shallow, this.ignoreElementEnd = !!t4.ignoreElementEnd, this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null, this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null, this._visitedParent = this.position.parent;
        }
        [Symbol.iterator]() {
          return this;
        }
        get position() {
          return this._position;
        }
        skip(t4) {
          let e4, n3, o3, i3;
          do {
            o3 = this.position, i3 = this._visitedParent, { done: e4, value: n3 } = this.next();
          } while (!e4 && t4(n3));
          e4 || (this._position = o3, this._visitedParent = i3);
        }
        next() {
          return "forward" == this.direction ? this._next() : this._previous();
        }
        _next() {
          const t4 = this.position, e4 = this.position.clone(), n3 = this._visitedParent;
          if (null === n3.parent && e4.offset === n3.maxOffset)
            return { done: true, value: void 0 };
          if (n3 === this._boundaryEndParent && e4.offset == this.boundaries.end.offset)
            return { done: true, value: void 0 };
          const o3 = Vl(e4, n3), i3 = o3 || Hl(e4, n3, o3);
          if (i3 instanceof Ll) {
            if (this.shallow) {
              if (this.boundaries && this.boundaries.end.isBefore(e4))
                return { done: true, value: void 0 };
              e4.offset++;
            } else
              e4.path.push(0), this._visitedParent = i3;
            return this._position = e4, Rl("elementStart", i3, t4, e4, 1);
          }
          if (i3 instanceof zl) {
            let o4;
            if (this.singleCharacters)
              o4 = 1;
            else {
              let t5 = i3.endOffset;
              this._boundaryEndParent == n3 && this.boundaries.end.offset < t5 && (t5 = this.boundaries.end.offset), o4 = t5 - e4.offset;
            }
            const r3 = e4.offset - i3.startOffset, s3 = new Ol(i3, r3, o4);
            return e4.offset += o4, this._position = e4, Rl("text", s3, t4, e4, o4);
          }
          return e4.path.pop(), e4.offset++, this._position = e4, this._visitedParent = n3.parent, this.ignoreElementEnd ? this._next() : Rl("elementEnd", n3, t4, e4);
        }
        _previous() {
          const t4 = this.position, e4 = this.position.clone(), n3 = this._visitedParent;
          if (null === n3.parent && 0 === e4.offset)
            return { done: true, value: void 0 };
          if (n3 == this._boundaryStartParent && e4.offset == this.boundaries.start.offset)
            return { done: true, value: void 0 };
          const o3 = e4.parent, i3 = Vl(e4, o3), r3 = i3 || Ul(e4, o3, i3);
          if (r3 instanceof Ll)
            return e4.offset--, this.shallow ? (this._position = e4, Rl("elementStart", r3, t4, e4, 1)) : (e4.path.push(r3.maxOffset), this._position = e4, this._visitedParent = r3, this.ignoreElementEnd ? this._previous() : Rl("elementEnd", r3, t4, e4));
          if (r3 instanceof zl) {
            let o4;
            if (this.singleCharacters)
              o4 = 1;
            else {
              let t5 = r3.startOffset;
              this._boundaryStartParent == n3 && this.boundaries.start.offset > t5 && (t5 = this.boundaries.start.offset), o4 = e4.offset - t5;
            }
            const i4 = e4.offset - r3.startOffset, s3 = new Ol(r3, i4 - o4, o4);
            return e4.offset -= o4, this._position = e4, Rl("text", s3, t4, e4, o4);
          }
          return e4.path.pop(), this._position = e4, this._visitedParent = n3.parent, Rl("elementStart", n3, t4, e4, 1);
        }
      }
      function Rl(t4, e4, n3, o3, i3) {
        return { done: false, value: { type: t4, item: e4, previousPosition: n3, nextPosition: o3, length: i3 } };
      }
      class Fl extends Bl {
        constructor(t4, e4, n3 = "toNone") {
          if (super(), !t4.is("element") && !t4.is("documentFragment"))
            throw new A2("model-position-root-invalid", t4);
          if (!(e4 instanceof Array) || 0 === e4.length)
            throw new A2("model-position-path-incorrect-format", t4, { path: e4 });
          t4.is("rootElement") ? e4 = e4.slice() : (e4 = [...t4.getPath(), ...e4], t4 = t4.root), this.root = t4, this.path = e4, this.stickiness = n3;
        }
        get offset() {
          return this.path[this.path.length - 1];
        }
        set offset(t4) {
          this.path[this.path.length - 1] = t4;
        }
        get parent() {
          let t4 = this.root;
          for (let e4 = 0; e4 < this.path.length - 1; e4++)
            if (t4 = t4.getChild(t4.offsetToIndex(this.path[e4])), !t4)
              throw new A2("model-position-path-incorrect", this, { position: this });
          if (t4.is("$text"))
            throw new A2("model-position-path-incorrect", this, { position: this });
          return t4;
        }
        get index() {
          return this.parent.offsetToIndex(this.offset);
        }
        get textNode() {
          return Vl(this, this.parent);
        }
        get nodeAfter() {
          const t4 = this.parent;
          return Hl(this, t4, Vl(this, t4));
        }
        get nodeBefore() {
          const t4 = this.parent;
          return Ul(this, t4, Vl(this, t4));
        }
        get isAtStart() {
          return 0 === this.offset;
        }
        get isAtEnd() {
          return this.offset == this.parent.maxOffset;
        }
        compareWith(t4) {
          if (this.root != t4.root)
            return "different";
          const e4 = tt2(this.path, t4.path);
          switch (e4) {
            case "same":
              return "same";
            case "prefix":
              return "before";
            case "extension":
              return "after";
            default:
              return this.path[e4] < t4.path[e4] ? "before" : "after";
          }
        }
        getLastMatchingPosition(t4, e4 = {}) {
          e4.startPosition = this;
          const n3 = new jl2(e4);
          return n3.skip(t4), n3.position;
        }
        getParentPath() {
          return this.path.slice(0, -1);
        }
        getAncestors() {
          const t4 = this.parent;
          return t4.is("documentFragment") ? [t4] : t4.getAncestors({ includeSelf: true });
        }
        findAncestor(t4) {
          const e4 = this.parent;
          return e4.is("element") ? e4.findAncestor(t4, { includeSelf: true }) : null;
        }
        getCommonPath(t4) {
          if (this.root != t4.root)
            return [];
          const e4 = tt2(this.path, t4.path), n3 = "string" == typeof e4 ? Math.min(this.path.length, t4.path.length) : e4;
          return this.path.slice(0, n3);
        }
        getCommonAncestor(t4) {
          const e4 = this.getAncestors(), n3 = t4.getAncestors();
          let o3 = 0;
          for (; e4[o3] == n3[o3] && e4[o3]; )
            o3++;
          return 0 === o3 ? null : e4[o3 - 1];
        }
        getShiftedBy(t4) {
          const e4 = this.clone(), n3 = e4.offset + t4;
          return e4.offset = n3 < 0 ? 0 : n3, e4;
        }
        isAfter(t4) {
          return "after" == this.compareWith(t4);
        }
        isBefore(t4) {
          return "before" == this.compareWith(t4);
        }
        isEqual(t4) {
          return "same" == this.compareWith(t4);
        }
        isTouching(t4) {
          if (this.root !== t4.root)
            return false;
          const e4 = Math.min(this.path.length, t4.path.length);
          for (let n3 = 0; n3 < e4; n3++) {
            const e5 = this.path[n3] - t4.path[n3];
            if (e5 < -1 || e5 > 1)
              return false;
            if (1 === e5)
              return ql2(t4, this, n3);
            if (-1 === e5)
              return ql2(this, t4, n3);
          }
          return this.path.length === t4.path.length || (this.path.length > t4.path.length ? Gl(this.path, e4) : Gl(t4.path, e4));
        }
        hasSameParentAs(t4) {
          if (this.root !== t4.root)
            return false;
          return "same" == tt2(this.getParentPath(), t4.getParentPath());
        }
        getTransformedByOperation(t4) {
          let e4;
          switch (t4.type) {
            case "insert":
              e4 = this._getTransformedByInsertOperation(t4);
              break;
            case "move":
            case "remove":
            case "reinsert":
              e4 = this._getTransformedByMoveOperation(t4);
              break;
            case "split":
              e4 = this._getTransformedBySplitOperation(t4);
              break;
            case "merge":
              e4 = this._getTransformedByMergeOperation(t4);
              break;
            default:
              e4 = Fl._createAt(this);
          }
          return e4;
        }
        _getTransformedByInsertOperation(t4) {
          return this._getTransformedByInsertion(t4.position, t4.howMany);
        }
        _getTransformedByMoveOperation(t4) {
          return this._getTransformedByMove(t4.sourcePosition, t4.targetPosition, t4.howMany);
        }
        _getTransformedBySplitOperation(t4) {
          const e4 = t4.movedRange;
          return e4.containsPosition(this) || e4.start.isEqual(this) && "toNext" == this.stickiness ? this._getCombined(t4.splitPosition, t4.moveTargetPosition) : t4.graveyardPosition ? this._getTransformedByMove(t4.graveyardPosition, t4.insertionPosition, 1) : this._getTransformedByInsertion(t4.insertionPosition, 1);
        }
        _getTransformedByMergeOperation(t4) {
          const e4 = t4.movedRange;
          let n3;
          return e4.containsPosition(this) || e4.start.isEqual(this) ? (n3 = this._getCombined(t4.sourcePosition, t4.targetPosition), t4.sourcePosition.isBefore(t4.targetPosition) && (n3 = n3._getTransformedByDeletion(t4.deletionPosition, 1))) : n3 = this.isEqual(t4.deletionPosition) ? Fl._createAt(t4.deletionPosition) : this._getTransformedByMove(t4.deletionPosition, t4.graveyardPosition, 1), n3;
        }
        _getTransformedByDeletion(t4, e4) {
          const n3 = Fl._createAt(this);
          if (this.root != t4.root)
            return n3;
          if ("same" == tt2(t4.getParentPath(), this.getParentPath())) {
            if (t4.offset < this.offset) {
              if (t4.offset + e4 > this.offset)
                return null;
              n3.offset -= e4;
            }
          } else if ("prefix" == tt2(t4.getParentPath(), this.getParentPath())) {
            const o3 = t4.path.length - 1;
            if (t4.offset <= this.path[o3]) {
              if (t4.offset + e4 > this.path[o3])
                return null;
              n3.path[o3] -= e4;
            }
          }
          return n3;
        }
        _getTransformedByInsertion(t4, e4) {
          const n3 = Fl._createAt(this);
          if (this.root != t4.root)
            return n3;
          if ("same" == tt2(t4.getParentPath(), this.getParentPath()))
            (t4.offset < this.offset || t4.offset == this.offset && "toPrevious" != this.stickiness) && (n3.offset += e4);
          else if ("prefix" == tt2(t4.getParentPath(), this.getParentPath())) {
            const o3 = t4.path.length - 1;
            t4.offset <= this.path[o3] && (n3.path[o3] += e4);
          }
          return n3;
        }
        _getTransformedByMove(t4, e4, n3) {
          if (e4 = e4._getTransformedByDeletion(t4, n3), t4.isEqual(e4))
            return Fl._createAt(this);
          const o3 = this._getTransformedByDeletion(t4, n3);
          return null === o3 || t4.isEqual(this) && "toNext" == this.stickiness || t4.getShiftedBy(n3).isEqual(this) && "toPrevious" == this.stickiness ? this._getCombined(t4, e4) : o3._getTransformedByInsertion(e4, n3);
        }
        _getCombined(t4, e4) {
          const n3 = t4.path.length - 1, o3 = Fl._createAt(e4);
          return o3.stickiness = this.stickiness, o3.offset = o3.offset + this.path[n3] - t4.offset, o3.path = [...o3.path, ...this.path.slice(n3 + 1)], o3;
        }
        toJSON() {
          return { root: this.root.toJSON(), path: Array.from(this.path), stickiness: this.stickiness };
        }
        clone() {
          return new this.constructor(this.root, this.path, this.stickiness);
        }
        static _createAt(t4, e4, n3 = "toNone") {
          if (t4 instanceof Fl)
            return new Fl(t4.root, t4.path, t4.stickiness);
          {
            const o3 = t4;
            if ("end" == e4)
              e4 = o3.maxOffset;
            else {
              if ("before" == e4)
                return this._createBefore(o3, n3);
              if ("after" == e4)
                return this._createAfter(o3, n3);
              if (0 !== e4 && !e4)
                throw new A2("model-createpositionat-offset-required", [this, t4]);
            }
            if (!o3.is("element") && !o3.is("documentFragment"))
              throw new A2("model-position-parent-incorrect", [this, t4]);
            const i3 = o3.getPath();
            return i3.push(e4), new this(o3.root, i3, n3);
          }
        }
        static _createAfter(t4, e4) {
          if (!t4.parent)
            throw new A2("model-position-after-root", [this, t4], { root: t4 });
          return this._createAt(t4.parent, t4.endOffset, e4);
        }
        static _createBefore(t4, e4) {
          if (!t4.parent)
            throw new A2("model-position-before-root", t4, { root: t4 });
          return this._createAt(t4.parent, t4.startOffset, e4);
        }
        static fromJSON(t4, e4) {
          if ("$graveyard" === t4.root) {
            const n3 = new Fl(e4.graveyard, t4.path);
            return n3.stickiness = t4.stickiness, n3;
          }
          if (!e4.getRoot(t4.root))
            throw new A2("model-position-fromjson-no-root", e4, { rootName: t4.root });
          return new Fl(e4.getRoot(t4.root), t4.path, t4.stickiness);
        }
      }
      function Vl(t4, e4) {
        const n3 = e4.getChild(e4.offsetToIndex(t4.offset));
        return n3 && n3.is("$text") && n3.startOffset < t4.offset ? n3 : null;
      }
      function Hl(t4, e4, n3) {
        return null !== n3 ? null : e4.getChild(e4.offsetToIndex(t4.offset));
      }
      function Ul(t4, e4, n3) {
        return null !== n3 ? null : e4.getChild(e4.offsetToIndex(t4.offset) - 1);
      }
      function ql2(t4, e4, n3) {
        return n3 + 1 !== t4.path.length && (!!Gl(e4.path, n3 + 1) && !!function(t5, e5) {
          let n4 = t5.parent, o3 = t5.path.length - 1, i3 = 0;
          for (; o3 >= e5; ) {
            if (t5.path[o3] + i3 !== n4.maxOffset)
              return false;
            i3 = 1, o3--, n4 = n4.parent;
          }
          return true;
        }(t4, n3 + 1));
      }
      function Gl(t4, e4) {
        for (; e4 < t4.length; ) {
          if (0 !== t4[e4])
            return false;
          e4++;
        }
        return true;
      }
      Fl.prototype.is = function(t4) {
        return "position" === t4 || "model:position" === t4;
      };
      class Wl extends Bl {
        constructor(t4, e4) {
          super(), this.start = Fl._createAt(t4), this.end = e4 ? Fl._createAt(e4) : Fl._createAt(t4), this.start.stickiness = this.isCollapsed ? "toNone" : "toNext", this.end.stickiness = this.isCollapsed ? "toNone" : "toPrevious";
        }
        *[Symbol.iterator]() {
          yield* new jl2({ boundaries: this, ignoreElementEnd: true });
        }
        get isCollapsed() {
          return this.start.isEqual(this.end);
        }
        get isFlat() {
          return "same" == tt2(this.start.getParentPath(), this.end.getParentPath());
        }
        get root() {
          return this.start.root;
        }
        containsPosition(t4) {
          return t4.isAfter(this.start) && t4.isBefore(this.end);
        }
        containsRange(t4, e4 = false) {
          t4.isCollapsed && (e4 = false);
          const n3 = this.containsPosition(t4.start) || e4 && this.start.isEqual(t4.start), o3 = this.containsPosition(t4.end) || e4 && this.end.isEqual(t4.end);
          return n3 && o3;
        }
        containsItem(t4) {
          const e4 = Fl._createBefore(t4);
          return this.containsPosition(e4) || this.start.isEqual(e4);
        }
        isEqual(t4) {
          return this.start.isEqual(t4.start) && this.end.isEqual(t4.end);
        }
        isIntersecting(t4) {
          return this.start.isBefore(t4.end) && this.end.isAfter(t4.start);
        }
        getDifference(t4) {
          const e4 = [];
          return this.isIntersecting(t4) ? (this.containsPosition(t4.start) && e4.push(new Wl(this.start, t4.start)), this.containsPosition(t4.end) && e4.push(new Wl(t4.end, this.end))) : e4.push(new Wl(this.start, this.end)), e4;
        }
        getIntersection(t4) {
          if (this.isIntersecting(t4)) {
            let e4 = this.start, n3 = this.end;
            return this.containsPosition(t4.start) && (e4 = t4.start), this.containsPosition(t4.end) && (n3 = t4.end), new Wl(e4, n3);
          }
          return null;
        }
        getJoined(t4, e4 = false) {
          let n3 = this.isIntersecting(t4);
          if (n3 || (n3 = this.start.isBefore(t4.start) ? e4 ? this.end.isTouching(t4.start) : this.end.isEqual(t4.start) : e4 ? t4.end.isTouching(this.start) : t4.end.isEqual(this.start)), !n3)
            return null;
          let o3 = this.start, i3 = this.end;
          return t4.start.isBefore(o3) && (o3 = t4.start), t4.end.isAfter(i3) && (i3 = t4.end), new Wl(o3, i3);
        }
        getMinimalFlatRanges() {
          const t4 = [], e4 = this.start.getCommonPath(this.end).length, n3 = Fl._createAt(this.start);
          let o3 = n3.parent;
          for (; n3.path.length > e4 + 1; ) {
            const e5 = o3.maxOffset - n3.offset;
            0 !== e5 && t4.push(new Wl(n3, n3.getShiftedBy(e5))), n3.path = n3.path.slice(0, -1), n3.offset++, o3 = o3.parent;
          }
          for (; n3.path.length <= this.end.path.length; ) {
            const e5 = this.end.path[n3.path.length - 1], o4 = e5 - n3.offset;
            0 !== o4 && t4.push(new Wl(n3, n3.getShiftedBy(o4))), n3.offset = e5, n3.path.push(0);
          }
          return t4;
        }
        getWalker(t4 = {}) {
          return t4.boundaries = this, new jl2(t4);
        }
        *getItems(t4 = {}) {
          t4.boundaries = this, t4.ignoreElementEnd = true;
          const e4 = new jl2(t4);
          for (const t5 of e4)
            yield t5.item;
        }
        *getPositions(t4 = {}) {
          t4.boundaries = this;
          const e4 = new jl2(t4);
          yield e4.position;
          for (const t5 of e4)
            yield t5.nextPosition;
        }
        getTransformedByOperation(t4) {
          switch (t4.type) {
            case "insert":
              return this._getTransformedByInsertOperation(t4);
            case "move":
            case "remove":
            case "reinsert":
              return this._getTransformedByMoveOperation(t4);
            case "split":
              return [this._getTransformedBySplitOperation(t4)];
            case "merge":
              return [this._getTransformedByMergeOperation(t4)];
          }
          return [new Wl(this.start, this.end)];
        }
        getTransformedByOperations(t4) {
          const e4 = [new Wl(this.start, this.end)];
          for (const n3 of t4)
            for (let t5 = 0; t5 < e4.length; t5++) {
              const o3 = e4[t5].getTransformedByOperation(n3);
              e4.splice(t5, 1, ...o3), t5 += o3.length - 1;
            }
          for (let t5 = 0; t5 < e4.length; t5++) {
            const n3 = e4[t5];
            for (let o3 = t5 + 1; o3 < e4.length; o3++) {
              const t6 = e4[o3];
              (n3.containsRange(t6) || t6.containsRange(n3) || n3.isEqual(t6)) && e4.splice(o3, 1);
            }
          }
          return e4;
        }
        getCommonAncestor() {
          return this.start.getCommonAncestor(this.end);
        }
        getContainedElement() {
          if (this.isCollapsed)
            return null;
          const t4 = this.start.nodeAfter, e4 = this.end.nodeBefore;
          return t4 && t4.is("element") && t4 === e4 ? t4 : null;
        }
        toJSON() {
          return { start: this.start.toJSON(), end: this.end.toJSON() };
        }
        clone() {
          return new this.constructor(this.start, this.end);
        }
        _getTransformedByInsertOperation(t4, e4 = false) {
          return this._getTransformedByInsertion(t4.position, t4.howMany, e4);
        }
        _getTransformedByMoveOperation(t4, e4 = false) {
          const n3 = t4.sourcePosition, o3 = t4.howMany, i3 = t4.targetPosition;
          return this._getTransformedByMove(n3, i3, o3, e4);
        }
        _getTransformedBySplitOperation(t4) {
          const e4 = this.start._getTransformedBySplitOperation(t4);
          let n3 = this.end._getTransformedBySplitOperation(t4);
          return this.end.isEqual(t4.insertionPosition) && (n3 = this.end.getShiftedBy(1)), e4.root != n3.root && (n3 = this.end.getShiftedBy(-1)), new Wl(e4, n3);
        }
        _getTransformedByMergeOperation(t4) {
          if (this.start.isEqual(t4.targetPosition) && this.end.isEqual(t4.deletionPosition))
            return new Wl(this.start);
          let e4 = this.start._getTransformedByMergeOperation(t4), n3 = this.end._getTransformedByMergeOperation(t4);
          return e4.root != n3.root && (n3 = this.end.getShiftedBy(-1)), e4.isAfter(n3) ? (t4.sourcePosition.isBefore(t4.targetPosition) ? (e4 = Fl._createAt(n3), e4.offset = 0) : (t4.deletionPosition.isEqual(e4) || (n3 = t4.deletionPosition), e4 = t4.targetPosition), new Wl(e4, n3)) : new Wl(e4, n3);
        }
        _getTransformedByInsertion(t4, e4, n3 = false) {
          if (n3 && this.containsPosition(t4))
            return [new Wl(this.start, t4), new Wl(t4.getShiftedBy(e4), this.end._getTransformedByInsertion(t4, e4))];
          {
            const n4 = new Wl(this.start, this.end);
            return n4.start = n4.start._getTransformedByInsertion(t4, e4), n4.end = n4.end._getTransformedByInsertion(t4, e4), [n4];
          }
        }
        _getTransformedByMove(t4, e4, n3, o3 = false) {
          if (this.isCollapsed) {
            const o4 = this.start._getTransformedByMove(t4, e4, n3);
            return [new Wl(o4)];
          }
          const i3 = Wl._createFromPositionAndShift(t4, n3), r3 = e4._getTransformedByDeletion(t4, n3);
          if (this.containsPosition(e4) && !o3 && (i3.containsPosition(this.start) || i3.containsPosition(this.end))) {
            const o4 = this.start._getTransformedByMove(t4, e4, n3), i4 = this.end._getTransformedByMove(t4, e4, n3);
            return [new Wl(o4, i4)];
          }
          let s3;
          const a3 = this.getDifference(i3);
          let c3 = null;
          const l3 = this.getIntersection(i3);
          if (1 == a3.length ? c3 = new Wl(a3[0].start._getTransformedByDeletion(t4, n3), a3[0].end._getTransformedByDeletion(t4, n3)) : 2 == a3.length && (c3 = new Wl(this.start, this.end._getTransformedByDeletion(t4, n3))), s3 = c3 ? c3._getTransformedByInsertion(r3, n3, null !== l3 || o3) : [], l3) {
            const t5 = new Wl(l3.start._getCombined(i3.start, r3), l3.end._getCombined(i3.start, r3));
            2 == s3.length ? s3.splice(1, 0, t5) : s3.push(t5);
          }
          return s3;
        }
        _getTransformedByDeletion(t4, e4) {
          let n3 = this.start._getTransformedByDeletion(t4, e4), o3 = this.end._getTransformedByDeletion(t4, e4);
          return null == n3 && null == o3 ? null : (null == n3 && (n3 = t4), null == o3 && (o3 = t4), new Wl(n3, o3));
        }
        static _createFromPositionAndShift(t4, e4) {
          const n3 = t4, o3 = t4.getShiftedBy(e4);
          return e4 > 0 ? new this(n3, o3) : new this(o3, n3);
        }
        static _createIn(t4) {
          return new this(Fl._createAt(t4, 0), Fl._createAt(t4, t4.maxOffset));
        }
        static _createOn(t4) {
          return this._createFromPositionAndShift(Fl._createBefore(t4), t4.offsetSize);
        }
        static _createFromRanges(t4) {
          if (0 === t4.length)
            throw new A2("range-create-from-ranges-empty-array", null);
          if (1 == t4.length)
            return t4[0].clone();
          const e4 = t4[0];
          t4.sort((t5, e5) => t5.start.isAfter(e5.start) ? 1 : -1);
          const n3 = t4.indexOf(e4), o3 = new this(e4.start, e4.end);
          if (n3 > 0)
            for (let e5 = n3 - 1; t4[e5].end.isEqual(o3.start); e5++)
              o3.start = Fl._createAt(t4[e5].start);
          for (let e5 = n3 + 1; e5 < t4.length && t4[e5].start.isEqual(o3.end); e5++)
            o3.end = Fl._createAt(t4[e5].end);
          return o3;
        }
        static fromJSON(t4, e4) {
          return new this(Fl.fromJSON(t4.start, e4), Fl.fromJSON(t4.end, e4));
        }
      }
      Wl.prototype.is = function(t4) {
        return "range" === t4 || "model:range" === t4;
      };
      class Kl extends M2() {
        constructor() {
          super(), this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelLengthCallbacks = /* @__PURE__ */ new Map(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._deferredBindingRemovals = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this.on("modelToViewPosition", (t4, e4) => {
            if (e4.viewPosition)
              return;
            const n3 = this._modelToViewMapping.get(e4.modelPosition.parent);
            if (!n3)
              throw new A2("mapping-model-position-view-parent-not-found", this, { modelPosition: e4.modelPosition });
            e4.viewPosition = this.findPositionIn(n3, e4.modelPosition.offset);
          }, { priority: "low" }), this.on("viewToModelPosition", (t4, e4) => {
            if (e4.modelPosition)
              return;
            const n3 = this.findMappedViewAncestor(e4.viewPosition), o3 = this._viewToModelMapping.get(n3), i3 = this._toModelOffset(e4.viewPosition.parent, e4.viewPosition.offset, n3);
            e4.modelPosition = Fl._createAt(o3, i3);
          }, { priority: "low" });
        }
        bindElements(t4, e4) {
          this._modelToViewMapping.set(t4, e4), this._viewToModelMapping.set(e4, t4);
        }
        unbindViewElement(t4, e4 = {}) {
          const n3 = this.toModelElement(t4);
          if (this._elementToMarkerNames.has(t4))
            for (const e5 of this._elementToMarkerNames.get(t4))
              this._unboundMarkerNames.add(e5);
          e4.defer ? this._deferredBindingRemovals.set(t4, t4.root) : (this._viewToModelMapping.delete(t4), this._modelToViewMapping.get(n3) == t4 && this._modelToViewMapping.delete(n3));
        }
        unbindModelElement(t4) {
          const e4 = this.toViewElement(t4);
          this._modelToViewMapping.delete(t4), this._viewToModelMapping.get(e4) == t4 && this._viewToModelMapping.delete(e4);
        }
        bindElementToMarker(t4, e4) {
          const n3 = this._markerNameToElements.get(e4) || /* @__PURE__ */ new Set();
          n3.add(t4);
          const o3 = this._elementToMarkerNames.get(t4) || /* @__PURE__ */ new Set();
          o3.add(e4), this._markerNameToElements.set(e4, n3), this._elementToMarkerNames.set(t4, o3);
        }
        unbindElementFromMarkerName(t4, e4) {
          const n3 = this._markerNameToElements.get(e4);
          n3 && (n3.delete(t4), 0 == n3.size && this._markerNameToElements.delete(e4));
          const o3 = this._elementToMarkerNames.get(t4);
          o3 && (o3.delete(e4), 0 == o3.size && this._elementToMarkerNames.delete(t4));
        }
        flushUnboundMarkerNames() {
          const t4 = Array.from(this._unboundMarkerNames);
          return this._unboundMarkerNames.clear(), t4;
        }
        flushDeferredBindings() {
          for (const [t4, e4] of this._deferredBindingRemovals)
            t4.root == e4 && this.unbindViewElement(t4);
          this._deferredBindingRemovals = /* @__PURE__ */ new Map();
        }
        clearBindings() {
          this._modelToViewMapping = /* @__PURE__ */ new WeakMap(), this._viewToModelMapping = /* @__PURE__ */ new WeakMap(), this._markerNameToElements = /* @__PURE__ */ new Map(), this._elementToMarkerNames = /* @__PURE__ */ new Map(), this._unboundMarkerNames = /* @__PURE__ */ new Set(), this._deferredBindingRemovals = /* @__PURE__ */ new Map();
        }
        toModelElement(t4) {
          return this._viewToModelMapping.get(t4);
        }
        toViewElement(t4) {
          return this._modelToViewMapping.get(t4);
        }
        toModelRange(t4) {
          return new Wl(this.toModelPosition(t4.start), this.toModelPosition(t4.end));
        }
        toViewRange(t4) {
          return new Da2(this.toViewPosition(t4.start), this.toViewPosition(t4.end));
        }
        toModelPosition(t4) {
          const e4 = { viewPosition: t4, mapper: this };
          return this.fire("viewToModelPosition", e4), e4.modelPosition;
        }
        toViewPosition(t4, e4 = {}) {
          const n3 = { modelPosition: t4, mapper: this, isPhantom: e4.isPhantom };
          return this.fire("modelToViewPosition", n3), n3.viewPosition;
        }
        markerNameToElements(t4) {
          const e4 = this._markerNameToElements.get(t4);
          if (!e4)
            return null;
          const n3 = /* @__PURE__ */ new Set();
          for (const t5 of e4)
            if (t5.is("attributeElement"))
              for (const e5 of t5.getElementsWithSameId())
                n3.add(e5);
            else
              n3.add(t5);
          return n3;
        }
        registerViewToModelLength(t4, e4) {
          this._viewToModelLengthCallbacks.set(t4, e4);
        }
        findMappedViewAncestor(t4) {
          let e4 = t4.parent;
          for (; !this._viewToModelMapping.has(e4); )
            e4 = e4.parent;
          return e4;
        }
        _toModelOffset(t4, e4, n3) {
          if (n3 != t4) {
            return this._toModelOffset(t4.parent, t4.index, n3) + this._toModelOffset(t4, e4, t4);
          }
          if (t4.is("$text"))
            return e4;
          let o3 = 0;
          for (let n4 = 0; n4 < e4; n4++)
            o3 += this.getModelLength(t4.getChild(n4));
          return o3;
        }
        getModelLength(t4) {
          if (this._viewToModelLengthCallbacks.get(t4.name)) {
            return this._viewToModelLengthCallbacks.get(t4.name)(t4);
          }
          if (this._viewToModelMapping.has(t4))
            return 1;
          if (t4.is("$text"))
            return t4.data.length;
          if (t4.is("uiElement"))
            return 0;
          {
            let e4 = 0;
            for (const n3 of t4.getChildren())
              e4 += this.getModelLength(n3);
            return e4;
          }
        }
        findPositionIn(t4, e4) {
          let n3, o3 = 0, i3 = 0, r3 = 0;
          if (t4.is("$text"))
            return new Ea2(t4, e4);
          for (; i3 < e4; )
            n3 = t4.getChild(r3), o3 = this.getModelLength(n3), i3 += o3, r3++;
          return i3 == e4 ? this._moveViewPositionToTextNode(new Ea2(t4, r3)) : this.findPositionIn(n3, e4 - (i3 - o3));
        }
        _moveViewPositionToTextNode(t4) {
          const e4 = t4.nodeBefore, n3 = t4.nodeAfter;
          return e4 instanceof fs ? new Ea2(e4, e4.data.length) : n3 instanceof fs ? new Ea2(n3, 0) : t4;
        }
      }
      class Yl {
        constructor() {
          this._consumable = /* @__PURE__ */ new Map(), this._textProxyRegistry = /* @__PURE__ */ new Map();
        }
        add(t4, e4) {
          e4 = $l(e4), t4 instanceof Ol && (t4 = this._getSymbolForTextProxy(t4)), this._consumable.has(t4) || this._consumable.set(t4, /* @__PURE__ */ new Map()), this._consumable.get(t4).set(e4, true);
        }
        consume(t4, e4) {
          return e4 = $l(e4), t4 instanceof Ol && (t4 = this._getSymbolForTextProxy(t4)), !!this.test(t4, e4) && (this._consumable.get(t4).set(e4, false), true);
        }
        test(t4, e4) {
          e4 = $l(e4), t4 instanceof Ol && (t4 = this._getSymbolForTextProxy(t4));
          const n3 = this._consumable.get(t4);
          if (void 0 === n3)
            return null;
          const o3 = n3.get(e4);
          return void 0 === o3 ? null : o3;
        }
        revert(t4, e4) {
          e4 = $l(e4), t4 instanceof Ol && (t4 = this._getSymbolForTextProxy(t4));
          const n3 = this.test(t4, e4);
          return false === n3 ? (this._consumable.get(t4).set(e4, true), true) : true !== n3 && null;
        }
        verifyAllConsumed(t4) {
          const e4 = [];
          for (const [n3, o3] of this._consumable)
            for (const [i3, r3] of o3) {
              const o4 = i3.split(":")[0];
              r3 && t4 == o4 && e4.push({ event: i3, item: n3.name || n3.description });
            }
          if (e4.length)
            throw new A2("conversion-model-consumable-not-consumed", null, { items: e4 });
        }
        _getSymbolForTextProxy(t4) {
          let e4 = null;
          const n3 = this._textProxyRegistry.get(t4.startOffset);
          if (n3) {
            const o3 = n3.get(t4.endOffset);
            o3 && (e4 = o3.get(t4.parent));
          }
          return e4 || (e4 = this._addSymbolForTextProxy(t4)), e4;
        }
        _addSymbolForTextProxy(t4) {
          const e4 = t4.startOffset, n3 = t4.endOffset, o3 = t4.parent, i3 = Symbol("$textProxy:" + t4.data);
          let r3, s3;
          return r3 = this._textProxyRegistry.get(e4), r3 || (r3 = /* @__PURE__ */ new Map(), this._textProxyRegistry.set(e4, r3)), s3 = r3.get(n3), s3 || (s3 = /* @__PURE__ */ new Map(), r3.set(n3, s3)), s3.set(o3, i3), i3;
        }
      }
      function $l(t4) {
        const e4 = t4.split(":");
        return "insert" == e4[0] ? e4[0] : "addMarker" == e4[0] || "removeMarker" == e4[0] ? t4 : e4.length > 1 ? e4[0] + ":" + e4[1] : e4[0];
      }
      var Zl = Object.defineProperty, Ql = Object.defineProperties, Jl = Object.getOwnPropertyDescriptors, Xl = Object.getOwnPropertySymbols, td2 = Object.prototype.hasOwnProperty, ed2 = Object.prototype.propertyIsEnumerable, nd2 = (t4, e4, n3) => e4 in t4 ? Zl(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, od2 = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          td2.call(e4, n3) && nd2(t4, n3, e4[n3]);
        if (Xl)
          for (var n3 of Xl(e4))
            ed2.call(e4, n3) && nd2(t4, n3, e4[n3]);
        return t4;
      }, id2 = (t4, e4) => Ql(t4, Jl(e4));
      class rd2 extends M2() {
        constructor(t4) {
          super(), this._conversionApi = od2({ dispatcher: this }, t4), this._firedEventsMap = /* @__PURE__ */ new WeakMap();
        }
        convertChanges(t4, e4, n3) {
          const o3 = this._createConversionApi(n3, t4.getRefreshedItems());
          for (const e5 of t4.getMarkersToRemove())
            this._convertMarkerRemove(e5.name, e5.range, o3);
          const i3 = this._reduceChanges(t4.getChanges());
          for (const t5 of i3)
            "insert" === t5.type ? this._convertInsert(Wl._createFromPositionAndShift(t5.position, t5.length), o3) : "reinsert" === t5.type ? this._convertReinsert(Wl._createFromPositionAndShift(t5.position, t5.length), o3) : "remove" === t5.type ? this._convertRemove(t5.position, t5.length, t5.name, o3) : this._convertAttribute(t5.range, t5.attributeKey, t5.attributeOldValue, t5.attributeNewValue, o3);
          for (const t5 of o3.mapper.flushUnboundMarkerNames()) {
            const n4 = e4.get(t5).getRange();
            this._convertMarkerRemove(t5, n4, o3), this._convertMarkerAdd(t5, n4, o3);
          }
          for (const e5 of t4.getMarkersToAdd())
            this._convertMarkerAdd(e5.name, e5.range, o3);
          o3.mapper.flushDeferredBindings(), o3.consumable.verifyAllConsumed("insert");
        }
        convert(t4, e4, n3, o3 = {}) {
          const i3 = this._createConversionApi(n3, void 0, o3);
          this._convertInsert(t4, i3);
          for (const [t5, n4] of e4)
            this._convertMarkerAdd(t5, n4, i3);
          i3.consumable.verifyAllConsumed("insert");
        }
        convertSelection(t4, e4, n3) {
          const o3 = this._createConversionApi(n3);
          this.fire("cleanSelection", { selection: t4 }, o3);
          const i3 = t4.getFirstPosition().root;
          if (!o3.mapper.toViewElement(i3))
            return;
          const r3 = Array.from(e4.getMarkersAtPosition(t4.getFirstPosition()));
          if (this._addConsumablesForSelection(o3.consumable, t4, r3), this.fire("selection", { selection: t4 }, o3), t4.isCollapsed) {
            for (const e5 of r3)
              if (o3.consumable.test(t4, "addMarker:" + e5.name)) {
                const n4 = e5.getRange();
                if (!sd2(t4.getFirstPosition(), e5, o3.mapper))
                  continue;
                const i4 = { item: t4, markerName: e5.name, markerRange: n4 };
                this.fire(`addMarker:${e5.name}`, i4, o3);
              }
            for (const e5 of t4.getAttributeKeys())
              if (o3.consumable.test(t4, "attribute:" + e5)) {
                const n4 = { item: t4, range: t4.getFirstRange(), attributeKey: e5, attributeOldValue: null, attributeNewValue: t4.getAttribute(e5) };
                this.fire(`attribute:${e5}:$text`, n4, o3);
              }
          }
        }
        _convertInsert(t4, e4, n3 = {}) {
          n3.doNotAddConsumables || this._addConsumablesForInsert(e4.consumable, Array.from(t4));
          for (const n4 of Array.from(t4.getWalker({ shallow: true })).map(ad2))
            this._testAndFire("insert", n4, e4);
        }
        _convertRemove(t4, e4, n3, o3) {
          this.fire(`remove:${n3}`, { position: t4, length: e4 }, o3);
        }
        _convertAttribute(t4, e4, n3, o3, i3) {
          this._addConsumablesForRange(i3.consumable, t4, `attribute:${e4}`);
          for (const r3 of t4) {
            const t5 = { item: r3.item, range: Wl._createFromPositionAndShift(r3.previousPosition, r3.length), attributeKey: e4, attributeOldValue: n3, attributeNewValue: o3 };
            this._testAndFire(`attribute:${e4}`, t5, i3);
          }
        }
        _convertReinsert(t4, e4) {
          const n3 = Array.from(t4.getWalker({ shallow: true }));
          this._addConsumablesForInsert(e4.consumable, n3);
          for (const t5 of n3.map(ad2))
            this._testAndFire("insert", id2(od2({}, t5), { reconversion: true }), e4);
        }
        _convertMarkerAdd(t4, e4, n3) {
          if ("$graveyard" == e4.root.rootName)
            return;
          const o3 = `addMarker:${t4}`;
          if (n3.consumable.add(e4, o3), this.fire(o3, { markerName: t4, markerRange: e4 }, n3), n3.consumable.consume(e4, o3)) {
            this._addConsumablesForRange(n3.consumable, e4, o3);
            for (const i3 of e4.getItems()) {
              if (!n3.consumable.test(i3, o3))
                continue;
              const r3 = { item: i3, range: Wl._createOn(i3), markerName: t4, markerRange: e4 };
              this.fire(o3, r3, n3);
            }
          }
        }
        _convertMarkerRemove(t4, e4, n3) {
          "$graveyard" != e4.root.rootName && this.fire(`removeMarker:${t4}`, { markerName: t4, markerRange: e4 }, n3);
        }
        _reduceChanges(t4) {
          const e4 = { changes: t4 };
          return this.fire("reduceChanges", e4), e4.changes;
        }
        _addConsumablesForInsert(t4, e4) {
          for (const n3 of e4) {
            const e5 = n3.item;
            if (null === t4.test(e5, "insert")) {
              t4.add(e5, "insert");
              for (const n4 of e5.getAttributeKeys())
                t4.add(e5, "attribute:" + n4);
            }
          }
          return t4;
        }
        _addConsumablesForRange(t4, e4, n3) {
          for (const o3 of e4.getItems())
            t4.add(o3, n3);
          return t4;
        }
        _addConsumablesForSelection(t4, e4, n3) {
          t4.add(e4, "selection");
          for (const o3 of n3)
            t4.add(e4, "addMarker:" + o3.name);
          for (const n4 of e4.getAttributeKeys())
            t4.add(e4, "attribute:" + n4);
          return t4;
        }
        _testAndFire(t4, e4, n3) {
          const o3 = function(t5, e5) {
            const n4 = e5.item.is("element") ? e5.item.name : "$text";
            return `${t5}:${n4}`;
          }(t4, e4), i3 = e4.item.is("$textProxy") ? n3.consumable._getSymbolForTextProxy(e4.item) : e4.item, r3 = this._firedEventsMap.get(n3), s3 = r3.get(i3);
          if (s3) {
            if (s3.has(o3))
              return;
            s3.add(o3);
          } else
            r3.set(i3, /* @__PURE__ */ new Set([o3]));
          this.fire(o3, e4, n3);
        }
        _testAndFireAddAttributes(t4, e4) {
          const n3 = { item: t4, range: Wl._createOn(t4) };
          for (const t5 of n3.item.getAttributeKeys())
            n3.attributeKey = t5, n3.attributeOldValue = null, n3.attributeNewValue = n3.item.getAttribute(t5), this._testAndFire(`attribute:${t5}`, n3, e4);
        }
        _createConversionApi(t4, e4 = /* @__PURE__ */ new Set(), n3 = {}) {
          const o3 = id2(od2({}, this._conversionApi), { consumable: new Yl(), writer: t4, options: n3, convertItem: (t5) => this._convertInsert(Wl._createOn(t5), o3), convertChildren: (t5) => this._convertInsert(Wl._createIn(t5), o3, { doNotAddConsumables: true }), convertAttributes: (t5) => this._testAndFireAddAttributes(t5, o3), canReuseView: (t5) => !e4.has(o3.mapper.toModelElement(t5)) });
          return this._firedEventsMap.set(o3, /* @__PURE__ */ new Map()), o3;
        }
      }
      function sd2(t4, e4, n3) {
        const o3 = e4.getRange(), i3 = Array.from(t4.getAncestors());
        i3.shift(), i3.reverse();
        return !i3.some((t5) => {
          if (o3.containsItem(t5)) {
            return !!n3.toViewElement(t5).getCustomProperty("addHighlight");
          }
        });
      }
      function ad2(t4) {
        return { item: t4.item, range: Wl._createFromPositionAndShift(t4.previousPosition, t4.length) };
      }
      class cd2 extends M2(Bl) {
        constructor(...t4) {
          super(), this._lastRangeBackward = false, this._attrs = /* @__PURE__ */ new Map(), this._ranges = [], t4.length && this.setTo(...t4);
        }
        get anchor() {
          if (this._ranges.length > 0) {
            const t4 = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t4.end : t4.start;
          }
          return null;
        }
        get focus() {
          if (this._ranges.length > 0) {
            const t4 = this._ranges[this._ranges.length - 1];
            return this._lastRangeBackward ? t4.start : t4.end;
          }
          return null;
        }
        get isCollapsed() {
          return 1 === this._ranges.length && this._ranges[0].isCollapsed;
        }
        get rangeCount() {
          return this._ranges.length;
        }
        get isBackward() {
          return !this.isCollapsed && this._lastRangeBackward;
        }
        isEqual(t4) {
          if (this.rangeCount != t4.rangeCount)
            return false;
          if (0 === this.rangeCount)
            return true;
          if (!this.anchor.isEqual(t4.anchor) || !this.focus.isEqual(t4.focus))
            return false;
          for (const e4 of this._ranges) {
            let n3 = false;
            for (const o3 of t4._ranges)
              if (e4.isEqual(o3)) {
                n3 = true;
                break;
              }
            if (!n3)
              return false;
          }
          return true;
        }
        *getRanges() {
          for (const t4 of this._ranges)
            yield new Wl(t4.start, t4.end);
        }
        getFirstRange() {
          let t4 = null;
          for (const e4 of this._ranges)
            t4 && !e4.start.isBefore(t4.start) || (t4 = e4);
          return t4 ? new Wl(t4.start, t4.end) : null;
        }
        getLastRange() {
          let t4 = null;
          for (const e4 of this._ranges)
            t4 && !e4.end.isAfter(t4.end) || (t4 = e4);
          return t4 ? new Wl(t4.start, t4.end) : null;
        }
        getFirstPosition() {
          const t4 = this.getFirstRange();
          return t4 ? t4.start.clone() : null;
        }
        getLastPosition() {
          const t4 = this.getLastRange();
          return t4 ? t4.end.clone() : null;
        }
        setTo(...t4) {
          let [e4, n3, o3] = t4;
          if ("object" == typeof n3 && (o3 = n3, n3 = void 0), null === e4)
            this._setRanges([]);
          else if (e4 instanceof cd2)
            this._setRanges(e4.getRanges(), e4.isBackward);
          else if (e4 && "function" == typeof e4.getRanges)
            this._setRanges(e4.getRanges(), e4.isBackward);
          else if (e4 instanceof Wl)
            this._setRanges([e4], !!o3 && !!o3.backward);
          else if (e4 instanceof Fl)
            this._setRanges([new Wl(e4)]);
          else if (e4 instanceof Nl) {
            const t5 = !!o3 && !!o3.backward;
            let i3;
            if ("in" == n3)
              i3 = Wl._createIn(e4);
            else if ("on" == n3)
              i3 = Wl._createOn(e4);
            else {
              if (void 0 === n3)
                throw new A2("model-selection-setto-required-second-parameter", [this, e4]);
              i3 = new Wl(Fl._createAt(e4, n3));
            }
            this._setRanges([i3], t5);
          } else {
            if (!et2(e4))
              throw new A2("model-selection-setto-not-selectable", [this, e4]);
            this._setRanges(e4, o3 && !!o3.backward);
          }
        }
        _setRanges(t4, e4 = false) {
          const n3 = Array.from(t4), o3 = n3.some((e5) => {
            if (!(e5 instanceof Wl))
              throw new A2("model-selection-set-ranges-not-range", [this, t4]);
            return this._ranges.every((t5) => !t5.isEqual(e5));
          });
          (n3.length !== this._ranges.length || o3) && (this._replaceAllRanges(n3), this._lastRangeBackward = !!e4, this.fire("change:range", { directChange: true }));
        }
        setFocus(t4, e4) {
          if (null === this.anchor)
            throw new A2("model-selection-setfocus-no-ranges", [this, t4]);
          const n3 = Fl._createAt(t4, e4);
          if ("same" == n3.compareWith(this.focus))
            return;
          const o3 = this.anchor;
          this._ranges.length && this._popRange(), "before" == n3.compareWith(o3) ? (this._pushRange(new Wl(n3, o3)), this._lastRangeBackward = true) : (this._pushRange(new Wl(o3, n3)), this._lastRangeBackward = false), this.fire("change:range", { directChange: true });
        }
        getAttribute(t4) {
          return this._attrs.get(t4);
        }
        getAttributes() {
          return this._attrs.entries();
        }
        getAttributeKeys() {
          return this._attrs.keys();
        }
        hasAttribute(t4) {
          return this._attrs.has(t4);
        }
        removeAttribute(t4) {
          this.hasAttribute(t4) && (this._attrs.delete(t4), this.fire("change:attribute", { attributeKeys: [t4], directChange: true }));
        }
        setAttribute(t4, e4) {
          this.getAttribute(t4) !== e4 && (this._attrs.set(t4, e4), this.fire("change:attribute", { attributeKeys: [t4], directChange: true }));
        }
        getSelectedElement() {
          return 1 !== this.rangeCount ? null : this.getFirstRange().getContainedElement();
        }
        *getSelectedBlocks() {
          const t4 = /* @__PURE__ */ new WeakSet();
          for (const e4 of this.getRanges()) {
            const n3 = hd2(e4.start, t4);
            gd2(n3, e4) && (yield n3);
            for (const n4 of e4.getWalker()) {
              const o4 = n4.item;
              "elementEnd" == n4.type && dd2(o4, t4, e4) && (yield o4);
            }
            const o3 = hd2(e4.end, t4);
            pd2(o3, e4) && (yield o3);
          }
        }
        containsEntireContent(t4 = this.anchor.root) {
          const e4 = Fl._createAt(t4, 0), n3 = Fl._createAt(t4, "end");
          return e4.isTouching(this.getFirstPosition()) && n3.isTouching(this.getLastPosition());
        }
        _pushRange(t4) {
          this._checkRange(t4), this._ranges.push(new Wl(t4.start, t4.end));
        }
        _checkRange(t4) {
          for (let e4 = 0; e4 < this._ranges.length; e4++)
            if (t4.isIntersecting(this._ranges[e4]))
              throw new A2("model-selection-range-intersects", [this, t4], { addedRange: t4, intersectingRange: this._ranges[e4] });
        }
        _replaceAllRanges(t4) {
          this._removeAllRanges();
          for (const e4 of t4)
            this._pushRange(e4);
        }
        _removeAllRanges() {
          for (; this._ranges.length > 0; )
            this._popRange();
        }
        _popRange() {
          this._ranges.pop();
        }
      }
      function ld2(t4, e4) {
        return !e4.has(t4) && (e4.add(t4), t4.root.document.model.schema.isBlock(t4) && !!t4.parent);
      }
      function dd2(t4, e4, n3) {
        return ld2(t4, e4) && ud2(t4, n3);
      }
      function hd2(t4, e4) {
        const n3 = t4.parent.root.document.model.schema, o3 = t4.parent.getAncestors({ parentFirst: true, includeSelf: true });
        let i3 = false;
        const r3 = o3.find((t5) => !i3 && (i3 = n3.isLimit(t5), !i3 && ld2(t5, e4)));
        return o3.forEach((t5) => e4.add(t5)), r3;
      }
      function ud2(t4, e4) {
        const n3 = function(t5) {
          const e5 = t5.root.document.model.schema;
          let n4 = t5.parent;
          for (; n4; ) {
            if (e5.isBlock(n4))
              return n4;
            n4 = n4.parent;
          }
        }(t4);
        if (!n3)
          return true;
        return !e4.containsRange(Wl._createOn(n3), true);
      }
      function gd2(t4, e4) {
        return !!t4 && (!(!e4.isCollapsed && !t4.isEmpty) || !e4.start.isTouching(Fl._createAt(t4, t4.maxOffset)) && ud2(t4, e4));
      }
      function pd2(t4, e4) {
        return !!t4 && (!(!e4.isCollapsed && !t4.isEmpty) || !e4.end.isTouching(Fl._createAt(t4, 0)) && ud2(t4, e4));
      }
      cd2.prototype.is = function(t4) {
        return "selection" === t4 || "model:selection" === t4;
      };
      class md2 extends M2(Wl) {
        constructor(t4, e4) {
          super(t4, e4), fd2.call(this);
        }
        detach() {
          this.stopListening();
        }
        toRange() {
          return new Wl(this.start, this.end);
        }
        static fromRange(t4) {
          return new md2(t4.start, t4.end);
        }
      }
      function fd2() {
        this.listenTo(this.root.document.model, "applyOperation", (t4, e4) => {
          const n3 = e4[0];
          n3.isDocumentOperation && kd2.call(this, n3);
        }, { priority: "low" });
      }
      function kd2(t4) {
        const e4 = this.getTransformedByOperation(t4), n3 = Wl._createFromRanges(e4), o3 = !n3.isEqual(this), i3 = function(t5, e5) {
          switch (e5.type) {
            case "insert":
              return t5.containsPosition(e5.position);
            case "move":
            case "remove":
            case "reinsert":
            case "merge":
              return t5.containsPosition(e5.sourcePosition) || t5.start.isEqual(e5.sourcePosition) || t5.containsPosition(e5.targetPosition);
            case "split":
              return t5.containsPosition(e5.splitPosition) || t5.containsPosition(e5.insertionPosition);
          }
          return false;
        }(this, t4);
        let r3 = null;
        if (o3) {
          "$graveyard" == n3.root.rootName && (r3 = "remove" == t4.type ? t4.sourcePosition : t4.deletionPosition);
          const e5 = this.toRange();
          this.start = n3.start, this.end = n3.end, this.fire("change:range", e5, { deletionPosition: r3 });
        } else
          i3 && this.fire("change:content", this.toRange(), { deletionPosition: r3 });
      }
      md2.prototype.is = function(t4) {
        return "liveRange" === t4 || "model:liveRange" === t4 || "range" == t4 || "model:range" === t4;
      };
      const bd2 = "selection:";
      class wd2 extends M2(Bl) {
        constructor(t4) {
          super(), this._selection = new Ad2(t4), this._selection.delegate("change:range").to(this), this._selection.delegate("change:attribute").to(this), this._selection.delegate("change:marker").to(this);
        }
        get isCollapsed() {
          return this._selection.isCollapsed;
        }
        get anchor() {
          return this._selection.anchor;
        }
        get focus() {
          return this._selection.focus;
        }
        get rangeCount() {
          return this._selection.rangeCount;
        }
        get hasOwnRange() {
          return this._selection.hasOwnRange;
        }
        get isBackward() {
          return this._selection.isBackward;
        }
        get isGravityOverridden() {
          return this._selection.isGravityOverridden;
        }
        get markers() {
          return this._selection.markers;
        }
        get _ranges() {
          return this._selection._ranges;
        }
        getRanges() {
          return this._selection.getRanges();
        }
        getFirstPosition() {
          return this._selection.getFirstPosition();
        }
        getLastPosition() {
          return this._selection.getLastPosition();
        }
        getFirstRange() {
          return this._selection.getFirstRange();
        }
        getLastRange() {
          return this._selection.getLastRange();
        }
        getSelectedBlocks() {
          return this._selection.getSelectedBlocks();
        }
        getSelectedElement() {
          return this._selection.getSelectedElement();
        }
        containsEntireContent(t4) {
          return this._selection.containsEntireContent(t4);
        }
        destroy() {
          this._selection.destroy();
        }
        getAttributeKeys() {
          return this._selection.getAttributeKeys();
        }
        getAttributes() {
          return this._selection.getAttributes();
        }
        getAttribute(t4) {
          return this._selection.getAttribute(t4);
        }
        hasAttribute(t4) {
          return this._selection.hasAttribute(t4);
        }
        refresh() {
          this._selection.updateMarkers(), this._selection._updateAttributes(false);
        }
        observeMarkers(t4) {
          this._selection.observeMarkers(t4);
        }
        _setFocus(t4, e4) {
          this._selection.setFocus(t4, e4);
        }
        _setTo(...t4) {
          this._selection.setTo(...t4);
        }
        _setAttribute(t4, e4) {
          this._selection.setAttribute(t4, e4);
        }
        _removeAttribute(t4) {
          this._selection.removeAttribute(t4);
        }
        _getStoredAttributes() {
          return this._selection.getStoredAttributes();
        }
        _overrideGravity() {
          return this._selection.overrideGravity();
        }
        _restoreGravity(t4) {
          this._selection.restoreGravity(t4);
        }
        static _getStoreAttributeKey(t4) {
          return bd2 + t4;
        }
        static _isStoreAttributeKey(t4) {
          return t4.startsWith(bd2);
        }
      }
      wd2.prototype.is = function(t4) {
        return "selection" === t4 || "model:selection" == t4 || "documentSelection" == t4 || "model:documentSelection" == t4;
      };
      class Ad2 extends cd2 {
        constructor(t4) {
          super(), this.markers = new Di2({ idProperty: "name" }), this._attributePriority = /* @__PURE__ */ new Map(), this._selectionRestorePosition = null, this._hasChangedRange = false, this._overriddenGravityRegister = /* @__PURE__ */ new Set(), this._observedMarkers = /* @__PURE__ */ new Set(), this._model = t4.model, this._document = t4, this.listenTo(this._model, "applyOperation", (t5, e4) => {
            const n3 = e4[0];
            n3.isDocumentOperation && "marker" != n3.type && "rename" != n3.type && "noop" != n3.type && (0 == this._ranges.length && this._selectionRestorePosition && this._fixGraveyardSelection(this._selectionRestorePosition), this._selectionRestorePosition = null, this._hasChangedRange && (this._hasChangedRange = false, this.fire("change:range", { directChange: false })));
          }, { priority: "lowest" }), this.on("change:range", () => {
            this._validateSelectionRanges(this.getRanges());
          }), this.listenTo(this._model.markers, "update", (t5, e4, n3, o3) => {
            this._updateMarker(e4, o3);
          }), this.listenTo(this._document, "change", (t5, e4) => {
            !function(t6, e5) {
              const n3 = t6.document.differ;
              for (const o3 of n3.getChanges()) {
                if ("insert" != o3.type)
                  continue;
                const n4 = o3.position.parent;
                o3.length === n4.maxOffset && t6.enqueueChange(e5, (t7) => {
                  const e6 = Array.from(n4.getAttributeKeys()).filter((t8) => t8.startsWith(bd2));
                  for (const o4 of e6)
                    t7.removeAttribute(o4, n4);
                });
              }
            }(this._model, e4);
          });
        }
        get isCollapsed() {
          return 0 === this._ranges.length ? this._document._getDefaultRange().isCollapsed : super.isCollapsed;
        }
        get anchor() {
          return super.anchor || this._document._getDefaultRange().start;
        }
        get focus() {
          return super.focus || this._document._getDefaultRange().end;
        }
        get rangeCount() {
          return this._ranges.length ? this._ranges.length : 1;
        }
        get hasOwnRange() {
          return this._ranges.length > 0;
        }
        get isGravityOverridden() {
          return !!this._overriddenGravityRegister.size;
        }
        destroy() {
          for (let t4 = 0; t4 < this._ranges.length; t4++)
            this._ranges[t4].detach();
          this.stopListening();
        }
        *getRanges() {
          this._ranges.length ? yield* super.getRanges() : yield this._document._getDefaultRange();
        }
        getFirstRange() {
          return super.getFirstRange() || this._document._getDefaultRange();
        }
        getLastRange() {
          return super.getLastRange() || this._document._getDefaultRange();
        }
        setTo(...t4) {
          super.setTo(...t4), this._updateAttributes(true), this.updateMarkers();
        }
        setFocus(t4, e4) {
          super.setFocus(t4, e4), this._updateAttributes(true), this.updateMarkers();
        }
        setAttribute(t4, e4) {
          if (this._setAttribute(t4, e4)) {
            const e5 = [t4];
            this.fire("change:attribute", { attributeKeys: e5, directChange: true });
          }
        }
        removeAttribute(t4) {
          if (this._removeAttribute(t4)) {
            const e4 = [t4];
            this.fire("change:attribute", { attributeKeys: e4, directChange: true });
          }
        }
        overrideGravity() {
          const t4 = f2();
          return this._overriddenGravityRegister.add(t4), 1 === this._overriddenGravityRegister.size && this._updateAttributes(true), t4;
        }
        restoreGravity(t4) {
          if (!this._overriddenGravityRegister.has(t4))
            throw new A2("document-selection-gravity-wrong-restore", this, { uid: t4 });
          this._overriddenGravityRegister.delete(t4), this.isGravityOverridden || this._updateAttributes(true);
        }
        observeMarkers(t4) {
          this._observedMarkers.add(t4), this.updateMarkers();
        }
        _replaceAllRanges(t4) {
          this._validateSelectionRanges(t4), super._replaceAllRanges(t4);
        }
        _popRange() {
          this._ranges.pop().detach();
        }
        _pushRange(t4) {
          const e4 = this._prepareRange(t4);
          e4 && this._ranges.push(e4);
        }
        _validateSelectionRanges(t4) {
          for (const e4 of t4)
            if (!this._document._validateSelectionRange(e4))
              throw new A2("document-selection-wrong-position", this, { range: e4 });
        }
        _prepareRange(t4) {
          if (this._checkRange(t4), t4.root == this._document.graveyard)
            return;
          const e4 = md2.fromRange(t4);
          return e4.on("change:range", (t5, n3, o3) => {
            if (this._hasChangedRange = true, e4.root == this._document.graveyard) {
              this._selectionRestorePosition = o3.deletionPosition;
              const t6 = this._ranges.indexOf(e4);
              this._ranges.splice(t6, 1), e4.detach();
            }
          }), e4;
        }
        updateMarkers() {
          if (!this._observedMarkers.size)
            return;
          const t4 = [];
          let e4 = false;
          for (const e5 of this._model.markers) {
            const n4 = e5.name.split(":", 1)[0];
            if (!this._observedMarkers.has(n4))
              continue;
            const o3 = e5.getRange();
            for (const n5 of this.getRanges())
              o3.containsRange(n5, !n5.isCollapsed) && t4.push(e5);
          }
          const n3 = Array.from(this.markers);
          for (const n4 of t4)
            this.markers.has(n4) || (this.markers.add(n4), e4 = true);
          for (const n4 of Array.from(this.markers))
            t4.includes(n4) || (this.markers.remove(n4), e4 = true);
          e4 && this.fire("change:marker", { oldMarkers: n3, directChange: false });
        }
        _updateMarker(t4, e4) {
          const n3 = t4.name.split(":", 1)[0];
          if (!this._observedMarkers.has(n3))
            return;
          let o3 = false;
          const i3 = Array.from(this.markers), r3 = this.markers.has(t4);
          if (e4) {
            let n4 = false;
            for (const t5 of this.getRanges())
              if (e4.containsRange(t5, !t5.isCollapsed)) {
                n4 = true;
                break;
              }
            n4 && !r3 ? (this.markers.add(t4), o3 = true) : !n4 && r3 && (this.markers.remove(t4), o3 = true);
          } else
            r3 && (this.markers.remove(t4), o3 = true);
          o3 && this.fire("change:marker", { oldMarkers: i3, directChange: false });
        }
        _updateAttributes(t4) {
          const e4 = Mi2(this._getSurroundingAttributes()), n3 = Mi2(this.getAttributes());
          if (t4)
            this._attributePriority = /* @__PURE__ */ new Map(), this._attrs = /* @__PURE__ */ new Map();
          else
            for (const [t5, e5] of this._attributePriority)
              "low" == e5 && (this._attrs.delete(t5), this._attributePriority.delete(t5));
          this._setAttributesTo(e4);
          const o3 = [];
          for (const [t5, e5] of this.getAttributes())
            n3.has(t5) && n3.get(t5) === e5 || o3.push(t5);
          for (const [t5] of n3)
            this.hasAttribute(t5) || o3.push(t5);
          o3.length > 0 && this.fire("change:attribute", { attributeKeys: o3, directChange: false });
        }
        _setAttribute(t4, e4, n3 = true) {
          const o3 = n3 ? "normal" : "low";
          if ("low" == o3 && "normal" == this._attributePriority.get(t4))
            return false;
          return super.getAttribute(t4) !== e4 && (this._attrs.set(t4, e4), this._attributePriority.set(t4, o3), true);
        }
        _removeAttribute(t4, e4 = true) {
          const n3 = e4 ? "normal" : "low";
          return ("low" != n3 || "normal" != this._attributePriority.get(t4)) && (this._attributePriority.set(t4, n3), !!super.hasAttribute(t4) && (this._attrs.delete(t4), true));
        }
        _setAttributesTo(t4) {
          const e4 = /* @__PURE__ */ new Set();
          for (const [e5, n3] of this.getAttributes())
            t4.get(e5) !== n3 && this._removeAttribute(e5, false);
          for (const [n3, o3] of t4) {
            this._setAttribute(n3, o3, false) && e4.add(n3);
          }
          return e4;
        }
        *getStoredAttributes() {
          const t4 = this.getFirstPosition().parent;
          if (this.isCollapsed && t4.isEmpty) {
            for (const e4 of t4.getAttributeKeys())
              if (e4.startsWith(bd2)) {
                const n3 = e4.substr(10);
                yield [n3, t4.getAttribute(e4)];
              }
          }
        }
        _getSurroundingAttributes() {
          const t4 = this.getFirstPosition(), e4 = this._model.schema;
          if ("$graveyard" == t4.root.rootName)
            return null;
          let n3 = null;
          if (this.isCollapsed) {
            const o3 = t4.textNode ? t4.textNode : t4.nodeBefore, i3 = t4.textNode ? t4.textNode : t4.nodeAfter;
            if (this.isGravityOverridden || (n3 = Cd2(o3, e4)), n3 || (n3 = Cd2(i3, e4)), !this.isGravityOverridden && !n3) {
              let t5 = o3;
              for (; t5 && !n3; )
                t5 = t5.previousSibling, n3 = Cd2(t5, e4);
            }
            if (!n3) {
              let t5 = i3;
              for (; t5 && !n3; )
                t5 = t5.nextSibling, n3 = Cd2(t5, e4);
            }
            n3 || (n3 = this.getStoredAttributes());
          } else {
            const t5 = this.getFirstRange();
            for (const o3 of t5) {
              if (o3.item.is("element") && e4.isObject(o3.item)) {
                n3 = Cd2(o3.item, e4);
                break;
              }
              if ("text" == o3.type) {
                n3 = o3.item.getAttributes();
                break;
              }
            }
          }
          return n3;
        }
        _fixGraveyardSelection(t4) {
          const e4 = this._model.schema.getNearestSelectionRange(t4);
          e4 && this._pushRange(e4);
        }
      }
      function Cd2(t4, e4) {
        if (!t4)
          return null;
        if (t4 instanceof Ol || t4 instanceof zl)
          return t4.getAttributes();
        if (!e4.isInline(t4))
          return null;
        if (!e4.isObject(t4))
          return [];
        const n3 = [];
        for (const [o3, i3] of t4.getAttributes())
          e4.checkAttribute("$text", o3) && false !== e4.getAttributeProperties(o3).copyFromObject && n3.push([o3, i3]);
        return n3;
      }
      class _d {
        constructor(t4) {
          this._dispatchers = t4;
        }
        add(t4) {
          for (const e4 of this._dispatchers)
            t4(e4);
          return this;
        }
      }
      class vd2 extends _d {
        elementToElement(t4) {
          return this.add(function(t5) {
            const e4 = Ed2(t5.model), n3 = Dd2(t5.view, "container");
            e4.attributes.length && (e4.children = true);
            return (o3) => {
              o3.on(`insert:${e4.name}`, function(t6, e5 = zd2) {
                return (n4, o4, i3) => {
                  if (!e5(o4.item, i3.consumable, { preflight: true }))
                    return;
                  const r3 = t6(o4.item, i3, o4);
                  if (!r3)
                    return;
                  e5(o4.item, i3.consumable);
                  const s3 = i3.mapper.toViewPosition(o4.range.start);
                  i3.mapper.bindElements(o4.item, r3), i3.writer.insert(s3, r3), i3.convertAttributes(o4.item), Nd2(r3, o4.item.getChildren(), i3, { reconversion: o4.reconversion });
                };
              }(n3, Bd2(e4)), { priority: t5.converterPriority || "normal" }), (e4.children || e4.attributes.length) && o3.on("reduceChanges", Md2(e4), { priority: "low" });
            };
          }(t4));
        }
        elementToStructure(t4) {
          return this.add(function(t5) {
            const e4 = Ed2(t5.model), n3 = Dd2(t5.view, "container");
            return e4.children = true, (o3) => {
              if (o3._conversionApi.schema.checkChild(e4.name, "$text"))
                throw new A2("conversion-element-to-structure-disallowed-text", o3, { elementName: e4.name });
              var i3, r3;
              o3.on(`insert:${e4.name}`, (i3 = n3, r3 = Bd2(e4), (t6, e5, n4) => {
                if (!r3(e5.item, n4.consumable, { preflight: true }))
                  return;
                const o4 = /* @__PURE__ */ new Map();
                n4.writer._registerSlotFactory(function(t7, e6, n5) {
                  return (o5, i4) => {
                    const r4 = o5.createContainerElement("$slot");
                    let s4 = null;
                    if ("children" === i4)
                      s4 = Array.from(t7.getChildren());
                    else {
                      if ("function" != typeof i4)
                        throw new A2("conversion-slot-mode-unknown", n5.dispatcher, { modeOrFilter: i4 });
                      s4 = Array.from(t7.getChildren()).filter((t8) => i4(t8));
                    }
                    return e6.set(r4, s4), r4;
                  };
                }(e5.item, o4, n4));
                const s3 = i3(e5.item, n4, e5);
                if (n4.writer._clearSlotFactory(), !s3)
                  return;
                !function(t7, e6, n5) {
                  const o5 = Array.from(e6.values()).flat(), i4 = new Set(o5);
                  if (i4.size != o5.length)
                    throw new A2("conversion-slot-filter-overlap", n5.dispatcher, { element: t7 });
                  if (i4.size != t7.childCount)
                    throw new A2("conversion-slot-filter-incomplete", n5.dispatcher, { element: t7 });
                }(e5.item, o4, n4), r3(e5.item, n4.consumable);
                const a3 = n4.mapper.toViewPosition(e5.range.start);
                n4.mapper.bindElements(e5.item, s3), n4.writer.insert(a3, s3), n4.convertAttributes(e5.item), function(t7, e6, n5, o5) {
                  n5.mapper.on("modelToViewPosition", s4, { priority: "highest" });
                  let i4 = null, r4 = null;
                  for ([i4, r4] of e6)
                    Nd2(t7, r4, n5, o5), n5.writer.move(n5.writer.createRangeIn(i4), n5.writer.createPositionBefore(i4)), n5.writer.remove(i4);
                  function s4(t8, e7) {
                    const n6 = e7.modelPosition.nodeAfter, o6 = r4.indexOf(n6);
                    o6 < 0 || (e7.viewPosition = e7.mapper.findPositionIn(i4, o6));
                  }
                  n5.mapper.off("modelToViewPosition", s4);
                }(s3, o4, n4, { reconversion: e5.reconversion });
              }), { priority: t5.converterPriority || "normal" }), o3.on("reduceChanges", Md2(e4), { priority: "low" });
            };
          }(t4));
        }
        attributeToElement(t4) {
          return this.add(function(t5) {
            t5 = Tl(t5);
            let e4 = t5.model;
            "string" == typeof e4 && (e4 = { key: e4 });
            let n3 = `attribute:${e4.key}`;
            e4.name && (n3 += ":" + e4.name);
            if (e4.values)
              for (const n4 of e4.values)
                t5.view[n4] = Dd2(t5.view[n4], "attribute");
            else
              t5.view = Dd2(t5.view, "attribute");
            const o3 = Sd2(t5);
            return (e5) => {
              e5.on(n3, function(t6) {
                return (e6, n4, o4) => {
                  if (!o4.consumable.test(n4.item, e6.name))
                    return;
                  const i3 = t6(n4.attributeOldValue, o4, n4), r3 = t6(n4.attributeNewValue, o4, n4);
                  if (!i3 && !r3)
                    return;
                  o4.consumable.consume(n4.item, e6.name);
                  const s3 = o4.writer, a3 = s3.document.selection;
                  if (n4.item instanceof cd2 || n4.item instanceof wd2)
                    s3.wrap(a3.getFirstRange(), r3);
                  else {
                    let t7 = o4.mapper.toViewRange(n4.range);
                    null !== n4.attributeOldValue && i3 && (t7 = s3.unwrap(t7, i3)), null !== n4.attributeNewValue && r3 && s3.wrap(t7, r3);
                  }
                };
              }(o3), { priority: t5.converterPriority || "normal" });
            };
          }(t4));
        }
        attributeToAttribute(t4) {
          return this.add(function(t5) {
            t5 = Tl(t5);
            let e4 = t5.model;
            "string" == typeof e4 && (e4 = { key: e4 });
            let n3 = `attribute:${e4.key}`;
            e4.name && (n3 += ":" + e4.name);
            if (e4.values)
              for (const n4 of e4.values)
                t5.view[n4] = Id2(t5.view[n4]);
            else
              t5.view = Id2(t5.view);
            const o3 = Sd2(t5);
            return (e5) => {
              var i3;
              e5.on(n3, (i3 = o3, (t6, e6, n4) => {
                if (!n4.consumable.test(e6.item, t6.name))
                  return;
                const o4 = i3(e6.attributeOldValue, n4, e6), r3 = i3(e6.attributeNewValue, n4, e6);
                if (!o4 && !r3)
                  return;
                n4.consumable.consume(e6.item, t6.name);
                const s3 = n4.mapper.toViewElement(e6.item), a3 = n4.writer;
                if (!s3)
                  throw new A2("conversion-attribute-to-attribute-on-text", n4.dispatcher, e6);
                if (null !== e6.attributeOldValue && o4)
                  if ("class" == o4.key) {
                    const t7 = _i(o4.value);
                    for (const e7 of t7)
                      a3.removeClass(e7, s3);
                  } else if ("style" == o4.key) {
                    const t7 = Object.keys(o4.value);
                    for (const e7 of t7)
                      a3.removeStyle(e7, s3);
                  } else
                    a3.removeAttribute(o4.key, s3);
                if (null !== e6.attributeNewValue && r3)
                  if ("class" == r3.key) {
                    const t7 = _i(r3.value);
                    for (const e7 of t7)
                      a3.addClass(e7, s3);
                  } else if ("style" == r3.key) {
                    const t7 = Object.keys(r3.value);
                    for (const e7 of t7)
                      a3.setStyle(e7, r3.value[e7], s3);
                  } else
                    a3.setAttribute(r3.key, r3.value, s3);
              }), { priority: t5.converterPriority || "normal" });
            };
          }(t4));
        }
        markerToElement(t4) {
          return this.add(function(t5) {
            const e4 = Dd2(t5.view, "ui");
            return (n3) => {
              var o3;
              n3.on(`addMarker:${t5.model}`, (o3 = e4, (t6, e5, n4) => {
                e5.isOpening = true;
                const i3 = o3(e5, n4);
                e5.isOpening = false;
                const r3 = o3(e5, n4);
                if (!i3 || !r3)
                  return;
                const s3 = e5.markerRange;
                if (s3.isCollapsed && !n4.consumable.consume(s3, t6.name))
                  return;
                for (const e6 of s3)
                  if (!n4.consumable.consume(e6.item, t6.name))
                    return;
                const a3 = n4.mapper, c3 = n4.writer;
                c3.insert(a3.toViewPosition(s3.start), i3), n4.mapper.bindElementToMarker(i3, e5.markerName), s3.isCollapsed || (c3.insert(a3.toViewPosition(s3.end), r3), n4.mapper.bindElementToMarker(r3, e5.markerName)), t6.stop();
              }), { priority: t5.converterPriority || "normal" }), n3.on(`removeMarker:${t5.model}`, (t6, e5, n4) => {
                const o4 = n4.mapper.markerNameToElements(e5.markerName);
                if (o4) {
                  for (const t7 of o4)
                    n4.mapper.unbindElementFromMarkerName(t7, e5.markerName), n4.writer.clear(n4.writer.createRangeOn(t7), t7);
                  n4.writer.clearClonedElementsGroup(e5.markerName), t6.stop();
                }
              }, { priority: t5.converterPriority || "normal" });
            };
          }(t4));
        }
        markerToHighlight(t4) {
          return this.add(function(t5) {
            return (e4) => {
              var n3;
              e4.on(`addMarker:${t5.model}`, (n3 = t5.view, (t6, e5, o3) => {
                if (!e5.item)
                  return;
                if (!(e5.item instanceof cd2 || e5.item instanceof wd2 || e5.item.is("$textProxy")))
                  return;
                const i3 = Td2(n3, e5, o3);
                if (!i3)
                  return;
                if (!o3.consumable.consume(e5.item, t6.name))
                  return;
                const r3 = o3.writer, s3 = yd2(r3, i3), a3 = r3.document.selection;
                if (e5.item instanceof cd2 || e5.item instanceof wd2)
                  r3.wrap(a3.getFirstRange(), s3);
                else {
                  const t7 = o3.mapper.toViewRange(e5.range), n4 = r3.wrap(t7, s3);
                  for (const t8 of n4.getItems())
                    if (t8.is("attributeElement") && t8.isSimilar(s3)) {
                      o3.mapper.bindElementToMarker(t8, e5.markerName);
                      break;
                    }
                }
              }), { priority: t5.converterPriority || "normal" }), e4.on(`addMarker:${t5.model}`, function(t6) {
                return (e5, n4, o3) => {
                  if (!n4.item)
                    return;
                  if (!(n4.item instanceof Ll))
                    return;
                  const i3 = Td2(t6, n4, o3);
                  if (!i3)
                    return;
                  if (!o3.consumable.test(n4.item, e5.name))
                    return;
                  const r3 = o3.mapper.toViewElement(n4.item);
                  if (r3 && r3.getCustomProperty("addHighlight")) {
                    o3.consumable.consume(n4.item, e5.name);
                    for (const t7 of Wl._createIn(n4.item))
                      o3.consumable.consume(t7.item, e5.name);
                    r3.getCustomProperty("addHighlight")(r3, i3, o3.writer), o3.mapper.bindElementToMarker(r3, n4.markerName);
                  }
                };
              }(t5.view), { priority: t5.converterPriority || "normal" }), e4.on(`removeMarker:${t5.model}`, function(t6) {
                return (e5, n4, o3) => {
                  if (n4.markerRange.isCollapsed)
                    return;
                  const i3 = Td2(t6, n4, o3);
                  if (!i3)
                    return;
                  const r3 = yd2(o3.writer, i3), s3 = o3.mapper.markerNameToElements(n4.markerName);
                  if (s3) {
                    for (const t7 of s3)
                      if (o3.mapper.unbindElementFromMarkerName(t7, n4.markerName), t7.is("attributeElement"))
                        o3.writer.unwrap(o3.writer.createRangeOn(t7), r3);
                      else {
                        t7.getCustomProperty("removeHighlight")(t7, i3.id, o3.writer);
                      }
                    o3.writer.clearClonedElementsGroup(n4.markerName), e5.stop();
                  }
                };
              }(t5.view), { priority: t5.converterPriority || "normal" });
            };
          }(t4));
        }
        markerToData(t4) {
          return this.add(function(t5) {
            t5 = Tl(t5);
            const e4 = t5.model;
            let n3 = t5.view;
            n3 || (n3 = (n4) => ({ group: e4, name: n4.substr(t5.model.length + 1) }));
            return (o3) => {
              var i3;
              o3.on(`addMarker:${e4}`, (i3 = n3, (t6, e5, n4) => {
                const o4 = i3(e5.markerName, n4);
                if (!o4)
                  return;
                const r3 = e5.markerRange;
                n4.consumable.consume(r3, t6.name) && (xd2(r3, false, n4, e5, o4), xd2(r3, true, n4, e5, o4), t6.stop());
              }), { priority: t5.converterPriority || "normal" }), o3.on(`removeMarker:${e4}`, function(t6) {
                return (e5, n4, o4) => {
                  const i4 = t6(n4.markerName, o4);
                  if (!i4)
                    return;
                  const r3 = o4.mapper.markerNameToElements(n4.markerName);
                  if (r3) {
                    for (const t7 of r3)
                      o4.mapper.unbindElementFromMarkerName(t7, n4.markerName), t7.is("containerElement") ? (s3(`data-${i4.group}-start-before`, t7), s3(`data-${i4.group}-start-after`, t7), s3(`data-${i4.group}-end-before`, t7), s3(`data-${i4.group}-end-after`, t7)) : o4.writer.clear(o4.writer.createRangeOn(t7), t7);
                    o4.writer.clearClonedElementsGroup(n4.markerName), e5.stop();
                  }
                  function s3(t7, e6) {
                    if (e6.hasAttribute(t7)) {
                      const n5 = new Set(e6.getAttribute(t7).split(","));
                      n5.delete(i4.name), 0 == n5.size ? o4.writer.removeAttribute(t7, e6) : o4.writer.setAttribute(t7, Array.from(n5).join(","), e6);
                    }
                  }
                };
              }(n3), { priority: t5.converterPriority || "normal" });
            };
          }(t4));
        }
      }
      function yd2(t4, e4) {
        const n3 = t4.createAttributeElement("span", e4.attributes);
        return e4.classes && n3._addClass(e4.classes), "number" == typeof e4.priority && (n3._priority = e4.priority), n3._id = e4.id, n3;
      }
      function xd2(t4, e4, n3, o3, i3) {
        const r3 = e4 ? t4.start : t4.end, s3 = r3.nodeAfter && r3.nodeAfter.is("element") ? r3.nodeAfter : null, a3 = r3.nodeBefore && r3.nodeBefore.is("element") ? r3.nodeBefore : null;
        if (s3 || a3) {
          let t5, r4;
          e4 && s3 || !e4 && !a3 ? (t5 = s3, r4 = true) : (t5 = a3, r4 = false);
          const c3 = n3.mapper.toViewElement(t5);
          if (c3)
            return void function(t6, e5, n4, o4, i4, r5) {
              const s4 = `data-${r5.group}-${e5 ? "start" : "end"}-${n4 ? "before" : "after"}`, a4 = t6.hasAttribute(s4) ? t6.getAttribute(s4).split(",") : [];
              a4.unshift(r5.name), o4.writer.setAttribute(s4, a4.join(","), t6), o4.mapper.bindElementToMarker(t6, i4.markerName);
            }(c3, e4, r4, n3, o3, i3);
        }
        !function(t5, e5, n4, o4, i4) {
          const r4 = `${i4.group}-${e5 ? "start" : "end"}`, s4 = i4.name ? { name: i4.name } : null, a4 = n4.writer.createUIElement(r4, s4);
          n4.writer.insert(t5, a4), n4.mapper.bindElementToMarker(a4, o4.markerName);
        }(n3.mapper.toViewPosition(r3), e4, n3, o3, i3);
      }
      function Ed2(t4) {
        return "string" == typeof t4 && (t4 = { name: t4 }), t4.attributes ? Array.isArray(t4.attributes) || (t4.attributes = [t4.attributes]) : t4.attributes = [], t4.children = !!t4.children, t4;
      }
      function Dd2(t4, e4) {
        return "function" == typeof t4 ? t4 : (n3, o3) => function(t5, e5, n4) {
          "string" == typeof t5 && (t5 = { name: t5 });
          let o4;
          const i3 = e5.writer, r3 = Object.assign({}, t5.attributes);
          if ("container" == n4)
            o4 = i3.createContainerElement(t5.name, r3);
          else if ("attribute" == n4) {
            const e6 = { priority: t5.priority || Ra2.DEFAULT_PRIORITY };
            o4 = i3.createAttributeElement(t5.name, r3, e6);
          } else
            o4 = i3.createUIElement(t5.name, r3);
          if (t5.styles) {
            const e6 = Object.keys(t5.styles);
            for (const n5 of e6)
              i3.setStyle(n5, t5.styles[n5], o4);
          }
          if (t5.classes) {
            const e6 = t5.classes;
            if ("string" == typeof e6)
              i3.addClass(e6, o4);
            else
              for (const t6 of e6)
                i3.addClass(t6, o4);
          }
          return o4;
        }(t4, o3, e4);
      }
      function Sd2(t4) {
        return t4.model.values ? (e4, n3, o3) => {
          const i3 = t4.view[e4];
          return i3 ? i3(e4, n3, o3) : null;
        } : t4.view;
      }
      function Id2(t4) {
        return "string" == typeof t4 ? (e4) => ({ key: t4, value: e4 }) : "object" == typeof t4 ? t4.value ? () => t4 : (e4) => ({ key: t4.key, value: e4 }) : t4;
      }
      function Td2(t4, e4, n3) {
        const o3 = "function" == typeof t4 ? t4(e4, n3) : t4;
        return o3 ? (o3.priority || (o3.priority = 10), o3.id || (o3.id = e4.markerName), o3) : null;
      }
      function Md2(t4) {
        const e4 = function(t5) {
          return (e5, n3) => {
            if (!e5.is("element", t5.name))
              return false;
            if ("attribute" == n3.type) {
              if (t5.attributes.includes(n3.attributeKey))
                return true;
            } else if (t5.children)
              return true;
            return false;
          };
        }(t4);
        return (t5, n3) => {
          const o3 = [];
          n3.reconvertedElements || (n3.reconvertedElements = /* @__PURE__ */ new Set());
          for (const t6 of n3.changes) {
            const i3 = "attribute" == t6.type ? t6.range.start.nodeAfter : t6.position.parent;
            if (i3 && e4(i3, t6)) {
              if (!n3.reconvertedElements.has(i3)) {
                n3.reconvertedElements.add(i3);
                const t7 = Fl._createBefore(i3);
                let e5 = o3.length;
                for (let n4 = o3.length - 1; n4 >= 0; n4--) {
                  const i4 = o3[n4], r3 = ("attribute" == i4.type ? i4.range.start : i4.position).compareWith(t7);
                  if ("before" == r3 || "remove" == i4.type && "same" == r3)
                    break;
                  e5 = n4;
                }
                o3.splice(e5, 0, { type: "remove", name: i3.name, position: t7, length: 1 }, { type: "reinsert", name: i3.name, position: t7, length: 1 });
              }
            } else
              o3.push(t6);
          }
          n3.changes = o3;
        };
      }
      function Bd2(t4) {
        return (e4, n3, o3 = {}) => {
          const i3 = ["insert"];
          for (const n4 of t4.attributes)
            e4.hasAttribute(n4) && i3.push(`attribute:${n4}`);
          return !!i3.every((t5) => n3.test(e4, t5)) && (o3.preflight || i3.forEach((t5) => n3.consume(e4, t5)), true);
        };
      }
      function Nd2(t4, e4, n3, o3) {
        for (const i3 of e4)
          Pd2(t4.root, i3, n3, o3) || n3.convertItem(i3);
      }
      function Pd2(t4, e4, n3, o3) {
        const { writer: i3, mapper: r3 } = n3;
        if (!o3.reconversion)
          return false;
        const s3 = r3.toViewElement(e4);
        return !(!s3 || s3.root == t4) && (!!n3.canReuseView(s3) && (i3.move(i3.createRangeOn(s3), r3.toViewPosition(Fl._createBefore(e4))), true));
      }
      function zd2(t4, e4, { preflight: n3 } = {}) {
        return n3 ? e4.test(t4, "insert") : e4.consume(t4, "insert");
      }
      function Od2(t4) {
        const { schema: e4, document: n3 } = t4.model;
        for (const o3 of n3.getRoots())
          if (o3.isEmpty && !e4.checkChild(o3, "$text") && e4.checkChild(o3, "paragraph"))
            return t4.insertElement("paragraph", o3), true;
        return false;
      }
      function Ld2(t4, e4, n3) {
        const o3 = n3.createContext(t4);
        return !!n3.checkChild(o3, "paragraph") && !!n3.checkChild(o3.push("paragraph"), e4);
      }
      function jd2(t4, e4) {
        const n3 = e4.createElement("paragraph");
        return e4.insert(n3, t4), e4.createPositionAt(n3, 0);
      }
      var Rd2 = Object.defineProperty, Fd2 = Object.defineProperties, Vd2 = Object.getOwnPropertyDescriptors, Hd2 = Object.getOwnPropertySymbols, Ud2 = Object.prototype.hasOwnProperty, qd2 = Object.prototype.propertyIsEnumerable, Gd2 = (t4, e4, n3) => e4 in t4 ? Rd2(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3;
      class Wd2 extends _d {
        elementToElement(t4) {
          return this.add(Kd2(t4));
        }
        elementToAttribute(t4) {
          return this.add(function(t5) {
            t5 = Tl(t5), Zd2(t5);
            const e4 = Qd2(t5, false), n3 = Yd2(t5.view), o3 = n3 ? `element:${n3}` : "element";
            return (n4) => {
              n4.on(o3, e4, { priority: t5.converterPriority || "low" });
            };
          }(t4));
        }
        attributeToAttribute(t4) {
          return this.add(function(t5) {
            t5 = Tl(t5);
            let e4 = null;
            ("string" == typeof t5.view || t5.view.key) && (e4 = function(t6) {
              "string" == typeof t6.view && (t6.view = { key: t6.view });
              const e5 = t6.view.key;
              let n4;
              if ("class" == e5 || "style" == e5) {
                n4 = { ["class" == e5 ? "classes" : "styles"]: t6.view.value };
              } else {
                n4 = { attributes: { [e5]: void 0 === t6.view.value ? /[\s\S]*/ : t6.view.value } };
              }
              t6.view.name && (n4.name = t6.view.name);
              return t6.view = n4, e5;
            }(t5));
            Zd2(t5, e4);
            const n3 = Qd2(t5, true);
            return (e5) => {
              e5.on("element", n3, { priority: t5.converterPriority || "low" });
            };
          }(t4));
        }
        elementToMarker(t4) {
          return this.add(function(t5) {
            const e4 = function(t6) {
              return (e5, n4) => {
                const o4 = "string" == typeof t6 ? t6 : t6(e5, n4);
                return n4.writer.createElement("$marker", { "data-name": o4 });
              };
            }(t5.model);
            return Kd2((n3 = ((t6, e5) => {
              for (var n4 in e5 || (e5 = {}))
                Ud2.call(e5, n4) && Gd2(t6, n4, e5[n4]);
              if (Hd2)
                for (var n4 of Hd2(e5))
                  qd2.call(e5, n4) && Gd2(t6, n4, e5[n4]);
              return t6;
            })({}, t5), o3 = { model: e4 }, Fd2(n3, Vd2(o3))));
            var n3, o3;
          }(t4));
        }
        dataToMarker(t4) {
          return this.add(function(t5) {
            t5 = Tl(t5), t5.model || (t5.model = (e5) => e5 ? t5.view + ":" + e5 : t5.view);
            const e4 = { view: t5.view, model: t5.model }, n3 = $d2(Jd2(e4, "start")), o3 = $d2(Jd2(e4, "end"));
            return (i3) => {
              i3.on(`element:${t5.view}-start`, n3, { priority: t5.converterPriority || "normal" }), i3.on(`element:${t5.view}-end`, o3, { priority: t5.converterPriority || "normal" });
              const r3 = k2.low, s3 = k2.highest, a3 = k2.get(t5.converterPriority) / s3;
              i3.on("element", function(t6) {
                return (e5, n4, o4) => {
                  const i4 = `data-${t6.view}`;
                  function r4(e6, i5) {
                    for (const r5 of i5) {
                      const i6 = t6.model(r5, o4), s4 = o4.writer.createElement("$marker", { "data-name": i6 });
                      o4.writer.insert(s4, e6), n4.modelCursor.isEqual(e6) ? n4.modelCursor = n4.modelCursor.getShiftedBy(1) : n4.modelCursor = n4.modelCursor._getTransformedByInsertion(e6, 1), n4.modelRange = n4.modelRange._getTransformedByInsertion(e6, 1)[0];
                    }
                  }
                  (o4.consumable.test(n4.viewItem, { attributes: i4 + "-end-after" }) || o4.consumable.test(n4.viewItem, { attributes: i4 + "-start-after" }) || o4.consumable.test(n4.viewItem, { attributes: i4 + "-end-before" }) || o4.consumable.test(n4.viewItem, { attributes: i4 + "-start-before" })) && (n4.modelRange || Object.assign(n4, o4.convertChildren(n4.viewItem, n4.modelCursor)), o4.consumable.consume(n4.viewItem, { attributes: i4 + "-end-after" }) && r4(n4.modelRange.end, n4.viewItem.getAttribute(i4 + "-end-after").split(",")), o4.consumable.consume(n4.viewItem, { attributes: i4 + "-start-after" }) && r4(n4.modelRange.end, n4.viewItem.getAttribute(i4 + "-start-after").split(",")), o4.consumable.consume(n4.viewItem, { attributes: i4 + "-end-before" }) && r4(n4.modelRange.start, n4.viewItem.getAttribute(i4 + "-end-before").split(",")), o4.consumable.consume(n4.viewItem, { attributes: i4 + "-start-before" }) && r4(n4.modelRange.start, n4.viewItem.getAttribute(i4 + "-start-before").split(",")));
                };
              }(e4), { priority: r3 + a3 });
            };
          }(t4));
        }
      }
      function Kd2(t4) {
        const e4 = $d2(t4 = Tl(t4)), n3 = Yd2(t4.view), o3 = n3 ? `element:${n3}` : "element";
        return (n4) => {
          n4.on(o3, e4, { priority: t4.converterPriority || "normal" });
        };
      }
      function Yd2(t4) {
        return "string" == typeof t4 ? t4 : "object" == typeof t4 && "string" == typeof t4.name ? t4.name : null;
      }
      function $d2(t4) {
        const e4 = new bs(t4.view);
        return (n3, o3, i3) => {
          const r3 = e4.match(o3.viewItem);
          if (!r3)
            return;
          const s3 = r3.match;
          if (s3.name = true, !i3.consumable.test(o3.viewItem, s3))
            return;
          const a3 = function(t5, e5, n4) {
            return t5 instanceof Function ? t5(e5, n4) : n4.writer.createElement(t5);
          }(t4.model, o3.viewItem, i3);
          a3 && i3.safeInsert(a3, o3.modelCursor) && (i3.consumable.consume(o3.viewItem, s3), i3.convertChildren(o3.viewItem, a3), i3.updateConversionResult(a3, o3));
        };
      }
      function Zd2(t4, e4 = null) {
        const n3 = null === e4 || ((t5) => t5.getAttribute(e4)), o3 = "object" != typeof t4.model ? t4.model : t4.model.key, i3 = "object" != typeof t4.model || void 0 === t4.model.value ? n3 : t4.model.value;
        t4.model = { key: o3, value: i3 };
      }
      function Qd2(t4, e4) {
        const n3 = new bs(t4.view);
        return (o3, i3, r3) => {
          if (!i3.modelRange && e4)
            return;
          const s3 = n3.match(i3.viewItem);
          if (!s3)
            return;
          if (!function(t5, e5) {
            const n4 = "function" == typeof t5 ? t5(e5) : t5;
            if ("object" == typeof n4 && !Yd2(n4))
              return false;
            return !n4.classes && !n4.attributes && !n4.styles;
          }(t4.view, i3.viewItem) ? delete s3.match.name : s3.match.name = true, !r3.consumable.test(i3.viewItem, s3.match))
            return;
          const a3 = t4.model.key, c3 = "function" == typeof t4.model.value ? t4.model.value(i3.viewItem, r3) : t4.model.value;
          if (null === c3)
            return;
          i3.modelRange || Object.assign(i3, r3.convertChildren(i3.viewItem, i3.modelCursor));
          const l3 = function(t5, e5, n4, o4) {
            let i4 = false;
            for (const r4 of Array.from(t5.getItems({ shallow: n4 })))
              o4.schema.checkAttribute(r4, e5.key) && (i4 = true, r4.hasAttribute(e5.key) || o4.writer.setAttribute(e5.key, e5.value, r4));
            return i4;
          }(i3.modelRange, { key: a3, value: c3 }, e4, r3);
          l3 && (r3.consumable.test(i3.viewItem, { name: true }) && (s3.match.name = true), r3.consumable.consume(i3.viewItem, s3.match));
        };
      }
      function Jd2(t4, e4) {
        return { view: `${t4.view}-${e4}`, model: (e5, n3) => {
          const o3 = e5.getAttribute("name"), i3 = t4.model(o3, n3);
          return n3.writer.createElement("$marker", { "data-name": i3 });
        } };
      }
      function Xd2(t4) {
        t4.document.registerPostFixer((e4) => function(t5, e5) {
          const n3 = e5.document.selection, o3 = e5.schema, i3 = [];
          let r3 = false;
          for (const t6 of n3.getRanges()) {
            const e6 = th2(t6, o3);
            e6 && !e6.isEqual(t6) ? (i3.push(e6), r3 = true) : i3.push(t6);
          }
          r3 && t5.setSelection(function(t6) {
            const e6 = [...t6], n4 = /* @__PURE__ */ new Set();
            let o4 = 1;
            for (; o4 < e6.length; ) {
              const t7 = e6[o4], i4 = e6.slice(0, o4);
              for (const [r4, s3] of i4.entries())
                if (!n4.has(r4)) {
                  if (t7.isEqual(s3))
                    n4.add(r4);
                  else if (t7.isIntersecting(s3)) {
                    n4.add(r4), n4.add(o4);
                    const i5 = t7.getJoined(s3);
                    e6.push(i5);
                  }
                }
              o4++;
            }
            return e6.filter((t7, e7) => !n4.has(e7));
          }(i3), { backward: n3.isBackward });
          return false;
        }(e4, t4));
      }
      function th2(t4, e4) {
        return t4.isCollapsed ? function(t5, e5) {
          const n3 = t5.start, o3 = e5.getNearestSelectionRange(n3);
          if (!o3) {
            const t6 = n3.getAncestors().reverse().find((t7) => e5.isObject(t7));
            return t6 ? Wl._createOn(t6) : null;
          }
          if (!o3.isCollapsed)
            return o3;
          const i3 = o3.start;
          if (n3.isEqual(i3))
            return null;
          return new Wl(i3);
        }(t4, e4) : function(t5, e5) {
          const { start: n3, end: o3 } = t5, i3 = e5.checkChild(n3, "$text"), r3 = e5.checkChild(o3, "$text"), s3 = e5.getLimitElement(n3), a3 = e5.getLimitElement(o3);
          if (s3 === a3) {
            if (i3 && r3)
              return null;
            if (function(t6, e6, n4) {
              const o4 = t6.nodeAfter && !n4.isLimit(t6.nodeAfter) || n4.checkChild(t6, "$text"), i4 = e6.nodeBefore && !n4.isLimit(e6.nodeBefore) || n4.checkChild(e6, "$text");
              return o4 || i4;
            }(n3, o3, e5)) {
              const t6 = n3.nodeAfter && e5.isSelectable(n3.nodeAfter) ? null : e5.getNearestSelectionRange(n3, "forward"), i4 = o3.nodeBefore && e5.isSelectable(o3.nodeBefore) ? null : e5.getNearestSelectionRange(o3, "backward"), r4 = t6 ? t6.start : n3, s4 = i4 ? i4.end : o3;
              return new Wl(r4, s4);
            }
          }
          const c3 = s3 && !s3.is("rootElement"), l3 = a3 && !a3.is("rootElement");
          if (c3 || l3) {
            const t6 = n3.nodeAfter && o3.nodeBefore && n3.nodeAfter.parent === o3.nodeBefore.parent, i4 = c3 && (!t6 || !nh2(n3.nodeAfter, e5)), r4 = l3 && (!t6 || !nh2(o3.nodeBefore, e5));
            let d3 = n3, h3 = o3;
            return i4 && (d3 = Fl._createBefore(eh2(s3, e5))), r4 && (h3 = Fl._createAfter(eh2(a3, e5))), new Wl(d3, h3);
          }
          return null;
        }(t4, e4);
      }
      function eh2(t4, e4) {
        let n3 = t4, o3 = n3;
        for (; e4.isLimit(o3) && o3.parent; )
          n3 = o3, o3 = o3.parent;
        return n3;
      }
      function nh2(t4, e4) {
        return t4 && e4.isSelectable(t4);
      }
      class oh2 extends W2() {
        constructor(t4, e4) {
          super(), this.model = t4, this.view = new Ml(e4), this.mapper = new Kl(), this.downcastDispatcher = new rd2({ mapper: this.mapper, schema: t4.schema });
          const n3 = this.model.document, o3 = n3.selection, i3 = this.model.markers;
          var r3, s3, c3;
          this.listenTo(this.model, "_beforeChanges", () => {
            this.view._disableRendering(true);
          }, { priority: "highest" }), this.listenTo(this.model, "_afterChanges", () => {
            this.view._disableRendering(false);
          }, { priority: "lowest" }), this.listenTo(n3, "change", () => {
            this.view.change((t5) => {
              this.downcastDispatcher.convertChanges(n3.differ, i3, t5), this.downcastDispatcher.convertSelection(o3, i3, t5);
            });
          }, { priority: "low" }), this.listenTo(this.view.document, "selectionChange", function(t5, e5) {
            return (n4, o4) => {
              const i4 = o4.newSelection, r4 = [];
              for (const t6 of i4.getRanges())
                r4.push(e5.toModelRange(t6));
              const s4 = t5.createSelection(r4, { backward: i4.isBackward });
              s4.isEqual(t5.document.selection) || t5.change((t6) => {
                t6.setSelection(s4);
              });
            };
          }(this.model, this.mapper)), this.listenTo(this.view.document, "beforeinput", (r3 = this.mapper, s3 = this.model.schema, c3 = this.view, (t5, e5) => {
            if (!c3.document.isComposing || a2.isAndroid)
              for (let t6 = 0; t6 < e5.targetRanges.length; t6++) {
                const n4 = e5.targetRanges[t6], o4 = r3.toModelRange(n4), i4 = th2(o4, s3);
                i4 && !i4.isEqual(o4) && (e5.targetRanges[t6] = r3.toViewRange(i4));
              }
          }), { priority: "high" }), this.downcastDispatcher.on("insert:$text", (t5, e5, n4) => {
            if (!n4.consumable.consume(e5.item, t5.name))
              return;
            const o4 = n4.writer, i4 = n4.mapper.toViewPosition(e5.range.start), r4 = o4.createText(e5.item.data);
            o4.insert(i4, r4);
          }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (t5, e5, n4) => {
            n4.convertAttributes(e5.item), e5.reconversion || !e5.item.is("element") || e5.item.isEmpty || n4.convertChildren(e5.item);
          }, { priority: "lowest" }), this.downcastDispatcher.on("remove", (t5, e5, n4) => {
            const o4 = n4.mapper.toViewPosition(e5.position), i4 = e5.position.getShiftedBy(e5.length), r4 = n4.mapper.toViewPosition(i4, { isPhantom: true }), s4 = n4.writer.createRange(o4, r4), a3 = n4.writer.remove(s4.getTrimmed());
            for (const t6 of n4.writer.createRangeIn(a3).getItems())
              n4.mapper.unbindViewElement(t6, { defer: true });
          }, { priority: "low" }), this.downcastDispatcher.on("cleanSelection", (t5, e5, n4) => {
            const o4 = n4.writer, i4 = o4.document.selection;
            for (const t6 of i4.getRanges())
              t6.isCollapsed && t6.end.parent.isAttached() && n4.writer.mergeAttributes(t6.start);
            o4.setSelection(null);
          }), this.downcastDispatcher.on("selection", (t5, e5, n4) => {
            const o4 = e5.selection;
            if (o4.isCollapsed)
              return;
            if (!n4.consumable.consume(o4, "selection"))
              return;
            const i4 = [];
            for (const t6 of o4.getRanges())
              i4.push(n4.mapper.toViewRange(t6));
            n4.writer.setSelection(i4, { backward: o4.isBackward });
          }, { priority: "low" }), this.downcastDispatcher.on("selection", (t5, e5, n4) => {
            const o4 = e5.selection;
            if (!o4.isCollapsed)
              return;
            if (!n4.consumable.consume(o4, "selection"))
              return;
            const i4 = n4.writer, r4 = o4.getFirstPosition(), s4 = n4.mapper.toViewPosition(r4), a3 = i4.breakAttributes(s4);
            i4.setSelection(a3);
          }, { priority: "low" }), this.view.document.roots.bindTo(this.model.document.roots).using((t5) => {
            if ("$graveyard" == t5.rootName)
              return null;
            const e5 = new ya2(this.view.document, t5.name);
            return e5.rootName = t5.rootName, this.mapper.bindElements(t5, e5), e5;
          });
        }
        destroy() {
          this.view.destroy(), this.stopListening();
        }
        reconvertMarker(t4) {
          const e4 = "string" == typeof t4 ? t4 : t4.name, n3 = this.model.markers.get(e4);
          if (!n3)
            throw new A2("editingcontroller-reconvertmarker-marker-not-exist", this, { markerName: e4 });
          this.model.change(() => {
            this.model.markers._refresh(n3);
          });
        }
        reconvertItem(t4) {
          this.model.change(() => {
            this.model.document.differ._refreshItem(t4);
          });
        }
      }
      class ih2 {
        constructor() {
          this._consumables = /* @__PURE__ */ new Map();
        }
        add(t4, e4) {
          let n3;
          t4.is("$text") || t4.is("documentFragment") ? this._consumables.set(t4, true) : (this._consumables.has(t4) ? n3 = this._consumables.get(t4) : (n3 = new sh2(t4), this._consumables.set(t4, n3)), n3.add(e4));
        }
        test(t4, e4) {
          const n3 = this._consumables.get(t4);
          return void 0 === n3 ? null : t4.is("$text") || t4.is("documentFragment") ? n3 : n3.test(e4);
        }
        consume(t4, e4) {
          return !!this.test(t4, e4) && (t4.is("$text") || t4.is("documentFragment") ? this._consumables.set(t4, false) : this._consumables.get(t4).consume(e4), true);
        }
        revert(t4, e4) {
          const n3 = this._consumables.get(t4);
          void 0 !== n3 && (t4.is("$text") || t4.is("documentFragment") ? this._consumables.set(t4, true) : n3.revert(e4));
        }
        static consumablesFromElement(t4) {
          const e4 = { element: t4, name: true, attributes: [], classes: [], styles: [] }, n3 = t4.getAttributeKeys();
          for (const t5 of n3)
            "style" != t5 && "class" != t5 && e4.attributes.push(t5);
          const o3 = t4.getClassNames();
          for (const t5 of o3)
            e4.classes.push(t5);
          const i3 = t4.getStyleNames();
          for (const t5 of i3)
            e4.styles.push(t5);
          return e4;
        }
        static createFrom(t4, e4) {
          if (e4 || (e4 = new ih2()), t4.is("$text"))
            return e4.add(t4), e4;
          t4.is("element") && e4.add(t4, ih2.consumablesFromElement(t4)), t4.is("documentFragment") && e4.add(t4);
          for (const n3 of t4.getChildren())
            e4 = ih2.createFrom(n3, e4);
          return e4;
        }
      }
      const rh2 = ["attributes", "classes", "styles"];
      class sh2 {
        constructor(t4) {
          this.element = t4, this._canConsumeName = null, this._consumables = { attributes: /* @__PURE__ */ new Map(), styles: /* @__PURE__ */ new Map(), classes: /* @__PURE__ */ new Map() };
        }
        add(t4) {
          t4.name && (this._canConsumeName = true);
          for (const e4 of rh2)
            e4 in t4 && this._add(e4, t4[e4]);
        }
        test(t4) {
          if (t4.name && !this._canConsumeName)
            return this._canConsumeName;
          for (const e4 of rh2)
            if (e4 in t4) {
              const n3 = this._test(e4, t4[e4]);
              if (true !== n3)
                return n3;
            }
          return true;
        }
        consume(t4) {
          t4.name && (this._canConsumeName = false);
          for (const e4 of rh2)
            e4 in t4 && this._consume(e4, t4[e4]);
        }
        revert(t4) {
          t4.name && (this._canConsumeName = true);
          for (const e4 of rh2)
            e4 in t4 && this._revert(e4, t4[e4]);
        }
        _add(t4, e4) {
          const n3 = mt2(e4) ? e4 : [e4], o3 = this._consumables[t4];
          for (const e5 of n3) {
            if ("attributes" === t4 && ("class" === e5 || "style" === e5))
              throw new A2("viewconsumable-invalid-attribute", this);
            if (o3.set(e5, true), "styles" === t4)
              for (const t5 of this.element.document.stylesProcessor.getRelatedStyles(e5))
                o3.set(t5, true);
          }
        }
        _test(t4, e4) {
          const n3 = mt2(e4) ? e4 : [e4], o3 = this._consumables[t4];
          for (const e5 of n3)
            if ("attributes" !== t4 || "class" !== e5 && "style" !== e5) {
              const t5 = o3.get(e5);
              if (void 0 === t5)
                return null;
              if (!t5)
                return false;
            } else {
              const t5 = "class" == e5 ? "classes" : "styles", n4 = this._test(t5, [...this._consumables[t5].keys()]);
              if (true !== n4)
                return n4;
            }
          return true;
        }
        _consume(t4, e4) {
          const n3 = mt2(e4) ? e4 : [e4], o3 = this._consumables[t4];
          for (const e5 of n3)
            if ("attributes" !== t4 || "class" !== e5 && "style" !== e5) {
              if (o3.set(e5, false), "styles" == t4)
                for (const t5 of this.element.document.stylesProcessor.getRelatedStyles(e5))
                  o3.set(t5, false);
            } else {
              const t5 = "class" == e5 ? "classes" : "styles";
              this._consume(t5, [...this._consumables[t5].keys()]);
            }
        }
        _revert(t4, e4) {
          const n3 = mt2(e4) ? e4 : [e4], o3 = this._consumables[t4];
          for (const e5 of n3)
            if ("attributes" !== t4 || "class" !== e5 && "style" !== e5) {
              false === o3.get(e5) && o3.set(e5, true);
            } else {
              const t5 = "class" == e5 ? "classes" : "styles";
              this._revert(t5, [...this._consumables[t5].keys()]);
            }
        }
      }
      class ah2 extends W2() {
        constructor() {
          super(), this._sourceDefinitions = {}, this._attributeProperties = {}, this.decorate("checkChild"), this.decorate("checkAttribute"), this.on("checkAttribute", (t4, e4) => {
            e4[0] = new ch2(e4[0]);
          }, { priority: "highest" }), this.on("checkChild", (t4, e4) => {
            e4[0] = new ch2(e4[0]), e4[1] = this.getDefinition(e4[1]);
          }, { priority: "highest" });
        }
        register(t4, e4) {
          if (this._sourceDefinitions[t4])
            throw new A2("schema-cannot-register-item-twice", this, { itemName: t4 });
          this._sourceDefinitions[t4] = [Object.assign({}, e4)], this._clearCache();
        }
        extend(t4, e4) {
          if (!this._sourceDefinitions[t4])
            throw new A2("schema-cannot-extend-missing-item", this, { itemName: t4 });
          this._sourceDefinitions[t4].push(Object.assign({}, e4)), this._clearCache();
        }
        getDefinitions() {
          return this._compiledDefinitions || this._compile(), this._compiledDefinitions;
        }
        getDefinition(t4) {
          let e4;
          return e4 = "string" == typeof t4 ? t4 : "is" in t4 && (t4.is("$text") || t4.is("$textProxy")) ? "$text" : t4.name, this.getDefinitions()[e4];
        }
        isRegistered(t4) {
          return !!this.getDefinition(t4);
        }
        isBlock(t4) {
          const e4 = this.getDefinition(t4);
          return !(!e4 || !e4.isBlock);
        }
        isLimit(t4) {
          const e4 = this.getDefinition(t4);
          return !!e4 && !(!e4.isLimit && !e4.isObject);
        }
        isObject(t4) {
          const e4 = this.getDefinition(t4);
          return !!e4 && !!(e4.isObject || e4.isLimit && e4.isSelectable && e4.isContent);
        }
        isInline(t4) {
          const e4 = this.getDefinition(t4);
          return !(!e4 || !e4.isInline);
        }
        isSelectable(t4) {
          const e4 = this.getDefinition(t4);
          return !!e4 && !(!e4.isSelectable && !e4.isObject);
        }
        isContent(t4) {
          const e4 = this.getDefinition(t4);
          return !!e4 && !(!e4.isContent && !e4.isObject);
        }
        checkChild(t4, e4) {
          return !!e4 && this._checkContextMatch(e4, t4);
        }
        checkAttribute(t4, e4) {
          const n3 = this.getDefinition(t4.last);
          return !!n3 && n3.allowAttributes.includes(e4);
        }
        checkMerge(t4, e4) {
          if (t4 instanceof Fl) {
            const e5 = t4.nodeBefore, n3 = t4.nodeAfter;
            if (!(e5 instanceof Ll))
              throw new A2("schema-check-merge-no-element-before", this);
            if (!(n3 instanceof Ll))
              throw new A2("schema-check-merge-no-element-after", this);
            return this.checkMerge(e5, n3);
          }
          for (const n3 of e4.getChildren())
            if (!this.checkChild(t4, n3))
              return false;
          return true;
        }
        addChildCheck(t4) {
          this.on("checkChild", (e4, [n3, o3]) => {
            if (!o3)
              return;
            const i3 = t4(n3, o3);
            "boolean" == typeof i3 && (e4.stop(), e4.return = i3);
          }, { priority: "high" });
        }
        addAttributeCheck(t4) {
          this.on("checkAttribute", (e4, [n3, o3]) => {
            const i3 = t4(n3, o3);
            "boolean" == typeof i3 && (e4.stop(), e4.return = i3);
          }, { priority: "high" });
        }
        setAttributeProperties(t4, e4) {
          this._attributeProperties[t4] = Object.assign(this.getAttributeProperties(t4), e4);
        }
        getAttributeProperties(t4) {
          return this._attributeProperties[t4] || {};
        }
        getLimitElement(t4) {
          let e4;
          if (t4 instanceof Fl)
            e4 = t4.parent;
          else {
            e4 = (t4 instanceof Wl ? [t4] : Array.from(t4.getRanges())).reduce((t5, e5) => {
              const n3 = e5.getCommonAncestor();
              return t5 ? t5.getCommonAncestor(n3, { includeSelf: true }) : n3;
            }, null);
          }
          for (; !this.isLimit(e4) && e4.parent; )
            e4 = e4.parent;
          return e4;
        }
        checkAttributeInSelection(t4, e4) {
          if (t4.isCollapsed) {
            const n3 = [...t4.getFirstPosition().getAncestors(), new zl("", t4.getAttributes())];
            return this.checkAttribute(n3, e4);
          }
          {
            const n3 = t4.getRanges();
            for (const t5 of n3)
              for (const n4 of t5)
                if (this.checkAttribute(n4.item, e4))
                  return true;
          }
          return false;
        }
        *getValidRanges(t4, e4) {
          t4 = function* (t5) {
            for (const e5 of t5)
              yield* e5.getMinimalFlatRanges();
          }(t4);
          for (const n3 of t4)
            yield* this._getValidRangesForRange(n3, e4);
        }
        getNearestSelectionRange(t4, e4 = "both") {
          if ("$graveyard" == t4.root.rootName)
            return null;
          if (this.checkChild(t4, "$text"))
            return new Wl(t4);
          let n3, o3;
          const i3 = t4.getAncestors().reverse().find((t5) => this.isLimit(t5)) || t4.root;
          "both" != e4 && "backward" != e4 || (n3 = new jl2({ boundaries: Wl._createIn(i3), startPosition: t4, direction: "backward" })), "both" != e4 && "forward" != e4 || (o3 = new jl2({ boundaries: Wl._createIn(i3), startPosition: t4 }));
          for (const t5 of function* (t6, e5) {
            let n4 = false;
            for (; !n4; ) {
              if (n4 = true, t6) {
                const e6 = t6.next();
                e6.done || (n4 = false, yield { walker: t6, value: e6.value });
              }
              if (e5) {
                const t7 = e5.next();
                t7.done || (n4 = false, yield { walker: e5, value: t7.value });
              }
            }
          }(n3, o3)) {
            const e5 = t5.walker == n3 ? "elementEnd" : "elementStart", o4 = t5.value;
            if (o4.type == e5 && this.isObject(o4.item))
              return Wl._createOn(o4.item);
            if (this.checkChild(o4.nextPosition, "$text"))
              return new Wl(o4.nextPosition);
          }
          return null;
        }
        findAllowedParent(t4, e4) {
          let n3 = t4.parent;
          for (; n3; ) {
            if (this.checkChild(n3, e4))
              return n3;
            if (this.isLimit(n3))
              return null;
            n3 = n3.parent;
          }
          return null;
        }
        setAllowedAttributes(t4, e4, n3) {
          const o3 = n3.model;
          for (const [i3, r3] of Object.entries(e4))
            o3.schema.checkAttribute(t4, i3) && n3.setAttribute(i3, r3, t4);
        }
        removeDisallowedAttributes(t4, e4) {
          for (const n3 of t4)
            if (n3.is("$text"))
              Ch2(this, n3, e4);
            else {
              const t5 = Wl._createIn(n3).getPositions();
              for (const n4 of t5) {
                Ch2(this, n4.nodeBefore || n4.parent, e4);
              }
            }
        }
        getAttributesWithProperty(t4, e4, n3) {
          const o3 = {};
          for (const [i3, r3] of t4.getAttributes()) {
            const t5 = this.getAttributeProperties(i3);
            void 0 !== t5[e4] && (void 0 !== n3 && n3 !== t5[e4] || (o3[i3] = r3));
          }
          return o3;
        }
        createContext(t4) {
          return new ch2(t4);
        }
        _clearCache() {
          this._compiledDefinitions = null;
        }
        _compile() {
          const t4 = {}, e4 = this._sourceDefinitions, n3 = Object.keys(e4);
          for (const o3 of n3)
            t4[o3] = lh2(e4[o3], o3);
          for (const e5 of n3)
            dh2(t4, e5);
          for (const e5 of n3)
            hh2(t4, e5);
          for (const e5 of n3)
            uh2(t4, e5);
          for (const e5 of n3)
            gh2(t4, e5), ph2(t4, e5);
          for (const e5 of n3)
            mh2(t4, e5), fh2(t4, e5), kh2(t4, e5);
          this._compiledDefinitions = t4;
        }
        _checkContextMatch(t4, e4, n3 = e4.length - 1) {
          const o3 = e4.getItem(n3);
          if (t4.allowIn.includes(o3.name)) {
            if (0 == n3)
              return true;
            {
              const t5 = this.getDefinition(o3);
              return this._checkContextMatch(t5, e4, n3 - 1);
            }
          }
          return false;
        }
        *_getValidRangesForRange(t4, e4) {
          let n3 = t4.start, o3 = t4.start;
          for (const i3 of t4.getItems({ shallow: true }))
            i3.is("element") && (yield* this._getValidRangesForRange(Wl._createIn(i3), e4)), this.checkAttribute(i3, e4) || (n3.isEqual(o3) || (yield new Wl(n3, o3)), n3 = Fl._createAfter(i3)), o3 = Fl._createAfter(i3);
          n3.isEqual(o3) || (yield new Wl(n3, o3));
        }
      }
      class ch2 {
        constructor(t4) {
          if (t4 instanceof ch2)
            return t4;
          let e4;
          e4 = "string" == typeof t4 ? [t4] : Array.isArray(t4) ? t4 : t4.getAncestors({ includeSelf: true }), this._items = e4.map(Ah2);
        }
        get length() {
          return this._items.length;
        }
        get last() {
          return this._items[this._items.length - 1];
        }
        [Symbol.iterator]() {
          return this._items[Symbol.iterator]();
        }
        push(t4) {
          const e4 = new ch2([t4]);
          return e4._items = [...this._items, ...e4._items], e4;
        }
        getItem(t4) {
          return this._items[t4];
        }
        *getNames() {
          yield* this._items.map((t4) => t4.name);
        }
        endsWith(t4) {
          return Array.from(this.getNames()).join(" ").endsWith(t4);
        }
        startsWith(t4) {
          return Array.from(this.getNames()).join(" ").startsWith(t4);
        }
      }
      function lh2(t4, e4) {
        const n3 = { name: e4, allowIn: [], allowContentOf: [], allowWhere: [], allowAttributes: [], allowAttributesOf: [], allowChildren: [], inheritTypesFrom: [] };
        return function(t5, e5) {
          for (const n4 of t5) {
            const t6 = Object.keys(n4).filter((t7) => t7.startsWith("is"));
            for (const o3 of t6)
              e5[o3] = !!n4[o3];
          }
        }(t4, n3), bh2(t4, n3, "allowIn"), bh2(t4, n3, "allowContentOf"), bh2(t4, n3, "allowWhere"), bh2(t4, n3, "allowAttributes"), bh2(t4, n3, "allowAttributesOf"), bh2(t4, n3, "allowChildren"), bh2(t4, n3, "inheritTypesFrom"), function(t5, e5) {
          for (const n4 of t5) {
            const t6 = n4.inheritAllFrom;
            t6 && (e5.allowContentOf.push(t6), e5.allowWhere.push(t6), e5.allowAttributesOf.push(t6), e5.inheritTypesFrom.push(t6));
          }
        }(t4, n3), n3;
      }
      function dh2(t4, e4) {
        const n3 = t4[e4];
        for (const o3 of n3.allowChildren) {
          const n4 = t4[o3];
          n4 && n4.allowIn.push(e4);
        }
        n3.allowChildren.length = 0;
      }
      function hh2(t4, e4) {
        for (const n3 of t4[e4].allowContentOf)
          if (t4[n3]) {
            wh2(t4, n3).forEach((t5) => {
              t5.allowIn.push(e4);
            });
          }
        delete t4[e4].allowContentOf;
      }
      function uh2(t4, e4) {
        for (const n3 of t4[e4].allowWhere) {
          const o3 = t4[n3];
          if (o3) {
            const n4 = o3.allowIn;
            t4[e4].allowIn.push(...n4);
          }
        }
        delete t4[e4].allowWhere;
      }
      function gh2(t4, e4) {
        for (const n3 of t4[e4].allowAttributesOf) {
          const o3 = t4[n3];
          if (o3) {
            const n4 = o3.allowAttributes;
            t4[e4].allowAttributes.push(...n4);
          }
        }
        delete t4[e4].allowAttributesOf;
      }
      function ph2(t4, e4) {
        const n3 = t4[e4];
        for (const e5 of n3.inheritTypesFrom) {
          const o3 = t4[e5];
          if (o3) {
            const t5 = Object.keys(o3).filter((t6) => t6.startsWith("is"));
            for (const e6 of t5)
              e6 in n3 || (n3[e6] = o3[e6]);
          }
        }
        delete n3.inheritTypesFrom;
      }
      function mh2(t4, e4) {
        const n3 = t4[e4], o3 = n3.allowIn.filter((e5) => t4[e5]);
        n3.allowIn = Array.from(new Set(o3));
      }
      function fh2(t4, e4) {
        const n3 = t4[e4];
        for (const o3 of n3.allowIn) {
          t4[o3].allowChildren.push(e4);
        }
      }
      function kh2(t4, e4) {
        const n3 = t4[e4];
        n3.allowAttributes = Array.from(new Set(n3.allowAttributes));
      }
      function bh2(t4, e4, n3) {
        for (const o3 of t4) {
          const t5 = o3[n3];
          "string" == typeof t5 ? e4[n3].push(t5) : Array.isArray(t5) && e4[n3].push(...t5);
        }
      }
      function wh2(t4, e4) {
        const n3 = t4[e4];
        return (o3 = t4, Object.keys(o3).map((t5) => o3[t5])).filter((t5) => t5.allowIn.includes(n3.name));
        var o3;
      }
      function Ah2(t4) {
        return "string" == typeof t4 || t4.is("documentFragment") ? { name: "string" == typeof t4 ? t4 : "$documentFragment", *getAttributeKeys() {
        }, getAttribute() {
        } } : { name: t4.is("element") ? t4.name : "$text", *getAttributeKeys() {
          yield* t4.getAttributeKeys();
        }, getAttribute: (e4) => t4.getAttribute(e4) };
      }
      function Ch2(t4, e4, n3) {
        for (const o3 of e4.getAttributeKeys())
          t4.checkAttribute(e4, o3) || n3.removeAttribute(o3, e4);
      }
      var _h = Object.defineProperty, vh2 = Object.defineProperties, yh2 = Object.getOwnPropertyDescriptors, xh2 = Object.getOwnPropertySymbols, Eh2 = Object.prototype.hasOwnProperty, Dh2 = Object.prototype.propertyIsEnumerable, Sh2 = (t4, e4, n3) => e4 in t4 ? _h(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3;
      class Ih2 extends M2() {
        constructor(t4) {
          var e4;
          super(), this._splitParts = /* @__PURE__ */ new Map(), this._cursorParents = /* @__PURE__ */ new Map(), this._modelCursor = null, this._emptyElementsToKeep = /* @__PURE__ */ new Set(), this.conversionApi = (e4 = ((t5, e5) => {
            for (var n3 in e5 || (e5 = {}))
              Eh2.call(e5, n3) && Sh2(t5, n3, e5[n3]);
            if (xh2)
              for (var n3 of xh2(e5))
                Dh2.call(e5, n3) && Sh2(t5, n3, e5[n3]);
            return t5;
          })({}, t4), vh2(e4, yh2({ consumable: null, writer: null, store: null, convertItem: (t5, e5) => this._convertItem(t5, e5), convertChildren: (t5, e5) => this._convertChildren(t5, e5), safeInsert: (t5, e5) => this._safeInsert(t5, e5), updateConversionResult: (t5, e5) => this._updateConversionResult(t5, e5), splitToAllowedParent: (t5, e5) => this._splitToAllowedParent(t5, e5), getSplitParts: (t5) => this._getSplitParts(t5), keepEmptyElement: (t5) => this._keepEmptyElement(t5) })));
        }
        convert(t4, e4, n3 = ["$root"]) {
          this.fire("viewCleanup", t4), this._modelCursor = function(t5, e5) {
            let n4;
            for (const o4 of new ch2(t5)) {
              const t6 = {};
              for (const e6 of o4.getAttributeKeys())
                t6[e6] = o4.getAttribute(e6);
              const i4 = e5.createElement(o4.name, t6);
              n4 && e5.insert(i4, n4), n4 = Fl._createAt(i4, 0);
            }
            return n4;
          }(n3, e4), this.conversionApi.writer = e4, this.conversionApi.consumable = ih2.createFrom(t4), this.conversionApi.store = {};
          const { modelRange: o3 } = this._convertItem(t4, this._modelCursor), i3 = e4.createDocumentFragment();
          if (o3) {
            this._removeEmptyElements();
            for (const t5 of Array.from(this._modelCursor.parent.getChildren()))
              e4.append(t5, i3);
            i3.markers = function(t5, e5) {
              const n4 = /* @__PURE__ */ new Set(), o4 = /* @__PURE__ */ new Map(), i4 = Wl._createIn(t5).getItems();
              for (const t6 of i4)
                t6.is("element", "$marker") && n4.add(t6);
              for (const t6 of n4) {
                const n5 = t6.getAttribute("data-name"), i5 = e5.createPositionBefore(t6);
                o4.has(n5) ? o4.get(n5).end = i5.clone() : o4.set(n5, new Wl(i5.clone())), e5.remove(t6);
              }
              return o4;
            }(i3, e4);
          }
          return this._modelCursor = null, this._splitParts.clear(), this._cursorParents.clear(), this._emptyElementsToKeep.clear(), this.conversionApi.writer = null, this.conversionApi.store = null, i3;
        }
        _convertItem(t4, e4) {
          const n3 = { viewItem: t4, modelCursor: e4, modelRange: null };
          if (t4.is("element") ? this.fire(`element:${t4.name}`, n3, this.conversionApi) : t4.is("$text") ? this.fire("text", n3, this.conversionApi) : this.fire("documentFragment", n3, this.conversionApi), n3.modelRange && !(n3.modelRange instanceof Wl))
            throw new A2("view-conversion-dispatcher-incorrect-result", this);
          return { modelRange: n3.modelRange, modelCursor: n3.modelCursor };
        }
        _convertChildren(t4, e4) {
          let n3 = e4.is("position") ? e4 : Fl._createAt(e4, 0);
          const o3 = new Wl(n3);
          for (const e5 of Array.from(t4.getChildren())) {
            const t5 = this._convertItem(e5, n3);
            t5.modelRange instanceof Wl && (o3.end = t5.modelRange.end, n3 = t5.modelCursor);
          }
          return { modelRange: o3, modelCursor: n3 };
        }
        _safeInsert(t4, e4) {
          const n3 = this._splitToAllowedParent(t4, e4);
          return !!n3 && (this.conversionApi.writer.insert(t4, n3.position), true);
        }
        _updateConversionResult(t4, e4) {
          const n3 = this._getSplitParts(t4), o3 = this.conversionApi.writer;
          e4.modelRange || (e4.modelRange = o3.createRange(o3.createPositionBefore(t4), o3.createPositionAfter(n3[n3.length - 1])));
          const i3 = this._cursorParents.get(t4);
          e4.modelCursor = i3 ? o3.createPositionAt(i3, 0) : e4.modelRange.end;
        }
        _splitToAllowedParent(t4, e4) {
          const { schema: n3, writer: o3 } = this.conversionApi;
          let i3 = n3.findAllowedParent(e4, t4);
          if (i3) {
            if (i3 === e4.parent)
              return { position: e4 };
            this._modelCursor.parent.getAncestors().includes(i3) && (i3 = null);
          }
          if (!i3)
            return Ld2(e4, t4, n3) ? { position: jd2(e4, o3) } : null;
          const r3 = this.conversionApi.writer.split(e4, i3), s3 = [];
          for (const t5 of r3.range.getWalker())
            if ("elementEnd" == t5.type)
              s3.push(t5.item);
            else {
              const e5 = s3.pop(), n4 = t5.item;
              this._registerSplitPair(e5, n4);
            }
          const a3 = r3.range.end.parent;
          return this._cursorParents.set(t4, a3), { position: r3.position, cursorParent: a3 };
        }
        _registerSplitPair(t4, e4) {
          this._splitParts.has(t4) || this._splitParts.set(t4, [t4]);
          const n3 = this._splitParts.get(t4);
          this._splitParts.set(e4, n3), n3.push(e4);
        }
        _getSplitParts(t4) {
          let e4;
          return e4 = this._splitParts.has(t4) ? this._splitParts.get(t4) : [t4], e4;
        }
        _keepEmptyElement(t4) {
          this._emptyElementsToKeep.add(t4);
        }
        _removeEmptyElements() {
          let t4 = false;
          for (const e4 of this._splitParts.keys())
            e4.isEmpty && !this._emptyElementsToKeep.has(e4) && (this.conversionApi.writer.remove(e4), this._splitParts.delete(e4), t4 = true);
          t4 && this._removeEmptyElements();
        }
      }
      class Th2 {
        getHtml(t4) {
          const e4 = document.implementation.createHTMLDocument("").createElement("div");
          return e4.appendChild(t4), e4.innerHTML;
        }
      }
      class Mh2 {
        constructor(t4) {
          this.skipComments = true, this.domParser = new DOMParser(), this.domConverter = new Ic2(t4, { renderingMode: "data" }), this.htmlWriter = new Th2();
        }
        toData(t4) {
          const e4 = this.domConverter.viewToDom(t4);
          return this.htmlWriter.getHtml(e4);
        }
        toView(t4) {
          const e4 = this._toDom(t4);
          return this.domConverter.domToView(e4, { skipComments: this.skipComments });
        }
        registerRawContentMatcher(t4) {
          this.domConverter.registerRawContentMatcher(t4);
        }
        useFillerType(t4) {
          this.domConverter.blockFillerMode = "marked" == t4 ? "markedNbsp" : "nbsp";
        }
        _toDom(t4) {
          t4.match(/<(?:html|body|head|meta)(?:\s[^>]*)?>/i) || (t4 = `<body>${t4}</body>`);
          const e4 = this.domParser.parseFromString(t4, "text/html"), n3 = e4.createDocumentFragment(), o3 = e4.body.childNodes;
          for (; o3.length > 0; )
            n3.appendChild(o3[0]);
          return n3;
        }
      }
      class Bh2 extends M2() {
        constructor(t4, e4) {
          super(), this.model = t4, this.mapper = new Kl(), this.downcastDispatcher = new rd2({ mapper: this.mapper, schema: t4.schema }), this.downcastDispatcher.on("insert:$text", (t5, e5, n3) => {
            if (!n3.consumable.consume(e5.item, t5.name))
              return;
            const o3 = n3.writer, i3 = n3.mapper.toViewPosition(e5.range.start), r3 = o3.createText(e5.item.data);
            o3.insert(i3, r3);
          }, { priority: "lowest" }), this.downcastDispatcher.on("insert", (t5, e5, n3) => {
            n3.convertAttributes(e5.item), e5.reconversion || !e5.item.is("element") || e5.item.isEmpty || n3.convertChildren(e5.item);
          }, { priority: "lowest" }), this.upcastDispatcher = new Ih2({ schema: t4.schema }), this.viewDocument = new ja2(e4), this.stylesProcessor = e4, this.htmlProcessor = new Mh2(this.viewDocument), this.processor = this.htmlProcessor, this._viewWriter = new Za2(this.viewDocument), this.upcastDispatcher.on("text", (t5, e5, { schema: n3, consumable: o3, writer: i3 }) => {
            let r3 = e5.modelCursor;
            if (!o3.test(e5.viewItem))
              return;
            if (!n3.checkChild(r3, "$text")) {
              if (!Ld2(r3, "$text", n3))
                return;
              if (0 == e5.viewItem.data.trim().length)
                return;
              const t6 = r3.nodeBefore;
              r3 = jd2(r3, i3), t6 && t6.is("element", "$marker") && (i3.move(i3.createRangeOn(t6), r3), r3 = i3.createPositionAfter(t6));
            }
            o3.consume(e5.viewItem);
            const s3 = i3.createText(e5.viewItem.data);
            i3.insert(s3, r3), e5.modelRange = i3.createRange(r3, r3.getShiftedBy(s3.offsetSize)), e5.modelCursor = e5.modelRange.end;
          }, { priority: "lowest" }), this.upcastDispatcher.on("element", (t5, e5, n3) => {
            if (!e5.modelRange && n3.consumable.consume(e5.viewItem, { name: true })) {
              const { modelRange: t6, modelCursor: o3 } = n3.convertChildren(e5.viewItem, e5.modelCursor);
              e5.modelRange = t6, e5.modelCursor = o3;
            }
          }, { priority: "lowest" }), this.upcastDispatcher.on("documentFragment", (t5, e5, n3) => {
            if (!e5.modelRange && n3.consumable.consume(e5.viewItem, { name: true })) {
              const { modelRange: t6, modelCursor: o3 } = n3.convertChildren(e5.viewItem, e5.modelCursor);
              e5.modelRange = t6, e5.modelCursor = o3;
            }
          }, { priority: "lowest" }), W2().prototype.decorate.call(this, "init"), W2().prototype.decorate.call(this, "set"), W2().prototype.decorate.call(this, "get"), W2().prototype.decorate.call(this, "toView"), W2().prototype.decorate.call(this, "toModel"), this.on("init", () => {
            this.fire("ready");
          }, { priority: "lowest" }), this.on("ready", () => {
            this.model.enqueueChange({ isUndoable: false }, Od2);
          }, { priority: "lowest" });
        }
        get(t4 = {}) {
          const { rootName: e4 = "main", trim: n3 = "empty" } = t4;
          if (!this._checkIfRootsExists([e4]))
            throw new A2("datacontroller-get-non-existent-root", this);
          const o3 = this.model.document.getRoot(e4);
          return o3.isAttached() || C2("datacontroller-get-detached-root", this), "empty" !== n3 || this.model.hasContent(o3, { ignoreWhitespaces: true }) ? this.stringify(o3, t4) : "";
        }
        stringify(t4, e4 = {}) {
          const n3 = this.toView(t4, e4);
          return this.processor.toData(n3);
        }
        toView(t4, e4 = {}) {
          const n3 = this.viewDocument, o3 = this._viewWriter;
          this.mapper.clearBindings();
          const i3 = Wl._createIn(t4), r3 = new $a(n3);
          this.mapper.bindElements(t4, r3);
          const s3 = t4.is("documentFragment") ? t4.markers : function(t5) {
            const e5 = [], n4 = t5.root.document;
            if (!n4)
              return /* @__PURE__ */ new Map();
            const o4 = Wl._createIn(t5);
            for (const t6 of n4.model.markers) {
              const n5 = t6.getRange(), i4 = n5.isCollapsed, r4 = n5.start.isEqual(o4.start) || n5.end.isEqual(o4.end);
              if (i4 && r4)
                e5.push([t6.name, n5]);
              else {
                const i5 = o4.getIntersection(n5);
                i5 && e5.push([t6.name, i5]);
              }
            }
            return e5.sort(([t6, e6], [n5, o5]) => {
              if ("after" !== e6.end.compareWith(o5.start))
                return 1;
              if ("before" !== e6.start.compareWith(o5.end))
                return -1;
              switch (e6.start.compareWith(o5.start)) {
                case "before":
                  return 1;
                case "after":
                  return -1;
                default:
                  switch (e6.end.compareWith(o5.end)) {
                    case "before":
                      return 1;
                    case "after":
                      return -1;
                    default:
                      return n5.localeCompare(t6);
                  }
              }
            }), new Map(e5);
          }(t4);
          return this.downcastDispatcher.convert(i3, s3, o3, e4), r3;
        }
        init(t4) {
          if (this.model.document.version)
            throw new A2("datacontroller-init-document-not-empty", this);
          let e4 = {};
          if ("string" == typeof t4 ? e4.main = t4 : e4 = t4, !this._checkIfRootsExists(Object.keys(e4)))
            throw new A2("datacontroller-init-non-existent-root", this);
          return this.model.enqueueChange({ isUndoable: false }, (t5) => {
            for (const n3 of Object.keys(e4)) {
              const o3 = this.model.document.getRoot(n3);
              t5.insert(this.parse(e4[n3], o3), o3, 0);
            }
          }), Promise.resolve();
        }
        set(t4, e4 = {}) {
          let n3 = {};
          if ("string" == typeof t4 ? n3.main = t4 : n3 = t4, !this._checkIfRootsExists(Object.keys(n3)))
            throw new A2("datacontroller-set-non-existent-root", this);
          this.model.enqueueChange(e4.batchType || {}, (t5) => {
            t5.setSelection(null), t5.removeSelectionAttribute(this.model.document.selection.getAttributeKeys());
            for (const e5 of Object.keys(n3)) {
              const o3 = this.model.document.getRoot(e5);
              t5.remove(t5.createRangeIn(o3)), t5.insert(this.parse(n3[e5], o3), o3, 0);
            }
          });
        }
        parse(t4, e4 = "$root") {
          const n3 = this.processor.toView(t4);
          return this.toModel(n3, e4);
        }
        toModel(t4, e4 = "$root") {
          return this.model.change((n3) => this.upcastDispatcher.convert(t4, n3, e4));
        }
        addStyleProcessorRules(t4) {
          t4(this.stylesProcessor);
        }
        registerRawContentMatcher(t4) {
          this.processor && this.processor !== this.htmlProcessor && this.processor.registerRawContentMatcher(t4), this.htmlProcessor.registerRawContentMatcher(t4);
        }
        destroy() {
          this.stopListening();
        }
        _checkIfRootsExists(t4) {
          for (const e4 of t4)
            if (!this.model.document.getRoot(e4))
              return false;
          return true;
        }
      }
      class Nh2 {
        constructor(t4, e4) {
          this._helpers = /* @__PURE__ */ new Map(), this._downcast = _i(t4), this._createConversionHelpers({ name: "downcast", dispatchers: this._downcast, isDowncast: true }), this._upcast = _i(e4), this._createConversionHelpers({ name: "upcast", dispatchers: this._upcast, isDowncast: false });
        }
        addAlias(t4, e4) {
          const n3 = this._downcast.includes(e4);
          if (!this._upcast.includes(e4) && !n3)
            throw new A2("conversion-add-alias-dispatcher-not-registered", this);
          this._createConversionHelpers({ name: t4, dispatchers: [e4], isDowncast: n3 });
        }
        for(t4) {
          if (!this._helpers.has(t4))
            throw new A2("conversion-for-unknown-group", this);
          return this._helpers.get(t4);
        }
        elementToElement(t4) {
          this.for("downcast").elementToElement(t4);
          for (const { model: e4, view: n3 } of Ph2(t4))
            this.for("upcast").elementToElement({ model: e4, view: n3, converterPriority: t4.converterPriority });
        }
        attributeToElement(t4) {
          this.for("downcast").attributeToElement(t4);
          for (const { model: e4, view: n3 } of Ph2(t4))
            this.for("upcast").elementToAttribute({ view: n3, model: e4, converterPriority: t4.converterPriority });
        }
        attributeToAttribute(t4) {
          this.for("downcast").attributeToAttribute(t4);
          for (const { model: e4, view: n3 } of Ph2(t4))
            this.for("upcast").attributeToAttribute({ view: n3, model: e4 });
        }
        _createConversionHelpers({ name: t4, dispatchers: e4, isDowncast: n3 }) {
          if (this._helpers.has(t4))
            throw new A2("conversion-group-exists", this);
          const o3 = n3 ? new vd2(e4) : new Wd2(e4);
          this._helpers.set(t4, o3);
        }
      }
      function* Ph2(t4) {
        if (t4.model.values)
          for (const e4 of t4.model.values) {
            const n3 = { key: t4.model.key, value: e4 }, o3 = t4.view[e4], i3 = t4.upcastAlso ? t4.upcastAlso[e4] : void 0;
            yield* zh2(n3, o3, i3);
          }
        else
          yield* zh2(t4.model, t4.view, t4.upcastAlso);
      }
      function* zh2(t4, e4, n3) {
        if (yield { model: t4, view: e4 }, n3)
          for (const e5 of _i(n3))
            yield { model: t4, view: e5 };
      }
      class Oh2 {
        constructor(t4) {
          this.baseVersion = t4, this.isDocumentOperation = null !== this.baseVersion, this.batch = null;
        }
        _validate() {
        }
        toJSON() {
          const t4 = Object.assign({}, this);
          return t4.__className = this.constructor.className, delete t4.batch, delete t4.isDocumentOperation, t4;
        }
        static get className() {
          return "Operation";
        }
        static fromJSON(t4, e4) {
          return new this(t4.baseVersion);
        }
      }
      function Lh2(t4, e4) {
        const n3 = Fh2(e4), o3 = n3.reduce((t5, e5) => t5 + e5.offsetSize, 0), i3 = t4.parent;
        Hh2(t4);
        const r3 = t4.index;
        return i3._insertChild(r3, n3), Vh2(i3, r3 + n3.length), Vh2(i3, r3), new Wl(t4, t4.getShiftedBy(o3));
      }
      function jh2(t4) {
        if (!t4.isFlat)
          throw new A2("operation-utils-remove-range-not-flat", this);
        const e4 = t4.start.parent;
        Hh2(t4.start), Hh2(t4.end);
        const n3 = e4._removeChildren(t4.start.index, t4.end.index - t4.start.index);
        return Vh2(e4, t4.start.index), n3;
      }
      function Rh2(t4, e4) {
        if (!t4.isFlat)
          throw new A2("operation-utils-move-range-not-flat", this);
        const n3 = jh2(t4);
        return Lh2(e4 = e4._getTransformedByDeletion(t4.start, t4.end.offset - t4.start.offset), n3);
      }
      function Fh2(t4) {
        const e4 = [];
        !function t5(n3) {
          if ("string" == typeof n3)
            e4.push(new zl(n3));
          else if (n3 instanceof Ol)
            e4.push(new zl(n3.data, n3.getAttributes()));
          else if (n3 instanceof Nl)
            e4.push(n3);
          else if (et2(n3))
            for (const e5 of n3)
              t5(e5);
        }(t4);
        for (let t5 = 1; t5 < e4.length; t5++) {
          const n3 = e4[t5], o3 = e4[t5 - 1];
          n3 instanceof zl && o3 instanceof zl && Uh2(n3, o3) && (e4.splice(t5 - 1, 2, new zl(o3.data + n3.data, o3.getAttributes())), t5--);
        }
        return e4;
      }
      function Vh2(t4, e4) {
        const n3 = t4.getChild(e4 - 1), o3 = t4.getChild(e4);
        if (n3 && o3 && n3.is("$text") && o3.is("$text") && Uh2(n3, o3)) {
          const i3 = new zl(n3.data + o3.data, n3.getAttributes());
          t4._removeChildren(e4 - 1, 2), t4._insertChild(e4 - 1, i3);
        }
      }
      function Hh2(t4) {
        const e4 = t4.textNode, n3 = t4.parent;
        if (e4) {
          const o3 = t4.offset - e4.startOffset, i3 = e4.index;
          n3._removeChildren(i3, 1);
          const r3 = new zl(e4.data.substr(0, o3), e4.getAttributes()), s3 = new zl(e4.data.substr(o3), e4.getAttributes());
          n3._insertChild(i3, [r3, s3]);
        }
      }
      function Uh2(t4, e4) {
        const n3 = t4.getAttributes(), o3 = e4.getAttributes();
        for (const t5 of n3) {
          if (t5[1] !== e4.getAttribute(t5[0]))
            return false;
          o3.next();
        }
        return o3.next().done;
      }
      class qh2 extends Oh2 {
        constructor(t4, e4, n3, o3) {
          super(o3), this.sourcePosition = t4.clone(), this.sourcePosition.stickiness = "toNext", this.howMany = e4, this.targetPosition = n3.clone(), this.targetPosition.stickiness = "toNone";
        }
        get type() {
          return "$graveyard" == this.targetPosition.root.rootName ? "remove" : "$graveyard" == this.sourcePosition.root.rootName ? "reinsert" : "move";
        }
        get affectedSelectable() {
          return [Wl._createFromPositionAndShift(this.sourcePosition, this.howMany), Wl._createFromPositionAndShift(this.targetPosition, 0)];
        }
        clone() {
          return new qh2(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
        }
        getMovedRangeStart() {
          return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
        }
        getReversed() {
          const t4 = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);
          return new qh2(this.getMovedRangeStart(), this.howMany, t4, this.baseVersion + 1);
        }
        _validate() {
          const t4 = this.sourcePosition.parent, e4 = this.targetPosition.parent, n3 = this.sourcePosition.offset, o3 = this.targetPosition.offset;
          if (n3 + this.howMany > t4.maxOffset)
            throw new A2("move-operation-nodes-do-not-exist", this);
          if (t4 === e4 && n3 < o3 && o3 < n3 + this.howMany)
            throw new A2("move-operation-range-into-itself", this);
          if (this.sourcePosition.root == this.targetPosition.root && "prefix" == tt2(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath())) {
            const t5 = this.sourcePosition.path.length - 1;
            if (this.targetPosition.path[t5] >= n3 && this.targetPosition.path[t5] < n3 + this.howMany)
              throw new A2("move-operation-node-into-itself", this);
          }
        }
        _execute() {
          Rh2(Wl._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.sourcePosition = this.sourcePosition.toJSON(), t4.targetPosition = this.targetPosition.toJSON(), t4;
        }
        static get className() {
          return "MoveOperation";
        }
        static fromJSON(t4, e4) {
          const n3 = Fl.fromJSON(t4.sourcePosition, e4), o3 = Fl.fromJSON(t4.targetPosition, e4);
          return new this(n3, t4.howMany, o3, t4.baseVersion);
        }
      }
      class Gh2 extends Oh2 {
        constructor(t4, e4, n3) {
          super(n3), this.position = t4.clone(), this.position.stickiness = "toNone", this.nodes = new Pl(Fh2(e4)), this.shouldReceiveAttributes = false;
        }
        get type() {
          return "insert";
        }
        get howMany() {
          return this.nodes.maxOffset;
        }
        get affectedSelectable() {
          return this.position.clone();
        }
        clone() {
          const t4 = new Pl([...this.nodes].map((t5) => t5._clone(true))), e4 = new Gh2(this.position, t4, this.baseVersion);
          return e4.shouldReceiveAttributes = this.shouldReceiveAttributes, e4;
        }
        getReversed() {
          const t4 = this.position.root.document.graveyard, e4 = new Fl(t4, [0]);
          return new qh2(this.position, this.nodes.maxOffset, e4, this.baseVersion + 1);
        }
        _validate() {
          const t4 = this.position.parent;
          if (!t4 || t4.maxOffset < this.position.offset)
            throw new A2("insert-operation-position-invalid", this);
        }
        _execute() {
          const t4 = this.nodes;
          this.nodes = new Pl([...t4].map((t5) => t5._clone(true))), Lh2(this.position, t4);
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.position = this.position.toJSON(), t4.nodes = this.nodes.toJSON(), t4;
        }
        static get className() {
          return "InsertOperation";
        }
        static fromJSON(t4, e4) {
          const n3 = [];
          for (const e5 of t4.nodes)
            e5.name ? n3.push(Ll.fromJSON(e5)) : n3.push(zl.fromJSON(e5));
          const o3 = new Gh2(Fl.fromJSON(t4.position, e4), n3, t4.baseVersion);
          return o3.shouldReceiveAttributes = t4.shouldReceiveAttributes, o3;
        }
      }
      class Wh2 extends Oh2 {
        constructor(t4, e4, n3, o3, i3) {
          super(i3), this.splitPosition = t4.clone(), this.splitPosition.stickiness = "toNext", this.howMany = e4, this.insertionPosition = n3, this.graveyardPosition = o3 ? o3.clone() : null, this.graveyardPosition && (this.graveyardPosition.stickiness = "toNext");
        }
        get type() {
          return "split";
        }
        get moveTargetPosition() {
          const t4 = this.insertionPosition.path.slice();
          return t4.push(0), new Fl(this.insertionPosition.root, t4);
        }
        get movedRange() {
          const t4 = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new Wl(this.splitPosition, t4);
        }
        get affectedSelectable() {
          const t4 = [Wl._createFromPositionAndShift(this.splitPosition, 0), Wl._createFromPositionAndShift(this.insertionPosition, 0)];
          return this.graveyardPosition && t4.push(Wl._createFromPositionAndShift(this.graveyardPosition, 0)), t4;
        }
        clone() {
          return new Wh2(this.splitPosition, this.howMany, this.insertionPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const t4 = this.splitPosition.root.document.graveyard, e4 = new Fl(t4, [0]);
          return new Kh2(this.moveTargetPosition, this.howMany, this.splitPosition, e4, this.baseVersion + 1);
        }
        _validate() {
          const t4 = this.splitPosition.parent, e4 = this.splitPosition.offset;
          if (!t4 || t4.maxOffset < e4)
            throw new A2("split-operation-position-invalid", this);
          if (!t4.parent)
            throw new A2("split-operation-split-in-root", this);
          if (this.howMany != t4.maxOffset - this.splitPosition.offset)
            throw new A2("split-operation-how-many-invalid", this);
          if (this.graveyardPosition && !this.graveyardPosition.nodeAfter)
            throw new A2("split-operation-graveyard-position-invalid", this);
        }
        _execute() {
          const t4 = this.splitPosition.parent;
          if (this.graveyardPosition)
            Rh2(Wl._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
          else {
            const e4 = t4._clone();
            Lh2(this.insertionPosition, e4);
          }
          Rh2(new Wl(Fl._createAt(t4, this.splitPosition.offset), Fl._createAt(t4, t4.maxOffset)), this.moveTargetPosition);
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.splitPosition = this.splitPosition.toJSON(), t4.insertionPosition = this.insertionPosition.toJSON(), this.graveyardPosition && (t4.graveyardPosition = this.graveyardPosition.toJSON()), t4;
        }
        static get className() {
          return "SplitOperation";
        }
        static getInsertionPosition(t4) {
          const e4 = t4.path.slice(0, -1);
          return e4[e4.length - 1]++, new Fl(t4.root, e4, "toPrevious");
        }
        static fromJSON(t4, e4) {
          const n3 = Fl.fromJSON(t4.splitPosition, e4), o3 = Fl.fromJSON(t4.insertionPosition, e4), i3 = t4.graveyardPosition ? Fl.fromJSON(t4.graveyardPosition, e4) : null;
          return new this(n3, t4.howMany, o3, i3, t4.baseVersion);
        }
      }
      class Kh2 extends Oh2 {
        constructor(t4, e4, n3, o3, i3) {
          super(i3), this.sourcePosition = t4.clone(), this.sourcePosition.stickiness = "toPrevious", this.howMany = e4, this.targetPosition = n3.clone(), this.targetPosition.stickiness = "toNext", this.graveyardPosition = o3.clone();
        }
        get type() {
          return "merge";
        }
        get deletionPosition() {
          return new Fl(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
        }
        get movedRange() {
          const t4 = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
          return new Wl(this.sourcePosition, t4);
        }
        get affectedSelectable() {
          const t4 = this.sourcePosition.parent;
          return [Wl._createOn(t4), Wl._createFromPositionAndShift(this.targetPosition, 0), Wl._createFromPositionAndShift(this.graveyardPosition, 0)];
        }
        clone() {
          return new Kh2(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
        }
        getReversed() {
          const t4 = this.targetPosition._getTransformedByMergeOperation(this), e4 = this.sourcePosition.path.slice(0, -1), n3 = new Fl(this.sourcePosition.root, e4)._getTransformedByMergeOperation(this);
          return new Wh2(t4, this.howMany, n3, this.graveyardPosition, this.baseVersion + 1);
        }
        _validate() {
          const t4 = this.sourcePosition.parent, e4 = this.targetPosition.parent;
          if (!t4.parent)
            throw new A2("merge-operation-source-position-invalid", this);
          if (!e4.parent)
            throw new A2("merge-operation-target-position-invalid", this);
          if (this.howMany != t4.maxOffset)
            throw new A2("merge-operation-how-many-invalid", this);
        }
        _execute() {
          const t4 = this.sourcePosition.parent;
          Rh2(Wl._createIn(t4), this.targetPosition), Rh2(Wl._createOn(t4), this.graveyardPosition);
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.sourcePosition = t4.sourcePosition.toJSON(), t4.targetPosition = t4.targetPosition.toJSON(), t4.graveyardPosition = t4.graveyardPosition.toJSON(), t4;
        }
        static get className() {
          return "MergeOperation";
        }
        static fromJSON(t4, e4) {
          const n3 = Fl.fromJSON(t4.sourcePosition, e4), o3 = Fl.fromJSON(t4.targetPosition, e4), i3 = Fl.fromJSON(t4.graveyardPosition, e4);
          return new this(n3, t4.howMany, o3, i3, t4.baseVersion);
        }
      }
      class Yh2 extends Oh2 {
        constructor(t4, e4, n3, o3, i3, r3) {
          super(r3), this.name = t4, this.oldRange = e4 ? e4.clone() : null, this.newRange = n3 ? n3.clone() : null, this.affectsData = i3, this._markers = o3;
        }
        get type() {
          return "marker";
        }
        get affectedSelectable() {
          const t4 = [];
          return this.oldRange && t4.push(this.oldRange.clone()), this.newRange && (this.oldRange ? t4.push(...this.newRange.getDifference(this.oldRange)) : t4.push(this.newRange.clone())), t4;
        }
        clone() {
          return new Yh2(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
        }
        getReversed() {
          return new Yh2(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
        }
        _execute() {
          this.newRange ? this._markers._set(this.name, this.newRange, true, this.affectsData) : this._markers._remove(this.name);
        }
        toJSON() {
          const t4 = super.toJSON();
          return this.oldRange && (t4.oldRange = this.oldRange.toJSON()), this.newRange && (t4.newRange = this.newRange.toJSON()), delete t4._markers, t4;
        }
        static get className() {
          return "MarkerOperation";
        }
        static fromJSON(t4, e4) {
          return new Yh2(t4.name, t4.oldRange ? Wl.fromJSON(t4.oldRange, e4) : null, t4.newRange ? Wl.fromJSON(t4.newRange, e4) : null, e4.model.markers, t4.affectsData, t4.baseVersion);
        }
      }
      const $h2 = function(t4, e4) {
        return bl2(t4, e4);
      };
      class Zh2 extends Oh2 {
        constructor(t4, e4, n3, o3, i3) {
          super(i3), this.range = t4.clone(), this.key = e4, this.oldValue = void 0 === n3 ? null : n3, this.newValue = void 0 === o3 ? null : o3;
        }
        get type() {
          return null === this.oldValue ? "addAttribute" : null === this.newValue ? "removeAttribute" : "changeAttribute";
        }
        get affectedSelectable() {
          return this.range.clone();
        }
        clone() {
          return new Zh2(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new Zh2(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.range = this.range.toJSON(), t4;
        }
        _validate() {
          if (!this.range.isFlat)
            throw new A2("attribute-operation-range-not-flat", this);
          for (const t4 of this.range.getItems({ shallow: true })) {
            if (null !== this.oldValue && !$h2(t4.getAttribute(this.key), this.oldValue))
              throw new A2("attribute-operation-wrong-old-value", this, { item: t4, key: this.key, value: this.oldValue });
            if (null === this.oldValue && null !== this.newValue && t4.hasAttribute(this.key))
              throw new A2("attribute-operation-attribute-exists", this, { node: t4, key: this.key });
          }
        }
        _execute() {
          $h2(this.oldValue, this.newValue) || function(t4, e4, n3) {
            Hh2(t4.start), Hh2(t4.end);
            for (const o3 of t4.getItems({ shallow: true })) {
              const t5 = o3.is("$textProxy") ? o3.textNode : o3;
              null !== n3 ? t5._setAttribute(e4, n3) : t5._removeAttribute(e4), Vh2(t5.parent, t5.index);
            }
            Vh2(t4.end.parent, t4.end.index);
          }(this.range, this.key, this.newValue);
        }
        static get className() {
          return "AttributeOperation";
        }
        static fromJSON(t4, e4) {
          return new Zh2(Wl.fromJSON(t4.range, e4), t4.key, t4.oldValue, t4.newValue, t4.baseVersion);
        }
      }
      class Qh2 extends Oh2 {
        get type() {
          return "noop";
        }
        get affectedSelectable() {
          return null;
        }
        clone() {
          return new Qh2(this.baseVersion);
        }
        getReversed() {
          return new Qh2(this.baseVersion + 1);
        }
        _execute() {
        }
        static get className() {
          return "NoOperation";
        }
      }
      class Jh2 extends Oh2 {
        constructor(t4, e4, n3, o3) {
          super(o3), this.position = t4, this.position.stickiness = "toNext", this.oldName = e4, this.newName = n3;
        }
        get type() {
          return "rename";
        }
        get affectedSelectable() {
          return this.position.nodeAfter;
        }
        clone() {
          return new Jh2(this.position.clone(), this.oldName, this.newName, this.baseVersion);
        }
        getReversed() {
          return new Jh2(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
        }
        _validate() {
          const t4 = this.position.nodeAfter;
          if (!(t4 instanceof Ll))
            throw new A2("rename-operation-wrong-position", this);
          if (t4.name !== this.oldName)
            throw new A2("rename-operation-wrong-name", this);
        }
        _execute() {
          this.position.nodeAfter.name = this.newName;
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.position = this.position.toJSON(), t4;
        }
        static get className() {
          return "RenameOperation";
        }
        static fromJSON(t4, e4) {
          return new Jh2(Fl.fromJSON(t4.position, e4), t4.oldName, t4.newName, t4.baseVersion);
        }
      }
      class Xh2 extends Oh2 {
        constructor(t4, e4, n3, o3, i3) {
          super(i3), this.root = t4, this.key = e4, this.oldValue = void 0 === n3 ? null : n3, this.newValue = void 0 === o3 ? null : o3;
        }
        get type() {
          return null === this.oldValue ? "addRootAttribute" : null === this.newValue ? "removeRootAttribute" : "changeRootAttribute";
        }
        get affectedSelectable() {
          return this.root;
        }
        clone() {
          return new Xh2(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
        }
        getReversed() {
          return new Xh2(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
        }
        _validate() {
          if (this.root != this.root.root || this.root.is("documentFragment"))
            throw new A2("rootattribute-operation-not-a-root", this, { root: this.root, key: this.key });
          if (null !== this.oldValue && this.root.getAttribute(this.key) !== this.oldValue)
            throw new A2("rootattribute-operation-wrong-old-value", this, { root: this.root, key: this.key });
          if (null === this.oldValue && null !== this.newValue && this.root.hasAttribute(this.key))
            throw new A2("rootattribute-operation-attribute-exists", this, { root: this.root, key: this.key });
        }
        _execute() {
          null !== this.newValue ? this.root._setAttribute(this.key, this.newValue) : this.root._removeAttribute(this.key);
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.root = this.root.toJSON(), t4;
        }
        static get className() {
          return "RootAttributeOperation";
        }
        static fromJSON(t4, e4) {
          if (!e4.getRoot(t4.root))
            throw new A2("rootattribute-operation-fromjson-no-root", this, { rootName: t4.root });
          return new Xh2(e4.getRoot(t4.root), t4.key, t4.oldValue, t4.newValue, t4.baseVersion);
        }
      }
      class tu extends Oh2 {
        constructor(t4, e4, n3, o3, i3) {
          if (super(i3), this.rootName = t4, this.elementName = e4, this.isAdd = n3, this._document = o3, !this._document.getRoot(this.rootName)) {
            this._document.createRoot(this.elementName, this.rootName)._isAttached = false;
          }
        }
        get type() {
          return this.isAdd ? "addRoot" : "detachRoot";
        }
        get affectedSelectable() {
          return this._document.getRoot(this.rootName);
        }
        clone() {
          return new tu(this.rootName, this.elementName, this.isAdd, this._document, this.baseVersion);
        }
        getReversed() {
          return new tu(this.rootName, this.elementName, !this.isAdd, this._document, this.baseVersion + 1);
        }
        _execute() {
          this._document.getRoot(this.rootName)._isAttached = this.isAdd;
        }
        toJSON() {
          const t4 = super.toJSON();
          return delete t4._document, t4;
        }
        static get className() {
          return "RootOperation";
        }
        static fromJSON(t4, e4) {
          return new tu(t4.rootName, t4.elementName, t4.isAdd, e4, t4.baseVersion);
        }
      }
      const eu = {};
      eu[Zh2.className] = Zh2, eu[Gh2.className] = Gh2, eu[Yh2.className] = Yh2, eu[qh2.className] = qh2, eu[Qh2.className] = Qh2, eu[Oh2.className] = Oh2, eu[Jh2.className] = Jh2, eu[Xh2.className] = Xh2, eu[tu.className] = tu, eu[Wh2.className] = Wh2, eu[Kh2.className] = Kh2;
      class nu {
        static fromJSON(t4, e4) {
          return eu[t4.__className].fromJSON(t4, e4);
        }
      }
      const ou = /* @__PURE__ */ new Map();
      function iu(t4, e4, n3) {
        let o3 = ou.get(t4);
        o3 || (o3 = /* @__PURE__ */ new Map(), ou.set(t4, o3)), o3.set(e4, n3);
      }
      function ru(t4) {
        return [t4];
      }
      function su(t4, e4, n3 = {}) {
        const o3 = function(t5, e5) {
          const n4 = ou.get(t5);
          return n4 && n4.has(e5) ? n4.get(e5) : ru;
        }(t4.constructor, e4.constructor);
        try {
          return o3(t4 = t4.clone(), e4, n3);
        } catch (t5) {
          throw t5;
        }
      }
      function au(t4, e4, n3) {
        t4 = t4.slice(), e4 = e4.slice();
        const o3 = new cu(n3.document, n3.useRelations, n3.forceWeakRemove);
        o3.setOriginalOperations(t4), o3.setOriginalOperations(e4);
        const i3 = o3.originalOperations;
        if (0 == t4.length || 0 == e4.length)
          return { operationsA: t4, operationsB: e4, originalOperations: i3 };
        const r3 = /* @__PURE__ */ new WeakMap();
        for (const e5 of t4)
          r3.set(e5, 0);
        const s3 = { nextBaseVersionA: t4[t4.length - 1].baseVersion + 1, nextBaseVersionB: e4[e4.length - 1].baseVersion + 1, originalOperationsACount: t4.length, originalOperationsBCount: e4.length };
        let a3 = 0;
        for (; a3 < t4.length; ) {
          const n4 = t4[a3], i4 = r3.get(n4);
          if (i4 == e4.length) {
            a3++;
            continue;
          }
          const s4 = e4[i4], c3 = su(n4, s4, o3.getContext(n4, s4, true)), l3 = su(s4, n4, o3.getContext(s4, n4, false));
          o3.updateRelation(n4, s4), o3.setOriginalOperations(c3, n4), o3.setOriginalOperations(l3, s4);
          for (const t5 of c3)
            r3.set(t5, i4 + l3.length);
          t4.splice(a3, 1, ...c3), e4.splice(i4, 1, ...l3);
        }
        if (n3.padWithNoOps) {
          const n4 = t4.length - s3.originalOperationsACount, o4 = e4.length - s3.originalOperationsBCount;
          du(t4, o4 - n4), du(e4, n4 - o4);
        }
        return lu(t4, s3.nextBaseVersionB), lu(e4, s3.nextBaseVersionA), { operationsA: t4, operationsB: e4, originalOperations: i3 };
      }
      class cu {
        constructor(t4, e4, n3 = false) {
          this.originalOperations = /* @__PURE__ */ new Map(), this._history = t4.history, this._useRelations = e4, this._forceWeakRemove = !!n3, this._relations = /* @__PURE__ */ new Map();
        }
        setOriginalOperations(t4, e4 = null) {
          const n3 = e4 ? this.originalOperations.get(e4) : null;
          for (const e5 of t4)
            this.originalOperations.set(e5, n3 || e5);
        }
        updateRelation(t4, e4) {
          if (t4 instanceof qh2)
            e4 instanceof Kh2 ? t4.targetPosition.isEqual(e4.sourcePosition) || e4.movedRange.containsPosition(t4.targetPosition) ? this._setRelation(t4, e4, "insertAtSource") : t4.targetPosition.isEqual(e4.deletionPosition) ? this._setRelation(t4, e4, "insertBetween") : t4.targetPosition.isAfter(e4.sourcePosition) && this._setRelation(t4, e4, "moveTargetAfter") : e4 instanceof qh2 && (t4.targetPosition.isEqual(e4.sourcePosition) || t4.targetPosition.isBefore(e4.sourcePosition) ? this._setRelation(t4, e4, "insertBefore") : this._setRelation(t4, e4, "insertAfter"));
          else if (t4 instanceof Wh2) {
            if (e4 instanceof Kh2)
              t4.splitPosition.isBefore(e4.sourcePosition) && this._setRelation(t4, e4, "splitBefore");
            else if (e4 instanceof qh2)
              if (t4.splitPosition.isEqual(e4.sourcePosition) || t4.splitPosition.isBefore(e4.sourcePosition))
                this._setRelation(t4, e4, "splitBefore");
              else {
                const n3 = Wl._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
                if (t4.splitPosition.hasSameParentAs(e4.sourcePosition) && n3.containsPosition(t4.splitPosition)) {
                  const o3 = n3.end.offset - t4.splitPosition.offset, i3 = t4.splitPosition.offset - n3.start.offset;
                  this._setRelation(t4, e4, { howMany: o3, offset: i3 });
                }
              }
          } else if (t4 instanceof Kh2)
            e4 instanceof Kh2 ? (t4.targetPosition.isEqual(e4.sourcePosition) || this._setRelation(t4, e4, "mergeTargetNotMoved"), t4.sourcePosition.isEqual(e4.targetPosition) && this._setRelation(t4, e4, "mergeSourceNotMoved"), t4.sourcePosition.isEqual(e4.sourcePosition) && this._setRelation(t4, e4, "mergeSameElement")) : e4 instanceof Wh2 && t4.sourcePosition.isEqual(e4.splitPosition) && this._setRelation(t4, e4, "splitAtSource");
          else if (t4 instanceof Yh2) {
            const n3 = t4.newRange;
            if (!n3)
              return;
            if (e4 instanceof qh2) {
              const o3 = Wl._createFromPositionAndShift(e4.sourcePosition, e4.howMany), i3 = o3.containsPosition(n3.start) || o3.start.isEqual(n3.start), r3 = o3.containsPosition(n3.end) || o3.end.isEqual(n3.end);
              !i3 && !r3 || o3.containsRange(n3) || this._setRelation(t4, e4, { side: i3 ? "left" : "right", path: i3 ? n3.start.path.slice() : n3.end.path.slice() });
            } else if (e4 instanceof Kh2) {
              const o3 = n3.start.isEqual(e4.targetPosition), i3 = n3.start.isEqual(e4.deletionPosition), r3 = n3.end.isEqual(e4.deletionPosition), s3 = n3.end.isEqual(e4.sourcePosition);
              (o3 || i3 || r3 || s3) && this._setRelation(t4, e4, { wasInLeftElement: o3, wasStartBeforeMergedElement: i3, wasEndBeforeMergedElement: r3, wasInRightElement: s3 });
            }
          }
        }
        getContext(t4, e4, n3) {
          return { aIsStrong: n3, aWasUndone: this._wasUndone(t4), bWasUndone: this._wasUndone(e4), abRelation: this._useRelations ? this._getRelation(t4, e4) : null, baRelation: this._useRelations ? this._getRelation(e4, t4) : null, forceWeakRemove: this._forceWeakRemove };
        }
        _wasUndone(t4) {
          const e4 = this.originalOperations.get(t4);
          return e4.wasUndone || this._history.isUndoneOperation(e4);
        }
        _getRelation(t4, e4) {
          const n3 = this.originalOperations.get(e4), o3 = this._history.getUndoneOperation(n3);
          if (!o3)
            return null;
          const i3 = this.originalOperations.get(t4), r3 = this._relations.get(i3);
          return r3 && r3.get(o3) || null;
        }
        _setRelation(t4, e4, n3) {
          const o3 = this.originalOperations.get(t4), i3 = this.originalOperations.get(e4);
          let r3 = this._relations.get(o3);
          r3 || (r3 = /* @__PURE__ */ new Map(), this._relations.set(o3, r3)), r3.set(i3, n3);
        }
      }
      function lu(t4, e4) {
        for (const n3 of t4)
          n3.baseVersion = e4++;
      }
      function du(t4, e4) {
        for (let n3 = 0; n3 < e4; n3++)
          t4.push(new Qh2(0));
      }
      function hu(t4, e4, n3) {
        const o3 = t4.nodes.getNode(0).getAttribute(e4);
        if (o3 == n3)
          return null;
        const i3 = new Wl(t4.position, t4.position.getShiftedBy(t4.howMany));
        return new Zh2(i3, e4, o3, n3, 0);
      }
      function uu(t4, e4) {
        return null === t4.targetPosition._getTransformedByDeletion(e4.sourcePosition, e4.howMany);
      }
      function gu(t4, e4) {
        const n3 = [];
        for (let o3 = 0; o3 < t4.length; o3++) {
          const i3 = t4[o3], r3 = new qh2(i3.start, i3.end.offset - i3.start.offset, e4, 0);
          n3.push(r3);
          for (let e5 = o3 + 1; e5 < t4.length; e5++)
            t4[e5] = t4[e5]._getTransformedByMove(r3.sourcePosition, r3.targetPosition, r3.howMany)[0];
          e4 = e4._getTransformedByMove(r3.sourcePosition, r3.targetPosition, r3.howMany);
        }
        return n3;
      }
      iu(Zh2, Zh2, (t4, e4, n3) => {
        if (t4.key === e4.key && t4.range.start.hasSameParentAs(e4.range.start)) {
          const o3 = t4.range.getDifference(e4.range).map((e5) => new Zh2(e5, t4.key, t4.oldValue, t4.newValue, 0)), i3 = t4.range.getIntersection(e4.range);
          return i3 && n3.aIsStrong && o3.push(new Zh2(i3, e4.key, e4.newValue, t4.newValue, 0)), 0 == o3.length ? [new Qh2(0)] : o3;
        }
        return [t4];
      }), iu(Zh2, Gh2, (t4, e4) => {
        if (t4.range.start.hasSameParentAs(e4.position) && t4.range.containsPosition(e4.position)) {
          const n3 = t4.range._getTransformedByInsertion(e4.position, e4.howMany, !e4.shouldReceiveAttributes).map((e5) => new Zh2(e5, t4.key, t4.oldValue, t4.newValue, t4.baseVersion));
          if (e4.shouldReceiveAttributes) {
            const o3 = hu(e4, t4.key, t4.oldValue);
            o3 && n3.unshift(o3);
          }
          return n3;
        }
        return t4.range = t4.range._getTransformedByInsertion(e4.position, e4.howMany, false)[0], [t4];
      }), iu(Zh2, Kh2, (t4, e4) => {
        const n3 = [];
        t4.range.start.hasSameParentAs(e4.deletionPosition) && (t4.range.containsPosition(e4.deletionPosition) || t4.range.start.isEqual(e4.deletionPosition)) && n3.push(Wl._createFromPositionAndShift(e4.graveyardPosition, 1));
        const o3 = t4.range._getTransformedByMergeOperation(e4);
        return o3.isCollapsed || n3.push(o3), n3.map((e5) => new Zh2(e5, t4.key, t4.oldValue, t4.newValue, t4.baseVersion));
      }), iu(Zh2, qh2, (t4, e4) => {
        const n3 = function(t5, e5) {
          const n4 = Wl._createFromPositionAndShift(e5.sourcePosition, e5.howMany);
          let o3 = null, i3 = [];
          n4.containsRange(t5, true) ? o3 = t5 : t5.start.hasSameParentAs(n4.start) ? (i3 = t5.getDifference(n4), o3 = t5.getIntersection(n4)) : i3 = [t5];
          const r3 = [];
          for (let t6 of i3) {
            t6 = t6._getTransformedByDeletion(e5.sourcePosition, e5.howMany);
            const n5 = e5.getMovedRangeStart(), o4 = t6.start.hasSameParentAs(n5), i4 = t6._getTransformedByInsertion(n5, e5.howMany, o4);
            r3.push(...i4);
          }
          o3 && r3.push(o3._getTransformedByMove(e5.sourcePosition, e5.targetPosition, e5.howMany, false)[0]);
          return r3;
        }(t4.range, e4);
        return n3.map((e5) => new Zh2(e5, t4.key, t4.oldValue, t4.newValue, t4.baseVersion));
      }), iu(Zh2, Wh2, (t4, e4) => {
        if (t4.range.end.isEqual(e4.insertionPosition))
          return e4.graveyardPosition || t4.range.end.offset++, [t4];
        if (t4.range.start.hasSameParentAs(e4.splitPosition) && t4.range.containsPosition(e4.splitPosition)) {
          const n3 = t4.clone();
          return n3.range = new Wl(e4.moveTargetPosition.clone(), t4.range.end._getCombined(e4.splitPosition, e4.moveTargetPosition)), t4.range.end = e4.splitPosition.clone(), t4.range.end.stickiness = "toPrevious", [t4, n3];
        }
        return t4.range = t4.range._getTransformedBySplitOperation(e4), [t4];
      }), iu(Gh2, Zh2, (t4, e4) => {
        const n3 = [t4];
        if (t4.shouldReceiveAttributes && t4.position.hasSameParentAs(e4.range.start) && e4.range.containsPosition(t4.position)) {
          const o3 = hu(t4, e4.key, e4.newValue);
          o3 && n3.push(o3);
        }
        return n3;
      }), iu(Gh2, Gh2, (t4, e4, n3) => (t4.position.isEqual(e4.position) && n3.aIsStrong || (t4.position = t4.position._getTransformedByInsertOperation(e4)), [t4])), iu(Gh2, qh2, (t4, e4) => (t4.position = t4.position._getTransformedByMoveOperation(e4), [t4])), iu(Gh2, Wh2, (t4, e4) => (t4.position = t4.position._getTransformedBySplitOperation(e4), [t4])), iu(Gh2, Kh2, (t4, e4) => (t4.position = t4.position._getTransformedByMergeOperation(e4), [t4])), iu(Yh2, Gh2, (t4, e4) => (t4.oldRange && (t4.oldRange = t4.oldRange._getTransformedByInsertOperation(e4)[0]), t4.newRange && (t4.newRange = t4.newRange._getTransformedByInsertOperation(e4)[0]), [t4])), iu(Yh2, Yh2, (t4, e4, n3) => {
        if (t4.name == e4.name) {
          if (!n3.aIsStrong)
            return [new Qh2(0)];
          t4.oldRange = e4.newRange ? e4.newRange.clone() : null;
        }
        return [t4];
      }), iu(Yh2, Kh2, (t4, e4) => (t4.oldRange && (t4.oldRange = t4.oldRange._getTransformedByMergeOperation(e4)), t4.newRange && (t4.newRange = t4.newRange._getTransformedByMergeOperation(e4)), [t4])), iu(Yh2, qh2, (t4, e4, n3) => {
        if (t4.oldRange && (t4.oldRange = Wl._createFromRanges(t4.oldRange._getTransformedByMoveOperation(e4))), t4.newRange) {
          if (n3.abRelation) {
            const o3 = Wl._createFromRanges(t4.newRange._getTransformedByMoveOperation(e4));
            if ("left" == n3.abRelation.side && e4.targetPosition.isEqual(t4.newRange.start))
              return t4.newRange.end = o3.end, t4.newRange.start.path = n3.abRelation.path, [t4];
            if ("right" == n3.abRelation.side && e4.targetPosition.isEqual(t4.newRange.end))
              return t4.newRange.start = o3.start, t4.newRange.end.path = n3.abRelation.path, [t4];
          }
          t4.newRange = Wl._createFromRanges(t4.newRange._getTransformedByMoveOperation(e4));
        }
        return [t4];
      }), iu(Yh2, Wh2, (t4, e4, n3) => {
        if (t4.oldRange && (t4.oldRange = t4.oldRange._getTransformedBySplitOperation(e4)), t4.newRange) {
          if (n3.abRelation) {
            const o3 = t4.newRange._getTransformedBySplitOperation(e4);
            return t4.newRange.start.isEqual(e4.splitPosition) && n3.abRelation.wasStartBeforeMergedElement ? t4.newRange.start = Fl._createAt(e4.insertionPosition) : t4.newRange.start.isEqual(e4.splitPosition) && !n3.abRelation.wasInLeftElement && (t4.newRange.start = Fl._createAt(e4.moveTargetPosition)), t4.newRange.end.isEqual(e4.splitPosition) && n3.abRelation.wasInRightElement ? t4.newRange.end = Fl._createAt(e4.moveTargetPosition) : t4.newRange.end.isEqual(e4.splitPosition) && n3.abRelation.wasEndBeforeMergedElement ? t4.newRange.end = Fl._createAt(e4.insertionPosition) : t4.newRange.end = o3.end, [t4];
          }
          t4.newRange = t4.newRange._getTransformedBySplitOperation(e4);
        }
        return [t4];
      }), iu(Kh2, Gh2, (t4, e4) => (t4.sourcePosition.hasSameParentAs(e4.position) && (t4.howMany += e4.howMany), t4.sourcePosition = t4.sourcePosition._getTransformedByInsertOperation(e4), t4.targetPosition = t4.targetPosition._getTransformedByInsertOperation(e4), [t4])), iu(Kh2, Kh2, (t4, e4, n3) => {
        if (t4.sourcePosition.isEqual(e4.sourcePosition) && t4.targetPosition.isEqual(e4.targetPosition)) {
          if (n3.bWasUndone) {
            const n4 = e4.graveyardPosition.path.slice();
            return n4.push(0), t4.sourcePosition = new Fl(e4.graveyardPosition.root, n4), t4.howMany = 0, [t4];
          }
          return [new Qh2(0)];
        }
        if (t4.sourcePosition.isEqual(e4.sourcePosition) && !t4.targetPosition.isEqual(e4.targetPosition) && !n3.bWasUndone && "splitAtSource" != n3.abRelation) {
          const o3 = "$graveyard" == t4.targetPosition.root.rootName, i3 = "$graveyard" == e4.targetPosition.root.rootName;
          if (i3 && !o3 || !(o3 && !i3) && n3.aIsStrong) {
            const n4 = e4.targetPosition._getTransformedByMergeOperation(e4), o4 = t4.targetPosition._getTransformedByMergeOperation(e4);
            return [new qh2(n4, t4.howMany, o4, 0)];
          }
          return [new Qh2(0)];
        }
        return t4.sourcePosition.hasSameParentAs(e4.targetPosition) && (t4.howMany += e4.howMany), t4.sourcePosition = t4.sourcePosition._getTransformedByMergeOperation(e4), t4.targetPosition = t4.targetPosition._getTransformedByMergeOperation(e4), t4.graveyardPosition.isEqual(e4.graveyardPosition) && n3.aIsStrong || (t4.graveyardPosition = t4.graveyardPosition._getTransformedByMergeOperation(e4)), [t4];
      }), iu(Kh2, qh2, (t4, e4, n3) => {
        const o3 = Wl._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
        return "remove" == e4.type && !n3.bWasUndone && !n3.forceWeakRemove && t4.deletionPosition.hasSameParentAs(e4.sourcePosition) && o3.containsPosition(t4.sourcePosition) ? [new Qh2(0)] : (t4.sourcePosition.hasSameParentAs(e4.targetPosition) && (t4.howMany += e4.howMany), t4.sourcePosition.hasSameParentAs(e4.sourcePosition) && (t4.howMany -= e4.howMany), t4.sourcePosition = t4.sourcePosition._getTransformedByMoveOperation(e4), t4.targetPosition = t4.targetPosition._getTransformedByMoveOperation(e4), t4.graveyardPosition.isEqual(e4.targetPosition) || (t4.graveyardPosition = t4.graveyardPosition._getTransformedByMoveOperation(e4)), [t4]);
      }), iu(Kh2, Wh2, (t4, e4, n3) => {
        if (e4.graveyardPosition && (t4.graveyardPosition = t4.graveyardPosition._getTransformedByDeletion(e4.graveyardPosition, 1), t4.deletionPosition.isEqual(e4.graveyardPosition) && (t4.howMany = e4.howMany)), t4.targetPosition.isEqual(e4.splitPosition)) {
          const o3 = 0 != e4.howMany, i3 = e4.graveyardPosition && t4.deletionPosition.isEqual(e4.graveyardPosition);
          if (o3 || i3 || "mergeTargetNotMoved" == n3.abRelation)
            return t4.sourcePosition = t4.sourcePosition._getTransformedBySplitOperation(e4), [t4];
        }
        if (t4.sourcePosition.isEqual(e4.splitPosition)) {
          if ("mergeSourceNotMoved" == n3.abRelation)
            return t4.howMany = 0, t4.targetPosition = t4.targetPosition._getTransformedBySplitOperation(e4), [t4];
          if ("mergeSameElement" == n3.abRelation || t4.sourcePosition.offset > 0)
            return t4.sourcePosition = e4.moveTargetPosition.clone(), t4.targetPosition = t4.targetPosition._getTransformedBySplitOperation(e4), [t4];
        }
        return t4.sourcePosition.hasSameParentAs(e4.splitPosition) && (t4.howMany = e4.splitPosition.offset), t4.sourcePosition = t4.sourcePosition._getTransformedBySplitOperation(e4), t4.targetPosition = t4.targetPosition._getTransformedBySplitOperation(e4), [t4];
      }), iu(qh2, Gh2, (t4, e4) => {
        const n3 = Wl._createFromPositionAndShift(t4.sourcePosition, t4.howMany)._getTransformedByInsertOperation(e4, false)[0];
        return t4.sourcePosition = n3.start, t4.howMany = n3.end.offset - n3.start.offset, t4.targetPosition.isEqual(e4.position) || (t4.targetPosition = t4.targetPosition._getTransformedByInsertOperation(e4)), [t4];
      }), iu(qh2, qh2, (t4, e4, n3) => {
        const o3 = Wl._createFromPositionAndShift(t4.sourcePosition, t4.howMany), i3 = Wl._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
        let r3, s3 = n3.aIsStrong, a3 = !n3.aIsStrong;
        if ("insertBefore" == n3.abRelation || "insertAfter" == n3.baRelation ? a3 = true : "insertAfter" != n3.abRelation && "insertBefore" != n3.baRelation || (a3 = false), r3 = t4.targetPosition.isEqual(e4.targetPosition) && a3 ? t4.targetPosition._getTransformedByDeletion(e4.sourcePosition, e4.howMany) : t4.targetPosition._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), uu(t4, e4) && uu(e4, t4))
          return [e4.getReversed()];
        if (o3.containsPosition(e4.targetPosition) && o3.containsRange(i3, true))
          return o3.start = o3.start._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), o3.end = o3.end._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), gu([o3], r3);
        if (i3.containsPosition(t4.targetPosition) && i3.containsRange(o3, true))
          return o3.start = o3.start._getCombined(e4.sourcePosition, e4.getMovedRangeStart()), o3.end = o3.end._getCombined(e4.sourcePosition, e4.getMovedRangeStart()), gu([o3], r3);
        const c3 = tt2(t4.sourcePosition.getParentPath(), e4.sourcePosition.getParentPath());
        if ("prefix" == c3 || "extension" == c3)
          return o3.start = o3.start._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), o3.end = o3.end._getTransformedByMove(e4.sourcePosition, e4.targetPosition, e4.howMany), gu([o3], r3);
        "remove" != t4.type || "remove" == e4.type || n3.aWasUndone || n3.forceWeakRemove ? "remove" == t4.type || "remove" != e4.type || n3.bWasUndone || n3.forceWeakRemove || (s3 = false) : s3 = true;
        const l3 = [], d3 = o3.getDifference(i3);
        for (const t5 of d3) {
          t5.start = t5.start._getTransformedByDeletion(e4.sourcePosition, e4.howMany), t5.end = t5.end._getTransformedByDeletion(e4.sourcePosition, e4.howMany);
          const n4 = "same" == tt2(t5.start.getParentPath(), e4.getMovedRangeStart().getParentPath()), o4 = t5._getTransformedByInsertion(e4.getMovedRangeStart(), e4.howMany, n4);
          l3.push(...o4);
        }
        const h3 = o3.getIntersection(i3);
        return null !== h3 && s3 && (h3.start = h3.start._getCombined(e4.sourcePosition, e4.getMovedRangeStart()), h3.end = h3.end._getCombined(e4.sourcePosition, e4.getMovedRangeStart()), 0 === l3.length ? l3.push(h3) : 1 == l3.length ? i3.start.isBefore(o3.start) || i3.start.isEqual(o3.start) ? l3.unshift(h3) : l3.push(h3) : l3.splice(1, 0, h3)), 0 === l3.length ? [new Qh2(t4.baseVersion)] : gu(l3, r3);
      }), iu(qh2, Wh2, (t4, e4, n3) => {
        let o3 = t4.targetPosition.clone();
        t4.targetPosition.isEqual(e4.insertionPosition) && e4.graveyardPosition && "moveTargetAfter" != n3.abRelation || (o3 = t4.targetPosition._getTransformedBySplitOperation(e4));
        const i3 = Wl._createFromPositionAndShift(t4.sourcePosition, t4.howMany);
        if (i3.end.isEqual(e4.insertionPosition))
          return e4.graveyardPosition || t4.howMany++, t4.targetPosition = o3, [t4];
        if (i3.start.hasSameParentAs(e4.splitPosition) && i3.containsPosition(e4.splitPosition)) {
          let t5 = new Wl(e4.splitPosition, i3.end);
          t5 = t5._getTransformedBySplitOperation(e4);
          return gu([new Wl(i3.start, e4.splitPosition), t5], o3);
        }
        t4.targetPosition.isEqual(e4.splitPosition) && "insertAtSource" == n3.abRelation && (o3 = e4.moveTargetPosition), t4.targetPosition.isEqual(e4.insertionPosition) && "insertBetween" == n3.abRelation && (o3 = t4.targetPosition);
        const r3 = [i3._getTransformedBySplitOperation(e4)];
        if (e4.graveyardPosition) {
          const o4 = i3.start.isEqual(e4.graveyardPosition) || i3.containsPosition(e4.graveyardPosition);
          t4.howMany > 1 && o4 && !n3.aWasUndone && r3.push(Wl._createFromPositionAndShift(e4.insertionPosition, 1));
        }
        return gu(r3, o3);
      }), iu(qh2, Kh2, (t4, e4, n3) => {
        const o3 = Wl._createFromPositionAndShift(t4.sourcePosition, t4.howMany);
        if (e4.deletionPosition.hasSameParentAs(t4.sourcePosition) && o3.containsPosition(e4.sourcePosition)) {
          if ("remove" != t4.type || n3.forceWeakRemove) {
            if (1 == t4.howMany)
              return n3.bWasUndone ? (t4.sourcePosition = e4.graveyardPosition.clone(), t4.targetPosition = t4.targetPosition._getTransformedByMergeOperation(e4), [t4]) : [new Qh2(0)];
          } else if (!n3.aWasUndone) {
            const n4 = [];
            let o4 = e4.graveyardPosition.clone(), i4 = e4.targetPosition._getTransformedByMergeOperation(e4);
            t4.howMany > 1 && (n4.push(new qh2(t4.sourcePosition, t4.howMany - 1, t4.targetPosition, 0)), o4 = o4._getTransformedByMove(t4.sourcePosition, t4.targetPosition, t4.howMany - 1), i4 = i4._getTransformedByMove(t4.sourcePosition, t4.targetPosition, t4.howMany - 1));
            const r3 = e4.deletionPosition._getCombined(t4.sourcePosition, t4.targetPosition), s3 = new qh2(o4, 1, r3, 0), a3 = s3.getMovedRangeStart().path.slice();
            a3.push(0);
            const c3 = new Fl(s3.targetPosition.root, a3);
            i4 = i4._getTransformedByMove(o4, r3, 1);
            const l3 = new qh2(i4, e4.howMany, c3, 0);
            return n4.push(s3), n4.push(l3), n4;
          }
        }
        const i3 = Wl._createFromPositionAndShift(t4.sourcePosition, t4.howMany)._getTransformedByMergeOperation(e4);
        return t4.sourcePosition = i3.start, t4.howMany = i3.end.offset - i3.start.offset, t4.targetPosition = t4.targetPosition._getTransformedByMergeOperation(e4), [t4];
      }), iu(Jh2, Gh2, (t4, e4) => (t4.position = t4.position._getTransformedByInsertOperation(e4), [t4])), iu(Jh2, Kh2, (t4, e4) => t4.position.isEqual(e4.deletionPosition) ? (t4.position = e4.graveyardPosition.clone(), t4.position.stickiness = "toNext", [t4]) : (t4.position = t4.position._getTransformedByMergeOperation(e4), [t4])), iu(Jh2, qh2, (t4, e4) => (t4.position = t4.position._getTransformedByMoveOperation(e4), [t4])), iu(Jh2, Jh2, (t4, e4, n3) => {
        if (t4.position.isEqual(e4.position)) {
          if (!n3.aIsStrong)
            return [new Qh2(0)];
          t4.oldName = e4.newName;
        }
        return [t4];
      }), iu(Jh2, Wh2, (t4, e4) => {
        if ("same" == tt2(t4.position.path, e4.splitPosition.getParentPath()) && !e4.graveyardPosition) {
          const e5 = new Jh2(t4.position.getShiftedBy(1), t4.oldName, t4.newName, 0);
          return [t4, e5];
        }
        return t4.position = t4.position._getTransformedBySplitOperation(e4), [t4];
      }), iu(Xh2, Xh2, (t4, e4, n3) => {
        if (t4.root === e4.root && t4.key === e4.key) {
          if (!n3.aIsStrong || t4.newValue === e4.newValue)
            return [new Qh2(0)];
          t4.oldValue = e4.newValue;
        }
        return [t4];
      }), iu(tu, tu, (t4, e4) => t4.rootName === e4.rootName && t4.isAdd === e4.isAdd ? [new Qh2(0)] : [t4]), iu(Wh2, Gh2, (t4, e4) => (t4.splitPosition.hasSameParentAs(e4.position) && t4.splitPosition.offset < e4.position.offset && (t4.howMany += e4.howMany), t4.splitPosition = t4.splitPosition._getTransformedByInsertOperation(e4), t4.insertionPosition = t4.insertionPosition._getTransformedByInsertOperation(e4), [t4])), iu(Wh2, Kh2, (t4, e4, n3) => {
        if (!t4.graveyardPosition && !n3.bWasUndone && t4.splitPosition.hasSameParentAs(e4.sourcePosition)) {
          const n4 = e4.graveyardPosition.path.slice();
          n4.push(0);
          const o3 = new Fl(e4.graveyardPosition.root, n4), i3 = Wh2.getInsertionPosition(new Fl(e4.graveyardPosition.root, n4)), r3 = new Wh2(o3, 0, i3, null, 0);
          return t4.splitPosition = t4.splitPosition._getTransformedByMergeOperation(e4), t4.insertionPosition = Wh2.getInsertionPosition(t4.splitPosition), t4.graveyardPosition = r3.insertionPosition.clone(), t4.graveyardPosition.stickiness = "toNext", [r3, t4];
        }
        return t4.splitPosition.hasSameParentAs(e4.deletionPosition) && !t4.splitPosition.isAfter(e4.deletionPosition) && t4.howMany--, t4.splitPosition.hasSameParentAs(e4.targetPosition) && (t4.howMany += e4.howMany), t4.splitPosition = t4.splitPosition._getTransformedByMergeOperation(e4), t4.insertionPosition = Wh2.getInsertionPosition(t4.splitPosition), t4.graveyardPosition && (t4.graveyardPosition = t4.graveyardPosition._getTransformedByMergeOperation(e4)), [t4];
      }), iu(Wh2, qh2, (t4, e4, n3) => {
        const o3 = Wl._createFromPositionAndShift(e4.sourcePosition, e4.howMany);
        if (t4.graveyardPosition) {
          const i4 = o3.start.isEqual(t4.graveyardPosition) || o3.containsPosition(t4.graveyardPosition);
          if (!n3.bWasUndone && i4) {
            const n4 = t4.splitPosition._getTransformedByMoveOperation(e4), o4 = t4.graveyardPosition._getTransformedByMoveOperation(e4), i5 = o4.path.slice();
            i5.push(0);
            const r3 = new Fl(o4.root, i5);
            return [new qh2(n4, t4.howMany, r3, 0)];
          }
          t4.graveyardPosition = t4.graveyardPosition._getTransformedByMoveOperation(e4);
        }
        const i3 = t4.splitPosition.isEqual(e4.targetPosition);
        if (i3 && ("insertAtSource" == n3.baRelation || "splitBefore" == n3.abRelation))
          return t4.howMany += e4.howMany, t4.splitPosition = t4.splitPosition._getTransformedByDeletion(e4.sourcePosition, e4.howMany), t4.insertionPosition = Wh2.getInsertionPosition(t4.splitPosition), [t4];
        if (i3 && n3.abRelation && n3.abRelation.howMany) {
          const { howMany: e5, offset: o4 } = n3.abRelation;
          return t4.howMany += e5, t4.splitPosition = t4.splitPosition.getShiftedBy(o4), [t4];
        }
        if (t4.splitPosition.hasSameParentAs(e4.sourcePosition) && o3.containsPosition(t4.splitPosition)) {
          const n4 = e4.howMany - (t4.splitPosition.offset - e4.sourcePosition.offset);
          return t4.howMany -= n4, t4.splitPosition.hasSameParentAs(e4.targetPosition) && t4.splitPosition.offset < e4.targetPosition.offset && (t4.howMany += e4.howMany), t4.splitPosition = e4.sourcePosition.clone(), t4.insertionPosition = Wh2.getInsertionPosition(t4.splitPosition), [t4];
        }
        return e4.sourcePosition.isEqual(e4.targetPosition) || (t4.splitPosition.hasSameParentAs(e4.sourcePosition) && t4.splitPosition.offset <= e4.sourcePosition.offset && (t4.howMany -= e4.howMany), t4.splitPosition.hasSameParentAs(e4.targetPosition) && t4.splitPosition.offset < e4.targetPosition.offset && (t4.howMany += e4.howMany)), t4.splitPosition.stickiness = "toNone", t4.splitPosition = t4.splitPosition._getTransformedByMoveOperation(e4), t4.splitPosition.stickiness = "toNext", t4.graveyardPosition ? t4.insertionPosition = t4.insertionPosition._getTransformedByMoveOperation(e4) : t4.insertionPosition = Wh2.getInsertionPosition(t4.splitPosition), [t4];
      }), iu(Wh2, Wh2, (t4, e4, n3) => {
        if (t4.splitPosition.isEqual(e4.splitPosition)) {
          if (!t4.graveyardPosition && !e4.graveyardPosition)
            return [new Qh2(0)];
          if (t4.graveyardPosition && e4.graveyardPosition && t4.graveyardPosition.isEqual(e4.graveyardPosition))
            return [new Qh2(0)];
          if ("splitBefore" == n3.abRelation)
            return t4.howMany = 0, t4.graveyardPosition = t4.graveyardPosition._getTransformedBySplitOperation(e4), [t4];
        }
        if (t4.graveyardPosition && e4.graveyardPosition && t4.graveyardPosition.isEqual(e4.graveyardPosition)) {
          const o3 = "$graveyard" == t4.splitPosition.root.rootName, i3 = "$graveyard" == e4.splitPosition.root.rootName;
          if (i3 && !o3 || !(o3 && !i3) && n3.aIsStrong) {
            const n4 = [];
            return e4.howMany && n4.push(new qh2(e4.moveTargetPosition, e4.howMany, e4.splitPosition, 0)), t4.howMany && n4.push(new qh2(t4.splitPosition, t4.howMany, t4.moveTargetPosition, 0)), n4;
          }
          return [new Qh2(0)];
        }
        if (t4.graveyardPosition && (t4.graveyardPosition = t4.graveyardPosition._getTransformedBySplitOperation(e4)), t4.splitPosition.isEqual(e4.insertionPosition) && "splitBefore" == n3.abRelation)
          return t4.howMany++, [t4];
        if (e4.splitPosition.isEqual(t4.insertionPosition) && "splitBefore" == n3.baRelation) {
          const n4 = e4.insertionPosition.path.slice();
          n4.push(0);
          const o3 = new Fl(e4.insertionPosition.root, n4);
          return [t4, new qh2(t4.insertionPosition, 1, o3, 0)];
        }
        return t4.splitPosition.hasSameParentAs(e4.splitPosition) && t4.splitPosition.offset < e4.splitPosition.offset && (t4.howMany -= e4.howMany), t4.splitPosition = t4.splitPosition._getTransformedBySplitOperation(e4), t4.insertionPosition = Wh2.getInsertionPosition(t4.splitPosition), [t4];
      });
      class pu extends M2(Fl) {
        constructor(t4, e4, n3 = "toNone") {
          if (super(t4, e4, n3), !this.root.is("rootElement"))
            throw new A2("model-liveposition-root-not-rootelement", t4);
          mu.call(this);
        }
        detach() {
          this.stopListening();
        }
        toPosition() {
          return new Fl(this.root, this.path.slice(), this.stickiness);
        }
        static fromPosition(t4, e4) {
          return new this(t4.root, t4.path.slice(), e4 || t4.stickiness);
        }
      }
      function mu() {
        this.listenTo(this.root.document.model, "applyOperation", (t4, e4) => {
          const n3 = e4[0];
          n3.isDocumentOperation && fu.call(this, n3);
        }, { priority: "low" });
      }
      function fu(t4) {
        const e4 = this.getTransformedByOperation(t4);
        if (!this.isEqual(e4)) {
          const t5 = this.toPosition();
          this.path = e4.path, this.root = e4.root, this.fire("change", t5);
        }
      }
      pu.prototype.is = function(t4) {
        return "livePosition" === t4 || "model:livePosition" === t4 || "position" == t4 || "model:position" === t4;
      };
      class ku {
        constructor(t4 = {}) {
          "string" == typeof t4 && (t4 = "transparent" === t4 ? { isUndoable: false } : {}, C2("batch-constructor-deprecated-string-type"));
          const { isUndoable: e4 = true, isLocal: n3 = true, isUndo: o3 = false, isTyping: i3 = false } = t4;
          this.operations = [], this.isUndoable = e4, this.isLocal = n3, this.isUndo = o3, this.isTyping = i3;
        }
        get type() {
          return C2("batch-type-deprecated"), "default";
        }
        get baseVersion() {
          for (const t4 of this.operations)
            if (null !== t4.baseVersion)
              return t4.baseVersion;
          return null;
        }
        addOperation(t4) {
          return t4.batch = this, this.operations.push(t4), t4;
        }
      }
      var bu = Object.defineProperty, wu = Object.defineProperties, Au = Object.getOwnPropertyDescriptors, Cu = Object.getOwnPropertySymbols, _u = Object.prototype.hasOwnProperty, vu = Object.prototype.propertyIsEnumerable, yu = (t4, e4, n3) => e4 in t4 ? bu(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, xu = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          _u.call(e4, n3) && yu(t4, n3, e4[n3]);
        if (Cu)
          for (var n3 of Cu(e4))
            vu.call(e4, n3) && yu(t4, n3, e4[n3]);
        return t4;
      };
      class Eu {
        constructor(t4) {
          this._changesInElement = /* @__PURE__ */ new Map(), this._elementSnapshots = /* @__PURE__ */ new Map(), this._changedMarkers = /* @__PURE__ */ new Map(), this._changedRoots = /* @__PURE__ */ new Map(), this._changeCount = 0, this._cachedChanges = null, this._cachedChangesWithGraveyard = null, this._refreshedItems = /* @__PURE__ */ new Set(), this._markerCollection = t4;
        }
        get isEmpty() {
          return 0 == this._changesInElement.size && 0 == this._changedMarkers.size && 0 == this._changedRoots.size;
        }
        bufferOperation(t4) {
          const e4 = t4;
          switch (e4.type) {
            case "insert":
              if (this._isInInsertedElement(e4.position.parent))
                return;
              this._markInsert(e4.position.parent, e4.position.offset, e4.nodes.maxOffset);
              break;
            case "addAttribute":
            case "removeAttribute":
            case "changeAttribute":
              for (const t5 of e4.range.getItems({ shallow: true }))
                this._isInInsertedElement(t5.parent) || this._markAttribute(t5);
              break;
            case "remove":
            case "move":
            case "reinsert": {
              if (e4.sourcePosition.isEqual(e4.targetPosition) || e4.sourcePosition.getShiftedBy(e4.howMany).isEqual(e4.targetPosition))
                return;
              const t5 = this._isInInsertedElement(e4.sourcePosition.parent), n3 = this._isInInsertedElement(e4.targetPosition.parent);
              t5 || this._markRemove(e4.sourcePosition.parent, e4.sourcePosition.offset, e4.howMany), n3 || this._markInsert(e4.targetPosition.parent, e4.getMovedRangeStart().offset, e4.howMany);
              break;
            }
            case "rename": {
              if (this._isInInsertedElement(e4.position.parent))
                return;
              this._markRemove(e4.position.parent, e4.position.offset, 1), this._markInsert(e4.position.parent, e4.position.offset, 1);
              const t5 = Wl._createFromPositionAndShift(e4.position, 1);
              for (const e5 of this._markerCollection.getMarkersIntersectingRange(t5)) {
                const t6 = e5.getData();
                this.bufferMarkerChange(e5.name, t6, t6);
              }
              break;
            }
            case "split": {
              const t5 = e4.splitPosition.parent;
              this._isInInsertedElement(t5) || this._markRemove(t5, e4.splitPosition.offset, e4.howMany), this._isInInsertedElement(e4.insertionPosition.parent) || this._markInsert(e4.insertionPosition.parent, e4.insertionPosition.offset, 1), e4.graveyardPosition && this._markRemove(e4.graveyardPosition.parent, e4.graveyardPosition.offset, 1);
              break;
            }
            case "merge": {
              const t5 = e4.sourcePosition.parent;
              this._isInInsertedElement(t5.parent) || this._markRemove(t5.parent, t5.startOffset, 1);
              const n3 = e4.graveyardPosition.parent;
              this._markInsert(n3, e4.graveyardPosition.offset, 1);
              const o3 = e4.targetPosition.parent;
              this._isInInsertedElement(o3) || this._markInsert(o3, e4.targetPosition.offset, t5.maxOffset);
              break;
            }
            case "detachRoot":
            case "addRoot": {
              const t5 = e4.affectedSelectable;
              if (!t5._isLoaded)
                return;
              if (t5.isAttached() == e4.isAdd)
                return;
              this._bufferRootStateChange(e4.rootName, e4.isAdd);
              break;
            }
            case "addRootAttribute":
            case "removeRootAttribute":
            case "changeRootAttribute": {
              if (!e4.root._isLoaded)
                return;
              const t5 = e4.root.rootName;
              this._bufferRootAttributeChange(t5, e4.key, e4.oldValue, e4.newValue);
              break;
            }
          }
          this._cachedChanges = null;
        }
        bufferMarkerChange(t4, e4, n3) {
          e4.range && e4.range.root.is("rootElement") && !e4.range.root._isLoaded && (e4.range = null), n3.range && n3.range.root.is("rootElement") && !n3.range.root._isLoaded && (n3.range = null);
          let o3 = this._changedMarkers.get(t4);
          o3 ? o3.newMarkerData = n3 : (o3 = { newMarkerData: n3, oldMarkerData: e4 }, this._changedMarkers.set(t4, o3)), null == o3.oldMarkerData.range && null == n3.range && this._changedMarkers.delete(t4);
        }
        getMarkersToRemove() {
          const t4 = [];
          for (const [e4, n3] of this._changedMarkers)
            null != n3.oldMarkerData.range && t4.push({ name: e4, range: n3.oldMarkerData.range });
          return t4;
        }
        getMarkersToAdd() {
          const t4 = [];
          for (const [e4, n3] of this._changedMarkers)
            null != n3.newMarkerData.range && t4.push({ name: e4, range: n3.newMarkerData.range });
          return t4;
        }
        getChangedMarkers() {
          return Array.from(this._changedMarkers).map(([t4, e4]) => ({ name: t4, data: { oldRange: e4.oldMarkerData.range, newRange: e4.newMarkerData.range } }));
        }
        hasDataChanges() {
          if (this._changesInElement.size > 0)
            return true;
          if (this._changedRoots.size > 0)
            return true;
          for (const { newMarkerData: t4, oldMarkerData: e4 } of this._changedMarkers.values()) {
            if (t4.affectsData !== e4.affectsData)
              return true;
            if (t4.affectsData) {
              const n3 = t4.range && !e4.range, o3 = !t4.range && e4.range, i3 = t4.range && e4.range && !t4.range.isEqual(e4.range);
              if (n3 || o3 || i3)
                return true;
            }
          }
          return false;
        }
        getChanges(t4 = {}) {
          if (this._cachedChanges)
            return t4.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
          let e4 = [];
          for (const t5 of this._changesInElement.keys()) {
            const n3 = this._changesInElement.get(t5).sort((t6, e5) => t6.offset === e5.offset ? t6.type != e5.type ? "remove" == t6.type ? -1 : 1 : 0 : t6.offset < e5.offset ? -1 : 1), o3 = this._elementSnapshots.get(t5), i3 = Du(t5.getChildren()), r3 = Su(o3.length, n3);
            let s3 = 0, a3 = 0;
            for (const n4 of r3)
              if ("i" === n4)
                e4.push(this._getInsertDiff(t5, s3, i3[s3])), s3++;
              else if ("r" === n4)
                e4.push(this._getRemoveDiff(t5, s3, o3[a3])), a3++;
              else if ("a" === n4) {
                const n5 = i3[s3].attributes, r4 = o3[a3].attributes;
                let c3;
                if ("$text" == i3[s3].name)
                  c3 = new Wl(Fl._createAt(t5, s3), Fl._createAt(t5, s3 + 1));
                else {
                  const e5 = t5.offsetToIndex(s3);
                  c3 = new Wl(Fl._createAt(t5, s3), Fl._createAt(t5.getChild(e5), 0));
                }
                e4.push(...this._getAttributesDiff(c3, r4, n5)), s3++, a3++;
              } else
                s3++, a3++;
          }
          e4.sort((t5, e5) => t5.position.root != e5.position.root ? t5.position.root.rootName < e5.position.root.rootName ? -1 : 1 : t5.position.isEqual(e5.position) ? t5.changeCount - e5.changeCount : t5.position.isBefore(e5.position) ? -1 : 1);
          for (let t5 = 1, n3 = 0; t5 < e4.length; t5++) {
            const o3 = e4[n3], i3 = e4[t5], r3 = "remove" == o3.type && "remove" == i3.type && "$text" == o3.name && "$text" == i3.name && o3.position.isEqual(i3.position), s3 = "insert" == o3.type && "insert" == i3.type && "$text" == o3.name && "$text" == i3.name && o3.position.parent == i3.position.parent && o3.position.offset + o3.length == i3.position.offset, a3 = "attribute" == o3.type && "attribute" == i3.type && o3.position.parent == i3.position.parent && o3.range.isFlat && i3.range.isFlat && o3.position.offset + o3.length == i3.position.offset && o3.attributeKey == i3.attributeKey && o3.attributeOldValue == i3.attributeOldValue && o3.attributeNewValue == i3.attributeNewValue;
            r3 || s3 || a3 ? (o3.length++, a3 && (o3.range.end = o3.range.end.getShiftedBy(1)), e4[t5] = null) : n3 = t5;
          }
          e4 = e4.filter((t5) => t5);
          for (const t5 of e4)
            delete t5.changeCount, "attribute" == t5.type && (delete t5.position, delete t5.length);
          return this._changeCount = 0, this._cachedChangesWithGraveyard = e4, this._cachedChanges = e4.filter(Iu), t4.includeChangesInGraveyard ? this._cachedChangesWithGraveyard.slice() : this._cachedChanges.slice();
        }
        getChangedRoots() {
          return Array.from(this._changedRoots.values()).map((t4) => {
            const e4 = xu({}, t4);
            return void 0 !== e4.state && delete e4.attributes, e4;
          });
        }
        getRefreshedItems() {
          return new Set(this._refreshedItems);
        }
        reset() {
          this._changesInElement.clear(), this._elementSnapshots.clear(), this._changedMarkers.clear(), this._changedRoots.clear(), this._refreshedItems = /* @__PURE__ */ new Set(), this._cachedChanges = null;
        }
        _bufferRootStateChange(t4, e4) {
          if (!this._changedRoots.has(t4))
            return void this._changedRoots.set(t4, { name: t4, state: e4 ? "attached" : "detached" });
          const n3 = this._changedRoots.get(t4);
          void 0 !== n3.state ? (delete n3.state, void 0 === n3.attributes && this._changedRoots.delete(t4)) : n3.state = e4 ? "attached" : "detached";
        }
        _bufferRootAttributeChange(t4, e4, n3, o3) {
          const i3 = this._changedRoots.get(t4) || { name: t4 }, r3 = i3.attributes || {};
          if (r3[e4]) {
            const t5 = r3[e4];
            o3 === t5.oldValue ? delete r3[e4] : t5.newValue = o3;
          } else
            r3[e4] = { oldValue: n3, newValue: o3 };
          0 === Object.entries(r3).length ? (delete i3.attributes, void 0 === i3.state && this._changedRoots.delete(t4)) : (i3.attributes = r3, this._changedRoots.set(t4, i3));
        }
        _refreshItem(t4) {
          if (this._isInInsertedElement(t4.parent))
            return;
          this._markRemove(t4.parent, t4.startOffset, t4.offsetSize), this._markInsert(t4.parent, t4.startOffset, t4.offsetSize), this._refreshedItems.add(t4);
          const e4 = Wl._createOn(t4);
          for (const t5 of this._markerCollection.getMarkersIntersectingRange(e4)) {
            const e5 = t5.getData();
            this.bufferMarkerChange(t5.name, e5, e5);
          }
          this._cachedChanges = null;
        }
        _bufferRootLoad(t4) {
          if (t4.isAttached()) {
            this._bufferRootStateChange(t4.rootName, true), this._markInsert(t4, 0, t4.maxOffset);
            for (const e5 of t4.getAttributeKeys())
              this._bufferRootAttributeChange(t4.rootName, e5, null, t4.getAttribute(e5));
            for (const n3 of this._markerCollection)
              if (n3.getRange().root == t4) {
                const t5 = n3.getData();
                this.bufferMarkerChange(n3.name, (e4 = xu({}, t5), wu(e4, Au({ range: null }))), t5);
              }
            var e4;
          }
        }
        _markInsert(t4, e4, n3) {
          if (t4.root.is("rootElement") && !t4.root._isLoaded)
            return;
          const o3 = { type: "insert", offset: e4, howMany: n3, count: this._changeCount++ };
          this._markChange(t4, o3);
        }
        _markRemove(t4, e4, n3) {
          if (t4.root.is("rootElement") && !t4.root._isLoaded)
            return;
          const o3 = { type: "remove", offset: e4, howMany: n3, count: this._changeCount++ };
          this._markChange(t4, o3), this._removeAllNestedChanges(t4, e4, n3);
        }
        _markAttribute(t4) {
          if (t4.root.is("rootElement") && !t4.root._isLoaded)
            return;
          const e4 = { type: "attribute", offset: t4.startOffset, howMany: t4.offsetSize, count: this._changeCount++ };
          this._markChange(t4.parent, e4);
        }
        _markChange(t4, e4) {
          this._makeSnapshot(t4);
          const n3 = this._getChangesForElement(t4);
          this._handleChange(e4, n3), n3.push(e4);
          for (let t5 = 0; t5 < n3.length; t5++)
            n3[t5].howMany < 1 && (n3.splice(t5, 1), t5--);
        }
        _getChangesForElement(t4) {
          let e4;
          return this._changesInElement.has(t4) ? e4 = this._changesInElement.get(t4) : (e4 = [], this._changesInElement.set(t4, e4)), e4;
        }
        _makeSnapshot(t4) {
          this._elementSnapshots.has(t4) || this._elementSnapshots.set(t4, Du(t4.getChildren()));
        }
        _handleChange(t4, e4) {
          t4.nodesToHandle = t4.howMany;
          for (const n3 of e4) {
            const o3 = t4.offset + t4.howMany, i3 = n3.offset + n3.howMany;
            if ("insert" == t4.type && ("insert" == n3.type && (t4.offset <= n3.offset ? n3.offset += t4.howMany : t4.offset < i3 && (n3.howMany += t4.nodesToHandle, t4.nodesToHandle = 0)), "remove" == n3.type && t4.offset < n3.offset && (n3.offset += t4.howMany), "attribute" == n3.type)) {
              if (t4.offset <= n3.offset)
                n3.offset += t4.howMany;
              else if (t4.offset < i3) {
                const i4 = n3.howMany;
                n3.howMany = t4.offset - n3.offset, e4.unshift({ type: "attribute", offset: o3, howMany: i4 - n3.howMany, count: this._changeCount++ });
              }
            }
            if ("remove" == t4.type) {
              if ("insert" == n3.type) {
                if (o3 <= n3.offset)
                  n3.offset -= t4.howMany;
                else if (o3 <= i3)
                  if (t4.offset < n3.offset) {
                    const e5 = o3 - n3.offset;
                    n3.offset = t4.offset, n3.howMany -= e5, t4.nodesToHandle -= e5;
                  } else
                    n3.howMany -= t4.nodesToHandle, t4.nodesToHandle = 0;
                else if (t4.offset <= n3.offset)
                  t4.nodesToHandle -= n3.howMany, n3.howMany = 0;
                else if (t4.offset < i3) {
                  const e5 = i3 - t4.offset;
                  n3.howMany -= e5, t4.nodesToHandle -= e5;
                }
              }
              if ("remove" == n3.type && (o3 <= n3.offset ? n3.offset -= t4.howMany : t4.offset < n3.offset && (t4.nodesToHandle += n3.howMany, n3.howMany = 0)), "attribute" == n3.type) {
                if (o3 <= n3.offset)
                  n3.offset -= t4.howMany;
                else if (t4.offset < n3.offset) {
                  const e5 = o3 - n3.offset;
                  n3.offset = t4.offset, n3.howMany -= e5;
                } else if (t4.offset < i3)
                  if (o3 <= i3) {
                    const o4 = n3.howMany;
                    n3.howMany = t4.offset - n3.offset;
                    const i4 = o4 - n3.howMany - t4.nodesToHandle;
                    e4.unshift({ type: "attribute", offset: t4.offset, howMany: i4, count: this._changeCount++ });
                  } else
                    n3.howMany -= i3 - t4.offset;
              }
            }
            if ("attribute" == t4.type) {
              if ("insert" == n3.type)
                if (t4.offset < n3.offset && o3 > n3.offset) {
                  if (o3 > i3) {
                    const t5 = { type: "attribute", offset: i3, howMany: o3 - i3, count: this._changeCount++ };
                    this._handleChange(t5, e4), e4.push(t5);
                  }
                  t4.nodesToHandle = n3.offset - t4.offset, t4.howMany = t4.nodesToHandle;
                } else
                  t4.offset >= n3.offset && t4.offset < i3 && (o3 > i3 ? (t4.nodesToHandle = o3 - i3, t4.offset = i3) : t4.nodesToHandle = 0);
              if ("remove" == n3.type && t4.offset < n3.offset && o3 > n3.offset) {
                const i4 = { type: "attribute", offset: n3.offset, howMany: o3 - n3.offset, count: this._changeCount++ };
                this._handleChange(i4, e4), e4.push(i4), t4.nodesToHandle = n3.offset - t4.offset, t4.howMany = t4.nodesToHandle;
              }
              "attribute" == n3.type && (t4.offset >= n3.offset && o3 <= i3 ? (t4.nodesToHandle = 0, t4.howMany = 0, t4.offset = 0) : t4.offset <= n3.offset && o3 >= i3 && (n3.howMany = 0));
            }
          }
          t4.howMany = t4.nodesToHandle, delete t4.nodesToHandle;
        }
        _getInsertDiff(t4, e4, n3) {
          return { type: "insert", position: Fl._createAt(t4, e4), name: n3.name, attributes: new Map(n3.attributes), length: 1, changeCount: this._changeCount++ };
        }
        _getRemoveDiff(t4, e4, n3) {
          return { type: "remove", position: Fl._createAt(t4, e4), name: n3.name, attributes: new Map(n3.attributes), length: 1, changeCount: this._changeCount++ };
        }
        _getAttributesDiff(t4, e4, n3) {
          const o3 = [];
          n3 = new Map(n3);
          for (const [i3, r3] of e4) {
            const e5 = n3.has(i3) ? n3.get(i3) : null;
            e5 !== r3 && o3.push({ type: "attribute", position: t4.start, range: t4.clone(), length: 1, attributeKey: i3, attributeOldValue: r3, attributeNewValue: e5, changeCount: this._changeCount++ }), n3.delete(i3);
          }
          for (const [e5, i3] of n3)
            o3.push({ type: "attribute", position: t4.start, range: t4.clone(), length: 1, attributeKey: e5, attributeOldValue: null, attributeNewValue: i3, changeCount: this._changeCount++ });
          return o3;
        }
        _isInInsertedElement(t4) {
          const e4 = t4.parent;
          if (!e4)
            return false;
          const n3 = this._changesInElement.get(e4), o3 = t4.startOffset;
          if (n3) {
            for (const t5 of n3)
              if ("insert" == t5.type && o3 >= t5.offset && o3 < t5.offset + t5.howMany)
                return true;
          }
          return this._isInInsertedElement(e4);
        }
        _removeAllNestedChanges(t4, e4, n3) {
          const o3 = new Wl(Fl._createAt(t4, e4), Fl._createAt(t4, e4 + n3));
          for (const t5 of o3.getItems({ shallow: true }))
            t5.is("element") && (this._elementSnapshots.delete(t5), this._changesInElement.delete(t5), this._removeAllNestedChanges(t5, 0, t5.maxOffset));
        }
      }
      function Du(t4) {
        const e4 = [];
        for (const n3 of t4)
          if (n3.is("$text"))
            for (let t5 = 0; t5 < n3.data.length; t5++)
              e4.push({ name: "$text", attributes: new Map(n3.getAttributes()) });
          else
            e4.push({ name: n3.name, attributes: new Map(n3.getAttributes()) });
        return e4;
      }
      function Su(t4, e4) {
        const n3 = [];
        let o3 = 0, i3 = 0;
        for (const t5 of e4) {
          if (t5.offset > o3) {
            for (let e5 = 0; e5 < t5.offset - o3; e5++)
              n3.push("e");
            i3 += t5.offset - o3;
          }
          if ("insert" == t5.type) {
            for (let e5 = 0; e5 < t5.howMany; e5++)
              n3.push("i");
            o3 = t5.offset + t5.howMany;
          } else if ("remove" == t5.type) {
            for (let e5 = 0; e5 < t5.howMany; e5++)
              n3.push("r");
            o3 = t5.offset, i3 += t5.howMany;
          } else
            n3.push(..."a".repeat(t5.howMany).split("")), o3 = t5.offset + t5.howMany, i3 += t5.howMany;
        }
        if (i3 < t4)
          for (let e5 = 0; e5 < t4 - i3 - o3; e5++)
            n3.push("e");
        return n3;
      }
      function Iu(t4) {
        const e4 = "position" in t4 && "$graveyard" == t4.position.root.rootName, n3 = "range" in t4 && "$graveyard" == t4.range.root.rootName;
        return !e4 && !n3;
      }
      class Tu {
        constructor() {
          this._operations = [], this._undoPairs = /* @__PURE__ */ new Map(), this._undoneOperations = /* @__PURE__ */ new Set(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map(), this._version = 0, this._gaps = /* @__PURE__ */ new Map();
        }
        get version() {
          return this._version;
        }
        set version(t4) {
          this._operations.length && t4 > this._version + 1 && this._gaps.set(this._version, t4), this._version = t4;
        }
        get lastOperation() {
          return this._operations[this._operations.length - 1];
        }
        addOperation(t4) {
          if (t4.baseVersion !== this.version)
            throw new A2("model-document-history-addoperation-incorrect-version", this, { operation: t4, historyVersion: this.version });
          this._operations.push(t4), this._version++, this._baseVersionToOperationIndex.set(t4.baseVersion, this._operations.length - 1);
        }
        getOperations(t4, e4 = this.version) {
          if (!this._operations.length)
            return [];
          const n3 = this._operations[0];
          void 0 === t4 && (t4 = n3.baseVersion);
          let o3 = e4 - 1;
          for (const [e5, n4] of this._gaps)
            t4 > e5 && t4 < n4 && (t4 = n4), o3 > e5 && o3 < n4 && (o3 = e5 - 1);
          if (o3 < n3.baseVersion || t4 > this.lastOperation.baseVersion)
            return [];
          let i3 = this._baseVersionToOperationIndex.get(t4);
          void 0 === i3 && (i3 = 0);
          let r3 = this._baseVersionToOperationIndex.get(o3);
          return void 0 === r3 && (r3 = this._operations.length - 1), this._operations.slice(i3, r3 + 1);
        }
        getOperation(t4) {
          const e4 = this._baseVersionToOperationIndex.get(t4);
          if (void 0 !== e4)
            return this._operations[e4];
        }
        setOperationAsUndone(t4, e4) {
          this._undoPairs.set(e4, t4), this._undoneOperations.add(t4);
        }
        isUndoingOperation(t4) {
          return this._undoPairs.has(t4);
        }
        isUndoneOperation(t4) {
          return this._undoneOperations.has(t4);
        }
        getUndoneOperation(t4) {
          return this._undoPairs.get(t4);
        }
        reset() {
          this._version = 0, this._undoPairs = /* @__PURE__ */ new Map(), this._operations = [], this._undoneOperations = /* @__PURE__ */ new Set(), this._gaps = /* @__PURE__ */ new Map(), this._baseVersionToOperationIndex = /* @__PURE__ */ new Map();
        }
      }
      class Mu extends Ll {
        constructor(t4, e4, n3 = "main") {
          super(e4), this._isAttached = true, this._isLoaded = true, this._document = t4, this.rootName = n3;
        }
        get document() {
          return this._document;
        }
        isAttached() {
          return this._isAttached;
        }
        toJSON() {
          return this.rootName;
        }
      }
      Mu.prototype.is = function(t4, e4) {
        return e4 ? e4 === this.name && ("rootElement" === t4 || "model:rootElement" === t4 || "element" === t4 || "model:element" === t4) : "rootElement" === t4 || "model:rootElement" === t4 || "element" === t4 || "model:element" === t4 || "node" === t4 || "model:node" === t4;
      };
      var Bu = Object.defineProperty, Nu = Object.defineProperties, Pu = Object.getOwnPropertyDescriptors, zu = Object.getOwnPropertySymbols, Ou = Object.prototype.hasOwnProperty, Lu = Object.prototype.propertyIsEnumerable, ju = (t4, e4, n3) => e4 in t4 ? Bu(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, Ru = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          Ou.call(e4, n3) && ju(t4, n3, e4[n3]);
        if (zu)
          for (var n3 of zu(e4))
            Lu.call(e4, n3) && ju(t4, n3, e4[n3]);
        return t4;
      }, Fu = (t4, e4) => Nu(t4, Pu(e4));
      const Vu = "$graveyard";
      class Hu extends M2() {
        constructor(t4) {
          super(), this.model = t4, this.history = new Tu(), this.selection = new wd2(this), this.roots = new Di2({ idProperty: "rootName" }), this.differ = new Eu(t4.markers), this.isReadOnly = false, this._postFixers = /* @__PURE__ */ new Set(), this._hasSelectionChangedFromTheLastChangeBlock = false, this.createRoot("$root", Vu), this.listenTo(t4, "applyOperation", (t5, e4) => {
            const n3 = e4[0];
            n3.isDocumentOperation && this.differ.bufferOperation(n3);
          }, { priority: "high" }), this.listenTo(t4, "applyOperation", (t5, e4) => {
            const n3 = e4[0];
            n3.isDocumentOperation && this.history.addOperation(n3);
          }, { priority: "low" }), this.listenTo(this.selection, "change", () => {
            this._hasSelectionChangedFromTheLastChangeBlock = true;
          }), this.listenTo(t4.markers, "update", (t5, e4, n3, o3, i3) => {
            const r3 = Fu(Ru({}, e4.getData()), { range: o3 });
            this.differ.bufferMarkerChange(e4.name, i3, r3), null === n3 && e4.on("change", (t6, n4) => {
              const o4 = e4.getData();
              this.differ.bufferMarkerChange(e4.name, Fu(Ru({}, o4), { range: n4 }), o4);
            });
          }), this.registerPostFixer((t5) => {
            let e4 = false;
            for (const n3 of this.roots)
              n3.isAttached() || n3.isEmpty || (t5.remove(t5.createRangeIn(n3)), e4 = true);
            for (const n3 of this.model.markers)
              n3.getRange().root.isAttached() || (t5.removeMarker(n3), e4 = true);
            return e4;
          });
        }
        get version() {
          return this.history.version;
        }
        set version(t4) {
          this.history.version = t4;
        }
        get graveyard() {
          return this.getRoot(Vu);
        }
        createRoot(t4 = "$root", e4 = "main") {
          if (this.roots.get(e4))
            throw new A2("model-document-createroot-name-exists", this, { name: e4 });
          const n3 = new Mu(this, t4, e4);
          return this.roots.add(n3), n3;
        }
        destroy() {
          this.selection.destroy(), this.stopListening();
        }
        getRoot(t4 = "main") {
          return this.roots.get(t4);
        }
        getRootNames(t4 = false) {
          return this.getRoots(t4).map((t5) => t5.rootName);
        }
        getRoots(t4 = false) {
          return Array.from(this.roots).filter((e4) => e4 != this.graveyard && (t4 || e4.isAttached()) && e4._isLoaded);
        }
        registerPostFixer(t4) {
          this._postFixers.add(t4);
        }
        toJSON() {
          const t4 = ps(this);
          return t4.selection = "[engine.model.DocumentSelection]", t4.model = "[engine.model.Model]", t4;
        }
        _handleChangeBlock(t4) {
          this._hasDocumentChangedFromTheLastChangeBlock() && (this._callPostFixers(t4), this.selection.refresh(), this.differ.hasDataChanges() ? this.fire("change:data", t4.batch) : this.fire("change", t4.batch), this.selection.refresh(), this.differ.reset()), this._hasSelectionChangedFromTheLastChangeBlock = false;
        }
        _hasDocumentChangedFromTheLastChangeBlock() {
          return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
        }
        _getDefaultRoot() {
          const t4 = this.getRoots();
          return t4.length ? t4[0] : this.graveyard;
        }
        _getDefaultRange() {
          const t4 = this._getDefaultRoot(), e4 = this.model, n3 = e4.schema, o3 = e4.createPositionFromPath(t4, [0]);
          return n3.getNearestSelectionRange(o3) || e4.createRange(o3);
        }
        _validateSelectionRange(t4) {
          return Uu(t4.start) && Uu(t4.end);
        }
        _callPostFixers(t4) {
          let e4 = false;
          do {
            for (const n3 of this._postFixers)
              if (this.selection.refresh(), e4 = n3(t4), e4)
                break;
          } while (e4);
        }
      }
      function Uu(t4) {
        const e4 = t4.textNode;
        if (e4) {
          const n3 = e4.data, o3 = t4.offset - e4.startOffset;
          return !Ni2(n3, o3) && !Pi2(n3, o3);
        }
        return true;
      }
      var qu = Object.defineProperty, Gu = Object.defineProperties, Wu = Object.getOwnPropertyDescriptors, Ku = Object.getOwnPropertySymbols, Yu = Object.prototype.hasOwnProperty, $u = Object.prototype.propertyIsEnumerable, Zu = (t4, e4, n3) => e4 in t4 ? qu(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3;
      class Qu extends M2() {
        constructor() {
          super(...arguments), this._markers = /* @__PURE__ */ new Map();
        }
        [Symbol.iterator]() {
          return this._markers.values();
        }
        has(t4) {
          const e4 = t4 instanceof Ju ? t4.name : t4;
          return this._markers.has(e4);
        }
        get(t4) {
          return this._markers.get(t4) || null;
        }
        _set(t4, e4, n3 = false, o3 = false) {
          const i3 = t4 instanceof Ju ? t4.name : t4;
          if (i3.includes(","))
            throw new A2("markercollection-incorrect-marker-name", this);
          const r3 = this._markers.get(i3);
          if (r3) {
            const t5 = r3.getData(), s4 = r3.getRange();
            let a4 = false;
            return s4.isEqual(e4) || (r3._attachLiveRange(md2.fromRange(e4)), a4 = true), n3 != r3.managedUsingOperations && (r3._managedUsingOperations = n3, a4 = true), "boolean" == typeof o3 && o3 != r3.affectsData && (r3._affectsData = o3, a4 = true), a4 && this.fire(`update:${i3}`, r3, s4, e4, t5), r3;
          }
          const s3 = md2.fromRange(e4), a3 = new Ju(i3, s3, n3, o3);
          var c3;
          return this._markers.set(i3, a3), this.fire(`update:${i3}`, a3, null, e4, (c3 = ((t5, e5) => {
            for (var n4 in e5 || (e5 = {}))
              Yu.call(e5, n4) && Zu(t5, n4, e5[n4]);
            if (Ku)
              for (var n4 of Ku(e5))
                $u.call(e5, n4) && Zu(t5, n4, e5[n4]);
            return t5;
          })({}, a3.getData()), Gu(c3, Wu({ range: null })))), a3;
        }
        _remove(t4) {
          const e4 = t4 instanceof Ju ? t4.name : t4, n3 = this._markers.get(e4);
          return !!n3 && (this._markers.delete(e4), this.fire(`update:${e4}`, n3, n3.getRange(), null, n3.getData()), this._destroyMarker(n3), true);
        }
        _refresh(t4) {
          const e4 = t4 instanceof Ju ? t4.name : t4, n3 = this._markers.get(e4);
          if (!n3)
            throw new A2("markercollection-refresh-marker-not-exists", this);
          const o3 = n3.getRange();
          this.fire(`update:${e4}`, n3, o3, o3, n3.getData());
        }
        *getMarkersAtPosition(t4) {
          for (const e4 of this)
            e4.getRange().containsPosition(t4) && (yield e4);
        }
        *getMarkersIntersectingRange(t4) {
          for (const e4 of this)
            null !== e4.getRange().getIntersection(t4) && (yield e4);
        }
        destroy() {
          for (const t4 of this._markers.values())
            this._destroyMarker(t4);
          this._markers = null, this.stopListening();
        }
        *getMarkersGroup(t4) {
          for (const e4 of this._markers.values())
            e4.name.startsWith(t4 + ":") && (yield e4);
        }
        _destroyMarker(t4) {
          t4.stopListening(), t4._detachLiveRange();
        }
      }
      class Ju extends M2(Bl) {
        constructor(t4, e4, n3, o3) {
          super(), this.name = t4, this._liveRange = this._attachLiveRange(e4), this._managedUsingOperations = n3, this._affectsData = o3;
        }
        get managedUsingOperations() {
          if (!this._liveRange)
            throw new A2("marker-destroyed", this);
          return this._managedUsingOperations;
        }
        get affectsData() {
          if (!this._liveRange)
            throw new A2("marker-destroyed", this);
          return this._affectsData;
        }
        getData() {
          return { range: this.getRange(), affectsData: this.affectsData, managedUsingOperations: this.managedUsingOperations };
        }
        getStart() {
          if (!this._liveRange)
            throw new A2("marker-destroyed", this);
          return this._liveRange.start.clone();
        }
        getEnd() {
          if (!this._liveRange)
            throw new A2("marker-destroyed", this);
          return this._liveRange.end.clone();
        }
        getRange() {
          if (!this._liveRange)
            throw new A2("marker-destroyed", this);
          return this._liveRange.toRange();
        }
        _attachLiveRange(t4) {
          return this._liveRange && this._detachLiveRange(), t4.delegate("change:range").to(this), t4.delegate("change:content").to(this), this._liveRange = t4, t4;
        }
        _detachLiveRange() {
          this._liveRange.stopDelegating("change:range", this), this._liveRange.stopDelegating("change:content", this), this._liveRange.detach(), this._liveRange = null;
        }
      }
      Ju.prototype.is = function(t4) {
        return "marker" === t4 || "model:marker" === t4;
      };
      class Xu extends Oh2 {
        constructor(t4, e4) {
          super(null), this.sourcePosition = t4.clone(), this.howMany = e4;
        }
        get type() {
          return "detach";
        }
        get affectedSelectable() {
          return null;
        }
        toJSON() {
          const t4 = super.toJSON();
          return t4.sourcePosition = this.sourcePosition.toJSON(), t4;
        }
        _validate() {
          if (this.sourcePosition.root.document)
            throw new A2("detach-operation-on-document-node", this);
        }
        _execute() {
          jh2(Wl._createFromPositionAndShift(this.sourcePosition, this.howMany));
        }
        static get className() {
          return "DetachOperation";
        }
      }
      class tg2 extends Bl {
        constructor(t4) {
          super(), this.markers = /* @__PURE__ */ new Map(), this._children = new Pl(), t4 && this._insertChild(0, t4);
        }
        [Symbol.iterator]() {
          return this.getChildren();
        }
        get childCount() {
          return this._children.length;
        }
        get maxOffset() {
          return this._children.maxOffset;
        }
        get isEmpty() {
          return 0 === this.childCount;
        }
        get nextSibling() {
          return null;
        }
        get previousSibling() {
          return null;
        }
        get root() {
          return this;
        }
        get parent() {
          return null;
        }
        get document() {
          return null;
        }
        isAttached() {
          return false;
        }
        getAncestors() {
          return [];
        }
        getChild(t4) {
          return this._children.getNode(t4);
        }
        getChildren() {
          return this._children[Symbol.iterator]();
        }
        getChildIndex(t4) {
          return this._children.getNodeIndex(t4);
        }
        getChildStartOffset(t4) {
          return this._children.getNodeStartOffset(t4);
        }
        getPath() {
          return [];
        }
        getNodeByPath(t4) {
          let e4 = this;
          for (const n3 of t4)
            e4 = e4.getChild(e4.offsetToIndex(n3));
          return e4;
        }
        offsetToIndex(t4) {
          return this._children.offsetToIndex(t4);
        }
        toJSON() {
          const t4 = [];
          for (const e4 of this._children)
            t4.push(e4.toJSON());
          return t4;
        }
        static fromJSON(t4) {
          const e4 = [];
          for (const n3 of t4)
            n3.name ? e4.push(Ll.fromJSON(n3)) : e4.push(zl.fromJSON(n3));
          return new tg2(e4);
        }
        _appendChild(t4) {
          this._insertChild(this.childCount, t4);
        }
        _insertChild(t4, e4) {
          const n3 = function(t5) {
            if ("string" == typeof t5)
              return [new zl(t5)];
            et2(t5) || (t5 = [t5]);
            return Array.from(t5).map((t6) => "string" == typeof t6 ? new zl(t6) : t6 instanceof Ol ? new zl(t6.data, t6.getAttributes()) : t6);
          }(e4);
          for (const t5 of n3)
            null !== t5.parent && t5._remove(), t5.parent = this;
          this._children._insertNodes(t4, n3);
        }
        _removeChildren(t4, e4 = 1) {
          const n3 = this._children._removeNodes(t4, e4);
          for (const t5 of n3)
            t5.parent = null;
          return n3;
        }
      }
      tg2.prototype.is = function(t4) {
        return "documentFragment" === t4 || "model:documentFragment" === t4;
      };
      class eg2 {
        constructor(t4, e4) {
          this.model = t4, this.batch = e4;
        }
        createText(t4, e4) {
          return new zl(t4, e4);
        }
        createElement(t4, e4) {
          return new Ll(t4, e4);
        }
        createDocumentFragment() {
          return new tg2();
        }
        cloneElement(t4, e4 = true) {
          return t4._clone(e4);
        }
        insert(t4, e4, n3 = 0) {
          if (this._assertWriterUsedCorrectly(), t4 instanceof zl && "" == t4.data)
            return;
          const o3 = Fl._createAt(e4, n3);
          if (t4.parent) {
            if (sg2(t4.root, o3.root))
              return void this.move(Wl._createOn(t4), o3);
            if (t4.root.document)
              throw new A2("model-writer-insert-forbidden-move", this);
            this.remove(t4);
          }
          const i3 = o3.root.document ? o3.root.document.version : null, r3 = new Gh2(o3, t4, i3);
          if (t4 instanceof zl && (r3.shouldReceiveAttributes = true), this.batch.addOperation(r3), this.model.applyOperation(r3), t4 instanceof tg2)
            for (const [e5, n4] of t4.markers) {
              const t5 = Fl._createAt(n4.root, 0), i4 = { range: new Wl(n4.start._getCombined(t5, o3), n4.end._getCombined(t5, o3)), usingOperation: true, affectsData: true };
              this.model.markers.has(e5) ? this.updateMarker(e5, i4) : this.addMarker(e5, i4);
            }
        }
        insertText(t4, e4, n3, o3) {
          e4 instanceof tg2 || e4 instanceof Ll || e4 instanceof Fl ? this.insert(this.createText(t4), e4, n3) : this.insert(this.createText(t4, e4), n3, o3);
        }
        insertElement(t4, e4, n3, o3) {
          e4 instanceof tg2 || e4 instanceof Ll || e4 instanceof Fl ? this.insert(this.createElement(t4), e4, n3) : this.insert(this.createElement(t4, e4), n3, o3);
        }
        append(t4, e4) {
          this.insert(t4, e4, "end");
        }
        appendText(t4, e4, n3) {
          e4 instanceof tg2 || e4 instanceof Ll ? this.insert(this.createText(t4), e4, "end") : this.insert(this.createText(t4, e4), n3, "end");
        }
        appendElement(t4, e4, n3) {
          e4 instanceof tg2 || e4 instanceof Ll ? this.insert(this.createElement(t4), e4, "end") : this.insert(this.createElement(t4, e4), n3, "end");
        }
        setAttribute(t4, e4, n3) {
          if (this._assertWriterUsedCorrectly(), n3 instanceof Wl) {
            const o3 = n3.getMinimalFlatRanges();
            for (const n4 of o3)
              ng2(this, t4, e4, n4);
          } else
            og2(this, t4, e4, n3);
        }
        setAttributes(t4, e4) {
          for (const [n3, o3] of Mi2(t4))
            this.setAttribute(n3, o3, e4);
        }
        removeAttribute(t4, e4) {
          if (this._assertWriterUsedCorrectly(), e4 instanceof Wl) {
            const n3 = e4.getMinimalFlatRanges();
            for (const e5 of n3)
              ng2(this, t4, null, e5);
          } else
            og2(this, t4, null, e4);
        }
        clearAttributes(t4) {
          this._assertWriterUsedCorrectly();
          const e4 = (t5) => {
            for (const e5 of t5.getAttributeKeys())
              this.removeAttribute(e5, t5);
          };
          if (t4 instanceof Wl)
            for (const n3 of t4.getItems())
              e4(n3);
          else
            e4(t4);
        }
        move(t4, e4, n3) {
          if (this._assertWriterUsedCorrectly(), !(t4 instanceof Wl))
            throw new A2("writer-move-invalid-range", this);
          if (!t4.isFlat)
            throw new A2("writer-move-range-not-flat", this);
          const o3 = Fl._createAt(e4, n3);
          if (o3.isEqual(t4.start))
            return;
          if (this._addOperationForAffectedMarkers("move", t4), !sg2(t4.root, o3.root))
            throw new A2("writer-move-different-document", this);
          const i3 = t4.root.document ? t4.root.document.version : null, r3 = new qh2(t4.start, t4.end.offset - t4.start.offset, o3, i3);
          this.batch.addOperation(r3), this.model.applyOperation(r3);
        }
        remove(t4) {
          this._assertWriterUsedCorrectly();
          const e4 = (t4 instanceof Wl ? t4 : Wl._createOn(t4)).getMinimalFlatRanges().reverse();
          for (const t5 of e4)
            this._addOperationForAffectedMarkers("move", t5), rg2(t5.start, t5.end.offset - t5.start.offset, this.batch, this.model);
        }
        merge(t4) {
          this._assertWriterUsedCorrectly();
          const e4 = t4.nodeBefore, n3 = t4.nodeAfter;
          if (this._addOperationForAffectedMarkers("merge", t4), !(e4 instanceof Ll))
            throw new A2("writer-merge-no-element-before", this);
          if (!(n3 instanceof Ll))
            throw new A2("writer-merge-no-element-after", this);
          t4.root.document ? this._merge(t4) : this._mergeDetached(t4);
        }
        createPositionFromPath(t4, e4, n3) {
          return this.model.createPositionFromPath(t4, e4, n3);
        }
        createPositionAt(t4, e4) {
          return this.model.createPositionAt(t4, e4);
        }
        createPositionAfter(t4) {
          return this.model.createPositionAfter(t4);
        }
        createPositionBefore(t4) {
          return this.model.createPositionBefore(t4);
        }
        createRange(t4, e4) {
          return this.model.createRange(t4, e4);
        }
        createRangeIn(t4) {
          return this.model.createRangeIn(t4);
        }
        createRangeOn(t4) {
          return this.model.createRangeOn(t4);
        }
        createSelection(...t4) {
          return this.model.createSelection(...t4);
        }
        _mergeDetached(t4) {
          const e4 = t4.nodeBefore, n3 = t4.nodeAfter;
          this.move(Wl._createIn(n3), Fl._createAt(e4, "end")), this.remove(n3);
        }
        _merge(t4) {
          const e4 = Fl._createAt(t4.nodeBefore, "end"), n3 = Fl._createAt(t4.nodeAfter, 0), o3 = t4.root.document.graveyard, i3 = new Fl(o3, [0]), r3 = t4.root.document.version, s3 = new Kh2(n3, t4.nodeAfter.maxOffset, e4, i3, r3);
          this.batch.addOperation(s3), this.model.applyOperation(s3);
        }
        rename(t4, e4) {
          if (this._assertWriterUsedCorrectly(), !(t4 instanceof Ll))
            throw new A2("writer-rename-not-element-instance", this);
          const n3 = t4.root.document ? t4.root.document.version : null, o3 = new Jh2(Fl._createBefore(t4), t4.name, e4, n3);
          this.batch.addOperation(o3), this.model.applyOperation(o3);
        }
        split(t4, e4) {
          this._assertWriterUsedCorrectly();
          let n3, o3, i3 = t4.parent;
          if (!i3.parent)
            throw new A2("writer-split-element-no-parent", this);
          if (e4 || (e4 = i3.parent), !t4.parent.getAncestors({ includeSelf: true }).includes(e4))
            throw new A2("writer-split-invalid-limit-element", this);
          do {
            const e5 = i3.root.document ? i3.root.document.version : null, r3 = i3.maxOffset - t4.offset, s3 = Wh2.getInsertionPosition(t4), a3 = new Wh2(t4, r3, s3, null, e5);
            this.batch.addOperation(a3), this.model.applyOperation(a3), n3 || o3 || (n3 = i3, o3 = t4.parent.nextSibling), i3 = (t4 = this.createPositionAfter(t4.parent)).parent;
          } while (i3 !== e4);
          return { position: t4, range: new Wl(Fl._createAt(n3, "end"), Fl._createAt(o3, 0)) };
        }
        wrap(t4, e4) {
          if (this._assertWriterUsedCorrectly(), !t4.isFlat)
            throw new A2("writer-wrap-range-not-flat", this);
          const n3 = e4 instanceof Ll ? e4 : new Ll(e4);
          if (n3.childCount > 0)
            throw new A2("writer-wrap-element-not-empty", this);
          if (null !== n3.parent)
            throw new A2("writer-wrap-element-attached", this);
          this.insert(n3, t4.start);
          const o3 = new Wl(t4.start.getShiftedBy(1), t4.end.getShiftedBy(1));
          this.move(o3, Fl._createAt(n3, 0));
        }
        unwrap(t4) {
          if (this._assertWriterUsedCorrectly(), null === t4.parent)
            throw new A2("writer-unwrap-element-no-parent", this);
          this.move(Wl._createIn(t4), this.createPositionAfter(t4)), this.remove(t4);
        }
        addMarker(t4, e4) {
          if (this._assertWriterUsedCorrectly(), !e4 || "boolean" != typeof e4.usingOperation)
            throw new A2("writer-addmarker-no-usingoperation", this);
          const n3 = e4.usingOperation, o3 = e4.range, i3 = void 0 !== e4.affectsData && e4.affectsData;
          if (this.model.markers.has(t4))
            throw new A2("writer-addmarker-marker-exists", this);
          if (!o3)
            throw new A2("writer-addmarker-no-range", this);
          return n3 ? (ig2(this, t4, null, o3, i3), this.model.markers.get(t4)) : this.model.markers._set(t4, o3, n3, i3);
        }
        updateMarker(t4, e4) {
          this._assertWriterUsedCorrectly();
          const n3 = "string" == typeof t4 ? t4 : t4.name, o3 = this.model.markers.get(n3);
          if (!o3)
            throw new A2("writer-updatemarker-marker-not-exists", this);
          if (!e4)
            return C2("writer-updatemarker-reconvert-using-editingcontroller", { markerName: n3 }), void this.model.markers._refresh(o3);
          const i3 = "boolean" == typeof e4.usingOperation, r3 = "boolean" == typeof e4.affectsData, s3 = r3 ? e4.affectsData : o3.affectsData;
          if (!i3 && !e4.range && !r3)
            throw new A2("writer-updatemarker-wrong-options", this);
          const a3 = o3.getRange(), c3 = e4.range ? e4.range : a3;
          i3 && e4.usingOperation !== o3.managedUsingOperations ? e4.usingOperation ? ig2(this, n3, null, c3, s3) : (ig2(this, n3, a3, null, s3), this.model.markers._set(n3, c3, void 0, s3)) : o3.managedUsingOperations ? ig2(this, n3, a3, c3, s3) : this.model.markers._set(n3, c3, void 0, s3);
        }
        removeMarker(t4) {
          this._assertWriterUsedCorrectly();
          const e4 = "string" == typeof t4 ? t4 : t4.name;
          if (!this.model.markers.has(e4))
            throw new A2("writer-removemarker-no-marker", this);
          const n3 = this.model.markers.get(e4);
          if (!n3.managedUsingOperations)
            return void this.model.markers._remove(e4);
          ig2(this, e4, n3.getRange(), null, n3.affectsData);
        }
        addRoot(t4, e4 = "$root") {
          this._assertWriterUsedCorrectly();
          const n3 = this.model.document.getRoot(t4);
          if (n3 && n3.isAttached())
            throw new A2("writer-addroot-root-exists", this);
          const o3 = this.model.document, i3 = new tu(t4, e4, true, o3, o3.version);
          return this.batch.addOperation(i3), this.model.applyOperation(i3), this.model.document.getRoot(t4);
        }
        detachRoot(t4) {
          this._assertWriterUsedCorrectly();
          const e4 = "string" == typeof t4 ? this.model.document.getRoot(t4) : t4;
          if (!e4 || !e4.isAttached())
            throw new A2("writer-detachroot-no-root", this);
          for (const t5 of this.model.markers)
            t5.getRange().root === e4 && this.removeMarker(t5);
          for (const t5 of e4.getAttributeKeys())
            this.removeAttribute(t5, e4);
          this.remove(this.createRangeIn(e4));
          const n3 = this.model.document, o3 = new tu(e4.rootName, e4.name, false, n3, n3.version);
          this.batch.addOperation(o3), this.model.applyOperation(o3);
        }
        setSelection(...t4) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setTo(...t4);
        }
        setSelectionFocus(t4, e4) {
          this._assertWriterUsedCorrectly(), this.model.document.selection._setFocus(t4, e4);
        }
        setSelectionAttribute(t4, e4) {
          if (this._assertWriterUsedCorrectly(), "string" == typeof t4)
            this._setSelectionAttribute(t4, e4);
          else
            for (const [e5, n3] of Mi2(t4))
              this._setSelectionAttribute(e5, n3);
        }
        removeSelectionAttribute(t4) {
          if (this._assertWriterUsedCorrectly(), "string" == typeof t4)
            this._removeSelectionAttribute(t4);
          else
            for (const e4 of t4)
              this._removeSelectionAttribute(e4);
        }
        overrideSelectionGravity() {
          return this.model.document.selection._overrideGravity();
        }
        restoreSelectionGravity(t4) {
          this.model.document.selection._restoreGravity(t4);
        }
        _setSelectionAttribute(t4, e4) {
          const n3 = this.model.document.selection;
          if (n3.isCollapsed && n3.anchor.parent.isEmpty) {
            const o3 = wd2._getStoreAttributeKey(t4);
            this.setAttribute(o3, e4, n3.anchor.parent);
          }
          n3._setAttribute(t4, e4);
        }
        _removeSelectionAttribute(t4) {
          const e4 = this.model.document.selection;
          if (e4.isCollapsed && e4.anchor.parent.isEmpty) {
            const n3 = wd2._getStoreAttributeKey(t4);
            this.removeAttribute(n3, e4.anchor.parent);
          }
          e4._removeAttribute(t4);
        }
        _assertWriterUsedCorrectly() {
          if (this.model._currentWriter !== this)
            throw new A2("writer-incorrect-use", this);
        }
        _addOperationForAffectedMarkers(t4, e4) {
          for (const n3 of this.model.markers) {
            if (!n3.managedUsingOperations)
              continue;
            const o3 = n3.getRange();
            let i3 = false;
            if ("move" === t4) {
              const t5 = e4;
              i3 = t5.containsPosition(o3.start) || t5.start.isEqual(o3.start) || t5.containsPosition(o3.end) || t5.end.isEqual(o3.end);
            } else {
              const t5 = e4, n4 = t5.nodeBefore, r3 = t5.nodeAfter, s3 = o3.start.parent == n4 && o3.start.isAtEnd, a3 = o3.end.parent == r3 && 0 == o3.end.offset, c3 = o3.end.nodeAfter == r3, l3 = o3.start.nodeAfter == r3;
              i3 = s3 || a3 || c3 || l3;
            }
            i3 && this.updateMarker(n3.name, { range: o3 });
          }
        }
      }
      function ng2(t4, e4, n3, o3) {
        const i3 = t4.model, r3 = i3.document;
        let s3, a3, c3, l3 = o3.start;
        for (const t5 of o3.getWalker({ shallow: true }))
          c3 = t5.item.getAttribute(e4), s3 && a3 != c3 && (a3 != n3 && d3(), l3 = s3), s3 = t5.nextPosition, a3 = c3;
        function d3() {
          const o4 = new Wl(l3, s3), c4 = o4.root.document ? r3.version : null, d4 = new Zh2(o4, e4, a3, n3, c4);
          t4.batch.addOperation(d4), i3.applyOperation(d4);
        }
        s3 instanceof Fl && s3 != l3 && a3 != n3 && d3();
      }
      function og2(t4, e4, n3, o3) {
        const i3 = t4.model, r3 = i3.document, s3 = o3.getAttribute(e4);
        let a3, c3;
        if (s3 != n3) {
          if (o3.root === o3) {
            const t5 = o3.document ? r3.version : null;
            c3 = new Xh2(o3, e4, s3, n3, t5);
          } else {
            a3 = new Wl(Fl._createBefore(o3), t4.createPositionAfter(o3));
            const i4 = a3.root.document ? r3.version : null;
            c3 = new Zh2(a3, e4, s3, n3, i4);
          }
          t4.batch.addOperation(c3), i3.applyOperation(c3);
        }
      }
      function ig2(t4, e4, n3, o3, i3) {
        const r3 = t4.model, s3 = r3.document, a3 = new Yh2(e4, n3, o3, r3.markers, !!i3, s3.version);
        t4.batch.addOperation(a3), r3.applyOperation(a3);
      }
      function rg2(t4, e4, n3, o3) {
        let i3;
        if (t4.root.document) {
          const n4 = o3.document, r3 = new Fl(n4.graveyard, [0]);
          i3 = new qh2(t4, e4, r3, n4.version);
        } else
          i3 = new Xu(t4, e4);
        n3.addOperation(i3), o3.applyOperation(i3);
      }
      function sg2(t4, e4) {
        return t4 === e4 || t4 instanceof Mu && e4 instanceof Mu;
      }
      function ag2(t4, e4, n3 = {}) {
        if (e4.isCollapsed)
          return;
        const o3 = e4.getFirstRange();
        if ("$graveyard" == o3.root.rootName)
          return;
        const i3 = t4.schema;
        t4.change((t5) => {
          if (!n3.doNotResetEntireContent && function(t6, e5) {
            const n4 = t6.getLimitElement(e5);
            if (!e5.containsEntireContent(n4))
              return false;
            const o4 = e5.getFirstRange();
            if (o4.start.parent == o4.end.parent)
              return false;
            return t6.checkChild(n4, "paragraph");
          }(i3, e4))
            return void function(t6, e5) {
              const n4 = t6.model.schema.getLimitElement(e5);
              t6.remove(t6.createRangeIn(n4)), hg2(t6, t6.createPositionAt(n4, 0), e5);
            }(t5, e4);
          const r3 = {};
          if (!n3.doNotAutoparagraph) {
            const t6 = e4.getSelectedElement();
            t6 && Object.assign(r3, i3.getAttributesWithProperty(t6, "copyOnReplace", true));
          }
          const [s3, a3] = function(t6) {
            const e5 = t6.root.document.model, n4 = t6.start;
            let o4 = t6.end;
            if (e5.hasContent(t6, { ignoreMarkers: true })) {
              const n5 = function(t7) {
                const e6 = t7.parent, n6 = e6.root.document.model.schema, o5 = e6.getAncestors({ parentFirst: true, includeSelf: true });
                for (const t8 of o5) {
                  if (n6.isLimit(t8))
                    return null;
                  if (n6.isBlock(t8))
                    return t8;
                }
              }(o4);
              if (n5 && o4.isTouching(e5.createPositionAt(n5, 0))) {
                const n6 = e5.createSelection(t6);
                e5.modifySelection(n6, { direction: "backward" });
                const i4 = n6.getLastPosition(), r4 = e5.createRange(i4, o4);
                e5.hasContent(r4, { ignoreMarkers: true }) || (o4 = i4);
              }
            }
            return [pu.fromPosition(n4, "toPrevious"), pu.fromPosition(o4, "toNext")];
          }(o3);
          s3.isTouching(a3) || t5.remove(t5.createRange(s3, a3)), n3.leaveUnmerged || (!function(t6, e5, n4) {
            const o4 = t6.model;
            if (!dg2(t6.model.schema, e5, n4))
              return;
            const [i4, r4] = function(t7, e6) {
              const n5 = t7.getAncestors(), o5 = e6.getAncestors();
              let i5 = 0;
              for (; n5[i5] && n5[i5] == o5[i5]; )
                i5++;
              return [n5[i5], o5[i5]];
            }(e5, n4);
            if (!i4 || !r4)
              return;
            !o4.hasContent(i4, { ignoreMarkers: true }) && o4.hasContent(r4, { ignoreMarkers: true }) ? lg2(t6, e5, n4, i4.parent) : cg2(t6, e5, n4, i4.parent);
          }(t5, s3, a3), i3.removeDisallowedAttributes(s3.parent.getChildren(), t5)), ug2(t5, e4, s3), !n3.doNotAutoparagraph && function(t6, e5) {
            const n4 = t6.checkChild(e5, "$text"), o4 = t6.checkChild(e5, "paragraph");
            return !n4 && o4;
          }(i3, s3) && hg2(t5, s3, e4, r3), s3.detach(), a3.detach();
        });
      }
      function cg2(t4, e4, n3, o3) {
        const i3 = e4.parent, r3 = n3.parent;
        if (i3 != o3 && r3 != o3) {
          for (e4 = t4.createPositionAfter(i3), (n3 = t4.createPositionBefore(r3)).isEqual(e4) || t4.insert(r3, e4), t4.merge(e4); n3.parent.isEmpty; ) {
            const e5 = n3.parent;
            n3 = t4.createPositionBefore(e5), t4.remove(e5);
          }
          dg2(t4.model.schema, e4, n3) && cg2(t4, e4, n3, o3);
        }
      }
      function lg2(t4, e4, n3, o3) {
        const i3 = e4.parent, r3 = n3.parent;
        if (i3 != o3 && r3 != o3) {
          for (e4 = t4.createPositionAfter(i3), (n3 = t4.createPositionBefore(r3)).isEqual(e4) || t4.insert(i3, n3); e4.parent.isEmpty; ) {
            const n4 = e4.parent;
            e4 = t4.createPositionBefore(n4), t4.remove(n4);
          }
          n3 = t4.createPositionBefore(r3), function(t5, e5) {
            const n4 = e5.nodeBefore, o4 = e5.nodeAfter;
            n4.name != o4.name && t5.rename(n4, o4.name);
            t5.clearAttributes(n4), t5.setAttributes(Object.fromEntries(o4.getAttributes()), n4), t5.merge(e5);
          }(t4, n3), dg2(t4.model.schema, e4, n3) && lg2(t4, e4, n3, o3);
        }
      }
      function dg2(t4, e4, n3) {
        const o3 = e4.parent, i3 = n3.parent;
        return o3 != i3 && (!t4.isLimit(o3) && !t4.isLimit(i3) && function(t5, e5, n4) {
          const o4 = new Wl(t5, e5);
          for (const t6 of o4.getWalker())
            if (n4.isLimit(t6.item))
              return false;
          return true;
        }(e4, n3, t4));
      }
      function hg2(t4, e4, n3, o3 = {}) {
        const i3 = t4.createElement("paragraph");
        t4.model.schema.setAllowedAttributes(i3, o3, t4), t4.insert(i3, e4), ug2(t4, n3, t4.createPositionAt(i3, 0));
      }
      function ug2(t4, e4, n3) {
        e4 instanceof wd2 ? t4.setSelection(n3) : e4.setTo(n3);
      }
      function gg2(t4, e4) {
        const n3 = [];
        Array.from(t4.getItems({ direction: "backward" })).map((t5) => e4.createRangeOn(t5)).filter((e5) => (e5.start.isAfter(t4.start) || e5.start.isEqual(t4.start)) && (e5.end.isBefore(t4.end) || e5.end.isEqual(t4.end))).forEach((t5) => {
          n3.push(t5.start.parent), e4.remove(t5);
        }), n3.forEach((t5) => {
          let n4 = t5;
          for (; n4.parent && n4.isEmpty; ) {
            const t6 = e4.createRangeOn(n4);
            n4 = n4.parent, e4.remove(t6);
          }
        });
      }
      class pg2 {
        constructor(t4, e4, n3) {
          this._firstNode = null, this._lastNode = null, this._lastAutoParagraph = null, this._filterAttributesOf = [], this._affectedStart = null, this._affectedEnd = null, this._nodeToSelect = null, this.model = t4, this.writer = e4, this.position = n3, this.canMergeWith = /* @__PURE__ */ new Set([this.position.parent]), this.schema = t4.schema, this._documentFragment = e4.createDocumentFragment(), this._documentFragmentPosition = e4.createPositionAt(this._documentFragment, 0);
        }
        handleNodes(t4) {
          for (const e4 of Array.from(t4))
            this._handleNode(e4);
          this._insertPartialFragment(), this._lastAutoParagraph && this._updateLastNodeFromAutoParagraph(this._lastAutoParagraph), this._mergeOnRight(), this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer), this._filterAttributesOf = [];
        }
        _updateLastNodeFromAutoParagraph(t4) {
          const e4 = this.writer.createPositionAfter(this._lastNode), n3 = this.writer.createPositionAfter(t4);
          if (n3.isAfter(e4)) {
            if (this._lastNode = t4, this.position.parent != t4 || !this.position.isAtEnd)
              throw new A2("insertcontent-invalid-insertion-position", this);
            this.position = n3, this._setAffectedBoundaries(this.position);
          }
        }
        getSelectionRange() {
          return this._nodeToSelect ? Wl._createOn(this._nodeToSelect) : this.model.schema.getNearestSelectionRange(this.position);
        }
        getAffectedRange() {
          return this._affectedStart ? new Wl(this._affectedStart, this._affectedEnd) : null;
        }
        destroy() {
          this._affectedStart && this._affectedStart.detach(), this._affectedEnd && this._affectedEnd.detach();
        }
        _handleNode(t4) {
          if (this.schema.isObject(t4))
            return void this._handleObject(t4);
          let e4 = this._checkAndAutoParagraphToAllowedPosition(t4);
          e4 || (e4 = this._checkAndSplitToAllowedPosition(t4), e4) ? (this._appendToFragment(t4), this._firstNode || (this._firstNode = t4), this._lastNode = t4) : this._handleDisallowedNode(t4);
        }
        _insertPartialFragment() {
          if (this._documentFragment.isEmpty)
            return;
          const t4 = pu.fromPosition(this.position, "toNext");
          this._setAffectedBoundaries(this.position), this._documentFragment.getChild(0) == this._firstNode && (this.writer.insert(this._firstNode, this.position), this._mergeOnLeft(), this.position = t4.toPosition()), this._documentFragment.isEmpty || this.writer.insert(this._documentFragment, this.position), this._documentFragmentPosition = this.writer.createPositionAt(this._documentFragment, 0), this.position = t4.toPosition(), t4.detach();
        }
        _handleObject(t4) {
          this._checkAndSplitToAllowedPosition(t4) ? this._appendToFragment(t4) : this._tryAutoparagraphing(t4);
        }
        _handleDisallowedNode(t4) {
          t4.is("element") ? this.handleNodes(t4.getChildren()) : this._tryAutoparagraphing(t4);
        }
        _appendToFragment(t4) {
          if (!this.schema.checkChild(this.position, t4))
            throw new A2("insertcontent-wrong-position", this, { node: t4, position: this.position });
          this.writer.insert(t4, this._documentFragmentPosition), this._documentFragmentPosition = this._documentFragmentPosition.getShiftedBy(t4.offsetSize), this.schema.isObject(t4) && !this.schema.checkChild(this.position, "$text") ? this._nodeToSelect = t4 : this._nodeToSelect = null, this._filterAttributesOf.push(t4);
        }
        _setAffectedBoundaries(t4) {
          this._affectedStart || (this._affectedStart = pu.fromPosition(t4, "toPrevious")), this._affectedEnd && !this._affectedEnd.isBefore(t4) || (this._affectedEnd && this._affectedEnd.detach(), this._affectedEnd = pu.fromPosition(t4, "toNext"));
        }
        _mergeOnLeft() {
          const t4 = this._firstNode;
          if (!(t4 instanceof Ll))
            return;
          if (!this._canMergeLeft(t4))
            return;
          const e4 = pu._createBefore(t4);
          e4.stickiness = "toNext";
          const n3 = pu.fromPosition(this.position, "toNext");
          this._affectedStart.isEqual(e4) && (this._affectedStart.detach(), this._affectedStart = pu._createAt(e4.nodeBefore, "end", "toPrevious")), this._firstNode === this._lastNode && (this._firstNode = e4.nodeBefore, this._lastNode = e4.nodeBefore), this.writer.merge(e4), e4.isEqual(this._affectedEnd) && this._firstNode === this._lastNode && (this._affectedEnd.detach(), this._affectedEnd = pu._createAt(e4.nodeBefore, "end", "toNext")), this.position = n3.toPosition(), n3.detach(), this._filterAttributesOf.push(this.position.parent), e4.detach();
        }
        _mergeOnRight() {
          const t4 = this._lastNode;
          if (!(t4 instanceof Ll))
            return;
          if (!this._canMergeRight(t4))
            return;
          const e4 = pu._createAfter(t4);
          if (e4.stickiness = "toNext", !this.position.isEqual(e4))
            throw new A2("insertcontent-invalid-insertion-position", this);
          this.position = Fl._createAt(e4.nodeBefore, "end");
          const n3 = pu.fromPosition(this.position, "toPrevious");
          this._affectedEnd.isEqual(e4) && (this._affectedEnd.detach(), this._affectedEnd = pu._createAt(e4.nodeBefore, "end", "toNext")), this._firstNode === this._lastNode && (this._firstNode = e4.nodeBefore, this._lastNode = e4.nodeBefore), this.writer.merge(e4), e4.getShiftedBy(-1).isEqual(this._affectedStart) && this._firstNode === this._lastNode && (this._affectedStart.detach(), this._affectedStart = pu._createAt(e4.nodeBefore, 0, "toPrevious")), this.position = n3.toPosition(), n3.detach(), this._filterAttributesOf.push(this.position.parent), e4.detach();
        }
        _canMergeLeft(t4) {
          const e4 = t4.previousSibling;
          return e4 instanceof Ll && this.canMergeWith.has(e4) && this.model.schema.checkMerge(e4, t4);
        }
        _canMergeRight(t4) {
          const e4 = t4.nextSibling;
          return e4 instanceof Ll && this.canMergeWith.has(e4) && this.model.schema.checkMerge(t4, e4);
        }
        _tryAutoparagraphing(t4) {
          const e4 = this.writer.createElement("paragraph");
          this._getAllowedIn(this.position.parent, e4) && this.schema.checkChild(e4, t4) && (e4._appendChild(t4), this._handleNode(e4));
        }
        _checkAndAutoParagraphToAllowedPosition(t4) {
          if (this.schema.checkChild(this.position.parent, t4))
            return true;
          if (!this.schema.checkChild(this.position.parent, "paragraph") || !this.schema.checkChild("paragraph", t4))
            return false;
          this._insertPartialFragment();
          const e4 = this.writer.createElement("paragraph");
          return this.writer.insert(e4, this.position), this._setAffectedBoundaries(this.position), this._lastAutoParagraph = e4, this.position = this.writer.createPositionAt(e4, 0), true;
        }
        _checkAndSplitToAllowedPosition(t4) {
          const e4 = this._getAllowedIn(this.position.parent, t4);
          if (!e4)
            return false;
          for (e4 != this.position.parent && this._insertPartialFragment(); e4 != this.position.parent; )
            if (this.position.isAtStart) {
              const t5 = this.position.parent;
              this.position = this.writer.createPositionBefore(t5), t5.isEmpty && t5.parent === e4 && this.writer.remove(t5);
            } else if (this.position.isAtEnd)
              this.position = this.writer.createPositionAfter(this.position.parent);
            else {
              const t5 = this.writer.createPositionAfter(this.position.parent);
              this._setAffectedBoundaries(this.position), this.writer.split(this.position), this.position = t5, this.canMergeWith.add(this.position.nodeAfter);
            }
          return true;
        }
        _getAllowedIn(t4, e4) {
          return this.schema.checkChild(t4, e4) ? t4 : this.schema.isLimit(t4) ? null : this._getAllowedIn(t4.parent, e4);
        }
      }
      function mg2(t4, e4, n3 = "auto") {
        const o3 = t4.getSelectedElement();
        if (o3 && e4.schema.isObject(o3) && !e4.schema.isInline(o3))
          return "before" == n3 || "after" == n3 ? e4.createRange(e4.createPositionAt(o3, n3)) : e4.createRangeOn(o3);
        const i3 = Si2(t4.getSelectedBlocks());
        if (!i3)
          return e4.createRange(t4.focus);
        if (i3.isEmpty)
          return e4.createRange(e4.createPositionAt(i3, 0));
        const r3 = e4.createPositionAfter(i3);
        return t4.focus.isTouching(r3) ? e4.createRange(r3) : e4.createRange(e4.createPositionBefore(i3));
      }
      function fg2(t4, e4, n3, o3 = {}) {
        if (!t4.schema.isObject(e4))
          throw new A2("insertobject-element-not-an-object", t4, { object: e4 });
        const i3 = n3 || t4.document.selection;
        let r3 = i3;
        o3.findOptimalPosition && t4.schema.isBlock(e4) && (r3 = t4.createSelection(mg2(i3, t4, o3.findOptimalPosition)));
        const s3 = Si2(i3.getSelectedBlocks()), a3 = {};
        return s3 && Object.assign(a3, t4.schema.getAttributesWithProperty(s3, "copyOnReplace", true)), t4.change((n4) => {
          r3.isCollapsed || t4.deleteContent(r3, { doNotAutoparagraph: true });
          let i4 = e4;
          const s4 = r3.anchor.parent;
          !t4.schema.checkChild(s4, e4) && t4.schema.checkChild(s4, "paragraph") && t4.schema.checkChild("paragraph", e4) && (i4 = n4.createElement("paragraph"), n4.insert(e4, i4)), t4.schema.setAllowedAttributes(i4, a3, n4);
          const c3 = t4.insertContent(i4, r3);
          return c3.isCollapsed || o3.setSelection && function(t5, e5, n5, o4) {
            const i5 = t5.model;
            if ("on" == n5)
              return void t5.setSelection(e5, "on");
            if ("after" != n5)
              throw new A2("insertobject-invalid-place-parameter-value", i5);
            let r4 = e5.nextSibling;
            if (i5.schema.isInline(e5))
              return void t5.setSelection(e5, "after");
            const s5 = r4 && i5.schema.checkChild(r4, "$text");
            !s5 && i5.schema.checkChild(e5.parent, "paragraph") && (r4 = t5.createElement("paragraph"), i5.schema.setAllowedAttributes(r4, o4, t5), i5.insertContent(r4, t5.createPositionAfter(e5)));
            r4 && t5.setSelection(r4, 0);
          }(n4, e4, o3.setSelection, a3), c3;
        });
      }
      const kg2 = ' ,.?!:;"-()';
      function bg2(t4, e4) {
        const { isForward: n3, walker: o3, unit: i3, schema: r3, treatEmojiAsSingleUnit: s3 } = t4, { type: a3, item: c3, nextPosition: l3 } = e4;
        if ("text" == a3)
          return "word" === t4.unit ? function(t5, e5) {
            let n4 = t5.position.textNode;
            n4 || (n4 = e5 ? t5.position.nodeAfter : t5.position.nodeBefore);
            for (; n4 && n4.is("$text"); ) {
              const o4 = t5.position.offset - n4.startOffset;
              if (Cg2(n4, o4, e5))
                n4 = e5 ? t5.position.nodeAfter : t5.position.nodeBefore;
              else {
                if (Ag2(n4.data, o4, e5))
                  break;
                t5.next();
              }
            }
            return t5.position;
          }(o3, n3) : function(t5, e5, n4) {
            const o4 = t5.position.textNode;
            if (o4) {
              const i4 = o4.data;
              let r4 = t5.position.offset - o4.startOffset;
              for (; Ni2(i4, r4) || "character" == e5 && Pi2(i4, r4) || n4 && Oi2(i4, r4); )
                t5.next(), r4 = t5.position.offset - o4.startOffset;
            }
            return t5.position;
          }(o3, i3, s3);
        if (a3 == (n3 ? "elementStart" : "elementEnd")) {
          if (r3.isSelectable(c3))
            return Fl._createAt(c3, n3 ? "after" : "before");
          if (r3.checkChild(l3, "$text"))
            return l3;
        } else {
          if (r3.isLimit(c3))
            return void o3.skip(() => true);
          if (r3.checkChild(l3, "$text"))
            return l3;
        }
      }
      function wg2(t4, e4) {
        const n3 = t4.root, o3 = Fl._createAt(n3, e4 ? "end" : 0);
        return e4 ? new Wl(t4, o3) : new Wl(o3, t4);
      }
      function Ag2(t4, e4, n3) {
        const o3 = e4 + (n3 ? 0 : -1);
        return kg2.includes(t4.charAt(o3));
      }
      function Cg2(t4, e4, n3) {
        return e4 === (n3 ? t4.offsetSize : 0);
      }
      class _g extends W2() {
        constructor() {
          super(), this.markers = new Qu(), this.document = new Hu(this), this.schema = new ah2(), this._pendingChanges = [], this._currentWriter = null, ["deleteContent", "modifySelection", "getSelectedContent", "applyOperation"].forEach((t4) => this.decorate(t4)), this.on("applyOperation", (t4, e4) => {
            e4[0]._validate();
          }, { priority: "highest" }), this.schema.register("$root", { isLimit: true }), this.schema.register("$container", { allowIn: ["$root", "$container"] }), this.schema.register("$block", { allowIn: ["$root", "$container"], isBlock: true }), this.schema.register("$blockObject", { allowWhere: "$block", isBlock: true, isObject: true }), this.schema.register("$inlineObject", { allowWhere: "$text", allowAttributesOf: "$text", isInline: true, isObject: true }), this.schema.register("$text", { allowIn: "$block", isInline: true, isContent: true }), this.schema.register("$clipboardHolder", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }), this.schema.register("$documentFragment", { allowContentOf: "$root", allowChildren: "$text", isLimit: true }), this.schema.register("$marker"), this.schema.addChildCheck((t4, e4) => {
            if ("$marker" === e4.name)
              return true;
          }), Xd2(this), this.document.registerPostFixer(Od2), this.on("insertContent", (t4, [e4, n3]) => {
            t4.return = function(t5, e5, n4) {
              return t5.change((o3) => {
                const i3 = n4 || t5.document.selection;
                i3.isCollapsed || t5.deleteContent(i3, { doNotAutoparagraph: true });
                const r3 = new pg2(t5, o3, i3.anchor), s3 = [];
                let a3;
                if (e5.is("documentFragment")) {
                  if (e5.markers.size) {
                    const t6 = [];
                    for (const [n5, o4] of e5.markers) {
                      const { start: e6, end: i4 } = o4, r4 = e6.isEqual(i4);
                      t6.push({ position: e6, name: n5, isCollapsed: r4 }, { position: i4, name: n5, isCollapsed: r4 });
                    }
                    t6.sort(({ position: t7 }, { position: e6 }) => t7.isBefore(e6) ? 1 : -1);
                    for (const { position: n5, name: i4, isCollapsed: r4 } of t6) {
                      let t7 = null, a4 = null;
                      const c4 = n5.parent === e5 && n5.isAtStart, l4 = n5.parent === e5 && n5.isAtEnd;
                      c4 || l4 ? r4 && (a4 = c4 ? "start" : "end") : (t7 = o3.createElement("$marker"), o3.insert(t7, n5)), s3.push({ name: i4, element: t7, collapsed: a4 });
                    }
                  }
                  a3 = e5.getChildren();
                } else
                  a3 = [e5];
                r3.handleNodes(a3);
                let c3 = r3.getSelectionRange();
                if (e5.is("documentFragment") && s3.length) {
                  const t6 = c3 ? md2.fromRange(c3) : null, e6 = {};
                  for (let t7 = s3.length - 1; t7 >= 0; t7--) {
                    const { name: n5, element: i4, collapsed: a4 } = s3[t7], c4 = !e6[n5];
                    if (c4 && (e6[n5] = []), i4) {
                      const t8 = o3.createPositionAt(i4, "before");
                      e6[n5].push(t8), o3.remove(i4);
                    } else {
                      const t8 = r3.getAffectedRange();
                      if (!t8) {
                        a4 && e6[n5].push(r3.position);
                        continue;
                      }
                      a4 ? e6[n5].push(t8[a4]) : e6[n5].push(c4 ? t8.start : t8.end);
                    }
                  }
                  for (const [t7, [n5, i4]] of Object.entries(e6))
                    n5 && i4 && n5.root === i4.root && o3.addMarker(t7, { usingOperation: true, affectsData: true, range: new Wl(n5, i4) });
                  t6 && (c3 = t6.toRange(), t6.detach());
                }
                c3 && (i3 instanceof wd2 ? o3.setSelection(c3) : i3.setTo(c3));
                const l3 = r3.getAffectedRange() || t5.createRange(i3.anchor);
                return r3.destroy(), l3;
              });
            }(this, e4, n3);
          }), this.on("insertObject", (t4, [e4, n3, o3]) => {
            t4.return = fg2(this, e4, n3, o3);
          }), this.on("canEditAt", (t4) => {
            const e4 = !this.document.isReadOnly;
            t4.return = e4, e4 || t4.stop();
          });
        }
        change(t4) {
          try {
            return 0 === this._pendingChanges.length ? (this._pendingChanges.push({ batch: new ku(), callback: t4 }), this._runPendingChanges()[0]) : t4(this._currentWriter);
          } catch (t5) {
            A2.rethrowUnexpectedError(t5, this);
          }
        }
        enqueueChange(t4, e4) {
          try {
            t4 ? "function" == typeof t4 ? (e4 = t4, t4 = new ku()) : t4 instanceof ku || (t4 = new ku(t4)) : t4 = new ku(), this._pendingChanges.push({ batch: t4, callback: e4 }), 1 == this._pendingChanges.length && this._runPendingChanges();
          } catch (t5) {
            A2.rethrowUnexpectedError(t5, this);
          }
        }
        applyOperation(t4) {
          t4._execute();
        }
        insertContent(t4, e4, n3, ...o3) {
          const i3 = vg2(e4, n3);
          return this.fire("insertContent", [t4, i3, n3, ...o3]);
        }
        insertObject(t4, e4, n3, o3, ...i3) {
          const r3 = vg2(e4, n3);
          return this.fire("insertObject", [t4, r3, o3, o3, ...i3]);
        }
        deleteContent(t4, e4) {
          ag2(this, t4, e4);
        }
        modifySelection(t4, e4) {
          !function(t5, e5, n3 = {}) {
            const o3 = t5.schema, i3 = "backward" != n3.direction, r3 = n3.unit ? n3.unit : "character", s3 = !!n3.treatEmojiAsSingleUnit, a3 = e5.focus, c3 = new jl2({ boundaries: wg2(a3, i3), singleCharacters: true, direction: i3 ? "forward" : "backward" }), l3 = { walker: c3, schema: o3, isForward: i3, unit: r3, treatEmojiAsSingleUnit: s3 };
            let d3;
            for (; d3 = c3.next(); ) {
              if (d3.done)
                return;
              const n4 = bg2(l3, d3.value);
              if (n4)
                return void (e5 instanceof wd2 ? t5.change((t6) => {
                  t6.setSelectionFocus(n4);
                }) : e5.setFocus(n4));
            }
          }(this, t4, e4);
        }
        getSelectedContent(t4) {
          return function(t5, e4) {
            return t5.change((t6) => {
              const n3 = t6.createDocumentFragment(), o3 = e4.getFirstRange();
              if (!o3 || o3.isCollapsed)
                return n3;
              const i3 = o3.start.root, r3 = o3.start.getCommonPath(o3.end), s3 = i3.getNodeByPath(r3);
              let a3;
              a3 = o3.start.parent == o3.end.parent ? o3 : t6.createRange(t6.createPositionAt(s3, o3.start.path[r3.length]), t6.createPositionAt(s3, o3.end.path[r3.length] + 1));
              const c3 = a3.end.offset - a3.start.offset;
              for (const e5 of a3.getItems({ shallow: true }))
                e5.is("$textProxy") ? t6.appendText(e5.data, e5.getAttributes(), n3) : t6.append(t6.cloneElement(e5, true), n3);
              if (a3 != o3) {
                const e5 = o3._getTransformedByMove(a3.start, t6.createPositionAt(n3, 0), c3)[0], i4 = t6.createRange(t6.createPositionAt(n3, 0), e5.start);
                gg2(t6.createRange(e5.end, t6.createPositionAt(n3, "end")), t6), gg2(i4, t6);
              }
              return n3;
            });
          }(this, t4);
        }
        hasContent(t4, e4 = {}) {
          const n3 = t4 instanceof Wl ? t4 : Wl._createIn(t4);
          if (n3.isCollapsed)
            return false;
          const { ignoreWhitespaces: o3 = false, ignoreMarkers: i3 = false } = e4;
          if (!i3) {
            for (const t5 of this.markers.getMarkersIntersectingRange(n3))
              if (t5.affectsData)
                return true;
          }
          for (const t5 of n3.getItems())
            if (this.schema.isContent(t5)) {
              if (!t5.is("$textProxy"))
                return true;
              if (!o3)
                return true;
              if (-1 !== t5.data.search(/\S/))
                return true;
            }
          return false;
        }
        canEditAt(t4) {
          const e4 = vg2(t4);
          return this.fire("canEditAt", [e4]);
        }
        createPositionFromPath(t4, e4, n3) {
          return new Fl(t4, e4, n3);
        }
        createPositionAt(t4, e4) {
          return Fl._createAt(t4, e4);
        }
        createPositionAfter(t4) {
          return Fl._createAfter(t4);
        }
        createPositionBefore(t4) {
          return Fl._createBefore(t4);
        }
        createRange(t4, e4) {
          return new Wl(t4, e4);
        }
        createRangeIn(t4) {
          return Wl._createIn(t4);
        }
        createRangeOn(t4) {
          return Wl._createOn(t4);
        }
        createSelection(...t4) {
          return new cd2(...t4);
        }
        createBatch(t4) {
          return new ku(t4);
        }
        createOperationFromJSON(t4) {
          return nu.fromJSON(t4, this.document);
        }
        destroy() {
          this.document.destroy(), this.stopListening();
        }
        _runPendingChanges() {
          const t4 = [];
          this.fire("_beforeChanges");
          try {
            for (; this._pendingChanges.length; ) {
              const e4 = this._pendingChanges[0].batch;
              this._currentWriter = new eg2(this, e4);
              const n3 = this._pendingChanges[0].callback(this._currentWriter);
              t4.push(n3), this.document._handleChangeBlock(this._currentWriter), this._pendingChanges.shift(), this._currentWriter = null;
            }
          } finally {
            this._pendingChanges.length = 0, this._currentWriter = null, this.fire("_afterChanges");
          }
          return t4;
        }
      }
      function vg2(t4, e4) {
        if (t4)
          return t4 instanceof cd2 || t4 instanceof wd2 ? t4 : t4 instanceof Nl ? e4 || 0 === e4 ? new cd2(t4, e4) : t4.is("rootElement") ? new cd2(t4, "in") : new cd2(t4, "on") : new cd2(t4);
      }
      class yg2 extends Lc2 {
        constructor() {
          super(...arguments), this.domEventType = "click";
        }
        onDomEvent(t4) {
          this.fire(t4.type, t4);
        }
      }
      class xg2 extends Lc2 {
        constructor() {
          super(...arguments), this.domEventType = ["mousedown", "mouseup", "mouseover", "mouseout"];
        }
        onDomEvent(t4) {
          this.fire(t4.type, t4);
        }
      }
      class Eg2 {
        constructor(t4) {
          this.document = t4;
        }
        createDocumentFragment(t4) {
          return new $a(this.document, t4);
        }
        createElement(t4, e4, n3) {
          return new ba(this.document, t4, e4, n3);
        }
        createText(t4) {
          return new fs(this.document, t4);
        }
        clone(t4, e4 = false) {
          return t4._clone(e4);
        }
        appendChild(t4, e4) {
          return e4._appendChild(t4);
        }
        insertChild(t4, e4, n3) {
          return n3._insertChild(t4, e4);
        }
        removeChildren(t4, e4, n3) {
          return n3._removeChildren(t4, e4);
        }
        remove(t4) {
          const e4 = t4.parent;
          return e4 ? this.removeChildren(e4.getChildIndex(t4), 1, e4) : [];
        }
        replace(t4, e4) {
          const n3 = t4.parent;
          if (n3) {
            const o3 = n3.getChildIndex(t4);
            return this.removeChildren(o3, 1, n3), this.insertChild(o3, e4, n3), true;
          }
          return false;
        }
        unwrapElement(t4) {
          const e4 = t4.parent;
          if (e4) {
            const n3 = e4.getChildIndex(t4);
            this.remove(t4), this.insertChild(n3, t4.getChildren(), e4);
          }
        }
        rename(t4, e4) {
          const n3 = new ba(this.document, t4, e4.getAttributes(), e4.getChildren());
          return this.replace(e4, n3) ? n3 : null;
        }
        setAttribute(t4, e4, n3) {
          n3._setAttribute(t4, e4);
        }
        removeAttribute(t4, e4) {
          e4._removeAttribute(t4);
        }
        addClass(t4, e4) {
          e4._addClass(t4);
        }
        removeClass(t4, e4) {
          e4._removeClass(t4);
        }
        setStyle(t4, e4, n3) {
          Et2(t4) && void 0 === n3 ? e4._setStyle(t4) : n3._setStyle(t4, e4);
        }
        removeStyle(t4, e4) {
          e4._removeStyle(t4);
        }
        setCustomProperty(t4, e4, n3) {
          n3._setCustomProperty(t4, e4);
        }
        removeCustomProperty(t4, e4) {
          return e4._removeCustomProperty(t4);
        }
        createPositionAt(t4, e4) {
          return Ea2._createAt(t4, e4);
        }
        createPositionAfter(t4) {
          return Ea2._createAfter(t4);
        }
        createPositionBefore(t4) {
          return Ea2._createBefore(t4);
        }
        createRange(t4, e4) {
          return new Da2(t4, e4);
        }
        createRangeOn(t4) {
          return Da2._createOn(t4);
        }
        createRangeIn(t4) {
          return Da2._createIn(t4);
        }
        createSelection(...t4) {
          return new Ia2(...t4);
        }
      }
      class Dg2 {
        constructor() {
          this._commands = /* @__PURE__ */ new Map();
        }
        add(t4, e4) {
          this._commands.set(t4, e4);
        }
        get(t4) {
          return this._commands.get(t4);
        }
        execute(t4, ...e4) {
          const n3 = this.get(t4);
          if (!n3)
            throw new A2("commandcollection-command-not-found", this, { commandName: t4 });
          return n3.execute(...e4);
        }
        *names() {
          yield* this._commands.keys();
        }
        *commands() {
          yield* this._commands.values();
        }
        [Symbol.iterator]() {
          return this._commands[Symbol.iterator]();
        }
        destroy() {
          for (const t4 of this.commands())
            t4.destroy();
        }
      }
      class Sg2 extends W2() {
        constructor(t4 = {}) {
          super();
          const e4 = this.constructor, n3 = t4.language || e4.defaultConfig && e4.defaultConfig.language;
          this._context = t4.context || new es({ language: n3 }), this._context._addEditor(this, !t4.context);
          const o3 = Array.from(e4.builtinPlugins || []);
          this.config = new xo2(t4, e4.defaultConfig), this.config.define("plugins", o3), this.config.define(this._context._getEditorConfig()), this.plugins = new ts(this, o3, this._context.plugins), this.locale = this._context.locale, this.t = this.locale.t, this._readOnlyLocks = /* @__PURE__ */ new Set(), this.commands = new Dg2(), this.set("state", "initializing"), this.once("ready", () => this.state = "ready", { priority: "high" }), this.once("destroy", () => this.state = "destroyed", { priority: "high" }), this.model = new _g(), this.on("change:isReadOnly", () => {
            this.model.document.isReadOnly = this.isReadOnly;
          });
          const i3 = new ma2();
          this.data = new Bh2(this.model, i3), this.editing = new oh2(this.model, i3), this.editing.view.document.bind("isReadOnly").to(this), this.conversion = new Nh2([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher), this.conversion.addAlias("dataDowncast", this.data.downcastDispatcher), this.conversion.addAlias("editingDowncast", this.editing.downcastDispatcher), this.keystrokes = new os(this), this.keystrokes.listenTo(this.editing.view.document);
        }
        get isReadOnly() {
          return this._readOnlyLocks.size > 0;
        }
        set isReadOnly(t4) {
          throw new A2("editor-isreadonly-has-no-setter");
        }
        enableReadOnlyMode(t4) {
          if ("string" != typeof t4 && "symbol" != typeof t4)
            throw new A2("editor-read-only-lock-id-invalid", null, { lockId: t4 });
          this._readOnlyLocks.has(t4) || (this._readOnlyLocks.add(t4), 1 === this._readOnlyLocks.size && this.fire("change:isReadOnly", "isReadOnly", true, false));
        }
        disableReadOnlyMode(t4) {
          if ("string" != typeof t4 && "symbol" != typeof t4)
            throw new A2("editor-read-only-lock-id-invalid", null, { lockId: t4 });
          this._readOnlyLocks.has(t4) && (this._readOnlyLocks.delete(t4), 0 === this._readOnlyLocks.size && this.fire("change:isReadOnly", "isReadOnly", false, true));
        }
        initPlugins() {
          const t4 = this.config, e4 = t4.get("plugins"), n3 = t4.get("removePlugins") || [], o3 = t4.get("extraPlugins") || [], i3 = t4.get("substitutePlugins") || [];
          return this.plugins.init(e4.concat(o3), n3, i3);
        }
        destroy() {
          let t4 = Promise.resolve();
          return "initializing" == this.state && (t4 = new Promise((t5) => this.once("ready", t5))), t4.then(() => {
            this.fire("destroy"), this.stopListening(), this.commands.destroy();
          }).then(() => this.plugins.destroy()).then(() => {
            this.model.destroy(), this.data.destroy(), this.editing.destroy(), this.keystrokes.destroy();
          }).then(() => this._context._removeEditor(this));
        }
        execute(t4, ...e4) {
          try {
            return this.commands.execute(t4, ...e4);
          } catch (t5) {
            A2.rethrowUnexpectedError(t5, this);
          }
        }
        focus() {
          this.editing.view.focus();
        }
        static create(...t4) {
          throw new Error("This is an abstract method.");
        }
      }
      function Ig2(t4) {
        return class extends t4 {
          setData(t5) {
            this.data.set(t5);
          }
          getData(t5) {
            return this.data.get(t5);
          }
        };
      }
      {
        const t4 = Ig2(Object);
        Ig2.setData = t4.prototype.setData, Ig2.getData = t4.prototype.getData;
      }
      function Tg2(t4) {
        return class extends t4 {
          updateSourceElement(t5 = this.data.get()) {
            if (!this.sourceElement)
              throw new A2("editor-missing-sourceelement", this);
            const e4 = this.config.get("updateSourceElementOnDestroy"), n3 = this.sourceElement instanceof HTMLTextAreaElement;
            Yo2(this.sourceElement, e4 || n3 ? t5 : "");
          }
        };
      }
      Tg2.updateSourceElement = Tg2(Object).prototype.updateSourceElement;
      class Mg2 extends ns {
        static get pluginName() {
          return "PendingActions";
        }
        init() {
          this.set("hasAny", false), this._actions = new Di2({ idProperty: "_id" }), this._actions.delegate("add", "remove").to(this);
        }
        add(t4) {
          if ("string" != typeof t4)
            throw new A2("pendingactions-add-invalid-message", this);
          const e4 = new (W2())();
          return e4.set("message", t4), this._actions.add(e4), this.hasAny = true, e4;
        }
        remove(t4) {
          this._actions.remove(t4), this.hasAny = !!this._actions.length;
        }
        get first() {
          return this._actions.get(0);
        }
        [Symbol.iterator]() {
          return this._actions[Symbol.iterator]();
        }
      }
      const Bg2 = { bold: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z"/></svg>', cancel: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.591 10.177 4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z"/></svg>', caption: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 16h9a1 1 0 0 1 0 2H2a1 1 0 0 1 0-2z"/><path d="M17 1a2 2 0 0 1 2 2v9a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V3a2 2 0 0 1 2-2h14zm0 1.5H3a.5.5 0 0 0-.492.41L2.5 3v9a.5.5 0 0 0 .41.492L3 12.5h14a.5.5 0 0 0 .492-.41L17.5 12V3a.5.5 0 0 0-.41-.492L17 2.5z" fill-opacity=".6"/></svg>', check: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z"/></svg>', cog: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.333 2 .19 2.263a5.899 5.899 0 0 1 1.458.604L14.714 3.4 16.6 5.286l-1.467 1.733c.263.452.468.942.605 1.46L18 8.666v2.666l-2.263.19a5.899 5.899 0 0 1-.604 1.458l1.467 1.733-1.886 1.886-1.733-1.467a5.899 5.899 0 0 1-1.46.605L11.334 18H8.667l-.19-2.263a5.899 5.899 0 0 1-1.458-.604L5.286 16.6 3.4 14.714l1.467-1.733a5.899 5.899 0 0 1-.604-1.458L2 11.333V8.667l2.262-.189a5.899 5.899 0 0 1 .605-1.459L3.4 5.286 5.286 3.4l1.733 1.467a5.899 5.899 0 0 1 1.46-.605L8.666 2h2.666zM10 6.267a3.733 3.733 0 1 0 0 7.466 3.733 3.733 0 0 0 0-7.466z"/></svg>', eraser: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m8.636 9.531-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z"/><path d="M4 18h5.523v-1H4zm-2 0h1v-1H2z"/></svg>', history: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11 1a9 9 0 1 1-8.027 13.075l1.128-1.129A7.502 7.502 0 0 0 18.5 10a7.5 7.5 0 1 0-14.962.759l-.745-.746-.76.76A9 9 0 0 1 11 1z"/><path d="M.475 8.17a.75.75 0 0 1 .978.047l.075.082 1.284 1.643 1.681-1.284a.75.75 0 0 1 .978.057l.073.083a.75.75 0 0 1-.057.978l-.083.073-2.27 1.737a.75.75 0 0 1-.973-.052l-.074-.082-1.741-2.23a.75.75 0 0 1 .13-1.052z"/><path d="M11.5 5v4.999l3.196 3.196-1.06 1.06L10.1 10.72l-.1-.113V5z"/></svg>', image: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z"/></svg>', lowVision: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5.085 6.22 2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z"/></svg>', loupe: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M12.68 13.74h-.001l4.209 4.208a1 1 0 1 0 1.414-1.414l-4.267-4.268a6 6 0 1 0-1.355 1.474ZM13 9a4 4 0 1 1-8 0 4 4 0 0 1 8 0Z"/></svg>', importExport: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M19 4.5 14 0H3v12.673l.868-1.041c.185-.222.4-.402.632-.54V1.5h8v5h5v7.626a2.24 2.24 0 0 1 1.5.822V4.5ZM14 5V2l3.3 3H14Zm-3.692 12.5c.062.105.133.206.213.303L11.52 19H8v-.876a2.243 2.243 0 0 0 1.82-.624h.488Zm7.518-.657a.75.75 0 0 0-1.152-.96L15.5 17.29V12H14v5.29l-1.174-1.408a.75.75 0 0 0-1.152.96l2.346 2.816a.95.95 0 0 0 1.46 0l2.346-2.815Zm-15.056-.38a.75.75 0 0 1-.096-1.056l2.346-2.815a.95.95 0 0 1 1.46 0l2.346 2.815a.75.75 0 1 1-1.152.96L6.5 14.96V20H5v-5.04l-1.174 1.408a.75.75 0 0 1-1.056.096Z"/></svg>', paragraph: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10.5 5.5H7v5h3.5a2.5 2.5 0 1 0 0-5zM5 3h6.5v.025a5 5 0 0 1 0 9.95V13H7v4a1 1 0 0 1-1 1H5a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z"/></svg>', plus: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M10 2a1 1 0 0 0-1 1v6H3a1 1 0 1 0 0 2h6v6a1 1 0 1 0 2 0v-6h6a1 1 0 1 0 0-2h-6V3a1 1 0 0 0-1-1Z"/></svg>', text: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.816 11.5 7.038 4.785 4.261 11.5h5.555Zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13Z"/><path d="m12.09 17-.534-1.292.848-1.971.545 1.319L12.113 17h-.023Zm1.142-5.187.545 1.319L15.5 9.13l1.858 4.316h-3.45l.398.965h3.467L18.887 17H20l-3.873-9h-1.254l-1.641 3.813Z"/></svg>', alignBottom: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.239 13.938-2.88-1.663a.75.75 0 0 1 .75-1.3L9 12.067V4.75a.75.75 0 1 1 1.5 0v7.318l1.89-1.093a.75.75 0 0 1 .75 1.3l-2.879 1.663a.752.752 0 0 1-.511.187.752.752 0 0 1-.511-.187zM4.25 17a.75.75 0 1 1 0-1.5h10.5a.75.75 0 0 1 0 1.5H4.25z"/></svg>', alignMiddle: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M9.75 11.875a.752.752 0 0 1 .508.184l2.883 1.666a.75.75 0 0 1-.659 1.344l-.091-.044-1.892-1.093.001 4.318a.75.75 0 1 1-1.5 0v-4.317l-1.89 1.092a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .51-.187zM15.25 9a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM9.75.375a.75.75 0 0 1 .75.75v4.318l1.89-1.093.092-.045a.75.75 0 0 1 .659 1.344l-2.883 1.667a.752.752 0 0 1-.508.184.752.752 0 0 1-.511-.187L6.359 5.65a.75.75 0 0 1 .75-1.299L9 5.442V1.125a.75.75 0 0 1 .75-.75z"/></svg>', alignTop: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m10.261 7.062 2.88 1.663a.75.75 0 0 1-.75 1.3L10.5 8.933v7.317a.75.75 0 1 1-1.5 0V8.932l-1.89 1.093a.75.75 0 0 1-.75-1.3l2.879-1.663a.752.752 0 0 1 .511-.187.752.752 0 0 1 .511.187zM15.25 4a.75.75 0 1 1 0 1.5H4.75a.75.75 0 0 1 0-1.5h10.5z"/></svg>', alignLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', alignCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z"/></svg>', alignRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z"/></svg>', alignJustify: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z"/></svg>', objectLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zm0-3H18v1.5h-4.5zm0-3H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectCenter: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M15.003 7v5.5a1 1 0 0 1-1 1H5.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H6.5V12h6.997V7.5z"/></svg>', objectRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2zm0-9h5v1.5H2zm0 3h5v1.5H2zm0 3h5v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectFullWidth: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18 7v5.5a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h14a1 1 0 0 1 1 1zm-1.505.5H3.504V12h12.991V7.5z"/></svg>', objectInline: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm11.5 9H18v1.5h-4.5zM2 15h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockLeft: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M12.003 7v5.5a1 1 0 0 1-1 1H2.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H3.5V12h6.997V7.5z"/></svg>', objectBlockRight: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path opacity=".5" d="M2 3h16v1.5H2zm0 12h16v1.5H2z"/><path d="M18.003 7v5.5a1 1 0 0 1-1 1H8.996a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h8.007a1 1 0 0 1 1 1zm-1.506.5H9.5V12h6.997V7.5z"/></svg>', objectSizeFull: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M18.095 2H1.905C.853 2 0 2.895 0 4v12c0 1.105.853 2 1.905 2h16.19C19.147 18 20 17.105 20 16V4c0-1.105-.853-2-1.905-2zm0 1.5c.263 0 .476.224.476.5v12c0 .276-.213.5-.476.5H1.905a.489.489 0 0 1-.476-.5V4c0-.276.213-.5.476-.5h16.19z"/></svg>', objectSizeLarge: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M13 6H2a2 2 0 0 0-2 2v8a2 2 0 0 0 2 2h11a2 2 0 0 0 2-2V8a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v8a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5V8a.5.5 0 0 1 .5-.5h11z"/></svg>', objectSizeSmall: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M7 10H2a2 2 0 0 0-2 2v4a2 2 0 0 0 2 2h5a2 2 0 0 0 2-2v-4a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-4a.5.5 0 0 1 .5-.5h5z"/></svg>', objectSizeMedium: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M2.5 17v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zm2 0v1h-1v-1h1zM1 15.5v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm-19-2v1H0v-1h1zm19 0v1h-1v-1h1zm0-2v1h-1v-1h1zm-19 0v1H0v-1h1zM14.5 2v1h-1V2h1zm2 0v1h-1V2h1zm2 0v1h-1V2h1zm-8 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm-2 0v1h-1V2h1zm8 0v1h-1V2h1zm-10 0v1h-1V2h1z"/><path d="M10 8H2a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm0 1.5a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5v-6a.5.5 0 0 1 .5-.5h8z"/></svg>', pencil: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m7.3 17.37-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506 13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5 9.375 17H19v1.5H8z"/></svg>', pilcrow: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M6.999 2H15a1 1 0 0 1 0 2h-1.004v13a1 1 0 1 1-2 0V4H8.999v13a1 1 0 1 1-2 0v-7A4 4 0 0 1 3 6a4 4 0 0 1 3.999-4z"/></svg>', quote: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 10.423a6.5 6.5 0 0 1 6.056-6.408l.038.67C6.448 5.423 5.354 7.663 5.22 10H9c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574zm8 0a6.5 6.5 0 0 1 6.056-6.408l.038.67c-2.646.739-3.74 2.979-3.873 5.315H17c.552 0 .5.432.5.986v4.511c0 .554-.448.503-1 .503h-5c-.552 0-.5-.449-.5-1.003v-4.574z"/></svg>', threeVerticalDots: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><circle cx="9.5" cy="4.5" r="1.5"/><circle cx="9.5" cy="10.5" r="1.5"/><circle cx="9.5" cy="16.5" r="1.5"/></svg>', dragIndicator: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M5 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 3.25a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 10a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M5 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/><path d="M12 16.75a1.5 1.5 0 1 0 3 0 1.5 1.5 0 1 0-3 0"/></svg>' };
      var Ng2 = n2(5542), Pg2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Ng2.Z, Pg2);
      Ng2.Z.locals;
      const { threeVerticalDots: zg2 } = Bg2, Og2 = { alignLeft: Bg2.alignLeft, bold: Bg2.bold, importExport: Bg2.importExport, paragraph: Bg2.paragraph, plus: Bg2.plus, text: Bg2.text, threeVerticalDots: Bg2.threeVerticalDots, pilcrow: Bg2.pilcrow, dragIndicator: Bg2.dragIndicator };
      class Lg2 extends Hi2 {
        constructor(t4, e4) {
          super(t4);
          const n3 = this.bindTemplate, o3 = this.t;
          this.options = e4 || {}, this.set("ariaLabel", o3("Editor toolbar")), this.set("maxWidth", "auto"), this.items = this.createCollection(), this.focusTracker = new Ii2(), this.keystrokes = new Ti2(), this.set("class", void 0), this.set("isCompact", false), this.itemsView = new jg2(t4), this.children = this.createCollection(), this.children.add(this.itemsView), this.focusables = this.createCollection();
          const i3 = "rtl" === t4.uiLanguageDirection;
          this._focusCycler = new qr({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: [i3 ? "arrowright" : "arrowleft", "arrowup"], focusNext: [i3 ? "arrowleft" : "arrowright", "arrowdown"] } });
          const r3 = ["ck", "ck-toolbar", n3.to("class"), n3.if("isCompact", "ck-toolbar_compact")];
          var s3;
          this.options.shouldGroupWhenFull && this.options.isFloating && r3.push("ck-toolbar_floating"), this.setTemplate({ tag: "div", attributes: { class: r3, role: "toolbar", "aria-label": n3.to("ariaLabel"), style: { maxWidth: n3.to("maxWidth") }, tabindex: -1 }, children: this.children, on: { mousedown: (s3 = this, s3.bindTemplate.to((t5) => {
            t5.target === s3.element && t5.preventDefault();
          })) } }), this._behavior = this.options.shouldGroupWhenFull ? new Fg2(this) : new Rg2(this);
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
          for (const t4 of this.items)
            this.focusTracker.add(t4.element);
          this.items.on("add", (t4, e4) => {
            this.focusTracker.add(e4.element);
          }), this.items.on("remove", (t4, e4) => {
            this.focusTracker.remove(e4.element);
          }), this.keystrokes.listenTo(this.element), this._behavior.render(this);
        }
        destroy() {
          return this._behavior.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy(), super.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        fillFromConfig(t4, e4, n3) {
          this.items.addMany(this._buildItemsFromConfig(t4, e4, n3));
        }
        _buildItemsFromConfig(t4, e4, n3) {
          const o3 = Yr(t4), i3 = n3 || o3.removeItems;
          return this._cleanItemsConfiguration(o3.items, e4, i3).map((t5) => R2(t5) ? this._createNestedToolbarDropdown(t5, e4, i3) : "|" === t5 ? new Wr() : "-" === t5 ? new Kr() : e4.create(t5)).filter((t5) => !!t5);
        }
        _cleanItemsConfiguration(t4, e4, n3) {
          const o3 = t4.filter((t5, o4, i3) => "|" === t5 || -1 === n3.indexOf(t5) && ("-" === t5 ? !this.options.shouldGroupWhenFull || (C2("toolbarview-line-break-ignored-when-grouping-items", i3), false) : !(!R2(t5) && !e4.has(t5)) || (C2("toolbarview-item-unavailable", { item: t5 }), false)));
          return this._cleanSeparatorsAndLineBreaks(o3);
        }
        _cleanSeparatorsAndLineBreaks(t4) {
          const e4 = (t5) => "-" !== t5 && "|" !== t5, n3 = t4.length, o3 = t4.findIndex(e4);
          if (-1 === o3)
            return [];
          const i3 = n3 - t4.slice().reverse().findIndex(e4);
          return t4.slice(o3, i3).filter((t5, n4, o4) => {
            if (e4(t5))
              return true;
            return !(n4 > 0 && o4[n4 - 1] === t5);
          });
        }
        _createNestedToolbarDropdown(t4, e4, n3) {
          let { label: o3, icon: i3, items: r3, tooltip: s3 = true, withText: a3 = false } = t4;
          if (r3 = this._cleanItemsConfiguration(r3, e4, n3), !r3.length)
            return null;
          const c3 = tp(this.locale);
          return o3 || C2("toolbarview-nested-toolbar-dropdown-missing-label", t4), c3.class = "ck-toolbar__nested-toolbar-dropdown", c3.buttonView.set({ label: o3, tooltip: s3, withText: !!a3 }), false !== i3 ? c3.buttonView.icon = Og2[i3] || i3 || zg2 : c3.buttonView.withText = true, ep(c3, () => c3.toolbarView._buildItemsFromConfig(r3, e4, n3)), c3;
        }
      }
      class jg2 extends Hi2 {
        constructor(t4) {
          super(t4), this.children = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-toolbar__items"] }, children: this.children });
        }
      }
      class Rg2 {
        constructor(t4) {
          const e4 = t4.bindTemplate;
          t4.set("isVertical", false), t4.itemsView.children.bindTo(t4.items).using((t5) => t5), t4.focusables.bindTo(t4.items).using((t5) => t5), t4.extendTemplate({ attributes: { class: [e4.if("isVertical", "ck-toolbar_vertical")] } });
        }
        render() {
        }
        destroy() {
        }
      }
      class Fg2 {
        constructor(t4) {
          this.resizeObserver = null, this.cachedPadding = null, this.shouldUpdateGroupingOnNextResize = false, this.view = t4, this.viewChildren = t4.children, this.viewFocusables = t4.focusables, this.viewItemsView = t4.itemsView, this.viewFocusTracker = t4.focusTracker, this.viewLocale = t4.locale, this.ungroupedItems = t4.createCollection(), this.groupedItems = t4.createCollection(), this.groupedItemsDropdown = this._createGroupedItemsDropdown(), t4.itemsView.children.bindTo(this.ungroupedItems).using((t5) => t5), this.ungroupedItems.on("change", this._updateFocusCycleableItems.bind(this)), t4.children.on("change", this._updateFocusCycleableItems.bind(this)), t4.items.on("change", (t5, e4) => {
            const n3 = e4.index, o3 = Array.from(e4.added);
            for (const t6 of e4.removed)
              n3 >= this.ungroupedItems.length ? this.groupedItems.remove(t6) : this.ungroupedItems.remove(t6);
            for (let t6 = n3; t6 < n3 + o3.length; t6++) {
              const e5 = o3[t6 - n3];
              t6 > this.ungroupedItems.length ? this.groupedItems.add(e5, t6 - this.ungroupedItems.length) : this.ungroupedItems.add(e5, t6);
            }
            this._updateGrouping();
          }), t4.extendTemplate({ attributes: { class: ["ck-toolbar_grouping"] } });
        }
        render(t4) {
          this.viewElement = t4.element, this._enableGroupingOnResize(), this._enableGroupingOnMaxWidthChange(t4);
        }
        destroy() {
          this.groupedItemsDropdown.destroy(), this.resizeObserver.destroy();
        }
        _updateGrouping() {
          if (!this.viewElement.ownerDocument.body.contains(this.viewElement))
            return;
          if (!Xo2(this.viewElement))
            return void (this.shouldUpdateGroupingOnNextResize = true);
          const t4 = this.groupedItems.length;
          let e4;
          for (; this._areItemsOverflowing; )
            this._groupLastItem(), e4 = true;
          if (!e4 && this.groupedItems.length) {
            for (; this.groupedItems.length && !this._areItemsOverflowing; )
              this._ungroupFirstItem();
            this._areItemsOverflowing && this._groupLastItem();
          }
          this.groupedItems.length !== t4 && this.view.fire("groupedItemsUpdate");
        }
        get _areItemsOverflowing() {
          if (!this.ungroupedItems.length)
            return false;
          const t4 = this.viewElement, e4 = this.viewLocale.uiLanguageDirection, n3 = new Vo2(t4.lastChild), o3 = new Vo2(t4);
          if (!this.cachedPadding) {
            const n4 = zo2.window.getComputedStyle(t4), o4 = "ltr" === e4 ? "paddingRight" : "paddingLeft";
            this.cachedPadding = Number.parseInt(n4[o4]);
          }
          return "ltr" === e4 ? n3.right > o3.right - this.cachedPadding : n3.left < o3.left + this.cachedPadding;
        }
        _enableGroupingOnResize() {
          let t4;
          this.resizeObserver = new Ko2(this.viewElement, (e4) => {
            t4 && t4 === e4.contentRect.width && !this.shouldUpdateGroupingOnNextResize || (this.shouldUpdateGroupingOnNextResize = false, this._updateGrouping(), t4 = e4.contentRect.width);
          }), this._updateGrouping();
        }
        _enableGroupingOnMaxWidthChange(t4) {
          t4.on("change:maxWidth", () => {
            this._updateGrouping();
          });
        }
        _groupLastItem() {
          this.groupedItems.length || (this.viewChildren.add(new Wr()), this.viewChildren.add(this.groupedItemsDropdown), this.viewFocusTracker.add(this.groupedItemsDropdown.element)), this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
        }
        _ungroupFirstItem() {
          this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first)), this.groupedItems.length || (this.viewChildren.remove(this.groupedItemsDropdown), this.viewChildren.remove(this.viewChildren.last), this.viewFocusTracker.remove(this.groupedItemsDropdown.element));
        }
        _createGroupedItemsDropdown() {
          const t4 = this.viewLocale, e4 = t4.t, n3 = tp(t4);
          return n3.class = "ck-toolbar__grouped-dropdown", n3.panelPosition = "ltr" === t4.uiLanguageDirection ? "sw" : "se", ep(n3, this.groupedItems), n3.buttonView.set({ label: e4("Show more items"), tooltip: true, tooltipPosition: "rtl" === t4.uiLanguageDirection ? "se" : "sw", icon: zg2 }), n3;
        }
        _updateFocusCycleableItems() {
          this.viewFocusables.clear(), this.ungroupedItems.map((t4) => {
            this.viewFocusables.add(t4);
          }), this.groupedItems.length && this.viewFocusables.add(this.groupedItemsDropdown);
        }
      }
      class Vg2 extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = this.bindTemplate, n3 = `ck-editor__label_${f2()}`, o3 = new qg2(t4);
          this.children = this.createCollection(), this.children.addMany([this._createLabel(n3), o3]), this.set({ label: "", isVisible: true }), o3.set({ role: "group", ariaLabelledBy: n3 }), o3.focusTracker.destroy(), o3.keystrokes.destroy(), this.items = o3.items, this.setTemplate({ tag: "li", attributes: { role: "presentation", class: ["ck", "ck-list__group", e4.if("isVisible", "ck-hidden", (t5) => !t5)] }, children: this.children });
        }
        _createLabel(t4) {
          const e4 = new Hi2(this.locale), n3 = this.bindTemplate;
          return e4.setTemplate({ tag: "span", attributes: { id: t4 }, children: [{ text: n3.to("label") }] }), e4;
        }
        focus() {
          this.items.first && this.items.first.focus();
        }
      }
      var Hg2 = n2(1046), Ug2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Hg2.Z, Ug2);
      Hg2.Z.locals;
      class qg2 extends Hi2 {
        constructor(t4) {
          super(t4), this._listItemGroupToChangeListeners = /* @__PURE__ */ new WeakMap();
          const e4 = this.bindTemplate;
          this.focusables = new Li2(), this.items = this.createCollection(), this.focusTracker = new Ii2(), this.keystrokes = new Ti2(), this._focusCycler = new qr({ focusables: this.focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "arrowup", focusNext: "arrowdown" } }), this.set("ariaLabel", void 0), this.set("ariaLabelledBy", void 0), this.set("role", void 0), this.setTemplate({ tag: "ul", attributes: { class: ["ck", "ck-reset", "ck-list"], role: e4.to("role"), "aria-label": e4.to("ariaLabel"), "aria-labelledby": e4.to("ariaLabelledBy") }, children: this.items });
        }
        render() {
          super.render();
          for (const t4 of this.items)
            t4 instanceof Vg2 ? this._registerFocusableItemsGroup(t4) : this._registerFocusableListItem(t4);
          this.items.on("change", (t4, e4) => {
            for (const t5 of e4.removed)
              t5 instanceof Vg2 ? this._deregisterFocusableItemsGroup(t5) : this._deregisterFocusableListItem(t5);
            for (const t5 of Array.from(e4.added).reverse())
              t5 instanceof Vg2 ? this._registerFocusableItemsGroup(t5, e4.index) : this._registerFocusableListItem(t5, e4.index);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusFirst() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
        _registerFocusableListItem(t4, e4) {
          this.focusTracker.add(t4.element), this.focusables.add(t4, e4);
        }
        _deregisterFocusableListItem(t4) {
          this.focusTracker.remove(t4.element), this.focusables.remove(t4);
        }
        _getOnGroupItemsChangeCallback(t4) {
          return (e4, n3) => {
            for (const t5 of n3.removed)
              this._deregisterFocusableListItem(t5);
            for (const e5 of Array.from(n3.added).reverse())
              this._registerFocusableListItem(e5, this.items.getIndex(t4) + n3.index);
          };
        }
        _registerFocusableItemsGroup(t4, e4) {
          Array.from(t4.items).forEach((t5, n4) => {
            const o3 = void 0 !== e4 ? e4 + n4 : void 0;
            this._registerFocusableListItem(t5, o3);
          });
          const n3 = this._getOnGroupItemsChangeCallback(t4);
          this._listItemGroupToChangeListeners.set(t4, n3), t4.items.on("change", n3);
        }
        _deregisterFocusableItemsGroup(t4) {
          for (const e4 of t4.items)
            this._deregisterFocusableListItem(e4);
          t4.items.off("change", this._listItemGroupToChangeListeners.get(t4)), this._listItemGroupToChangeListeners.delete(t4);
        }
      }
      class Gg2 extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = this.bindTemplate;
          this.set("isVisible", true), this.children = this.createCollection(), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__item", e4.if("isVisible", "ck-hidden", (t5) => !t5)], role: "presentation" }, children: this.children });
        }
        focus() {
          this.children.first && this.children.first.focus();
        }
      }
      class Wg2 extends Hi2 {
        constructor(t4) {
          super(t4), this.setTemplate({ tag: "li", attributes: { class: ["ck", "ck-list__separator"] } });
        }
      }
      var Kg2 = n2(7686), Yg2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Kg2.Z, Yg2);
      Kg2.Z.locals;
      class $g2 extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = this.bindTemplate;
          this.set("class", void 0), this.set("labelStyle", void 0), this.set("icon", void 0), this.set("isEnabled", true), this.set("isOn", false), this.set("isToggleable", false), this.set("isVisible", true), this.set("keystroke", void 0), this.set("withKeystroke", false), this.set("label", void 0), this.set("tabindex", -1), this.set("tooltip", false), this.set("tooltipPosition", "s"), this.set("type", "button"), this.set("withText", false), this.children = this.createCollection(), this.actionView = this._createActionView(), this.arrowView = this._createArrowView(), this.keystrokes = new Ti2(), this.focusTracker = new Ii2(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-splitbutton", e4.to("class"), e4.if("isVisible", "ck-hidden", (t5) => !t5), this.arrowView.bindTemplate.if("isOn", "ck-splitbutton_open")] }, children: this.children });
        }
        render() {
          super.render(), this.children.add(this.actionView), this.children.add(this.arrowView), this.focusTracker.add(this.actionView.element), this.focusTracker.add(this.arrowView.element), this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", (t4, e4) => {
            this.focusTracker.focusedElement === this.actionView.element && (this.arrowView.focus(), e4());
          }), this.keystrokes.set("arrowleft", (t4, e4) => {
            this.focusTracker.focusedElement === this.arrowView.element && (this.actionView.focus(), e4());
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this.actionView.focus();
        }
        _createActionView() {
          const t4 = new br();
          return t4.bind("icon", "isEnabled", "isOn", "isToggleable", "keystroke", "label", "tabindex", "tooltip", "tooltipPosition", "type", "withText").to(this), t4.extendTemplate({ attributes: { class: "ck-splitbutton__action" } }), t4.delegate("execute").to(this), t4;
        }
        _createArrowView() {
          const t4 = new br(), e4 = t4.bindTemplate;
          return t4.icon = Hr, t4.extendTemplate({ attributes: { class: ["ck-splitbutton__arrow"], "data-cke-tooltip-disabled": e4.to("isOn"), "aria-haspopup": true, "aria-expanded": e4.to("isOn", (t5) => String(t5)) } }), t4.bind("isEnabled").to(this), t4.bind("label").to(this), t4.bind("tooltip").to(this), t4.delegate("execute").to(this, "open"), t4;
        }
      }
      var Zg2 = n2(7339), Qg2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Zg2.Z, Qg2);
      Zg2.Z.locals;
      var Jg2 = n2(3949), Xg2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Jg2.Z, Xg2);
      Jg2.Z.locals;
      function tp(e4, n3 = Ur) {
        const o3 = new n3(e4), i3 = new Lr(e4), r3 = new Vr(e4, o3, i3);
        return o3.bind("isEnabled").to(r3), o3 instanceof $g2 ? o3.arrowView.bind("isOn").to(r3, "isOpen") : o3.bind("isOn").to(r3, "isOpen"), function(e5) {
          (function(e6) {
            e6.on("render", () => {
              t3({ emitter: e6, activator: () => e6.isOpen, callback: () => {
                e6.isOpen = false;
              }, contextElements: () => [e6.element, ...e6.focusTracker._elements] });
            });
          })(e5), function(t4) {
            t4.on("execute", (e6) => {
              e6.source instanceof Cr || (t4.isOpen = false);
            });
          }(e5), function(t4) {
            t4.focusTracker.on("change:isFocused", (e6, n4, o4) => {
              t4.isOpen && !o4 && (t4.isOpen = false);
            });
          }(e5), function(t4) {
            t4.keystrokes.set("arrowdown", (e6, n4) => {
              t4.isOpen && (t4.panelView.focus(), n4());
            }), t4.keystrokes.set("arrowup", (e6, n4) => {
              t4.isOpen && (t4.panelView.focusLast(), n4());
            });
          }(e5), function(t4) {
            t4.on("change:isOpen", (e6, n4, o4) => {
              if (o4)
                return;
              const i4 = t4.panelView.element;
              i4 && i4.contains(zo2.document.activeElement) && t4.buttonView.focus();
            });
          }(e5), function(t4) {
            t4.on("change:isOpen", (e6, n4, o4) => {
              o4 && t4.panelView.focus();
            }, { priority: "low" });
          }(e5);
        }(r3), r3;
      }
      function ep(t4, e4, n3 = {}) {
        t4.extendTemplate({ attributes: { class: ["ck-toolbar-dropdown"] } }), t4.isOpen ? np(t4, e4, n3) : t4.once("change:isOpen", () => np(t4, e4, n3), { priority: "highest" }), n3.enableActiveItemFocusOnDropdownOpen && rp(t4, () => t4.toolbarView.items.find((t5) => t5.isOn));
      }
      function np(t4, e4, n3) {
        const o3 = t4.locale, i3 = o3.t, r3 = t4.toolbarView = new Lg2(o3), s3 = "function" == typeof e4 ? e4() : e4;
        r3.ariaLabel = n3.ariaLabel || i3("Dropdown toolbar"), n3.maxWidth && (r3.maxWidth = n3.maxWidth), n3.class && (r3.class = n3.class), n3.isCompact && (r3.isCompact = n3.isCompact), n3.isVertical && (r3.isVertical = true), s3 instanceof Li2 ? r3.items.bindTo(s3).using((t5) => t5) : r3.items.addMany(s3), t4.panelView.children.add(r3), r3.items.delegate("execute").to(t4);
      }
      function op(t4, e4, n3 = {}) {
        t4.isOpen ? ip(t4, e4, n3) : t4.once("change:isOpen", () => ip(t4, e4, n3), { priority: "highest" }), rp(t4, () => t4.listView.items.find((t5) => t5 instanceof Gg2 && t5.children.first.isOn));
      }
      function ip(t4, e4, n3) {
        const o3 = t4.locale, i3 = t4.listView = new qg2(o3), r3 = "function" == typeof e4 ? e4() : e4;
        i3.ariaLabel = n3.ariaLabel, i3.role = n3.role, sp(t4, i3.items, r3, o3), t4.panelView.children.add(i3), i3.items.delegate("execute").to(t4);
      }
      function rp(t4, e4) {
        t4.on("change:isOpen", () => {
          if (!t4.isOpen)
            return;
          const n3 = e4();
          n3 && ("function" == typeof n3.focus ? n3.focus() : C2("ui-dropdown-focus-child-on-open-child-missing-focus", { view: n3 }));
        }, { priority: k2.low - 10 });
      }
      function sp(t4, e4, n3, o3) {
        e4.bindTo(n3).using((e5) => {
          if ("separator" === e5.type)
            return new Wg2(o3);
          if ("group" === e5.type) {
            const n4 = new Vg2(o3);
            return n4.set({ label: e5.label }), sp(t4, n4.items, e5.items, o3), n4.items.delegate("execute").to(t4), n4;
          }
          if ("button" === e5.type || "switchbutton" === e5.type) {
            const t5 = new Gg2(o3);
            let n4;
            return n4 = "button" === e5.type ? new br(o3) : new Cr(o3), n4.bind(...Object.keys(e5.model)).to(e5.model), n4.delegate("execute").to(t5), t5.children.add(n4), t5;
          }
          return null;
        });
      }
      const ap = (t4, e4, n3) => {
        const o3 = new Pr(t4.locale);
        return o3.set({ id: e4, ariaDescribedById: n3 }), o3.bind("isReadOnly").to(t4, "isEnabled", (t5) => !t5), o3.bind("hasError").to(t4, "errorText", (t5) => !!t5), o3.on("input", () => {
          t4.errorText = null;
        }), t4.bind("isEmpty", "isFocused", "placeholder").to(o3), o3;
      }, cp = (t4, e4 = 0, n3 = 1) => t4 > n3 ? n3 : t4 < e4 ? e4 : t4, lp = (t4, e4 = 0, n3 = Math.pow(10, e4)) => Math.round(n3 * t4) / n3, dp = (t4) => ("#" === t4[0] && (t4 = t4.substring(1)), t4.length < 6 ? { r: parseInt(t4[0] + t4[0], 16), g: parseInt(t4[1] + t4[1], 16), b: parseInt(t4[2] + t4[2], 16), a: 4 === t4.length ? lp(parseInt(t4[3] + t4[3], 16) / 255, 2) : 1 } : { r: parseInt(t4.substring(0, 2), 16), g: parseInt(t4.substring(2, 4), 16), b: parseInt(t4.substring(4, 6), 16), a: 8 === t4.length ? lp(parseInt(t4.substring(6, 8), 16) / 255, 2) : 1 }), hp = ({ h: t4, s: e4, v: n3, a: o3 }) => {
        const i3 = (200 - e4) * n3 / 100;
        return { h: lp(t4), s: lp(i3 > 0 && i3 < 200 ? e4 * n3 / 100 / (i3 <= 100 ? i3 : 200 - i3) * 100 : 0), l: lp(i3 / 2), a: lp(o3, 2) };
      }, up = (t4) => {
        const { h: e4, s: n3, l: o3 } = hp(t4);
        return `hsl(${e4}, ${n3}%, ${o3}%)`;
      }, gp = ({ h: t4, s: e4, v: n3, a: o3 }) => {
        t4 = t4 / 360 * 6, e4 /= 100, n3 /= 100;
        const i3 = Math.floor(t4), r3 = n3 * (1 - e4), s3 = n3 * (1 - (t4 - i3) * e4), a3 = n3 * (1 - (1 - t4 + i3) * e4), c3 = i3 % 6;
        return { r: lp(255 * [n3, s3, r3, r3, a3, n3][c3]), g: lp(255 * [a3, n3, n3, s3, r3, r3][c3]), b: lp(255 * [r3, r3, a3, n3, n3, s3][c3]), a: lp(o3, 2) };
      }, pp = (t4) => {
        const e4 = t4.toString(16);
        return e4.length < 2 ? "0" + e4 : e4;
      }, mp = ({ r: t4, g: e4, b: n3, a: o3 }) => {
        const i3 = o3 < 1 ? pp(lp(255 * o3)) : "";
        return "#" + pp(t4) + pp(e4) + pp(n3) + i3;
      }, fp = ({ r: t4, g: e4, b: n3, a: o3 }) => {
        const i3 = Math.max(t4, e4, n3), r3 = i3 - Math.min(t4, e4, n3), s3 = r3 ? i3 === t4 ? (e4 - n3) / r3 : i3 === e4 ? 2 + (n3 - t4) / r3 : 4 + (t4 - e4) / r3 : 0;
        return { h: lp(60 * (s3 < 0 ? s3 + 6 : s3)), s: lp(i3 ? r3 / i3 * 100 : 0), v: lp(i3 / 255 * 100), a: o3 };
      }, kp = (t4, e4) => {
        if (t4 === e4)
          return true;
        for (const n3 in t4)
          if (t4[n3] !== e4[n3])
            return false;
        return true;
      }, bp = {}, wp = (t4) => {
        let e4 = bp[t4];
        return e4 || (e4 = document.createElement("template"), e4.innerHTML = t4, bp[t4] = e4), e4;
      }, Ap = (t4, e4, n3) => {
        t4.dispatchEvent(new CustomEvent(e4, { bubbles: true, detail: n3 }));
      };
      let Cp = false;
      const _p = (t4) => "touches" in t4, vp = (t4, e4) => {
        const n3 = _p(e4) ? e4.touches[0] : e4, o3 = t4.el.getBoundingClientRect();
        Ap(t4.el, "move", t4.getMove({ x: cp((n3.pageX - (o3.left + window.pageXOffset)) / o3.width), y: cp((n3.pageY - (o3.top + window.pageYOffset)) / o3.height) }));
      };
      class yp {
        constructor(t4, e4, n3, o3) {
          const i3 = wp(`<div role="slider" tabindex="0" part="${e4}" ${n3}><div part="${e4}-pointer"></div></div>`);
          t4.appendChild(i3.content.cloneNode(true));
          const r3 = t4.querySelector(`[part=${e4}]`);
          r3.addEventListener("mousedown", this), r3.addEventListener("touchstart", this), r3.addEventListener("keydown", this), this.el = r3, this.xy = o3, this.nodes = [r3.firstChild, r3];
        }
        set dragging(t4) {
          const e4 = t4 ? document.addEventListener : document.removeEventListener;
          e4(Cp ? "touchmove" : "mousemove", this), e4(Cp ? "touchend" : "mouseup", this);
        }
        handleEvent(t4) {
          switch (t4.type) {
            case "mousedown":
            case "touchstart":
              if (t4.preventDefault(), !((t5) => !(Cp && !_p(t5) || (Cp || (Cp = _p(t5)), 0)))(t4) || !Cp && 0 != t4.button)
                return;
              this.el.focus(), vp(this, t4), this.dragging = true;
              break;
            case "mousemove":
            case "touchmove":
              t4.preventDefault(), vp(this, t4);
              break;
            case "mouseup":
            case "touchend":
              this.dragging = false;
              break;
            case "keydown":
              ((t5, e4) => {
                const n3 = e4.keyCode;
                n3 > 40 || t5.xy && n3 < 37 || n3 < 33 || (e4.preventDefault(), Ap(t5.el, "move", t5.getMove({ x: 39 === n3 ? 0.01 : 37 === n3 ? -0.01 : 34 === n3 ? 0.05 : 33 === n3 ? -0.05 : 35 === n3 ? 1 : 36 === n3 ? -1 : 0, y: 40 === n3 ? 0.01 : 38 === n3 ? -0.01 : 0 }, true)));
              })(this, t4);
          }
        }
        style(t4) {
          t4.forEach((t5, e4) => {
            for (const n3 in t5)
              this.nodes[e4].style.setProperty(n3, t5[n3]);
          });
        }
      }
      class xp extends yp {
        constructor(t4) {
          super(t4, "hue", 'aria-label="Hue" aria-valuemin="0" aria-valuemax="360"', false);
        }
        update({ h: t4 }) {
          this.h = t4, this.style([{ left: t4 / 360 * 100 + "%", color: up({ h: t4, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuenow", `${lp(t4)}`);
        }
        getMove(t4, e4) {
          return { h: e4 ? cp(this.h + 360 * t4.x, 0, 360) : 360 * t4.x };
        }
      }
      class Ep extends yp {
        constructor(t4) {
          super(t4, "saturation", 'aria-label="Color"', true);
        }
        update(t4) {
          this.hsva = t4, this.style([{ top: 100 - t4.v + "%", left: `${t4.s}%`, color: up(t4) }, { "background-color": up({ h: t4.h, s: 100, v: 100, a: 1 }) }]), this.el.setAttribute("aria-valuetext", `Saturation ${lp(t4.s)}%, Brightness ${lp(t4.v)}%`);
        }
        getMove(t4, e4) {
          return { s: e4 ? cp(this.hsva.s + 100 * t4.x, 0, 100) : 100 * t4.x, v: e4 ? cp(this.hsva.v - 100 * t4.y, 0, 100) : Math.round(100 - 100 * t4.y) };
        }
      }
      const Dp = Symbol("same"), Sp = Symbol("color"), Ip = Symbol("hsva"), Tp = Symbol("update"), Mp = Symbol("parts"), Bp = Symbol("css"), Np = Symbol("sliders");
      class Pp extends HTMLElement {
        static get observedAttributes() {
          return ["color"];
        }
        get [Bp]() {
          return [':host{display:flex;flex-direction:column;position:relative;width:200px;height:200px;user-select:none;-webkit-user-select:none;cursor:default}:host([hidden]){display:none!important}[role=slider]{position:relative;touch-action:none;user-select:none;-webkit-user-select:none;outline:0}[role=slider]:last-child{border-radius:0 0 8px 8px}[part$=pointer]{position:absolute;z-index:1;box-sizing:border-box;width:28px;height:28px;display:flex;place-content:center center;transform:translate(-50%,-50%);background-color:#fff;border:2px solid #fff;border-radius:50%;box-shadow:0 2px 4px rgba(0,0,0,.2)}[part$=pointer]::after{content:"";width:100%;height:100%;border-radius:inherit;background-color:currentColor}[role=slider]:focus [part$=pointer]{transform:translate(-50%,-50%) scale(1.1)}', "[part=hue]{flex:0 0 24px;background:linear-gradient(to right,red 0,#ff0 17%,#0f0 33%,#0ff 50%,#00f 67%,#f0f 83%,red 100%)}[part=hue-pointer]{top:50%;z-index:2}", "[part=saturation]{flex-grow:1;border-color:transparent;border-bottom:12px solid #000;border-radius:8px 8px 0 0;background-image:linear-gradient(to top,#000,transparent),linear-gradient(to right,#fff,rgba(255,255,255,0));box-shadow:inset 0 0 0 1px rgba(0,0,0,.05)}[part=saturation-pointer]{z-index:3}"];
        }
        get [Np]() {
          return [Ep, xp];
        }
        get color() {
          return this[Sp];
        }
        set color(t4) {
          if (!this[Dp](t4)) {
            const e4 = this.colorModel.toHsva(t4);
            this[Tp](e4), this[Sp] = t4;
          }
        }
        constructor() {
          super();
          const t4 = wp(`<style>${this[Bp].join("")}</style>`), e4 = this.attachShadow({ mode: "open" });
          e4.appendChild(t4.content.cloneNode(true)), e4.addEventListener("move", this), this[Mp] = this[Np].map((t5) => new t5(e4));
        }
        connectedCallback() {
          if (this.hasOwnProperty("color")) {
            const t4 = this.color;
            delete this.color, this.color = t4;
          } else
            this.color || (this.color = this.colorModel.defaultColor);
        }
        attributeChangedCallback(t4, e4, n3) {
          const o3 = this.colorModel.fromAttr(n3);
          this[Dp](o3) || (this.color = o3);
        }
        handleEvent(t4) {
          const e4 = this[Ip], n3 = { ...e4, ...t4.detail };
          let o3;
          this[Tp](n3), kp(n3, e4) || this[Dp](o3 = this.colorModel.fromHsva(n3)) || (this[Sp] = o3, Ap(this, "color-changed", { value: o3 }));
        }
        [Dp](t4) {
          return this.color && this.colorModel.equal(t4, this.color);
        }
        [Tp](t4) {
          this[Ip] = t4, this[Mp].forEach((e4) => e4.update(t4));
        }
      }
      const zp = { defaultColor: "#000", toHsva: (t4) => fp(dp(t4)), fromHsva: ({ h: t4, s: e4, v: n3 }) => mp(gp({ h: t4, s: e4, v: n3, a: 1 })), equal: (t4, e4) => t4.toLowerCase() === e4.toLowerCase() || kp(dp(t4), dp(e4)), fromAttr: (t4) => t4 };
      class Op extends Pp {
        get colorModel() {
          return zp;
        }
      }
      customElements.define("hex-color-picker", class extends Op {
      });
      var Lp = n2(3398), jp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Lp.Z, jp);
      Lp.Z.locals;
      var Rp = n2(4157), Fp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Rp.Z, Fp);
      Rp.Z.locals;
      class Vp {
        constructor(t4) {
          this._components = /* @__PURE__ */ new Map(), this.editor = t4;
        }
        *names() {
          for (const t4 of this._components.values())
            yield t4.originalName;
        }
        add(t4, e4) {
          this._components.set(Hp(t4), { callback: e4, originalName: t4 });
        }
        create(t4) {
          if (!this.has(t4))
            throw new A2("componentfactory-item-missing", this, { name: t4 });
          return this._components.get(Hp(t4)).callback(this.editor.locale);
        }
        has(t4) {
          return this._components.has(Hp(t4));
        }
      }
      function Hp(t4) {
        return String(t4).toLowerCase();
      }
      var Up = n2(8793), qp = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Up.Z, qp);
      Up.Z.locals;
      var Gp = Object.defineProperty, Wp = Object.getOwnPropertySymbols, Kp = Object.prototype.hasOwnProperty, Yp = Object.prototype.propertyIsEnumerable, $p = (t4, e4, n3) => e4 in t4 ? Gp(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, Zp = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          Kp.call(e4, n3) && $p(t4, n3, e4[n3]);
        if (Wp)
          for (var n3 of Wp(e4))
            Yp.call(e4, n3) && $p(t4, n3, e4[n3]);
        return t4;
      };
      const Qp = $o2("px"), Jp = zo2.document.body, Xp = { top: -99999, left: -99999, name: "arrowless", config: { withArrow: false } }, tm = class extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("position", "arrow_nw"), this.set("isVisible", false), this.set("withArrow", true), this.set("class", void 0), this._pinWhenIsVisibleCallback = null, this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-panel", e4.to("position", (t5) => `ck-balloon-panel_${t5}`), e4.if("isVisible", "ck-balloon-panel_visible"), e4.if("withArrow", "ck-balloon-panel_with-arrow"), e4.to("class")], style: { top: e4.to("top", Qp), left: e4.to("left", Qp) } }, children: this.content });
        }
        show() {
          this.isVisible = true;
        }
        hide() {
          this.isVisible = false;
        }
        attachTo(t4) {
          this.show();
          const e4 = tm.defaultPositions, n3 = Object.assign({}, { element: this.element, positions: [e4.southArrowNorth, e4.southArrowNorthMiddleWest, e4.southArrowNorthMiddleEast, e4.southArrowNorthWest, e4.southArrowNorthEast, e4.northArrowSouth, e4.northArrowSouthMiddleWest, e4.northArrowSouthMiddleEast, e4.northArrowSouthWest, e4.northArrowSouthEast, e4.viewportStickyNorth], limiter: Jp, fitInViewport: true }, t4), o3 = tm._getOptimalPosition(n3) || Xp, i3 = parseInt(o3.left), r3 = parseInt(o3.top), s3 = o3.name, a3 = o3.config || {}, { withArrow: c3 = true } = a3;
          this.top = r3, this.left = i3, this.position = s3, this.withArrow = c3;
        }
        pin(t4) {
          this.unpin(), this._pinWhenIsVisibleCallback = () => {
            this.isVisible ? this._startPinning(t4) : this._stopPinning();
          }, this._startPinning(t4), this.listenTo(this, "change:isVisible", this._pinWhenIsVisibleCallback);
        }
        unpin() {
          this._pinWhenIsVisibleCallback && (this._stopPinning(), this.stopListening(this, "change:isVisible", this._pinWhenIsVisibleCallback), this._pinWhenIsVisibleCallback = null, this.hide());
        }
        _startPinning(t4) {
          this.attachTo(t4);
          const e4 = nm(t4.target), n3 = t4.limiter ? nm(t4.limiter) : Jp;
          this.listenTo(zo2.document, "scroll", (o3, i3) => {
            const r3 = i3.target, s3 = e4 && r3.contains(e4), a3 = n3 && r3.contains(n3);
            !s3 && !a3 && e4 && n3 || this.attachTo(t4);
          }, { useCapture: true }), this.listenTo(zo2.window, "resize", () => {
            this.attachTo(t4);
          });
        }
        _stopPinning() {
          this.stopListening(zo2.document, "scroll"), this.stopListening(zo2.window, "resize");
        }
      };
      let em = tm;
      function nm(t4) {
        return yo2(t4) ? t4 : Lo2(t4) ? t4.commonAncestorContainer : "function" == typeof t4 ? nm(t4()) : null;
      }
      function om(t4 = {}) {
        const { sideOffset: e4 = em.arrowSideOffset, heightOffset: n3 = em.arrowHeightOffset, stickyVerticalOffset: o3 = em.stickyVerticalOffset, config: i3 } = t4;
        return { northWestArrowSouthWest: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.left - e4, name: "arrow_sw" }, i3 && { config: i3 }), northWestArrowSouthMiddleWest: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.left - 0.25 * n4.width - e4, name: "arrow_smw" }, i3 && { config: i3 }), northWestArrowSouth: (t5, e5) => Zp({ top: r3(t5, e5), left: t5.left - e5.width / 2, name: "arrow_s" }, i3 && { config: i3 }), northWestArrowSouthMiddleEast: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.left - 0.75 * n4.width + e4, name: "arrow_sme" }, i3 && { config: i3 }), northWestArrowSouthEast: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.left - n4.width + e4, name: "arrow_se" }, i3 && { config: i3 }), northArrowSouthWest: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.left + t5.width / 2 - e4, name: "arrow_sw" }, i3 && { config: i3 }), northArrowSouthMiddleWest: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.left + t5.width / 2 - 0.25 * n4.width - e4, name: "arrow_smw" }, i3 && { config: i3 }), northArrowSouth: (t5, e5) => Zp({ top: r3(t5, e5), left: t5.left + t5.width / 2 - e5.width / 2, name: "arrow_s" }, i3 && { config: i3 }), northArrowSouthMiddleEast: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.left + t5.width / 2 - 0.75 * n4.width + e4, name: "arrow_sme" }, i3 && { config: i3 }), northArrowSouthEast: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.left + t5.width / 2 - n4.width + e4, name: "arrow_se" }, i3 && { config: i3 }), northEastArrowSouthWest: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.right - e4, name: "arrow_sw" }, i3 && { config: i3 }), northEastArrowSouthMiddleWest: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.right - 0.25 * n4.width - e4, name: "arrow_smw" }, i3 && { config: i3 }), northEastArrowSouth: (t5, e5) => Zp({ top: r3(t5, e5), left: t5.right - e5.width / 2, name: "arrow_s" }, i3 && { config: i3 }), northEastArrowSouthMiddleEast: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.right - 0.75 * n4.width + e4, name: "arrow_sme" }, i3 && { config: i3 }), northEastArrowSouthEast: (t5, n4) => Zp({ top: r3(t5, n4), left: t5.right - n4.width + e4, name: "arrow_se" }, i3 && { config: i3 }), southWestArrowNorthWest: (t5) => Zp({ top: s3(t5), left: t5.left - e4, name: "arrow_nw" }, i3 && { config: i3 }), southWestArrowNorthMiddleWest: (t5, n4) => Zp({ top: s3(t5), left: t5.left - 0.25 * n4.width - e4, name: "arrow_nmw" }, i3 && { config: i3 }), southWestArrowNorth: (t5, e5) => Zp({ top: s3(t5), left: t5.left - e5.width / 2, name: "arrow_n" }, i3 && { config: i3 }), southWestArrowNorthMiddleEast: (t5, n4) => Zp({ top: s3(t5), left: t5.left - 0.75 * n4.width + e4, name: "arrow_nme" }, i3 && { config: i3 }), southWestArrowNorthEast: (t5, n4) => Zp({ top: s3(t5), left: t5.left - n4.width + e4, name: "arrow_ne" }, i3 && { config: i3 }), southArrowNorthWest: (t5) => Zp({ top: s3(t5), left: t5.left + t5.width / 2 - e4, name: "arrow_nw" }, i3 && { config: i3 }), southArrowNorthMiddleWest: (t5, n4) => Zp({ top: s3(t5), left: t5.left + t5.width / 2 - 0.25 * n4.width - e4, name: "arrow_nmw" }, i3 && { config: i3 }), southArrowNorth: (t5, e5) => Zp({ top: s3(t5), left: t5.left + t5.width / 2 - e5.width / 2, name: "arrow_n" }, i3 && { config: i3 }), southArrowNorthMiddleEast: (t5, n4) => Zp({ top: s3(t5), left: t5.left + t5.width / 2 - 0.75 * n4.width + e4, name: "arrow_nme" }, i3 && { config: i3 }), southArrowNorthEast: (t5, n4) => Zp({ top: s3(t5), left: t5.left + t5.width / 2 - n4.width + e4, name: "arrow_ne" }, i3 && { config: i3 }), southEastArrowNorthWest: (t5) => Zp({ top: s3(t5), left: t5.right - e4, name: "arrow_nw" }, i3 && { config: i3 }), southEastArrowNorthMiddleWest: (t5, n4) => Zp({ top: s3(t5), left: t5.right - 0.25 * n4.width - e4, name: "arrow_nmw" }, i3 && { config: i3 }), southEastArrowNorth: (t5, e5) => Zp({ top: s3(t5), left: t5.right - e5.width / 2, name: "arrow_n" }, i3 && { config: i3 }), southEastArrowNorthMiddleEast: (t5, n4) => Zp({ top: s3(t5), left: t5.right - 0.75 * n4.width + e4, name: "arrow_nme" }, i3 && { config: i3 }), southEastArrowNorthEast: (t5, n4) => Zp({ top: s3(t5), left: t5.right - n4.width + e4, name: "arrow_ne" }, i3 && { config: i3 }), westArrowEast: (t5, e5) => Zp({ top: t5.top + t5.height / 2 - e5.height / 2, left: t5.left - e5.width - n3, name: "arrow_e" }, i3 && { config: i3 }), eastArrowWest: (t5, e5) => Zp({ top: t5.top + t5.height / 2 - e5.height / 2, left: t5.right + n3, name: "arrow_w" }, i3 && { config: i3 }), viewportStickyNorth: (t5, e5, n4, r4) => {
          const s4 = r4 || n4;
          return t5.getIntersection(s4) ? s4.height - t5.height > o3 ? null : { top: s4.top + o3, left: t5.left + t5.width / 2 - e5.width / 2, name: "arrowless", config: Zp({ withArrow: false }, i3) } : null;
        } };
        function r3(t5, e5) {
          return t5.top - e5.height - n3;
        }
        function s3(t5) {
          return t5.bottom + n3;
        }
      }
      em.arrowSideOffset = 25, em.arrowHeightOffset = 10, em.stickyVerticalOffset = 20, em._getOptimalPosition = ei2, em.defaultPositions = om();
      var im = n2(3332), rm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(im.Z, rm);
      im.Z.locals;
      const sm = "ck-tooltip", am = class extends Mo2() {
        constructor(t4) {
          if (super(), this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver = null, am._editors.add(t4), am._instance)
            return am._instance;
          am._instance = this, this.tooltipTextView = new Hi2(t4.locale), this.tooltipTextView.set("text", ""), this.tooltipTextView.setTemplate({ tag: "span", attributes: { class: ["ck", "ck-tooltip__text"] }, children: [{ text: this.tooltipTextView.bindTemplate.to("text") }] }), this.balloonPanelView = new em(t4.locale), this.balloonPanelView.class = sm, this.balloonPanelView.content.add(this.tooltipTextView), this._pinTooltipDebounced = Qc2(this._pinTooltip, 600), this.listenTo(zo2.document, "mouseenter", this._onEnterOrFocus.bind(this), { useCapture: true }), this.listenTo(zo2.document, "mouseleave", this._onLeaveOrBlur.bind(this), { useCapture: true }), this.listenTo(zo2.document, "focus", this._onEnterOrFocus.bind(this), { useCapture: true }), this.listenTo(zo2.document, "blur", this._onLeaveOrBlur.bind(this), { useCapture: true }), this.listenTo(zo2.document, "scroll", this._onScroll.bind(this), { useCapture: true }), this._watchdogExcluded = true;
        }
        destroy(t4) {
          const e4 = t4.ui.view && t4.ui.view.body;
          am._editors.delete(t4), this.stopListening(t4.ui), e4 && e4.has(this.balloonPanelView) && e4.remove(this.balloonPanelView), am._editors.size || (this._unpinTooltip(), this.balloonPanelView.destroy(), this.stopListening(), am._instance = null);
        }
        static getPositioningFunctions(t4) {
          const e4 = am.defaultBalloonPositions;
          return { s: [e4.southArrowNorth, e4.southArrowNorthEast, e4.southArrowNorthWest], n: [e4.northArrowSouth], e: [e4.eastArrowWest], w: [e4.westArrowEast], sw: [e4.southArrowNorthEast], se: [e4.southArrowNorthWest] }[t4];
        }
        _onEnterOrFocus(t4, { target: e4 }) {
          const n3 = lm(e4);
          var o3;
          n3 && (n3 !== this._currentElementWithTooltip && (this._unpinTooltip(), this._pinTooltipDebounced(n3, { text: (o3 = n3).dataset.ckeTooltipText, position: o3.dataset.ckeTooltipPosition || "s", cssClass: o3.dataset.ckeTooltipClass || "" })));
        }
        _onLeaveOrBlur(t4, { target: e4, relatedTarget: n3 }) {
          if ("mouseleave" === t4.name) {
            if (!yo2(e4))
              return;
            if (this._currentElementWithTooltip && e4 !== this._currentElementWithTooltip)
              return;
            const t5 = lm(e4), o3 = lm(n3);
            t5 && t5 !== o3 && this._unpinTooltip();
          } else {
            if (this._currentElementWithTooltip && e4 !== this._currentElementWithTooltip)
              return;
            this._unpinTooltip();
          }
        }
        _onScroll(t4, { target: e4 }) {
          this._currentElementWithTooltip && (e4.contains(this.balloonPanelView.element) && e4.contains(this._currentElementWithTooltip) || this._unpinTooltip());
        }
        _pinTooltip(t4, { text: e4, position: n3, cssClass: o3 }) {
          const i3 = Si2(am._editors.values()).ui.view.body;
          i3.has(this.balloonPanelView) || i3.add(this.balloonPanelView), this.tooltipTextView.text = e4, this.balloonPanelView.pin({ target: t4, positions: am.getPositioningFunctions(n3) }), this._resizeObserver = new Ko2(t4, () => {
            Xo2(t4) || this._unpinTooltip();
          }), this.balloonPanelView.class = [sm, o3].filter((t5) => t5).join(" ");
          for (const t5 of am._editors)
            this.listenTo(t5.ui, "update", this._updateTooltipPosition.bind(this), { priority: "low" });
          this._currentElementWithTooltip = t4, this._currentTooltipPosition = n3;
        }
        _unpinTooltip() {
          this._pinTooltipDebounced.cancel(), this.balloonPanelView.unpin();
          for (const t4 of am._editors)
            this.stopListening(t4.ui, "update");
          this._currentElementWithTooltip = null, this._currentTooltipPosition = null, this._resizeObserver && this._resizeObserver.destroy();
        }
        _updateTooltipPosition() {
          Xo2(this._currentElementWithTooltip) ? this.balloonPanelView.pin({ target: this._currentElementWithTooltip, positions: am.getPositioningFunctions(this._currentTooltipPosition) }) : this._unpinTooltip();
        }
      };
      let cm = am;
      function lm(t4) {
        return yo2(t4) ? t4.closest("[data-cke-tooltip-text]:not([data-cke-tooltip-disabled])") : null;
      }
      cm.defaultBalloonPositions = om({ heightOffset: 5, sideOffset: 13 }), cm._editors = /* @__PURE__ */ new Set(), cm._instance = null;
      const dm = function(t4, e4, n3) {
        var o3 = true, i3 = true;
        if ("function" != typeof t4)
          throw new TypeError("Expected a function");
        return R2(n3) && (o3 = "leading" in n3 ? !!n3.leading : o3, i3 = "trailing" in n3 ? !!n3.trailing : i3), Qc2(t4, e4, { leading: o3, maxWait: e4, trailing: i3 });
      };
      var hm = Object.defineProperty, um = Object.getOwnPropertySymbols, gm = Object.prototype.hasOwnProperty, pm = Object.prototype.propertyIsEnumerable, mm = (t4, e4, n3) => e4 in t4 ? hm(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, fm = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          gm.call(e4, n3) && mm(t4, n3, e4[n3]);
        if (um)
          for (var n3 of um(e4))
            pm.call(e4, n3) && mm(t4, n3, e4[n3]);
        return t4;
      };
      const km = 50, bm = 350, wm = "Powered by";
      class Am extends Mo2() {
        constructor(t4) {
          super(), this.editor = t4, this._balloonView = null, this._lastFocusedEditableElement = null, this._showBalloonThrottled = dm(this._showBalloon.bind(this), 50, { leading: true }), t4.on("ready", this._handleEditorReady.bind(this));
        }
        destroy() {
          const t4 = this._balloonView;
          t4 && (t4.unpin(), this._balloonView = null), this._showBalloonThrottled.cancel(), this.stopListening();
        }
        _handleEditorReady() {
          const t4 = this.editor;
          (!!t4.config.get("ui.poweredBy.forceVisible") || "VALID" !== function(t5) {
            function e4(t6) {
              return t6.length >= 40 && t6.length <= 255 ? "VALID" : "INVALID";
            }
            if (!t5)
              return "INVALID";
            let n3 = "";
            try {
              n3 = atob(t5);
            } catch (t6) {
              return "INVALID";
            }
            const o3 = n3.split("-"), i3 = o3[0], r3 = o3[1];
            if (!r3)
              return e4(t5);
            try {
              atob(r3);
            } catch (n4) {
              try {
                if (atob(i3), !atob(i3).length)
                  return e4(t5);
              } catch (n5) {
                return e4(t5);
              }
            }
            if (i3.length < 40 || i3.length > 255)
              return "INVALID";
            let s3 = "";
            try {
              atob(i3), s3 = atob(r3);
            } catch (t6) {
              return "INVALID";
            }
            if (8 !== s3.length)
              return "INVALID";
            const a3 = Number(s3.substring(0, 4)), c3 = Number(s3.substring(4, 6)) - 1, l3 = Number(s3.substring(6, 8)), d3 = new Date(a3, c3, l3);
            return d3 < E2 || isNaN(Number(d3)) ? "INVALID" : "VALID";
          }(t4.config.get("licenseKey"))) && t4.ui.view && (t4.ui.focusTracker.on("change:isFocused", (t5, e4, n3) => {
            this._updateLastFocusedEditableElement(), n3 ? this._showBalloon() : this._hideBalloon();
          }), t4.ui.focusTracker.on("change:focusedElement", (t5, e4, n3) => {
            this._updateLastFocusedEditableElement(), n3 && this._showBalloon();
          }), t4.ui.on("update", () => {
            this._showBalloonThrottled();
          }));
        }
        _createBalloonView() {
          const t4 = this.editor, e4 = this._balloonView = new em(), n3 = vm(t4), o3 = new Cm(t4.locale, n3.label);
          e4.content.add(o3), e4.set({ class: "ck-powered-by-balloon" }), t4.ui.view.body.add(e4), t4.ui.focusTracker.add(e4.element), this._balloonView = e4;
        }
        _showBalloon() {
          if (!this._lastFocusedEditableElement)
            return;
          const t4 = function(t5, e4) {
            const n3 = vm(t5), o3 = "right" === n3.side ? function(t6, e5) {
              return _m(t6, e5, (t7, n4) => t7.left + t7.width - n4.width - e5.horizontalOffset);
            }(e4, n3) : function(t6, e5) {
              return _m(t6, e5, (t7) => t7.left + e5.horizontalOffset);
            }(e4, n3);
            return { target: e4, positions: [o3] };
          }(this.editor, this._lastFocusedEditableElement);
          t4 && (this._balloonView || this._createBalloonView(), this._balloonView.pin(t4));
        }
        _hideBalloon() {
          this._balloonView && this._balloonView.unpin();
        }
        _updateLastFocusedEditableElement() {
          const t4 = this.editor, e4 = t4.ui.focusTracker.isFocused, n3 = t4.ui.focusTracker.focusedElement;
          if (!e4 || !n3)
            return void (this._lastFocusedEditableElement = null);
          const o3 = Array.from(t4.ui.getEditableElementsNames()).map((e5) => t4.ui.getEditableElement(e5));
          o3.includes(n3) ? this._lastFocusedEditableElement = n3 : this._lastFocusedEditableElement = o3[0];
        }
      }
      class Cm extends Hi2 {
        constructor(t4, e4) {
          super(t4);
          const n3 = new pr(), o3 = this.bindTemplate;
          n3.set({ content: '<svg xmlns="http://www.w3.org/2000/svg" width="53" height="10" viewBox="0 0 53 10"><path fill="#1C2331" d="M31.724 1.492a15.139 15.139 0 0 0 .045 1.16 2.434 2.434 0 0 0-.687-.34 3.68 3.68 0 0 0-1.103-.166 2.332 2.332 0 0 0-1.14.255 1.549 1.549 0 0 0-.686.87c-.15.41-.225.98-.225 1.712 0 .939.148 1.659.444 2.161.297.503.792.754 1.487.754.452.015.9-.094 1.294-.316.296-.174.557-.4.771-.669l.14.852h1.282V.007h-1.623v1.485ZM31 6.496a1.77 1.77 0 0 1-.494.061.964.964 0 0 1-.521-.127.758.758 0 0 1-.296-.466 3.984 3.984 0 0 1-.093-.992 4.208 4.208 0 0 1 .098-1.052.753.753 0 0 1 .307-.477 1.08 1.08 0 0 1 .55-.122c.233-.004.466.026.69.089l.483.144v2.553c-.11.076-.213.143-.307.2a1.73 1.73 0 0 1-.417.189ZM35.68 0l-.702.004c-.322.002-.482.168-.48.497l.004.581c.002.33.164.493.486.49l.702-.004c.322-.002.481-.167.48-.496L36.165.49c-.002-.33-.164-.493-.486-.491ZM36.145 2.313l-1.612.01.034 5.482 1.613-.01-.035-5.482ZM39.623.79 37.989.8 38 2.306l-.946.056.006 1.009.949-.006.024 2.983c.003.476.143.844.419 1.106.275.26.658.39 1.148.387.132 0 .293-.01.483-.03.19-.02.38-.046.57-.08.163-.028.324-.068.482-.119l-.183-1.095-.702.004a.664.664 0 0 1-.456-.123.553.553 0 0 1-.14-.422l-.016-2.621 1.513-.01-.006-1.064-1.514.01-.01-1.503ZM46.226 2.388c-.41-.184-.956-.274-1.636-.27-.673.004-1.215.101-1.627.29-.402.179-.72.505-.888.91-.18.419-.268.979-.264 1.68.004.688.1 1.24.285 1.655.172.404.495.724.9.894.414.18.957.268 1.63.264.68-.004 1.224-.099 1.632-.284.4-.176.714-.501.878-.905.176-.418.263-.971.258-1.658-.004-.702-.097-1.261-.28-1.677a1.696 1.696 0 0 0-.888-.9Zm-.613 3.607a.77.77 0 0 1-.337.501 1.649 1.649 0 0 1-1.317.009.776.776 0 0 1-.343-.497 4.066 4.066 0 0 1-.105-1.02 4.136 4.136 0 0 1 .092-1.03.786.786 0 0 1 .337-.507 1.59 1.59 0 0 1 1.316-.008.79.79 0 0 1 .344.502c.078.337.113.683.105 1.03.012.343-.019.685-.092 1.02ZM52.114 2.07a2.67 2.67 0 0 0-1.128.278c-.39.191-.752.437-1.072.73l-.157-.846-1.273.008.036 5.572 1.623-.01-.024-3.78c.35-.124.646-.22.887-.286.26-.075.53-.114.8-.118l.45-.003.144-1.546-.286.001ZM22.083 7.426l-1.576-2.532a2.137 2.137 0 0 0-.172-.253 1.95 1.95 0 0 0-.304-.29.138.138 0 0 1 .042-.04 1.7 1.7 0 0 0 .328-.374l1.75-2.71c.01-.015.025-.028.024-.048-.01-.01-.021-.007-.031-.007L20.49 1.17a.078.078 0 0 0-.075.045l-.868 1.384c-.23.366-.46.732-.688 1.099a.108.108 0 0 1-.112.06c-.098-.005-.196-.001-.294-.002-.018 0-.038.006-.055-.007.002-.02.002-.039.005-.058a4.6 4.6 0 0 0 .046-.701V1.203c0-.02-.009-.032-.03-.03h-.033L16.93 1.17c-.084 0-.073-.01-.073.076v6.491c-.001.018.006.028.025.027h1.494c.083 0 .072.007.072-.071v-2.19c0-.055-.003-.11-.004-.166a3.366 3.366 0 0 0-.05-.417h.06c.104 0 .209.002.313-.002a.082.082 0 0 1 .084.05c.535.913 1.07 1.824 1.607 2.736a.104.104 0 0 0 .103.062c.554-.003 1.107-.002 1.66-.002l.069-.003-.019-.032-.188-.304ZM27.112 6.555c-.005-.08-.004-.08-.082-.08h-2.414c-.053 0-.106-.003-.159-.011a.279.279 0 0 1-.246-.209.558.558 0 0 1-.022-.15c0-.382 0-.762-.002-1.143 0-.032.007-.049.042-.044h2.504c.029.003.037-.012.034-.038V3.814c0-.089.013-.078-.076-.078h-2.44c-.07 0-.062.003-.062-.06v-.837c0-.047.004-.093.013-.14a.283.283 0 0 1 .241-.246.717.717 0 0 1 .146-.011h2.484c.024.002.035-.009.036-.033l.003-.038.03-.496c.01-.183.024-.365.034-.548.005-.085.003-.087-.082-.094-.218-.018-.437-.038-.655-.05a17.845 17.845 0 0 0-.657-.026 72.994 72.994 0 0 0-1.756-.016 1.7 1.7 0 0 0-.471.064 1.286 1.286 0 0 0-.817.655c-.099.196-.149.413-.145.633v3.875c0 .072.003.144.011.216a1.27 1.27 0 0 0 .711 1.029c.228.113.48.167.734.158.757-.005 1.515.002 2.272-.042.274-.016.548-.034.82-.053.03-.002.043-.008.04-.041-.008-.104-.012-.208-.019-.312a69.964 69.964 0 0 1-.05-.768ZM16.14 7.415l-.127-1.075c-.004-.03-.014-.04-.044-.037a13.125 13.125 0 0 1-.998.073c-.336.01-.672.02-1.008.016-.116-.001-.233-.014-.347-.039a.746.746 0 0 1-.45-.262c-.075-.1-.132-.211-.167-.33a3.324 3.324 0 0 1-.126-.773 9.113 9.113 0 0 1-.015-.749c0-.285.022-.57.065-.852.023-.158.066-.312.127-.46a.728.728 0 0 1 .518-.443 1.64 1.64 0 0 1 .397-.048c.628-.001 1.255.003 1.882.05.022.001.033-.006.036-.026l.003-.031.06-.55c.019-.177.036-.355.057-.532.004-.034-.005-.046-.04-.056a5.595 5.595 0 0 0-1.213-.21 10.783 10.783 0 0 0-.708-.02c-.24-.003-.48.01-.719.041a3.477 3.477 0 0 0-.625.14 1.912 1.912 0 0 0-.807.497c-.185.2-.33.433-.424.688a4.311 4.311 0 0 0-.24 1.096c-.031.286-.045.572-.042.86-.006.43.024.86.091 1.286.04.25.104.497.193.734.098.279.26.53.473.734.214.205.473.358.756.446.344.11.702.17 1.063.177a8.505 8.505 0 0 0 1.578-.083 6.11 6.11 0 0 0 .766-.18c.03-.008.047-.023.037-.057a.157.157 0 0 1-.003-.025Z"/><path fill="#AFE229" d="M6.016 6.69a1.592 1.592 0 0 0-.614.21c-.23.132-.422.32-.56.546-.044.072-.287.539-.287.539l-.836 1.528.009.006c.038.025.08.046.123.063.127.046.26.07.395.073.505.023 1.011-.007 1.517-.003.29.009.58.002.869-.022a.886.886 0 0 0 .395-.116.962.962 0 0 0 .312-.286c.056-.083.114-.163.164-.249.24-.408.48-.816.718-1.226.075-.128.148-.257.222-.386l.112-.192a1.07 1.07 0 0 0 .153-.518l-1.304.023s-1.258-.005-1.388.01Z"/><path fill="#771BFF" d="m2.848 9.044.76-1.39.184-.352c-.124-.067-.245-.14-.367-.21-.346-.204-.706-.384-1.045-.6a.984.984 0 0 1-.244-.207c-.108-.134-.136-.294-.144-.46-.021-.409-.002-.818-.009-1.227-.003-.195 0-.39.003-.585.004-.322.153-.553.427-.713l.833-.488c.22-.13.44-.257.662-.385.05-.029.105-.052.158-.077.272-.128.519-.047.76.085l.044.028c.123.06.242.125.358.196.318.178.635.357.952.537.095.056.187.117.275.184.194.144.254.35.266.578.016.284.007.569.006.853-.001.28.004.558 0 .838.592-.003 1.259 0 1.259 0l.723-.013c-.003-.292-.007-.584-.007-.876 0-.524.015-1.048-.016-1.571-.024-.42-.135-.8-.492-1.067a5.02 5.02 0 0 0-.506-.339A400.52 400.52 0 0 0 5.94.787C5.722.664 5.513.524 5.282.423 5.255.406 5.228.388 5.2.373 4.758.126 4.305-.026 3.807.21c-.097.046-.197.087-.29.14A699.896 699.896 0 0 0 .783 1.948c-.501.294-.773.717-.778 1.31-.004.36-.009.718-.001 1.077.016.754-.017 1.508.024 2.261.016.304.07.6.269.848.127.15.279.28.448.382.622.4 1.283.734 1.92 1.11l.183.109Z"/></svg>\n', isColorInherited: false }), n3.extendTemplate({ attributes: { style: { width: "53px", height: "10px" } } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-powered-by"], "aria-hidden": true }, children: [{ tag: "a", attributes: { href: "https://ckeditor.com/?utm_source=ckeditor&utm_medium=referral&utm_campaign=701Dn000000hVgmIAE_powered_by_ckeditor_logo", target: "_blank", tabindex: "-1" }, children: [...e4 ? [{ tag: "span", attributes: { class: ["ck", "ck-powered-by__label"] }, children: [e4] }] : [], n3], on: { dragstart: o3.to((t5) => t5.preventDefault()) } }] });
        }
      }
      function _m(t4, e4, n3) {
        return (o3, i3) => {
          const r3 = new Vo2(t4);
          if (r3.width < bm || r3.height < km)
            return null;
          let s3;
          s3 = "inside" === e4.position ? r3.bottom - i3.height : r3.bottom - i3.height / 2, s3 -= e4.verticalOffset;
          const a3 = n3(r3, i3), c3 = o3.clone().moveTo(a3, s3).getIntersection(i3.clone().moveTo(a3, s3)).getVisible();
          return !c3 || c3.getArea() < i3.getArea() ? null : { top: s3, left: a3, name: `position_${e4.position}-side_${e4.side}`, config: { withArrow: false } };
        };
      }
      function vm(t4) {
        const e4 = t4.config.get("ui.poweredBy"), n3 = e4 && e4.position || "border";
        return fm({ position: n3, label: wm, verticalOffset: "inside" === n3 ? 5 : 0, horizontalOffset: 5, side: "ltr" === t4.locale.contentLanguageDirection ? "right" : "left" }, e4);
      }
      var ym = Object.defineProperty, xm = Object.getOwnPropertySymbols, Em = Object.prototype.hasOwnProperty, Dm = Object.prototype.propertyIsEnumerable, Sm = (t4, e4, n3) => e4 in t4 ? ym(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3;
      class Im extends W2() {
        constructor(t4) {
          super(), this.isReady = false, this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
          const e4 = t4.editing.view;
          this.editor = t4, this.componentFactory = new Vp(t4), this.focusTracker = new Ii2(), this.tooltipManager = new cm(t4), this.poweredBy = new Am(t4), this.set("viewportOffset", this._readViewportOffsetFromConfig()), this.once("ready", () => {
            this.isReady = true;
          }), this.listenTo(e4.document, "layoutChanged", this.update.bind(this)), this.listenTo(e4, "scrollToTheSelection", this._handleScrollToTheSelection.bind(this)), this._initFocusTracking();
        }
        get element() {
          return null;
        }
        update() {
          this.fire("update");
        }
        destroy() {
          this.stopListening(), this.focusTracker.destroy(), this.tooltipManager.destroy(this.editor), this.poweredBy.destroy();
          for (const t4 of this._editableElementsMap.values())
            t4.ckeditorInstance = null, this.editor.keystrokes.stopListening(t4);
          this._editableElementsMap = /* @__PURE__ */ new Map(), this._focusableToolbarDefinitions = [];
        }
        setEditableElement(t4, e4) {
          this._editableElementsMap.set(t4, e4), e4.ckeditorInstance || (e4.ckeditorInstance = this.editor), this.focusTracker.add(e4);
          const n3 = () => {
            this.editor.editing.view.getDomRoot(t4) || this.editor.keystrokes.listenTo(e4);
          };
          this.isReady ? n3() : this.once("ready", n3);
        }
        removeEditableElement(t4) {
          const e4 = this._editableElementsMap.get(t4);
          e4 && (this._editableElementsMap.delete(t4), this.editor.keystrokes.stopListening(e4), this.focusTracker.remove(e4), e4.ckeditorInstance = null);
        }
        getEditableElement(t4 = "main") {
          return this._editableElementsMap.get(t4);
        }
        getEditableElementsNames() {
          return this._editableElementsMap.keys();
        }
        addToolbar(t4, e4 = {}) {
          t4.isRendered ? (this.focusTracker.add(t4.element), this.editor.keystrokes.listenTo(t4.element)) : t4.once("render", () => {
            this.focusTracker.add(t4.element), this.editor.keystrokes.listenTo(t4.element);
          }), this._focusableToolbarDefinitions.push({ toolbarView: t4, options: e4 });
        }
        get _editableElements() {
          return console.warn("editor-ui-deprecated-editable-elements: The EditorUI#_editableElements property has been deprecated and will be removed in the near future.", { editorUI: this }), this._editableElementsMap;
        }
        _readViewportOffsetFromConfig() {
          const t4 = this.editor, e4 = t4.config.get("ui.viewportOffset");
          if (e4)
            return e4;
          const n3 = t4.config.get("toolbar.viewportTopOffset");
          return n3 ? (console.warn("editor-ui-deprecated-viewport-offset-config: The `toolbar.vieportTopOffset` configuration option is deprecated. It will be removed from future CKEditor versions. Use `ui.viewportOffset.top` instead."), { top: n3 }) : { top: 0 };
        }
        _initFocusTracking() {
          const t4 = this.editor, e4 = t4.editing.view;
          let n3, o3;
          t4.keystrokes.set("Alt+F10", (t5, i3) => {
            const r3 = this.focusTracker.focusedElement;
            Array.from(this._editableElementsMap.values()).includes(r3) && !Array.from(e4.domRoots.values()).includes(r3) && (n3 = r3);
            const s3 = this._getCurrentFocusedToolbarDefinition();
            s3 && o3 || (o3 = this._getFocusableCandidateToolbarDefinitions());
            for (let t6 = 0; t6 < o3.length; t6++) {
              const t7 = o3.shift();
              if (o3.push(t7), t7 !== s3 && this._focusFocusableCandidateToolbar(t7)) {
                s3 && s3.options.afterBlur && s3.options.afterBlur();
                break;
              }
            }
            i3();
          }), t4.keystrokes.set("Esc", (e5, o4) => {
            const i3 = this._getCurrentFocusedToolbarDefinition();
            i3 && (n3 ? (n3.focus(), n3 = null) : t4.editing.view.focus(), i3.options.afterBlur && i3.options.afterBlur(), o4());
          });
        }
        _getFocusableCandidateToolbarDefinitions() {
          const t4 = [];
          for (const e4 of this._focusableToolbarDefinitions) {
            const { toolbarView: n3, options: o3 } = e4;
            (Xo2(n3.element) || o3.beforeFocus) && t4.push(e4);
          }
          return t4.sort((t5, e4) => Tm(t5) - Tm(e4)), t4;
        }
        _getCurrentFocusedToolbarDefinition() {
          for (const t4 of this._focusableToolbarDefinitions)
            if (t4.toolbarView.element && t4.toolbarView.element.contains(this.focusTracker.focusedElement))
              return t4;
          return null;
        }
        _focusFocusableCandidateToolbar(t4) {
          const { toolbarView: e4, options: { beforeFocus: n3 } } = t4;
          return n3 && n3(), !!Xo2(e4.element) && (e4.focus(), true);
        }
        _handleScrollToTheSelection(t4, e4) {
          const n3 = ((t5, e5) => {
            for (var n4 in e5 || (e5 = {}))
              Em.call(e5, n4) && Sm(t5, n4, e5[n4]);
            if (xm)
              for (var n4 of xm(e5))
                Dm.call(e5, n4) && Sm(t5, n4, e5[n4]);
            return t5;
          })({ top: 0, bottom: 0, left: 0, right: 0 }, this.viewportOffset);
          e4.viewportOffset.top += n3.top, e4.viewportOffset.bottom += n3.bottom, e4.viewportOffset.left += n3.left, e4.viewportOffset.right += n3.right;
        }
      }
      function Tm(t4) {
        const { toolbarView: e4, options: n3 } = t4;
        let o3 = 10;
        return Xo2(e4.element) && o3--, n3.isContextual && o3--, o3;
      }
      var Mm = n2(9688), Bm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Mm.Z, Bm);
      Mm.Z.locals;
      class Nm extends Hi2 {
        constructor(t4) {
          super(t4), this.body = new dr(t4);
        }
        render() {
          super.render(), this.body.attachToDom();
        }
        destroy() {
          return this.body.detachFromDom(), super.destroy();
        }
      }
      class Pm extends Nm {
        constructor(t4) {
          super(t4), this.top = this.createCollection(), this.main = this.createCollection(), this._voiceLabelView = this._createVoiceLabel(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-reset", "ck-editor", "ck-rounded-corners"], role: "application", dir: t4.uiLanguageDirection, lang: t4.uiLanguage, "aria-labelledby": this._voiceLabelView.id }, children: [this._voiceLabelView, { tag: "div", attributes: { class: ["ck", "ck-editor__top", "ck-reset_all"], role: "presentation" }, children: this.top }, { tag: "div", attributes: { class: ["ck", "ck-editor__main"], role: "presentation" }, children: this.main }] });
        }
        _createVoiceLabel() {
          const t4 = this.t, e4 = new Er();
          return e4.text = t4("Rich Text Editor"), e4.extendTemplate({ attributes: { class: "ck-voice-label" } }), e4;
        }
      }
      class zm extends Hi2 {
        constructor(t4, e4, n3) {
          super(t4), this.name = null, this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-content", "ck-editor__editable", "ck-rounded-corners"], lang: t4.contentLanguage, dir: t4.contentLanguageDirection } }), this.set("isFocused", false), this._editableElement = n3, this._hasExternalElement = !!this._editableElement, this._editingView = e4;
        }
        render() {
          super.render(), this._hasExternalElement ? this.template.apply(this.element = this._editableElement) : this._editableElement = this.element, this.on("change:isFocused", () => this._updateIsFocusedClasses()), this._updateIsFocusedClasses();
        }
        destroy() {
          this._hasExternalElement && this.template.revert(this._editableElement), super.destroy();
        }
        get hasExternalElement() {
          return this._hasExternalElement;
        }
        _updateIsFocusedClasses() {
          const t4 = this._editingView;
          function e4(e5) {
            t4.change((n3) => {
              const o3 = t4.document.getRoot(e5.name);
              n3.addClass(e5.isFocused ? "ck-focused" : "ck-blurred", o3), n3.removeClass(e5.isFocused ? "ck-blurred" : "ck-focused", o3);
            });
          }
          t4.isRenderingInProgress ? function n3(o3) {
            t4.once("change:isRenderingInProgress", (t5, i3, r3) => {
              r3 ? n3(o3) : e4(o3);
            });
          }(this) : e4(this);
        }
      }
      class Om extends zm {
        constructor(t4, e4, n3, o3 = {}) {
          super(t4, e4, n3);
          const i3 = t4.t;
          this.extendTemplate({ attributes: { role: "textbox", class: "ck-editor__editable_inline" } }), this._generateLabel = o3.label || (() => i3("Editor editing area: %0", this.name));
        }
        render() {
          super.render();
          const t4 = this._editingView;
          t4.change((e4) => {
            const n3 = t4.document.getRoot(this.name);
            e4.setAttribute("aria-label", this._generateLabel(this), n3);
          });
        }
      }
      var Lm = n2(8847), jm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Lm.Z, jm);
      Lm.Z.locals;
      class Rm extends ns {
        static get pluginName() {
          return "Notification";
        }
        init() {
          this.on("show:warning", (t4, e4) => {
            window.alert(e4.message);
          }, { priority: "lowest" });
        }
        showSuccess(t4, e4 = {}) {
          this._showNotification({ message: t4, type: "success", namespace: e4.namespace, title: e4.title });
        }
        showInfo(t4, e4 = {}) {
          this._showNotification({ message: t4, type: "info", namespace: e4.namespace, title: e4.title });
        }
        showWarning(t4, e4 = {}) {
          this._showNotification({ message: t4, type: "warning", namespace: e4.namespace, title: e4.title });
        }
        _showNotification(t4) {
          const e4 = t4.namespace ? `show:${t4.type}:${t4.namespace}` : `show:${t4.type}`;
          this.fire(e4, { message: t4.message, type: t4.type, title: t4.title || "" });
        }
      }
      class Fm extends W2() {
        constructor(t4, e4) {
          super(), e4 && zc2(this, e4), t4 && this.set(t4);
        }
      }
      var Vm = n2(4650), Hm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Vm.Z, Hm);
      Vm.Z.locals;
      var Um = n2(7676), qm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Um.Z, qm);
      Um.Z.locals;
      const Gm = $o2("px");
      class Wm extends $r {
        constructor(t4) {
          super(t4), this._viewToStack = /* @__PURE__ */ new Map(), this._idToStack = /* @__PURE__ */ new Map(), this._view = null, this._rotatorView = null, this._fakePanelsView = null, this.positionLimiter = () => {
            const t5 = this.editor.editing.view, e4 = t5.document.selection.editableElement;
            return e4 ? t5.domConverter.mapViewToDom(e4.root) : null;
          }, this.set("visibleView", null), this.set("_numberOfStacks", 0), this.set("_singleViewMode", false);
        }
        static get pluginName() {
          return "ContextualBalloon";
        }
        destroy() {
          super.destroy(), this._view && this._view.destroy(), this._rotatorView && this._rotatorView.destroy(), this._fakePanelsView && this._fakePanelsView.destroy();
        }
        get view() {
          return this._view || this._createPanelView(), this._view;
        }
        hasView(t4) {
          return Array.from(this._viewToStack.keys()).includes(t4);
        }
        add(t4) {
          if (this._view || this._createPanelView(), this.hasView(t4.view))
            throw new A2("contextualballoon-add-view-exist", [this, t4]);
          const e4 = t4.stackId || "main";
          if (!this._idToStack.has(e4))
            return this._idToStack.set(e4, /* @__PURE__ */ new Map([[t4.view, t4]])), this._viewToStack.set(t4.view, this._idToStack.get(e4)), this._numberOfStacks = this._idToStack.size, void (this._visibleStack && !t4.singleViewMode || this.showStack(e4));
          const n3 = this._idToStack.get(e4);
          t4.singleViewMode && this.showStack(e4), n3.set(t4.view, t4), this._viewToStack.set(t4.view, n3), n3 === this._visibleStack && this._showView(t4);
        }
        remove(t4) {
          if (!this.hasView(t4))
            throw new A2("contextualballoon-remove-view-not-exist", [this, t4]);
          const e4 = this._viewToStack.get(t4);
          this._singleViewMode && this.visibleView === t4 && (this._singleViewMode = false), this.visibleView === t4 && (1 === e4.size ? this._idToStack.size > 1 ? this._showNextStack() : (this.view.hide(), this.visibleView = null, this._rotatorView.hideView()) : this._showView(Array.from(e4.values())[e4.size - 2])), 1 === e4.size ? (this._idToStack.delete(this._getStackId(e4)), this._numberOfStacks = this._idToStack.size) : e4.delete(t4), this._viewToStack.delete(t4);
        }
        updatePosition(t4) {
          t4 && (this._visibleStack.get(this.visibleView).position = t4), this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition();
        }
        showStack(t4) {
          this.visibleStack = t4;
          const e4 = this._idToStack.get(t4);
          if (!e4)
            throw new A2("contextualballoon-showstack-stack-not-exist", this);
          this._visibleStack !== e4 && this._showView(Array.from(e4.values()).pop());
        }
        _createPanelView() {
          this._view = new em(this.editor.locale), this.editor.ui.view.body.add(this._view), this.editor.ui.focusTracker.add(this._view.element), this._rotatorView = this._createRotatorView(), this._fakePanelsView = this._createFakePanelsView();
        }
        get _visibleStack() {
          return this._viewToStack.get(this.visibleView);
        }
        _getStackId(t4) {
          return Array.from(this._idToStack.entries()).find((e4) => e4[1] === t4)[0];
        }
        _showNextStack() {
          const t4 = Array.from(this._idToStack.values());
          let e4 = t4.indexOf(this._visibleStack) + 1;
          t4[e4] || (e4 = 0), this.showStack(this._getStackId(t4[e4]));
        }
        _showPrevStack() {
          const t4 = Array.from(this._idToStack.values());
          let e4 = t4.indexOf(this._visibleStack) - 1;
          t4[e4] || (e4 = t4.length - 1), this.showStack(this._getStackId(t4[e4]));
        }
        _createRotatorView() {
          const t4 = new Km(this.editor.locale), e4 = this.editor.locale.t;
          return this.view.content.add(t4), t4.bind("isNavigationVisible").to(this, "_numberOfStacks", this, "_singleViewMode", (t5, e5) => !e5 && t5 > 1), t4.on("change:isNavigationVisible", () => this.updatePosition(), { priority: "low" }), t4.bind("counter").to(this, "visibleView", this, "_numberOfStacks", (t5, n3) => {
            if (n3 < 2)
              return "";
            const o3 = Array.from(this._idToStack.values()).indexOf(this._visibleStack) + 1;
            return e4("%0 of %1", [o3, n3]);
          }), t4.buttonNextView.on("execute", () => {
            t4.focusTracker.isFocused && this.editor.editing.view.focus(), this._showNextStack();
          }), t4.buttonPrevView.on("execute", () => {
            t4.focusTracker.isFocused && this.editor.editing.view.focus(), this._showPrevStack();
          }), t4;
        }
        _createFakePanelsView() {
          const t4 = new Ym(this.editor.locale, this.view);
          return t4.bind("numberOfPanels").to(this, "_numberOfStacks", this, "_singleViewMode", (t5, e4) => !e4 && t5 >= 2 ? Math.min(t5 - 1, 2) : 0), t4.listenTo(this.view, "change:top", () => t4.updatePosition()), t4.listenTo(this.view, "change:left", () => t4.updatePosition()), this.editor.ui.view.body.add(t4), t4;
        }
        _showView({ view: t4, balloonClassName: e4 = "", withArrow: n3 = true, singleViewMode: o3 = false }) {
          this.view.class = e4, this.view.withArrow = n3, this._rotatorView.showView(t4), this.visibleView = t4, this.view.pin(this._getBalloonPosition()), this._fakePanelsView.updatePosition(), o3 && (this._singleViewMode = true);
        }
        _getBalloonPosition() {
          let t4 = Array.from(this._visibleStack.values()).pop().position;
          return t4 && (t4.limiter || (t4 = Object.assign({}, t4, { limiter: this.positionLimiter })), t4 = Object.assign({}, t4, { viewportOffsetConfig: this.editor.ui.viewportOffset })), t4;
        }
      }
      class Km extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = t4.t, n3 = this.bindTemplate;
          this.set("isNavigationVisible", true), this.focusTracker = new Ii2(), this.buttonPrevView = this._createButtonView(e4("Previous"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z"/></svg>'), this.buttonNextView = this._createButtonView(e4("Next"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z"/></svg>'), this.content = this.createCollection(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-balloon-rotator"], "z-index": "-1" }, children: [{ tag: "div", attributes: { class: ["ck-balloon-rotator__navigation", n3.to("isNavigationVisible", (t5) => t5 ? "" : "ck-hidden")] }, children: [this.buttonPrevView, { tag: "span", attributes: { class: ["ck-balloon-rotator__counter"] }, children: [{ text: n3.to("counter") }] }, this.buttonNextView] }, { tag: "div", attributes: { class: "ck-balloon-rotator__content" }, children: this.content }] });
        }
        render() {
          super.render(), this.focusTracker.add(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy();
        }
        showView(t4) {
          this.hideView(), this.content.add(t4);
        }
        hideView() {
          this.content.clear();
        }
        _createButtonView(t4, e4) {
          const n3 = new br(this.locale);
          return n3.set({ label: t4, icon: e4, tooltip: true }), n3;
        }
      }
      class Ym extends Hi2 {
        constructor(t4, e4) {
          super(t4);
          const n3 = this.bindTemplate;
          this.set("top", 0), this.set("left", 0), this.set("height", 0), this.set("width", 0), this.set("numberOfPanels", 0), this.content = this.createCollection(), this._balloonPanelView = e4, this.setTemplate({ tag: "div", attributes: { class: ["ck-fake-panel", n3.to("numberOfPanels", (t5) => t5 ? "" : "ck-hidden")], style: { top: n3.to("top", Gm), left: n3.to("left", Gm), width: n3.to("width", Gm), height: n3.to("height", Gm) } }, children: this.content }), this.on("change:numberOfPanels", (t5, e5, n4, o3) => {
            n4 > o3 ? this._addPanels(n4 - o3) : this._removePanels(o3 - n4), this.updatePosition();
          });
        }
        _addPanels(t4) {
          for (; t4--; ) {
            const t5 = new Hi2();
            t5.setTemplate({ tag: "div" }), this.content.add(t5), this.registerChild(t5);
          }
        }
        _removePanels(t4) {
          for (; t4--; ) {
            const t5 = this.content.last;
            this.content.remove(t5), this.deregisterChild(t5), t5.destroy();
          }
        }
        updatePosition() {
          if (this.numberOfPanels) {
            const { top: t4, left: e4 } = this._balloonPanelView, { width: n3, height: o3 } = new Vo2(this._balloonPanelView.element);
            Object.assign(this, { top: t4, left: e4, width: n3, height: o3 });
          }
        }
      }
      var $m = n2(5868), Zm = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()($m.Z, Zm);
      $m.Z.locals;
      const Qm = $o2("px");
      class Jm extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = this.bindTemplate;
          this.set("isActive", false), this.set("isSticky", false), this.set("limiterElement", null), this.set("limiterBottomOffset", 50), this.set("viewportTopOffset", 0), this.set("_marginLeft", null), this.set("_isStickyToTheBottomOfLimiter", false), this.set("_stickyTopOffset", null), this.set("_stickyBottomOffset", null), this.content = this.createCollection(), this._contentPanelPlaceholder = new Ui2({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__placeholder"], style: { display: e4.to("isSticky", (t5) => t5 ? "block" : "none"), height: e4.to("isSticky", (t5) => t5 ? Qm(this._contentPanelRect.height) : null) } } }).render(), this._contentPanel = new Ui2({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel__content", e4.if("isSticky", "ck-sticky-panel__content_sticky"), e4.if("_isStickyToTheBottomOfLimiter", "ck-sticky-panel__content_sticky_bottom-limit")], style: { width: e4.to("isSticky", (t5) => t5 ? Qm(this._contentPanelPlaceholder.getBoundingClientRect().width) : null), top: e4.to("_stickyTopOffset", (t5) => t5 ? Qm(t5) : t5), bottom: e4.to("_stickyBottomOffset", (t5) => t5 ? Qm(t5) : t5), marginLeft: e4.to("_marginLeft") } }, children: this.content }).render(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-sticky-panel"] }, children: [this._contentPanelPlaceholder, this._contentPanel] });
        }
        render() {
          super.render(), this.checkIfShouldBeSticky(), this.listenTo(zo2.document, "scroll", () => {
            this.checkIfShouldBeSticky();
          }, { useCapture: true }), this.listenTo(this, "change:isActive", () => {
            this.checkIfShouldBeSticky();
          });
        }
        checkIfShouldBeSticky() {
          if (!this.limiterElement || !this.isActive)
            return void this._unstick();
          const t4 = new Vo2(this.limiterElement);
          let e4 = t4.getVisible();
          if (e4) {
            const t5 = new Vo2(zo2.window);
            t5.top += this.viewportTopOffset, t5.height -= this.viewportTopOffset, e4 = e4.getIntersection(t5);
          }
          if (e4 && t4.top < e4.top) {
            const n3 = e4.top;
            if (n3 + this._contentPanelRect.height + this.limiterBottomOffset > e4.bottom) {
              const n4 = Math.max(t4.bottom - e4.bottom, 0) + this.limiterBottomOffset;
              t4.bottom - n4 > t4.top + this._contentPanelRect.height ? this._stickToBottomOfLimiter(n4) : this._unstick();
            } else
              this._contentPanelRect.height + this.limiterBottomOffset < t4.height ? this._stickToTopOfAncestors(n3) : this._unstick();
          } else
            this._unstick();
        }
        _stickToTopOfAncestors(t4) {
          this.isSticky = true, this._isStickyToTheBottomOfLimiter = false, this._stickyTopOffset = t4, this._stickyBottomOffset = null, this._marginLeft = Qm(-zo2.window.scrollX);
        }
        _stickToBottomOfLimiter(t4) {
          this.isSticky = true, this._isStickyToTheBottomOfLimiter = true, this._stickyTopOffset = null, this._stickyBottomOffset = t4, this._marginLeft = Qm(-zo2.window.scrollX);
        }
        _unstick() {
          this.isSticky = false, this._isStickyToTheBottomOfLimiter = false, this._stickyTopOffset = null, this._stickyBottomOffset = null, this._marginLeft = null;
        }
        get _contentPanelRect() {
          return new Vo2(this._contentPanel);
        }
      }
      class Xm extends Ir {
        constructor(t4, e4) {
          const n3 = t4.t, o3 = Object.assign({}, { showResetButton: true, showIcon: true, creator: ap }, e4);
          super(t4, o3.creator), this.label = e4.label, this._viewConfig = o3, this._viewConfig.showIcon && (this.iconView = new pr(), this.iconView.content = Bg2.loupe, this.fieldWrapperChildren.add(this.iconView, 0), this.extendTemplate({ attributes: { class: "ck-search__query_with-icon" } })), this._viewConfig.showResetButton && (this.resetButtonView = new br(t4), this.resetButtonView.set({ label: n3("Clear"), icon: Bg2.cancel, class: "ck-search__reset", isVisible: false, tooltip: true }), this.resetButtonView.on("execute", () => {
            this.reset(), this.focus(), this.fire("reset");
          }), this.resetButtonView.bind("isVisible").to(this.fieldView, "isEmpty", (t5) => !t5), this.fieldWrapperChildren.add(this.resetButtonView), this.extendTemplate({ attributes: { class: "ck-search__query_with-reset" } }));
        }
        reset() {
          this.fieldView.reset(), this._viewConfig.showResetButton && (this.resetButtonView.isVisible = false);
        }
      }
      class tf2 extends Hi2 {
        constructor() {
          super();
          const t4 = this.bindTemplate;
          this.set({ isVisible: false, primaryText: "", secondaryText: "" }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search__info", t4.if("isVisible", "ck-hidden", (t5) => !t5)], tabindex: -1 }, children: [{ tag: "span", children: [{ text: [t4.to("primaryText")] }] }, { tag: "span", children: [{ text: [t4.to("secondaryText")] }] }] });
        }
        focus() {
          this.element.focus();
        }
      }
      class ef2 extends Hi2 {
        constructor(t4) {
          super(t4), this.children = this.createCollection(), this.focusTracker = new Ii2(), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search__results"], tabindex: -1 }, children: this.children }), this._focusCycler = new qr({ focusables: this.children, focusTracker: this.focusTracker });
        }
        render() {
          super.render();
          for (const t4 of this.children)
            this.focusTracker.add(t4.element);
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        focusFirst() {
          this._focusCycler.focusFirst();
        }
        focusLast() {
          this._focusCycler.focusLast();
        }
      }
      var nf2 = /[\\^$.*+?()[\]{}|]/g, of2 = RegExp(nf2.source);
      const rf2 = function(t4) {
        return (t4 = Os(t4)) && of2.test(t4) ? t4.replace(nf2, "\\$&") : t4;
      };
      var sf2 = n2(6770), af2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(sf2.Z, af2);
      sf2.Z.locals;
      var cf2 = Object.defineProperty, lf2 = Object.getOwnPropertySymbols, df2 = Object.prototype.hasOwnProperty, hf = Object.prototype.propertyIsEnumerable, uf2 = (t4, e4, n3) => e4 in t4 ? cf2(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3;
      class gf extends Hi2 {
        constructor(t4, e4) {
          super(t4), this._config = e4, this.filteredView = e4.filteredView, this.queryView = this._createSearchTextQueryView(), this.focusTracker = new Ii2(), this.keystrokes = new Ti2(), this.resultsView = new ef2(t4), this.children = this.createCollection(), this.focusableChildren = this.createCollection([this.queryView, this.resultsView]), this.set("isEnabled", true), this.set("resultsCount", 0), this.set("totalItemsCount", 0), e4.infoView && e4.infoView.instance ? this.infoView = e4.infoView.instance : (this.infoView = new tf2(), this._enableDefaultInfoViewBehavior(), this.on("render", () => {
            this.search("");
          })), this.resultsView.children.addMany([this.infoView, this.filteredView]), this.focusCycler = new qr({ focusables: this.focusableChildren, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.on("search", (t5, { resultsCount: e5, totalItemsCount: n3 }) => {
            this.resultsCount = e5, this.totalItemsCount = n3;
          }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-search", e4.class || null], tabindex: "-1" }, children: this.children });
        }
        render() {
          super.render(), this.children.addMany([this.queryView, this.resultsView]);
          const t4 = (t5) => t5.stopPropagation();
          for (const t5 of this.focusableChildren)
            this.focusTracker.add(t5.element);
          this.keystrokes.listenTo(this.element), this.keystrokes.set("arrowright", t4), this.keystrokes.set("arrowleft", t4), this.keystrokes.set("arrowup", t4), this.keystrokes.set("arrowdown", t4);
        }
        focus() {
          this.queryView.focus();
        }
        reset() {
          this.queryView.reset(), this.search("");
        }
        search(t4) {
          const e4 = t4 ? new RegExp(rf2(t4), "ig") : null, n3 = this.filteredView.filter(e4);
          this.fire("search", ((t5, e5) => {
            for (var n4 in e5 || (e5 = {}))
              df2.call(e5, n4) && uf2(t5, n4, e5[n4]);
            if (lf2)
              for (var n4 of lf2(e5))
                hf.call(e5, n4) && uf2(t5, n4, e5[n4]);
            return t5;
          })({ query: t4 }, n3));
        }
        _createSearchTextQueryView() {
          const t4 = new Xm(this.locale, this._config.queryView);
          return this.listenTo(t4.fieldView, "input", () => {
            this.search(t4.fieldView.element.value);
          }), t4.on("reset", () => this.reset()), t4.bind("isEnabled").to(this), t4;
        }
        _enableDefaultInfoViewBehavior() {
          const t4 = this.locale.t, e4 = this.infoView;
          function n3(t5, { query: e5, resultsCount: n4, totalItemsCount: o3 }) {
            return "function" == typeof t5 ? t5(e5, n4, o3) : t5;
          }
          this.on("search", (o3, i3) => {
            if (i3.resultsCount)
              e4.set({ isVisible: false });
            else {
              const o4 = this._config.infoView && this._config.infoView.text;
              let r3, s3;
              i3.totalItemsCount ? o4 && o4.notFound ? (r3 = o4.notFound.primary, s3 = o4.notFound.secondary) : (r3 = t4("No results found"), s3 = "") : o4 && o4.noSearchableItems ? (r3 = o4.noSearchableItems.primary, s3 = o4.noSearchableItems.secondary) : (r3 = t4("No searchable items"), s3 = ""), e4.set({ primaryText: n3(r3, i3), secondaryText: n3(s3, i3), isVisible: true });
            }
          });
        }
      }
      var pf2 = n2(8157), mf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(pf2.Z, mf2);
      pf2.Z.locals;
      const ff2 = class extends gf {
        constructor(t4, e4) {
          super(t4, e4), this._config = e4;
          const n3 = $o2("px");
          this.extendTemplate({ attributes: { class: ["ck-autocomplete"] } });
          const o3 = this.resultsView.bindTemplate;
          this.resultsView.set("isVisible", false), this.resultsView.set("_position", "s"), this.resultsView.set("_width", 0), this.resultsView.extendTemplate({ attributes: { class: [o3.if("isVisible", "ck-hidden", (t5) => !t5), o3.to("_position", (t5) => `ck-search__results_${t5}`)], style: { width: o3.to("_width", n3) } } }), this.focusTracker.on("change:isFocused", (t5, n4, o4) => {
            this._updateResultsVisibility(), o4 ? this.resultsView.element.scrollTop = 0 : e4.resetOnBlur && this.queryView.reset();
          }), this.on("search", () => {
            this._updateResultsVisibility(), this._updateResultsViewWidthAndPosition();
          }), this.keystrokes.set("esc", (t5, e5) => {
            this.resultsView.isVisible = false, e5();
          }), this.listenTo(zo2.document, "scroll", () => {
            this._updateResultsViewWidthAndPosition();
          }), this.on("change:isEnabled", () => {
            this._updateResultsVisibility();
          }), this.filteredView.on("execute", (t5, { value: e5 }) => {
            this.focus(), this.reset(), this.queryView.fieldView.value = this.queryView.fieldView.element.value = e5, this.resultsView.isVisible = false;
          }), this.resultsView.on("change:isVisible", () => {
            this._updateResultsViewWidthAndPosition();
          });
        }
        _updateResultsViewWidthAndPosition() {
          if (!this.resultsView.isVisible)
            return;
          this.resultsView._width = new Vo2(this.queryView.fieldView.element).width;
          const t4 = ff2._getOptimalPosition({ element: this.resultsView.element, target: this.queryView.element, fitInViewport: true, positions: ff2.defaultResultsPositions });
          this.resultsView._position = t4 ? t4.name : "s";
        }
        _updateResultsVisibility() {
          const t4 = void 0 === this._config.queryMinChars ? 0 : this._config.queryMinChars, e4 = this.queryView.fieldView.element.value.length;
          this.resultsView.isVisible = this.focusTracker.isFocused && this.isEnabled && e4 >= t4;
        }
      };
      let kf = ff2;
      kf.defaultResultsPositions = [(t4) => ({ top: t4.bottom, left: t4.left, name: "s" }), (t4, e4) => ({ top: t4.top - e4.height, left: t4.left, name: "n" })], kf._getOptimalPosition = ei2;
      var bf2 = n2(8960), wf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(bf2.Z, wf2);
      bf2.Z.locals;
      var Af2 = n2(498), Cf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Af2.Z, Cf2);
      Af2.Z.locals;
      var _f = n2(9695), vf2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(_f.Z, vf2);
      _f.Z.locals;
      class yf2 extends Im {
        constructor(t4, e4) {
          super(t4), this.view = e4, this._toolbarConfig = Yr(t4.config.get("toolbar")), this._elementReplacer = new J2(), this.listenTo(t4.editing.view, "scrollToTheSelection", this._handleScrollToTheSelectionWithStickyPanel.bind(this));
        }
        get element() {
          return this.view.element;
        }
        init(t4) {
          const e4 = this.editor, n3 = this.view, o3 = e4.editing.view, i3 = n3.editable, r3 = o3.document.getRoot();
          i3.name = r3.rootName, n3.render();
          const s3 = i3.element;
          this.setEditableElement(i3.name, s3), n3.editable.bind("isFocused").to(this.focusTracker), o3.attachDomRoot(s3), t4 && this._elementReplacer.replace(t4, this.element), this._initPlaceholder(), this._initToolbar(), this.fire("ready");
        }
        destroy() {
          super.destroy();
          const t4 = this.view, e4 = this.editor.editing.view;
          this._elementReplacer.restore(), e4.detachDomRoot(t4.editable.name), t4.destroy();
        }
        _initToolbar() {
          const t4 = this.view;
          t4.stickyPanel.bind("isActive").to(this.focusTracker, "isFocused"), t4.stickyPanel.limiterElement = t4.element, t4.stickyPanel.bind("viewportTopOffset").to(this, "viewportOffset", ({ top: t5 }) => t5 || 0), t4.toolbar.fillFromConfig(this._toolbarConfig, this.componentFactory), this.addToolbar(t4.toolbar);
        }
        _initPlaceholder() {
          const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document.getRoot(), o3 = t4.sourceElement;
          let i3;
          const r3 = t4.config.get("placeholder");
          r3 && (i3 = "string" == typeof r3 ? r3 : r3[this.view.editable.name]), !i3 && o3 && "textarea" === o3.tagName.toLowerCase() && (i3 = o3.getAttribute("placeholder")), i3 && (n3.placeholder = i3), cs({ view: e4, element: n3, isDirectHost: false, keepOnFocus: true });
        }
        _handleScrollToTheSelectionWithStickyPanel(t4, e4, n3) {
          const o3 = this.view.stickyPanel;
          if (o3.isSticky) {
            const t5 = new Vo2(o3.element).height;
            e4.viewportOffset.top += t5;
          } else {
            const t5 = () => {
              this.editor.editing.view.scrollToTheSelection(n3);
            };
            this.listenTo(o3, "change:isSticky", t5), setTimeout(() => {
              this.stopListening(o3, "change:isSticky", t5);
            }, 20);
          }
        }
      }
      var xf2 = n2(3143), Ef2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(xf2.Z, Ef2);
      xf2.Z.locals;
      class Df2 extends Pm {
        constructor(t4, e4, n3 = {}) {
          super(t4), this.stickyPanel = new Jm(t4), this.toolbar = new Lg2(t4, { shouldGroupWhenFull: n3.shouldToolbarGroupWhenFull }), this.editable = new Om(t4, e4);
        }
        render() {
          super.render(), this.stickyPanel.content.add(this.toolbar), this.top.add(this.stickyPanel), this.main.add(this.editable);
        }
      }
      class Sf2 {
        constructor(t4) {
          if (this.crashes = [], this.state = "initializing", this._now = Date.now, this.crashes = [], this._crashNumberLimit = "number" == typeof t4.crashNumberLimit ? t4.crashNumberLimit : 3, this._minimumNonErrorTimePeriod = "number" == typeof t4.minimumNonErrorTimePeriod ? t4.minimumNonErrorTimePeriod : 5e3, this._boundErrorHandler = (t5) => {
            const e4 = "error" in t5 ? t5.error : t5.reason;
            e4 instanceof Error && this._handleError(e4, t5);
          }, this._listeners = {}, !this._restart)
            throw new Error("The Watchdog class was split into the abstract `Watchdog` class and the `EditorWatchdog` class. Please, use `EditorWatchdog` if you have used the `Watchdog` class previously.");
        }
        destroy() {
          this._stopErrorHandling(), this._listeners = {};
        }
        on(t4, e4) {
          this._listeners[t4] || (this._listeners[t4] = []), this._listeners[t4].push(e4);
        }
        off(t4, e4) {
          this._listeners[t4] = this._listeners[t4].filter((t5) => t5 !== e4);
        }
        _fire(t4, ...e4) {
          const n3 = this._listeners[t4] || [];
          for (const t5 of n3)
            t5.apply(this, [null, ...e4]);
        }
        _startErrorHandling() {
          window.addEventListener("error", this._boundErrorHandler), window.addEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _stopErrorHandling() {
          window.removeEventListener("error", this._boundErrorHandler), window.removeEventListener("unhandledrejection", this._boundErrorHandler);
        }
        _handleError(t4, e4) {
          if (this._shouldReactToError(t4)) {
            this.crashes.push({ message: t4.message, stack: t4.stack, filename: e4 instanceof ErrorEvent ? e4.filename : void 0, lineno: e4 instanceof ErrorEvent ? e4.lineno : void 0, colno: e4 instanceof ErrorEvent ? e4.colno : void 0, date: this._now() });
            const n3 = this._shouldRestart();
            this.state = "crashed", this._fire("stateChange"), this._fire("error", { error: t4, causesRestart: n3 }), n3 ? this._restart() : (this.state = "crashedPermanently", this._fire("stateChange"));
          }
        }
        _shouldReactToError(t4) {
          return t4.is && t4.is("CKEditorError") && void 0 !== t4.context && null !== t4.context && "ready" === this.state && this._isErrorComingFromThisItem(t4);
        }
        _shouldRestart() {
          if (this.crashes.length <= this._crashNumberLimit)
            return true;
          return (this.crashes[this.crashes.length - 1].date - this.crashes[this.crashes.length - 1 - this._crashNumberLimit].date) / this._crashNumberLimit > this._minimumNonErrorTimePeriod;
        }
      }
      function If2(t4, e4 = /* @__PURE__ */ new Set()) {
        const n3 = [t4], o3 = /* @__PURE__ */ new Set();
        let i3 = 0;
        for (; n3.length > i3; ) {
          const t5 = n3[i3++];
          if (!o3.has(t5) && Tf2(t5) && !e4.has(t5))
            if (o3.add(t5), Symbol.iterator in t5)
              try {
                for (const e5 of t5)
                  n3.push(e5);
              } catch (t6) {
              }
            else
              for (const e5 in t5)
                "defaultValue" !== e5 && n3.push(t5[e5]);
        }
        return o3;
      }
      function Tf2(t4) {
        const e4 = Object.prototype.toString.call(t4), n3 = typeof t4;
        return !("number" === n3 || "boolean" === n3 || "string" === n3 || "symbol" === n3 || "function" === n3 || "[object Date]" === e4 || "[object RegExp]" === e4 || "[object Module]" === e4 || null == t4 || t4._watchdogExcluded || t4 instanceof EventTarget || t4 instanceof Event);
      }
      function Mf2(t4, e4, n3 = /* @__PURE__ */ new Set()) {
        if (t4 === e4 && ("object" == typeof (o3 = t4) && null !== o3))
          return true;
        var o3;
        const i3 = If2(t4, n3), r3 = If2(e4, n3);
        for (const t5 of i3)
          if (r3.has(t5))
            return true;
        return false;
      }
      var Bf2 = Object.defineProperty, Nf2 = Object.defineProperties, Pf2 = Object.getOwnPropertyDescriptors, zf2 = Object.getOwnPropertySymbols, Of2 = Object.prototype.hasOwnProperty, Lf2 = Object.prototype.propertyIsEnumerable, jf = (t4, e4, n3) => e4 in t4 ? Bf2(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, Rf2 = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          Of2.call(e4, n3) && jf(t4, n3, e4[n3]);
        if (zf2)
          for (var n3 of zf2(e4))
            Lf2.call(e4, n3) && jf(t4, n3, e4[n3]);
        return t4;
      };
      class Ff2 extends Sf2 {
        constructor(t4, e4 = {}) {
          super(e4), this._editor = null, this._initUsingData = true, this._editables = {}, this._throttledSave = dm(this._save.bind(this), "number" == typeof e4.saveInterval ? e4.saveInterval : 5e3), t4 && (this._creator = (e5, n3) => t4.create(e5, n3)), this._destructor = (t5) => t5.destroy();
        }
        get editor() {
          return this._editor;
        }
        get _item() {
          return this._editor;
        }
        setCreator(t4) {
          this._creator = t4;
        }
        setDestructor(t4) {
          this._destructor = t4;
        }
        _restart() {
          return Promise.resolve().then(() => (this.state = "initializing", this._fire("stateChange"), this._destroy())).catch((t4) => {
            console.error("An error happened during the editor destroying.", t4);
          }).then(() => {
            const t4 = {}, e4 = [], n3 = this._config.rootsAttributes || {}, o3 = {};
            for (const [i4, r4] of Object.entries(this._data.roots))
              r4.isLoaded ? (t4[i4] = "", o3[i4] = n3[i4] || {}) : e4.push(i4);
            const i3 = (r3 = Rf2({}, this._config), s3 = { extraPlugins: this._config.extraPlugins || [], lazyRoots: e4, rootsAttributes: o3, _watchdogInitialData: this._data }, Nf2(r3, Pf2(s3)));
            var r3, s3;
            return delete i3.initialData, i3.extraPlugins.push(Vf2), this._initUsingData ? this.create(t4, i3, i3.context) : yo2(this._elementOrData) ? this.create(this._elementOrData, i3, i3.context) : this.create(this._editables, i3, i3.context);
          }).then(() => {
            this._fire("restart");
          });
        }
        create(t4 = this._elementOrData, e4 = this._config, n3) {
          return Promise.resolve().then(() => (super._startErrorHandling(), this._elementOrData = t4, this._initUsingData = "string" == typeof t4 || Object.keys(t4).length > 0 && "string" == typeof Object.values(t4)[0], this._config = this._cloneEditorConfiguration(e4) || {}, this._config.context = n3, this._creator(t4, this._config))).then((t5) => {
            this._editor = t5, t5.model.document.on("change:data", this._throttledSave), this._lastDocumentVersion = t5.model.document.version, this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this.state = "ready", this._fire("stateChange");
          });
        }
        destroy() {
          return Promise.resolve().then(() => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling(), this._throttledSave.cancel();
            const t4 = this._editor;
            return this._editor = null, t4.model.document.off("change:data", this._throttledSave), this._destructor(t4);
          });
        }
        _save() {
          const t4 = this._editor.model.document.version;
          try {
            this._data = this._getData(), this._initUsingData || (this._editables = this._getEditables()), this._lastDocumentVersion = t4;
          } catch (t5) {
            console.error(t5, "An error happened during restoring editor data. Editor will be restored from the previously saved data.");
          }
        }
        _setExcludedProperties(t4) {
          this._excludedProps = t4;
        }
        _getData() {
          const t4 = this._editor, e4 = t4.model.document.roots.filter((t5) => t5.isAttached() && "$graveyard" != t5.rootName), { plugins: n3 } = t4, o3 = n3.has("CommentsRepository") && n3.get("CommentsRepository"), i3 = n3.has("TrackChanges") && n3.get("TrackChanges"), r3 = { roots: {}, markers: {}, commentThreads: JSON.stringify([]), suggestions: JSON.stringify([]) };
          e4.forEach((t5) => {
            r3.roots[t5.rootName] = { content: JSON.stringify(Array.from(t5.getChildren())), attributes: JSON.stringify(Array.from(t5.getAttributes())), isLoaded: t5._isLoaded };
          });
          for (const e5 of t4.model.markers)
            e5._affectsData && (r3.markers[e5.name] = { rangeJSON: e5.getRange().toJSON(), usingOperation: e5._managedUsingOperations, affectsData: e5._affectsData });
          return o3 && (r3.commentThreads = JSON.stringify(o3.getCommentThreads({ toJSON: true, skipNotAttached: true }))), i3 && (r3.suggestions = JSON.stringify(i3.getSuggestions({ toJSON: true, skipNotAttached: true }))), r3;
        }
        _getEditables() {
          const t4 = {};
          for (const e4 of this.editor.model.document.getRootNames()) {
            const n3 = this.editor.ui.getEditableElement(e4);
            n3 && (t4[e4] = n3);
          }
          return t4;
        }
        _isErrorComingFromThisItem(t4) {
          return Mf2(this._editor, t4.context, this._excludedProps);
        }
        _cloneEditorConfiguration(t4) {
          return vo2(t4, (t5, e4) => yo2(t5) || "context" === e4 ? t5 : void 0);
        }
      }
      class Vf2 {
        constructor(t4) {
          this.editor = t4, this._data = t4.config.get("_watchdogInitialData");
        }
        init() {
          this.editor.data.on("init", (t4) => {
            t4.stop(), this.editor.model.enqueueChange({ isUndoable: false }, (t5) => {
              this._restoreCollaborationData(), this._restoreEditorData(t5);
            }), this.editor.data.fire("ready");
          }, { priority: 999 });
        }
        _createNode(t4, e4) {
          if ("name" in e4) {
            const n3 = t4.createElement(e4.name, e4.attributes);
            if (e4.children)
              for (const o3 of e4.children)
                n3._appendChild(this._createNode(t4, o3));
            return n3;
          }
          return t4.createText(e4.data, e4.attributes);
        }
        _restoreEditorData(t4) {
          const e4 = this.editor;
          Object.entries(this._data.roots).forEach(([n3, { content: o3, attributes: i3 }]) => {
            const r3 = JSON.parse(o3), s3 = JSON.parse(i3), a3 = e4.model.document.getRoot(n3);
            for (const [e5, n4] of s3)
              t4.setAttribute(e5, n4, a3);
            for (const e5 of r3) {
              const n4 = this._createNode(t4, e5);
              t4.insert(n4, a3, "end");
            }
          }), Object.entries(this._data.markers).forEach(([n3, o3]) => {
            const { document: i3 } = e4.model, r3 = o3, { rangeJSON: { start: s3, end: a3 } } = r3, c3 = ((t5, e5) => {
              var n4 = {};
              for (var o4 in t5)
                Of2.call(t5, o4) && e5.indexOf(o4) < 0 && (n4[o4] = t5[o4]);
              if (null != t5 && zf2)
                for (var o4 of zf2(t5))
                  e5.indexOf(o4) < 0 && Lf2.call(t5, o4) && (n4[o4] = t5[o4]);
              return n4;
            })(r3, ["rangeJSON"]), l3 = i3.getRoot(s3.root), d3 = t4.createPositionFromPath(l3, s3.path, s3.stickiness), h3 = t4.createPositionFromPath(l3, a3.path, a3.stickiness), u3 = t4.createRange(d3, h3);
            t4.addMarker(n3, Rf2({ range: u3 }, c3));
          });
        }
        _restoreCollaborationData() {
          const t4 = JSON.parse(this._data.commentThreads), e4 = JSON.parse(this._data.suggestions);
          t4.forEach((t5) => {
            const e5 = this.editor.config.get("collaboration.channelId"), n3 = this.editor.plugins.get("CommentsRepository");
            if (n3.hasCommentThread(t5.threadId)) {
              n3.getCommentThread(t5.threadId).remove();
            }
            n3.addCommentThread(Rf2({ channelId: e5 }, t5));
          }), e4.forEach((t5) => {
            const e5 = this.editor.plugins.get("TrackChangesEditing");
            if (e5.hasSuggestion(t5.id)) {
              e5.getSuggestion(t5.id).attributes = t5.attributes;
            } else
              e5.addSuggestionData(t5);
          });
        }
      }
      const Hf2 = Symbol("MainQueueId");
      class Uf2 {
        constructor() {
          this._onEmptyCallbacks = [], this._queues = /* @__PURE__ */ new Map(), this._activeActions = 0;
        }
        onEmpty(t4) {
          this._onEmptyCallbacks.push(t4);
        }
        enqueue(t4, e4) {
          const n3 = t4 === Hf2;
          this._activeActions++, this._queues.get(t4) || this._queues.set(t4, Promise.resolve());
          const o3 = (n3 ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(Hf2), this._queues.get(t4)])).then(e4), i3 = o3.catch(() => {
          });
          return this._queues.set(t4, i3), o3.finally(() => {
            this._activeActions--, this._queues.get(t4) === i3 && 0 === this._activeActions && this._onEmptyCallbacks.forEach((t5) => t5());
          });
        }
      }
      function qf2(t4) {
        return Array.isArray(t4) ? t4 : [t4];
      }
      class Gf2 extends Ig2(Tg2(Sg2)) {
        constructor(t4, e4 = {}) {
          if (!Wf2(t4) && void 0 !== e4.initialData)
            throw new A2("editor-create-initial-data", null);
          super(e4), void 0 === this.config.get("initialData") && this.config.set("initialData", function(t5) {
            return Wf2(t5) ? (e5 = t5, e5 instanceof HTMLTextAreaElement ? e5.value : e5.innerHTML) : t5;
            var e5;
          }(t4)), Wf2(t4) && (this.sourceElement = t4), this.model.document.createRoot();
          const n3 = !this.config.get("toolbar.shouldNotGroupWhenFull"), o3 = new Df2(this.locale, this.editing.view, { shouldToolbarGroupWhenFull: n3 });
          this.ui = new yf2(this, o3), function(t5) {
            if (!Vt2(t5.updateSourceElement))
              throw new A2("attachtoform-missing-elementapi-interface", t5);
            const e5 = t5.sourceElement;
            if (function(t6) {
              return !!t6 && "textarea" === t6.tagName.toLowerCase();
            }(e5) && e5.form) {
              let n4;
              const o4 = e5.form, i3 = () => t5.updateSourceElement();
              Vt2(o4.submit) && (n4 = o4.submit, o4.submit = () => {
                i3(), n4.apply(o4);
              }), o4.addEventListener("submit", i3), t5.on("destroy", () => {
                o4.removeEventListener("submit", i3), n4 && (o4.submit = n4);
              });
            }
          }(this);
        }
        destroy() {
          return this.sourceElement && this.updateSourceElement(), this.ui.destroy(), super.destroy();
        }
        static create(t4, e4 = {}) {
          return new Promise((n3) => {
            const o3 = new this(t4, e4);
            n3(o3.initPlugins().then(() => o3.ui.init(Wf2(t4) ? t4 : null)).then(() => o3.data.init(o3.config.get("initialData"))).then(() => o3.fire("ready")).then(() => o3));
          });
        }
      }
      function Wf2(t4) {
        return yo2(t4);
      }
      Gf2.Context = es, Gf2.EditorWatchdog = Ff2, Gf2.ContextWatchdog = class extends Sf2 {
        constructor(t4, e4 = {}) {
          super(e4), this._watchdogs = /* @__PURE__ */ new Map(), this._context = null, this._contextProps = /* @__PURE__ */ new Set(), this._actionQueues = new Uf2(), this._watchdogConfig = e4, this._creator = (e5) => t4.create(e5), this._destructor = (t5) => t5.destroy(), this._actionQueues.onEmpty(() => {
            "initializing" === this.state && (this.state = "ready", this._fire("stateChange"));
          });
        }
        setCreator(t4) {
          this._creator = t4;
        }
        setDestructor(t4) {
          this._destructor = t4;
        }
        get context() {
          return this._context;
        }
        create(t4 = {}) {
          return this._actionQueues.enqueue(Hf2, () => (this._contextConfig = t4, this._create()));
        }
        getItem(t4) {
          return this._getWatchdog(t4)._item;
        }
        getItemState(t4) {
          return this._getWatchdog(t4).state;
        }
        add(t4) {
          const e4 = qf2(t4);
          return Promise.all(e4.map((t5) => this._actionQueues.enqueue(t5.id, () => {
            if ("destroyed" === this.state)
              throw new Error("Cannot add items to destroyed watchdog.");
            if (!this._context)
              throw new Error("Context was not created yet. You should call the `ContextWatchdog#create()` method first.");
            let e5;
            if (this._watchdogs.has(t5.id))
              throw new Error(`Item with the given id is already added: '${t5.id}'.`);
            if ("editor" === t5.type)
              return e5 = new Ff2(null, this._watchdogConfig), e5.setCreator(t5.creator), e5._setExcludedProperties(this._contextProps), t5.destructor && e5.setDestructor(t5.destructor), this._watchdogs.set(t5.id, e5), e5.on("error", (n3, { error: o3, causesRestart: i3 }) => {
                this._fire("itemError", { itemId: t5.id, error: o3 }), i3 && this._actionQueues.enqueue(t5.id, () => new Promise((n4) => {
                  const o4 = () => {
                    e5.off("restart", o4), this._fire("itemRestart", { itemId: t5.id }), n4();
                  };
                  e5.on("restart", o4);
                }));
              }), e5.create(t5.sourceElementOrData, t5.config, this._context);
            throw new Error(`Not supported item type: '${t5.type}'.`);
          })));
        }
        remove(t4) {
          const e4 = qf2(t4);
          return Promise.all(e4.map((t5) => this._actionQueues.enqueue(t5, () => {
            const e5 = this._getWatchdog(t5);
            return this._watchdogs.delete(t5), e5.destroy();
          })));
        }
        destroy() {
          return this._actionQueues.enqueue(Hf2, () => (this.state = "destroyed", this._fire("stateChange"), super.destroy(), this._destroy()));
        }
        _restart() {
          return this._actionQueues.enqueue(Hf2, () => (this.state = "initializing", this._fire("stateChange"), this._destroy().catch((t4) => {
            console.error("An error happened during destroying the context or items.", t4);
          }).then(() => this._create()).then(() => this._fire("restart"))));
        }
        _create() {
          return Promise.resolve().then(() => (this._startErrorHandling(), this._creator(this._contextConfig))).then((t4) => (this._context = t4, this._contextProps = If2(this._context), Promise.all(Array.from(this._watchdogs.values()).map((t5) => (t5._setExcludedProperties(this._contextProps), t5.create(void 0, void 0, this._context))))));
        }
        _destroy() {
          return Promise.resolve().then(() => {
            this._stopErrorHandling();
            const t4 = this._context;
            return this._context = null, this._contextProps = /* @__PURE__ */ new Set(), Promise.all(Array.from(this._watchdogs.values()).map((t5) => t5.destroy())).then(() => this._destructor(t4));
          });
        }
        _getWatchdog(t4) {
          const e4 = this._watchdogs.get(t4);
          if (!e4)
            throw new Error(`Item with the given id was not registered: ${t4}.`);
          return e4;
        }
        _isErrorComingFromThisItem(t4) {
          for (const e4 of this._watchdogs.values())
            if (e4._isErrorComingFromThisItem(t4))
              return false;
          return Mf2(this._context, t4.context);
        }
      };
      class Kf2 extends Lc2 {
        constructor(t4) {
          super(t4), this.domEventType = ["paste", "copy", "cut", "drop", "dragover", "dragstart", "dragend", "dragenter", "dragleave"];
          const e4 = this.document;
          function n3(t5) {
            return (n4, o3) => {
              o3.preventDefault();
              const i3 = o3.dropRange ? [o3.dropRange] : null, r3 = new p2(e4, t5);
              e4.fire(r3, { dataTransfer: o3.dataTransfer, method: n4.name, targetRanges: i3, target: o3.target, domEvent: o3.domEvent }), r3.stop.called && o3.stopPropagation();
            };
          }
          this.listenTo(e4, "paste", n3("clipboardInput"), { priority: "low" }), this.listenTo(e4, "drop", n3("clipboardInput"), { priority: "low" }), this.listenTo(e4, "dragover", n3("dragging"), { priority: "low" });
        }
        onDomEvent(t4) {
          const e4 = "clipboardData" in t4 ? t4.clipboardData : t4.dataTransfer, n3 = "drop" == t4.type || "paste" == t4.type, o3 = { dataTransfer: new xl(e4, { cacheFiles: n3 }) };
          "drop" != t4.type && "dragover" != t4.type || (o3.dropRange = function(t5, e5) {
            const n4 = e5.target.ownerDocument, o4 = e5.clientX, i3 = e5.clientY;
            let r3;
            n4.caretRangeFromPoint && n4.caretRangeFromPoint(o4, i3) ? r3 = n4.caretRangeFromPoint(o4, i3) : e5.rangeParent && (r3 = n4.createRange(), r3.setStart(e5.rangeParent, e5.rangeOffset), r3.collapse(true));
            if (r3)
              return t5.domConverter.domRangeToView(r3);
            return null;
          }(this.view, t4)), this.fire(t4.type, t4, o3);
        }
      }
      const Yf2 = ["figcaption", "li"];
      function $f2(t4) {
        let e4 = "";
        if (t4.is("$text") || t4.is("$textProxy"))
          e4 = t4.data;
        else if (t4.is("element", "img") && t4.hasAttribute("alt"))
          e4 = t4.getAttribute("alt");
        else if (t4.is("element", "br"))
          e4 = "\n";
        else {
          let n3 = null;
          for (const o3 of t4.getChildren()) {
            const t5 = $f2(o3);
            n3 && (n3.is("containerElement") || o3.is("containerElement")) && (Yf2.includes(n3.name) || Yf2.includes(o3.name) ? e4 += "\n" : e4 += "\n\n"), e4 += t5, n3 = o3;
          }
        }
        return e4;
      }
      class Zf2 extends $r {
        static get pluginName() {
          return "ClipboardPipeline";
        }
        init() {
          this.editor.editing.view.addObserver(Kf2), this._setupPasteDrop(), this._setupCopyCut();
        }
        _fireOutputTransformationEvent(t4, e4, n3) {
          const o3 = this.editor.model.getSelectedContent(e4);
          this.fire("outputTransformation", { dataTransfer: t4, content: o3, method: n3 });
        }
        _setupPasteDrop() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, o3 = n3.document;
          this.listenTo(o3, "clipboardInput", (e5, n4) => {
            "paste" != n4.method || t4.model.canEditAt(t4.model.document.selection) || e5.stop();
          }, { priority: "highest" }), this.listenTo(o3, "clipboardInput", (t5, e5) => {
            const o4 = e5.dataTransfer;
            let i3;
            if (e5.content)
              i3 = e5.content;
            else {
              let t6 = "";
              o4.getData("text/html") ? t6 = function(t7) {
                return t7.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t8, e6) => 1 == e6.length ? " " : e6).replace(/<!--[\s\S]*?-->/g, "");
              }(o4.getData("text/html")) : o4.getData("text/plain") && (((r3 = (r3 = o4.getData("text/plain")).replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r?\n\r?\n/g, "</p><p>").replace(/\r?\n/g, "<br>").replace(/\t/g, "&nbsp;&nbsp;&nbsp;&nbsp;").replace(/^\s/, "&nbsp;").replace(/\s$/, "&nbsp;").replace(/\s\s/g, " &nbsp;")).includes("</p><p>") || r3.includes("<br>")) && (r3 = `<p>${r3}</p>`), t6 = r3), i3 = this.editor.data.htmlProcessor.toView(t6);
            }
            var r3;
            const s3 = new p2(this, "inputTransformation");
            this.fire(s3, { content: i3, dataTransfer: o4, targetRanges: e5.targetRanges, method: e5.method }), s3.stop.called && t5.stop(), n3.scrollToTheSelection();
          }, { priority: "low" }), this.listenTo(this, "inputTransformation", (t5, n4) => {
            if (n4.content.isEmpty)
              return;
            const o4 = this.editor.data.toModel(n4.content, "$clipboardHolder");
            0 != o4.childCount && (t5.stop(), e4.change(() => {
              this.fire("contentInsertion", { content: o4, method: n4.method, dataTransfer: n4.dataTransfer, targetRanges: n4.targetRanges });
            }));
          }, { priority: "low" }), this.listenTo(this, "contentInsertion", (t5, n4) => {
            n4.resultRange = e4.insertContent(n4.content);
          }, { priority: "low" });
        }
        _setupCopyCut() {
          const t4 = this.editor, e4 = t4.model.document, n3 = t4.editing.view.document, o3 = (t5, n4) => {
            const o4 = n4.dataTransfer;
            n4.preventDefault(), this._fireOutputTransformationEvent(o4, e4.selection, t5.name);
          };
          this.listenTo(n3, "copy", o3, { priority: "low" }), this.listenTo(n3, "cut", (e5, n4) => {
            t4.model.canEditAt(t4.model.document.selection) ? o3(e5, n4) : n4.preventDefault();
          }, { priority: "low" }), this.listenTo(this, "outputTransformation", (e5, o4) => {
            const i3 = t4.data.toView(o4.content);
            n3.fire("clipboardOutput", { dataTransfer: o4.dataTransfer, content: i3, method: o4.method });
          }, { priority: "low" }), this.listenTo(n3, "clipboardOutput", (n4, o4) => {
            o4.content.isEmpty || (o4.dataTransfer.setData("text/html", this.editor.data.htmlProcessor.toData(o4.content)), o4.dataTransfer.setData("text/plain", $f2(o4.content))), "cut" == o4.method && t4.model.deleteContent(e4.selection);
          }, { priority: "low" });
        }
      }
      class Qf2 {
        constructor(t4, e4 = 20) {
          this._batch = null, this.model = t4, this._size = 0, this.limit = e4, this._isLocked = false, this._changeCallback = (t5, e5) => {
            e5.isLocal && e5.isUndoable && e5 !== this._batch && this._reset(true);
          }, this._selectionChangeCallback = () => {
            this._reset();
          }, this.model.document.on("change", this._changeCallback), this.model.document.selection.on("change:range", this._selectionChangeCallback), this.model.document.selection.on("change:attribute", this._selectionChangeCallback);
        }
        get batch() {
          return this._batch || (this._batch = this.model.createBatch({ isTyping: true })), this._batch;
        }
        get size() {
          return this._size;
        }
        input(t4) {
          this._size += t4, this._size >= this.limit && this._reset(true);
        }
        get isLocked() {
          return this._isLocked;
        }
        lock() {
          this._isLocked = true;
        }
        unlock() {
          this._isLocked = false;
        }
        destroy() {
          this.model.document.off("change", this._changeCallback), this.model.document.selection.off("change:range", this._selectionChangeCallback), this.model.document.selection.off("change:attribute", this._selectionChangeCallback);
        }
        _reset(t4 = false) {
          this.isLocked && !t4 || (this._batch = null, this._size = 0);
        }
      }
      class Jf2 extends Qr {
        constructor(t4, e4) {
          super(t4), this._buffer = new Qf2(t4.model, e4), this._isEnabledBasedOnSelection = false;
        }
        get buffer() {
          return this._buffer;
        }
        destroy() {
          super.destroy(), this._buffer.destroy();
        }
        execute(t4 = {}) {
          const e4 = this.editor.model, n3 = e4.document, o3 = t4.text || "", i3 = o3.length;
          let r3 = n3.selection;
          if (t4.selection ? r3 = t4.selection : t4.range && (r3 = e4.createSelection(t4.range)), !e4.canEditAt(r3))
            return;
          const s3 = t4.resultRange;
          e4.enqueueChange(this._buffer.batch, (t5) => {
            this._buffer.lock(), e4.deleteContent(r3), o3 && e4.insertContent(t5.createText(o3, n3.selection.getAttributes()), r3), s3 ? t5.setSelection(s3) : r3.is("documentSelection") || t5.setSelection(r3), this._buffer.unlock(), this._buffer.input(i3);
          });
        }
      }
      const Xf2 = ["insertText", "insertReplacementText"];
      class tk2 extends Pc2 {
        constructor(t4) {
          super(t4), this.focusObserver = t4.getObserver(_l), a2.isAndroid && Xf2.push("insertCompositionText");
          const e4 = t4.document;
          e4.on("beforeinput", (n3, o3) => {
            if (!this.isEnabled)
              return;
            const { data: i3, targetRanges: r3, inputType: s3, domEvent: a3 } = o3;
            if (!Xf2.includes(s3))
              return;
            this.focusObserver.flush();
            const c3 = new p2(e4, "insertText");
            e4.fire(c3, new Oc2(t4, a3, { text: i3, selection: t4.createSelection(r3) })), c3.stop.called && n3.stop();
          }), e4.on("compositionend", (n3, { data: o3, domEvent: i3 }) => {
            this.isEnabled && !a2.isAndroid && o3 && e4.fire("insertText", new Oc2(t4, i3, { text: o3, selection: e4.selection }));
          }, { priority: "lowest" });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class ek2 extends $r {
        static get pluginName() {
          return "Input";
        }
        init() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, o3 = e4.document.selection;
          n3.addObserver(tk2);
          const i3 = new Jf2(t4, t4.config.get("typing.undoStep") || 20);
          t4.commands.add("insertText", i3), t4.commands.add("input", i3), this.listenTo(n3.document, "insertText", (o4, i4) => {
            n3.document.isComposing || i4.preventDefault();
            const { text: r3, selection: s3, resultRange: c3 } = i4, l3 = Array.from(s3.getRanges()).map((e5) => t4.editing.mapper.toModelRange(e5));
            let d3 = r3;
            if (a2.isAndroid) {
              const t5 = Array.from(l3[0].getItems()).reduce((t6, e5) => t6 + (e5.is("$textProxy") ? e5.data : ""), "");
              t5 && (t5.length <= d3.length ? d3.startsWith(t5) && (d3 = d3.substring(t5.length), l3[0].start = l3[0].start.getShiftedBy(t5.length)) : t5.startsWith(d3) && (l3[0].start = l3[0].start.getShiftedBy(d3.length), d3 = ""));
            }
            const h3 = { text: d3, selection: e4.createSelection(l3) };
            c3 && (h3.resultRange = t4.editing.mapper.toModelRange(c3)), t4.execute("insertText", h3), n3.scrollToTheSelection();
          }), a2.isAndroid ? this.listenTo(n3.document, "keydown", (t5, r3) => {
            !o3.isCollapsed && 229 == r3.keyCode && n3.document.isComposing && nk2(e4, i3);
          }) : this.listenTo(n3.document, "compositionstart", () => {
            o3.isCollapsed || nk2(e4, i3);
          });
        }
      }
      function nk2(t4, e4) {
        if (!e4.isEnabled)
          return;
        const n3 = e4.buffer;
        n3.lock(), t4.enqueueChange(n3.batch, () => {
          t4.deleteContent(t4.document.selection);
        }), n3.unlock();
      }
      class ok2 extends Qr {
        constructor(t4, e4) {
          super(t4), this.direction = e4, this._buffer = new Qf2(t4.model, t4.config.get("typing.undoStep")), this._isEnabledBasedOnSelection = false;
        }
        get buffer() {
          return this._buffer;
        }
        execute(t4 = {}) {
          const e4 = this.editor.model, n3 = e4.document;
          e4.enqueueChange(this._buffer.batch, (o3) => {
            this._buffer.lock();
            const i3 = o3.createSelection(t4.selection || n3.selection);
            if (!e4.canEditAt(i3))
              return;
            const r3 = t4.sequence || 1, s3 = i3.isCollapsed;
            if (i3.isCollapsed && e4.modifySelection(i3, { direction: this.direction, unit: t4.unit, treatEmojiAsSingleUnit: true }), this._shouldEntireContentBeReplacedWithParagraph(r3))
              return void this._replaceEntireContentWithParagraph(o3);
            if (this._shouldReplaceFirstBlockWithParagraph(i3, r3))
              return void this.editor.execute("paragraph", { selection: i3 });
            if (i3.isCollapsed)
              return;
            let a3 = 0;
            i3.getFirstRange().getMinimalFlatRanges().forEach((t5) => {
              a3 += X2(t5.getWalker({ singleCharacters: true, ignoreElementEnd: true, shallow: true }));
            }), e4.deleteContent(i3, { doNotResetEntireContent: s3, direction: this.direction }), this._buffer.input(a3), o3.setSelection(i3), this._buffer.unlock();
          });
        }
        _shouldEntireContentBeReplacedWithParagraph(t4) {
          if (t4 > 1)
            return false;
          const e4 = this.editor.model, n3 = e4.document.selection, o3 = e4.schema.getLimitElement(n3);
          if (!(n3.isCollapsed && n3.containsEntireContent(o3)))
            return false;
          if (!e4.schema.checkChild(o3, "paragraph"))
            return false;
          const i3 = o3.getChild(0);
          return !i3 || !i3.is("element", "paragraph");
        }
        _replaceEntireContentWithParagraph(t4) {
          const e4 = this.editor.model, n3 = e4.document.selection, o3 = e4.schema.getLimitElement(n3), i3 = t4.createElement("paragraph");
          t4.remove(t4.createRangeIn(o3)), t4.insert(i3, o3), t4.setSelection(i3, 0);
        }
        _shouldReplaceFirstBlockWithParagraph(t4, e4) {
          const n3 = this.editor.model;
          if (e4 > 1 || "backward" != this.direction)
            return false;
          if (!t4.isCollapsed)
            return false;
          const o3 = t4.getFirstPosition(), i3 = n3.schema.getLimitElement(o3), r3 = i3.getChild(0);
          return o3.parent == r3 && (!!t4.containsEntireContent(r3) && (!!n3.schema.checkChild(i3, "paragraph") && "paragraph" != r3.name));
        }
      }
      const ik2 = "word", rk2 = "selection", sk2 = "backward", ak2 = "forward", ck2 = { deleteContent: { unit: rk2, direction: sk2 }, deleteContentBackward: { unit: "codePoint", direction: sk2 }, deleteWordBackward: { unit: ik2, direction: sk2 }, deleteHardLineBackward: { unit: rk2, direction: sk2 }, deleteSoftLineBackward: { unit: rk2, direction: sk2 }, deleteContentForward: { unit: "character", direction: ak2 }, deleteWordForward: { unit: ik2, direction: ak2 }, deleteHardLineForward: { unit: rk2, direction: ak2 }, deleteSoftLineForward: { unit: rk2, direction: ak2 } };
      class lk2 extends Pc2 {
        constructor(t4) {
          super(t4);
          const e4 = t4.document;
          let n3 = 0;
          e4.on("keydown", () => {
            n3++;
          }), e4.on("keyup", () => {
            n3 = 0;
          }), e4.on("beforeinput", (o3, i3) => {
            if (!this.isEnabled)
              return;
            const { targetRanges: r3, domEvent: s3, inputType: c3 } = i3, l3 = ck2[c3];
            if (!l3)
              return;
            const d3 = { direction: l3.direction, unit: l3.unit, sequence: n3 };
            d3.unit == rk2 && (d3.selectionToRemove = t4.createSelection(r3[0])), "deleteContentBackward" === c3 && (a2.isAndroid && (d3.sequence = 1), function(t5) {
              if (1 != t5.length || t5[0].isCollapsed)
                return false;
              const e5 = t5[0].getWalker({ direction: "backward", singleCharacters: true, ignoreElementEnd: true });
              let n4 = 0;
              for (const { nextPosition: t6 } of e5) {
                if (t6.parent.is("$text")) {
                  const e6 = t6.parent.data, o4 = t6.offset;
                  if (Ni2(e6, o4) || Pi2(e6, o4) || Oi2(e6, o4))
                    continue;
                  n4++;
                } else
                  n4++;
                if (n4 > 1)
                  return true;
              }
              return false;
            }(r3) && (d3.unit = rk2, d3.selectionToRemove = t4.createSelection(r3)));
            const h3 = new Ma2(e4, "delete", r3[0]);
            e4.fire(h3, new Oc2(t4, s3, d3)), h3.stop.called && o3.stop();
          }), a2.isBlink && function(t5) {
            const e5 = t5.view, n4 = e5.document;
            let o3 = null, i3 = false;
            function r3(t6) {
              return t6 == fi2.backspace || t6 == fi2.delete;
            }
            function s3(t6) {
              return t6 == fi2.backspace ? sk2 : ak2;
            }
            n4.on("keydown", (t6, { keyCode: e6 }) => {
              o3 = e6, i3 = false;
            }), n4.on("keyup", (a3, { keyCode: c3, domEvent: l3 }) => {
              const d3 = n4.selection, h3 = t5.isEnabled && c3 == o3 && r3(c3) && !d3.isCollapsed && !i3;
              if (o3 = null, h3) {
                const t6 = d3.getFirstRange(), o4 = new Ma2(n4, "delete", t6), i4 = { unit: rk2, direction: s3(c3), selectionToRemove: d3 };
                n4.fire(o4, new Oc2(e5, l3, i4));
              }
            }), n4.on("beforeinput", (t6, { inputType: e6 }) => {
              const n5 = ck2[e6];
              r3(o3) && n5 && n5.direction == s3(o3) && (i3 = true);
            }, { priority: "high" }), n4.on("beforeinput", (t6, { inputType: e6, data: n5 }) => {
              o3 == fi2.delete && "insertText" == e6 && "" == n5 && t6.stop();
            }, { priority: "high" });
          }(this);
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class dk2 extends $r {
        static get pluginName() {
          return "Delete";
        }
        init() {
          const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document, o3 = t4.model.document;
          e4.addObserver(lk2), this._undoOnBackspace = false;
          const i3 = new ok2(t4, "forward");
          t4.commands.add("deleteForward", i3), t4.commands.add("forwardDelete", i3), t4.commands.add("delete", new ok2(t4, "backward")), this.listenTo(n3, "delete", (o4, i4) => {
            n3.isComposing || i4.preventDefault();
            const { direction: r3, sequence: s3, selectionToRemove: a3, unit: c3 } = i4, l3 = "forward" === r3 ? "deleteForward" : "delete", d3 = { sequence: s3 };
            if ("selection" == c3) {
              const e5 = Array.from(a3.getRanges()).map((e6) => t4.editing.mapper.toModelRange(e6));
              d3.selection = t4.model.createSelection(e5);
            } else
              d3.unit = c3;
            t4.execute(l3, d3), e4.scrollToTheSelection();
          }, { priority: "low" }), this.editor.plugins.has("UndoEditing") && (this.listenTo(n3, "delete", (e5, n4) => {
            this._undoOnBackspace && "backward" == n4.direction && 1 == n4.sequence && "codePoint" == n4.unit && (this._undoOnBackspace = false, t4.execute("undo"), n4.preventDefault(), e5.stop());
          }, { context: "$capture" }), this.listenTo(o3, "change", () => {
            this._undoOnBackspace = false;
          }));
        }
        requestUndoOnBackspace() {
          this.editor.plugins.has("UndoEditing") && (this._undoOnBackspace = true);
        }
      }
      class hk2 extends $r {
        static get requires() {
          return [ek2, dk2];
        }
        static get pluginName() {
          return "Typing";
        }
      }
      function uk2(t4, e4) {
        let n3 = t4.start;
        return { text: Array.from(t4.getWalker({ ignoreElementEnd: false })).reduce((t5, { item: o3 }) => o3.is("$text") || o3.is("$textProxy") ? t5 + o3.data : (n3 = e4.createPositionAfter(o3), ""), ""), range: e4.createRange(n3, t4.end) };
      }
      class gk2 extends W2() {
        constructor(t4, e4) {
          super(), this.model = t4, this.testCallback = e4, this._hasMatch = false, this.set("isEnabled", true), this.on("change:isEnabled", () => {
            this.isEnabled ? this._startListening() : (this.stopListening(t4.document.selection), this.stopListening(t4.document));
          }), this._startListening();
        }
        get hasMatch() {
          return this._hasMatch;
        }
        _startListening() {
          const t4 = this.model.document;
          this.listenTo(t4.selection, "change:range", (e4, { directChange: n3 }) => {
            n3 && (t4.selection.isCollapsed ? this._evaluateTextBeforeSelection("selection") : this.hasMatch && (this.fire("unmatched"), this._hasMatch = false));
          }), this.listenTo(t4, "change:data", (t5, e4) => {
            !e4.isUndo && e4.isLocal && this._evaluateTextBeforeSelection("data", { batch: e4 });
          });
        }
        _evaluateTextBeforeSelection(t4, e4 = {}) {
          const n3 = this.model, o3 = n3.document.selection, i3 = n3.createRange(n3.createPositionAt(o3.focus.parent, 0), o3.focus), { text: r3, range: s3 } = uk2(i3, n3), a3 = this.testCallback(r3);
          if (!a3 && this.hasMatch && this.fire("unmatched"), this._hasMatch = !!a3, a3) {
            const n4 = Object.assign(e4, { text: r3, range: s3 });
            "object" == typeof a3 && Object.assign(n4, a3), this.fire(`matched:${t4}`, n4);
          }
        }
      }
      class pk2 extends $r {
        constructor(t4) {
          super(t4), this.attributes = /* @__PURE__ */ new Set(), this._overrideUid = null;
        }
        static get pluginName() {
          return "TwoStepCaretMovement";
        }
        init() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, o3 = t4.locale, i3 = e4.document.selection;
          this.listenTo(n3.document, "arrowKey", (t5, e5) => {
            if (!i3.isCollapsed)
              return;
            if (e5.shiftKey || e5.altKey || e5.ctrlKey)
              return;
            const n4 = e5.keyCode == fi2.arrowright, r3 = e5.keyCode == fi2.arrowleft;
            if (!n4 && !r3)
              return;
            const s3 = o3.contentLanguageDirection;
            let a3 = false;
            a3 = "ltr" === s3 && n4 || "rtl" === s3 && r3 ? this._handleForwardMovement(e5) : this._handleBackwardMovement(e5), true === a3 && t5.stop();
          }, { context: "$text", priority: "highest" }), this._isNextGravityRestorationSkipped = false, this.listenTo(i3, "change:range", (t5, e5) => {
            this._isNextGravityRestorationSkipped ? this._isNextGravityRestorationSkipped = false : this._isGravityOverridden && (!e5.directChange && bk2(i3.getFirstPosition(), this.attributes) || this._restoreGravity());
          });
        }
        registerAttribute(t4) {
          this.attributes.add(t4);
        }
        _handleForwardMovement(t4) {
          const e4 = this.attributes, n3 = this.editor.model.document.selection, o3 = n3.getFirstPosition();
          return !this._isGravityOverridden && ((!o3.isAtStart || !mk2(n3, e4)) && (!!bk2(o3, e4) && (kk2(t4), this._overrideGravity(), true)));
        }
        _handleBackwardMovement(t4) {
          const e4 = this.attributes, n3 = this.editor.model, o3 = n3.document.selection, i3 = o3.getFirstPosition();
          return this._isGravityOverridden ? (kk2(t4), this._restoreGravity(), fk2(n3, e4, i3), true) : i3.isAtStart ? !!mk2(o3, e4) && (kk2(t4), fk2(n3, e4, i3), true) : !!function(t5, e5) {
            const n4 = t5.getShiftedBy(-1);
            return bk2(n4, e5);
          }(i3, e4) && (i3.isAtEnd && !mk2(o3, e4) && bk2(i3, e4) ? (kk2(t4), fk2(n3, e4, i3), true) : (this._isNextGravityRestorationSkipped = true, this._overrideGravity(), false));
        }
        get _isGravityOverridden() {
          return !!this._overrideUid;
        }
        _overrideGravity() {
          this._overrideUid = this.editor.model.change((t4) => t4.overrideSelectionGravity());
        }
        _restoreGravity() {
          this.editor.model.change((t4) => {
            t4.restoreSelectionGravity(this._overrideUid), this._overrideUid = null;
          });
        }
      }
      function mk2(t4, e4) {
        for (const n3 of e4)
          if (t4.hasAttribute(n3))
            return true;
        return false;
      }
      function fk2(t4, e4, n3) {
        const o3 = n3.nodeBefore;
        t4.change((n4) => {
          if (o3) {
            const e5 = [], i3 = t4.schema.isObject(o3) && t4.schema.isInline(o3);
            for (const [n5, r3] of o3.getAttributes())
              !t4.schema.checkAttribute("$text", n5) || i3 && false === t4.schema.getAttributeProperties(n5).copyFromObject || e5.push([n5, r3]);
            n4.setSelectionAttribute(e5);
          } else
            n4.removeSelectionAttribute(e4);
        });
      }
      function kk2(t4) {
        t4.preventDefault();
      }
      function bk2(t4, e4) {
        const { nodeBefore: n3, nodeAfter: o3 } = t4;
        for (const t5 of e4) {
          const e5 = n3 ? n3.getAttribute(t5) : void 0;
          if ((o3 ? o3.getAttribute(t5) : void 0) !== e5)
            return true;
        }
        return false;
      }
      const wk2 = { copyright: { from: "(c)", to: "©" }, registeredTrademark: { from: "(r)", to: "®" }, trademark: { from: "(tm)", to: "™" }, oneHalf: { from: /(^|[^/a-z0-9])(1\/2)([^/a-z0-9])$/i, to: [null, "½", null] }, oneThird: { from: /(^|[^/a-z0-9])(1\/3)([^/a-z0-9])$/i, to: [null, "⅓", null] }, twoThirds: { from: /(^|[^/a-z0-9])(2\/3)([^/a-z0-9])$/i, to: [null, "⅔", null] }, oneForth: { from: /(^|[^/a-z0-9])(1\/4)([^/a-z0-9])$/i, to: [null, "¼", null] }, threeQuarters: { from: /(^|[^/a-z0-9])(3\/4)([^/a-z0-9])$/i, to: [null, "¾", null] }, lessThanOrEqual: { from: "<=", to: "≤" }, greaterThanOrEqual: { from: ">=", to: "≥" }, notEqual: { from: "!=", to: "≠" }, arrowLeft: { from: "<-", to: "←" }, arrowRight: { from: "->", to: "→" }, horizontalEllipsis: { from: "...", to: "…" }, enDash: { from: /(^| )(--)( )$/, to: [null, "–", null] }, emDash: { from: /(^| )(---)( )$/, to: [null, "—", null] }, quotesPrimary: { from: xk2('"'), to: [null, "“", null, "”"] }, quotesSecondary: { from: xk2("'"), to: [null, "‘", null, "’"] }, quotesPrimaryEnGb: { from: xk2("'"), to: [null, "‘", null, "’"] }, quotesSecondaryEnGb: { from: xk2('"'), to: [null, "“", null, "”"] }, quotesPrimaryPl: { from: xk2('"'), to: [null, "„", null, "”"] }, quotesSecondaryPl: { from: xk2("'"), to: [null, "‚", null, "’"] } }, Ak2 = { symbols: ["copyright", "registeredTrademark", "trademark"], mathematical: ["oneHalf", "oneThird", "twoThirds", "oneForth", "threeQuarters", "lessThanOrEqual", "greaterThanOrEqual", "notEqual", "arrowLeft", "arrowRight"], typography: ["horizontalEllipsis", "enDash", "emDash"], quotes: ["quotesPrimary", "quotesSecondary"] }, Ck2 = ["symbols", "mathematical", "typography", "quotes"];
      function _k(t4) {
        return "string" == typeof t4 ? new RegExp(`(${rf2(t4)})$`) : t4;
      }
      function vk2(t4) {
        return "string" == typeof t4 ? () => [t4] : t4 instanceof Array ? () => t4 : t4;
      }
      function yk2(t4) {
        return (t4.textNode ? t4.textNode : t4.nodeAfter).getAttributes();
      }
      function xk2(t4) {
        return new RegExp(`(^|\\s)(${t4})([^${t4}]*)(${t4})$`);
      }
      function Ek2(t4, e4, n3, o3) {
        return o3.createRange(Dk2(t4, e4, n3, true, o3), Dk2(t4, e4, n3, false, o3));
      }
      function Dk2(t4, e4, n3, o3, i3) {
        let r3 = t4.textNode || (o3 ? t4.nodeBefore : t4.nodeAfter), s3 = null;
        for (; r3 && r3.getAttribute(e4) == n3; )
          s3 = r3, r3 = o3 ? r3.previousSibling : r3.nextSibling;
        return s3 ? i3.createPositionAt(s3, o3 ? "before" : "after") : t4;
      }
      function* Sk2(t4, e4) {
        for (const n3 of e4)
          n3 && t4.getAttributeProperties(n3[0]).copyOnEnter && (yield n3);
      }
      class Ik2 extends Qr {
        execute() {
          this.editor.model.change((t4) => {
            this.enterBlock(t4), this.fire("afterExecute", { writer: t4 });
          });
        }
        enterBlock(t4) {
          const e4 = this.editor.model, n3 = e4.document.selection, o3 = e4.schema, i3 = n3.isCollapsed, r3 = n3.getFirstRange(), s3 = r3.start.parent, a3 = r3.end.parent;
          if (o3.isLimit(s3) || o3.isLimit(a3))
            return i3 || s3 != a3 || e4.deleteContent(n3), false;
          if (i3) {
            const e5 = Sk2(t4.model.schema, n3.getAttributes());
            return Tk2(t4, r3.start), t4.setSelectionAttribute(e5), true;
          }
          {
            const o4 = !(r3.start.isAtStart && r3.end.isAtEnd), i4 = s3 == a3;
            if (e4.deleteContent(n3, { leaveUnmerged: o4 }), o4) {
              if (i4)
                return Tk2(t4, n3.focus), true;
              t4.setSelection(a3, 0);
            }
          }
          return false;
        }
      }
      function Tk2(t4, e4) {
        t4.split(e4), t4.setSelection(e4.parent.nextSibling, 0);
      }
      const Mk2 = { insertParagraph: { isSoft: false }, insertLineBreak: { isSoft: true } };
      class Bk2 extends Pc2 {
        constructor(t4) {
          super(t4);
          const e4 = this.document;
          let n3 = false;
          e4.on("keydown", (t5, e5) => {
            n3 = e5.shiftKey;
          }), e4.on("beforeinput", (o3, i3) => {
            if (!this.isEnabled)
              return;
            let r3 = i3.inputType;
            a2.isSafari && n3 && "insertParagraph" == r3 && (r3 = "insertLineBreak");
            const s3 = i3.domEvent, c3 = Mk2[r3];
            if (!c3)
              return;
            const l3 = new Ma2(e4, "enter", i3.targetRanges[0]);
            e4.fire(l3, new Oc2(t4, s3, { isSoft: c3.isSoft })), l3.stop.called && o3.stop();
          });
        }
        observe() {
        }
        stopObserving() {
        }
      }
      class Nk2 extends $r {
        static get pluginName() {
          return "Enter";
        }
        init() {
          const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document;
          e4.addObserver(Bk2), t4.commands.add("enter", new Ik2(t4)), this.listenTo(n3, "enter", (o3, i3) => {
            n3.isComposing || i3.preventDefault(), i3.isSoft || (t4.execute("enter"), e4.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class Pk2 extends Qr {
        execute() {
          const t4 = this.editor.model, e4 = t4.document;
          t4.change((n3) => {
            !function(t5, e5, n4) {
              const o3 = n4.isCollapsed, i3 = n4.getFirstRange(), r3 = i3.start.parent, s3 = i3.end.parent, a3 = r3 == s3;
              if (o3) {
                const o4 = Sk2(t5.schema, n4.getAttributes());
                zk2(t5, e5, i3.end), e5.removeSelectionAttribute(n4.getAttributeKeys()), e5.setSelectionAttribute(o4);
              } else {
                const o4 = !(i3.start.isAtStart && i3.end.isAtEnd);
                t5.deleteContent(n4, { leaveUnmerged: o4 }), a3 ? zk2(t5, e5, n4.focus) : o4 && e5.setSelection(s3, 0);
              }
            }(t4, n3, e4.selection), this.fire("afterExecute", { writer: n3 });
          });
        }
        refresh() {
          const t4 = this.editor.model, e4 = t4.document;
          this.isEnabled = function(t5, e5) {
            if (e5.rangeCount > 1)
              return false;
            const n3 = e5.anchor;
            if (!n3 || !t5.checkChild(n3, "softBreak"))
              return false;
            const o3 = e5.getFirstRange(), i3 = o3.start.parent, r3 = o3.end.parent;
            if ((Ok2(i3, t5) || Ok2(r3, t5)) && i3 !== r3)
              return false;
            return true;
          }(t4.schema, e4.selection);
        }
      }
      function zk2(t4, e4, n3) {
        const o3 = e4.createElement("softBreak");
        t4.insertContent(o3, n3), e4.setSelection(o3, "after");
      }
      function Ok2(t4, e4) {
        return !t4.is("rootElement") && (e4.isLimit(t4) || Ok2(t4.parent, e4));
      }
      class Lk2 extends $r {
        static get pluginName() {
          return "ShiftEnter";
        }
        init() {
          const t4 = this.editor, e4 = t4.model.schema, n3 = t4.conversion, o3 = t4.editing.view, i3 = o3.document;
          e4.register("softBreak", { allowWhere: "$text", isInline: true }), n3.for("upcast").elementToElement({ model: "softBreak", view: "br" }), n3.for("downcast").elementToElement({ model: "softBreak", view: (t5, { writer: e5 }) => e5.createEmptyElement("br") }), o3.addObserver(Bk2), t4.commands.add("shiftEnter", new Pk2(t4)), this.listenTo(i3, "enter", (e5, n4) => {
            i3.isComposing || n4.preventDefault(), n4.isSoft && (t4.execute("shiftEnter"), o3.scrollToTheSelection());
          }, { priority: "low" });
        }
      }
      class jk2 extends M2() {
        constructor() {
          super(...arguments), this._stack = [];
        }
        add(t4, e4) {
          const n3 = this._stack, o3 = n3[0];
          this._insertDescriptor(t4);
          const i3 = n3[0];
          o3 === i3 || Rk2(o3, i3) || this.fire("change:top", { oldDescriptor: o3, newDescriptor: i3, writer: e4 });
        }
        remove(t4, e4) {
          const n3 = this._stack, o3 = n3[0];
          this._removeDescriptor(t4);
          const i3 = n3[0];
          o3 === i3 || Rk2(o3, i3) || this.fire("change:top", { oldDescriptor: o3, newDescriptor: i3, writer: e4 });
        }
        _insertDescriptor(t4) {
          const e4 = this._stack, n3 = e4.findIndex((e5) => e5.id === t4.id);
          if (Rk2(t4, e4[n3]))
            return;
          n3 > -1 && e4.splice(n3, 1);
          let o3 = 0;
          for (; e4[o3] && Fk2(e4[o3], t4); )
            o3++;
          e4.splice(o3, 0, t4);
        }
        _removeDescriptor(t4) {
          const e4 = this._stack, n3 = e4.findIndex((e5) => e5.id === t4);
          n3 > -1 && e4.splice(n3, 1);
        }
      }
      function Rk2(t4, e4) {
        return t4 && e4 && t4.priority == e4.priority && Vk2(t4.classes) == Vk2(e4.classes);
      }
      function Fk2(t4, e4) {
        return t4.priority > e4.priority || !(t4.priority < e4.priority) && Vk2(t4.classes) > Vk2(e4.classes);
      }
      function Vk2(t4) {
        return Array.isArray(t4) ? t4.sort().join(",") : t4;
      }
      const Hk2 = '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z"/><path fill-opacity=".256" d="M1 1h14v14H1z"/><g class="ck-icon__selected-indicator"><path d="M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z"/><path fill-opacity=".254" d="M1 1h14v14H1z"/></g></svg>', Uk2 = "ck-widget", qk2 = "ck-widget_selected";
      function Gk2(t4) {
        return !!t4.is("element") && !!t4.getCustomProperty("widget");
      }
      function Wk2(t4, e4, n3 = {}) {
        if (!t4.is("containerElement"))
          throw new A2("widget-to-widget-wrong-element-type", null, { element: t4 });
        return e4.setAttribute("contenteditable", "false", t4), e4.addClass(Uk2, t4), e4.setCustomProperty("widget", true, t4), t4.getFillerOffset = Jk2, e4.setCustomProperty("widgetLabel", [], t4), n3.label && function(t5, e5) {
          const n4 = t5.getCustomProperty("widgetLabel");
          n4.push(e5);
        }(t4, n3.label), n3.hasSelectionHandle && function(t5, e5) {
          const n4 = e5.createUIElement("div", { class: "ck ck-widget__selection-handle" }, function(t6) {
            const e6 = this.toDomElement(t6), n5 = new pr();
            return n5.set("content", Hk2), n5.render(), e6.appendChild(n5.element), e6;
          });
          e5.insert(e5.createPositionAt(t5, 0), n4), e5.addClass(["ck-widget_with-selection-handle"], t5);
        }(t4, e4), $k2(t4, e4), t4;
      }
      function Kk2(t4, e4, n3) {
        if (e4.classes && n3.addClass(_i(e4.classes), t4), e4.attributes)
          for (const o3 in e4.attributes)
            n3.setAttribute(o3, e4.attributes[o3], t4);
      }
      function Yk2(t4, e4, n3) {
        if (e4.classes && n3.removeClass(_i(e4.classes), t4), e4.attributes)
          for (const o3 in e4.attributes)
            n3.removeAttribute(o3, t4);
      }
      function $k2(t4, e4, n3 = Kk2, o3 = Yk2) {
        const i3 = new jk2();
        i3.on("change:top", (e5, i4) => {
          i4.oldDescriptor && o3(t4, i4.oldDescriptor, i4.writer), i4.newDescriptor && n3(t4, i4.newDescriptor, i4.writer);
        });
        e4.setCustomProperty("addHighlight", (t5, e5, n4) => i3.add(e5, n4), t4), e4.setCustomProperty("removeHighlight", (t5, e5, n4) => i3.remove(e5, n4), t4);
      }
      function Zk2(t4, e4, n3 = {}) {
        return e4.addClass(["ck-editor__editable", "ck-editor__nested-editable"], t4), e4.setAttribute("role", "textbox", t4), n3.label && e4.setAttribute("aria-label", n3.label, t4), e4.setAttribute("contenteditable", t4.isReadOnly ? "false" : "true", t4), t4.on("change:isReadOnly", (n4, o3, i3) => {
          e4.setAttribute("contenteditable", i3 ? "false" : "true", t4);
        }), t4.on("change:isFocused", (n4, o3, i3) => {
          i3 ? e4.addClass("ck-editor__nested-editable_focused", t4) : e4.removeClass("ck-editor__nested-editable_focused", t4);
        }), $k2(t4, e4), t4;
      }
      function Qk2(t4, e4) {
        const n3 = t4.getSelectedElement();
        if (n3) {
          const o3 = eb2(t4);
          if (o3)
            return e4.createRange(e4.createPositionAt(n3, o3));
        }
        return mg2(t4, e4);
      }
      function Jk2() {
        return null;
      }
      const Xk2 = "widget-type-around";
      function tb2(t4, e4, n3) {
        return !!t4 && Gk2(t4) && !n3.isInline(e4);
      }
      function eb2(t4) {
        return t4.getAttribute(Xk2);
      }
      var nb2 = n2(4921), ob2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(nb2.Z, ob2);
      nb2.Z.locals;
      const ib2 = ["before", "after"], rb2 = new DOMParser().parseFromString('<svg viewBox="0 0 10 8" xmlns="http://www.w3.org/2000/svg"><path d="M9.055.263v3.972h-6.77M1 4.216l2-2.038m-2 2 2 2.038"/></svg>', "image/svg+xml").firstChild, sb2 = "ck-widget__type-around_disabled";
      class ab2 extends $r {
        constructor() {
          super(...arguments), this._currentFakeCaretModelElement = null;
        }
        static get pluginName() {
          return "WidgetTypeAround";
        }
        static get requires() {
          return [Nk2, dk2];
        }
        init() {
          const t4 = this.editor, e4 = t4.editing.view;
          this.on("change:isEnabled", (n3, o3, i3) => {
            e4.change((t5) => {
              for (const n4 of e4.document.roots)
                i3 ? t5.removeClass(sb2, n4) : t5.addClass(sb2, n4);
            }), i3 || t4.model.change((t5) => {
              t5.removeSelectionAttribute(Xk2);
            });
          }), this._enableTypeAroundUIInjection(), this._enableInsertingParagraphsOnButtonClick(), this._enableInsertingParagraphsOnEnterKeypress(), this._enableInsertingParagraphsOnTypingKeystroke(), this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows(), this._enableDeleteIntegration(), this._enableInsertContentIntegration(), this._enableInsertObjectIntegration(), this._enableDeleteContentIntegration();
        }
        destroy() {
          super.destroy(), this._currentFakeCaretModelElement = null;
        }
        _insertParagraph(t4, e4) {
          const n3 = this.editor, o3 = n3.editing.view, i3 = n3.model.schema.getAttributesWithProperty(t4, "copyOnReplace", true);
          n3.execute("insertParagraph", { position: n3.model.createPositionAt(t4, e4), attributes: i3 }), o3.focus(), o3.scrollToTheSelection();
        }
        _listenToIfEnabled(t4, e4, n3, o3) {
          this.listenTo(t4, e4, (...t5) => {
            this.isEnabled && n3(...t5);
          }, o3);
        }
        _insertParagraphAccordingToFakeCaretPosition() {
          const t4 = this.editor.model.document.selection, e4 = eb2(t4);
          if (!e4)
            return false;
          const n3 = t4.getSelectedElement();
          return this._insertParagraph(n3, e4), true;
        }
        _enableTypeAroundUIInjection() {
          const t4 = this.editor, e4 = t4.model.schema, n3 = t4.locale.t, o3 = { before: n3("Insert paragraph before block"), after: n3("Insert paragraph after block") };
          t4.editing.downcastDispatcher.on("insert", (t5, i3, r3) => {
            const s3 = r3.mapper.toViewElement(i3.item);
            if (s3 && tb2(s3, i3.item, e4)) {
              !function(t6, e5, n4) {
                const o4 = t6.createUIElement("div", { class: "ck ck-reset_all ck-widget__type-around" }, function(t7) {
                  const n5 = this.toDomElement(t7);
                  return function(t8, e6) {
                    for (const n6 of ib2) {
                      const o5 = new Ui2({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__button", `ck-widget__type-around__button_${n6}`], title: e6[n6], "aria-hidden": "true" }, children: [t8.ownerDocument.importNode(rb2, true)] });
                      t8.appendChild(o5.render());
                    }
                  }(n5, e5), function(t8) {
                    const e6 = new Ui2({ tag: "div", attributes: { class: ["ck", "ck-widget__type-around__fake-caret"] } });
                    t8.appendChild(e6.render());
                  }(n5), n5;
                });
                t6.insert(t6.createPositionAt(n4, "end"), o4);
              }(r3.writer, o3, s3);
              s3.getCustomProperty("widgetLabel").push(() => this.isEnabled ? n3("Press Enter to type after or press Shift + Enter to type before the widget") : "");
            }
          }, { priority: "low" });
        }
        _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
          const t4 = this.editor, e4 = t4.model, n3 = e4.document.selection, o3 = e4.schema, i3 = t4.editing.view;
          function r3(t5) {
            return `ck-widget_type-around_show-fake-caret_${t5}`;
          }
          this._listenToIfEnabled(i3.document, "arrowKey", (t5, e5) => {
            this._handleArrowKeyPress(t5, e5);
          }, { context: [Gk2, "$text"], priority: "high" }), this._listenToIfEnabled(n3, "change:range", (e5, n4) => {
            n4.directChange && t4.model.change((t5) => {
              t5.removeSelectionAttribute(Xk2);
            });
          }), this._listenToIfEnabled(e4.document, "change:data", () => {
            const e5 = n3.getSelectedElement();
            if (e5) {
              if (tb2(t4.editing.mapper.toViewElement(e5), e5, o3))
                return;
            }
            t4.model.change((t5) => {
              t5.removeSelectionAttribute(Xk2);
            });
          }), this._listenToIfEnabled(t4.editing.downcastDispatcher, "selection", (t5, e5, n4) => {
            const i4 = n4.writer;
            if (this._currentFakeCaretModelElement) {
              const t6 = n4.mapper.toViewElement(this._currentFakeCaretModelElement);
              t6 && (i4.removeClass(ib2.map(r3), t6), this._currentFakeCaretModelElement = null);
            }
            const s3 = e5.selection.getSelectedElement();
            if (!s3)
              return;
            const a3 = n4.mapper.toViewElement(s3);
            if (!tb2(a3, s3, o3))
              return;
            const c3 = eb2(e5.selection);
            c3 && (i4.addClass(r3(c3), a3), this._currentFakeCaretModelElement = s3);
          }), this._listenToIfEnabled(t4.ui.focusTracker, "change:isFocused", (e5, n4, o4) => {
            o4 || t4.model.change((t5) => {
              t5.removeSelectionAttribute(Xk2);
            });
          });
        }
        _handleArrowKeyPress(t4, e4) {
          const n3 = this.editor, o3 = n3.model, i3 = o3.document.selection, r3 = o3.schema, s3 = n3.editing.view, a3 = function(t5, e5) {
            const n4 = Ci2(t5, e5);
            return "down" === n4 || "right" === n4;
          }(e4.keyCode, n3.locale.contentLanguageDirection), c3 = s3.document.selection.getSelectedElement();
          let l3;
          tb2(c3, n3.editing.mapper.toModelElement(c3), r3) ? l3 = this._handleArrowKeyPressOnSelectedWidget(a3) : i3.isCollapsed ? l3 = this._handleArrowKeyPressWhenSelectionNextToAWidget(a3) : e4.shiftKey || (l3 = this._handleArrowKeyPressWhenNonCollapsedSelection(a3)), l3 && (e4.preventDefault(), t4.stop());
        }
        _handleArrowKeyPressOnSelectedWidget(t4) {
          const e4 = this.editor.model, n3 = eb2(e4.document.selection);
          return e4.change((e5) => {
            if (!n3)
              return e5.setSelectionAttribute(Xk2, t4 ? "after" : "before"), true;
            if (!(n3 === (t4 ? "after" : "before")))
              return e5.removeSelectionAttribute(Xk2), true;
            return false;
          });
        }
        _handleArrowKeyPressWhenSelectionNextToAWidget(t4) {
          const e4 = this.editor, n3 = e4.model, o3 = n3.schema, i3 = e4.plugins.get("Widget"), r3 = i3._getObjectElementNextToSelection(t4);
          return !!tb2(e4.editing.mapper.toViewElement(r3), r3, o3) && (n3.change((e5) => {
            i3._setSelectionOverElement(r3), e5.setSelectionAttribute(Xk2, t4 ? "before" : "after");
          }), true);
        }
        _handleArrowKeyPressWhenNonCollapsedSelection(t4) {
          const e4 = this.editor, n3 = e4.model, o3 = n3.schema, i3 = e4.editing.mapper, r3 = n3.document.selection, s3 = t4 ? r3.getLastPosition().nodeBefore : r3.getFirstPosition().nodeAfter;
          return !!tb2(i3.toViewElement(s3), s3, o3) && (n3.change((e5) => {
            e5.setSelection(s3, "on"), e5.setSelectionAttribute(Xk2, t4 ? "after" : "before");
          }), true);
        }
        _enableInsertingParagraphsOnButtonClick() {
          const t4 = this.editor, e4 = t4.editing.view;
          this._listenToIfEnabled(e4.document, "mousedown", (n3, o3) => {
            const i3 = o3.domTarget.closest(".ck-widget__type-around__button");
            if (!i3)
              return;
            const r3 = function(t5) {
              return t5.classList.contains("ck-widget__type-around__button_before") ? "before" : "after";
            }(i3), s3 = function(t5, e5) {
              const n4 = t5.closest(".ck-widget");
              return e5.mapDomToView(n4);
            }(i3, e4.domConverter), a3 = t4.editing.mapper.toModelElement(s3);
            this._insertParagraph(a3, r3), o3.preventDefault(), n3.stop();
          });
        }
        _enableInsertingParagraphsOnEnterKeypress() {
          const t4 = this.editor, e4 = t4.model.document.selection, n3 = t4.editing.view;
          this._listenToIfEnabled(n3.document, "enter", (n4, o3) => {
            if ("atTarget" != n4.eventPhase)
              return;
            const i3 = e4.getSelectedElement(), r3 = t4.editing.mapper.toViewElement(i3), s3 = t4.model.schema;
            let a3;
            this._insertParagraphAccordingToFakeCaretPosition() ? a3 = true : tb2(r3, i3, s3) && (this._insertParagraph(i3, o3.isSoft ? "before" : "after"), a3 = true), a3 && (o3.preventDefault(), n4.stop());
          }, { context: Gk2 });
        }
        _enableInsertingParagraphsOnTypingKeystroke() {
          const t4 = this.editor.editing.view.document;
          this._listenToIfEnabled(t4, "insertText", (e4, n3) => {
            this._insertParagraphAccordingToFakeCaretPosition() && (n3.selection = t4.selection);
          }, { priority: "high" }), a2.isAndroid ? this._listenToIfEnabled(t4, "keydown", (t5, e4) => {
            229 == e4.keyCode && this._insertParagraphAccordingToFakeCaretPosition();
          }) : this._listenToIfEnabled(t4, "compositionstart", () => {
            this._insertParagraphAccordingToFakeCaretPosition();
          }, { priority: "high" });
        }
        _enableDeleteIntegration() {
          const t4 = this.editor, e4 = t4.editing.view, n3 = t4.model, o3 = n3.schema;
          this._listenToIfEnabled(e4.document, "delete", (e5, i3) => {
            if ("atTarget" != e5.eventPhase)
              return;
            const r3 = eb2(n3.document.selection);
            if (!r3)
              return;
            const s3 = i3.direction, a3 = n3.document.selection.getSelectedElement(), c3 = "forward" == s3;
            if ("before" === r3 === c3)
              t4.execute("delete", { selection: n3.createSelection(a3, "on") });
            else {
              const e6 = o3.getNearestSelectionRange(n3.createPositionAt(a3, r3), s3);
              if (e6)
                if (e6.isCollapsed) {
                  const i4 = n3.createSelection(e6.start);
                  if (n3.modifySelection(i4, { direction: s3 }), i4.focus.isEqual(e6.start)) {
                    const t5 = function(t6, e7) {
                      let n4 = e7;
                      for (const o4 of e7.getAncestors({ parentFirst: true })) {
                        if (o4.childCount > 1 || t6.isLimit(o4))
                          break;
                        n4 = o4;
                      }
                      return n4;
                    }(o3, e6.start.parent);
                    n3.deleteContent(n3.createSelection(t5, "on"), { doNotAutoparagraph: true });
                  } else
                    n3.change((n4) => {
                      n4.setSelection(e6), t4.execute(c3 ? "deleteForward" : "delete");
                    });
                } else
                  n3.change((n4) => {
                    n4.setSelection(e6), t4.execute(c3 ? "deleteForward" : "delete");
                  });
            }
            i3.preventDefault(), e5.stop();
          }, { context: Gk2 });
        }
        _enableInsertContentIntegration() {
          const t4 = this.editor, e4 = this.editor.model, n3 = e4.document.selection;
          this._listenToIfEnabled(t4.model, "insertContent", (t5, [o3, i3]) => {
            if (i3 && !i3.is("documentSelection"))
              return;
            const r3 = eb2(n3);
            return r3 ? (t5.stop(), e4.change((t6) => {
              const i4 = n3.getSelectedElement(), s3 = e4.createPositionAt(i4, r3), a3 = t6.createSelection(s3), c3 = e4.insertContent(o3, a3);
              return t6.setSelection(a3), c3;
            })) : void 0;
          }, { priority: "high" });
        }
        _enableInsertObjectIntegration() {
          const t4 = this.editor, e4 = this.editor.model.document.selection;
          this._listenToIfEnabled(t4.model, "insertObject", (t5, n3) => {
            const [, o3, i3 = {}] = n3;
            if (o3 && !o3.is("documentSelection"))
              return;
            const r3 = eb2(e4);
            r3 && (i3.findOptimalPosition = r3, n3[3] = i3);
          }, { priority: "high" });
        }
        _enableDeleteContentIntegration() {
          const t4 = this.editor, e4 = this.editor.model.document.selection;
          this._listenToIfEnabled(t4.model, "deleteContent", (t5, [n3]) => {
            if (n3 && !n3.is("documentSelection"))
              return;
            eb2(e4) && t5.stop();
          }, { priority: "high" });
        }
      }
      function cb2(t4) {
        const e4 = t4.model;
        return (n3, o3) => {
          const i3 = o3.keyCode == fi2.arrowup, r3 = o3.keyCode == fi2.arrowdown, s3 = o3.shiftKey, a3 = e4.document.selection;
          if (!i3 && !r3)
            return;
          const c3 = r3;
          if (s3 && function(t5, e5) {
            return !t5.isCollapsed && t5.isBackward == e5;
          }(a3, c3))
            return;
          const l3 = function(t5, e5, n4) {
            const o4 = t5.model;
            if (n4) {
              const t6 = e5.isCollapsed ? e5.focus : e5.getLastPosition(), n5 = lb2(o4, t6, "forward");
              if (!n5)
                return null;
              const i4 = o4.createRange(t6, n5), r4 = db2(o4.schema, i4, "backward");
              return r4 ? o4.createRange(t6, r4) : null;
            }
            {
              const t6 = e5.isCollapsed ? e5.focus : e5.getFirstPosition(), n5 = lb2(o4, t6, "backward");
              if (!n5)
                return null;
              const i4 = o4.createRange(n5, t6), r4 = db2(o4.schema, i4, "forward");
              return r4 ? o4.createRange(r4, t6) : null;
            }
          }(t4, a3, c3);
          if (l3) {
            if (l3.isCollapsed) {
              if (a3.isCollapsed)
                return;
              if (s3)
                return;
            }
            (l3.isCollapsed || function(t5, e5, n4) {
              const o4 = t5.model, i4 = t5.view.domConverter;
              if (n4) {
                const t6 = o4.createSelection(e5.start);
                o4.modifySelection(t6), t6.focus.isAtEnd || e5.start.isEqual(t6.focus) || (e5 = o4.createRange(t6.focus, e5.end));
              }
              const r4 = t5.mapper.toViewRange(e5), s4 = i4.viewRangeToDom(r4), a4 = Vo2.getDomRangeRects(s4);
              let c4;
              for (const t6 of a4)
                if (void 0 !== c4) {
                  if (Math.round(t6.top) >= c4)
                    return false;
                  c4 = Math.max(c4, Math.round(t6.bottom));
                } else
                  c4 = Math.round(t6.bottom);
              return true;
            }(t4, l3, c3)) && (e4.change((t5) => {
              const n4 = c3 ? l3.end : l3.start;
              if (s3) {
                const o4 = e4.createSelection(a3.anchor);
                o4.setFocus(n4), t5.setSelection(o4);
              } else
                t5.setSelection(n4);
            }), n3.stop(), o3.preventDefault(), o3.stopPropagation());
          }
        };
      }
      function lb2(t4, e4, n3) {
        const o3 = t4.schema, i3 = t4.createRangeIn(e4.root), r3 = "forward" == n3 ? "elementStart" : "elementEnd";
        for (const { previousPosition: t5, item: s3, type: a3 } of i3.getWalker({ startPosition: e4, direction: n3 })) {
          if (o3.isLimit(s3) && !o3.isInline(s3))
            return t5;
          if (a3 == r3 && o3.isBlock(s3))
            return null;
        }
        return null;
      }
      function db2(t4, e4, n3) {
        const o3 = "backward" == n3 ? e4.end : e4.start;
        if (t4.checkChild(o3, "$text"))
          return o3;
        for (const { nextPosition: o4 } of e4.getWalker({ direction: n3 }))
          if (t4.checkChild(o4, "$text"))
            return o4;
        return null;
      }
      var hb2 = n2(3488), ub2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(hb2.Z, ub2);
      hb2.Z.locals;
      class gb2 extends $r {
        constructor() {
          super(...arguments), this._previouslySelected = /* @__PURE__ */ new Set();
        }
        static get pluginName() {
          return "Widget";
        }
        static get requires() {
          return [ab2, dk2];
        }
        init() {
          const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document;
          this.editor.editing.downcastDispatcher.on("selection", (e5, n4, o3) => {
            const i3 = o3.writer, r3 = n4.selection;
            if (r3.isCollapsed)
              return;
            const s3 = r3.getSelectedElement();
            if (!s3)
              return;
            const a3 = t4.editing.mapper.toViewElement(s3);
            var c3;
            Gk2(a3) && (o3.consumable.consume(r3, "selection") && i3.setSelection(i3.createRangeOn(a3), { fake: true, label: (c3 = a3, c3.getCustomProperty("widgetLabel").reduce((t5, e6) => "function" == typeof e6 ? t5 ? t5 + ". " + e6() : e6() : t5 ? t5 + ". " + e6 : e6, "")) }));
          }), this.editor.editing.downcastDispatcher.on("selection", (t5, e5, n4) => {
            this._clearPreviouslySelectedWidgets(n4.writer);
            const o3 = n4.writer, i3 = o3.document.selection;
            let r3 = null;
            for (const t6 of i3.getRanges())
              for (const e6 of t6) {
                const t7 = e6.item;
                Gk2(t7) && !pb2(t7, r3) && (o3.addClass(qk2, t7), this._previouslySelected.add(t7), r3 = t7);
              }
          }, { priority: "low" }), e4.addObserver(xg2), this.listenTo(n3, "mousedown", (...t5) => this._onMousedown(...t5)), this.listenTo(n3, "arrowKey", (...t5) => {
            this._handleSelectionChangeOnArrowKeyPress(...t5);
          }, { context: [Gk2, "$text"] }), this.listenTo(n3, "arrowKey", (...t5) => {
            this._preventDefaultOnArrowKeyPress(...t5);
          }, { context: "$root" }), this.listenTo(n3, "arrowKey", cb2(this.editor.editing), { context: "$text" }), this.listenTo(n3, "delete", (t5, e5) => {
            this._handleDelete("forward" == e5.direction) && (e5.preventDefault(), t5.stop());
          }, { context: "$root" });
        }
        _onMousedown(t4, e4) {
          const n3 = this.editor, o3 = n3.editing.view, i3 = o3.document;
          let r3 = e4.target;
          if (function(t5) {
            let e5 = t5;
            for (; e5; ) {
              if (e5.is("editableElement") && !e5.is("rootElement"))
                return true;
              if (Gk2(e5))
                return false;
              e5 = e5.parent;
            }
            return false;
          }(r3)) {
            if ((a2.isSafari || a2.isGecko) && e4.domEvent.detail >= 3) {
              const t5 = n3.editing.mapper, o4 = r3.is("attributeElement") ? r3.findAncestor((t6) => !t6.is("attributeElement")) : r3, i4 = t5.toModelElement(o4);
              e4.preventDefault(), this.editor.model.change((t6) => {
                t6.setSelection(i4, "in");
              });
            }
            return;
          }
          if (!Gk2(r3) && (r3 = r3.findAncestor(Gk2), !r3))
            return;
          a2.isAndroid && e4.preventDefault(), i3.isFocused || o3.focus();
          const s3 = n3.editing.mapper.toModelElement(r3);
          this._setSelectionOverElement(s3);
        }
        _handleSelectionChangeOnArrowKeyPress(t4, e4) {
          const n3 = e4.keyCode, o3 = this.editor.model, i3 = o3.schema, r3 = o3.document.selection, s3 = r3.getSelectedElement(), a3 = Ci2(n3, this.editor.locale.contentLanguageDirection), c3 = "down" == a3 || "right" == a3, l3 = "up" == a3 || "down" == a3;
          if (s3 && i3.isObject(s3)) {
            const n4 = c3 ? r3.getLastPosition() : r3.getFirstPosition(), s4 = i3.getNearestSelectionRange(n4, c3 ? "forward" : "backward");
            return void (s4 && (o3.change((t5) => {
              t5.setSelection(s4);
            }), e4.preventDefault(), t4.stop()));
          }
          if (!r3.isCollapsed && !e4.shiftKey) {
            const n4 = r3.getFirstPosition(), s4 = r3.getLastPosition(), a4 = n4.nodeAfter, l4 = s4.nodeBefore;
            return void ((a4 && i3.isObject(a4) || l4 && i3.isObject(l4)) && (o3.change((t5) => {
              t5.setSelection(c3 ? s4 : n4);
            }), e4.preventDefault(), t4.stop()));
          }
          if (!r3.isCollapsed)
            return;
          const d3 = this._getObjectElementNextToSelection(c3);
          if (d3 && i3.isObject(d3)) {
            if (i3.isInline(d3) && l3)
              return;
            this._setSelectionOverElement(d3), e4.preventDefault(), t4.stop();
          }
        }
        _preventDefaultOnArrowKeyPress(t4, e4) {
          const n3 = this.editor.model, o3 = n3.schema, i3 = n3.document.selection.getSelectedElement();
          i3 && o3.isObject(i3) && (e4.preventDefault(), t4.stop());
        }
        _handleDelete(t4) {
          const e4 = this.editor.model.document.selection;
          if (!this.editor.model.canEditAt(e4))
            return;
          if (!e4.isCollapsed)
            return;
          const n3 = this._getObjectElementNextToSelection(t4);
          return n3 ? (this.editor.model.change((t5) => {
            let o3 = e4.anchor.parent;
            for (; o3.isEmpty; ) {
              const e5 = o3;
              o3 = e5.parent, t5.remove(e5);
            }
            this._setSelectionOverElement(n3);
          }), true) : void 0;
        }
        _setSelectionOverElement(t4) {
          this.editor.model.change((e4) => {
            e4.setSelection(e4.createRangeOn(t4));
          });
        }
        _getObjectElementNextToSelection(t4) {
          const e4 = this.editor.model, n3 = e4.schema, o3 = e4.document.selection, i3 = e4.createSelection(o3);
          if (e4.modifySelection(i3, { direction: t4 ? "forward" : "backward" }), i3.isEqual(o3))
            return null;
          const r3 = t4 ? i3.focus.nodeBefore : i3.focus.nodeAfter;
          return r3 && n3.isObject(r3) ? r3 : null;
        }
        _clearPreviouslySelectedWidgets(t4) {
          for (const e4 of this._previouslySelected)
            t4.removeClass(qk2, e4);
          this._previouslySelected.clear();
        }
      }
      function pb2(t4, e4) {
        return !!e4 && Array.from(t4.getAncestors()).includes(e4);
      }
      class mb2 extends $r {
        constructor() {
          super(...arguments), this._toolbarDefinitions = /* @__PURE__ */ new Map();
        }
        static get requires() {
          return [Wm];
        }
        static get pluginName() {
          return "WidgetToolbarRepository";
        }
        init() {
          const t4 = this.editor;
          if (t4.plugins.has("BalloonToolbar")) {
            const e4 = t4.plugins.get("BalloonToolbar");
            this.listenTo(e4, "show", (e5) => {
              (function(t5) {
                const e6 = t5.getSelectedElement();
                return !(!e6 || !Gk2(e6));
              })(t4.editing.view.document.selection) && e5.stop();
            }, { priority: "high" });
          }
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this.on("change:isEnabled", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(t4.ui, "update", () => {
            this._updateToolbarsVisibility();
          }), this.listenTo(t4.ui.focusTracker, "change:isFocused", () => {
            this._updateToolbarsVisibility();
          }, { priority: "low" });
        }
        destroy() {
          super.destroy();
          for (const t4 of this._toolbarDefinitions.values())
            t4.view.destroy();
        }
        register(t4, { ariaLabel: e4, items: n3, getRelatedElement: o3, balloonClassName: i3 = "ck-toolbar-container" }) {
          if (!n3.length)
            return void C2("widget-toolbar-no-items", { toolbarId: t4 });
          const r3 = this.editor, s3 = r3.t, a3 = new Lg2(r3.locale);
          if (a3.ariaLabel = e4 || s3("Widget toolbar"), this._toolbarDefinitions.has(t4))
            throw new A2("widget-toolbar-duplicated", this, { toolbarId: t4 });
          const c3 = { view: a3, getRelatedElement: o3, balloonClassName: i3, itemsConfig: n3, initialized: false };
          r3.ui.addToolbar(a3, { isContextual: true, beforeFocus: () => {
            const t5 = o3(r3.editing.view.document.selection);
            t5 && this._showToolbar(c3, t5);
          }, afterBlur: () => {
            this._hideToolbar(c3);
          } }), this._toolbarDefinitions.set(t4, c3);
        }
        _updateToolbarsVisibility() {
          let t4 = 0, e4 = null, n3 = null;
          for (const o3 of this._toolbarDefinitions.values()) {
            const i3 = o3.getRelatedElement(this.editor.editing.view.document.selection);
            if (this.isEnabled && i3)
              if (this.editor.ui.focusTracker.isFocused) {
                const r3 = i3.getAncestors().length;
                r3 > t4 && (t4 = r3, e4 = i3, n3 = o3);
              } else
                this._isToolbarVisible(o3) && this._hideToolbar(o3);
            else
              this._isToolbarInBalloon(o3) && this._hideToolbar(o3);
          }
          n3 && this._showToolbar(n3, e4);
        }
        _hideToolbar(t4) {
          this._balloon.remove(t4.view), this.stopListening(this._balloon, "change:visibleView");
        }
        _showToolbar(t4, e4) {
          this._isToolbarVisible(t4) ? fb2(this.editor, e4) : this._isToolbarInBalloon(t4) || (t4.initialized || (t4.initialized = true, t4.view.fillFromConfig(t4.itemsConfig, this.editor.ui.componentFactory)), this._balloon.add({ view: t4.view, position: kb2(this.editor, e4), balloonClassName: t4.balloonClassName }), this.listenTo(this._balloon, "change:visibleView", () => {
            for (const t5 of this._toolbarDefinitions.values())
              if (this._isToolbarVisible(t5)) {
                const e5 = t5.getRelatedElement(this.editor.editing.view.document.selection);
                fb2(this.editor, e5);
              }
          }));
        }
        _isToolbarVisible(t4) {
          return this._balloon.visibleView === t4.view;
        }
        _isToolbarInBalloon(t4) {
          return this._balloon.hasView(t4.view);
        }
      }
      function fb2(t4, e4) {
        const n3 = t4.plugins.get("ContextualBalloon"), o3 = kb2(t4, e4);
        n3.updatePosition(o3);
      }
      function kb2(t4, e4) {
        const n3 = t4.editing.view, o3 = em.defaultPositions;
        return { target: n3.domConverter.mapViewToDom(e4), positions: [o3.northArrowSouth, o3.northArrowSouthWest, o3.northArrowSouthEast, o3.southArrowNorth, o3.southArrowNorthWest, o3.southArrowNorthEast, o3.viewportStickyNorth] };
      }
      var bb2 = n2(8506), wb2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(bb2.Z, wb2);
      bb2.Z.locals;
      const Ab2 = $o2("px");
      class Cb2 extends Hi2 {
        constructor() {
          super();
          const t4 = this.bindTemplate;
          this.set({ isVisible: false, left: null, top: null, width: null }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-clipboard-drop-target-line", t4.if("isVisible", "ck-hidden", (t5) => !t5)], style: { left: t4.to("left", (t5) => Ab2(t5)), top: t4.to("top", (t5) => Ab2(t5)), width: t4.to("width", (t5) => Ab2(t5)) } } });
        }
      }
      class _b extends $r {
        constructor() {
          super(...arguments), this.removeDropMarkerDelayed = Bi2(() => this.removeDropMarker(), 40), this._updateDropMarkerThrottled = dm((t4) => this._updateDropMarker(t4), 40), this._reconvertMarkerThrottled = dm(() => {
            this.editor.model.markers.has("drop-target") && this.editor.editing.reconvertMarker("drop-target");
          }, 0), this._dropTargetLineView = new Cb2(), this._domEmitter = new (Mo2())(), this._scrollables = /* @__PURE__ */ new Map();
        }
        static get pluginName() {
          return "DragDropTarget";
        }
        init() {
          this._setupDropMarker();
        }
        destroy() {
          this._domEmitter.stopListening();
          for (const { resizeObserver: t4 } of this._scrollables.values())
            t4.destroy();
          return this._updateDropMarkerThrottled.cancel(), this.removeDropMarkerDelayed.cancel(), this._reconvertMarkerThrottled.cancel(), super.destroy();
        }
        updateDropMarker(t4, e4, n3, o3, i3) {
          this.removeDropMarkerDelayed.cancel();
          const r3 = vb2(this.editor, t4, e4, n3, o3, i3);
          r3 && this._updateDropMarkerThrottled(r3);
        }
        getFinalDropRange(t4, e4, n3, o3, i3) {
          const r3 = vb2(this.editor, t4, e4, n3, o3, i3);
          return this.removeDropMarker(), r3;
        }
        removeDropMarker() {
          const t4 = this.editor.model;
          this.removeDropMarkerDelayed.cancel(), this._updateDropMarkerThrottled.cancel(), this._dropTargetLineView.isVisible = false, t4.markers.has("drop-target") && t4.change((t5) => {
            t5.removeMarker("drop-target");
          });
        }
        _setupDropMarker() {
          const t4 = this.editor;
          t4.ui.view.body.add(this._dropTargetLineView), t4.conversion.for("editingDowncast").markerToHighlight({ model: "drop-target", view: { classes: ["ck-clipboard-drop-target-range"] } }), t4.conversion.for("editingDowncast").markerToElement({ model: "drop-target", view: (e4, { writer: n3 }) => {
            if (t4.model.schema.checkChild(e4.markerRange.start, "$text"))
              return this._dropTargetLineView.isVisible = false, this._createDropTargetPosition(n3);
            e4.markerRange.isCollapsed ? this._updateDropTargetLine(e4.markerRange) : this._dropTargetLineView.isVisible = false;
          } });
        }
        _updateDropMarker(t4) {
          const e4 = this.editor, n3 = e4.model.markers;
          e4.model.change((e5) => {
            n3.has("drop-target") ? n3.get("drop-target").getRange().isEqual(t4) || e5.updateMarker("drop-target", { range: t4 }) : e5.addMarker("drop-target", { range: t4, usingOperation: false, affectsData: false });
          });
        }
        _createDropTargetPosition(t4) {
          return t4.createUIElement("span", { class: "ck ck-clipboard-drop-target-position" }, function(t5) {
            const e4 = this.toDomElement(t5);
            return e4.append("⁠", t5.createElement("span"), "⁠"), e4;
          });
        }
        _updateDropTargetLine(t4) {
          const e4 = this.editor.editing, n3 = t4.start.nodeBefore, o3 = t4.start.nodeAfter, i3 = t4.start.parent, r3 = n3 ? e4.mapper.toViewElement(n3) : null, s3 = r3 ? e4.view.domConverter.mapViewToDom(r3) : null, a3 = o3 ? e4.mapper.toViewElement(o3) : null, c3 = a3 ? e4.view.domConverter.mapViewToDom(a3) : null, l3 = e4.mapper.toViewElement(i3), d3 = e4.view.domConverter.mapViewToDom(l3), h3 = this._getScrollableRect(l3), { scrollX: u3, scrollY: g3 } = zo2.window, p3 = s3 ? new Vo2(s3) : null, m3 = c3 ? new Vo2(c3) : null, f3 = new Vo2(d3).excludeScrollbarsAndBorders(), k3 = p3 ? p3.bottom : f3.top, b3 = m3 ? m3.top : f3.bottom, w3 = zo2.window.getComputedStyle(d3), A3 = k3 <= b3 ? (k3 + b3) / 2 : b3;
          if (h3.top < A3 && A3 < h3.bottom) {
            const t5 = f3.left + parseFloat(w3.paddingLeft), e5 = f3.right - parseFloat(w3.paddingRight), n4 = Math.max(t5 + u3, h3.left), o4 = Math.min(e5 + u3, h3.right);
            this._dropTargetLineView.set({ isVisible: true, left: n4, top: A3 + g3, width: o4 - n4 });
          } else
            this._dropTargetLineView.isVisible = false;
        }
        _getScrollableRect(t4) {
          const e4 = t4.root.rootName;
          let n3;
          if (this._scrollables.has(e4))
            n3 = this._scrollables.get(e4).domElement;
          else {
            n3 = function(t5) {
              let e5 = t5;
              do {
                e5 = e5.parentElement;
                const t6 = zo2.window.getComputedStyle(e5).overflowY;
                if ("auto" == t6 || "scroll" == t6)
                  break;
              } while ("BODY" != e5.tagName);
              return e5;
            }(this.editor.editing.view.domConverter.mapViewToDom(t4)), this._domEmitter.listenTo(n3, "scroll", this._reconvertMarkerThrottled, { usePassive: true });
            const o3 = new Ko2(n3, this._reconvertMarkerThrottled);
            this._scrollables.set(e4, { domElement: n3, resizeObserver: o3 });
          }
          return new Vo2(n3).excludeScrollbarsAndBorders();
        }
      }
      function vb2(t4, e4, n3, o3, i3, r3) {
        const s3 = t4.model, a3 = t4.editing.mapper;
        let c3 = Db2(t4, e4);
        for (; c3; ) {
          if (!r3) {
            if (s3.schema.checkChild(c3, "$text")) {
              const e5 = n3 ? n3[0].start : null, r4 = e5 ? a3.toModelPosition(e5) : null;
              if (r4) {
                if (s3.schema.checkChild(r4, "$text"))
                  return s3.createRange(r4);
                if (e5)
                  return xb2(t4, Db2(t4, e5.parent), o3, i3);
              }
            } else if (s3.schema.isInline(c3))
              return xb2(t4, c3, o3, i3);
          }
          if (s3.schema.isBlock(c3))
            return xb2(t4, c3, o3, i3);
          if (s3.schema.checkChild(c3, "$block")) {
            const e5 = Array.from(c3.getChildren()).filter((e6) => e6.is("element") && !yb2(t4, e6));
            let n4 = 0, r4 = e5.length;
            if (0 == r4)
              return s3.createRange(s3.createPositionAt(c3, "end"));
            for (; n4 < r4 - 1; ) {
              const s4 = Math.floor((n4 + r4) / 2);
              "before" == Eb2(t4, e5[s4], o3, i3) ? r4 = s4 : n4 = s4;
            }
            return xb2(t4, e5[n4], o3, i3);
          }
          c3 = c3.parent;
        }
        return null;
      }
      function yb2(t4, e4) {
        const n3 = t4.editing.mapper, o3 = t4.editing.view.domConverter, i3 = n3.toViewElement(e4), r3 = o3.mapViewToDom(i3);
        return "none" != zo2.window.getComputedStyle(r3).float;
      }
      function xb2(t4, e4, n3, o3) {
        const i3 = t4.model;
        return i3.createRange(i3.createPositionAt(e4, Eb2(t4, e4, n3, o3)));
      }
      function Eb2(t4, e4, n3, o3) {
        const i3 = t4.editing.mapper, r3 = t4.editing.view.domConverter, s3 = i3.toViewElement(e4), a3 = r3.mapViewToDom(s3), c3 = new Vo2(a3);
        return t4.model.schema.isInline(e4) ? n3 < (c3.left + c3.right) / 2 ? "before" : "after" : o3 < (c3.top + c3.bottom) / 2 ? "before" : "after";
      }
      function Db2(t4, e4) {
        const n3 = t4.editing.mapper, o3 = t4.editing.view, i3 = n3.toModelElement(e4);
        if (i3)
          return i3;
        const r3 = o3.createPositionBefore(e4), s3 = n3.findMappedViewAncestor(r3);
        return n3.toModelElement(s3);
      }
      var Sb2 = Object.defineProperty, Ib2 = Object.defineProperties, Tb2 = Object.getOwnPropertyDescriptors, Mb = Object.getOwnPropertySymbols, Bb2 = Object.prototype.hasOwnProperty, Nb2 = Object.prototype.propertyIsEnumerable, Pb2 = (t4, e4, n3) => e4 in t4 ? Sb2(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3;
      class zb2 extends $r {
        constructor() {
          super(...arguments), this._isBlockDragging = false, this._domEmitter = new (Mo2())();
        }
        static get pluginName() {
          return "DragDropBlockToolbar";
        }
        init() {
          const t4 = this.editor;
          if (this.listenTo(t4, "change:isReadOnly", (t5, e4, n3) => {
            n3 ? (this.forceDisabled("readOnlyMode"), this._isBlockDragging = false) : this.clearForceDisabled("readOnlyMode");
          }), a2.isAndroid && this.forceDisabled("noAndroidSupport"), t4.plugins.has("BlockToolbar")) {
            const e4 = t4.plugins.get("BlockToolbar").buttonView.element;
            this._domEmitter.listenTo(e4, "dragstart", (t5, e5) => this._handleBlockDragStart(e5)), this._domEmitter.listenTo(zo2.document, "dragover", (t5, e5) => this._handleBlockDragging(e5)), this._domEmitter.listenTo(zo2.document, "drop", (t5, e5) => this._handleBlockDragging(e5)), this._domEmitter.listenTo(zo2.document, "dragend", () => this._handleBlockDragEnd(), { useCapture: true }), this.isEnabled && e4.setAttribute("draggable", "true"), this.on("change:isEnabled", (t5, n3, o3) => {
              e4.setAttribute("draggable", o3 ? "true" : "false");
            });
          }
        }
        destroy() {
          return this._domEmitter.stopListening(), super.destroy();
        }
        _handleBlockDragStart(t4) {
          if (!this.isEnabled)
            return;
          const e4 = this.editor.model, n3 = e4.document.selection, o3 = this.editor.editing.view, i3 = Array.from(n3.getSelectedBlocks()), r3 = e4.createRange(e4.createPositionBefore(i3[0]), e4.createPositionAfter(i3[i3.length - 1]));
          e4.change((t5) => t5.setSelection(r3)), this._isBlockDragging = true, o3.focus(), o3.getObserver(Kf2).onDomEvent(t4);
        }
        _handleBlockDragging(t4) {
          if (!this.isEnabled || !this._isBlockDragging)
            return;
          const e4 = t4.clientX + ("ltr" == this.editor.locale.contentLanguageDirection ? 100 : -100), n3 = t4.clientY, o3 = document.elementFromPoint(e4, n3), i3 = this.editor.editing.view;
          var r3, s3;
          o3 && o3.closest(".ck-editor__editable") && i3.getObserver(Kf2).onDomEvent((r3 = ((t5, e5) => {
            for (var n4 in e5 || (e5 = {}))
              Bb2.call(e5, n4) && Pb2(t5, n4, e5[n4]);
            if (Mb)
              for (var n4 of Mb(e5))
                Nb2.call(e5, n4) && Pb2(t5, n4, e5[n4]);
            return t5;
          })({}, t4), s3 = { type: t4.type, dataTransfer: t4.dataTransfer, target: o3, clientX: e4, clientY: n3, preventDefault: () => t4.preventDefault(), stopPropagation: () => t4.stopPropagation() }, Ib2(r3, Tb2(s3))));
        }
        _handleBlockDragEnd() {
          this._isBlockDragging = false;
        }
      }
      var Ob2 = n2(903), Lb2 = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Ob2.Z, Lb2);
      Ob2.Z.locals;
      class jb2 extends $r {
        constructor() {
          super(...arguments), this._clearDraggableAttributesDelayed = Bi2(() => this._clearDraggableAttributes(), 40), this._blockMode = false, this._domEmitter = new (Mo2())();
        }
        static get pluginName() {
          return "DragDrop";
        }
        static get requires() {
          return [Zf2, gb2, _b, zb2];
        }
        init() {
          const t4 = this.editor, e4 = t4.editing.view;
          this._draggedRange = null, this._draggingUid = "", this._draggableElement = null, e4.addObserver(Kf2), e4.addObserver(xg2), this._setupDragging(), this._setupContentInsertionIntegration(), this._setupClipboardInputIntegration(), this._setupDraggableAttributeHandling(), this.listenTo(t4, "change:isReadOnly", (t5, e5, n3) => {
            n3 ? this.forceDisabled("readOnlyMode") : this.clearForceDisabled("readOnlyMode");
          }), this.on("change:isEnabled", (t5, e5, n3) => {
            n3 || this._finalizeDragging(false);
          }), a2.isAndroid && this.forceDisabled("noAndroidSupport");
        }
        destroy() {
          return this._draggedRange && (this._draggedRange.detach(), this._draggedRange = null), this._previewContainer && this._previewContainer.remove(), this._domEmitter.stopListening(), this._clearDraggableAttributesDelayed.cancel(), super.destroy();
        }
        _setupDragging() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, o3 = n3.document, i3 = t4.plugins.get(_b);
          this.listenTo(o3, "dragstart", (t5, n4) => {
            if (n4.target && n4.target.is("editableElement"))
              return void n4.preventDefault();
            if (this._prepareDraggedRange(n4.target), !this._draggedRange)
              return void n4.preventDefault();
            this._draggingUid = f2(), n4.dataTransfer.effectAllowed = this.isEnabled ? "copyMove" : "copy", n4.dataTransfer.setData("application/ckeditor5-dragging-uid", this._draggingUid);
            const o4 = e4.createSelection(this._draggedRange.toRange());
            this.editor.plugins.get("ClipboardPipeline")._fireOutputTransformationEvent(n4.dataTransfer, o4, "dragstart");
            const { dataTransfer: i4, domTarget: r3, domEvent: s3 } = n4, { clientX: a3 } = s3;
            this._updatePreview({ dataTransfer: i4, domTarget: r3, clientX: a3 }), n4.stopPropagation(), this.isEnabled || (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
          }, { priority: "low" }), this.listenTo(o3, "dragend", (t5, e5) => {
            this._finalizeDragging(!e5.dataTransfer.isCanceled && "move" == e5.dataTransfer.dropEffect);
          }, { priority: "low" }), this._domEmitter.listenTo(zo2.document, "dragend", () => {
            this._blockMode = false;
          }, { useCapture: true }), this.listenTo(o3, "dragenter", () => {
            this.isEnabled && n3.focus();
          }), this.listenTo(o3, "dragleave", () => {
            i3.removeDropMarkerDelayed();
          }), this.listenTo(o3, "dragging", (t5, e5) => {
            if (!this.isEnabled)
              return void (e5.dataTransfer.dropEffect = "none");
            const { clientX: n4, clientY: o4 } = e5.domEvent;
            i3.updateDropMarker(e5.target, e5.targetRanges, n4, o4, this._blockMode), this._draggedRange || (e5.dataTransfer.dropEffect = "copy"), a2.isGecko || ("copy" == e5.dataTransfer.effectAllowed ? e5.dataTransfer.dropEffect = "copy" : ["all", "copyMove"].includes(e5.dataTransfer.effectAllowed) && (e5.dataTransfer.dropEffect = "move")), t5.stop();
          }, { priority: "low" });
        }
        _setupClipboardInputIntegration() {
          const t4 = this.editor, e4 = t4.editing.view.document, n3 = t4.plugins.get(_b);
          this.listenTo(e4, "clipboardInput", (e5, o3) => {
            if ("drop" != o3.method)
              return;
            const { clientX: i3, clientY: r3 } = o3.domEvent, s3 = n3.getFinalDropRange(o3.target, o3.targetRanges, i3, r3, this._blockMode);
            if (!s3)
              return this._finalizeDragging(false), void e5.stop();
            this._draggedRange && this._draggingUid != o3.dataTransfer.getData("application/ckeditor5-dragging-uid") && (this._draggedRange.detach(), this._draggedRange = null, this._draggingUid = "");
            if ("move" == Rb2(o3.dataTransfer) && this._draggedRange && this._draggedRange.containsRange(s3, true))
              return this._finalizeDragging(false), void e5.stop();
            o3.targetRanges = [t4.editing.mapper.toViewRange(s3)];
          }, { priority: "high" });
        }
        _setupContentInsertionIntegration() {
          const t4 = this.editor.plugins.get(Zf2);
          t4.on("contentInsertion", (t5, e4) => {
            if (!this.isEnabled || "drop" !== e4.method)
              return;
            const n3 = e4.targetRanges.map((t6) => this.editor.editing.mapper.toModelRange(t6));
            this.editor.model.change((t6) => t6.setSelection(n3));
          }, { priority: "high" }), t4.on("contentInsertion", (t5, e4) => {
            if (!this.isEnabled || "drop" !== e4.method)
              return;
            const n3 = "move" == Rb2(e4.dataTransfer), o3 = !e4.resultRange || !e4.resultRange.isCollapsed;
            this._finalizeDragging(o3 && n3);
          }, { priority: "lowest" });
        }
        _setupDraggableAttributeHandling() {
          const t4 = this.editor, e4 = t4.editing.view, n3 = e4.document;
          this.listenTo(n3, "mousedown", (o3, i3) => {
            if (a2.isAndroid || !i3)
              return;
            this._clearDraggableAttributesDelayed.cancel();
            let r3 = Fb2(i3.target);
            if (a2.isBlink && !t4.isReadOnly && !r3 && !n3.selection.isCollapsed) {
              const t5 = n3.selection.getSelectedElement();
              t5 && Gk2(t5) || (r3 = n3.selection.editableElement);
            }
            r3 && (e4.change((t5) => {
              t5.setAttribute("draggable", "true", r3);
            }), this._draggableElement = t4.editing.mapper.toModelElement(r3));
          }), this.listenTo(n3, "mouseup", () => {
            a2.isAndroid || this._clearDraggableAttributesDelayed();
          });
        }
        _clearDraggableAttributes() {
          const t4 = this.editor.editing;
          t4.view.change((e4) => {
            this._draggableElement && "$graveyard" != this._draggableElement.root.rootName && e4.removeAttribute("draggable", t4.mapper.toViewElement(this._draggableElement)), this._draggableElement = null;
          });
        }
        _finalizeDragging(t4) {
          const e4 = this.editor, n3 = e4.model;
          if (e4.plugins.get(_b).removeDropMarker(), this._clearDraggableAttributes(), e4.plugins.has("WidgetToolbarRepository")) {
            e4.plugins.get("WidgetToolbarRepository").clearForceDisabled("dragDrop");
          }
          this._draggingUid = "", this._previewContainer && (this._previewContainer.remove(), this._previewContainer = void 0), this._draggedRange && (t4 && this.isEnabled && n3.change((t5) => {
            const e5 = n3.createSelection(this._draggedRange);
            n3.deleteContent(e5, { doNotAutoparagraph: true });
            const o3 = e5.getFirstPosition().parent;
            o3.isEmpty && !n3.schema.checkChild(o3, "$text") && n3.schema.checkChild(o3, "paragraph") && t5.insertElement("paragraph", o3, 0);
          }), this._draggedRange.detach(), this._draggedRange = null);
        }
        _prepareDraggedRange(t4) {
          const e4 = this.editor, n3 = e4.model, o3 = n3.document.selection, i3 = t4 ? Fb2(t4) : null;
          if (i3) {
            const t5 = e4.editing.mapper.toModelElement(i3);
            if (this._draggedRange = md2.fromRange(n3.createRangeOn(t5)), this._blockMode = n3.schema.isBlock(t5), e4.plugins.has("WidgetToolbarRepository")) {
              e4.plugins.get("WidgetToolbarRepository").forceDisabled("dragDrop");
            }
            return;
          }
          if (o3.isCollapsed && !o3.getFirstPosition().parent.isEmpty)
            return;
          const r3 = Array.from(o3.getSelectedBlocks()), s3 = o3.getFirstRange();
          if (0 == r3.length)
            return void (this._draggedRange = md2.fromRange(s3));
          const a3 = Vb2(n3, r3);
          if (r3.length > 1)
            this._draggedRange = md2.fromRange(a3), this._blockMode = true;
          else if (1 == r3.length) {
            const t5 = s3.start.isTouching(a3.start) && s3.end.isTouching(a3.end);
            this._draggedRange = md2.fromRange(t5 ? a3 : s3), this._blockMode = t5;
          }
          n3.change((t5) => t5.setSelection(this._draggedRange.toRange()));
        }
        _updatePreview({ dataTransfer: t4, domTarget: e4, clientX: n3 }) {
          const o3 = this.editor.editing.view, i3 = o3.document.selection.editableElement, r3 = o3.domConverter.mapViewToDom(i3), s3 = zo2.window.getComputedStyle(r3);
          this._previewContainer ? this._previewContainer.firstElementChild && this._previewContainer.removeChild(this._previewContainer.firstElementChild) : (this._previewContainer = bt2(zo2.document, "div", { style: "position: fixed; left: -999999px;" }), zo2.document.body.appendChild(this._previewContainer));
          const c3 = new Vo2(r3);
          if (r3.contains(e4))
            return;
          const l3 = parseFloat(s3.paddingLeft), d3 = bt2(zo2.document, "div");
          d3.className = "ck ck-content", d3.style.width = s3.width, d3.style.paddingLeft = `${c3.left - n3 + l3}px`, a2.isiOS && (d3.style.backgroundColor = "white"), d3.innerHTML = t4.getData("text/html"), t4.setDragImage(d3, 0, 0), this._previewContainer.appendChild(d3);
        }
      }
      function Rb2(t4) {
        return a2.isGecko ? t4.dropEffect : ["all", "copyMove"].includes(t4.effectAllowed) ? "move" : "copy";
      }
      function Fb2(t4) {
        if (t4.is("editableElement"))
          return null;
        if (t4.hasClass("ck-widget__selection-handle"))
          return t4.findAncestor(Gk2);
        if (Gk2(t4))
          return t4;
        const e4 = t4.findAncestor((t5) => Gk2(t5) || t5.is("editableElement"));
        return Gk2(e4) ? e4 : null;
      }
      function Vb2(t4, e4) {
        const n3 = e4[0], o3 = e4[e4.length - 1], i3 = n3.getCommonAncestor(o3), r3 = t4.createPositionBefore(n3), s3 = t4.createPositionAfter(o3);
        if (i3 && i3.is("element") && !t4.schema.isLimit(i3)) {
          const e5 = t4.createRangeOn(i3), n4 = r3.isTouching(e5.start), o4 = s3.isTouching(e5.end);
          if (n4 && o4)
            return Vb2(t4, [i3]);
        }
        return t4.createRange(r3, s3);
      }
      class Hb2 extends $r {
        static get pluginName() {
          return "PastePlainText";
        }
        static get requires() {
          return [Zf2];
        }
        init() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, o3 = n3.document, i3 = e4.document.selection;
          let r3 = false;
          n3.addObserver(Kf2), this.listenTo(o3, "keydown", (t5, e5) => {
            r3 = e5.shiftKey;
          }), t4.plugins.get(Zf2).on("contentInsertion", (t5, n4) => {
            (r3 || function(t6, e5) {
              if (t6.childCount > 1)
                return false;
              const n5 = t6.getChild(0);
              if (e5.isObject(n5))
                return false;
              return 0 == Array.from(n5.getAttributeKeys()).length;
            }(n4.content, e4.schema)) && e4.change((t6) => {
              const o4 = Array.from(i3.getAttributes()).filter(([t7]) => e4.schema.getAttributeProperties(t7).isFormatting);
              i3.isCollapsed || e4.deleteContent(i3, { doNotAutoparagraph: true }), o4.push(...i3.getAttributes());
              const r4 = t6.createRangeIn(n4.content);
              for (const e5 of r4.getItems())
                e5.is("$textProxy") && t6.setAttributes(o4, e5);
            });
          });
        }
      }
      class Ub2 extends $r {
        static get pluginName() {
          return "Clipboard";
        }
        static get requires() {
          return [Zf2, jb2, Hb2];
        }
      }
      class qb2 extends Qr {
        constructor(t4) {
          super(t4), this.affectsData = false;
        }
        execute() {
          const t4 = this.editor.model, e4 = t4.document.selection;
          let n3 = t4.schema.getLimitElement(e4);
          if (e4.containsEntireContent(n3) || !Gb2(t4.schema, n3))
            do {
              if (n3 = n3.parent, !n3)
                return;
            } while (!Gb2(t4.schema, n3));
          t4.change((t5) => {
            t5.setSelection(n3, "in");
          });
        }
      }
      function Gb2(t4, e4) {
        return t4.isLimit(e4) && (t4.checkChild(e4, "$text") || t4.checkChild(e4, "paragraph"));
      }
      const Wb2 = wi2("Ctrl+A");
      class Kb2 extends $r {
        static get pluginName() {
          return "SelectAllEditing";
        }
        init() {
          const t4 = this.editor, e4 = t4.editing.view.document;
          t4.commands.add("selectAll", new qb2(t4)), this.listenTo(e4, "keydown", (e5, n3) => {
            bi2(n3) === Wb2 && (t4.execute("selectAll"), n3.preventDefault());
          });
        }
      }
      class Yb2 extends $r {
        static get pluginName() {
          return "SelectAllUI";
        }
        init() {
          const t4 = this.editor;
          t4.ui.componentFactory.add("selectAll", (e4) => {
            const n3 = t4.commands.get("selectAll"), o3 = new br(e4), i3 = e4.t;
            return o3.set({ label: i3("Select all"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z"/></svg>', keystroke: "Ctrl+A", tooltip: true }), o3.bind("isEnabled").to(n3, "isEnabled"), this.listenTo(o3, "execute", () => {
              t4.execute("selectAll"), t4.editing.view.focus();
            }), o3;
          });
        }
      }
      class $b2 extends $r {
        static get requires() {
          return [Kb2, Yb2];
        }
        static get pluginName() {
          return "SelectAll";
        }
      }
      var Zb2 = Object.defineProperty, Qb2 = Object.getOwnPropertySymbols, Jb2 = Object.prototype.hasOwnProperty, Xb2 = Object.prototype.propertyIsEnumerable, tw = (t4, e4, n3) => e4 in t4 ? Zb2(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3;
      class ew extends Qr {
        constructor(t4) {
          super(t4), this._stack = [], this._createdBatches = /* @__PURE__ */ new WeakSet(), this.refresh(), this._isEnabledBasedOnSelection = false, this.listenTo(t4.data, "set", (t5, e4) => {
            e4[1] = ((t6, e5) => {
              for (var n4 in e5 || (e5 = {}))
                Jb2.call(e5, n4) && tw(t6, n4, e5[n4]);
              if (Qb2)
                for (var n4 of Qb2(e5))
                  Xb2.call(e5, n4) && tw(t6, n4, e5[n4]);
              return t6;
            })({}, e4[1]);
            const n3 = e4[1];
            n3.batchType || (n3.batchType = { isUndoable: false });
          }, { priority: "high" }), this.listenTo(t4.data, "set", (t5, e4) => {
            e4[1].batchType.isUndoable || this.clearStack();
          });
        }
        refresh() {
          this.isEnabled = this._stack.length > 0;
        }
        get createdBatches() {
          return this._createdBatches;
        }
        addBatch(t4) {
          const e4 = this.editor.model.document.selection, n3 = { ranges: e4.hasOwnRange ? Array.from(e4.getRanges()) : [], isBackward: e4.isBackward };
          this._stack.push({ batch: t4, selection: n3 }), this.refresh();
        }
        clearStack() {
          this._stack = [], this.refresh();
        }
        _restoreSelection(t4, e4, n3) {
          const o3 = this.editor.model, i3 = o3.document, r3 = [], s3 = t4.map((t5) => t5.getTransformedByOperations(n3)), a3 = s3.flat();
          for (const t5 of s3) {
            const e5 = t5.filter((t6) => t6.root != i3.graveyard).filter((t6) => !ow(t6, a3));
            e5.length && (nw(e5), r3.push(e5[0]));
          }
          r3.length && o3.change((t5) => {
            t5.setSelection(r3, { backward: e4 });
          });
        }
        _undo(t4, e4) {
          const n3 = this.editor.model, o3 = n3.document;
          this._createdBatches.add(e4);
          const i3 = t4.operations.slice().filter((t5) => t5.isDocumentOperation);
          i3.reverse();
          for (const t5 of i3) {
            const i4 = t5.baseVersion + 1, r3 = Array.from(o3.history.getOperations(i4)), s3 = au([t5.getReversed()], r3, { useRelations: true, document: this.editor.model.document, padWithNoOps: false, forceWeakRemove: true }).operationsA;
            for (let i5 of s3) {
              const r4 = i5.affectedSelectable;
              r4 && !n3.canEditAt(r4) && (i5 = new Qh2(i5.baseVersion)), e4.addOperation(i5), n3.applyOperation(i5), o3.history.setOperationAsUndone(t5, i5);
            }
          }
        }
      }
      function nw(t4) {
        t4.sort((t5, e4) => t5.start.isBefore(e4.start) ? -1 : 1);
        for (let e4 = 1; e4 < t4.length; e4++) {
          const n3 = t4[e4 - 1].getJoined(t4[e4], true);
          n3 && (e4--, t4.splice(e4, 2, n3));
        }
      }
      function ow(t4, e4) {
        return e4.some((e5) => e5 !== t4 && e5.containsRange(t4, true));
      }
      class iw extends ew {
        execute(t4 = null) {
          const e4 = t4 ? this._stack.findIndex((e5) => e5.batch == t4) : this._stack.length - 1, n3 = this._stack.splice(e4, 1)[0], o3 = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(o3, () => {
            this._undo(n3.batch, o3);
            const t5 = this.editor.model.document.history.getOperations(n3.batch.baseVersion);
            this._restoreSelection(n3.selection.ranges, n3.selection.isBackward, t5);
          }), this.fire("revert", n3.batch, o3), this.refresh();
        }
      }
      class rw extends ew {
        execute() {
          const t4 = this._stack.pop(), e4 = this.editor.model.createBatch({ isUndo: true });
          this.editor.model.enqueueChange(e4, () => {
            const n3 = t4.batch.operations[t4.batch.operations.length - 1].baseVersion + 1, o3 = this.editor.model.document.history.getOperations(n3);
            this._restoreSelection(t4.selection.ranges, t4.selection.isBackward, o3), this._undo(t4.batch, e4);
          }), this.refresh();
        }
      }
      class sw extends $r {
        constructor() {
          super(...arguments), this._batchRegistry = /* @__PURE__ */ new WeakSet();
        }
        static get pluginName() {
          return "UndoEditing";
        }
        init() {
          const t4 = this.editor;
          this._undoCommand = new iw(t4), this._redoCommand = new rw(t4), t4.commands.add("undo", this._undoCommand), t4.commands.add("redo", this._redoCommand), this.listenTo(t4.model, "applyOperation", (t5, e4) => {
            const n3 = e4[0];
            if (!n3.isDocumentOperation)
              return;
            const o3 = n3.batch, i3 = this._redoCommand.createdBatches.has(o3), r3 = this._undoCommand.createdBatches.has(o3);
            this._batchRegistry.has(o3) || (this._batchRegistry.add(o3), o3.isUndoable && (i3 ? this._undoCommand.addBatch(o3) : r3 || (this._undoCommand.addBatch(o3), this._redoCommand.clearStack())));
          }, { priority: "highest" }), this.listenTo(this._undoCommand, "revert", (t5, e4, n3) => {
            this._redoCommand.addBatch(n3);
          }), t4.keystrokes.set("CTRL+Z", "undo"), t4.keystrokes.set("CTRL+Y", "redo"), t4.keystrokes.set("CTRL+SHIFT+Z", "redo");
        }
      }
      const aw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m5.042 9.367 2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z"/></svg>', cw = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m14.958 9.367-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z"/></svg>';
      class lw extends $r {
        static get pluginName() {
          return "UndoUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.locale, n3 = t4.t, o3 = "ltr" == e4.uiLanguageDirection ? aw : cw, i3 = "ltr" == e4.uiLanguageDirection ? cw : aw;
          this._addButton("undo", n3("Undo"), "CTRL+Z", o3), this._addButton("redo", n3("Redo"), "CTRL+Y", i3);
        }
        _addButton(t4, e4, n3, o3) {
          const i3 = this.editor;
          i3.ui.componentFactory.add(t4, (r3) => {
            const s3 = i3.commands.get(t4), a3 = new br(r3);
            return a3.set({ label: e4, icon: o3, keystroke: n3, tooltip: true }), a3.bind("isEnabled").to(s3, "isEnabled"), this.listenTo(a3, "execute", () => {
              i3.execute(t4), i3.editing.view.focus();
            }), a3;
          });
        }
      }
      class dw extends $r {
        static get requires() {
          return [sw, lw];
        }
        static get pluginName() {
          return "Undo";
        }
      }
      class hw extends W2() {
        constructor() {
          super();
          const t4 = new window.FileReader();
          this._reader = t4, this._data = void 0, this.set("loaded", 0), t4.onprogress = (t5) => {
            this.loaded = t5.loaded;
          };
        }
        get error() {
          return this._reader.error;
        }
        get data() {
          return this._data;
        }
        read(t4) {
          const e4 = this._reader;
          return this.total = t4.size, new Promise((n3, o3) => {
            e4.onload = () => {
              const t5 = e4.result;
              this._data = t5, n3(t5);
            }, e4.onerror = () => {
              o3("error");
            }, e4.onabort = () => {
              o3("aborted");
            }, this._reader.readAsDataURL(t4);
          });
        }
        abort() {
          this._reader.abort();
        }
      }
      class uw extends $r {
        constructor() {
          super(...arguments), this.loaders = new Di2(), this._loadersMap = /* @__PURE__ */ new Map(), this._pendingAction = null;
        }
        static get pluginName() {
          return "FileRepository";
        }
        static get requires() {
          return [Mg2];
        }
        init() {
          this.loaders.on("change", () => this._updatePendingAction()), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t4, e4) => e4 ? t4 / e4 * 100 : 0);
        }
        getLoader(t4) {
          return this._loadersMap.get(t4) || null;
        }
        createLoader(t4) {
          if (!this.createUploadAdapter)
            return C2("filerepository-no-upload-adapter"), null;
          const e4 = new gw(Promise.resolve(t4), this.createUploadAdapter);
          return this.loaders.add(e4), this._loadersMap.set(t4, e4), t4 instanceof Promise && e4.file.then((t5) => {
            this._loadersMap.set(t5, e4);
          }).catch(() => {
          }), e4.on("change:uploaded", () => {
            let t5 = 0;
            for (const e5 of this.loaders)
              t5 += e5.uploaded;
            this.uploaded = t5;
          }), e4.on("change:uploadTotal", () => {
            let t5 = 0;
            for (const e5 of this.loaders)
              e5.uploadTotal && (t5 += e5.uploadTotal);
            this.uploadTotal = t5;
          }), e4;
        }
        destroyLoader(t4) {
          const e4 = t4 instanceof gw ? t4 : this.getLoader(t4);
          e4._destroy(), this.loaders.remove(e4), this._loadersMap.forEach((t5, n3) => {
            t5 === e4 && this._loadersMap.delete(n3);
          });
        }
        _updatePendingAction() {
          const t4 = this.editor.plugins.get(Mg2);
          if (this.loaders.length) {
            if (!this._pendingAction) {
              const e4 = this.editor.t, n3 = (t5) => `${e4("Upload in progress")} ${parseInt(t5)}%.`;
              this._pendingAction = t4.add(n3(this.uploadedPercent)), this._pendingAction.bind("message").to(this, "uploadedPercent", n3);
            }
          } else
            t4.remove(this._pendingAction), this._pendingAction = null;
        }
      }
      class gw extends W2() {
        constructor(t4, e4) {
          super(), this.id = f2(), this._filePromiseWrapper = this._createFilePromiseWrapper(t4), this._adapter = e4(this), this._reader = new hw(), this.set("status", "idle"), this.set("uploaded", 0), this.set("uploadTotal", null), this.bind("uploadedPercent").to(this, "uploaded", this, "uploadTotal", (t5, e5) => e5 ? t5 / e5 * 100 : 0), this.set("uploadResponse", null);
        }
        get file() {
          return this._filePromiseWrapper ? this._filePromiseWrapper.promise.then((t4) => this._filePromiseWrapper ? t4 : null) : Promise.resolve(null);
        }
        get data() {
          return this._reader.data;
        }
        read() {
          if ("idle" != this.status)
            throw new A2("filerepository-read-wrong-status", this);
          return this.status = "reading", this.file.then((t4) => this._reader.read(t4)).then((t4) => {
            if ("reading" !== this.status)
              throw this.status;
            return this.status = "idle", t4;
          }).catch((t4) => {
            if ("aborted" === t4)
              throw this.status = "aborted", "aborted";
            throw this.status = "error", this._reader.error ? this._reader.error : t4;
          });
        }
        upload() {
          if ("idle" != this.status)
            throw new A2("filerepository-upload-wrong-status", this);
          return this.status = "uploading", this.file.then(() => this._adapter.upload()).then((t4) => (this.uploadResponse = t4, this.status = "idle", t4)).catch((t4) => {
            if ("aborted" === this.status)
              throw "aborted";
            throw this.status = "error", t4;
          });
        }
        abort() {
          const t4 = this.status;
          this.status = "aborted", this._filePromiseWrapper.isFulfilled ? "reading" == t4 ? this._reader.abort() : "uploading" == t4 && this._adapter.abort && this._adapter.abort() : (this._filePromiseWrapper.promise.catch(() => {
          }), this._filePromiseWrapper.rejecter("aborted")), this._destroy();
        }
        _destroy() {
          this._filePromiseWrapper = void 0, this._reader = void 0, this._adapter = void 0, this.uploadResponse = void 0;
        }
        _createFilePromiseWrapper(t4) {
          const e4 = {};
          return e4.promise = new Promise((n3, o3) => {
            e4.rejecter = o3, e4.isFulfilled = false, t4.then((t5) => {
              e4.isFulfilled = true, n3(t5);
            }).catch((t5) => {
              e4.isFulfilled = true, o3(t5);
            });
          }), e4;
        }
      }
      class pw extends Hi2 {
        constructor(t4) {
          super(t4), this.buttonView = new br(t4), this._fileInputView = new mw(t4), this._fileInputView.bind("acceptedType").to(this), this._fileInputView.bind("allowMultipleFiles").to(this), this._fileInputView.delegate("done").to(this), this.setTemplate({ tag: "span", attributes: { class: "ck-file-dialog-button" }, children: [this.buttonView, this._fileInputView] }), this.buttonView.on("execute", () => {
            this._fileInputView.open();
          });
        }
        focus() {
          this.buttonView.focus();
        }
      }
      class mw extends Hi2 {
        constructor(t4) {
          super(t4), this.set("acceptedType", void 0), this.set("allowMultipleFiles", false);
          const e4 = this.bindTemplate;
          this.setTemplate({ tag: "input", attributes: { class: ["ck-hidden"], type: "file", tabindex: "-1", accept: e4.to("acceptedType"), multiple: e4.to("allowMultipleFiles") }, on: { change: e4.to(() => {
            this.element && this.element.files && this.element.files.length && this.fire("done", this.element.files), this.element.value = "";
          }) } });
        }
        open() {
          this.element.click();
        }
      }
      const fw = "ckCsrfToken", kw = "abcdefghijklmnopqrstuvwxyz0123456789";
      function bw() {
        let t4 = function(t5) {
          t5 = t5.toLowerCase();
          const e5 = document.cookie.split(";");
          for (const n4 of e5) {
            const e6 = n4.split("=");
            if (decodeURIComponent(e6[0].trim().toLowerCase()) === t5)
              return decodeURIComponent(e6[1]);
          }
          return null;
        }(fw);
        var e4, n3;
        return t4 && 40 == t4.length || (t4 = function(t5) {
          let e5 = "";
          const n4 = new Uint8Array(t5);
          window.crypto.getRandomValues(n4);
          for (let t6 = 0; t6 < n4.length; t6++) {
            const o3 = kw.charAt(n4[t6] % kw.length);
            e5 += Math.random() > 0.5 ? o3.toUpperCase() : o3;
          }
          return e5;
        }(40), e4 = fw, n3 = t4, document.cookie = encodeURIComponent(e4) + "=" + encodeURIComponent(n3) + ";path=/"), t4;
      }
      class ww {
        constructor(t4, e4, n3) {
          this.loader = t4, this.url = e4, this.t = n3;
        }
        upload() {
          return this.loader.file.then((t4) => new Promise((e4, n3) => {
            this._initRequest(), this._initListeners(e4, n3, t4), this._sendRequest(t4);
          }));
        }
        abort() {
          this.xhr && this.xhr.abort();
        }
        _initRequest() {
          const t4 = this.xhr = new XMLHttpRequest();
          t4.open("POST", this.url, true), t4.responseType = "json";
        }
        _initListeners(t4, e4, n3) {
          const o3 = this.xhr, i3 = this.loader, r3 = (0, this.t)("Cannot upload file:") + ` ${n3.name}.`;
          o3.addEventListener("error", () => e4(r3)), o3.addEventListener("abort", () => e4()), o3.addEventListener("load", () => {
            const n4 = o3.response;
            if (!n4 || !n4.uploaded)
              return e4(n4 && n4.error && n4.error.message ? n4.error.message : r3);
            t4({ default: n4.url });
          }), o3.upload && o3.upload.addEventListener("progress", (t5) => {
            t5.lengthComputable && (i3.uploadTotal = t5.total, i3.uploaded = t5.loaded);
          });
        }
        _sendRequest(t4) {
          const e4 = new FormData();
          e4.append("upload", t4), e4.append("ckCsrfToken", bw()), this.xhr.send(e4);
        }
      }
      function Aw(t4, e4, n3, o3) {
        let i3, r3 = null;
        "function" == typeof o3 ? i3 = o3 : (r3 = t4.commands.get(o3), i3 = () => {
          t4.execute(o3);
        }), t4.model.document.on("change:data", (s3, a3) => {
          if (r3 && !r3.isEnabled || !e4.isEnabled)
            return;
          const c3 = Si2(t4.model.document.selection.getRanges());
          if (!c3.isCollapsed)
            return;
          if (a3.isUndo || !a3.isLocal)
            return;
          const l3 = Array.from(t4.model.document.differ.getChanges()), d3 = l3[0];
          if (1 != l3.length || "insert" !== d3.type || "$text" != d3.name || 1 != d3.length)
            return;
          const h3 = d3.position.parent;
          if (h3.is("element", "codeBlock"))
            return;
          if (h3.is("element", "listItem") && "function" != typeof o3 && !["numberedList", "bulletedList", "todoList"].includes(o3))
            return;
          if (r3 && true === r3.value)
            return;
          const u3 = h3.getChild(0), g3 = t4.model.createRangeOn(u3);
          if (!g3.containsRange(c3) && !c3.end.isEqual(g3.end))
            return;
          const p3 = n3.exec(u3.data.substr(0, c3.end.offset));
          p3 && t4.model.enqueueChange((e5) => {
            const n4 = e5.createPositionAt(h3, 0), o4 = e5.createPositionAt(h3, p3[0].length), r4 = new md2(n4, o4);
            if (false !== i3({ match: p3 })) {
              e5.remove(r4);
              const n5 = t4.model.document.selection.getFirstRange(), o5 = e5.createRangeIn(h3);
              !h3.isEmpty || o5.isEqual(n5) || o5.containsRange(n5, true) || e5.remove(h3);
            }
            r4.detach(), t4.model.enqueueChange(() => {
              t4.plugins.get("Delete").requestUndoOnBackspace();
            });
          });
        });
      }
      function Cw(t4, e4, n3, o3) {
        let i3, r3;
        n3 instanceof RegExp ? i3 = n3 : r3 = n3, r3 = r3 || ((t5) => {
          let e5;
          const n4 = [], o4 = [];
          for (; null !== (e5 = i3.exec(t5)) && !(e5 && e5.length < 4); ) {
            let { index: t6, 1: i4, 2: r4, 3: s3 } = e5;
            const a3 = i4 + r4 + s3;
            t6 += e5[0].length - a3.length;
            const c3 = [t6, t6 + i4.length], l3 = [t6 + i4.length + r4.length, t6 + i4.length + r4.length + s3.length];
            n4.push(c3), n4.push(l3), o4.push([t6 + i4.length, t6 + i4.length + r4.length]);
          }
          return { remove: n4, format: o4 };
        }), t4.model.document.on("change:data", (n4, i4) => {
          if (i4.isUndo || !i4.isLocal || !e4.isEnabled)
            return;
          const s3 = t4.model, a3 = s3.document.selection;
          if (!a3.isCollapsed)
            return;
          const c3 = Array.from(s3.document.differ.getChanges()), l3 = c3[0];
          if (1 != c3.length || "insert" !== l3.type || "$text" != l3.name || 1 != l3.length)
            return;
          const d3 = a3.focus, h3 = d3.parent, { text: u3, range: g3 } = function(t5, e5) {
            let n5 = t5.start;
            const o4 = Array.from(t5.getItems()).reduce((t6, o5) => !o5.is("$text") && !o5.is("$textProxy") || o5.getAttribute("code") ? (n5 = e5.createPositionAfter(o5), "") : t6 + o5.data, "");
            return { text: o4, range: e5.createRange(n5, t5.end) };
          }(s3.createRange(s3.createPositionAt(h3, 0), d3), s3), p3 = r3(u3), m3 = _w(g3.start, p3.format, s3), f3 = _w(g3.start, p3.remove, s3);
          m3.length && f3.length && s3.enqueueChange((e5) => {
            if (false !== o3(e5, m3)) {
              for (const t5 of f3.reverse())
                e5.remove(t5);
              s3.enqueueChange(() => {
                t4.plugins.get("Delete").requestUndoOnBackspace();
              });
            }
          });
        });
      }
      function _w(t4, e4, n3) {
        return e4.filter((t5) => void 0 !== t5[0] && void 0 !== t5[1]).map((e5) => n3.createRange(t4.getShiftedBy(e5[0]), t4.getShiftedBy(e5[1])));
      }
      function vw(t4, e4) {
        return (n3, o3) => {
          if (!t4.commands.get(e4).isEnabled)
            return false;
          const i3 = t4.model.schema.getValidRanges(o3, e4);
          for (const t5 of i3)
            n3.setAttribute(e4, true, t5);
          n3.removeSelectionAttribute(e4);
        };
      }
      class yw extends Qr {
        constructor(t4, e4) {
          super(t4), this.attributeKey = e4;
        }
        refresh() {
          const t4 = this.editor.model, e4 = t4.document;
          this.value = this._getValueFromFirstAllowedNode(), this.isEnabled = t4.schema.checkAttributeInSelection(e4.selection, this.attributeKey);
        }
        execute(t4 = {}) {
          const e4 = this.editor.model, n3 = e4.document.selection, o3 = void 0 === t4.forceValue ? !this.value : t4.forceValue;
          e4.change((t5) => {
            if (n3.isCollapsed)
              o3 ? t5.setSelectionAttribute(this.attributeKey, true) : t5.removeSelectionAttribute(this.attributeKey);
            else {
              const i3 = e4.schema.getValidRanges(n3.getRanges(), this.attributeKey);
              for (const e5 of i3)
                o3 ? t5.setAttribute(this.attributeKey, o3, e5) : t5.removeAttribute(this.attributeKey, e5);
            }
          });
        }
        _getValueFromFirstAllowedNode() {
          const t4 = this.editor.model, e4 = t4.schema, n3 = t4.document.selection;
          if (n3.isCollapsed)
            return n3.hasAttribute(this.attributeKey);
          for (const t5 of n3.getRanges())
            for (const n4 of t5.getItems())
              if (e4.checkAttribute(n4, this.attributeKey))
                return n4.hasAttribute(this.attributeKey);
          return false;
        }
      }
      const xw = "bold";
      class Ew extends $r {
        static get pluginName() {
          return "BoldEditing";
        }
        init() {
          const t4 = this.editor;
          t4.model.schema.extend("$text", { allowAttributes: xw }), t4.model.schema.setAttributeProperties(xw, { isFormatting: true, copyOnEnter: true }), t4.conversion.attributeToElement({ model: xw, view: "strong", upcastAlso: ["b", (t5) => {
            const e4 = t5.getStyle("font-weight");
            return e4 && ("bold" == e4 || Number(e4) >= 600) ? { name: true, styles: ["font-weight"] } : null;
          }] }), t4.commands.add(xw, new yw(t4, xw)), t4.keystrokes.set("CTRL+B", xw);
        }
      }
      const Dw = "bold";
      class Sw extends $r {
        static get pluginName() {
          return "BoldUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.t;
          t4.ui.componentFactory.add(Dw, (n3) => {
            const o3 = t4.commands.get(Dw), i3 = new br(n3);
            return i3.set({ label: e4("Bold"), icon: Bg2.bold, keystroke: "CTRL+B", tooltip: true, isToggleable: true }), i3.bind("isOn", "isEnabled").to(o3, "value", "isEnabled"), this.listenTo(i3, "execute", () => {
              t4.execute(Dw), t4.editing.view.focus();
            }), i3;
          });
        }
      }
      var Iw = n2(8603), Tw = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Iw.Z, Tw);
      Iw.Z.locals;
      const Mw = "italic";
      class Bw extends $r {
        static get pluginName() {
          return "ItalicEditing";
        }
        init() {
          const t4 = this.editor;
          t4.model.schema.extend("$text", { allowAttributes: Mw }), t4.model.schema.setAttributeProperties(Mw, { isFormatting: true, copyOnEnter: true }), t4.conversion.attributeToElement({ model: Mw, view: "i", upcastAlso: ["em", { styles: { "font-style": "italic" } }] }), t4.commands.add(Mw, new yw(t4, Mw)), t4.keystrokes.set("CTRL+I", Mw);
        }
      }
      const Nw = "italic";
      class Pw extends $r {
        static get pluginName() {
          return "ItalicUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.t;
          t4.ui.componentFactory.add(Nw, (n3) => {
            const o3 = t4.commands.get(Nw), i3 = new br(n3);
            return i3.set({ label: e4("Italic"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m9.586 14.633.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z"/></svg>', keystroke: "CTRL+I", tooltip: true, isToggleable: true }), i3.bind("isOn", "isEnabled").to(o3, "value", "isEnabled"), this.listenTo(i3, "execute", () => {
              t4.execute(Nw), t4.editing.view.focus();
            }), i3;
          });
        }
      }
      class zw extends Qr {
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(t4 = {}) {
          const e4 = this.editor.model, n3 = e4.schema, o3 = e4.document.selection, i3 = Array.from(o3.getSelectedBlocks()), r3 = void 0 === t4.forceValue ? !this.value : t4.forceValue;
          e4.change((t5) => {
            if (r3) {
              const e5 = i3.filter((t6) => Ow(t6) || jw(n3, t6));
              this._applyQuote(t5, e5);
            } else
              this._removeQuote(t5, i3.filter(Ow));
          });
        }
        _getValue() {
          const t4 = Si2(this.editor.model.document.selection.getSelectedBlocks());
          return !(!t4 || !Ow(t4));
        }
        _checkEnabled() {
          if (this.value)
            return true;
          const t4 = this.editor.model.document.selection, e4 = this.editor.model.schema, n3 = Si2(t4.getSelectedBlocks());
          return !!n3 && jw(e4, n3);
        }
        _removeQuote(t4, e4) {
          Lw(t4, e4).reverse().forEach((e5) => {
            if (e5.start.isAtStart && e5.end.isAtEnd)
              return void t4.unwrap(e5.start.parent);
            if (e5.start.isAtStart) {
              const n4 = t4.createPositionBefore(e5.start.parent);
              return void t4.move(e5, n4);
            }
            e5.end.isAtEnd || t4.split(e5.end);
            const n3 = t4.createPositionAfter(e5.end.parent);
            t4.move(e5, n3);
          });
        }
        _applyQuote(t4, e4) {
          const n3 = [];
          Lw(t4, e4).reverse().forEach((e5) => {
            let o3 = Ow(e5.start);
            o3 || (o3 = t4.createElement("blockQuote"), t4.wrap(e5, o3)), n3.push(o3);
          }), n3.reverse().reduce((e5, n4) => e5.nextSibling == n4 ? (t4.merge(t4.createPositionAfter(e5)), e5) : n4);
        }
      }
      function Ow(t4) {
        return "blockQuote" == t4.parent.name ? t4.parent : null;
      }
      function Lw(t4, e4) {
        let n3, o3 = 0;
        const i3 = [];
        for (; o3 < e4.length; ) {
          const r3 = e4[o3], s3 = e4[o3 + 1];
          n3 || (n3 = t4.createPositionBefore(r3)), s3 && r3.nextSibling == s3 || (i3.push(t4.createRange(n3, t4.createPositionAfter(r3))), n3 = null), o3++;
        }
        return i3;
      }
      function jw(t4, e4) {
        const n3 = t4.checkChild(e4.parent, "blockQuote"), o3 = t4.checkChild(["$root", "blockQuote"], e4);
        return n3 && o3;
      }
      class Rw extends $r {
        static get pluginName() {
          return "BlockQuoteEditing";
        }
        static get requires() {
          return [Nk2, dk2];
        }
        init() {
          const t4 = this.editor, e4 = t4.model.schema;
          t4.commands.add("blockQuote", new zw(t4)), e4.register("blockQuote", { inheritAllFrom: "$container" }), t4.conversion.elementToElement({ model: "blockQuote", view: "blockquote" }), t4.model.document.registerPostFixer((n4) => {
            const o4 = t4.model.document.differ.getChanges();
            for (const t5 of o4)
              if ("insert" == t5.type) {
                const o5 = t5.position.nodeAfter;
                if (!o5)
                  continue;
                if (o5.is("element", "blockQuote") && o5.isEmpty)
                  return n4.remove(o5), true;
                if (o5.is("element", "blockQuote") && !e4.checkChild(t5.position, o5))
                  return n4.unwrap(o5), true;
                if (o5.is("element")) {
                  const t6 = n4.createRangeIn(o5);
                  for (const o6 of t6.getItems())
                    if (o6.is("element", "blockQuote") && !e4.checkChild(n4.createPositionBefore(o6), o6))
                      return n4.unwrap(o6), true;
                }
              } else if ("remove" == t5.type) {
                const e5 = t5.position.parent;
                if (e5.is("element", "blockQuote") && e5.isEmpty)
                  return n4.remove(e5), true;
              }
            return false;
          });
          const n3 = this.editor.editing.view.document, o3 = t4.model.document.selection, i3 = t4.commands.get("blockQuote");
          this.listenTo(n3, "enter", (e5, n4) => {
            if (!o3.isCollapsed || !i3.value)
              return;
            o3.getLastPosition().parent.isEmpty && (t4.execute("blockQuote"), t4.editing.view.scrollToTheSelection(), n4.preventDefault(), e5.stop());
          }, { context: "blockquote" }), this.listenTo(n3, "delete", (e5, n4) => {
            if ("backward" != n4.direction || !o3.isCollapsed || !i3.value)
              return;
            const r3 = o3.getLastPosition().parent;
            r3.isEmpty && !r3.previousSibling && (t4.execute("blockQuote"), t4.editing.view.scrollToTheSelection(), n4.preventDefault(), e5.stop());
          }, { context: "blockquote" });
        }
      }
      var Fw = n2(3062), Vw = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Fw.Z, Vw);
      Fw.Z.locals;
      class Hw extends $r {
        static get pluginName() {
          return "BlockQuoteUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.t;
          t4.ui.componentFactory.add("blockQuote", (n3) => {
            const o3 = t4.commands.get("blockQuote"), i3 = new br(n3);
            return i3.set({ label: e4("Block quote"), icon: Bg2.quote, tooltip: true, isToggleable: true }), i3.bind("isOn", "isEnabled").to(o3, "value", "isEnabled"), this.listenTo(i3, "execute", () => {
              t4.execute("blockQuote"), t4.editing.view.focus();
            }), i3;
          });
        }
      }
      class Uw extends $r {
        static get pluginName() {
          return "CKBoxUI";
        }
        afterInit() {
          const t4 = this.editor, e4 = t4.commands.get("ckbox");
          if (!e4)
            return;
          const n3 = t4.t;
          t4.ui.componentFactory.add("ckbox", (o3) => {
            const i3 = new br(o3);
            return i3.set({ label: n3("Open file manager"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>', tooltip: true }), i3.bind("isOn", "isEnabled").to(e4, "value", "isEnabled"), i3.on("execute", () => {
              t4.execute("ckbox");
            }), i3;
          });
        }
      }
      function qw(t4) {
        const e4 = [];
        let n3 = 0;
        for (const o4 in t4) {
          const i3 = parseInt(o4, 10);
          isNaN(i3) || (i3 > n3 && (n3 = i3), e4.push(`${t4[o4]} ${o4}w`));
        }
        const o3 = [{ srcset: e4.join(","), sizes: `(max-width: ${n3}px) 100vw, ${n3}px`, type: "image/webp" }];
        return { imageFallbackUrl: t4.default, imageSources: o3 };
      }
      class Gw extends Qr {
        constructor(t4) {
          super(t4), this._chosenAssets = /* @__PURE__ */ new Set(), this._wrapper = null, this._initListeners();
        }
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute() {
          this.fire("ckbox:open");
        }
        _getValue() {
          return null !== this._wrapper;
        }
        _checkEnabled() {
          const t4 = this.editor.commands.get("insertImage"), e4 = this.editor.commands.get("link");
          return !(!t4.isEnabled && !e4.isEnabled);
        }
        _prepareOptions() {
          const t4 = this.editor.config.get("ckbox");
          return { theme: t4.theme, language: t4.language, tokenUrl: t4.tokenUrl, serviceOrigin: t4.serviceOrigin, dialog: { onClose: () => this.fire("ckbox:close") }, assets: { onChoose: (t5) => this.fire("ckbox:choose", t5) } };
        }
        _initListeners() {
          const t4 = this.editor, e4 = t4.model, n3 = !t4.config.get("ckbox.ignoreDataId");
          this.on("ckbox", () => {
            this.refresh();
          }, { priority: "low" }), this.on("ckbox:open", () => {
            this.isEnabled && !this.value && (this._wrapper = bt2(document, "div", { class: "ck ckbox-wrapper" }), document.body.appendChild(this._wrapper), window.CKBox.mount(this._wrapper, this._prepareOptions()));
          }), this.on("ckbox:close", () => {
            this.value && (this._wrapper.remove(), this._wrapper = null);
          }), this.on("ckbox:choose", (o3, i3) => {
            if (!this.isEnabled)
              return;
            const r3 = t4.commands.get("insertImage"), s3 = t4.commands.get("link"), a3 = function({ assets: t5, isImageAllowed: e5, isLinkAllowed: n4 }) {
              return t5.map((t6) => function(t7) {
                const e6 = t7.data.metadata;
                if (!e6)
                  return false;
                return e6.width && e6.height;
              }(t6) ? { id: t6.data.id, type: "image", attributes: Ww(t6) } : { id: t6.data.id, type: "link", attributes: Kw(t6) }).filter((t6) => "image" === t6.type ? e5 : n4);
            }({ assets: i3, isImageAllowed: r3.isEnabled, isLinkAllowed: s3.isEnabled });
            0 !== a3.length && e4.change((t5) => {
              for (const e5 of a3) {
                const o4 = e5 === a3[a3.length - 1];
                this._insertAsset(e5, o4, t5), n3 && (setTimeout(() => this._chosenAssets.delete(e5), 1e3), this._chosenAssets.add(e5));
              }
            });
          }), this.listenTo(t4, "destroy", () => {
            this.fire("ckbox:close"), this._chosenAssets.clear();
          });
        }
        _insertAsset(t4, e4, n3) {
          const o3 = this.editor.model.document.selection;
          n3.removeSelectionAttribute("linkHref"), "image" === t4.type ? this._insertImage(t4) : this._insertLink(t4, n3), e4 || n3.setSelection(o3.getLastPosition());
        }
        _insertImage(t4) {
          const e4 = this.editor, { imageFallbackUrl: n3, imageSources: o3, imageTextAlternative: i3 } = t4.attributes;
          e4.execute("insertImage", { source: { src: n3, sources: o3, alt: i3 } });
        }
        _insertLink(t4, e4) {
          const n3 = this.editor, o3 = n3.model, i3 = o3.document.selection, { linkName: r3, linkHref: s3 } = t4.attributes;
          if (i3.isCollapsed) {
            const t5 = Mi2(i3.getAttributes()), n4 = e4.createText(r3, t5), s4 = o3.insertContent(n4);
            e4.setSelection(s4);
          }
          n3.execute("link", s3);
        }
      }
      function Ww(t4) {
        const { imageFallbackUrl: e4, imageSources: n3 } = qw(t4.data.imageUrls);
        return { imageFallbackUrl: e4, imageSources: n3, imageTextAlternative: t4.data.metadata.description || "" };
      }
      function Kw(t4) {
        return { linkName: t4.data.name, linkHref: Yw(t4) };
      }
      function Yw(t4) {
        const e4 = new URL(t4.data.url);
        return e4.searchParams.set("download", "true"), e4.toString();
      }
      var $w = (t4, e4, n3) => new Promise((o3, i3) => {
        var r3 = (t5) => {
          try {
            a3(n3.next(t5));
          } catch (t6) {
            i3(t6);
          }
        }, s3 = (t5) => {
          try {
            a3(n3.throw(t5));
          } catch (t6) {
            i3(t6);
          }
        }, a3 = (t5) => t5.done ? o3(t5.value) : Promise.resolve(t5.value).then(r3, s3);
        a3((n3 = n3.apply(t4, e4)).next());
      });
      class Zw extends $r {
        static get requires() {
          return ["ImageUploadEditing", "ImageUploadProgress", uw, Jw];
        }
        static get pluginName() {
          return "CKBoxUploadAdapter";
        }
        afterInit() {
          return $w(this, null, function* () {
            const t4 = this.editor, e4 = !!t4.config.get("ckbox"), n3 = !!window.CKBox;
            if (!e4 && !n3)
              return;
            const o3 = t4.plugins.get(uw), i3 = t4.plugins.get(Jw);
            o3.createUploadAdapter = (e5) => new Qw(e5, i3.getToken(), t4);
            const r3 = !t4.config.get("ckbox.ignoreDataId"), s3 = t4.plugins.get("ImageUploadEditing");
            r3 && s3.on("uploadComplete", (e5, { imageElement: n4, data: o4 }) => {
              t4.model.change((t5) => {
                t5.setAttribute("ckboxImageId", o4.ckboxImageId, n4);
              });
            });
          });
        }
      }
      class Qw {
        constructor(t4, e4, n3) {
          this.loader = t4, this.token = e4, this.editor = n3, this.controller = new AbortController(), this.serviceOrigin = n3.config.get("ckbox.serviceOrigin");
        }
        getWorkspaceId() {
          const t4 = (0, this.editor.t)("Cannot access default workspace."), e4 = this.editor.config.get("ckbox.defaultUploadWorkspaceId"), n3 = function(t5, e5) {
            const [, n4] = t5.value.split("."), o3 = JSON.parse(atob(n4)), i3 = o3.auth && o3.auth.ckbox && o3.auth.ckbox.workspaces || [o3.aud];
            return e5 ? "superadmin" == (o3.auth && o3.auth.ckbox && o3.auth.ckbox.role) || i3.includes(e5) ? e5 : null : i3[0];
          }(this.token, e4);
          if (null == n3)
            throw _2("ckbox-access-default-workspace-error"), t4;
          return n3;
        }
        getAvailableCategories(t4 = 0) {
          return $w(this, null, function* () {
            const e4 = new URL("categories", this.serviceOrigin);
            return e4.searchParams.set("limit", 50 .toString()), e4.searchParams.set("offset", t4.toString()), e4.searchParams.set("workspaceId", this.getWorkspaceId()), this._sendHttpRequest({ url: e4 }).then((e5) => $w(this, null, function* () {
              if (e5.totalCount - (t4 + 50) > 0) {
                const n3 = yield this.getAvailableCategories(t4 + 50);
                return [...e5.items, ...n3];
              }
              return e5.items;
            })).catch(() => {
              this.controller.signal.throwIfAborted(), _2("ckbox-fetch-category-http-error");
            });
          });
        }
        getCategoryIdForFile(t4) {
          return $w(this, null, function* () {
            const e4 = function(t5) {
              const e5 = new RegExp("\\.(?<ext>[^.]+)$");
              return t5.match(e5).groups.ext.toLowerCase();
            }(t4.name), n3 = yield this.getAvailableCategories();
            if (!n3)
              return null;
            const o3 = this.editor.config.get("ckbox.defaultUploadCategories");
            if (o3) {
              const t5 = Object.keys(o3).find((t6) => o3[t6].find((t7) => t7.toLowerCase() == e4));
              if (t5) {
                const e5 = n3.find((e6) => e6.id === t5 || e6.name === t5);
                return e5 ? e5.id : null;
              }
            }
            const i3 = n3.find((t5) => t5.extensions.find((t6) => t6.toLowerCase() == e4));
            return i3 ? i3.id : null;
          });
        }
        upload() {
          return $w(this, null, function* () {
            const t4 = this.editor.t, e4 = t4("Cannot determine a category for the uploaded file."), n3 = yield this.loader.file, o3 = yield this.getCategoryIdForFile(n3);
            if (!o3)
              return Promise.reject(e4);
            const i3 = new URL("assets", this.serviceOrigin), r3 = new FormData();
            i3.searchParams.set("workspaceId", this.getWorkspaceId()), r3.append("categoryId", o3), r3.append("file", n3);
            const s3 = { method: "POST", url: i3, data: r3, onUploadProgress: (t5) => {
              t5.lengthComputable && (this.loader.uploadTotal = t5.total, this.loader.uploaded = t5.loaded);
            } };
            return this._sendHttpRequest(s3).then((t5) => $w(this, null, function* () {
              const e5 = qw(t5.imageUrls);
              return { ckboxImageId: t5.id, default: e5.imageFallbackUrl, sources: e5.imageSources };
            })).catch(() => {
              const e5 = t4("Cannot upload file:") + ` ${n3.name}.`;
              return Promise.reject(e5);
            });
          });
        }
        abort() {
          this.controller.abort();
        }
        _sendHttpRequest({ url: t4, method: e4 = "GET", data: n3, onUploadProgress: o3 }) {
          const i3 = this.controller.signal, r3 = new XMLHttpRequest();
          r3.open(e4, t4.toString(), true), r3.setRequestHeader("Authorization", this.token.value), r3.setRequestHeader("CKBox-Version", "CKEditor 5"), r3.responseType = "json";
          const s3 = () => {
            r3.abort();
          };
          return new Promise((t5, e5) => {
            i3.addEventListener("abort", s3), r3.addEventListener("loadstart", () => {
              i3.addEventListener("abort", s3);
            }), r3.addEventListener("loadend", () => {
              i3.removeEventListener("abort", s3);
            }), r3.addEventListener("error", () => {
              e5();
            }), r3.addEventListener("abort", () => {
              e5();
            }), r3.addEventListener("load", () => $w(this, null, function* () {
              const n4 = r3.response;
              return !n4 || n4.statusCode >= 400 ? e5(n4 && n4.message) : t5(n4);
            })), o3 && r3.upload.addEventListener("progress", (t6) => {
              o3(t6);
            }), r3.send(n3);
          });
        }
      }
      class Jw extends $r {
        static get pluginName() {
          return "CKBoxEditing";
        }
        static get requires() {
          return ["CloudServices", "LinkEditing", "PictureEditing", Zw];
        }
        init() {
          return t4 = this, e4 = null, n3 = function* () {
            const t5 = this.editor, e5 = !!t5.config.get("ckbox"), n4 = !!window.CKBox;
            if (!e5 && !n4)
              return;
            this._initConfig();
            const o3 = t5.plugins.get("CloudServicesCore"), i3 = t5.config.get("ckbox.tokenUrl");
            if (i3 === t5.config.get("cloudServices.tokenUrl")) {
              const e6 = t5.plugins.get("CloudServices");
              this._token = e6.token;
            } else
              this._token = yield o3.createToken(i3).init();
            t5.config.get("ckbox.ignoreDataId") || (this._initSchema(), this._initConversion(), this._initFixers()), n4 && t5.commands.add("ckbox", new Gw(t5));
          }, new Promise((o3, i3) => {
            var r3 = (t5) => {
              try {
                a3(n3.next(t5));
              } catch (t6) {
                i3(t6);
              }
            }, s3 = (t5) => {
              try {
                a3(n3.throw(t5));
              } catch (t6) {
                i3(t6);
              }
            }, a3 = (t5) => t5.done ? o3(t5.value) : Promise.resolve(t5.value).then(r3, s3);
            a3((n3 = n3.apply(t4, e4)).next());
          });
          var t4, e4, n3;
        }
        getToken() {
          return this._token;
        }
        _initConfig() {
          const t4 = this.editor;
          t4.config.define("ckbox", { serviceOrigin: "https://api.ckbox.io", defaultUploadCategories: null, ignoreDataId: false, language: t4.locale.uiLanguage, theme: "default", tokenUrl: t4.config.get("cloudServices.tokenUrl") });
          if (!t4.config.get("ckbox.tokenUrl"))
            throw new A2("ckbox-plugin-missing-token-url", this);
          t4.plugins.has("ImageBlockEditing") || t4.plugins.has("ImageInlineEditing") || _2("ckbox-plugin-image-feature-missing", t4);
        }
        _initSchema() {
          const t4 = this.editor.model.schema;
          t4.extend("$text", { allowAttributes: "ckboxLinkId" }), t4.isRegistered("imageBlock") && t4.extend("imageBlock", { allowAttributes: ["ckboxImageId", "ckboxLinkId"] }), t4.isRegistered("imageInline") && t4.extend("imageInline", { allowAttributes: ["ckboxImageId", "ckboxLinkId"] }), t4.addAttributeCheck((t5, e4) => {
            if (!!!t5.last.getAttribute("linkHref") && "ckboxLinkId" === e4)
              return false;
          });
        }
        _initConversion() {
          const t4 = this.editor;
          t4.conversion.for("downcast").add((t5) => {
            t5.on("attribute:ckboxLinkId:imageBlock", (t6, e4, n3) => {
              const { writer: o3, mapper: i3, consumable: r3 } = n3;
              if (!r3.consume(e4.item, t6.name))
                return;
              const s3 = [...i3.toViewElement(e4.item).getChildren()].find((t7) => "a" === t7.name);
              s3 && (e4.item.hasAttribute("ckboxLinkId") ? o3.setAttribute("data-ckbox-resource-id", e4.item.getAttribute("ckboxLinkId"), s3) : o3.removeAttribute("data-ckbox-resource-id", s3));
            }, { priority: "low" }), t5.on("attribute:ckboxLinkId", (t6, e4, n3) => {
              const { writer: o3, mapper: i3, consumable: r3 } = n3;
              if (r3.consume(e4.item, t6.name)) {
                if (e4.attributeOldValue) {
                  const t7 = tA(o3, e4.attributeOldValue);
                  o3.unwrap(i3.toViewRange(e4.range), t7);
                }
                if (e4.attributeNewValue) {
                  const t7 = tA(o3, e4.attributeNewValue);
                  if (e4.item.is("selection")) {
                    const e5 = o3.document.selection;
                    o3.wrap(e5.getFirstRange(), t7);
                  } else
                    o3.wrap(i3.toViewRange(e4.range), t7);
                }
              }
            }, { priority: "low" });
          }), t4.conversion.for("upcast").add((t5) => {
            t5.on("element:a", (t6, e4, n3) => {
              const { writer: o3, consumable: i3 } = n3;
              if (!e4.viewItem.getAttribute("href"))
                return;
              if (!i3.consume(e4.viewItem, { attributes: ["data-ckbox-resource-id"] }))
                return;
              const r3 = e4.viewItem.getAttribute("data-ckbox-resource-id");
              if (r3)
                if (e4.modelRange)
                  for (let t7 of e4.modelRange.getItems())
                    t7.is("$textProxy") && (t7 = t7.textNode), eA(t7) && o3.setAttribute("ckboxLinkId", r3, t7);
                else {
                  const t7 = e4.modelCursor.nodeBefore || e4.modelCursor.parent;
                  o3.setAttribute("ckboxLinkId", r3, t7);
                }
            }, { priority: "low" });
          }), t4.conversion.for("downcast").attributeToAttribute({ model: "ckboxImageId", view: "data-ckbox-resource-id" }), t4.conversion.for("upcast").elementToAttribute({ model: { key: "ckboxImageId", value: (t5) => t5.getAttribute("data-ckbox-resource-id") }, view: { attributes: { "data-ckbox-resource-id": /[\s\S]+/ } } });
        }
        _initFixers() {
          const t4 = this.editor, e4 = t4.model, n3 = e4.document.selection;
          e4.document.registerPostFixer(function(t5) {
            return (e5) => {
              let n4 = false;
              const o3 = t5.model, i3 = t5.commands.get("ckbox");
              if (!i3)
                return n4;
              for (const t6 of o3.document.differ.getChanges()) {
                if ("insert" !== t6.type && "attribute" !== t6.type)
                  continue;
                const o4 = "insert" === t6.type ? new Wl(t6.position, t6.position.getShiftedBy(t6.length)) : t6.range, r3 = "attribute" === t6.type && "linkHref" === t6.attributeKey && null === t6.attributeNewValue;
                for (const t7 of o4.getItems()) {
                  if (r3 && t7.hasAttribute("ckboxLinkId")) {
                    e5.removeAttribute("ckboxLinkId", t7), n4 = true;
                    continue;
                  }
                  const o5 = Xw(t7, i3._chosenAssets);
                  for (const i4 of o5) {
                    const o6 = "image" === i4.type ? "ckboxImageId" : "ckboxLinkId";
                    i4.id !== t7.getAttribute(o6) && (e5.setAttribute(o6, i4.id, t7), n4 = true);
                  }
                }
              }
              return n4;
            };
          }(t4)), e4.document.registerPostFixer(function(t5) {
            return (e5) => !(t5.hasAttribute("linkHref") || !t5.hasAttribute("ckboxLinkId")) && (e5.removeSelectionAttribute("ckboxLinkId"), true);
          }(n3));
        }
      }
      function Xw(t4, e4) {
        const n3 = t4.is("element", "imageInline") || t4.is("element", "imageBlock"), o3 = t4.hasAttribute("linkHref");
        return [...e4].filter((e5) => "image" === e5.type && n3 ? e5.attributes.imageFallbackUrl === t4.getAttribute("src") : "link" === e5.type && o3 ? e5.attributes.linkHref === t4.getAttribute("linkHref") : void 0);
      }
      function tA(t4, e4) {
        const n3 = t4.createAttributeElement("a", { "data-ckbox-resource-id": e4 }, { priority: 5 });
        return t4.setCustomProperty("link", true, n3), n3;
      }
      function eA(t4) {
        return !!t4.is("$text") || !(!t4.is("element", "imageInline") && !t4.is("element", "imageBlock"));
      }
      class nA extends $r {
        static get pluginName() {
          return "CKFinderUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.ui.componentFactory, n3 = t4.t;
          e4.add("ckfinder", (e5) => {
            const o3 = t4.commands.get("ckfinder"), i3 = new br(e5);
            return i3.set({ label: n3("Insert image or file"), icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z"/><path d="M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z"/></svg>', tooltip: true }), i3.bind("isEnabled").to(o3), i3.on("execute", () => {
              t4.execute("ckfinder"), t4.editing.view.focus();
            }), i3;
          });
        }
      }
      class oA extends Qr {
        constructor(t4) {
          super(t4), this.affectsData = false, this.stopListening(this.editor.model.document, "change"), this.listenTo(this.editor.model.document, "change", () => this.refresh(), { priority: "low" });
        }
        refresh() {
          const t4 = this.editor.commands.get("insertImage"), e4 = this.editor.commands.get("link");
          this.isEnabled = t4.isEnabled || e4.isEnabled;
        }
        execute() {
          const t4 = this.editor, e4 = this.editor.config.get("ckfinder.openerMethod") || "modal";
          if ("popup" != e4 && "modal" != e4)
            throw new A2("ckfinder-unknown-openermethod", t4);
          const n3 = this.editor.config.get("ckfinder.options") || {};
          n3.chooseFiles = true;
          const o3 = n3.onInit;
          n3.language || (n3.language = t4.locale.uiLanguage), n3.onInit = (e5) => {
            o3 && o3(e5), e5.on("files:choose", (n4) => {
              const o4 = n4.data.files.toArray(), i3 = o4.filter((t5) => !t5.isImage()), r3 = o4.filter((t5) => t5.isImage());
              for (const e6 of i3)
                t4.execute("link", e6.getUrl());
              const s3 = [];
              for (const t5 of r3) {
                const n5 = t5.getUrl();
                s3.push(n5 || e5.request("file:getProxyUrl", { file: t5 }));
              }
              s3.length && iA(t4, s3);
            }), e5.on("file:choose:resizedImage", (e6) => {
              const n4 = e6.data.resizedUrl;
              if (n4)
                iA(t4, [n4]);
              else {
                const e7 = t4.plugins.get("Notification"), n5 = t4.locale.t;
                e7.showWarning(n5("Could not obtain resized image URL."), { title: n5("Selecting resized image failed"), namespace: "ckfinder" });
              }
            });
          }, window.CKFinder[e4](n3);
        }
      }
      function iA(t4, e4) {
        if (t4.commands.get("insertImage").isEnabled)
          t4.execute("insertImage", { source: e4 });
        else {
          const e5 = t4.plugins.get("Notification"), n3 = t4.locale.t;
          e5.showWarning(n3("Could not insert image at the current position."), { title: n3("Inserting image failed"), namespace: "ckfinder" });
        }
      }
      class rA extends $r {
        static get pluginName() {
          return "CKFinderEditing";
        }
        static get requires() {
          return [Rm, "LinkEditing"];
        }
        init() {
          const t4 = this.editor;
          if (!t4.plugins.has("ImageBlockEditing") && !t4.plugins.has("ImageInlineEditing"))
            throw new A2("ckfinder-missing-image-plugin", t4);
          t4.commands.add("ckfinder", new oA(t4));
        }
      }
      class sA extends $r {
        static get pluginName() {
          return "CloudServicesUploadAdapter";
        }
        static get requires() {
          return ["CloudServices", uw];
        }
        init() {
          const t4 = this.editor, e4 = t4.plugins.get("CloudServices"), n3 = e4.token, o3 = e4.uploadUrl;
          if (!n3)
            return;
          const i3 = t4.plugins.get("CloudServicesCore");
          this._uploadGateway = i3.createUploadGateway(n3, o3), t4.plugins.get(uw).createUploadAdapter = (t5) => new aA(this._uploadGateway, t5);
        }
      }
      class aA {
        constructor(t4, e4) {
          this.uploadGateway = t4, this.loader = e4;
        }
        upload() {
          return this.loader.file.then((t4) => (this.fileUploader = this.uploadGateway.upload(t4), this.fileUploader.on("progress", (t5, e4) => {
            this.loader.uploadTotal = e4.total, this.loader.uploaded = e4.uploaded;
          }), this.fileUploader.send()));
        }
        abort() {
          this.fileUploader.abort();
        }
      }
      class cA extends Qr {
        constructor(t4) {
          super(t4), this._isEnabledBasedOnSelection = false;
        }
        refresh() {
          const t4 = this.editor.model, e4 = Si2(t4.document.selection.getSelectedBlocks());
          this.value = !!e4 && e4.is("element", "paragraph"), this.isEnabled = !!e4 && lA(e4, t4.schema);
        }
        execute(t4 = {}) {
          const e4 = this.editor.model, n3 = e4.document, o3 = t4.selection || n3.selection;
          e4.canEditAt(o3) && e4.change((t5) => {
            const n4 = o3.getSelectedBlocks();
            for (const o4 of n4)
              !o4.is("element", "paragraph") && lA(o4, e4.schema) && t5.rename(o4, "paragraph");
          });
        }
      }
      function lA(t4, e4) {
        return e4.checkChild(t4.parent, "paragraph") && !e4.isObject(t4);
      }
      class dA extends Qr {
        constructor(t4) {
          super(t4), this._isEnabledBasedOnSelection = false;
        }
        execute(t4) {
          const e4 = this.editor.model, n3 = t4.attributes;
          let o3 = t4.position;
          e4.canEditAt(o3) && e4.change((t5) => {
            if (o3 = this._findPositionToInsertParagraph(o3, t5), !o3)
              return;
            const i3 = t5.createElement("paragraph");
            n3 && e4.schema.setAllowedAttributes(i3, n3, t5), e4.insertContent(i3, o3), t5.setSelection(i3, "in");
          });
        }
        _findPositionToInsertParagraph(t4, e4) {
          const n3 = this.editor.model;
          if (n3.schema.checkChild(t4, "paragraph"))
            return t4;
          const o3 = n3.schema.findAllowedParent(t4, "paragraph");
          if (!o3)
            return null;
          const i3 = t4.parent, r3 = n3.schema.checkChild(i3, "$text");
          return i3.isEmpty || r3 && t4.isAtEnd ? n3.createPositionAfter(i3) : !i3.isEmpty && r3 && t4.isAtStart ? n3.createPositionBefore(i3) : e4.split(t4, o3).position;
        }
      }
      const hA = class extends $r {
        static get pluginName() {
          return "Paragraph";
        }
        init() {
          const t4 = this.editor, e4 = t4.model;
          t4.commands.add("paragraph", new cA(t4)), t4.commands.add("insertParagraph", new dA(t4)), e4.schema.register("paragraph", { inheritAllFrom: "$block" }), t4.conversion.elementToElement({ model: "paragraph", view: "p" }), t4.conversion.for("upcast").elementToElement({ model: (t5, { writer: e5 }) => hA.paragraphLikeElements.has(t5.name) ? t5.isEmpty ? null : e5.createElement("paragraph") : null, view: /.+/, converterPriority: "low" });
        }
      };
      let uA = hA;
      uA.paragraphLikeElements = /* @__PURE__ */ new Set(["blockquote", "dd", "div", "dt", "h1", "h2", "h3", "h4", "h5", "h6", "li", "p", "td", "th"]);
      class gA extends Qr {
        constructor(t4, e4) {
          super(t4), this.modelElements = e4;
        }
        refresh() {
          const t4 = Si2(this.editor.model.document.selection.getSelectedBlocks());
          this.value = !!t4 && this.modelElements.includes(t4.name) && t4.name, this.isEnabled = !!t4 && this.modelElements.some((e4) => pA(t4, e4, this.editor.model.schema));
        }
        execute(t4) {
          const e4 = this.editor.model, n3 = e4.document, o3 = t4.value;
          e4.change((t5) => {
            const i3 = Array.from(n3.selection.getSelectedBlocks()).filter((t6) => pA(t6, o3, e4.schema));
            for (const e5 of i3)
              e5.is("element", o3) || t5.rename(e5, o3);
          });
        }
      }
      function pA(t4, e4, n3) {
        return n3.checkChild(t4.parent, e4) && !n3.isObject(t4);
      }
      const mA = "paragraph";
      class fA extends $r {
        static get pluginName() {
          return "HeadingEditing";
        }
        constructor(t4) {
          super(t4), t4.config.define("heading", { options: [{ model: "paragraph", title: "Paragraph", class: "ck-heading_paragraph" }, { model: "heading1", view: "h2", title: "Heading 1", class: "ck-heading_heading1" }, { model: "heading2", view: "h3", title: "Heading 2", class: "ck-heading_heading2" }, { model: "heading3", view: "h4", title: "Heading 3", class: "ck-heading_heading3" }] });
        }
        static get requires() {
          return [uA];
        }
        init() {
          const t4 = this.editor, e4 = t4.config.get("heading.options"), n3 = [];
          for (const o3 of e4)
            "paragraph" !== o3.model && (t4.model.schema.register(o3.model, { inheritAllFrom: "$block" }), t4.conversion.elementToElement(o3), n3.push(o3.model));
          this._addDefaultH1Conversion(t4), t4.commands.add("heading", new gA(t4, n3));
        }
        afterInit() {
          const t4 = this.editor, e4 = t4.commands.get("enter"), n3 = t4.config.get("heading.options");
          e4 && this.listenTo(e4, "afterExecute", (e5, o3) => {
            const i3 = t4.model.document.selection.getFirstPosition().parent;
            n3.some((t5) => i3.is("element", t5.model)) && !i3.is("element", mA) && 0 === i3.childCount && o3.writer.rename(i3, mA);
          });
        }
        _addDefaultH1Conversion(t4) {
          t4.conversion.for("upcast").elementToElement({ model: "heading1", view: "h1", converterPriority: k2.low + 1 });
        }
      }
      var kA = n2(8733), bA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(kA.Z, bA);
      kA.Z.locals;
      class wA extends $r {
        static get pluginName() {
          return "HeadingUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.t, n3 = function(t5) {
            const e5 = t5.t, n4 = { Paragraph: e5("Paragraph"), "Heading 1": e5("Heading 1"), "Heading 2": e5("Heading 2"), "Heading 3": e5("Heading 3"), "Heading 4": e5("Heading 4"), "Heading 5": e5("Heading 5"), "Heading 6": e5("Heading 6") };
            return t5.config.get("heading.options").map((t6) => {
              const e6 = n4[t6.title];
              return e6 && e6 != t6.title && (t6.title = e6), t6;
            });
          }(t4), o3 = e4("Choose heading"), i3 = e4("Heading");
          t4.ui.componentFactory.add("heading", (e5) => {
            const r3 = {}, s3 = new Di2(), a3 = t4.commands.get("heading"), c3 = t4.commands.get("paragraph"), l3 = [a3];
            for (const t5 of n3) {
              const e6 = { type: "button", model: new Fm({ label: t5.title, class: t5.class, role: "menuitemradio", withText: true }) };
              "paragraph" === t5.model ? (e6.model.bind("isOn").to(c3, "value"), e6.model.set("commandName", "paragraph"), l3.push(c3)) : (e6.model.bind("isOn").to(a3, "value", (e7) => e7 === t5.model), e6.model.set({ commandName: "heading", commandValue: t5.model })), s3.add(e6), r3[t5.model] = t5.title;
            }
            const d3 = tp(e5);
            return op(d3, s3, { ariaLabel: i3, role: "menu" }), d3.buttonView.set({ ariaLabel: i3, ariaLabelledBy: void 0, isOn: false, withText: true, tooltip: i3 }), d3.extendTemplate({ attributes: { class: ["ck-heading-dropdown"] } }), d3.bind("isEnabled").toMany(l3, "isEnabled", (...t5) => t5.some((t6) => t6)), d3.buttonView.bind("label").to(a3, "value", c3, "value", (t5, e6) => {
              const n4 = t5 || e6 && "paragraph";
              return "boolean" == typeof n4 ? o3 : r3[n4] ? r3[n4] : o3;
            }), this.listenTo(d3, "execute", (e6) => {
              const { commandName: n4, commandValue: o4 } = e6.source;
              t4.execute(n4, o4 ? { value: o4 } : void 0), t4.editing.view.focus();
            }), d3;
          });
        }
      }
      function AA(t4) {
        return t4.createContainerElement("figure", { class: "image" }, [t4.createEmptyElement("img"), t4.createSlot("children")]);
      }
      function CA(t4, e4) {
        const n3 = t4.plugins.get("ImageUtils"), o3 = t4.plugins.has("ImageInlineEditing") && t4.plugins.has("ImageBlockEditing");
        return (t5) => {
          if (!n3.isInlineImageView(t5))
            return null;
          if (!o3)
            return i3(t5);
          return ("block" == t5.getStyle("display") || t5.findAncestor(n3.isBlockImageView) ? "imageBlock" : "imageInline") !== e4 ? null : i3(t5);
        };
        function i3(t5) {
          const e5 = { name: true };
          return t5.hasAttribute("src") && (e5.attributes = ["src"]), e5;
        }
      }
      function _A(t4, e4) {
        const n3 = Si2(e4.getSelectedBlocks());
        return !n3 || t4.isObject(n3) || n3.isEmpty && "listItem" != n3.name ? "imageBlock" : "imageInline";
      }
      function vA(t4) {
        return t4 && t4.endsWith("px") ? parseInt(t4) : null;
      }
      function yA(t4) {
        const e4 = vA(t4.getStyle("width")), n3 = vA(t4.getStyle("height"));
        return !(!e4 || !n3);
      }
      var xA = Object.defineProperty, EA = Object.getOwnPropertySymbols, DA = Object.prototype.hasOwnProperty, SA = Object.prototype.propertyIsEnumerable, IA = (t4, e4, n3) => e4 in t4 ? xA(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, TA = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          DA.call(e4, n3) && IA(t4, n3, e4[n3]);
        if (EA)
          for (var n3 of EA(e4))
            SA.call(e4, n3) && IA(t4, n3, e4[n3]);
        return t4;
      };
      const MA = /^(image|image-inline)$/;
      class BA extends $r {
        constructor() {
          super(...arguments), this._domEmitter = new (Mo2())();
        }
        static get pluginName() {
          return "ImageUtils";
        }
        isImage(t4) {
          return this.isInlineImage(t4) || this.isBlockImage(t4);
        }
        isInlineImageView(t4) {
          return !!t4 && t4.is("element", "img");
        }
        isBlockImageView(t4) {
          return !!t4 && t4.is("element", "figure") && t4.hasClass("image");
        }
        insertImage(t4 = {}, e4 = null, n3 = null, o3 = {}) {
          const i3 = this.editor, r3 = i3.model, s3 = r3.document.selection;
          n3 = NA(i3, e4 || s3, n3), t4 = TA(TA({}, Object.fromEntries(s3.getAttributes())), t4);
          for (const e5 in t4)
            r3.schema.checkAttribute(n3, e5) || delete t4[e5];
          return r3.change((i4) => {
            const { setImageSizes: s4 = true } = o3, a3 = i4.createElement(n3, t4);
            return r3.insertObject(a3, e4, null, { setSelection: "on", findOptimalPosition: e4 || "imageInline" == n3 ? void 0 : "auto" }), a3.parent ? (s4 && this.setImageNaturalSizeAttributes(a3), a3) : null;
          });
        }
        setImageNaturalSizeAttributes(t4) {
          const e4 = t4.getAttribute("src");
          e4 && (t4.getAttribute("width") || t4.getAttribute("height") || this.editor.model.change((n3) => {
            const o3 = new zo2.window.Image();
            this._domEmitter.listenTo(o3, "load", () => {
              t4.getAttribute("width") || t4.getAttribute("height") || this.editor.model.enqueueChange(n3.batch, (e5) => {
                e5.setAttribute("width", o3.naturalWidth, t4), e5.setAttribute("height", o3.naturalHeight, t4);
              }), this._domEmitter.stopListening(o3, "load");
            }), o3.src = e4;
          }));
        }
        getClosestSelectedImageWidget(t4) {
          const e4 = t4.getFirstPosition();
          if (!e4)
            return null;
          const n3 = t4.getSelectedElement();
          if (n3 && this.isImageWidget(n3))
            return n3;
          let o3 = e4.parent;
          for (; o3; ) {
            if (o3.is("element") && this.isImageWidget(o3))
              return o3;
            o3 = o3.parent;
          }
          return null;
        }
        getClosestSelectedImageElement(t4) {
          const e4 = t4.getSelectedElement();
          return this.isImage(e4) ? e4 : t4.getFirstPosition().findAncestor("imageBlock");
        }
        getImageWidgetFromImageView(t4) {
          return t4.findAncestor({ classes: MA });
        }
        isImageAllowed() {
          const t4 = this.editor.model.document.selection;
          return function(t5, e4) {
            const n3 = NA(t5, e4, null);
            if ("imageBlock" == n3) {
              const n4 = function(t6, e5) {
                const n5 = Qk2(t6, e5), o3 = n5.start.parent;
                if (o3.isEmpty && !o3.is("element", "$root"))
                  return o3.parent;
                return o3;
              }(e4, t5.model);
              if (t5.model.schema.checkChild(n4, "imageBlock"))
                return true;
            } else if (t5.model.schema.checkChild(e4.focus, "imageInline"))
              return true;
            return false;
          }(this.editor, t4) && function(t5) {
            return [...t5.focus.getAncestors()].every((t6) => !t6.is("element", "imageBlock"));
          }(t4);
        }
        toImageWidget(t4, e4, n3) {
          e4.setCustomProperty("image", true, t4);
          return Wk2(t4, e4, { label: () => {
            const e5 = this.findViewImgElement(t4).getAttribute("alt");
            return e5 ? `${e5} ${n3}` : n3;
          } });
        }
        isImageWidget(t4) {
          return !!t4.getCustomProperty("image") && Gk2(t4);
        }
        isBlockImage(t4) {
          return !!t4 && t4.is("element", "imageBlock");
        }
        isInlineImage(t4) {
          return !!t4 && t4.is("element", "imageInline");
        }
        findViewImgElement(t4) {
          if (this.isInlineImageView(t4))
            return t4;
          const e4 = this.editor.editing.view;
          for (const { item: n3 } of e4.createRangeIn(t4))
            if (this.isInlineImageView(n3))
              return n3;
        }
        destroy() {
          return this._domEmitter.stopListening(), super.destroy();
        }
      }
      function NA(t4, e4, n3) {
        const o3 = t4.model.schema, i3 = t4.config.get("image.insert.type");
        return t4.plugins.has("ImageBlockEditing") ? t4.plugins.has("ImageInlineEditing") ? n3 || ("inline" === i3 ? "imageInline" : "block" === i3 ? "imageBlock" : e4.is("selection") ? _A(o3, e4) : o3.checkChild(e4, "imageInline") ? "imageInline" : "imageBlock") : "imageBlock" : "imageInline";
      }
      class PA extends Qr {
        refresh() {
          const t4 = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!t4, this.isEnabled && t4.hasAttribute("alt") ? this.value = t4.getAttribute("alt") : this.value = false;
        }
        execute(t4) {
          const e4 = this.editor, n3 = e4.plugins.get("ImageUtils"), o3 = e4.model, i3 = n3.getClosestSelectedImageElement(o3.document.selection);
          o3.change((e5) => {
            e5.setAttribute("alt", t4.newValue, i3);
          });
        }
      }
      class zA extends $r {
        static get requires() {
          return [BA];
        }
        static get pluginName() {
          return "ImageTextAlternativeEditing";
        }
        init() {
          this.editor.commands.add("imageTextAlternative", new PA(this.editor));
        }
      }
      var OA = n2(1905), LA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(OA.Z, LA);
      OA.Z.locals;
      var jA = n2(6764), RA = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(jA.Z, RA);
      jA.Z.locals;
      class FA extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = this.locale.t;
          this.focusTracker = new Ii2(), this.keystrokes = new Ti2(), this.labeledInput = this._createLabeledInputView(), this.saveButtonView = this._createButton(e4("Save"), Bg2.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(e4("Cancel"), Bg2.cancel, "ck-button-cancel", "cancel"), this._focusables = new Li2(), this._focusCycler = new qr({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-text-alternative-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.labeledInput, this.saveButtonView, this.cancelButtonView] });
        }
        render() {
          super.render(), this.keystrokes.listenTo(this.element), i2({ view: this }), [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach((t4) => {
            this._focusables.add(t4), this.focusTracker.add(t4.element);
          });
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        _createButton(t4, e4, n3, o3) {
          const i3 = new br(this.locale);
          return i3.set({ label: t4, icon: e4, tooltip: true }), i3.extendTemplate({ attributes: { class: n3 } }), o3 && i3.delegate("execute").to(this, o3), i3;
        }
        _createLabeledInputView() {
          const t4 = this.locale.t, e4 = new Ir(this.locale, ap);
          return e4.label = t4("Text alternative"), e4;
        }
      }
      function VA(t4) {
        const e4 = t4.editing.view, n3 = em.defaultPositions, o3 = t4.plugins.get("ImageUtils");
        return { target: e4.domConverter.mapViewToDom(o3.getClosestSelectedImageWidget(e4.document.selection)), positions: [n3.northArrowSouth, n3.northArrowSouthWest, n3.northArrowSouthEast, n3.southArrowNorth, n3.southArrowNorthWest, n3.southArrowNorthEast, n3.viewportStickyNorth] };
      }
      class HA extends $r {
        static get requires() {
          return [Wm];
        }
        static get pluginName() {
          return "ImageTextAlternativeUI";
        }
        init() {
          this._createButton();
        }
        destroy() {
          super.destroy(), this._form && this._form.destroy();
        }
        _createButton() {
          const t4 = this.editor, e4 = t4.t;
          t4.ui.componentFactory.add("imageTextAlternative", (n3) => {
            const o3 = t4.commands.get("imageTextAlternative"), i3 = new br(n3);
            return i3.set({ label: e4("Change image text alternative"), icon: Bg2.lowVision, tooltip: true }), i3.bind("isEnabled").to(o3, "isEnabled"), i3.bind("isOn").to(o3, "value", (t5) => !!t5), this.listenTo(i3, "execute", () => {
              this._showForm();
            }), i3;
          });
        }
        _createForm() {
          const n3 = this.editor, o3 = n3.editing.view.document, i3 = n3.plugins.get("ImageUtils");
          this._balloon = this.editor.plugins.get("ContextualBalloon"), this._form = new (e3(FA))(n3.locale), this._form.render(), this.listenTo(this._form, "submit", () => {
            n3.execute("imageTextAlternative", { newValue: this._form.labeledInput.fieldView.element.value }), this._hideForm(true);
          }), this.listenTo(this._form, "cancel", () => {
            this._hideForm(true);
          }), this._form.keystrokes.set("Esc", (t4, e4) => {
            this._hideForm(true), e4();
          }), this.listenTo(n3.ui, "update", () => {
            i3.getClosestSelectedImageWidget(o3.selection) ? this._isVisible && function(t4) {
              const e4 = t4.plugins.get("ContextualBalloon");
              if (t4.plugins.get("ImageUtils").getClosestSelectedImageWidget(t4.editing.view.document.selection)) {
                const n4 = VA(t4);
                e4.updatePosition(n4);
              }
            }(n3) : this._hideForm(true);
          }), t3({ emitter: this._form, activator: () => this._isVisible, contextElements: () => [this._balloon.view.element], callback: () => this._hideForm() });
        }
        _showForm() {
          if (this._isVisible)
            return;
          this._form || this._createForm();
          const t4 = this.editor, e4 = t4.commands.get("imageTextAlternative"), n3 = this._form.labeledInput;
          this._form.disableCssTransitions(), this._isInBalloon || this._balloon.add({ view: this._form, position: VA(t4) }), n3.fieldView.value = n3.fieldView.element.value = e4.value || "", this._form.labeledInput.fieldView.select(), this._form.enableCssTransitions();
        }
        _hideForm(t4 = false) {
          this._isInBalloon && (this._form.focusTracker.isFocused && this._form.saveButtonView.focus(), this._balloon.remove(this._form), t4 && this.editor.editing.view.focus());
        }
        get _isVisible() {
          return !!this._balloon && this._balloon.visibleView === this._form;
        }
        get _isInBalloon() {
          return !!this._balloon && this._balloon.hasView(this._form);
        }
      }
      class UA extends $r {
        static get requires() {
          return [zA, HA];
        }
        static get pluginName() {
          return "ImageTextAlternative";
        }
      }
      function qA(t4, e4) {
        const n3 = (e5, n4, o3) => {
          if (!o3.consumable.consume(n4.item, e5.name))
            return;
          const i3 = o3.writer, r3 = o3.mapper.toViewElement(n4.item), s3 = t4.findViewImgElement(r3);
          null === n4.attributeNewValue ? (i3.removeAttribute("srcset", s3), i3.removeAttribute("sizes", s3)) : n4.attributeNewValue && (i3.setAttribute("srcset", n4.attributeNewValue, s3), i3.setAttribute("sizes", "100vw", s3));
        };
        return (t5) => {
          t5.on(`attribute:srcset:${e4}`, n3);
        };
      }
      function GA(t4, e4, n3) {
        const o3 = (e5, n4, o4) => {
          if (!o4.consumable.consume(n4.item, e5.name))
            return;
          const i3 = o4.writer, r3 = o4.mapper.toViewElement(n4.item), s3 = t4.findViewImgElement(r3);
          i3.setAttribute(n4.attributeKey, n4.attributeNewValue || "", s3);
        };
        return (t5) => {
          t5.on(`attribute:${n3}:${e4}`, o3);
        };
      }
      class WA extends Pc2 {
        observe(t4) {
          this.listenTo(t4, "load", (t5, e4) => {
            const n3 = e4.target;
            this.checkShouldIgnoreEventFromTarget(n3) || "IMG" == n3.tagName && this._fireEvents(e4);
          }, { useCapture: true });
        }
        stopObserving(t4) {
          this.stopListening(t4);
        }
        _fireEvents(t4) {
          this.isEnabled && (this.document.fire("layoutChanged"), this.document.fire("imageLoaded", t4));
        }
      }
      var KA = Object.defineProperty, YA = Object.getOwnPropertySymbols, $A = Object.prototype.hasOwnProperty, ZA = Object.prototype.propertyIsEnumerable, QA = (t4, e4, n3) => e4 in t4 ? KA(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, JA = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          $A.call(e4, n3) && QA(t4, n3, e4[n3]);
        if (YA)
          for (var n3 of YA(e4))
            ZA.call(e4, n3) && QA(t4, n3, e4[n3]);
        return t4;
      };
      class XA extends Qr {
        constructor(t4) {
          super(t4);
          const e4 = t4.config.get("image.insert.type");
          t4.plugins.has("ImageBlockEditing") || "block" === e4 && C2("image-block-plugin-required"), t4.plugins.has("ImageInlineEditing") || "inline" === e4 && C2("image-inline-plugin-required");
        }
        refresh() {
          const t4 = this.editor.plugins.get("ImageUtils");
          this.isEnabled = t4.isImageAllowed();
        }
        execute(t4) {
          const e4 = _i(t4.source), n3 = this.editor.model.document.selection, o3 = this.editor.plugins.get("ImageUtils"), i3 = Object.fromEntries(n3.getAttributes());
          e4.forEach((t5, e5) => {
            const r3 = n3.getSelectedElement();
            if ("string" == typeof t5 && (t5 = { src: t5 }), e5 && r3 && o3.isImage(r3)) {
              const e6 = this.editor.model.createPositionAfter(r3);
              o3.insertImage(JA(JA({}, t5), i3), e6);
            } else
              o3.insertImage(JA(JA({}, t5), i3));
          });
        }
      }
      class tC extends Qr {
        refresh() {
          const t4 = this.editor.plugins.get("ImageUtils"), e4 = this.editor.model.document.selection.getSelectedElement();
          this.isEnabled = t4.isImage(e4), this.value = this.isEnabled ? e4.getAttribute("src") : null;
        }
        execute(t4) {
          const e4 = this.editor.model.document.selection.getSelectedElement();
          this.editor.model.change((n3) => {
            n3.setAttribute("src", t4.source, e4), n3.removeAttribute("srcset", e4), n3.removeAttribute("sizes", e4);
          });
        }
      }
      class eC extends $r {
        static get requires() {
          return [BA];
        }
        static get pluginName() {
          return "ImageEditing";
        }
        init() {
          const t4 = this.editor, e4 = t4.conversion;
          t4.editing.view.addObserver(WA), e4.for("upcast").attributeToAttribute({ view: { name: "img", key: "alt" }, model: "alt" }).attributeToAttribute({ view: { name: "img", key: "srcset" }, model: "srcset" });
          const n3 = new XA(t4), o3 = new tC(t4);
          t4.commands.add("insertImage", n3), t4.commands.add("replaceImageSource", o3), t4.commands.add("imageInsert", n3);
        }
      }
      class nC extends $r {
        static get requires() {
          return [BA];
        }
        static get pluginName() {
          return "ImageSizeAttributes";
        }
        afterInit() {
          this._registerSchema(), this._registerConverters("imageBlock"), this._registerConverters("imageInline");
        }
        _registerSchema() {
          this.editor.plugins.has("ImageBlockEditing") && this.editor.model.schema.extend("imageBlock", { allowAttributes: ["width", "height"] }), this.editor.plugins.has("ImageInlineEditing") && this.editor.model.schema.extend("imageInline", { allowAttributes: ["width", "height"] });
        }
        _registerConverters(t4) {
          const e4 = this.editor, n3 = e4.plugins.get("ImageUtils"), o3 = "imageBlock" === t4 ? "figure" : "img";
          function i3(e5, o4, i4, r3) {
            e5.on(`attribute:${o4}:${t4}`, (e6, o5, s3) => {
              if (!s3.consumable.consume(o5.item, e6.name))
                return;
              const a3 = s3.writer, c3 = s3.mapper.toViewElement(o5.item), l3 = n3.findViewImgElement(c3);
              if (null !== o5.attributeNewValue ? a3.setAttribute(i4, o5.attributeNewValue, l3) : a3.removeAttribute(i4, l3), o5.item.hasAttribute("sources"))
                return;
              const d3 = o5.item.hasAttribute("resizedWidth");
              if ("imageInline" === t4 && !d3 && !r3)
                return;
              const h3 = o5.item.getAttribute("width"), u3 = o5.item.getAttribute("height"), g3 = l3.getStyle("aspect-ratio");
              h3 && u3 && !g3 && a3.setStyle("aspect-ratio", `${h3}/${u3}`, l3);
            });
          }
          e4.conversion.for("upcast").attributeToAttribute({ view: { name: o3, styles: { width: /.+/ } }, model: { key: "width", value: (t5) => yA(t5) ? vA(t5.getStyle("width")) : null } }).attributeToAttribute({ view: { name: o3, key: "width" }, model: "width" }).attributeToAttribute({ view: { name: o3, styles: { height: /.+/ } }, model: { key: "height", value: (t5) => yA(t5) ? vA(t5.getStyle("height")) : null } }).attributeToAttribute({ view: { name: o3, key: "height" }, model: "height" }), e4.conversion.for("editingDowncast").add((t5) => {
            i3(t5, "width", "width", true), i3(t5, "height", "height", true);
          }), e4.conversion.for("dataDowncast").add((t5) => {
            i3(t5, "width", "width", false), i3(t5, "height", "height", false);
          });
        }
      }
      class oC extends Qr {
        constructor(t4, e4) {
          super(t4), this._modelElementName = e4;
        }
        refresh() {
          const t4 = this.editor.plugins.get("ImageUtils"), e4 = t4.getClosestSelectedImageElement(this.editor.model.document.selection);
          "imageBlock" === this._modelElementName ? this.isEnabled = t4.isInlineImage(e4) : this.isEnabled = t4.isBlockImage(e4);
        }
        execute(t4 = {}) {
          const e4 = this.editor, n3 = this.editor.model, o3 = e4.plugins.get("ImageUtils"), i3 = o3.getClosestSelectedImageElement(n3.document.selection), r3 = Object.fromEntries(i3.getAttributes());
          return r3.src || r3.uploadId ? n3.change((e5) => {
            const { setImageSizes: s3 = true } = t4, a3 = Array.from(n3.markers).filter((t5) => t5.getRange().containsItem(i3)), c3 = o3.insertImage(r3, n3.createSelection(i3, "on"), this._modelElementName, { setImageSizes: s3 });
            if (!c3)
              return null;
            const l3 = e5.createRangeOn(c3);
            for (const t5 of a3) {
              const n4 = t5.getRange(), o4 = "$graveyard" != n4.root.rootName ? n4.getJoined(l3, true) : l3;
              e5.updateMarker(t5, { range: o4 });
            }
            return { oldElement: i3, newElement: c3 };
          }) : null;
        }
      }
      class iC extends $r {
        static get requires() {
          return [eC, nC, BA, Zf2];
        }
        static get pluginName() {
          return "ImageBlockEditing";
        }
        init() {
          const t4 = this.editor;
          t4.model.schema.register("imageBlock", { inheritAllFrom: "$blockObject", allowAttributes: ["alt", "src", "srcset"] }), this._setupConversion(), t4.plugins.has("ImageInlineEditing") && (t4.commands.add("imageTypeBlock", new oC(this.editor, "imageBlock")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const t4 = this.editor, e4 = t4.t, n3 = t4.conversion, o3 = t4.plugins.get("ImageUtils");
          n3.for("dataDowncast").elementToStructure({ model: "imageBlock", view: (t5, { writer: e5 }) => AA(e5) }), n3.for("editingDowncast").elementToStructure({ model: "imageBlock", view: (t5, { writer: n4 }) => o3.toImageWidget(AA(n4), n4, e4("image widget")) }), n3.for("downcast").add(GA(o3, "imageBlock", "src")).add(GA(o3, "imageBlock", "alt")).add(qA(o3, "imageBlock")), n3.for("upcast").elementToElement({ view: CA(t4, "imageBlock"), model: (t5, { writer: e5 }) => e5.createElement("imageBlock", t5.hasAttribute("src") ? { src: t5.getAttribute("src") } : void 0) }).add(function(t5) {
            const e5 = (e6, n4, o4) => {
              if (!o4.consumable.test(n4.viewItem, { name: true, classes: "image" }))
                return;
              const i3 = t5.findViewImgElement(n4.viewItem);
              if (!i3 || !o4.consumable.test(i3, { name: true }))
                return;
              o4.consumable.consume(n4.viewItem, { name: true, classes: "image" });
              const r3 = Si2(o4.convertItem(i3, n4.modelCursor).modelRange.getItems());
              r3 ? (o4.convertChildren(n4.viewItem, r3), o4.updateConversionResult(r3, n4)) : o4.consumable.revert(n4.viewItem, { name: true, classes: "image" });
            };
            return (t6) => {
              t6.on("element:figure", e5);
            };
          }(o3));
        }
        _setupClipboardIntegration() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, o3 = t4.plugins.get("ImageUtils"), i3 = t4.plugins.get("ClipboardPipeline");
          this.listenTo(i3, "inputTransformation", (i4, r3) => {
            const s3 = Array.from(r3.content.getChildren());
            let a3;
            if (!s3.every(o3.isInlineImageView))
              return;
            a3 = r3.targetRanges ? t4.editing.mapper.toModelRange(r3.targetRanges[0]) : e4.document.selection.getFirstRange();
            const c3 = e4.createSelection(a3);
            if ("imageBlock" === _A(e4.schema, c3)) {
              const t5 = new Eg2(n3.document), e5 = s3.map((e6) => t5.createElement("figure", { class: "image" }, e6));
              r3.content = t5.createDocumentFragment(e5);
            }
          }), this.listenTo(i3, "contentInsertion", (t5, n4) => {
            "paste" === n4.method && e4.change((t6) => {
              const e5 = t6.createRangeIn(n4.content);
              for (const t7 of e5.getItems())
                t7.is("element", "imageBlock") && o3.setImageNaturalSizeAttributes(t7);
            });
          });
        }
      }
      var rC = n2(3508), sC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(rC.Z, sC);
      rC.Z.locals;
      class aC extends $r {
        static get requires() {
          return [iC, gb2, UA];
        }
        static get pluginName() {
          return "ImageBlock";
        }
      }
      class cC extends $r {
        static get requires() {
          return [eC, nC, BA, Zf2];
        }
        static get pluginName() {
          return "ImageInlineEditing";
        }
        init() {
          const t4 = this.editor, e4 = t4.model.schema;
          e4.register("imageInline", { inheritAllFrom: "$inlineObject", allowAttributes: ["alt", "src", "srcset"] }), e4.addChildCheck((t5, e5) => {
            if (t5.endsWith("caption") && "imageInline" === e5.name)
              return false;
          }), this._setupConversion(), t4.plugins.has("ImageBlockEditing") && (t4.commands.add("imageTypeInline", new oC(this.editor, "imageInline")), this._setupClipboardIntegration());
        }
        _setupConversion() {
          const t4 = this.editor, e4 = t4.t, n3 = t4.conversion, o3 = t4.plugins.get("ImageUtils");
          n3.for("dataDowncast").elementToElement({ model: "imageInline", view: (t5, { writer: e5 }) => e5.createEmptyElement("img") }), n3.for("editingDowncast").elementToStructure({ model: "imageInline", view: (t5, { writer: n4 }) => o3.toImageWidget(function(t6) {
            return t6.createContainerElement("span", { class: "image-inline" }, t6.createEmptyElement("img"));
          }(n4), n4, e4("image widget")) }), n3.for("downcast").add(GA(o3, "imageInline", "src")).add(GA(o3, "imageInline", "alt")).add(qA(o3, "imageInline")), n3.for("upcast").elementToElement({ view: CA(t4, "imageInline"), model: (t5, { writer: e5 }) => e5.createElement("imageInline", t5.hasAttribute("src") ? { src: t5.getAttribute("src") } : void 0) });
        }
        _setupClipboardIntegration() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view, o3 = t4.plugins.get("ImageUtils"), i3 = t4.plugins.get("ClipboardPipeline");
          this.listenTo(i3, "inputTransformation", (i4, r3) => {
            const s3 = Array.from(r3.content.getChildren());
            let a3;
            if (!s3.every(o3.isBlockImageView))
              return;
            a3 = r3.targetRanges ? t4.editing.mapper.toModelRange(r3.targetRanges[0]) : e4.document.selection.getFirstRange();
            const c3 = e4.createSelection(a3);
            if ("imageInline" === _A(e4.schema, c3)) {
              const t5 = new Eg2(n3.document), e5 = s3.map((e6) => 1 === e6.childCount ? (Array.from(e6.getAttributes()).forEach((n4) => t5.setAttribute(...n4, o3.findViewImgElement(e6))), e6.getChild(0)) : e6);
              r3.content = t5.createDocumentFragment(e5);
            }
          }), this.listenTo(i3, "contentInsertion", (t5, n4) => {
            "paste" === n4.method && e4.change((t6) => {
              const e5 = t6.createRangeIn(n4.content);
              for (const t7 of e5.getItems())
                t7.is("element", "imageInline") && o3.setImageNaturalSizeAttributes(t7);
            });
          });
        }
      }
      class lC extends $r {
        static get requires() {
          return [cC, gb2, UA];
        }
        static get pluginName() {
          return "ImageInline";
        }
      }
      class dC extends $r {
        static get pluginName() {
          return "ImageCaptionUtils";
        }
        static get requires() {
          return [BA];
        }
        getCaptionFromImageModelElement(t4) {
          for (const e4 of t4.getChildren())
            if (e4 && e4.is("element", "caption"))
              return e4;
          return null;
        }
        getCaptionFromModelSelection(t4) {
          const e4 = this.editor.plugins.get("ImageUtils"), n3 = t4.getFirstPosition().findAncestor("caption");
          return n3 && e4.isBlockImage(n3.parent) ? n3 : null;
        }
        matchImageCaptionViewElement(t4) {
          const e4 = this.editor.plugins.get("ImageUtils");
          return "figcaption" == t4.name && e4.isBlockImageView(t4.parent) ? { name: true } : null;
        }
      }
      class hC extends Qr {
        refresh() {
          const t4 = this.editor, e4 = t4.plugins.get("ImageCaptionUtils"), n3 = t4.plugins.get("ImageUtils");
          if (!t4.plugins.has(iC))
            return this.isEnabled = false, void (this.value = false);
          const o3 = t4.model.document.selection, i3 = o3.getSelectedElement();
          if (!i3) {
            const t5 = e4.getCaptionFromModelSelection(o3);
            return this.isEnabled = !!t5, void (this.value = !!t5);
          }
          this.isEnabled = n3.isImage(i3), this.isEnabled ? this.value = !!e4.getCaptionFromImageModelElement(i3) : this.value = false;
        }
        execute(t4 = {}) {
          const { focusCaptionOnShow: e4 } = t4;
          this.editor.model.change((t5) => {
            this.value ? this._hideImageCaption(t5) : this._showImageCaption(t5, e4);
          });
        }
        _showImageCaption(t4, e4) {
          const n3 = this.editor.model.document.selection, o3 = this.editor.plugins.get("ImageCaptionEditing"), i3 = this.editor.plugins.get("ImageUtils");
          let r3 = n3.getSelectedElement();
          const s3 = o3._getSavedCaption(r3);
          i3.isInlineImage(r3) && (this.editor.execute("imageTypeBlock"), r3 = n3.getSelectedElement());
          const a3 = s3 || t4.createElement("caption");
          t4.append(a3, r3), e4 && t4.setSelection(a3, "in");
        }
        _hideImageCaption(t4) {
          const e4 = this.editor, n3 = e4.model.document.selection, o3 = e4.plugins.get("ImageCaptionEditing"), i3 = e4.plugins.get("ImageCaptionUtils");
          let r3, s3 = n3.getSelectedElement();
          s3 ? r3 = i3.getCaptionFromImageModelElement(s3) : (r3 = i3.getCaptionFromModelSelection(n3), s3 = r3.parent), o3._saveCaption(s3, r3), t4.setSelection(s3, "on"), t4.remove(r3);
        }
      }
      class uC extends $r {
        constructor(t4) {
          super(t4), this._savedCaptionsMap = /* @__PURE__ */ new WeakMap();
        }
        static get requires() {
          return [BA, dC];
        }
        static get pluginName() {
          return "ImageCaptionEditing";
        }
        init() {
          const t4 = this.editor, e4 = t4.model.schema;
          e4.isRegistered("caption") ? e4.extend("caption", { allowIn: "imageBlock" }) : e4.register("caption", { allowIn: "imageBlock", allowContentOf: "$block", isLimit: true }), t4.commands.add("toggleImageCaption", new hC(this.editor)), this._setupConversion(), this._setupImageTypeCommandsIntegration(), this._registerCaptionReconversion();
        }
        _setupConversion() {
          const t4 = this.editor, e4 = t4.editing.view, n3 = t4.plugins.get("ImageUtils"), o3 = t4.plugins.get("ImageCaptionUtils"), i3 = t4.t;
          t4.conversion.for("upcast").elementToElement({ view: (t5) => o3.matchImageCaptionViewElement(t5), model: "caption" }), t4.conversion.for("dataDowncast").elementToElement({ model: "caption", view: (t5, { writer: e5 }) => n3.isBlockImage(t5.parent) ? e5.createContainerElement("figcaption") : null }), t4.conversion.for("editingDowncast").elementToElement({ model: "caption", view: (t5, { writer: o4 }) => {
            if (!n3.isBlockImage(t5.parent))
              return null;
            const r3 = o4.createEditableElement("figcaption");
            o4.setCustomProperty("imageCaption", true, r3), r3.placeholder = i3("Enter image caption"), cs({ view: e4, element: r3, keepOnFocus: true });
            const s3 = t5.parent.getAttribute("alt");
            return Zk2(r3, o4, { label: s3 ? i3("Caption for image: %0", [s3]) : i3("Caption for the image") });
          } });
        }
        _setupImageTypeCommandsIntegration() {
          const t4 = this.editor, e4 = t4.plugins.get("ImageUtils"), n3 = t4.plugins.get("ImageCaptionUtils"), o3 = t4.commands.get("imageTypeInline"), i3 = t4.commands.get("imageTypeBlock"), r3 = (t5) => {
            if (!t5.return)
              return;
            const { oldElement: o4, newElement: i4 } = t5.return;
            if (!o4)
              return;
            if (e4.isBlockImage(o4)) {
              const t6 = n3.getCaptionFromImageModelElement(o4);
              if (t6)
                return void this._saveCaption(i4, t6);
            }
            const r4 = this._getSavedCaption(o4);
            r4 && this._saveCaption(i4, r4);
          };
          o3 && this.listenTo(o3, "execute", r3, { priority: "low" }), i3 && this.listenTo(i3, "execute", r3, { priority: "low" });
        }
        _getSavedCaption(t4) {
          const e4 = this._savedCaptionsMap.get(t4);
          return e4 ? Ll.fromJSON(e4) : null;
        }
        _saveCaption(t4, e4) {
          this._savedCaptionsMap.set(t4, e4.toJSON());
        }
        _registerCaptionReconversion() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.plugins.get("ImageUtils"), o3 = t4.plugins.get("ImageCaptionUtils");
          e4.document.on("change:data", () => {
            const i3 = e4.document.differ.getChanges();
            for (const e5 of i3) {
              if ("alt" !== e5.attributeKey)
                continue;
              const i4 = e5.range.start.nodeAfter;
              if (n3.isBlockImage(i4)) {
                const e6 = o3.getCaptionFromImageModelElement(i4);
                if (!e6)
                  return;
                t4.editing.reconvertItem(e6);
              }
            }
          });
        }
      }
      class gC extends $r {
        static get requires() {
          return [dC];
        }
        static get pluginName() {
          return "ImageCaptionUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.editing.view, n3 = t4.plugins.get("ImageCaptionUtils"), o3 = t4.t;
          t4.ui.componentFactory.add("toggleImageCaption", (i3) => {
            const r3 = t4.commands.get("toggleImageCaption"), s3 = new br(i3);
            return s3.set({ icon: Bg2.caption, tooltip: true, isToggleable: true }), s3.bind("isOn", "isEnabled").to(r3, "value", "isEnabled"), s3.bind("label").to(r3, "value", (t5) => o3(t5 ? "Toggle caption off" : "Toggle caption on")), this.listenTo(s3, "execute", () => {
              t4.execute("toggleImageCaption", { focusCaptionOnShow: true });
              const o4 = n3.getCaptionFromModelSelection(t4.model.document.selection);
              if (o4) {
                const n4 = t4.editing.mapper.toViewElement(o4);
                e4.scrollToTheSelection(), e4.change((t5) => {
                  t5.addClass("image__caption_highlighted", n4);
                });
              }
              t4.editing.view.focus();
            }), s3;
          });
        }
      }
      var pC = n2(2640), mC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(pC.Z, mC);
      pC.Z.locals;
      function fC(t4) {
        const e4 = t4.map((t5) => t5.replace("+", "\\+"));
        return new RegExp(`^image\\/(${e4.join("|")})$`);
      }
      function kC(t4) {
        return new Promise((e4, n3) => {
          const o3 = t4.getAttribute("src");
          fetch(o3).then((t5) => t5.blob()).then((t5) => {
            const n4 = bC(t5, o3), i3 = n4.replace("image/", ""), r3 = new File([t5], `image.${i3}`, { type: n4 });
            e4(r3);
          }).catch((t5) => t5 && "TypeError" === t5.name ? function(t6) {
            return function(t7) {
              return new Promise((e5, n4) => {
                const o4 = zo2.document.createElement("img");
                o4.addEventListener("load", () => {
                  const t8 = zo2.document.createElement("canvas");
                  t8.width = o4.width, t8.height = o4.height;
                  t8.getContext("2d").drawImage(o4, 0, 0), t8.toBlob((t9) => t9 ? e5(t9) : n4());
                }), o4.addEventListener("error", () => n4()), o4.src = t7;
              });
            }(t6).then((e5) => {
              const n4 = bC(e5, t6), o4 = n4.replace("image/", "");
              return new File([e5], `image.${o4}`, { type: n4 });
            });
          }(o3).then(e4).catch(n3) : n3(t5));
        });
      }
      function bC(t4, e4) {
        return t4.type ? t4.type : e4.match(/data:(image\/\w+);base64/) ? e4.match(/data:(image\/\w+);base64/)[1].toLowerCase() : "image/jpeg";
      }
      class wC extends $r {
        static get pluginName() {
          return "ImageUploadUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.t, n3 = (n4) => {
            const o3 = new pw(n4), i3 = t4.commands.get("uploadImage"), r3 = t4.config.get("image.upload.types"), s3 = fC(r3);
            return o3.set({ acceptedType: r3.map((t5) => `image/${t5}`).join(","), allowMultipleFiles: true }), o3.buttonView.set({ label: e4("Insert image"), icon: Bg2.image, tooltip: true }), o3.buttonView.bind("isEnabled").to(i3), o3.on("done", (e5, n5) => {
              const o4 = Array.from(n5).filter((t5) => s3.test(t5.type));
              o4.length && (t4.execute("uploadImage", { file: o4 }), t4.editing.view.focus());
            }), o3;
          };
          t4.ui.componentFactory.add("uploadImage", n3), t4.ui.componentFactory.add("imageUpload", n3);
        }
      }
      var AC = n2(3689), CC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(AC.Z, CC);
      AC.Z.locals;
      var _C = n2(4036), vC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(_C.Z, vC);
      _C.Z.locals;
      var yC = n2(3773), xC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(yC.Z, xC);
      yC.Z.locals;
      class EC extends $r {
        constructor(t4) {
          super(t4), this.uploadStatusChange = (t5, e4, n3) => {
            const o3 = this.editor, i3 = e4.item, r3 = i3.getAttribute("uploadId");
            if (!n3.consumable.consume(e4.item, t5.name))
              return;
            const s3 = o3.plugins.get("ImageUtils"), a3 = o3.plugins.get(uw), c3 = r3 ? e4.attributeNewValue : null, l3 = this.placeholder, d3 = o3.editing.mapper.toViewElement(i3), h3 = n3.writer;
            if ("reading" == c3)
              return DC(d3, h3), void SC(s3, l3, d3, h3);
            if ("uploading" == c3) {
              const t6 = a3.loaders.get(r3);
              return DC(d3, h3), void (t6 ? (IC(d3, h3), function(t7, e5, n4, o4) {
                const i4 = function(t8) {
                  const e6 = t8.createUIElement("div", { class: "ck-progress-bar" });
                  return t8.setCustomProperty("progressBar", true, e6), e6;
                }(e5);
                e5.insert(e5.createPositionAt(t7, "end"), i4), n4.on("change:uploadedPercent", (t8, e6, n5) => {
                  o4.change((t9) => {
                    t9.setStyle("width", n5 + "%", i4);
                  });
                });
              }(d3, h3, t6, o3.editing.view), function(t7, e5, n4, o4) {
                if (o4.data) {
                  const i4 = t7.findViewImgElement(e5);
                  n4.setAttribute("src", o4.data, i4);
                }
              }(s3, d3, h3, t6)) : SC(s3, l3, d3, h3));
            }
            "complete" == c3 && a3.loaders.get(r3) && function(t6, e5, n4) {
              const o4 = e5.createUIElement("div", { class: "ck-image-upload-complete-icon" });
              e5.insert(e5.createPositionAt(t6, "end"), o4), setTimeout(() => {
                n4.change((t7) => t7.remove(t7.createRangeOn(o4)));
              }, 3e3);
            }(d3, h3, o3.editing.view), function(t6, e5) {
              MC(t6, e5, "progressBar");
            }(d3, h3), IC(d3, h3), function(t6, e5) {
              e5.removeClass("ck-appear", t6);
            }(d3, h3);
          }, this.placeholder = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
        }
        static get pluginName() {
          return "ImageUploadProgress";
        }
        init() {
          const t4 = this.editor;
          t4.plugins.has("ImageBlockEditing") && t4.editing.downcastDispatcher.on("attribute:uploadStatus:imageBlock", this.uploadStatusChange), t4.plugins.has("ImageInlineEditing") && t4.editing.downcastDispatcher.on("attribute:uploadStatus:imageInline", this.uploadStatusChange);
        }
      }
      function DC(t4, e4) {
        t4.hasClass("ck-appear") || e4.addClass("ck-appear", t4);
      }
      function SC(t4, e4, n3, o3) {
        n3.hasClass("ck-image-upload-placeholder") || o3.addClass("ck-image-upload-placeholder", n3);
        const i3 = t4.findViewImgElement(n3);
        i3.getAttribute("src") !== e4 && o3.setAttribute("src", e4, i3), TC(n3, "placeholder") || o3.insert(o3.createPositionAfter(i3), function(t5) {
          const e5 = t5.createUIElement("div", { class: "ck-upload-placeholder-loader" });
          return t5.setCustomProperty("placeholder", true, e5), e5;
        }(o3));
      }
      function IC(t4, e4) {
        t4.hasClass("ck-image-upload-placeholder") && e4.removeClass("ck-image-upload-placeholder", t4), MC(t4, e4, "placeholder");
      }
      function TC(t4, e4) {
        for (const n3 of t4.getChildren())
          if (n3.getCustomProperty(e4))
            return n3;
      }
      function MC(t4, e4, n3) {
        const o3 = TC(t4, n3);
        o3 && e4.remove(e4.createRangeOn(o3));
      }
      var BC = Object.defineProperty, NC = Object.defineProperties, PC = Object.getOwnPropertyDescriptors, zC = Object.getOwnPropertySymbols, OC = Object.prototype.hasOwnProperty, LC = Object.prototype.propertyIsEnumerable, jC = (t4, e4, n3) => e4 in t4 ? BC(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3;
      class RC extends Qr {
        refresh() {
          const t4 = this.editor, e4 = t4.plugins.get("ImageUtils"), n3 = t4.model.document.selection.getSelectedElement();
          this.isEnabled = e4.isImageAllowed() || e4.isImage(n3);
        }
        execute(t4) {
          const e4 = _i(t4.file), n3 = this.editor.model.document.selection, o3 = this.editor.plugins.get("ImageUtils"), i3 = Object.fromEntries(n3.getAttributes());
          e4.forEach((t5, e5) => {
            const r3 = n3.getSelectedElement();
            if (e5 && r3 && o3.isImage(r3)) {
              const e6 = this.editor.model.createPositionAfter(r3);
              this._uploadImage(t5, i3, e6);
            } else
              this._uploadImage(t5, i3);
          });
        }
        _uploadImage(t4, e4, n3) {
          const o3 = this.editor, i3 = o3.plugins.get(uw).createLoader(t4), r3 = o3.plugins.get("ImageUtils");
          var s3, a3;
          i3 && r3.insertImage((s3 = ((t5, e5) => {
            for (var n4 in e5 || (e5 = {}))
              OC.call(e5, n4) && jC(t5, n4, e5[n4]);
            if (zC)
              for (var n4 of zC(e5))
                LC.call(e5, n4) && jC(t5, n4, e5[n4]);
            return t5;
          })({}, e4), a3 = { uploadId: i3.id }, NC(s3, PC(a3))), n3);
        }
      }
      class FC extends $r {
        constructor(t4) {
          super(t4), t4.config.define("image", { upload: { types: ["jpeg", "png", "gif", "bmp", "webp", "tiff"] } }), this._uploadImageElements = /* @__PURE__ */ new Map();
        }
        static get requires() {
          return [uw, Rm, Zf2, BA];
        }
        static get pluginName() {
          return "ImageUploadEditing";
        }
        init() {
          const t4 = this.editor, e4 = t4.model.document, n3 = t4.conversion, o3 = t4.plugins.get(uw), i3 = t4.plugins.get("ImageUtils"), r3 = t4.plugins.get("ClipboardPipeline"), s3 = fC(t4.config.get("image.upload.types")), a3 = new RC(t4);
          t4.commands.add("uploadImage", a3), t4.commands.add("imageUpload", a3), n3.for("upcast").attributeToAttribute({ view: { name: "img", key: "uploadId" }, model: "uploadId" }), this.listenTo(t4.editing.view.document, "clipboardInput", (e5, n4) => {
            if (o4 = n4.dataTransfer, Array.from(o4.types).includes("text/html") && "" !== o4.getData("text/html"))
              return;
            var o4;
            const i4 = Array.from(n4.dataTransfer.files).filter((t5) => !!t5 && s3.test(t5.type));
            i4.length && (e5.stop(), t4.model.change((e6) => {
              n4.targetRanges && e6.setSelection(n4.targetRanges.map((e7) => t4.editing.mapper.toModelRange(e7))), t4.execute("uploadImage", { file: i4 });
            }));
          }), this.listenTo(r3, "inputTransformation", (e5, n4) => {
            const r4 = Array.from(t4.editing.view.createRangeIn(n4.content)).map((t5) => t5.item).filter((t5) => function(t6, e6) {
              return !(!t6.isInlineImageView(e6) || !e6.getAttribute("src") || !e6.getAttribute("src").match(/^data:image\/\w+;base64,/g) && !e6.getAttribute("src").match(/^blob:/g));
            }(i3, t5) && !t5.getAttribute("uploadProcessed")).map((t5) => ({ promise: kC(t5), imageElement: t5 }));
            if (!r4.length)
              return;
            const s4 = new Eg2(t4.editing.view.document);
            for (const t5 of r4) {
              s4.setAttribute("uploadProcessed", true, t5.imageElement);
              const e6 = o3.createLoader(t5.promise);
              e6 && (s4.setAttribute("src", "", t5.imageElement), s4.setAttribute("uploadId", e6.id, t5.imageElement));
            }
          }), t4.editing.view.document.on("dragover", (t5, e5) => {
            e5.preventDefault();
          }), e4.on("change", () => {
            const n4 = e4.differ.getChanges({ includeChangesInGraveyard: true }).reverse(), i4 = /* @__PURE__ */ new Set();
            for (const e5 of n4)
              if ("insert" == e5.type && "$text" != e5.name) {
                const n5 = e5.position.nodeAfter, r4 = "$graveyard" == e5.position.root.rootName;
                for (const e6 of VC(t4, n5)) {
                  const t5 = e6.getAttribute("uploadId");
                  if (!t5)
                    continue;
                  const n6 = o3.loaders.get(t5);
                  n6 && (r4 ? i4.has(t5) || n6.abort() : (i4.add(t5), this._uploadImageElements.set(t5, e6), "idle" == n6.status && this._readAndUpload(n6)));
                }
              }
          }), this.on("uploadComplete", (t5, { imageElement: e5, data: n4 }) => {
            const o4 = n4.urls ? n4.urls : n4;
            this.editor.model.change((t6) => {
              t6.setAttribute("src", o4.default, e5), this._parseAndSetSrcsetAttributeOnImage(o4, e5, t6), i3.setImageNaturalSizeAttributes(e5);
            });
          }, { priority: "low" });
        }
        afterInit() {
          const t4 = this.editor.model.schema;
          this.editor.plugins.has("ImageBlockEditing") && t4.extend("imageBlock", { allowAttributes: ["uploadId", "uploadStatus"] }), this.editor.plugins.has("ImageInlineEditing") && t4.extend("imageInline", { allowAttributes: ["uploadId", "uploadStatus"] });
        }
        _readAndUpload(t4) {
          const e4 = this.editor, n3 = e4.model, o3 = e4.locale.t, i3 = e4.plugins.get(uw), r3 = e4.plugins.get(Rm), s3 = e4.plugins.get("ImageUtils"), c3 = this._uploadImageElements;
          return n3.enqueueChange({ isUndoable: false }, (e5) => {
            e5.setAttribute("uploadStatus", "reading", c3.get(t4.id));
          }), t4.read().then(() => {
            const o4 = t4.upload(), i4 = c3.get(t4.id);
            if (a2.isSafari) {
              const t5 = e4.editing.mapper.toViewElement(i4), n4 = s3.findViewImgElement(t5);
              e4.editing.view.once("render", () => {
                if (!n4.parent)
                  return;
                const t6 = e4.editing.view.domConverter.mapViewToDom(n4.parent);
                if (!t6)
                  return;
                const o5 = t6.style.display;
                t6.style.display = "none", t6._ckHack = t6.offsetHeight, t6.style.display = o5;
              });
            }
            return n3.enqueueChange({ isUndoable: false }, (t5) => {
              t5.setAttribute("uploadStatus", "uploading", i4);
            }), o4;
          }).then((e5) => {
            n3.enqueueChange({ isUndoable: false }, (n4) => {
              const o4 = c3.get(t4.id);
              n4.setAttribute("uploadStatus", "complete", o4), this.fire("uploadComplete", { data: e5, imageElement: o4 });
            }), l3();
          }).catch((e5) => {
            if ("error" !== t4.status && "aborted" !== t4.status)
              throw e5;
            "error" == t4.status && e5 && r3.showWarning(e5, { title: o3("Upload failed"), namespace: "upload" }), n3.enqueueChange({ isUndoable: false }, (e6) => {
              e6.remove(c3.get(t4.id));
            }), l3();
          });
          function l3() {
            n3.enqueueChange({ isUndoable: false }, (e5) => {
              const n4 = c3.get(t4.id);
              e5.removeAttribute("uploadId", n4), e5.removeAttribute("uploadStatus", n4), c3.delete(t4.id);
            }), i3.destroyLoader(t4);
          }
        }
        _parseAndSetSrcsetAttributeOnImage(t4, e4, n3) {
          let o3 = 0;
          const i3 = Object.keys(t4).filter((t5) => {
            const e5 = parseInt(t5, 10);
            if (!isNaN(e5))
              return o3 = Math.max(o3, e5), true;
          }).map((e5) => `${t4[e5]} ${e5}w`).join(", ");
          if ("" != i3) {
            const t5 = { srcset: i3 };
            e4.hasAttribute("width") || e4.hasAttribute("height") || (t5.width = o3), n3.setAttributes(t5, e4);
          }
        }
      }
      function VC(t4, e4) {
        const n3 = t4.plugins.get("ImageUtils");
        return Array.from(t4.model.createRangeOn(e4)).filter((t5) => n3.isImage(t5.item)).map((t5) => t5.item);
      }
      var HC = n2(1568), UC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(HC.Z, UC);
      HC.Z.locals;
      var qC = n2(3535), GC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(qC.Z, GC);
      qC.Z.locals;
      var WC = n2(6270), KC = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(WC.Z, KC);
      WC.Z.locals;
      class YC extends Qr {
        constructor(t4, e4) {
          super(t4), this._defaultStyles = { imageBlock: false, imageInline: false }, this._styles = new Map(e4.map((t5) => {
            if (t5.isDefault)
              for (const e5 of t5.modelElements)
                this._defaultStyles[e5] = t5.name;
            return [t5.name, t5];
          }));
        }
        refresh() {
          const t4 = this.editor.plugins.get("ImageUtils").getClosestSelectedImageElement(this.editor.model.document.selection);
          this.isEnabled = !!t4, this.isEnabled ? t4.hasAttribute("imageStyle") ? this.value = t4.getAttribute("imageStyle") : this.value = this._defaultStyles[t4.name] : this.value = false;
        }
        execute(t4 = {}) {
          const e4 = this.editor, n3 = e4.model, o3 = e4.plugins.get("ImageUtils");
          n3.change((e5) => {
            const i3 = t4.value, { setImageSizes: r3 = true } = t4;
            let s3 = o3.getClosestSelectedImageElement(n3.document.selection);
            i3 && this.shouldConvertImageType(i3, s3) && (this.editor.execute(o3.isBlockImage(s3) ? "imageTypeInline" : "imageTypeBlock", { setImageSizes: r3 }), s3 = o3.getClosestSelectedImageElement(n3.document.selection)), !i3 || this._styles.get(i3).isDefault ? e5.removeAttribute("imageStyle", s3) : e5.setAttribute("imageStyle", i3, s3), r3 && o3.setImageNaturalSizeAttributes(s3);
          });
        }
        shouldConvertImageType(t4, e4) {
          return !this._styles.get(t4).modelElements.includes(e4.name);
        }
      }
      var $C = Object.defineProperty, ZC = Object.getOwnPropertySymbols, QC = Object.prototype.hasOwnProperty, JC = Object.prototype.propertyIsEnumerable, XC = (t4, e4, n3) => e4 in t4 ? $C(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, t_ = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          QC.call(e4, n3) && XC(t4, n3, e4[n3]);
        if (ZC)
          for (var n3 of ZC(e4))
            JC.call(e4, n3) && XC(t4, n3, e4[n3]);
        return t4;
      };
      const { objectFullWidth: e_, objectInline: n_, objectLeft: o_, objectRight: i_, objectCenter: r_, objectBlockLeft: s_, objectBlockRight: a_ } = Bg2, c_ = { get inline() {
        return { name: "inline", title: "In line", icon: n_, modelElements: ["imageInline"], isDefault: true };
      }, get alignLeft() {
        return { name: "alignLeft", title: "Left aligned image", icon: o_, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-left" };
      }, get alignBlockLeft() {
        return { name: "alignBlockLeft", title: "Left aligned image", icon: s_, modelElements: ["imageBlock"], className: "image-style-block-align-left" };
      }, get alignCenter() {
        return { name: "alignCenter", title: "Centered image", icon: r_, modelElements: ["imageBlock"], className: "image-style-align-center" };
      }, get alignRight() {
        return { name: "alignRight", title: "Right aligned image", icon: i_, modelElements: ["imageBlock", "imageInline"], className: "image-style-align-right" };
      }, get alignBlockRight() {
        return { name: "alignBlockRight", title: "Right aligned image", icon: a_, modelElements: ["imageBlock"], className: "image-style-block-align-right" };
      }, get block() {
        return { name: "block", title: "Centered image", icon: r_, modelElements: ["imageBlock"], isDefault: true };
      }, get side() {
        return { name: "side", title: "Side image", icon: i_, modelElements: ["imageBlock"], className: "image-style-side" };
      } }, l_ = { full: e_, left: s_, right: a_, center: r_, inlineLeft: o_, inlineRight: i_, inline: n_ }, d_ = [{ name: "imageStyle:wrapText", title: "Wrap text", defaultItem: "imageStyle:alignLeft", items: ["imageStyle:alignLeft", "imageStyle:alignRight"] }, { name: "imageStyle:breakText", title: "Break text", defaultItem: "imageStyle:block", items: ["imageStyle:alignBlockLeft", "imageStyle:block", "imageStyle:alignBlockRight"] }];
      function h_(t4) {
        C2("image-style-configuration-definition-invalid", t4);
      }
      const u_ = { normalizeStyles: function(t4) {
        return (t4.configuredStyles.options || []).map((t5) => function(t6) {
          t6 = "string" == typeof t6 ? c_[t6] ? t_({}, c_[t6]) : { name: t6 } : function(t7, e4) {
            const n3 = t_({}, e4);
            for (const o3 in t7)
              Object.prototype.hasOwnProperty.call(e4, o3) || (n3[o3] = t7[o3]);
            return n3;
          }(c_[t6.name], t6);
          "string" == typeof t6.icon && (t6.icon = l_[t6.icon] || t6.icon);
          return t6;
        }(t5)).filter((e4) => function(t5, { isBlockPluginLoaded: e5, isInlinePluginLoaded: n3 }) {
          const { modelElements: o3, name: i3 } = t5;
          if (!(o3 && o3.length && i3))
            return h_({ style: t5 }), false;
          {
            const i4 = [e5 ? "imageBlock" : null, n3 ? "imageInline" : null];
            if (!o3.some((t6) => i4.includes(t6)))
              return C2("image-style-missing-dependency", { style: t5, missingPlugins: o3.map((t6) => "imageBlock" === t6 ? "ImageBlockEditing" : "ImageInlineEditing") }), false;
          }
          return true;
        }(e4, t4));
      }, getDefaultStylesConfiguration: function(t4, e4) {
        return t4 && e4 ? { options: ["inline", "alignLeft", "alignRight", "alignCenter", "alignBlockLeft", "alignBlockRight", "block", "side"] } : t4 ? { options: ["block", "side"] } : e4 ? { options: ["inline", "alignLeft", "alignRight"] } : {};
      }, getDefaultDropdownDefinitions: function(t4) {
        return t4.has("ImageBlockEditing") && t4.has("ImageInlineEditing") ? [...d_] : [];
      }, warnInvalidStyle: h_, DEFAULT_OPTIONS: c_, DEFAULT_ICONS: l_, DEFAULT_DROPDOWN_DEFINITIONS: d_ };
      function g_(t4, e4) {
        for (const n3 of e4)
          if (n3.name === t4)
            return n3;
      }
      class p_ extends $r {
        static get pluginName() {
          return "ImageStyleEditing";
        }
        static get requires() {
          return [BA];
        }
        init() {
          const { normalizeStyles: t4, getDefaultStylesConfiguration: e4 } = u_, n3 = this.editor, o3 = n3.plugins.has("ImageBlockEditing"), i3 = n3.plugins.has("ImageInlineEditing");
          n3.config.define("image.styles", e4(o3, i3)), this.normalizedStyles = t4({ configuredStyles: n3.config.get("image.styles"), isBlockPluginLoaded: o3, isInlinePluginLoaded: i3 }), this._setupConversion(o3, i3), this._setupPostFixer(), n3.commands.add("imageStyle", new YC(n3, this.normalizedStyles));
        }
        _setupConversion(t4, e4) {
          const n3 = this.editor, o3 = n3.model.schema, i3 = (r3 = this.normalizedStyles, (t5, e5, n4) => {
            if (!n4.consumable.consume(e5.item, t5.name))
              return;
            const o4 = g_(e5.attributeNewValue, r3), i4 = g_(e5.attributeOldValue, r3), s4 = n4.mapper.toViewElement(e5.item), a3 = n4.writer;
            i4 && a3.removeClass(i4.className, s4), o4 && a3.addClass(o4.className, s4);
          });
          var r3;
          const s3 = function(t5) {
            const e5 = { imageInline: t5.filter((t6) => !t6.isDefault && t6.modelElements.includes("imageInline")), imageBlock: t5.filter((t6) => !t6.isDefault && t6.modelElements.includes("imageBlock")) };
            return (t6, n4, o4) => {
              if (!n4.modelRange)
                return;
              const i4 = n4.viewItem, r4 = Si2(n4.modelRange.getItems());
              if (r4 && o4.schema.checkAttribute(r4, "imageStyle"))
                for (const t7 of e5[r4.name])
                  o4.consumable.consume(i4, { classes: t7.className }) && o4.writer.setAttribute("imageStyle", t7.name, r4);
            };
          }(this.normalizedStyles);
          n3.editing.downcastDispatcher.on("attribute:imageStyle", i3), n3.data.downcastDispatcher.on("attribute:imageStyle", i3), t4 && (o3.extend("imageBlock", { allowAttributes: "imageStyle" }), n3.data.upcastDispatcher.on("element:figure", s3, { priority: "low" })), e4 && (o3.extend("imageInline", { allowAttributes: "imageStyle" }), n3.data.upcastDispatcher.on("element:img", s3, { priority: "low" }));
        }
        _setupPostFixer() {
          const t4 = this.editor, e4 = t4.model.document, n3 = t4.plugins.get(BA), o3 = new Map(this.normalizedStyles.map((t5) => [t5.name, t5]));
          e4.registerPostFixer((t5) => {
            let i3 = false;
            for (const r3 of e4.differ.getChanges())
              if ("insert" == r3.type || "attribute" == r3.type && "imageStyle" == r3.attributeKey) {
                let e5 = "insert" == r3.type ? r3.position.nodeAfter : r3.range.start.nodeAfter;
                if (e5 && e5.is("element", "paragraph") && e5.childCount > 0 && (e5 = e5.getChild(0)), !n3.isImage(e5))
                  continue;
                const s3 = e5.getAttribute("imageStyle");
                if (!s3)
                  continue;
                const a3 = o3.get(s3);
                a3 && a3.modelElements.includes(e5.name) || (t5.removeAttribute("imageStyle", e5), i3 = true);
              }
            return i3;
          });
        }
      }
      var m_ = n2(5083), f_ = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(m_.Z, f_);
      m_.Z.locals;
      class k_ extends $r {
        static get requires() {
          return [p_];
        }
        static get pluginName() {
          return "ImageStyleUI";
        }
        get localizedDefaultStylesTitles() {
          const t4 = this.editor.t;
          return { "Wrap text": t4("Wrap text"), "Break text": t4("Break text"), "In line": t4("In line"), "Full size image": t4("Full size image"), "Side image": t4("Side image"), "Left aligned image": t4("Left aligned image"), "Centered image": t4("Centered image"), "Right aligned image": t4("Right aligned image") };
        }
        init() {
          const t4 = this.editor.plugins, e4 = this.editor.config.get("image.toolbar") || [], n3 = b_(t4.get("ImageStyleEditing").normalizedStyles, this.localizedDefaultStylesTitles);
          for (const t5 of n3)
            this._createButton(t5);
          const o3 = b_([...e4.filter(R2), ...u_.getDefaultDropdownDefinitions(t4)], this.localizedDefaultStylesTitles);
          for (const t5 of o3)
            this._createDropdown(t5, n3);
        }
        _createDropdown(t4, e4) {
          const n3 = this.editor.ui.componentFactory;
          n3.add(t4.name, (o3) => {
            let i3;
            const { defaultItem: r3, items: s3, title: a3 } = t4, c3 = s3.filter((t5) => e4.find(({ name: e5 }) => w_(e5) === t5)).map((t5) => {
              const e5 = n3.create(t5);
              return t5 === r3 && (i3 = e5), e5;
            });
            s3.length !== c3.length && u_.warnInvalidStyle({ dropdown: t4 });
            const l3 = tp(o3, $g2), d3 = l3.buttonView, h3 = d3.arrowView;
            return ep(l3, c3, { enableActiveItemFocusOnDropdownOpen: true }), d3.set({ label: A_(a3, i3.label), class: null, tooltip: true }), h3.unbind("label"), h3.set({ label: a3 }), d3.bind("icon").toMany(c3, "isOn", (...t5) => {
              const e5 = t5.findIndex(Xs);
              return e5 < 0 ? i3.icon : c3[e5].icon;
            }), d3.bind("label").toMany(c3, "isOn", (...t5) => {
              const e5 = t5.findIndex(Xs);
              return A_(a3, e5 < 0 ? i3.label : c3[e5].label);
            }), d3.bind("isOn").toMany(c3, "isOn", (...t5) => t5.some(Xs)), d3.bind("class").toMany(c3, "isOn", (...t5) => t5.some(Xs) ? "ck-splitbutton_flatten" : void 0), d3.on("execute", () => {
              c3.some(({ isOn: t5 }) => t5) ? l3.isOpen = !l3.isOpen : i3.fire("execute");
            }), l3.bind("isEnabled").toMany(c3, "isEnabled", (...t5) => t5.some(Xs)), this.listenTo(l3, "execute", () => {
              this.editor.editing.view.focus();
            }), l3;
          });
        }
        _createButton(t4) {
          const e4 = t4.name;
          this.editor.ui.componentFactory.add(w_(e4), (n3) => {
            const o3 = this.editor.commands.get("imageStyle"), i3 = new br(n3);
            return i3.set({ label: t4.title, icon: t4.icon, tooltip: true, isToggleable: true }), i3.bind("isEnabled").to(o3, "isEnabled"), i3.bind("isOn").to(o3, "value", (t5) => t5 === e4), i3.on("execute", this._executeCommand.bind(this, e4)), i3;
          });
        }
        _executeCommand(t4) {
          this.editor.execute("imageStyle", { value: t4 }), this.editor.editing.view.focus();
        }
      }
      function b_(t4, e4) {
        for (const n3 of t4)
          e4[n3.title] && (n3.title = e4[n3.title]);
        return t4;
      }
      function w_(t4) {
        return `imageStyle:${t4}`;
      }
      function A_(t4, e4) {
        return (t4 ? t4 + ": " : "") + e4;
      }
      class C_ extends $r {
        static get pluginName() {
          return "IndentEditing";
        }
        init() {
          const t4 = this.editor;
          t4.commands.add("indent", new Xr(t4)), t4.commands.add("outdent", new Xr(t4));
        }
      }
      const __ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zM1.632 6.95 5.02 9.358a.4.4 0 0 1-.013.661l-3.39 2.207A.4.4 0 0 1 1 11.892V7.275a.4.4 0 0 1 .632-.326z"/></svg>', v_ = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm5 6c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM2.75 16.5h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 1 0 0 1.5zm1.618-9.55L.98 9.358a.4.4 0 0 0 .013.661l3.39 2.207A.4.4 0 0 0 5 11.892V7.275a.4.4 0 0 0-.632-.326z"/></svg>';
      class y_ extends $r {
        static get pluginName() {
          return "IndentUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.locale, n3 = t4.t, o3 = "ltr" == e4.uiLanguageDirection ? __ : v_, i3 = "ltr" == e4.uiLanguageDirection ? v_ : __;
          this._defineButton("indent", n3("Increase indent"), o3), this._defineButton("outdent", n3("Decrease indent"), i3);
        }
        _defineButton(t4, e4, n3) {
          const o3 = this.editor;
          o3.ui.componentFactory.add(t4, (i3) => {
            const r3 = o3.commands.get(t4), s3 = new br(i3);
            return s3.set({ label: e4, icon: n3, tooltip: true }), s3.bind("isEnabled").to(r3, "isEnabled"), this.listenTo(s3, "execute", () => {
              o3.execute(t4), o3.editing.view.focus();
            }), s3;
          });
        }
      }
      class x_ {
        constructor() {
          this._definitions = /* @__PURE__ */ new Set();
        }
        get length() {
          return this._definitions.size;
        }
        add(t4) {
          Array.isArray(t4) ? t4.forEach((t5) => this._definitions.add(t5)) : this._definitions.add(t4);
        }
        getDispatcher() {
          return (t4) => {
            t4.on("attribute:linkHref", (t5, e4, n3) => {
              if (!n3.consumable.test(e4.item, "attribute:linkHref"))
                return;
              if (!e4.item.is("selection") && !n3.schema.isInline(e4.item))
                return;
              const o3 = n3.writer, i3 = o3.document.selection;
              for (const t6 of this._definitions) {
                const r3 = o3.createAttributeElement("a", t6.attributes, { priority: 5 });
                t6.classes && o3.addClass(t6.classes, r3);
                for (const e5 in t6.styles)
                  o3.setStyle(e5, t6.styles[e5], r3);
                o3.setCustomProperty("link", true, r3), t6.callback(e4.attributeNewValue) ? e4.item.is("selection") ? o3.wrap(i3.getFirstRange(), r3) : o3.wrap(n3.mapper.toViewRange(e4.range), r3) : o3.unwrap(n3.mapper.toViewRange(e4.range), r3);
              }
            }, { priority: "high" });
          };
        }
        getDispatcherForLinkedImage() {
          return (t4) => {
            t4.on("attribute:linkHref:imageBlock", (t5, e4, { writer: n3, mapper: o3 }) => {
              const i3 = o3.toViewElement(e4.item), r3 = Array.from(i3.getChildren()).find((t6) => t6.is("element", "a"));
              for (const t6 of this._definitions) {
                const o4 = Mi2(t6.attributes);
                if (t6.callback(e4.attributeNewValue)) {
                  for (const [t7, e5] of o4)
                    "class" === t7 ? n3.addClass(e5, r3) : n3.setAttribute(t7, e5, r3);
                  t6.classes && n3.addClass(t6.classes, r3);
                  for (const e5 in t6.styles)
                    n3.setStyle(e5, t6.styles[e5], r3);
                } else {
                  for (const [t7, e5] of o4)
                    "class" === t7 ? n3.removeClass(e5, r3) : n3.removeAttribute(t7, r3);
                  t6.classes && n3.removeClass(t6.classes, r3);
                  for (const e5 in t6.styles)
                    n3.removeStyle(e5, r3);
                }
              }
            });
          };
        }
      }
      const E_ = function(t4, e4, n3) {
        var o3 = t4.length;
        return n3 = void 0 === n3 ? o3 : n3, !e4 && n3 >= o3 ? t4 : Vs(t4, e4, n3);
      };
      var D_ = RegExp("[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]");
      const S_ = function(t4) {
        return D_.test(t4);
      };
      const I_ = function(t4) {
        return t4.split("");
      };
      var T_ = "\\ud800-\\udfff", M_ = "[" + T_ + "]", B_ = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]", N_ = "\\ud83c[\\udffb-\\udfff]", P_ = "[^" + T_ + "]", z_ = "(?:\\ud83c[\\udde6-\\uddff]){2}", O_ = "[\\ud800-\\udbff][\\udc00-\\udfff]", L_ = "(?:" + B_ + "|" + N_ + ")?", j_ = "[\\ufe0e\\ufe0f]?", R_ = j_ + L_ + ("(?:\\u200d(?:" + [P_, z_, O_].join("|") + ")" + j_ + L_ + ")*"), F_ = "(?:" + [P_ + B_ + "?", B_, z_, O_, M_].join("|") + ")", V_ = RegExp(N_ + "(?=" + N_ + ")|" + F_ + R_, "g");
      const H_ = function(t4) {
        return t4.match(V_) || [];
      };
      const U_ = function(t4) {
        return S_(t4) ? H_(t4) : I_(t4);
      };
      const q_ = function(t4) {
        return function(e4) {
          e4 = Os(e4);
          var n3 = S_(e4) ? U_(e4) : void 0, o3 = n3 ? n3[0] : e4.charAt(0), i3 = n3 ? E_(n3, 1).join("") : e4.slice(1);
          return o3[t4]() + i3;
        };
      }("toUpperCase"), G_ = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, W_ = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i, K_ = /^[\S]+@((?![-_])(?:[-\w\u00a1-\uffff]{0,63}[^-_]\.))+(?:[a-z\u00a1-\uffff]{2,})$/i, Y_ = /^((\w+:(\/{2,})?)|(\W))/i, $_ = "Ctrl+K";
      function Z_(t4, { writer: e4 }) {
        const n3 = e4.createAttributeElement("a", { href: t4 }, { priority: 5 });
        return e4.setCustomProperty("link", true, n3), n3;
      }
      function Q_(t4) {
        const e4 = String(t4);
        return function(t5) {
          const e5 = t5.replace(G_, "");
          return !!e5.match(W_);
        }(e4) ? e4 : "#";
      }
      function J_(t4, e4) {
        return !!t4 && e4.checkAttribute(t4.name, "linkHref");
      }
      function X_(t4, e4) {
        const n3 = (o3 = t4, K_.test(o3) ? "mailto:" : e4);
        var o3;
        const i3 = !!n3 && !tv(t4);
        return t4 && i3 ? n3 + t4 : t4;
      }
      function tv(t4) {
        return Y_.test(t4);
      }
      function ev(t4) {
        window.open(t4, "_blank", "noopener");
      }
      class nv extends Qr {
        constructor() {
          super(...arguments), this.manualDecorators = new Di2(), this.automaticDecorators = new x_();
        }
        restoreManualDecoratorStates() {
          for (const t4 of this.manualDecorators)
            t4.value = this._getDecoratorStateFromModel(t4.id);
        }
        refresh() {
          const t4 = this.editor.model, e4 = t4.document.selection, n3 = e4.getSelectedElement() || Si2(e4.getSelectedBlocks());
          J_(n3, t4.schema) ? (this.value = n3.getAttribute("linkHref"), this.isEnabled = t4.schema.checkAttribute(n3, "linkHref")) : (this.value = e4.getAttribute("linkHref"), this.isEnabled = t4.schema.checkAttributeInSelection(e4, "linkHref"));
          for (const t5 of this.manualDecorators)
            t5.value = this._getDecoratorStateFromModel(t5.id);
        }
        execute(t4, e4 = {}) {
          const n3 = this.editor.model, o3 = n3.document.selection, i3 = [], r3 = [];
          for (const t5 in e4)
            e4[t5] ? i3.push(t5) : r3.push(t5);
          n3.change((e5) => {
            if (o3.isCollapsed) {
              const s3 = o3.getFirstPosition();
              if (o3.hasAttribute("linkHref")) {
                const a3 = ov(o3);
                let c3 = Ek2(s3, "linkHref", o3.getAttribute("linkHref"), n3);
                o3.getAttribute("linkHref") === a3 && (c3 = this._updateLinkContent(n3, e5, c3, t4)), e5.setAttribute("linkHref", t4, c3), i3.forEach((t5) => {
                  e5.setAttribute(t5, true, c3);
                }), r3.forEach((t5) => {
                  e5.removeAttribute(t5, c3);
                }), e5.setSelection(e5.createPositionAfter(c3.end.nodeBefore));
              } else if ("" !== t4) {
                const r4 = Mi2(o3.getAttributes());
                r4.set("linkHref", t4), i3.forEach((t5) => {
                  r4.set(t5, true);
                });
                const { end: a3 } = n3.insertContent(e5.createText(t4, r4), s3);
                e5.setSelection(a3);
              }
              ["linkHref", ...i3, ...r3].forEach((t5) => {
                e5.removeSelectionAttribute(t5);
              });
            } else {
              const s3 = n3.schema.getValidRanges(o3.getRanges(), "linkHref"), a3 = [];
              for (const t5 of o3.getSelectedBlocks())
                n3.schema.checkAttribute(t5, "linkHref") && a3.push(e5.createRangeOn(t5));
              const c3 = a3.slice();
              for (const t5 of s3)
                this._isRangeToUpdate(t5, a3) && c3.push(t5);
              for (const s4 of c3) {
                let a4 = s4;
                if (1 === c3.length) {
                  const i4 = ov(o3);
                  o3.getAttribute("linkHref") === i4 && (a4 = this._updateLinkContent(n3, e5, s4, t4), e5.setSelection(e5.createSelection(a4)));
                }
                e5.setAttribute("linkHref", t4, a4), i3.forEach((t5) => {
                  e5.setAttribute(t5, true, a4);
                }), r3.forEach((t5) => {
                  e5.removeAttribute(t5, a4);
                });
              }
            }
          });
        }
        _getDecoratorStateFromModel(t4) {
          const e4 = this.editor.model, n3 = e4.document.selection, o3 = n3.getSelectedElement();
          return J_(o3, e4.schema) ? o3.getAttribute(t4) : n3.getAttribute(t4);
        }
        _isRangeToUpdate(t4, e4) {
          for (const n3 of e4)
            if (n3.containsRange(t4))
              return false;
          return true;
        }
        _updateLinkContent(t4, e4, n3, o3) {
          const i3 = e4.createText(o3, { linkHref: o3 });
          return t4.insertContent(i3, n3);
        }
      }
      function ov(t4) {
        if (t4.isCollapsed) {
          const e4 = t4.getFirstPosition();
          return e4.textNode && e4.textNode.data;
        }
        {
          const e4 = Array.from(t4.getFirstRange().getItems());
          if (e4.length > 1)
            return null;
          const n3 = e4[0];
          return n3.is("$text") || n3.is("$textProxy") ? n3.data : null;
        }
      }
      class iv extends Qr {
        refresh() {
          const t4 = this.editor.model, e4 = t4.document.selection, n3 = e4.getSelectedElement();
          J_(n3, t4.schema) ? this.isEnabled = t4.schema.checkAttribute(n3, "linkHref") : this.isEnabled = t4.schema.checkAttributeInSelection(e4, "linkHref");
        }
        execute() {
          const t4 = this.editor, e4 = this.editor.model, n3 = e4.document.selection, o3 = t4.commands.get("link");
          e4.change((t5) => {
            const i3 = n3.isCollapsed ? [Ek2(n3.getFirstPosition(), "linkHref", n3.getAttribute("linkHref"), e4)] : e4.schema.getValidRanges(n3.getRanges(), "linkHref");
            for (const e5 of i3)
              if (t5.removeAttribute("linkHref", e5), o3)
                for (const n4 of o3.manualDecorators)
                  t5.removeAttribute(n4.id, e5);
          });
        }
      }
      class rv extends W2() {
        constructor({ id: t4, label: e4, attributes: n3, classes: o3, styles: i3, defaultValue: r3 }) {
          super(), this.id = t4, this.set("value", void 0), this.defaultValue = r3, this.label = e4, this.attributes = n3, this.classes = o3, this.styles = i3;
        }
        _createPattern() {
          return { attributes: this.attributes, classes: this.classes, styles: this.styles };
        }
      }
      var sv = n2(9773), av = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(sv.Z, av);
      sv.Z.locals;
      var cv = Object.defineProperty, lv = Object.getOwnPropertySymbols, dv = Object.prototype.hasOwnProperty, hv = Object.prototype.propertyIsEnumerable, uv = (t4, e4, n3) => e4 in t4 ? cv(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, gv = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          dv.call(e4, n3) && uv(t4, n3, e4[n3]);
        if (lv)
          for (var n3 of lv(e4))
            hv.call(e4, n3) && uv(t4, n3, e4[n3]);
        return t4;
      };
      const pv = "automatic", mv = /^(https?:)?\/\//;
      class fv extends $r {
        static get pluginName() {
          return "LinkEditing";
        }
        static get requires() {
          return [pk2, ek2, Zf2];
        }
        constructor(t4) {
          super(t4), t4.config.define("link", { addTargetToExternalLinks: false });
        }
        init() {
          const t4 = this.editor;
          t4.model.schema.extend("$text", { allowAttributes: "linkHref" }), t4.conversion.for("dataDowncast").attributeToElement({ model: "linkHref", view: Z_ }), t4.conversion.for("editingDowncast").attributeToElement({ model: "linkHref", view: (t5, e5) => Z_(Q_(t5), e5) }), t4.conversion.for("upcast").elementToAttribute({ view: { name: "a", attributes: { href: true } }, model: { key: "linkHref", value: (t5) => t5.getAttribute("href") } }), t4.commands.add("link", new nv(t4)), t4.commands.add("unlink", new iv(t4));
          const e4 = function(t5, e5) {
            const n3 = { "Open in a new tab": t5("Open in a new tab"), Downloadable: t5("Downloadable") };
            return e5.forEach((t6) => ("label" in t6 && n3[t6.label] && (t6.label = n3[t6.label]), t6)), e5;
          }(t4.t, function(t5) {
            const e5 = [];
            if (t5)
              for (const [n3, o3] of Object.entries(t5)) {
                const t6 = Object.assign({}, o3, { id: `link${q_(n3)}` });
                e5.push(t6);
              }
            return e5;
          }(t4.config.get("link.decorators")));
          this._enableAutomaticDecorators(e4.filter((t5) => t5.mode === pv)), this._enableManualDecorators(e4.filter((t5) => "manual" === t5.mode));
          t4.plugins.get(pk2).registerAttribute("linkHref"), function(t5, e5, n3, o3) {
            const i3 = t5.editing.view, r3 = /* @__PURE__ */ new Set();
            i3.document.registerPostFixer((i4) => {
              const s3 = t5.model.document.selection;
              let a3 = false;
              if (s3.hasAttribute(e5)) {
                const c3 = Ek2(s3.getFirstPosition(), e5, s3.getAttribute(e5), t5.model), l3 = t5.editing.mapper.toViewRange(c3);
                for (const t6 of l3.getItems())
                  t6.is("element", n3) && !t6.hasClass(o3) && (i4.addClass(o3, t6), r3.add(t6), a3 = true);
              }
              return a3;
            }), t5.conversion.for("editingDowncast").add((t6) => {
              function e6() {
                i3.change((t7) => {
                  for (const e7 of r3.values())
                    t7.removeClass(o3, e7), r3.delete(e7);
                });
              }
              t6.on("insert", e6, { priority: "highest" }), t6.on("remove", e6, { priority: "highest" }), t6.on("attribute", e6, { priority: "highest" }), t6.on("selection", e6, { priority: "highest" });
            });
          }(t4, "linkHref", "a", "ck-link_selected"), this._enableLinkOpen(), this._enableInsertContentSelectionAttributesFixer(), this._enableClickingAfterLink(), this._enableTypingOverLink(), this._handleDeleteContentAfterLink(), this._enableClipboardIntegration();
        }
        _enableAutomaticDecorators(t4) {
          const e4 = this.editor, n3 = e4.commands.get("link").automaticDecorators;
          e4.config.get("link.addTargetToExternalLinks") && n3.add({ id: "linkIsExternal", mode: pv, callback: (t5) => !!t5 && mv.test(t5), attributes: { target: "_blank", rel: "noopener noreferrer" } }), n3.add(t4), n3.length && e4.conversion.for("downcast").add(n3.getDispatcher());
        }
        _enableManualDecorators(t4) {
          if (!t4.length)
            return;
          const e4 = this.editor, n3 = e4.commands.get("link").manualDecorators;
          t4.forEach((t5) => {
            e4.model.schema.extend("$text", { allowAttributes: t5.id });
            const o3 = new rv(t5);
            n3.add(o3), e4.conversion.for("downcast").attributeToElement({ model: o3.id, view: (t6, { writer: e5, schema: n4 }, { item: i3 }) => {
              if ((i3.is("selection") || n4.isInline(i3)) && t6) {
                const t7 = e5.createAttributeElement("a", o3.attributes, { priority: 5 });
                o3.classes && e5.addClass(o3.classes, t7);
                for (const n5 in o3.styles)
                  e5.setStyle(n5, o3.styles[n5], t7);
                return e5.setCustomProperty("link", true, t7), t7;
              }
            } }), e4.conversion.for("upcast").elementToAttribute({ view: gv({ name: "a" }, o3._createPattern()), model: { key: o3.id } });
          });
        }
        _enableLinkOpen() {
          const t4 = this.editor, e4 = t4.editing.view.document;
          this.listenTo(e4, "click", (t5, e5) => {
            if (!(a2.isMac ? e5.domEvent.metaKey : e5.domEvent.ctrlKey))
              return;
            let n3 = e5.domTarget;
            if ("a" != n3.tagName.toLowerCase() && (n3 = n3.closest("a")), !n3)
              return;
            const o3 = n3.getAttribute("href");
            o3 && (t5.stop(), e5.preventDefault(), ev(o3));
          }, { context: "$capture" }), this.listenTo(e4, "keydown", (e5, n3) => {
            const o3 = t4.commands.get("link").value;
            !!o3 && n3.keyCode === fi2.enter && n3.altKey && (e5.stop(), ev(o3));
          });
        }
        _enableInsertContentSelectionAttributesFixer() {
          const t4 = this.editor.model, e4 = t4.document.selection;
          this.listenTo(t4, "insertContent", () => {
            const n3 = e4.anchor.nodeBefore, o3 = e4.anchor.nodeAfter;
            e4.hasAttribute("linkHref") && n3 && n3.hasAttribute("linkHref") && (o3 && o3.hasAttribute("linkHref") || t4.change((e5) => {
              kv(e5, wv(t4.schema));
            }));
          }, { priority: "low" });
        }
        _enableClickingAfterLink() {
          const t4 = this.editor, e4 = t4.model;
          t4.editing.view.addObserver(xg2);
          let n3 = false;
          this.listenTo(t4.editing.view.document, "mousedown", () => {
            n3 = true;
          }), this.listenTo(t4.editing.view.document, "selectionChange", () => {
            if (!n3)
              return;
            n3 = false;
            const t5 = e4.document.selection;
            if (!t5.isCollapsed)
              return;
            if (!t5.hasAttribute("linkHref"))
              return;
            const o3 = t5.getFirstPosition(), i3 = Ek2(o3, "linkHref", t5.getAttribute("linkHref"), e4);
            (o3.isTouching(i3.start) || o3.isTouching(i3.end)) && e4.change((t6) => {
              kv(t6, wv(e4.schema));
            });
          });
        }
        _enableTypingOverLink() {
          const t4 = this.editor, e4 = t4.editing.view;
          let n3 = null, o3 = false;
          this.listenTo(e4.document, "delete", () => {
            o3 = true;
          }, { priority: "high" }), this.listenTo(t4.model, "deleteContent", () => {
            const e5 = t4.model.document.selection;
            e5.isCollapsed || (o3 ? o3 = false : bv(t4) && function(t5) {
              const e6 = t5.document.selection, n4 = e6.getFirstPosition(), o4 = e6.getLastPosition(), i3 = n4.nodeAfter;
              if (!i3)
                return false;
              if (!i3.is("$text"))
                return false;
              if (!i3.hasAttribute("linkHref"))
                return false;
              const r3 = o4.textNode || o4.nodeBefore;
              if (i3 === r3)
                return true;
              return Ek2(n4, "linkHref", i3.getAttribute("linkHref"), t5).containsRange(t5.createRange(n4, o4), true);
            }(t4.model) && (n3 = e5.getAttributes()));
          }, { priority: "high" }), this.listenTo(t4.model, "insertContent", (e5, [i3]) => {
            o3 = false, bv(t4) && n3 && (t4.model.change((t5) => {
              for (const [e6, o4] of n3)
                t5.setAttribute(e6, o4, i3);
            }), n3 = null);
          }, { priority: "high" });
        }
        _handleDeleteContentAfterLink() {
          const t4 = this.editor, e4 = t4.model, n3 = e4.document.selection, o3 = t4.editing.view;
          let i3 = false, r3 = false;
          this.listenTo(o3.document, "delete", (t5, e5) => {
            r3 = "backward" === e5.direction;
          }, { priority: "high" }), this.listenTo(e4, "deleteContent", () => {
            i3 = false;
            const t5 = n3.getFirstPosition(), o4 = n3.getAttribute("linkHref");
            if (!o4)
              return;
            const r4 = Ek2(t5, "linkHref", o4, e4);
            i3 = r4.containsPosition(t5) || r4.end.isEqual(t5);
          }, { priority: "high" }), this.listenTo(e4, "deleteContent", () => {
            r3 && (r3 = false, i3 || t4.model.enqueueChange((t5) => {
              kv(t5, wv(e4.schema));
            }));
          }, { priority: "low" });
        }
        _enableClipboardIntegration() {
          const t4 = this.editor, e4 = t4.model, n3 = this.editor.config.get("link.defaultProtocol");
          n3 && this.listenTo(t4.plugins.get("ClipboardPipeline"), "contentInsertion", (t5, o3) => {
            e4.change((t6) => {
              const e5 = t6.createRangeIn(o3.content);
              for (const o4 of e5.getItems())
                if (o4.hasAttribute("linkHref")) {
                  const e6 = X_(o4.getAttribute("linkHref"), n3);
                  t6.setAttribute("linkHref", e6, o4);
                }
            });
          });
        }
      }
      function kv(t4, e4) {
        t4.removeSelectionAttribute("linkHref");
        for (const n3 of e4)
          t4.removeSelectionAttribute(n3);
      }
      function bv(t4) {
        return t4.model.change((t5) => t5.batch).isTyping;
      }
      function wv(t4) {
        return t4.getDefinition("$text").allowAttributes.filter((t5) => t5.startsWith("link"));
      }
      var Av = n2(7754), Cv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Av.Z, Cv);
      Av.Z.locals;
      class _v extends Hi2 {
        constructor(t4, e4) {
          super(t4), this.focusTracker = new Ii2(), this.keystrokes = new Ti2(), this._focusables = new Li2();
          const n3 = t4.t;
          this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n3("Save"), Bg2.check, "ck-button-save"), this.saveButtonView.type = "submit", this.cancelButtonView = this._createButton(n3("Cancel"), Bg2.cancel, "ck-button-cancel", "cancel"), this._manualDecoratorSwitches = this._createManualDecoratorSwitches(e4), this.children = this._createFormChildren(e4.manualDecorators), this._focusCycler = new qr({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } });
          const o3 = ["ck", "ck-link-form", "ck-responsive-form"];
          e4.manualDecorators.length && o3.push("ck-link-form_layout-vertical", "ck-vertical-form"), this.setTemplate({ tag: "form", attributes: { class: o3, tabindex: "-1" }, children: this.children });
        }
        getDecoratorSwitchesState() {
          return Array.from(this._manualDecoratorSwitches).reduce((t4, e4) => (t4[e4.name] = e4.isOn, t4), {});
        }
        render() {
          super.render(), i2({ view: this });
          [this.urlInputView, ...this._manualDecoratorSwitches, this.saveButtonView, this.cancelButtonView].forEach((t4) => {
            this._focusables.add(t4), this.focusTracker.add(t4.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createUrlInput() {
          const t4 = this.locale.t, e4 = new Ir(this.locale, ap);
          return e4.label = t4("Link URL"), e4;
        }
        _createButton(t4, e4, n3, o3) {
          const i3 = new br(this.locale);
          return i3.set({ label: t4, icon: e4, tooltip: true }), i3.extendTemplate({ attributes: { class: n3 } }), o3 && i3.delegate("execute").to(this, o3), i3;
        }
        _createManualDecoratorSwitches(t4) {
          const e4 = this.createCollection();
          for (const n3 of t4.manualDecorators) {
            const o3 = new Cr(this.locale);
            o3.set({ name: n3.id, label: n3.label, withText: true }), o3.bind("isOn").toMany([n3, t4], "value", (t5, e5) => void 0 === e5 && void 0 === t5 ? !!n3.defaultValue : !!t5), o3.on("execute", () => {
              n3.set("value", !o3.isOn);
            }), e4.add(o3);
          }
          return e4;
        }
        _createFormChildren(t4) {
          const e4 = this.createCollection();
          if (e4.add(this.urlInputView), t4.length) {
            const t5 = new Hi2();
            t5.setTemplate({ tag: "ul", children: this._manualDecoratorSwitches.map((t6) => ({ tag: "li", children: [t6], attributes: { class: ["ck", "ck-list__item"] } })), attributes: { class: ["ck", "ck-reset", "ck-list"] } }), e4.add(t5);
          }
          return e4.add(this.saveButtonView), e4.add(this.cancelButtonView), e4;
        }
      }
      var vv = n2(2347), yv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(vv.Z, yv);
      vv.Z.locals;
      class xv extends Hi2 {
        constructor(t4) {
          super(t4), this.focusTracker = new Ii2(), this.keystrokes = new Ti2(), this._focusables = new Li2();
          const e4 = t4.t;
          this.previewButtonView = this._createPreviewButton(), this.unlinkButtonView = this._createButton(e4("Unlink"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z"/></svg>', "unlink"), this.editButtonView = this._createButton(e4("Edit link"), Bg2.pencil, "edit"), this.set("href", void 0), this._focusCycler = new qr({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this.setTemplate({ tag: "div", attributes: { class: ["ck", "ck-link-actions", "ck-responsive-form"], tabindex: "-1" }, children: [this.previewButtonView, this.editButtonView, this.unlinkButtonView] });
        }
        render() {
          super.render();
          [this.previewButtonView, this.editButtonView, this.unlinkButtonView].forEach((t4) => {
            this._focusables.add(t4), this.focusTracker.add(t4.element);
          }), this.keystrokes.listenTo(this.element);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        _createButton(t4, e4, n3) {
          const o3 = new br(this.locale);
          return o3.set({ label: t4, icon: e4, tooltip: true }), o3.delegate("execute").to(this, n3), o3;
        }
        _createPreviewButton() {
          const t4 = new br(this.locale), e4 = this.bindTemplate, n3 = this.t;
          return t4.set({ withText: true, tooltip: n3("Open link in new tab") }), t4.extendTemplate({ attributes: { class: ["ck", "ck-link-actions__preview"], href: e4.to("href", (t5) => t5 && Q_(t5)), target: "_blank", rel: "noopener noreferrer" } }), t4.bind("label").to(this, "href", (t5) => t5 || n3("This link has no URL")), t4.bind("isEnabled").to(this, "href", (t5) => !!t5), t4.template.tag = "a", t4.template.eventListeners = {}, t4;
        }
      }
      const Ev = "link-ui";
      class Dv extends $r {
        constructor() {
          super(...arguments), this.actionsView = null, this.formView = null;
        }
        static get requires() {
          return [Wm];
        }
        static get pluginName() {
          return "LinkUI";
        }
        init() {
          const t4 = this.editor;
          t4.editing.view.addObserver(yg2), this._balloon = t4.plugins.get(Wm), this._createToolbarLinkButton(), this._enableBalloonActivators(), t4.conversion.for("editingDowncast").markerToHighlight({ model: Ev, view: { classes: ["ck-fake-link-selection"] } }), t4.conversion.for("editingDowncast").markerToElement({ model: Ev, view: { name: "span", classes: ["ck-fake-link-selection", "ck-fake-link-selection_collapsed"] } });
        }
        destroy() {
          super.destroy(), this.formView && this.formView.destroy(), this.actionsView && this.actionsView.destroy();
        }
        _createViews() {
          this.actionsView = this._createActionsView(), this.formView = this._createFormView(), this._enableUserBalloonInteractions();
        }
        _createActionsView() {
          const t4 = this.editor, e4 = new xv(t4.locale), n3 = t4.commands.get("link"), o3 = t4.commands.get("unlink");
          return e4.bind("href").to(n3, "value"), e4.editButtonView.bind("isEnabled").to(n3), e4.unlinkButtonView.bind("isEnabled").to(o3), this.listenTo(e4, "edit", () => {
            this._addFormView();
          }), this.listenTo(e4, "unlink", () => {
            t4.execute("unlink"), this._hideUI();
          }), e4.keystrokes.set("Esc", (t5, e5) => {
            this._hideUI(), e5();
          }), e4.keystrokes.set($_, (t5, e5) => {
            this._addFormView(), e5();
          }), e4;
        }
        _createFormView() {
          const t4 = this.editor, n3 = t4.commands.get("link"), o3 = t4.config.get("link.defaultProtocol"), i3 = new (e3(_v))(t4.locale, n3);
          return i3.urlInputView.fieldView.bind("value").to(n3, "value"), i3.urlInputView.bind("isEnabled").to(n3, "isEnabled"), i3.saveButtonView.bind("isEnabled").to(n3), this.listenTo(i3, "submit", () => {
            const { value: e4 } = i3.urlInputView.fieldView.element, n4 = X_(e4, o3);
            t4.execute("link", n4, i3.getDecoratorSwitchesState()), this._closeFormView();
          }), this.listenTo(i3, "cancel", () => {
            this._closeFormView();
          }), i3.keystrokes.set("Esc", (t5, e4) => {
            this._closeFormView(), e4();
          }), i3;
        }
        _createToolbarLinkButton() {
          const t4 = this.editor, e4 = t4.commands.get("link"), n3 = t4.t;
          t4.ui.componentFactory.add("link", (t5) => {
            const o3 = new br(t5);
            return o3.isEnabled = true, o3.label = n3("Link"), o3.icon = '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="m11.077 15 .991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z"/></svg>', o3.keystroke = $_, o3.tooltip = true, o3.isToggleable = true, o3.bind("isEnabled").to(e4, "isEnabled"), o3.bind("isOn").to(e4, "value", (t6) => !!t6), this.listenTo(o3, "execute", () => this._showUI(true)), o3;
          });
        }
        _enableBalloonActivators() {
          const t4 = this.editor, e4 = t4.editing.view.document;
          this.listenTo(e4, "click", () => {
            this._getSelectedLinkElement() && this._showUI();
          }), t4.keystrokes.set($_, (e5, n3) => {
            n3(), t4.commands.get("link").isEnabled && this._showUI(true);
          });
        }
        _enableUserBalloonInteractions() {
          this.editor.keystrokes.set("Tab", (t4, e4) => {
            this._areActionsVisible && !this.actionsView.focusTracker.isFocused && (this.actionsView.focus(), e4());
          }, { priority: "high" }), this.editor.keystrokes.set("Esc", (t4, e4) => {
            this._isUIVisible && (this._hideUI(), e4());
          }), t3({ emitter: this.formView, activator: () => this._isUIInPanel, contextElements: () => [this._balloon.view.element], callback: () => this._hideUI() });
        }
        _addActionsView() {
          this.actionsView || this._createViews(), this._areActionsInPanel || this._balloon.add({ view: this.actionsView, position: this._getBalloonPositionData() });
        }
        _addFormView() {
          if (this.formView || this._createViews(), this._isFormInPanel)
            return;
          const t4 = this.editor.commands.get("link");
          this.formView.disableCssTransitions(), this._balloon.add({ view: this.formView, position: this._getBalloonPositionData() }), this._balloon.visibleView === this.formView && this.formView.urlInputView.fieldView.select(), this.formView.enableCssTransitions(), this.formView.urlInputView.fieldView.element.value = t4.value || "";
        }
        _closeFormView() {
          const t4 = this.editor.commands.get("link");
          t4.restoreManualDecoratorStates(), void 0 !== t4.value ? this._removeFormView() : this._hideUI();
        }
        _removeFormView() {
          this._isFormInPanel && (this.formView.saveButtonView.focus(), this._balloon.remove(this.formView), this.editor.editing.view.focus(), this._hideFakeVisualSelection());
        }
        _showUI(t4 = false) {
          this.formView || this._createViews(), this._getSelectedLinkElement() ? (this._areActionsVisible ? this._addFormView() : this._addActionsView(), t4 && this._balloon.showStack("main")) : (this._showFakeVisualSelection(), this._addActionsView(), t4 && this._balloon.showStack("main"), this._addFormView()), this._startUpdatingUI();
        }
        _hideUI() {
          if (!this._isUIInPanel)
            return;
          const t4 = this.editor;
          this.stopListening(t4.ui, "update"), this.stopListening(this._balloon, "change:visibleView"), t4.editing.view.focus(), this._removeFormView(), this._balloon.remove(this.actionsView), this._hideFakeVisualSelection();
        }
        _startUpdatingUI() {
          const t4 = this.editor, e4 = t4.editing.view.document;
          let n3 = this._getSelectedLinkElement(), o3 = r3();
          const i3 = () => {
            const t5 = this._getSelectedLinkElement(), e5 = r3();
            n3 && !t5 || !n3 && e5 !== o3 ? this._hideUI() : this._isUIVisible && this._balloon.updatePosition(this._getBalloonPositionData()), n3 = t5, o3 = e5;
          };
          function r3() {
            return e4.selection.focus.getAncestors().reverse().find((t5) => t5.is("element"));
          }
          this.listenTo(t4.ui, "update", i3), this.listenTo(this._balloon, "change:visibleView", i3);
        }
        get _isFormInPanel() {
          return !!this.formView && this._balloon.hasView(this.formView);
        }
        get _areActionsInPanel() {
          return !!this.actionsView && this._balloon.hasView(this.actionsView);
        }
        get _areActionsVisible() {
          return !!this.actionsView && this._balloon.visibleView === this.actionsView;
        }
        get _isUIInPanel() {
          return this._isFormInPanel || this._areActionsInPanel;
        }
        get _isUIVisible() {
          const t4 = this._balloon.visibleView;
          return !!this.formView && t4 == this.formView || this._areActionsVisible;
        }
        _getBalloonPositionData() {
          const t4 = this.editor.editing.view, e4 = this.editor.model, n3 = t4.document;
          let o3;
          if (e4.markers.has(Ev)) {
            const e5 = Array.from(this.editor.editing.mapper.markerNameToElements(Ev)), n4 = t4.createRange(t4.createPositionBefore(e5[0]), t4.createPositionAfter(e5[e5.length - 1]));
            o3 = t4.domConverter.viewRangeToDom(n4);
          } else
            o3 = () => {
              const e5 = this._getSelectedLinkElement();
              return e5 ? t4.domConverter.mapViewToDom(e5) : t4.domConverter.viewRangeToDom(n3.selection.getFirstRange());
            };
          return { target: o3 };
        }
        _getSelectedLinkElement() {
          const t4 = this.editor.editing.view, e4 = t4.document.selection, n3 = e4.getSelectedElement();
          if (e4.isCollapsed || n3 && Gk2(n3))
            return Sv(e4.getFirstPosition());
          {
            const n4 = e4.getFirstRange().getTrimmed(), o3 = Sv(n4.start), i3 = Sv(n4.end);
            return o3 && o3 == i3 && t4.createRangeIn(o3).getTrimmed().isEqual(n4) ? o3 : null;
          }
        }
        _showFakeVisualSelection() {
          const t4 = this.editor.model;
          t4.change((e4) => {
            const n3 = t4.document.selection.getFirstRange();
            if (t4.markers.has(Ev))
              e4.updateMarker(Ev, { range: n3 });
            else if (n3.start.isAtEnd) {
              const o3 = n3.start.getLastMatchingPosition(({ item: e5 }) => !t4.schema.isContent(e5), { boundaries: n3 });
              e4.addMarker(Ev, { usingOperation: false, affectsData: false, range: e4.createRange(o3, n3.end) });
            } else
              e4.addMarker(Ev, { usingOperation: false, affectsData: false, range: n3 });
          });
        }
        _hideFakeVisualSelection() {
          const t4 = this.editor.model;
          t4.markers.has(Ev) && t4.change((t5) => {
            t5.removeMarker(Ev);
          });
        }
      }
      function Sv(t4) {
        return t4.getAncestors().find((t5) => {
          return (e4 = t5).is("attributeElement") && !!e4.getCustomProperty("link");
          var e4;
        }) || null;
      }
      const Iv = new RegExp("(^|\\s)(((?:(?:(?:https?|ftp):)?\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(((?!www\\.)|(www\\.))(?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.)+(?:[a-z\\u00a1-\\uffff]{2,63})))(?::\\d{2,5})?(?:[/?#]\\S*)?)|((www.|(\\S+@))((?![-_])(?:[-_a-z0-9\\u00a1-\\uffff]{1,63}\\.))+(?:[a-z\\u00a1-\\uffff]{2,63})))$", "i");
      class Tv extends $r {
        static get requires() {
          return [dk2];
        }
        static get pluginName() {
          return "AutoLink";
        }
        init() {
          const t4 = this.editor.model.document.selection;
          t4.on("change:range", () => {
            this.isEnabled = !t4.anchor.parent.is("element", "codeBlock");
          }), this._enableTypingHandling();
        }
        afterInit() {
          this._enableEnterHandling(), this._enableShiftEnterHandling();
        }
        _enableTypingHandling() {
          const t4 = this.editor, e4 = new gk2(t4.model, (t5) => {
            if (!function(t6) {
              return t6.length > 4 && " " === t6[t6.length - 1] && " " !== t6[t6.length - 2];
            }(t5))
              return;
            const e5 = Mv(t5.substr(0, t5.length - 1));
            return e5 ? { url: e5 } : void 0;
          });
          e4.on("matched:data", (e5, n3) => {
            const { batch: o3, range: i3, url: r3 } = n3;
            if (!o3.isTyping)
              return;
            const s3 = i3.end.getShiftedBy(-1), a3 = s3.getShiftedBy(-r3.length), c3 = t4.model.createRange(a3, s3);
            this._applyAutoLink(r3, c3);
          }), e4.bind("isEnabled").to(this);
        }
        _enableEnterHandling() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.commands.get("enter");
          n3 && n3.on("execute", () => {
            const t5 = e4.document.selection.getFirstPosition();
            if (!t5.parent.previousSibling)
              return;
            const n4 = e4.createRangeIn(t5.parent.previousSibling);
            this._checkAndApplyAutoLinkOnRange(n4);
          });
        }
        _enableShiftEnterHandling() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.commands.get("shiftEnter");
          n3 && n3.on("execute", () => {
            const t5 = e4.document.selection.getFirstPosition(), n4 = e4.createRange(e4.createPositionAt(t5.parent, 0), t5.getShiftedBy(-1));
            this._checkAndApplyAutoLinkOnRange(n4);
          });
        }
        _checkAndApplyAutoLinkOnRange(t4) {
          const e4 = this.editor.model, { text: n3, range: o3 } = uk2(t4, e4), i3 = Mv(n3);
          if (i3) {
            const t5 = e4.createRange(o3.end.getShiftedBy(-i3.length), o3.end);
            this._applyAutoLink(i3, t5);
          }
        }
        _applyAutoLink(t4, e4) {
          const n3 = this.editor.model, o3 = X_(t4, this.editor.config.get("link.defaultProtocol"));
          this.isEnabled && function(t5, e5) {
            return e5.schema.checkAttributeInSelection(e5.createSelection(t5), "linkHref");
          }(e4, n3) && tv(o3) && !function(t5) {
            const e5 = t5.start.nodeAfter;
            return !!e5 && e5.hasAttribute("linkHref");
          }(e4) && this._persistAutoLink(o3, e4);
        }
        _persistAutoLink(t4, e4) {
          const n3 = this.editor.model, o3 = this.editor.plugins.get("Delete");
          n3.enqueueChange((i3) => {
            i3.setAttribute("linkHref", t4, e4), n3.enqueueChange(() => {
              o3.requestUndoOnBackspace();
            });
          });
        }
      }
      function Mv(t4) {
        const e4 = Iv.exec(t4);
        return e4 ? e4[2] : null;
      }
      var Bv = n2(111), Nv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Bv.Z, Nv);
      Bv.Z.locals;
      var Pv = n2(5730), zv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Pv.Z, zv);
      Pv.Z.locals;
      var Ov = n2(4564), Lv = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Ov.Z, Lv);
      Ov.Z.locals;
      function jv(t4, e4) {
        const n3 = e4.mapper, o3 = e4.writer, i3 = "numbered" == t4.getAttribute("listType") ? "ol" : "ul", r3 = function(t5) {
          const e5 = t5.createContainerElement("li");
          return e5.getFillerOffset = Kv, e5;
        }(o3), s3 = o3.createContainerElement(i3, null);
        return o3.insert(o3.createPositionAt(s3, 0), r3), n3.bindElements(t4, r3), r3;
      }
      function Rv(t4, e4, n3, o3) {
        const i3 = e4.parent, r3 = n3.mapper, s3 = n3.writer;
        let a3 = r3.toViewPosition(o3.createPositionBefore(t4));
        const c3 = Hv(t4.previousSibling, { sameIndent: true, smallerIndent: true, listIndent: t4.getAttribute("listIndent") }), l3 = t4.previousSibling;
        if (c3 && c3.getAttribute("listIndent") == t4.getAttribute("listIndent")) {
          const t5 = r3.toViewElement(c3);
          a3 = s3.breakContainer(s3.createPositionAfter(t5));
        } else if (l3 && "listItem" == l3.name) {
          a3 = r3.toViewPosition(o3.createPositionAt(l3, "end"));
          const t5 = r3.findMappedViewAncestor(a3), e5 = function(t6) {
            for (const e6 of t6.getChildren())
              if ("ul" == e6.name || "ol" == e6.name)
                return e6;
            return null;
          }(t5);
          a3 = e5 ? s3.createPositionBefore(e5) : s3.createPositionAt(t5, "end");
        } else
          a3 = r3.toViewPosition(o3.createPositionBefore(t4));
        if (a3 = Vv(a3), s3.insert(a3, i3), l3 && "listItem" == l3.name) {
          const t5 = r3.toViewElement(l3), n4 = s3.createRange(s3.createPositionAt(t5, 0), a3).getWalker({ ignoreElementEnd: true });
          for (const t6 of n4)
            if (t6.item.is("element", "li")) {
              const o4 = s3.breakContainer(s3.createPositionBefore(t6.item)), i4 = t6.item.parent, r4 = s3.createPositionAt(e4, "end");
              Fv(s3, r4.nodeBefore, r4.nodeAfter), s3.move(s3.createRangeOn(i4), r4), n4._position = o4;
            }
        } else {
          const n4 = i3.nextSibling;
          if (n4 && (n4.is("element", "ul") || n4.is("element", "ol"))) {
            let o4 = null;
            for (const e5 of n4.getChildren()) {
              const n5 = r3.toModelElement(e5);
              if (!(n5 && n5.getAttribute("listIndent") > t4.getAttribute("listIndent")))
                break;
              o4 = e5;
            }
            o4 && (s3.breakContainer(s3.createPositionAfter(o4)), s3.move(s3.createRangeOn(o4.parent), s3.createPositionAt(e4, "end")));
          }
        }
        Fv(s3, i3, i3.nextSibling), Fv(s3, i3.previousSibling, i3);
      }
      function Fv(t4, e4, n3) {
        return !e4 || !n3 || "ul" != e4.name && "ol" != e4.name || e4.name != n3.name || e4.getAttribute("class") !== n3.getAttribute("class") ? null : t4.mergeContainers(t4.createPositionAfter(e4));
      }
      function Vv(t4) {
        return t4.getLastMatchingPosition((t5) => t5.item.is("uiElement"));
      }
      function Hv(t4, e4) {
        const n3 = !!e4.sameIndent, o3 = !!e4.smallerIndent, i3 = e4.listIndent;
        let r3 = t4;
        for (; r3 && "listItem" == r3.name; ) {
          const t5 = r3.getAttribute("listIndent");
          if (n3 && i3 == t5 || o3 && i3 > t5)
            return r3;
          r3 = "forward" === e4.direction ? r3.nextSibling : r3.previousSibling;
        }
        return null;
      }
      function Uv(t4, e4, n3, o3) {
        t4.ui.componentFactory.add(e4, (i3) => {
          const r3 = t4.commands.get(e4), s3 = new br(i3);
          return s3.set({ label: n3, icon: o3, tooltip: true, isToggleable: true }), s3.bind("isOn", "isEnabled").to(r3, "value", "isEnabled"), s3.on("execute", () => {
            t4.execute(e4), t4.editing.view.focus();
          }), s3;
        });
      }
      function qv(t4, e4) {
        const n3 = [], o3 = t4.parent, i3 = { ignoreElementEnd: false, startPosition: t4, shallow: true, direction: e4 }, r3 = o3.getAttribute("listIndent"), s3 = [...new jl2(i3)].filter((t5) => t5.item.is("element")).map((t5) => t5.item);
        for (const t5 of s3) {
          if (!t5.is("element", "listItem"))
            break;
          if (t5.getAttribute("listIndent") < r3)
            break;
          if (!(t5.getAttribute("listIndent") > r3)) {
            if (t5.getAttribute("listType") !== o3.getAttribute("listType"))
              break;
            if (t5.getAttribute("listStyle") !== o3.getAttribute("listStyle"))
              break;
            if (t5.getAttribute("listReversed") !== o3.getAttribute("listReversed"))
              break;
            if (t5.getAttribute("listStart") !== o3.getAttribute("listStart"))
              break;
            "backward" === e4 ? n3.unshift(t5) : n3.push(t5);
          }
        }
        return n3;
      }
      const Gv = ["disc", "circle", "square"], Wv = ["decimal", "decimal-leading-zero", "lower-roman", "upper-roman", "lower-latin", "upper-latin"];
      function Kv() {
        const t4 = !this.isEmpty && ("ul" == this.getChild(0).name || "ol" == this.getChild(0).name);
        return this.isEmpty || t4 ? 0 : Ca2.call(this);
      }
      class Yv extends $r {
        static get pluginName() {
          return "ListUI";
        }
        init() {
          const t4 = this.editor.t;
          Uv(this.editor, "numberedList", t4("Numbered List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z"/></svg>'), Uv(this.editor, "bulletedList", t4("Bulleted List"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z"/></svg>');
        }
      }
      const Jv = [{ listStyle: "disc", typeAttribute: "disc", listType: "bulleted" }, { listStyle: "circle", typeAttribute: "circle", listType: "bulleted" }, { listStyle: "square", typeAttribute: "square", listType: "bulleted" }, { listStyle: "decimal", typeAttribute: "1", listType: "numbered" }, { listStyle: "decimal-leading-zero", typeAttribute: null, listType: "numbered" }, { listStyle: "lower-roman", typeAttribute: "i", listType: "numbered" }, { listStyle: "upper-roman", typeAttribute: "I", listType: "numbered" }, { listStyle: "lower-alpha", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-alpha", typeAttribute: "A", listType: "numbered" }, { listStyle: "lower-latin", typeAttribute: "a", listType: "numbered" }, { listStyle: "upper-latin", typeAttribute: "A", listType: "numbered" }];
      for (const { listStyle: t4, typeAttribute: e4, listType: n3 } of Jv)
        ;
      var Xv = n2(4721), ty = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Xv.Z, ty);
      Xv.Z.locals;
      var ey = n2(6082), ny = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(ey.Z, ny);
      ey.Z.locals;
      var oy = n2(2417), iy = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(oy.Z, iy);
      oy.Z.locals;
      class ry extends Qr {
        constructor(t4, e4) {
          super(t4), this._indentBy = "forward" == e4 ? 1 : -1;
        }
        refresh() {
          this.isEnabled = this._checkEnabled();
        }
        execute() {
          const t4 = this.editor.model, e4 = t4.document;
          let n3 = Array.from(e4.selection.getSelectedBlocks());
          t4.change((t5) => {
            const e5 = n3[n3.length - 1];
            let o3 = e5.nextSibling;
            for (; o3 && "listItem" == o3.name && o3.getAttribute("listIndent") > e5.getAttribute("listIndent"); )
              n3.push(o3), o3 = o3.nextSibling;
            this._indentBy < 0 && (n3 = n3.reverse());
            for (const e6 of n3) {
              const n4 = e6.getAttribute("listIndent") + this._indentBy;
              n4 < 0 ? t5.rename(e6, "paragraph") : t5.setAttribute("listIndent", n4, e6);
            }
            this.fire("_executeCleanup", n3);
          });
        }
        _checkEnabled() {
          const t4 = Si2(this.editor.model.document.selection.getSelectedBlocks());
          if (!t4 || !t4.is("element", "listItem"))
            return false;
          if (this._indentBy > 0) {
            const e4 = t4.getAttribute("listIndent"), n3 = t4.getAttribute("listType");
            let o3 = t4.previousSibling;
            for (; o3 && o3.is("element", "listItem") && o3.getAttribute("listIndent") >= e4; ) {
              if (o3.getAttribute("listIndent") == e4)
                return o3.getAttribute("listType") == n3;
              o3 = o3.previousSibling;
            }
            return false;
          }
          return true;
        }
      }
      class sy extends Qr {
        constructor(t4, e4) {
          super(t4), this.type = e4;
        }
        refresh() {
          this.value = this._getValue(), this.isEnabled = this._checkEnabled();
        }
        execute(t4 = {}) {
          const e4 = this.editor.model, n3 = e4.document, o3 = Array.from(n3.selection.getSelectedBlocks()).filter((t5) => cy(t5, e4.schema)), i3 = void 0 !== t4.forceValue ? !t4.forceValue : this.value;
          e4.change((t5) => {
            if (i3) {
              let e5 = o3[o3.length - 1].nextSibling, n4 = Number.POSITIVE_INFINITY, i4 = [];
              for (; e5 && "listItem" == e5.name && 0 !== e5.getAttribute("listIndent"); ) {
                const t6 = e5.getAttribute("listIndent");
                t6 < n4 && (n4 = t6);
                const o4 = t6 - n4;
                i4.push({ element: e5, listIndent: o4 }), e5 = e5.nextSibling;
              }
              i4 = i4.reverse();
              for (const e6 of i4)
                t5.setAttribute("listIndent", e6.listIndent, e6.element);
            }
            if (!i3) {
              let t6 = Number.POSITIVE_INFINITY;
              for (const e5 of o3)
                e5.is("element", "listItem") && e5.getAttribute("listIndent") < t6 && (t6 = e5.getAttribute("listIndent"));
              t6 = 0 === t6 ? 1 : t6, ay(o3, true, t6), ay(o3, false, t6);
            }
            for (const e5 of o3.reverse())
              i3 && "listItem" == e5.name ? t5.rename(e5, "paragraph") : i3 || "listItem" == e5.name ? i3 || "listItem" != e5.name || e5.getAttribute("listType") == this.type || t5.setAttribute("listType", this.type, e5) : (t5.setAttributes({ listType: this.type, listIndent: 0 }, e5), t5.rename(e5, "listItem"));
            this.fire("_executeCleanup", o3);
          });
        }
        _getValue() {
          const t4 = Si2(this.editor.model.document.selection.getSelectedBlocks());
          return !!t4 && t4.is("element", "listItem") && t4.getAttribute("listType") == this.type;
        }
        _checkEnabled() {
          if (this.value)
            return true;
          const t4 = this.editor.model.document.selection, e4 = this.editor.model.schema, n3 = Si2(t4.getSelectedBlocks());
          return !!n3 && cy(n3, e4);
        }
      }
      function ay(t4, e4, n3) {
        const o3 = e4 ? t4[0] : t4[t4.length - 1];
        if (o3.is("element", "listItem")) {
          let i3 = o3[e4 ? "previousSibling" : "nextSibling"], r3 = o3.getAttribute("listIndent");
          for (; i3 && i3.is("element", "listItem") && i3.getAttribute("listIndent") >= n3; )
            r3 > i3.getAttribute("listIndent") && (r3 = i3.getAttribute("listIndent")), i3.getAttribute("listIndent") == r3 && t4[e4 ? "unshift" : "push"](i3), i3 = i3[e4 ? "previousSibling" : "nextSibling"];
        }
      }
      function cy(t4, e4) {
        return e4.checkChild(t4.parent, "listItem") && !e4.isObject(t4);
      }
      class ly extends $r {
        static get pluginName() {
          return "ListUtils";
        }
        getListTypeFromListStyleType(t4) {
          return function(t5) {
            return Gv.includes(t5) ? "bulleted" : Wv.includes(t5) ? "numbered" : null;
          }(t4);
        }
        getSelectedListItems(t4) {
          return function(t5) {
            let e4 = [...t5.document.selection.getSelectedBlocks()].filter((t6) => t6.is("element", "listItem")).map((e5) => {
              const n3 = t5.change((t6) => t6.createPositionAt(e5, 0));
              return [...qv(n3, "backward"), ...qv(n3, "forward")];
            }).flat();
            return e4 = [...new Set(e4)], e4;
          }(t4);
        }
        getSiblingNodes(t4, e4) {
          return qv(t4, e4);
        }
      }
      function dy(t4) {
        return (e4, n3, o3) => {
          const i3 = o3.consumable;
          if (!i3.test(n3.item, "insert") || !i3.test(n3.item, "attribute:listType") || !i3.test(n3.item, "attribute:listIndent"))
            return;
          i3.consume(n3.item, "insert"), i3.consume(n3.item, "attribute:listType"), i3.consume(n3.item, "attribute:listIndent");
          const r3 = n3.item;
          Rv(r3, jv(r3, o3), o3, t4);
        };
      }
      const hy = (t4, e4, n3) => {
        if (!n3.consumable.test(e4.item, t4.name))
          return;
        const o3 = n3.mapper.toViewElement(e4.item), i3 = n3.writer;
        i3.breakContainer(i3.createPositionBefore(o3)), i3.breakContainer(i3.createPositionAfter(o3));
        const r3 = o3.parent, s3 = "numbered" == e4.attributeNewValue ? "ol" : "ul";
        i3.rename(s3, r3);
      }, uy = (t4, e4, n3) => {
        n3.consumable.consume(e4.item, t4.name);
        const o3 = n3.mapper.toViewElement(e4.item).parent, i3 = n3.writer;
        Fv(i3, o3, o3.nextSibling), Fv(i3, o3.previousSibling, o3);
      };
      const gy = (t4, e4, n3) => {
        if (n3.consumable.test(e4.item, t4.name) && "listItem" != e4.item.name) {
          let t5 = n3.mapper.toViewPosition(e4.range.start);
          const o3 = n3.writer, i3 = [];
          for (; ("ul" == t5.parent.name || "ol" == t5.parent.name) && (t5 = o3.breakContainer(t5), "li" == t5.parent.name); ) {
            const e5 = t5, n4 = o3.createPositionAt(t5.parent, "end");
            if (!e5.isEqual(n4)) {
              const t6 = o3.remove(o3.createRange(e5, n4));
              i3.push(t6);
            }
            t5 = o3.createPositionAfter(t5.parent);
          }
          if (i3.length > 0) {
            for (let e5 = 0; e5 < i3.length; e5++) {
              const n4 = t5.nodeBefore;
              if (t5 = o3.insert(t5, i3[e5]).end, e5 > 0) {
                const e6 = Fv(o3, n4, n4.nextSibling);
                e6 && e6.parent == n4 && t5.offset--;
              }
            }
            Fv(o3, t5.nodeBefore, t5.nodeAfter);
          }
        }
      }, py = (t4, e4, n3) => {
        const o3 = n3.mapper.toViewPosition(e4.position), i3 = o3.nodeBefore, r3 = o3.nodeAfter;
        Fv(n3.writer, i3, r3);
      }, my = (t4, e4, n3) => {
        if (n3.consumable.consume(e4.viewItem, { name: true })) {
          const t5 = n3.writer, o3 = t5.createElement("listItem"), i3 = function(t6) {
            let e5 = 0, n4 = t6.parent;
            for (; n4; ) {
              if (n4.is("element", "li"))
                e5++;
              else {
                const t7 = n4.previousSibling;
                t7 && t7.is("element", "li") && e5++;
              }
              n4 = n4.parent;
            }
            return e5;
          }(e4.viewItem);
          t5.setAttribute("listIndent", i3, o3);
          const r3 = e4.viewItem.parent && "ol" == e4.viewItem.parent.name ? "numbered" : "bulleted";
          if (t5.setAttribute("listType", r3, o3), !n3.safeInsert(o3, e4.modelCursor))
            return;
          const s3 = function(t6, e5, n4) {
            const { writer: o4, schema: i4 } = n4;
            let r4 = o4.createPositionAfter(t6);
            for (const s4 of e5)
              if ("ul" == s4.name || "ol" == s4.name)
                r4 = n4.convertItem(s4, r4).modelCursor;
              else {
                const e6 = n4.convertItem(s4, o4.createPositionAt(t6, "end")), a3 = e6.modelRange.start.nodeAfter;
                a3 && a3.is("element") && !i4.checkChild(t6, a3.name) && (t6 = e6.modelCursor.parent.is("element", "listItem") ? e6.modelCursor.parent : Ay(e6.modelCursor), r4 = o4.createPositionAfter(t6));
              }
            return r4;
          }(o3, e4.viewItem.getChildren(), n3);
          e4.modelRange = t5.createRange(e4.modelCursor, s3), n3.updateConversionResult(o3, e4);
        }
      }, fy = (t4, e4, n3) => {
        if (n3.consumable.test(e4.viewItem, { name: true })) {
          const t5 = Array.from(e4.viewItem.getChildren());
          for (const e5 of t5) {
            !(e5.is("element", "li") || _y(e5)) && e5._remove();
          }
        }
      }, ky = (t4, e4, n3) => {
        if (n3.consumable.test(e4.viewItem, { name: true })) {
          if (0 === e4.viewItem.childCount)
            return;
          const t5 = [...e4.viewItem.getChildren()];
          let n4 = false;
          for (const e5 of t5)
            n4 && !_y(e5) && e5._remove(), _y(e5) && (n4 = true);
        }
      };
      function by(t4) {
        return (e4, n3) => {
          if (n3.isPhantom)
            return;
          const o3 = n3.modelPosition.nodeBefore;
          if (o3 && o3.is("element", "listItem")) {
            const e5 = n3.mapper.toViewElement(o3), i3 = e5.getAncestors().find(_y), r3 = t4.createPositionAt(e5, 0).getWalker();
            for (const t5 of r3) {
              if ("elementStart" == t5.type && t5.item.is("element", "li")) {
                n3.viewPosition = t5.previousPosition;
                break;
              }
              if ("elementEnd" == t5.type && t5.item == i3) {
                n3.viewPosition = t5.nextPosition;
                break;
              }
            }
          }
        };
      }
      const wy = function(t4, [e4, n3]) {
        const o3 = this;
        let i3, r3 = e4.is("documentFragment") ? e4.getChild(0) : e4;
        if (i3 = n3 ? o3.createSelection(n3) : o3.document.selection, r3 && r3.is("element", "listItem")) {
          const t5 = i3.getFirstPosition();
          let e5 = null;
          if (t5.parent.is("element", "listItem") ? e5 = t5.parent : t5.nodeBefore && t5.nodeBefore.is("element", "listItem") && (e5 = t5.nodeBefore), e5) {
            const t6 = e5.getAttribute("listIndent");
            if (t6 > 0)
              for (; r3 && r3.is("element", "listItem"); )
                r3._setAttribute("listIndent", r3.getAttribute("listIndent") + t6), r3 = r3.nextSibling;
          }
        }
      };
      function Ay(t4) {
        const e4 = new jl2({ startPosition: t4 });
        let n3;
        do {
          n3 = e4.next();
        } while (!n3.value.item.is("element", "listItem"));
        return n3.value.item;
      }
      function Cy(t4, e4, n3, o3, i3, r3) {
        const s3 = Hv(e4.nodeBefore, { sameIndent: true, smallerIndent: true, listIndent: t4 }), a3 = i3.mapper, c3 = i3.writer, l3 = s3 ? s3.getAttribute("listIndent") : null;
        let d3;
        if (s3)
          if (l3 == t4) {
            const t5 = a3.toViewElement(s3).parent;
            d3 = c3.createPositionAfter(t5);
          } else {
            const t5 = r3.createPositionAt(s3, "end");
            d3 = a3.toViewPosition(t5);
          }
        else
          d3 = n3;
        d3 = Vv(d3);
        for (const t5 of [...o3.getChildren()])
          _y(t5) && (d3 = c3.move(c3.createRangeOn(t5), d3).end, Fv(c3, t5, t5.nextSibling), Fv(c3, t5.previousSibling, t5));
      }
      function _y(t4) {
        return t4.is("element", "ol") || t4.is("element", "ul");
      }
      class vy extends $r {
        static get pluginName() {
          return "ListEditing";
        }
        static get requires() {
          return [Nk2, dk2, ly];
        }
        init() {
          const t4 = this.editor;
          t4.model.schema.register("listItem", { inheritAllFrom: "$block", allowAttributes: ["listType", "listIndent"] });
          const e4 = t4.data, n3 = t4.editing;
          var o3;
          t4.model.document.registerPostFixer((e5) => function(t5, e6) {
            const n4 = t5.document.differ.getChanges(), o4 = /* @__PURE__ */ new Map();
            let i4 = false;
            for (const o5 of n4)
              if ("insert" == o5.type && "listItem" == o5.name)
                r3(o5.position);
              else if ("insert" == o5.type && "listItem" != o5.name) {
                if ("$text" != o5.name) {
                  const n5 = o5.position.nodeAfter;
                  n5.hasAttribute("listIndent") && (e6.removeAttribute("listIndent", n5), i4 = true), n5.hasAttribute("listType") && (e6.removeAttribute("listType", n5), i4 = true), n5.hasAttribute("listStyle") && (e6.removeAttribute("listStyle", n5), i4 = true), n5.hasAttribute("listReversed") && (e6.removeAttribute("listReversed", n5), i4 = true), n5.hasAttribute("listStart") && (e6.removeAttribute("listStart", n5), i4 = true);
                  for (const e7 of Array.from(t5.createRangeIn(n5)).filter((t6) => t6.item.is("element", "listItem")))
                    r3(e7.previousPosition);
                }
                r3(o5.position.getShiftedBy(o5.length));
              } else
                "remove" == o5.type && "listItem" == o5.name ? r3(o5.position) : ("attribute" == o5.type && "listIndent" == o5.attributeKey || "attribute" == o5.type && "listType" == o5.attributeKey) && r3(o5.range.start);
            for (const t6 of o4.values())
              s3(t6), a3(t6);
            return i4;
            function r3(t6) {
              const e7 = t6.nodeBefore;
              if (e7 && e7.is("element", "listItem")) {
                let t7 = e7;
                if (o4.has(t7))
                  return;
                for (let e8 = t7.previousSibling; e8 && e8.is("element", "listItem"); e8 = t7.previousSibling)
                  if (t7 = e8, o4.has(t7))
                    return;
                o4.set(e7, t7);
              } else {
                const e8 = t6.nodeAfter;
                e8 && e8.is("element", "listItem") && o4.set(e8, e8);
              }
            }
            function s3(t6) {
              let n5 = 0, o5 = null;
              for (; t6 && t6.is("element", "listItem"); ) {
                const r4 = t6.getAttribute("listIndent");
                if (r4 > n5) {
                  let s4;
                  null === o5 ? (o5 = r4 - n5, s4 = n5) : (o5 > r4 && (o5 = r4), s4 = r4 - o5), e6.setAttribute("listIndent", s4, t6), i4 = true;
                } else
                  o5 = null, n5 = t6.getAttribute("listIndent") + 1;
                t6 = t6.nextSibling;
              }
            }
            function a3(t6) {
              let n5 = [], o5 = null;
              for (; t6 && t6.is("element", "listItem"); ) {
                const r4 = t6.getAttribute("listIndent");
                if (o5 && o5.getAttribute("listIndent") > r4 && (n5 = n5.slice(0, r4 + 1)), 0 != r4)
                  if (n5[r4]) {
                    const o6 = n5[r4];
                    t6.getAttribute("listType") != o6 && (e6.setAttribute("listType", o6, t6), i4 = true);
                  } else
                    n5[r4] = t6.getAttribute("listType");
                o5 = t6, t6 = t6.nextSibling;
              }
            }
          }(t4.model, e5)), n3.mapper.registerViewToModelLength("li", yy), e4.mapper.registerViewToModelLength("li", yy), n3.mapper.on("modelToViewPosition", by(n3.view)), n3.mapper.on("viewToModelPosition", (o3 = t4.model, (t5, e5) => {
            const n4 = e5.viewPosition, i4 = n4.parent, r3 = e5.mapper;
            if ("ul" == i4.name || "ol" == i4.name) {
              if (n4.isAtEnd) {
                const t6 = r3.toModelElement(n4.nodeBefore), i5 = r3.getModelLength(n4.nodeBefore);
                e5.modelPosition = o3.createPositionBefore(t6).getShiftedBy(i5);
              } else {
                const t6 = r3.toModelElement(n4.nodeAfter);
                e5.modelPosition = o3.createPositionBefore(t6);
              }
              t5.stop();
            } else if ("li" == i4.name && n4.nodeBefore && ("ul" == n4.nodeBefore.name || "ol" == n4.nodeBefore.name)) {
              const s3 = r3.toModelElement(i4);
              let a3 = 1, c3 = n4.nodeBefore;
              for (; c3 && _y(c3); )
                a3 += r3.getModelLength(c3), c3 = c3.previousSibling;
              e5.modelPosition = o3.createPositionBefore(s3).getShiftedBy(a3), t5.stop();
            }
          })), e4.mapper.on("modelToViewPosition", by(n3.view)), t4.conversion.for("editingDowncast").add((e5) => {
            e5.on("insert", gy, { priority: "high" }), e5.on("insert:listItem", dy(t4.model)), e5.on("attribute:listType:listItem", hy, { priority: "high" }), e5.on("attribute:listType:listItem", uy, { priority: "low" }), e5.on("attribute:listIndent:listItem", function(t5) {
              return (e6, n4, o4) => {
                if (!o4.consumable.consume(n4.item, "attribute:listIndent"))
                  return;
                const i4 = o4.mapper.toViewElement(n4.item), r3 = o4.writer;
                r3.breakContainer(r3.createPositionBefore(i4)), r3.breakContainer(r3.createPositionAfter(i4));
                const s3 = i4.parent, a3 = s3.previousSibling, c3 = r3.createRangeOn(s3);
                r3.remove(c3), a3 && a3.nextSibling && Fv(r3, a3, a3.nextSibling), Cy(n4.attributeOldValue + 1, n4.range.start, c3.start, i4, o4, t5), Rv(n4.item, i4, o4, t5);
                for (const t6 of n4.item.getChildren())
                  o4.consumable.consume(t6, "insert");
              };
            }(t4.model)), e5.on("remove:listItem", function(t5) {
              return (e6, n4, o4) => {
                const i4 = o4.mapper.toViewPosition(n4.position).getLastMatchingPosition((t6) => !t6.item.is("element", "li")).nodeAfter, r3 = o4.writer;
                r3.breakContainer(r3.createPositionBefore(i4)), r3.breakContainer(r3.createPositionAfter(i4));
                const s3 = i4.parent, a3 = s3.previousSibling, c3 = r3.createRangeOn(s3), l3 = r3.remove(c3);
                a3 && a3.nextSibling && Fv(r3, a3, a3.nextSibling), Cy(o4.mapper.toModelElement(i4).getAttribute("listIndent") + 1, n4.position, c3.start, i4, o4, t5);
                for (const t6 of r3.createRangeIn(l3).getItems())
                  o4.mapper.unbindViewElement(t6);
                e6.stop();
              };
            }(t4.model)), e5.on("remove", py, { priority: "low" });
          }), t4.conversion.for("dataDowncast").add((e5) => {
            e5.on("insert", gy, { priority: "high" }), e5.on("insert:listItem", dy(t4.model));
          }), t4.conversion.for("upcast").add((t5) => {
            t5.on("element:ul", fy, { priority: "high" }), t5.on("element:ol", fy, { priority: "high" }), t5.on("element:li", ky, { priority: "high" }), t5.on("element:li", my);
          }), t4.model.on("insertContent", wy, { priority: "high" }), t4.commands.add("numberedList", new sy(t4, "numbered")), t4.commands.add("bulletedList", new sy(t4, "bulleted")), t4.commands.add("indentList", new ry(t4, "forward")), t4.commands.add("outdentList", new ry(t4, "backward"));
          const i3 = n3.view.document;
          this.listenTo(i3, "enter", (t5, e5) => {
            const n4 = this.editor.model.document, o4 = n4.selection.getLastPosition().parent;
            n4.selection.isCollapsed && "listItem" == o4.name && o4.isEmpty && (this.editor.execute("outdentList"), e5.preventDefault(), t5.stop());
          }, { context: "li" }), this.listenTo(i3, "delete", (t5, e5) => {
            if ("backward" !== e5.direction)
              return;
            const n4 = this.editor.model.document.selection;
            if (!n4.isCollapsed)
              return;
            const o4 = n4.getFirstPosition();
            if (!o4.isAtStart)
              return;
            const i4 = o4.parent;
            if ("listItem" !== i4.name)
              return;
            i4.previousSibling && "listItem" === i4.previousSibling.name || (this.editor.execute("outdentList"), e5.preventDefault(), t5.stop());
          }, { context: "li" }), this.listenTo(t4.editing.view.document, "tab", (e5, n4) => {
            const o4 = n4.shiftKey ? "outdentList" : "indentList";
            this.editor.commands.get(o4).isEnabled && (t4.execute(o4), n4.stopPropagation(), n4.preventDefault(), e5.stop());
          }, { context: "li" });
        }
        afterInit() {
          const t4 = this.editor.commands, e4 = t4.get("indent"), n3 = t4.get("outdent");
          e4 && e4.registerChildCommand(t4.get("indentList")), n3 && n3.registerChildCommand(t4.get("outdentList"));
        }
      }
      function yy(t4) {
        let e4 = 1;
        for (const n3 of t4.getChildren())
          if ("ul" == n3.name || "ol" == n3.name)
            for (const t5 of n3.getChildren())
              e4 += yy(t5);
        return e4;
      }
      wi2("Ctrl+Enter");
      var xy = n2(1199), Ey = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(xy.Z, Ey);
      xy.Z.locals;
      wi2("Ctrl+Enter");
      function Dy(t4, e4) {
        const n3 = (n4, o3, i3) => {
          if (!i3.consumable.consume(o3.item, n4.name))
            return;
          const r3 = o3.attributeNewValue, s3 = i3.writer, a3 = i3.mapper.toViewElement(o3.item), c3 = [...a3.getChildren()].find((t5) => t5.getCustomProperty("media-content"));
          s3.remove(c3);
          const l3 = t4.getMediaViewElement(s3, r3, e4);
          s3.insert(s3.createPositionAt(a3, 0), l3);
        };
        return (t5) => {
          t5.on("attribute:url:media", n3);
        };
      }
      function Sy(t4, e4, n3, o3) {
        return t4.createContainerElement("figure", { class: "media" }, [e4.getMediaViewElement(t4, n3, o3), t4.createSlot()]);
      }
      function Iy(t4) {
        const e4 = t4.getSelectedElement();
        return e4 && e4.is("element", "media") ? e4 : null;
      }
      function Ty(t4, e4, n3, o3) {
        t4.change((i3) => {
          const r3 = i3.createElement("media", { url: e4 });
          t4.insertObject(r3, n3, null, { setSelection: "on", findOptimalPosition: o3 ? "auto" : void 0 });
        });
      }
      class My extends Qr {
        refresh() {
          const t4 = this.editor.model, e4 = t4.document.selection, n3 = Iy(e4);
          this.value = n3 ? n3.getAttribute("url") : void 0, this.isEnabled = function(t5) {
            const e5 = t5.getSelectedElement();
            return !!e5 && "media" === e5.name;
          }(e4) || function(t5, e5) {
            const n4 = Qk2(t5, e5);
            let o3 = n4.start.parent;
            o3.isEmpty && !e5.schema.isLimit(o3) && (o3 = o3.parent);
            return e5.schema.checkChild(o3, "media");
          }(e4, t4);
        }
        execute(t4) {
          const e4 = this.editor.model, n3 = e4.document.selection, o3 = Iy(n3);
          o3 ? e4.change((e5) => {
            e5.setAttribute("url", t4, o3);
          }) : Ty(e4, t4, n3, true);
        }
      }
      class By {
        constructor(t4, e4) {
          const n3 = e4.providers, o3 = e4.extraProviders || [], i3 = new Set(e4.removeProviders), r3 = n3.concat(o3).filter((t5) => {
            const e5 = t5.name;
            return e5 ? !i3.has(e5) : (C2("media-embed-no-provider-name", { provider: t5 }), false);
          });
          this.locale = t4, this.providerDefinitions = r3;
        }
        hasMedia(t4) {
          return !!this._getMedia(t4);
        }
        getMediaViewElement(t4, e4, n3) {
          return this._getMedia(e4).getViewElement(t4, n3);
        }
        _getMedia(t4) {
          if (!t4)
            return new Ny(this.locale);
          t4 = t4.trim();
          for (const e4 of this.providerDefinitions) {
            const n3 = e4.html, o3 = _i(e4.url);
            for (const e5 of o3) {
              const o4 = this._getUrlMatches(t4, e5);
              if (o4)
                return new Ny(this.locale, t4, o4, n3);
            }
          }
          return null;
        }
        _getUrlMatches(t4, e4) {
          let n3 = t4.match(e4);
          if (n3)
            return n3;
          let o3 = t4.replace(/^https?:\/\//, "");
          return n3 = o3.match(e4), n3 || (o3 = o3.replace(/^www\./, ""), n3 = o3.match(e4), n3 || null);
        }
      }
      class Ny {
        constructor(t4, e4, n3, o3) {
          this.url = this._getValidUrl(e4), this._locale = t4, this._match = n3, this._previewRenderer = o3;
        }
        getViewElement(t4, e4) {
          const n3 = {};
          let o3;
          if (e4.renderForEditingView || e4.renderMediaPreview && this.url && this._previewRenderer) {
            this.url && (n3["data-oembed-url"] = this.url), e4.renderForEditingView && (n3.class = "ck-media__wrapper");
            const i3 = this._getPreviewHtml(e4);
            o3 = t4.createRawElement("div", n3, (t5, e5) => {
              e5.setContentOf(t5, i3);
            });
          } else
            this.url && (n3.url = this.url), o3 = t4.createEmptyElement(e4.elementName, n3);
          return t4.setCustomProperty("media-content", true, o3), o3;
        }
        _getPreviewHtml(t4) {
          return this._previewRenderer ? this._previewRenderer(this._match) : this.url && t4.renderForEditingView ? this._getPlaceholderHtml() : "";
        }
        _getPlaceholderHtml() {
          const t4 = new pr(), e4 = this._locale.t;
          t4.content = '<svg viewBox="0 0 64 42" xmlns="http://www.w3.org/2000/svg"><path d="M47.426 17V3.713L63.102 0v19.389h-.001l.001.272c0 1.595-2.032 3.43-4.538 4.098-2.506.668-4.538-.083-4.538-1.678 0-1.594 2.032-3.43 4.538-4.098.914-.244 2.032-.565 2.888-.603V4.516L49.076 7.447v9.556A1.014 1.014 0 0 0 49 17h-1.574zM29.5 17h-8.343a7.073 7.073 0 1 0-4.657 4.06v3.781H3.3a2.803 2.803 0 0 1-2.8-2.804V8.63a2.803 2.803 0 0 1 2.8-2.805h4.082L8.58 2.768A1.994 1.994 0 0 1 10.435 1.5h8.985c.773 0 1.477.448 1.805 1.149l1.488 3.177H26.7c1.546 0 2.8 1.256 2.8 2.805V17zm-11.637 0H17.5a1 1 0 0 0-1 1v.05A4.244 4.244 0 1 1 17.863 17zm29.684 2c.97 0 .953-.048.953.889v20.743c0 .953.016.905-.953.905H19.453c-.97 0-.953.048-.953-.905V19.89c0-.937-.016-.889.97-.889h28.077zm-4.701 19.338V22.183H24.154v16.155h18.692zM20.6 21.375v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616v-1.616H20.6zm0 3.231v1.616h1.616V37.53H20.6zm24.233-16.155v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615v-1.616h-1.615zm0 3.231v1.616h1.615V37.53h-1.615zM29.485 25.283a.4.4 0 0 1 .593-.35l9.05 4.977a.4.4 0 0 1 0 .701l-9.05 4.978a.4.4 0 0 1-.593-.35v-9.956z"/></svg>', t4.viewBox = "0 0 64 42";
          return new Ui2({ tag: "div", attributes: { class: "ck ck-reset_all ck-media__placeholder" }, children: [{ tag: "div", attributes: { class: "ck-media__placeholder__icon" }, children: [t4] }, { tag: "a", attributes: { class: "ck-media__placeholder__url", target: "_blank", rel: "noopener noreferrer", href: this.url, "data-cke-tooltip-text": e4("Open media in new tab") }, children: [{ tag: "span", attributes: { class: "ck-media__placeholder__url__text" }, children: [this.url] }] }] }).render().outerHTML;
        }
        _getValidUrl(t4) {
          return t4 ? t4.match(/^https?/) ? t4 : "https://" + t4 : null;
        }
      }
      var Py = n2(7442), zy = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Py.Z, zy);
      Py.Z.locals;
      class Oy extends $r {
        constructor(t4) {
          super(t4), t4.config.define("mediaEmbed", { elementName: "oembed", providers: [{ name: "dailymotion", url: /^dailymotion\.com\/video\/(\w+)/, html: (t5) => `<div style="position: relative; padding-bottom: 100%; height: 0; "><iframe src="https://www.dailymotion.com/embed/video/${t5[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" width="480" height="270" allowfullscreen allow="autoplay"></iframe></div>` }, { name: "spotify", url: [/^open\.spotify\.com\/(artist\/\w+)/, /^open\.spotify\.com\/(album\/\w+)/, /^open\.spotify\.com\/(track\/\w+)/], html: (t5) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 126%;"><iframe src="https://open.spotify.com/embed/${t5[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe></div>` }, { name: "youtube", url: [/^(?:m\.)?youtube\.com\/watch\?v=([\w-]+)(?:&t=(\d+))?/, /^(?:m\.)?youtube\.com\/v\/([\w-]+)(?:\?t=(\d+))?/, /^youtube\.com\/embed\/([\w-]+)(?:\?start=(\d+))?/, /^youtu\.be\/([\w-]+)(?:\?t=(\d+))?/], html: (t5) => {
            const e4 = t5[1], n3 = t5[2];
            return `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://www.youtube.com/embed/${e4}${n3 ? `?start=${n3}` : ""}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe></div>`;
          } }, { name: "vimeo", url: [/^vimeo\.com\/(\d+)/, /^vimeo\.com\/[^/]+\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/album\/[^/]+\/video\/(\d+)/, /^vimeo\.com\/channels\/[^/]+\/(\d+)/, /^vimeo\.com\/groups\/[^/]+\/videos\/(\d+)/, /^vimeo\.com\/ondemand\/[^/]+\/(\d+)/, /^player\.vimeo\.com\/video\/(\d+)/], html: (t5) => `<div style="position: relative; padding-bottom: 100%; height: 0; padding-bottom: 56.2493%;"><iframe src="https://player.vimeo.com/video/${t5[1]}" style="position: absolute; width: 100%; height: 100%; top: 0; left: 0;" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe></div>` }, { name: "instagram", url: /^instagram\.com\/p\/(\w+)/ }, { name: "twitter", url: /^twitter\.com/ }, { name: "googleMaps", url: [/^google\.com\/maps/, /^goo\.gl\/maps/, /^maps\.google\.com/, /^maps\.app\.goo\.gl/] }, { name: "flickr", url: /^flickr\.com/ }, { name: "facebook", url: /^facebook\.com/ }] }), this.registry = new By(t4.locale, t4.config.get("mediaEmbed"));
        }
        static get pluginName() {
          return "MediaEmbedEditing";
        }
        init() {
          const t4 = this.editor, e4 = t4.model.schema, n3 = t4.t, o3 = t4.conversion, i3 = t4.config.get("mediaEmbed.previewsInData"), r3 = t4.config.get("mediaEmbed.elementName"), s3 = this.registry;
          t4.commands.add("mediaEmbed", new My(t4)), e4.register("media", { inheritAllFrom: "$blockObject", allowAttributes: ["url"] }), o3.for("dataDowncast").elementToStructure({ model: "media", view: (t5, { writer: e5 }) => {
            const n4 = t5.getAttribute("url");
            return Sy(e5, s3, n4, { elementName: r3, renderMediaPreview: !!n4 && i3 });
          } }), o3.for("dataDowncast").add(Dy(s3, { elementName: r3, renderMediaPreview: i3 })), o3.for("editingDowncast").elementToStructure({ model: "media", view: (t5, { writer: e5 }) => {
            const o4 = t5.getAttribute("url");
            return function(t6, e6, n4) {
              return e6.setCustomProperty("media", true, t6), Wk2(t6, e6, { label: n4 });
            }(Sy(e5, s3, o4, { elementName: r3, renderForEditingView: true }), e5, n3("media widget"));
          } }), o3.for("editingDowncast").add(Dy(s3, { elementName: r3, renderForEditingView: true })), o3.for("upcast").elementToElement({ view: (t5) => ["oembed", r3].includes(t5.name) && t5.getAttribute("url") ? { name: true } : null, model: (t5, { writer: e5 }) => {
            const n4 = t5.getAttribute("url");
            return s3.hasMedia(n4) ? e5.createElement("media", { url: n4 }) : null;
          } }).elementToElement({ view: { name: "div", attributes: { "data-oembed-url": true } }, model: (t5, { writer: e5 }) => {
            const n4 = t5.getAttribute("data-oembed-url");
            return s3.hasMedia(n4) ? e5.createElement("media", { url: n4 }) : null;
          } }).add((t5) => {
            t5.on("element:figure", (t6, e5, n4) => {
              if (!n4.consumable.consume(e5.viewItem, { name: true, classes: "media" }))
                return;
              const { modelRange: o4, modelCursor: i4 } = n4.convertChildren(e5.viewItem, e5.modelCursor);
              e5.modelRange = o4, e5.modelCursor = i4;
              Si2(o4.getItems()) || n4.consumable.revert(e5.viewItem, { name: true, classes: "media" });
            });
          });
        }
      }
      const Ly = /^(?:http(s)?:\/\/)?[\w-]+\.[\w-.~:/?#[\]@!$&'()*+,;=%]+$/;
      class jy extends $r {
        constructor(t4) {
          super(t4), this._timeoutId = null, this._positionToInsert = null;
        }
        static get requires() {
          return [Ub2, dk2, dw];
        }
        static get pluginName() {
          return "AutoMediaEmbed";
        }
        init() {
          const t4 = this.editor, e4 = t4.model.document, n3 = t4.plugins.get("ClipboardPipeline");
          this.listenTo(n3, "inputTransformation", () => {
            const t5 = e4.selection.getFirstRange(), n4 = pu.fromPosition(t5.start);
            n4.stickiness = "toPrevious";
            const o3 = pu.fromPosition(t5.end);
            o3.stickiness = "toNext", e4.once("change:data", () => {
              this._embedMediaBetweenPositions(n4, o3), n4.detach(), o3.detach();
            }, { priority: "high" });
          });
          t4.commands.get("undo").on("execute", () => {
            this._timeoutId && (zo2.window.clearTimeout(this._timeoutId), this._positionToInsert.detach(), this._timeoutId = null, this._positionToInsert = null);
          }, { priority: "high" });
        }
        _embedMediaBetweenPositions(t4, e4) {
          const n3 = this.editor, o3 = n3.plugins.get(Oy).registry, i3 = new md2(t4, e4), r3 = i3.getWalker({ ignoreElementEnd: true });
          let s3 = "";
          for (const t5 of r3)
            t5.item.is("$textProxy") && (s3 += t5.item.data);
          if (s3 = s3.trim(), !s3.match(Ly))
            return void i3.detach();
          if (!o3.hasMedia(s3))
            return void i3.detach();
          n3.commands.get("mediaEmbed").isEnabled ? (this._positionToInsert = pu.fromPosition(t4), this._timeoutId = zo2.window.setTimeout(() => {
            n3.model.change((t5) => {
              this._timeoutId = null, t5.remove(i3), i3.detach();
              let e5 = null;
              "$graveyard" !== this._positionToInsert.root.rootName && (e5 = this._positionToInsert), Ty(n3.model, s3, e5, false), this._positionToInsert.detach(), this._positionToInsert = null;
            }), n3.plugins.get(dk2).requestUndoOnBackspace();
          }, 100)) : i3.detach();
        }
      }
      var Ry = n2(9292), Fy = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Ry.Z, Fy);
      Ry.Z.locals;
      class Vy extends Hi2 {
        constructor(t4, e4) {
          super(e4);
          const n3 = e4.t;
          this.focusTracker = new Ii2(), this.keystrokes = new Ti2(), this.set("mediaURLInputValue", ""), this.urlInputView = this._createUrlInput(), this.saveButtonView = this._createButton(n3("Save"), Bg2.check, "ck-button-save"), this.saveButtonView.type = "submit", this.saveButtonView.bind("isEnabled").to(this, "mediaURLInputValue", (t5) => !!t5), this.cancelButtonView = this._createButton(n3("Cancel"), Bg2.cancel, "ck-button-cancel", "cancel"), this._focusables = new Li2(), this._focusCycler = new qr({ focusables: this._focusables, focusTracker: this.focusTracker, keystrokeHandler: this.keystrokes, actions: { focusPrevious: "shift + tab", focusNext: "tab" } }), this._validators = t4, this.setTemplate({ tag: "form", attributes: { class: ["ck", "ck-media-form", "ck-responsive-form"], tabindex: "-1" }, children: [this.urlInputView, this.saveButtonView, this.cancelButtonView] });
        }
        render() {
          super.render(), i2({ view: this });
          [this.urlInputView, this.saveButtonView, this.cancelButtonView].forEach((t5) => {
            this._focusables.add(t5), this.focusTracker.add(t5.element);
          }), this.keystrokes.listenTo(this.element);
          const t4 = (t5) => t5.stopPropagation();
          this.keystrokes.set("arrowright", t4), this.keystrokes.set("arrowleft", t4), this.keystrokes.set("arrowup", t4), this.keystrokes.set("arrowdown", t4);
        }
        destroy() {
          super.destroy(), this.focusTracker.destroy(), this.keystrokes.destroy();
        }
        focus() {
          this._focusCycler.focusFirst();
        }
        get url() {
          return this.urlInputView.fieldView.element.value.trim();
        }
        set url(t4) {
          this.urlInputView.fieldView.element.value = t4.trim();
        }
        isValid() {
          this.resetFormStatus();
          for (const t4 of this._validators) {
            const e4 = t4(this);
            if (e4)
              return this.urlInputView.errorText = e4, false;
          }
          return true;
        }
        resetFormStatus() {
          this.urlInputView.errorText = null, this.urlInputView.infoText = this._urlInputViewInfoDefault;
        }
        _createUrlInput() {
          const t4 = this.locale.t, e4 = new Ir(this.locale, ap), n3 = e4.fieldView;
          return this._urlInputViewInfoDefault = t4("Paste the media URL in the input."), this._urlInputViewInfoTip = t4("Tip: Paste the URL into the content to embed faster."), e4.label = t4("Media URL"), e4.infoText = this._urlInputViewInfoDefault, n3.on("input", () => {
            e4.infoText = n3.element.value ? this._urlInputViewInfoTip : this._urlInputViewInfoDefault, this.mediaURLInputValue = n3.element.value.trim();
          }), e4;
        }
        _createButton(t4, e4, n3, o3) {
          const i3 = new br(this.locale);
          return i3.set({ label: t4, icon: e4, tooltip: true }), i3.extendTemplate({ attributes: { class: n3 } }), o3 && i3.delegate("execute").to(this, o3), i3;
        }
      }
      class Hy extends $r {
        static get requires() {
          return [Oy];
        }
        static get pluginName() {
          return "MediaEmbedUI";
        }
        init() {
          const t4 = this.editor, e4 = t4.commands.get("mediaEmbed");
          t4.ui.componentFactory.add("mediaEmbed", (t5) => {
            const n3 = tp(t5);
            return this._setUpDropdown(n3, e4), n3;
          });
        }
        _setUpDropdown(t4, n3) {
          const o3 = this.editor, i3 = o3.t, r3 = t4.buttonView, s3 = o3.plugins.get(Oy).registry;
          t4.once("change:isOpen", () => {
            const i4 = new (e3(Vy))(function(t5, e4) {
              return [(e5) => {
                if (!e5.url.length)
                  return t5("The URL must not be empty.");
              }, (n4) => {
                if (!e4.hasMedia(n4.url))
                  return t5("This media URL is not supported.");
              }];
            }(o3.t, s3), o3.locale);
            t4.panelView.children.add(i4), r3.on("open", () => {
              i4.disableCssTransitions(), i4.url = n3.value || "", i4.urlInputView.fieldView.select(), i4.enableCssTransitions();
            }, { priority: "low" }), t4.on("submit", () => {
              i4.isValid() && (o3.execute("mediaEmbed", i4.url), o3.editing.view.focus());
            }), t4.on("change:isOpen", () => i4.resetFormStatus()), t4.on("cancel", () => {
              o3.editing.view.focus();
            }), i4.delegate("submit", "cancel").to(t4), i4.urlInputView.fieldView.bind("value").to(n3, "value"), i4.urlInputView.bind("isEnabled").to(n3, "isEnabled");
          }), t4.bind("isEnabled").to(n3), r3.set({ label: i3("Insert media"), icon: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20"><path d="M18.68 3.03c.6 0 .59-.03.59.55v12.84c0 .59.01.56-.59.56H1.29c-.6 0-.59.03-.59-.56V3.58c0-.58-.01-.55.6-.55h17.38zM15.77 15V5H4.2v10h11.57zM2 4v1h1V4H2zm0 2v1h1V6H2zm0 2v1h1V8H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zm0 2v1h1v-1H2zM17 4v1h1V4h-1zm0 2v1h1V6h-1zm0 2v1h1V8h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zm0 2v1h1v-1h-1zM7.5 7.177a.4.4 0 0 1 .593-.351l5.133 2.824a.4.4 0 0 1 0 .7l-5.133 2.824a.4.4 0 0 1-.593-.35V7.176v.001z"/></svg>', tooltip: true });
        }
      }
      var Uy = n2(4652), qy = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(Uy.Z, qy);
      Uy.Z.locals;
      function Gy(t4, e4) {
        if (!t4.childCount)
          return;
        const n3 = new Eg2(t4.document), o3 = function(t5, e5) {
          const n4 = e5.createRangeIn(t5), o4 = new bs({ name: /^p|h\d+$/, styles: { "mso-list": /.*/ } }), i4 = [];
          for (const t6 of n4)
            if ("elementStart" === t6.type && o4.match(t6.item)) {
              const e6 = Yy(t6.item);
              i4.push({ element: t6.item, id: e6.id, order: e6.order, indent: e6.indent });
            }
          return i4;
        }(t4, n3);
        if (!o3.length)
          return;
        let i3 = null, r3 = 1;
        o3.forEach((t5, s3) => {
          const a3 = function(t6, e5) {
            if (!t6)
              return true;
            if (t6.id !== e5.id)
              return e5.indent - t6.indent != 1;
            const n4 = e5.element.previousSibling;
            if (!n4)
              return true;
            return o4 = n4, !(o4.is("element", "ol") || o4.is("element", "ul"));
            var o4;
          }(o3[s3 - 1], t5), c3 = a3 ? null : o3[s3 - 1], l3 = (h3 = t5, (d3 = c3) ? h3.indent - d3.indent : h3.indent - 1);
          var d3, h3;
          if (a3 && (i3 = null, r3 = 1), !i3 || 0 !== l3) {
            const o4 = function(t6, e5) {
              const n4 = new RegExp(`@list l${t6.id}:level${t6.indent}\\s*({[^}]*)`, "gi"), o5 = /mso-level-number-format:([^;]{0,100});/gi, i4 = /mso-level-start-at:\s{0,100}([0-9]{0,10})\s{0,100};/gi, r4 = n4.exec(e5);
              let s4 = "decimal", a4 = "ol", c4 = null;
              if (r4 && r4[1]) {
                const e6 = o5.exec(r4[1]);
                if (e6 && e6[1] && (s4 = e6[1].trim(), a4 = "bullet" !== s4 && "image" !== s4 ? "ol" : "ul"), "bullet" === s4) {
                  const e7 = function(t7) {
                    const e8 = function(t8) {
                      if (t8.getChild(0).is("$text"))
                        return null;
                      for (const e9 of t8.getChildren()) {
                        if (!e9.is("element", "span"))
                          continue;
                        const t9 = e9.getChild(0);
                        if (t9)
                          return t9.is("$text") ? t9 : t9.getChild(0);
                      }
                      return null;
                    }(t7);
                    if (!e8)
                      return null;
                    const n5 = e8._data;
                    if ("o" === n5)
                      return "circle";
                    if ("·" === n5)
                      return "disc";
                    if ("§" === n5)
                      return "square";
                    return null;
                  }(t6.element);
                  e7 && (s4 = e7);
                } else {
                  const t7 = i4.exec(r4[1]);
                  t7 && t7[1] && (c4 = parseInt(t7[1]));
                }
              }
              return { type: a4, startIndex: c4, style: Wy(s4) };
            }(t5, e4);
            if (i3) {
              if (t5.indent > r3) {
                const t6 = i3.getChild(i3.childCount - 1), e5 = t6.getChild(t6.childCount - 1);
                i3 = Ky(o4, e5, n3), r3 += 1;
              } else if (t5.indent < r3) {
                const e5 = r3 - t5.indent;
                i3 = function(t6, e6) {
                  const n4 = t6.getAncestors({ parentFirst: true });
                  let o5 = null, i4 = 0;
                  for (const t7 of n4)
                    if ((t7.is("element", "ul") || t7.is("element", "ol")) && i4++, i4 === e6) {
                      o5 = t7;
                      break;
                    }
                  return o5;
                }(i3, e5), r3 = t5.indent;
              }
            } else
              i3 = Ky(o4, t5.element, n3);
            t5.indent <= r3 && (i3.is("element", o4.type) || (i3 = n3.rename(o4.type, i3)));
          }
          const u3 = function(t6, e5) {
            return function(t7, e6) {
              const n4 = new bs({ name: "span", styles: { "mso-list": "Ignore" } }), o4 = e6.createRangeIn(t7);
              for (const t8 of o4)
                "elementStart" === t8.type && n4.match(t8.item) && e6.remove(t8.item);
            }(t6, e5), e5.removeStyle("text-indent", t6), e5.rename("li", t6);
          }(t5.element, n3);
          n3.appendChild(u3, i3);
        });
      }
      function Wy(t4) {
        if (t4.startsWith("arabic-leading-zero"))
          return "decimal-leading-zero";
        switch (t4) {
          case "alpha-upper":
            return "upper-alpha";
          case "alpha-lower":
            return "lower-alpha";
          case "roman-upper":
            return "upper-roman";
          case "roman-lower":
            return "lower-roman";
          case "circle":
          case "disc":
          case "square":
            return t4;
          default:
            return null;
        }
      }
      function Ky(t4, e4, n3) {
        const o3 = e4.parent, i3 = n3.createElement(t4.type), r3 = o3.getChildIndex(e4) + 1;
        return n3.insertChild(r3, i3, o3), t4.style && n3.setStyle("list-style-type", t4.style, i3), t4.startIndex && t4.startIndex > 1 && n3.setAttribute("start", t4.startIndex, i3), i3;
      }
      function Yy(t4) {
        const e4 = {}, n3 = t4.getStyle("mso-list");
        if (n3) {
          const t5 = n3.match(/(^|\s{1,100})l(\d+)/i), o3 = n3.match(/\s{0,100}lfo(\d+)/i), i3 = n3.match(/\s{0,100}level(\d+)/i);
          t5 && o3 && i3 && (e4.id = t5[2], e4.order = o3[1], e4.indent = parseInt(i3[1]));
        }
        return e4;
      }
      function $y(t4, e4) {
        if (!t4.childCount)
          return;
        const n3 = new Eg2(t4.document), o3 = function(t5, e5) {
          const n4 = e5.createRangeIn(t5), o4 = new bs({ name: /v:(.+)/ }), i4 = [];
          for (const t6 of n4) {
            if ("elementStart" != t6.type)
              continue;
            const e6 = t6.item, n5 = e6.previousSibling, r3 = n5 && n5.is("element") ? n5.name : null;
            o4.match(e6) && e6.getAttribute("o:gfxdata") && "v:shapetype" !== r3 && i4.push(t6.item.getAttribute("id"));
          }
          return i4;
        }(t4, n3);
        !function(t5, e5, n4) {
          const o4 = n4.createRangeIn(e5), i4 = new bs({ name: "img" }), r3 = [];
          for (const e6 of o4)
            if (e6.item.is("element") && i4.match(e6.item)) {
              const n5 = e6.item, o5 = n5.getAttribute("v:shapes") ? n5.getAttribute("v:shapes").split(" ") : [];
              o5.length && o5.every((e7) => t5.indexOf(e7) > -1) ? r3.push(n5) : n5.getAttribute("src") || r3.push(n5);
            }
          for (const t6 of r3)
            n4.remove(t6);
        }(o3, t4, n3), function(t5, e5, n4) {
          const o4 = n4.createRangeIn(e5), i4 = [];
          for (const e6 of o4)
            if ("elementStart" == e6.type && e6.item.is("element", "v:shape")) {
              const n5 = e6.item.getAttribute("id");
              if (t5.includes(n5))
                continue;
              r3(e6.item.parent.getChildren(), n5) || i4.push(e6.item);
            }
          for (const t6 of i4) {
            const e6 = { src: s3(t6) };
            t6.hasAttribute("alt") && (e6.alt = t6.getAttribute("alt"));
            const o5 = n4.createElement("img", e6);
            n4.insertChild(t6.index + 1, o5, t6.parent);
          }
          function r3(t6, e6) {
            for (const n5 of t6)
              if (n5.is("element")) {
                if ("img" == n5.name && n5.getAttribute("v:shapes") == e6)
                  return true;
                if (r3(n5.getChildren(), e6))
                  return true;
              }
            return false;
          }
          function s3(t6) {
            for (const e6 of t6.getChildren())
              if (e6.is("element") && e6.getAttribute("src"))
                return e6.getAttribute("src");
          }
        }(o3, t4, n3), function(t5, e5) {
          const n4 = e5.createRangeIn(t5), o4 = new bs({ name: /v:(.+)/ }), i4 = [];
          for (const t6 of n4)
            "elementStart" == t6.type && o4.match(t6.item) && i4.push(t6.item);
          for (const t6 of i4)
            e5.remove(t6);
        }(t4, n3);
        const i3 = function(t5, e5) {
          const n4 = e5.createRangeIn(t5), o4 = new bs({ name: "img" }), i4 = [];
          for (const t6 of n4)
            t6.item.is("element") && o4.match(t6.item) && t6.item.getAttribute("src").startsWith("file://") && i4.push(t6.item);
          return i4;
        }(t4, n3);
        i3.length && function(t5, e5, n4) {
          if (t5.length === e5.length)
            for (let o4 = 0; o4 < t5.length; o4++) {
              const i4 = `data:${e5[o4].type};base64,${Zy(e5[o4].hex)}`;
              n4.setAttribute("src", i4, t5[o4]);
            }
        }(i3, function(t5) {
          if (!t5)
            return [];
          const e5 = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/, n4 = new RegExp("(?:(" + e5.source + "))([\\da-fA-F\\s]+)\\}", "g"), o4 = t5.match(n4), i4 = [];
          if (o4)
            for (const t6 of o4) {
              let n5 = false;
              t6.includes("\\pngblip") ? n5 = "image/png" : t6.includes("\\jpegblip") && (n5 = "image/jpeg"), n5 && i4.push({ hex: t6.replace(e5, "").replace(/[^\da-fA-F]/g, ""), type: n5 });
            }
          return i4;
        }(e4), n3);
      }
      function Zy(t4) {
        return btoa(t4.match(/\w{2}/g).map((t5) => String.fromCharCode(parseInt(t5, 16))).join(""));
      }
      const Qy = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i, Jy = /xmlns:o="urn:schemas-microsoft-com/i;
      class Xy {
        constructor(t4) {
          this.document = t4;
        }
        isActive(t4) {
          return Qy.test(t4) || Jy.test(t4);
        }
        execute(t4) {
          const { body: e4, stylesString: n3 } = t4._parsedData;
          Gy(e4, n3), $y(e4, t4.dataTransfer.getData("text/rtf")), t4.content = e4;
        }
      }
      function tx(t4, e4, n3, { blockElements: o3, inlineObjectElements: i3 }) {
        let r3 = n3.createPositionAt(t4, "forward" == e4 ? "after" : "before");
        return r3 = r3.getLastMatchingPosition(({ item: t5 }) => t5.is("element") && !o3.includes(t5.name) && !i3.includes(t5.name), { direction: e4 }), "forward" == e4 ? r3.nodeAfter : r3.nodeBefore;
      }
      function ex(t4, e4) {
        return !!t4 && t4.is("element") && e4.includes(t4.name);
      }
      const nx = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
      class ox {
        constructor(t4) {
          this.document = t4;
        }
        isActive(t4) {
          return nx.test(t4);
        }
        execute(t4) {
          const e4 = new Eg2(this.document), { body: n3 } = t4._parsedData;
          !function(t5, e5) {
            for (const n4 of t5.getChildren())
              if (n4.is("element", "b") && "normal" === n4.getStyle("font-weight")) {
                const o3 = t5.getChildIndex(n4);
                e5.remove(n4), e5.insertChild(o3, n4.getChildren(), t5);
              }
          }(n3, e4), function(t5, e5) {
            for (const n4 of e5.createRangeIn(t5)) {
              const t6 = n4.item;
              if (t6.is("element", "li")) {
                const n5 = t6.getChild(0);
                n5 && n5.is("element", "p") && e5.unwrapElement(n5);
              }
            }
          }(n3, e4), function(t5, e5) {
            const n4 = new ja2(e5.document.stylesProcessor), o3 = new Ic2(n4, { renderingMode: "data" }), i3 = o3.blockElements, r3 = o3.inlineObjectElements, s3 = [];
            for (const n5 of e5.createRangeIn(t5)) {
              const t6 = n5.item;
              if (t6.is("element", "br")) {
                const n6 = tx(t6, "forward", e5, { blockElements: i3, inlineObjectElements: r3 }), o4 = tx(t6, "backward", e5, { blockElements: i3, inlineObjectElements: r3 }), a3 = ex(n6, i3);
                (ex(o4, i3) || a3) && s3.push(t6);
              }
            }
            for (const t6 of s3)
              t6.hasClass("Apple-interchange-newline") ? e5.remove(t6) : e5.replace(t6, e5.createElement("p"));
          }(n3, e4), t4.content = n3;
        }
      }
      const ix = /<google-sheets-html-origin/i;
      class rx {
        constructor(t4) {
          this.document = t4;
        }
        isActive(t4) {
          return ix.test(t4);
        }
        execute(t4) {
          const e4 = new Eg2(this.document), { body: n3 } = t4._parsedData;
          !function(t5, e5) {
            for (const n4 of t5.getChildren())
              if (n4.is("element", "google-sheets-html-origin")) {
                const o3 = t5.getChildIndex(n4);
                e5.remove(n4), e5.insertChild(o3, n4.getChildren(), t5);
              }
          }(n3, e4), function(t5, e5) {
            for (const n4 of t5.getChildren())
              n4.is("element", "table") && n4.hasAttribute("xmlns") && e5.removeAttribute("xmlns", n4);
          }(n3, e4), function(t5, e5) {
            for (const n4 of t5.getChildren())
              n4.is("element", "table") && "0px" === n4.getStyle("width") && e5.removeStyle("width", n4);
          }(n3, e4), function(t5, e5) {
            for (const n4 of Array.from(t5.getChildren()))
              n4.is("element", "style") && e5.remove(n4);
          }(n3, e4), t4.content = n3;
        }
      }
      function sx(t4) {
        return t4.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, (t5, e4) => 1 === e4.length ? " " : Array(e4.length + 1).join("  ").substr(0, e4.length));
      }
      function ax(t4, e4) {
        const n3 = new DOMParser(), o3 = function(t5) {
          return sx(sx(t5)).replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[^\S\r\n]*?)[\r\n]+([^\S\r\n]*<\/span>)/g, "$1$2").replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, "").replace(/(<span\s+style=['"]letter-spacing:[^'"]+?['"]>)[\r\n]+(<\/span>)/g, "$1 $2").replace(/ <\//g, " </").replace(/ <o:p><\/o:p>/g, " <o:p></o:p>").replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, "").replace(/>([^\S\r\n]*[\r\n]\s*)</g, "><");
        }(function(t5) {
          const e5 = "</body>", n4 = "</html>", o4 = t5.indexOf(e5);
          if (o4 < 0)
            return t5;
          const i4 = t5.indexOf(n4, o4 + e5.length);
          return t5.substring(0, o4 + e5.length) + (i4 >= 0 ? t5.substring(i4) : "");
        }(t4 = t4.replace(/<!--\[if gte vml 1]>/g, ""))), i3 = n3.parseFromString(o3, "text/html");
        !function(t5) {
          t5.querySelectorAll("span[style*=spacerun]").forEach((t6) => {
            const e5 = t6, n4 = e5.innerText.length || 0;
            e5.innerText = Array(n4 + 1).join("  ").substr(0, n4);
          });
        }(i3);
        const r3 = i3.body.innerHTML, s3 = function(t5, e5) {
          const n4 = new ja2(e5), o4 = new Ic2(n4, { renderingMode: "data" }), i4 = t5.createDocumentFragment(), r4 = t5.body.childNodes;
          for (; r4.length > 0; )
            i4.appendChild(r4[0]);
          return o4.domToView(i4, { skipComments: true });
        }(i3, e4), a3 = function(t5) {
          const e5 = [], n4 = [], o4 = Array.from(t5.getElementsByTagName("style"));
          for (const t6 of o4)
            t6.sheet && t6.sheet.cssRules && t6.sheet.cssRules.length && (e5.push(t6.sheet), n4.push(t6.innerHTML));
          return { styles: e5, stylesString: n4.join(" ") };
        }(i3);
        return { body: s3, bodyString: r3, styles: a3.styles, stylesString: a3.stylesString };
      }
      function cx(t4, e4, n3, o3, i3 = 1) {
        null != e4 && null != i3 && e4 > i3 ? o3.setAttribute(t4, e4, n3) : o3.removeAttribute(t4, n3);
      }
      function lx(t4, e4, n3 = {}) {
        const o3 = t4.createElement("tableCell", n3);
        return t4.insertElement("paragraph", o3), t4.insert(o3, e4), o3;
      }
      function dx(t4, e4) {
        const n3 = e4.parent.parent, o3 = parseInt(n3.getAttribute("headingColumns") || "0"), { column: i3 } = t4.getCellLocation(e4);
        return !!o3 && i3 < o3;
      }
      function hx() {
        return (t4) => {
          t4.on("element:table", (t5, e4, n3) => {
            const o3 = e4.viewItem;
            if (!n3.consumable.test(o3, { name: true }))
              return;
            const { rows: i3, headingRows: r3, headingColumns: s3 } = function(t6) {
              let e5, n4 = 0;
              const o4 = [], i4 = [];
              let r4;
              for (const s4 of Array.from(t6.getChildren())) {
                if ("tbody" !== s4.name && "thead" !== s4.name && "tfoot" !== s4.name)
                  continue;
                "thead" !== s4.name || r4 || (r4 = s4);
                const t7 = Array.from(s4.getChildren()).filter((t8) => t8.is("element", "tr"));
                for (const a4 of t7)
                  if (r4 && s4 === r4 || "tbody" === s4.name && Array.from(a4.getChildren()).length && Array.from(a4.getChildren()).every((t8) => t8.is("element", "th")))
                    n4++, o4.push(a4);
                  else {
                    i4.push(a4);
                    const t8 = gx(a4);
                    (!e5 || t8 < e5) && (e5 = t8);
                  }
              }
              return { headingRows: n4, headingColumns: e5 || 0, rows: [...o4, ...i4] };
            }(o3), a3 = {};
            s3 && (a3.headingColumns = s3), r3 && (a3.headingRows = r3);
            const c3 = n3.writer.createElement("table", a3);
            if (n3.safeInsert(c3, e4.modelCursor)) {
              if (n3.consumable.consume(o3, { name: true }), i3.forEach((t6) => n3.convertItem(t6, n3.writer.createPositionAt(c3, "end"))), n3.convertChildren(o3, n3.writer.createPositionAt(c3, "end")), c3.isEmpty) {
                const t6 = n3.writer.createElement("tableRow");
                n3.writer.insert(t6, n3.writer.createPositionAt(c3, "end")), lx(n3.writer, n3.writer.createPositionAt(t6, "end"));
              }
              n3.updateConversionResult(c3, e4);
            }
          });
        };
      }
      function ux(t4) {
        return (e4) => {
          e4.on(`element:${t4}`, (t5, e5, { writer: n3 }) => {
            if (!e5.modelRange)
              return;
            const o3 = e5.modelRange.start.nodeAfter, i3 = n3.createPositionAt(o3, 0);
            if (e5.viewItem.isEmpty)
              return void n3.insertElement("paragraph", i3);
            const r3 = Array.from(o3.getChildren());
            if (r3.every((t6) => t6.is("element", "$marker"))) {
              const t6 = n3.createElement("paragraph");
              n3.insert(t6, n3.createPositionAt(o3, 0));
              for (const e6 of r3)
                n3.move(n3.createRangeOn(e6), n3.createPositionAt(t6, "end"));
            }
          }, { priority: "low" });
        };
      }
      function gx(t4) {
        let e4 = 0, n3 = 0;
        const o3 = Array.from(t4.getChildren()).filter((t5) => "th" === t5.name || "td" === t5.name);
        for (; n3 < o3.length && "th" === o3[n3].name; ) {
          const t5 = o3[n3];
          e4 += parseInt(t5.getAttribute("colspan") || "1"), n3++;
        }
        return e4;
      }
      class px {
        constructor(t4, e4 = {}) {
          this._jumpedToStartRow = false, this._table = t4, this._startRow = void 0 !== e4.row ? e4.row : e4.startRow || 0, this._endRow = void 0 !== e4.row ? e4.row : e4.endRow, this._startColumn = void 0 !== e4.column ? e4.column : e4.startColumn || 0, this._endColumn = void 0 !== e4.column ? e4.column : e4.endColumn, this._includeAllSlots = !!e4.includeAllSlots, this._skipRows = /* @__PURE__ */ new Set(), this._row = 0, this._rowIndex = 0, this._column = 0, this._cellIndex = 0, this._spannedCells = /* @__PURE__ */ new Map(), this._nextCellAtColumn = -1;
        }
        [Symbol.iterator]() {
          return this;
        }
        next() {
          this._canJumpToStartRow() && this._jumpToNonSpannedRowClosestToStartRow();
          const t4 = this._table.getChild(this._rowIndex);
          if (!t4 || this._isOverEndRow())
            return { done: true, value: void 0 };
          if (!t4.is("element", "tableRow"))
            return this._rowIndex++, this.next();
          if (this._isOverEndColumn())
            return this._advanceToNextRow();
          let e4 = null;
          const n3 = this._getSpanned();
          if (n3)
            this._includeAllSlots && !this._shouldSkipSlot() && (e4 = this._formatOutValue(n3.cell, n3.row, n3.column));
          else {
            const n4 = t4.getChild(this._cellIndex);
            if (!n4)
              return this._advanceToNextRow();
            const o3 = parseInt(n4.getAttribute("colspan") || "1"), i3 = parseInt(n4.getAttribute("rowspan") || "1");
            (o3 > 1 || i3 > 1) && this._recordSpans(n4, i3, o3), this._shouldSkipSlot() || (e4 = this._formatOutValue(n4)), this._nextCellAtColumn = this._column + o3;
          }
          return this._column++, this._column == this._nextCellAtColumn && this._cellIndex++, e4 || this.next();
        }
        skipRow(t4) {
          this._skipRows.add(t4);
        }
        _advanceToNextRow() {
          return this._row++, this._rowIndex++, this._column = 0, this._cellIndex = 0, this._nextCellAtColumn = -1, this.next();
        }
        _isOverEndRow() {
          return void 0 !== this._endRow && this._row > this._endRow;
        }
        _isOverEndColumn() {
          return void 0 !== this._endColumn && this._column > this._endColumn;
        }
        _formatOutValue(t4, e4 = this._row, n3 = this._column) {
          return { done: false, value: new mx(this, t4, e4, n3) };
        }
        _shouldSkipSlot() {
          const t4 = this._skipRows.has(this._row), e4 = this._row < this._startRow, n3 = this._column < this._startColumn, o3 = void 0 !== this._endColumn && this._column > this._endColumn;
          return t4 || e4 || n3 || o3;
        }
        _getSpanned() {
          const t4 = this._spannedCells.get(this._row);
          return t4 && t4.get(this._column) || null;
        }
        _recordSpans(t4, e4, n3) {
          const o3 = { cell: t4, row: this._row, column: this._column };
          for (let t5 = this._row; t5 < this._row + e4; t5++)
            for (let e5 = this._column; e5 < this._column + n3; e5++)
              t5 == this._row && e5 == this._column || this._markSpannedCell(t5, e5, o3);
        }
        _markSpannedCell(t4, e4, n3) {
          this._spannedCells.has(t4) || this._spannedCells.set(t4, /* @__PURE__ */ new Map());
          this._spannedCells.get(t4).set(e4, n3);
        }
        _canJumpToStartRow() {
          return !!this._startRow && this._startRow > 0 && !this._jumpedToStartRow;
        }
        _jumpToNonSpannedRowClosestToStartRow() {
          const t4 = this._getRowLength(0);
          for (let e4 = this._startRow; !this._jumpedToStartRow; e4--)
            t4 === this._getRowLength(e4) && (this._row = e4, this._rowIndex = e4, this._jumpedToStartRow = true);
        }
        _getRowLength(t4) {
          return [...this._table.getChild(t4).getChildren()].reduce((t5, e4) => t5 + parseInt(e4.getAttribute("colspan") || "1"), 0);
        }
      }
      class mx {
        constructor(t4, e4, n3, o3) {
          this.cell = e4, this.row = t4._row, this.column = t4._column, this.cellAnchorRow = n3, this.cellAnchorColumn = o3, this._cellIndex = t4._cellIndex, this._rowIndex = t4._rowIndex, this._table = t4._table;
        }
        get isAnchor() {
          return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
        }
        get cellWidth() {
          return parseInt(this.cell.getAttribute("colspan") || "1");
        }
        get cellHeight() {
          return parseInt(this.cell.getAttribute("rowspan") || "1");
        }
        get rowIndex() {
          return this._rowIndex;
        }
        getPositionBefore() {
          return this._table.root.document.model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
        }
      }
      function fx(t4, e4) {
        return (n3, { writer: o3 }) => {
          const i3 = n3.getAttribute("headingRows") || 0, r3 = o3.createContainerElement("table", null, []), s3 = o3.createContainerElement("figure", { class: "table" }, r3);
          i3 > 0 && o3.insert(o3.createPositionAt(r3, "end"), o3.createContainerElement("thead", null, o3.createSlot((t5) => t5.is("element", "tableRow") && t5.index < i3))), i3 < t4.getRows(n3) && o3.insert(o3.createPositionAt(r3, "end"), o3.createContainerElement("tbody", null, o3.createSlot((t5) => t5.is("element", "tableRow") && t5.index >= i3)));
          for (const { positionOffset: t5, filter: n4 } of e4.additionalSlots)
            o3.insert(o3.createPositionAt(r3, t5), o3.createSlot(n4));
          return o3.insert(o3.createPositionAt(r3, "after"), o3.createSlot((t5) => !t5.is("element", "tableRow") && !e4.additionalSlots.some(({ filter: e5 }) => e5(t5)))), e4.asWidget ? function(t5, e5) {
            return e5.setCustomProperty("table", true, t5), Wk2(t5, e5, { hasSelectionHandle: true });
          }(s3, o3) : s3;
        };
      }
      function kx(t4 = {}) {
        return (e4, { writer: n3 }) => {
          const o3 = e4.parent, i3 = o3.parent, r3 = i3.getChildIndex(o3), s3 = new px(i3, { row: r3 }), a3 = i3.getAttribute("headingRows") || 0, c3 = i3.getAttribute("headingColumns") || 0;
          let l3 = null;
          for (const o4 of s3)
            if (o4.cell == e4) {
              const e5 = o4.row < a3 || o4.column < c3 ? "th" : "td";
              l3 = t4.asWidget ? Zk2(n3.createEditableElement(e5), n3) : n3.createContainerElement(e5);
              break;
            }
          return l3;
        };
      }
      function bx(t4 = {}) {
        return (e4, { writer: n3 }) => {
          if (!e4.parent.is("element", "tableCell"))
            return null;
          if (!wx(e4))
            return null;
          if (t4.asWidget)
            return n3.createContainerElement("span", { class: "ck-table-bogus-paragraph" });
          {
            const t5 = n3.createContainerElement("p");
            return n3.setCustomProperty("dataPipeline:transparentRendering", true, t5), t5;
          }
        };
      }
      function wx(t4) {
        return 1 == t4.parent.childCount && !!t4.getAttributeKeys().next().done;
      }
      class Ax extends Qr {
        refresh() {
          const t4 = this.editor.model, e4 = t4.document.selection, n3 = t4.schema;
          this.isEnabled = function(t5, e5) {
            const n4 = t5.getFirstPosition().parent, o3 = n4 === n4.root ? n4 : n4.parent;
            return e5.checkChild(o3, "table");
          }(e4, n3);
        }
        execute(t4 = {}) {
          const e4 = this.editor, n3 = e4.model, o3 = e4.plugins.get("TableUtils"), i3 = e4.config.get("table.defaultHeadings.rows"), r3 = e4.config.get("table.defaultHeadings.columns");
          void 0 === t4.headingRows && i3 && (t4.headingRows = i3), void 0 === t4.headingColumns && r3 && (t4.headingColumns = r3), n3.change((e5) => {
            const i4 = o3.createTable(e5, t4);
            n3.insertObject(i4, null, null, { findOptimalPosition: "auto" }), e5.setSelection(e5.createPositionAt(i4.getNodeByPath([0, 0, 0]), 0));
          });
        }
      }
      class Cx extends Qr {
        constructor(t4, e4 = {}) {
          super(t4), this.order = e4.order || "below";
        }
        refresh() {
          const t4 = this.editor.model.document.selection, e4 = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t4).length;
          this.isEnabled = e4;
        }
        execute() {
          const t4 = this.editor, e4 = t4.model.document.selection, n3 = t4.plugins.get("TableUtils"), o3 = "above" === this.order, i3 = n3.getSelectionAffectedTableCells(e4), r3 = n3.getRowIndexes(i3), s3 = o3 ? r3.first : r3.last, a3 = i3[0].findAncestor("table");
          n3.insertRows(a3, { at: o3 ? s3 : s3 + 1, copyStructureFromAbove: !o3 });
        }
      }
      class _x extends Qr {
        constructor(t4, e4 = {}) {
          super(t4), this.order = e4.order || "right";
        }
        refresh() {
          const t4 = this.editor.model.document.selection, e4 = !!this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(t4).length;
          this.isEnabled = e4;
        }
        execute() {
          const t4 = this.editor, e4 = t4.model.document.selection, n3 = t4.plugins.get("TableUtils"), o3 = "left" === this.order, i3 = n3.getSelectionAffectedTableCells(e4), r3 = n3.getColumnIndexes(i3), s3 = o3 ? r3.first : r3.last, a3 = i3[0].findAncestor("table");
          n3.insertColumns(a3, { columns: 1, at: o3 ? s3 : s3 + 1 });
        }
      }
      class vx extends Qr {
        constructor(t4, e4 = {}) {
          super(t4), this.direction = e4.direction || "horizontally";
        }
        refresh() {
          const t4 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = 1 === t4.length;
        }
        execute() {
          const t4 = this.editor.plugins.get("TableUtils"), e4 = t4.getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
          "horizontally" === this.direction ? t4.splitCellHorizontally(e4, 2) : t4.splitCellVertically(e4, 2);
        }
      }
      function yx(t4, e4, n3) {
        const { startRow: o3, startColumn: i3, endRow: r3, endColumn: s3 } = e4, a3 = n3.createElement("table"), c3 = r3 - o3 + 1;
        for (let t5 = 0; t5 < c3; t5++)
          n3.insertElement("tableRow", a3, "end");
        const l3 = [...new px(t4, { startRow: o3, endRow: r3, startColumn: i3, endColumn: s3, includeAllSlots: true })];
        for (const { row: t5, column: e5, cell: c4, isAnchor: d3, cellAnchorRow: h3, cellAnchorColumn: u3 } of l3) {
          const l4 = t5 - o3, g3 = a3.getChild(l4);
          if (d3) {
            const o4 = n3.cloneElement(c4);
            n3.append(o4, g3), Ix(o4, t5, e5, r3, s3, n3);
          } else
            (h3 < o3 || u3 < i3) && lx(n3, n3.createPositionAt(g3, "end"));
        }
        return function(t5, e5, n4, o4, i4) {
          const r4 = parseInt(e5.getAttribute("headingRows") || "0");
          if (r4 > 0) {
            cx("headingRows", r4 - n4, t5, i4, 0);
          }
          const s4 = parseInt(e5.getAttribute("headingColumns") || "0");
          if (s4 > 0) {
            cx("headingColumns", s4 - o4, t5, i4, 0);
          }
        }(a3, t4, o3, i3, n3), a3;
      }
      function xx(t4, e4, n3 = 0) {
        const o3 = [], i3 = new px(t4, { startRow: n3, endRow: e4 - 1 });
        for (const t5 of i3) {
          const { row: n4, cellHeight: i4 } = t5;
          n4 < e4 && e4 <= n4 + i4 - 1 && o3.push(t5);
        }
        return o3;
      }
      function Ex(t4, e4, n3) {
        const o3 = t4.parent, i3 = o3.parent, r3 = o3.index, s3 = e4 - r3, a3 = {}, c3 = parseInt(t4.getAttribute("rowspan")) - s3;
        c3 > 1 && (a3.rowspan = c3);
        const l3 = parseInt(t4.getAttribute("colspan") || "1");
        l3 > 1 && (a3.colspan = l3);
        const d3 = r3 + s3, h3 = [...new px(i3, { startRow: r3, endRow: d3, includeAllSlots: true })];
        let u3, g3 = null;
        for (const e5 of h3) {
          const { row: o4, column: i4, cell: r4 } = e5;
          r4 === t4 && void 0 === u3 && (u3 = i4), void 0 !== u3 && u3 === i4 && o4 === d3 && (g3 = lx(n3, e5.getPositionBefore(), a3));
        }
        return cx("rowspan", s3, t4, n3), g3;
      }
      function Dx(t4, e4) {
        const n3 = [], o3 = new px(t4);
        for (const t5 of o3) {
          const { column: o4, cellWidth: i3 } = t5;
          o4 < e4 && e4 <= o4 + i3 - 1 && n3.push(t5);
        }
        return n3;
      }
      function Sx(t4, e4, n3, o3) {
        const i3 = n3 - e4, r3 = {}, s3 = parseInt(t4.getAttribute("colspan")) - i3;
        s3 > 1 && (r3.colspan = s3);
        const a3 = parseInt(t4.getAttribute("rowspan") || "1");
        a3 > 1 && (r3.rowspan = a3);
        const c3 = lx(o3, o3.createPositionAfter(t4), r3);
        return cx("colspan", i3, t4, o3), c3;
      }
      function Ix(t4, e4, n3, o3, i3, r3) {
        const s3 = parseInt(t4.getAttribute("colspan") || "1"), a3 = parseInt(t4.getAttribute("rowspan") || "1");
        if (n3 + s3 - 1 > i3) {
          cx("colspan", i3 - n3 + 1, t4, r3, 1);
        }
        if (e4 + a3 - 1 > o3) {
          cx("rowspan", o3 - e4 + 1, t4, r3, 1);
        }
      }
      function Tx(t4, e4) {
        const n3 = e4.getColumns(t4), o3 = new Array(n3).fill(0);
        for (const { column: e5 } of new px(t4))
          o3[e5]++;
        const i3 = o3.reduce((t5, e5, n4) => e5 ? t5 : [...t5, n4], []);
        if (i3.length > 0) {
          const n4 = i3[i3.length - 1];
          return e4.removeColumns(t4, { at: n4 }), true;
        }
        return false;
      }
      function Mx(t4, e4) {
        const n3 = [], o3 = e4.getRows(t4);
        for (let e5 = 0; e5 < o3; e5++) {
          t4.getChild(e5).isEmpty && n3.push(e5);
        }
        if (n3.length > 0) {
          const o4 = n3[n3.length - 1];
          return e4.removeRows(t4, { at: o4 }), true;
        }
        return false;
      }
      function Bx(t4, e4) {
        Tx(t4, e4) || Mx(t4, e4);
      }
      function Nx(t4, e4) {
        const n3 = Array.from(new px(t4, { startColumn: e4.firstColumn, endColumn: e4.lastColumn, row: e4.lastRow }));
        if (n3.every(({ cellHeight: t5 }) => 1 === t5))
          return e4.lastRow;
        const o3 = n3[0].cellHeight - 1;
        return e4.lastRow + o3;
      }
      function Px(t4, e4) {
        const n3 = Array.from(new px(t4, { startRow: e4.firstRow, endRow: e4.lastRow, column: e4.lastColumn }));
        if (n3.every(({ cellWidth: t5 }) => 1 === t5))
          return e4.lastColumn;
        const o3 = n3[0].cellWidth - 1;
        return e4.lastColumn + o3;
      }
      class zx extends Qr {
        constructor(t4, e4) {
          super(t4), this.direction = e4.direction, this.isHorizontal = "right" == this.direction || "left" == this.direction;
        }
        refresh() {
          const t4 = this._getMergeableCell();
          this.value = t4, this.isEnabled = !!t4;
        }
        execute() {
          const t4 = this.editor.model, e4 = t4.document, n3 = this.editor.plugins.get("TableUtils").getTableCellsContainingSelection(e4.selection)[0], o3 = this.value, i3 = this.direction;
          t4.change((t5) => {
            const e5 = "right" == i3 || "down" == i3, r3 = e5 ? n3 : o3, s3 = e5 ? o3 : n3, a3 = s3.parent;
            !function(t6, e6, n4) {
              Ox(t6) || (Ox(e6) && n4.remove(n4.createRangeIn(e6)), n4.move(n4.createRangeIn(t6), n4.createPositionAt(e6, "end")));
              n4.remove(t6);
            }(s3, r3, t5);
            const c3 = this.isHorizontal ? "colspan" : "rowspan", l3 = parseInt(n3.getAttribute(c3) || "1"), d3 = parseInt(o3.getAttribute(c3) || "1");
            t5.setAttribute(c3, l3 + d3, r3), t5.setSelection(t5.createRangeIn(r3));
            const h3 = this.editor.plugins.get("TableUtils");
            Bx(a3.findAncestor("table"), h3);
          });
        }
        _getMergeableCell() {
          const t4 = this.editor.model.document, e4 = this.editor.plugins.get("TableUtils"), n3 = e4.getTableCellsContainingSelection(t4.selection)[0];
          if (!n3)
            return;
          const o3 = this.isHorizontal ? function(t5, e5, n4) {
            const o4 = t5.parent, i4 = o4.parent, r4 = "right" == e5 ? t5.nextSibling : t5.previousSibling, s3 = (i4.getAttribute("headingColumns") || 0) > 0;
            if (!r4)
              return;
            const a3 = "right" == e5 ? t5 : r4, c3 = "right" == e5 ? r4 : t5, { column: l3 } = n4.getCellLocation(a3), { column: d3 } = n4.getCellLocation(c3), h3 = parseInt(a3.getAttribute("colspan") || "1"), u3 = dx(n4, a3), g3 = dx(n4, c3);
            if (s3 && u3 != g3)
              return;
            return l3 + h3 === d3 ? r4 : void 0;
          }(n3, this.direction, e4) : function(t5, e5, n4) {
            const o4 = t5.parent, i4 = o4.parent, r4 = i4.getChildIndex(o4);
            if ("down" == e5 && r4 === n4.getRows(i4) - 1 || "up" == e5 && 0 === r4)
              return null;
            const s3 = parseInt(t5.getAttribute("rowspan") || "1"), a3 = i4.getAttribute("headingRows") || 0, c3 = "down" == e5 && r4 + s3 === a3, l3 = "up" == e5 && r4 === a3;
            if (a3 && (c3 || l3))
              return null;
            const d3 = parseInt(t5.getAttribute("rowspan") || "1"), h3 = "down" == e5 ? r4 + d3 : r4, u3 = [...new px(i4, { endRow: h3 })], g3 = u3.find((e6) => e6.cell === t5), p3 = g3.column, m3 = u3.find(({ row: t6, cellHeight: n5, column: o5 }) => o5 === p3 && ("down" == e5 ? t6 === h3 : h3 === t6 + n5));
            return m3 && m3.cell ? m3.cell : null;
          }(n3, this.direction, e4);
          if (!o3)
            return;
          const i3 = this.isHorizontal ? "rowspan" : "colspan", r3 = parseInt(n3.getAttribute(i3) || "1");
          return parseInt(o3.getAttribute(i3) || "1") === r3 ? o3 : void 0;
        }
      }
      function Ox(t4) {
        const e4 = t4.getChild(0);
        return 1 == t4.childCount && e4.is("element", "paragraph") && e4.isEmpty;
      }
      class Lx extends Qr {
        refresh() {
          const t4 = this.editor.plugins.get("TableUtils"), e4 = t4.getSelectionAffectedTableCells(this.editor.model.document.selection), n3 = e4[0];
          if (n3) {
            const o3 = n3.findAncestor("table"), i3 = t4.getRows(o3) - 1, r3 = t4.getRowIndexes(e4), s3 = 0 === r3.first && r3.last === i3;
            this.isEnabled = !s3;
          } else
            this.isEnabled = false;
        }
        execute() {
          const t4 = this.editor.model, e4 = this.editor.plugins.get("TableUtils"), n3 = e4.getSelectionAffectedTableCells(t4.document.selection), o3 = e4.getRowIndexes(n3), i3 = n3[0], r3 = i3.findAncestor("table"), s3 = e4.getCellLocation(i3).column;
          t4.change((t5) => {
            const n4 = o3.last - o3.first + 1;
            e4.removeRows(r3, { at: o3.first, rows: n4 });
            const i4 = function(t6, e5, n5, o4) {
              const i5 = t6.getChild(Math.min(e5, o4 - 1));
              let r4 = i5.getChild(0), s4 = 0;
              for (const t7 of i5.getChildren()) {
                if (s4 > n5)
                  return r4;
                r4 = t7, s4 += parseInt(t7.getAttribute("colspan") || "1");
              }
              return r4;
            }(r3, o3.first, s3, e4.getRows(r3));
            t5.setSelection(t5.createPositionAt(i4, 0));
          });
        }
      }
      class jx extends Qr {
        refresh() {
          const t4 = this.editor.plugins.get("TableUtils"), e4 = t4.getSelectionAffectedTableCells(this.editor.model.document.selection), n3 = e4[0];
          if (n3) {
            const o3 = n3.findAncestor("table"), i3 = t4.getColumns(o3), { first: r3, last: s3 } = t4.getColumnIndexes(e4);
            this.isEnabled = s3 - r3 < i3 - 1;
          } else
            this.isEnabled = false;
        }
        execute() {
          const t4 = this.editor.plugins.get("TableUtils"), [e4, n3] = function(t5, e5) {
            const n4 = e5.getSelectionAffectedTableCells(t5), o4 = n4[0], i4 = n4.pop(), r4 = [o4, i4];
            return o4.isBefore(i4) ? r4 : r4.reverse();
          }(this.editor.model.document.selection, t4), o3 = e4.parent.parent, i3 = [...new px(o3)], r3 = { first: i3.find((t5) => t5.cell === e4).column, last: i3.find((t5) => t5.cell === n3).column }, s3 = function(t5, e5, n4, o4) {
            const i4 = parseInt(n4.getAttribute("colspan") || "1");
            return i4 > 1 ? n4 : e5.previousSibling || n4.nextSibling ? n4.nextSibling || e5.previousSibling : o4.first ? t5.reverse().find(({ column: t6 }) => t6 < o4.first).cell : t5.reverse().find(({ column: t6 }) => t6 > o4.last).cell;
          }(i3, e4, n3, r3);
          this.editor.model.change((e5) => {
            const n4 = r3.last - r3.first + 1;
            t4.removeColumns(o3, { at: r3.first, columns: n4 }), e5.setSelection(e5.createPositionAt(s3, 0));
          });
        }
      }
      class Rx extends Qr {
        refresh() {
          const t4 = this.editor.plugins.get("TableUtils"), e4 = this.editor.model, n3 = t4.getSelectionAffectedTableCells(e4.document.selection), o3 = n3.length > 0;
          this.isEnabled = o3, this.value = o3 && n3.every((t5) => this._isInHeading(t5, t5.parent.parent));
        }
        execute(t4 = {}) {
          if (t4.forceValue === this.value)
            return;
          const e4 = this.editor.plugins.get("TableUtils"), n3 = this.editor.model, o3 = e4.getSelectionAffectedTableCells(n3.document.selection), i3 = o3[0].findAncestor("table"), { first: r3, last: s3 } = e4.getRowIndexes(o3), a3 = this.value ? r3 : s3 + 1, c3 = i3.getAttribute("headingRows") || 0;
          n3.change((t5) => {
            if (a3) {
              const e5 = xx(i3, a3, a3 > c3 ? c3 : 0);
              for (const { cell: n4 } of e5)
                Ex(n4, a3, t5);
            }
            cx("headingRows", a3, i3, t5, 0);
          });
        }
        _isInHeading(t4, e4) {
          const n3 = parseInt(e4.getAttribute("headingRows") || "0");
          return !!n3 && t4.parent.index < n3;
        }
      }
      class Fx extends Qr {
        refresh() {
          const t4 = this.editor.model, e4 = this.editor.plugins.get("TableUtils"), n3 = e4.getSelectionAffectedTableCells(t4.document.selection), o3 = n3.length > 0;
          this.isEnabled = o3, this.value = o3 && n3.every((t5) => dx(e4, t5));
        }
        execute(t4 = {}) {
          if (t4.forceValue === this.value)
            return;
          const e4 = this.editor.plugins.get("TableUtils"), n3 = this.editor.model, o3 = e4.getSelectionAffectedTableCells(n3.document.selection), i3 = o3[0].findAncestor("table"), { first: r3, last: s3 } = e4.getColumnIndexes(o3), a3 = this.value ? r3 : s3 + 1;
          n3.change((t5) => {
            if (a3) {
              const e5 = Dx(i3, a3);
              for (const { cell: n4, column: o4 } of e5)
                Sx(n4, o4, a3, t5);
            }
            cx("headingColumns", a3, i3, t5, 0);
          });
        }
      }
      function Vx(t4) {
        if (t4.is("element", "tableColumnGroup"))
          return t4;
        const e4 = t4.getChildren();
        return Array.from(e4).find((t5) => t5.is("element", "tableColumnGroup"));
      }
      function Hx(t4) {
        const e4 = Vx(t4);
        return e4 ? Array.from(e4.getChildren()) : [];
      }
      class Ux extends $r {
        static get pluginName() {
          return "TableUtils";
        }
        init() {
          this.decorate("insertColumns"), this.decorate("insertRows");
        }
        getCellLocation(t4) {
          const e4 = t4.parent, n3 = e4.parent, o3 = n3.getChildIndex(e4), i3 = new px(n3, { row: o3 });
          for (const { cell: e5, row: n4, column: o4 } of i3)
            if (e5 === t4)
              return { row: n4, column: o4 };
        }
        createTable(t4, e4) {
          const n3 = t4.createElement("table"), o3 = e4.rows || 2, i3 = e4.columns || 2;
          return qx(t4, n3, 0, o3, i3), e4.headingRows && cx("headingRows", Math.min(e4.headingRows, o3), n3, t4, 0), e4.headingColumns && cx("headingColumns", Math.min(e4.headingColumns, i3), n3, t4, 0), n3;
        }
        insertRows(t4, e4 = {}) {
          const n3 = this.editor.model, o3 = e4.at || 0, i3 = e4.rows || 1, r3 = void 0 !== e4.copyStructureFromAbove, s3 = e4.copyStructureFromAbove ? o3 - 1 : o3, a3 = this.getRows(t4), c3 = this.getColumns(t4);
          if (o3 > a3)
            throw new A2("tableutils-insertrows-insert-out-of-range", this, { options: e4 });
          n3.change((e5) => {
            const n4 = t4.getAttribute("headingRows") || 0;
            if (n4 > o3 && cx("headingRows", n4 + i3, t4, e5, 0), !r3 && (0 === o3 || o3 === a3))
              return void qx(e5, t4, o3, i3, c3);
            const l3 = r3 ? Math.max(o3, s3) : o3, d3 = new px(t4, { endRow: l3 }), h3 = new Array(c3).fill(1);
            for (const { row: t5, column: n5, cellHeight: a4, cellWidth: c4, cell: l4 } of d3) {
              const d4 = t5 + a4 - 1, u3 = t5 <= s3 && s3 <= d4;
              t5 < o3 && o3 <= d4 ? (e5.setAttribute("rowspan", a4 + i3, l4), h3[n5] = -c4) : r3 && u3 && (h3[n5] = c4);
            }
            for (let n5 = 0; n5 < i3; n5++) {
              const n6 = e5.createElement("tableRow");
              e5.insert(n6, t4, o3);
              for (let t5 = 0; t5 < h3.length; t5++) {
                const o4 = h3[t5], i4 = e5.createPositionAt(n6, "end");
                o4 > 0 && lx(e5, i4, o4 > 1 ? { colspan: o4 } : void 0), t5 += Math.abs(o4) - 1;
              }
            }
          });
        }
        insertColumns(t4, e4 = {}) {
          const n3 = this.editor.model, o3 = e4.at || 0, i3 = e4.columns || 1;
          n3.change((e5) => {
            const n4 = t4.getAttribute("headingColumns");
            o3 < n4 && e5.setAttribute("headingColumns", n4 + i3, t4);
            const r3 = this.getColumns(t4);
            if (0 === o3 || r3 === o3) {
              for (const n5 of t4.getChildren())
                n5.is("element", "tableRow") && Gx(i3, e5, e5.createPositionAt(n5, o3 ? "end" : 0));
              return;
            }
            const s3 = new px(t4, { column: o3, includeAllSlots: true });
            for (const t5 of s3) {
              const { row: n5, cell: r4, cellAnchorColumn: a3, cellAnchorRow: c3, cellWidth: l3, cellHeight: d3 } = t5;
              if (a3 < o3) {
                e5.setAttribute("colspan", l3 + i3, r4);
                const t6 = c3 + d3 - 1;
                for (let e6 = n5; e6 <= t6; e6++)
                  s3.skipRow(e6);
              } else
                Gx(i3, e5, t5.getPositionBefore());
            }
          });
        }
        removeRows(t4, e4) {
          const n3 = this.editor.model, o3 = e4.rows || 1, i3 = this.getRows(t4), r3 = e4.at, s3 = r3 + o3 - 1;
          if (s3 > i3 - 1)
            throw new A2("tableutils-removerows-row-index-out-of-range", this, { table: t4, options: e4 });
          n3.change((e5) => {
            const n4 = { first: r3, last: s3 }, { cellsToMove: o4, cellsToTrim: i4 } = function(t5, { first: e6, last: n5 }) {
              const o5 = /* @__PURE__ */ new Map(), i5 = [];
              for (const { row: r4, column: s4, cellHeight: a3, cell: c3 } of new px(t5, { endRow: n5 })) {
                const t6 = r4 + a3 - 1;
                if (r4 >= e6 && r4 <= n5 && t6 > n5) {
                  const t7 = a3 - (n5 - r4 + 1);
                  o5.set(s4, { cell: c3, rowspan: t7 });
                }
                if (r4 < e6 && t6 >= e6) {
                  let o6;
                  o6 = t6 >= n5 ? n5 - e6 + 1 : t6 - e6 + 1, i5.push({ cell: c3, rowspan: a3 - o6 });
                }
              }
              return { cellsToMove: o5, cellsToTrim: i5 };
            }(t4, n4);
            if (o4.size) {
              !function(t5, e6, n5, o5) {
                const i5 = new px(t5, { includeAllSlots: true, row: e6 }), r4 = [...i5], s4 = t5.getChild(e6);
                let a3;
                for (const { column: t6, cell: e7, isAnchor: i6 } of r4)
                  if (n5.has(t6)) {
                    const { cell: e8, rowspan: i7 } = n5.get(t6), r5 = a3 ? o5.createPositionAfter(a3) : o5.createPositionAt(s4, 0);
                    o5.move(o5.createRangeOn(e8), r5), cx("rowspan", i7, e8, o5), a3 = e8;
                  } else
                    i6 && (a3 = e7);
              }(t4, s3 + 1, o4, e5);
            }
            for (let n5 = s3; n5 >= r3; n5--)
              e5.remove(t4.getChild(n5));
            for (const { rowspan: t5, cell: n5 } of i4)
              cx("rowspan", t5, n5, e5);
            !function(t5, { first: e6, last: n5 }, o5) {
              const i5 = t5.getAttribute("headingRows") || 0;
              if (e6 < i5) {
                cx("headingRows", n5 < i5 ? i5 - (n5 - e6 + 1) : e6, t5, o5, 0);
              }
            }(t4, n4, e5), Tx(t4, this) || Mx(t4, this);
          });
        }
        removeColumns(t4, e4) {
          const n3 = this.editor.model, o3 = e4.at, i3 = e4.columns || 1, r3 = e4.at + i3 - 1;
          n3.change((e5) => {
            !function(t5, e6, n5) {
              const o4 = t5.getAttribute("headingColumns") || 0;
              if (o4 && e6.first < o4) {
                const i4 = Math.min(o4 - 1, e6.last) - e6.first + 1;
                n5.setAttribute("headingColumns", o4 - i4, t5);
              }
            }(t4, { first: o3, last: r3 }, e5);
            const n4 = Hx(t4);
            for (let i4 = r3; i4 >= o3; i4--) {
              for (const { cell: n5, column: o4, cellWidth: r4 } of [...new px(t4)])
                o4 <= i4 && r4 > 1 && o4 + r4 > i4 ? cx("colspan", r4 - 1, n5, e5) : o4 === i4 && e5.remove(n5);
              if (n4[i4]) {
                const t5 = 0 === i4 ? n4[1] : n4[i4 - 1], o4 = parseFloat(n4[i4].getAttribute("columnWidth")), r4 = parseFloat(t5.getAttribute("columnWidth"));
                e5.remove(n4[i4]), e5.setAttribute("columnWidth", o4 + r4 + "%", t5);
              }
            }
            Mx(t4, this) || Tx(t4, this);
          });
        }
        splitCellVertically(t4, e4 = 2) {
          const n3 = this.editor.model, o3 = t4.parent.parent, i3 = parseInt(t4.getAttribute("rowspan") || "1"), r3 = parseInt(t4.getAttribute("colspan") || "1");
          n3.change((n4) => {
            if (r3 > 1) {
              const { newCellsSpan: o4, updatedSpan: s3 } = Wx(r3, e4);
              cx("colspan", s3, t4, n4);
              const a3 = {};
              o4 > 1 && (a3.colspan = o4), i3 > 1 && (a3.rowspan = i3);
              Gx(r3 > e4 ? e4 - 1 : r3 - 1, n4, n4.createPositionAfter(t4), a3);
            }
            if (r3 < e4) {
              const s3 = e4 - r3, a3 = [...new px(o3)], { column: c3 } = a3.find(({ cell: e5 }) => e5 === t4), l3 = a3.filter(({ cell: e5, cellWidth: n5, column: o4 }) => e5 !== t4 && o4 === c3 || o4 < c3 && o4 + n5 > c3);
              for (const { cell: t5, cellWidth: e5 } of l3)
                n4.setAttribute("colspan", e5 + s3, t5);
              const d3 = {};
              i3 > 1 && (d3.rowspan = i3), Gx(s3, n4, n4.createPositionAfter(t4), d3);
              const h3 = o3.getAttribute("headingColumns") || 0;
              h3 > c3 && cx("headingColumns", h3 + s3, o3, n4);
            }
          });
        }
        splitCellHorizontally(t4, e4 = 2) {
          const n3 = this.editor.model, o3 = t4.parent, i3 = o3.parent, r3 = i3.getChildIndex(o3), s3 = parseInt(t4.getAttribute("rowspan") || "1"), a3 = parseInt(t4.getAttribute("colspan") || "1");
          n3.change((n4) => {
            if (s3 > 1) {
              const o4 = [...new px(i3, { startRow: r3, endRow: r3 + s3 - 1, includeAllSlots: true })], { newCellsSpan: c3, updatedSpan: l3 } = Wx(s3, e4);
              cx("rowspan", l3, t4, n4);
              const { column: d3 } = o4.find(({ cell: e5 }) => e5 === t4), h3 = {};
              c3 > 1 && (h3.rowspan = c3), a3 > 1 && (h3.colspan = a3);
              for (const t5 of o4) {
                const { column: e5, row: o5 } = t5;
                o5 >= r3 + l3 && e5 === d3 && (o5 + r3 + l3) % c3 == 0 && Gx(1, n4, t5.getPositionBefore(), h3);
              }
            }
            if (s3 < e4) {
              const o4 = e4 - s3, c3 = [...new px(i3, { startRow: 0, endRow: r3 })];
              for (const { cell: e5, cellHeight: i4, row: s4 } of c3)
                if (e5 !== t4 && s4 + i4 > r3) {
                  const t5 = i4 + o4;
                  n4.setAttribute("rowspan", t5, e5);
                }
              const l3 = {};
              a3 > 1 && (l3.colspan = a3), qx(n4, i3, r3 + 1, o4, 1, l3);
              const d3 = i3.getAttribute("headingRows") || 0;
              d3 > r3 && cx("headingRows", d3 + o4, i3, n4);
            }
          });
        }
        getColumns(t4) {
          return [...t4.getChild(0).getChildren()].reduce((t5, e4) => t5 + parseInt(e4.getAttribute("colspan") || "1"), 0);
        }
        getRows(t4) {
          return Array.from(t4.getChildren()).reduce((t5, e4) => e4.is("element", "tableRow") ? t5 + 1 : t5, 0);
        }
        createTableWalker(t4, e4 = {}) {
          return new px(t4, e4);
        }
        getSelectedTableCells(t4) {
          const e4 = [];
          for (const n3 of this.sortRanges(t4.getRanges())) {
            const t5 = n3.getContainedElement();
            t5 && t5.is("element", "tableCell") && e4.push(t5);
          }
          return e4;
        }
        getTableCellsContainingSelection(t4) {
          const e4 = [];
          for (const n3 of t4.getRanges()) {
            const t5 = n3.start.findAncestor("tableCell");
            t5 && e4.push(t5);
          }
          return e4;
        }
        getSelectionAffectedTableCells(t4) {
          const e4 = this.getSelectedTableCells(t4);
          return e4.length ? e4 : this.getTableCellsContainingSelection(t4);
        }
        getRowIndexes(t4) {
          const e4 = t4.map((t5) => t5.parent.index);
          return this._getFirstLastIndexesObject(e4);
        }
        getColumnIndexes(t4) {
          const e4 = t4[0].findAncestor("table"), n3 = [...new px(e4)].filter((e5) => t4.includes(e5.cell)).map((t5) => t5.column);
          return this._getFirstLastIndexesObject(n3);
        }
        isSelectionRectangular(t4) {
          if (t4.length < 2 || !this._areCellInTheSameTableSection(t4))
            return false;
          const e4 = /* @__PURE__ */ new Set(), n3 = /* @__PURE__ */ new Set();
          let o3 = 0;
          for (const i4 of t4) {
            const { row: t5, column: r3 } = this.getCellLocation(i4), s3 = parseInt(i4.getAttribute("rowspan")) || 1, a3 = parseInt(i4.getAttribute("colspan")) || 1;
            e4.add(t5), n3.add(r3), s3 > 1 && e4.add(t5 + s3 - 1), a3 > 1 && n3.add(r3 + a3 - 1), o3 += s3 * a3;
          }
          const i3 = function(t5, e5) {
            const n4 = Array.from(t5.values()), o4 = Array.from(e5.values()), i4 = Math.max(...n4), r3 = Math.min(...n4), s3 = Math.max(...o4), a3 = Math.min(...o4);
            return (i4 - r3 + 1) * (s3 - a3 + 1);
          }(e4, n3);
          return i3 == o3;
        }
        sortRanges(t4) {
          return Array.from(t4).sort(Kx);
        }
        _getFirstLastIndexesObject(t4) {
          const e4 = t4.sort((t5, e5) => t5 - e5);
          return { first: e4[0], last: e4[e4.length - 1] };
        }
        _areCellInTheSameTableSection(t4) {
          const e4 = t4[0].findAncestor("table"), n3 = this.getRowIndexes(t4), o3 = parseInt(e4.getAttribute("headingRows")) || 0;
          if (!this._areIndexesInSameSection(n3, o3))
            return false;
          const i3 = this.getColumnIndexes(t4), r3 = parseInt(e4.getAttribute("headingColumns")) || 0;
          return this._areIndexesInSameSection(i3, r3);
        }
        _areIndexesInSameSection({ first: t4, last: e4 }, n3) {
          return t4 < n3 === e4 < n3;
        }
      }
      function qx(t4, e4, n3, o3, i3, r3 = {}) {
        for (let s3 = 0; s3 < o3; s3++) {
          const o4 = t4.createElement("tableRow");
          t4.insert(o4, e4, n3), Gx(i3, t4, t4.createPositionAt(o4, "end"), r3);
        }
      }
      function Gx(t4, e4, n3, o3 = {}) {
        for (let i3 = 0; i3 < t4; i3++)
          lx(e4, n3, o3);
      }
      function Wx(t4, e4) {
        if (t4 < e4)
          return { newCellsSpan: 1, updatedSpan: 1 };
        const n3 = Math.floor(t4 / e4);
        return { newCellsSpan: n3, updatedSpan: t4 - n3 * e4 + n3 };
      }
      function Kx(t4, e4) {
        const n3 = t4.start, o3 = e4.start;
        return n3.isBefore(o3) ? -1 : 1;
      }
      class Yx extends Qr {
        refresh() {
          const t4 = this.editor.plugins.get(Ux), e4 = t4.getSelectedTableCells(this.editor.model.document.selection);
          this.isEnabled = t4.isSelectionRectangular(e4);
        }
        execute() {
          const t4 = this.editor.model, e4 = this.editor.plugins.get(Ux);
          t4.change((n3) => {
            const o3 = e4.getSelectedTableCells(t4.document.selection), i3 = o3.shift(), { mergeWidth: r3, mergeHeight: s3 } = function(t5, e5, n4) {
              let o4 = 0, i4 = 0;
              for (const t6 of e5) {
                const { row: e6, column: r5 } = n4.getCellLocation(t6);
                o4 = Qx(t6, r5, o4, "colspan"), i4 = Qx(t6, e6, i4, "rowspan");
              }
              const { row: r4, column: s4 } = n4.getCellLocation(t5), a3 = o4 - s4, c3 = i4 - r4;
              return { mergeWidth: a3, mergeHeight: c3 };
            }(i3, o3, e4);
            cx("colspan", r3, i3, n3), cx("rowspan", s3, i3, n3);
            for (const t5 of o3)
              $x(t5, i3, n3);
            Bx(i3.findAncestor("table"), e4), n3.setSelection(i3, "in");
          });
        }
      }
      function $x(t4, e4, n3) {
        Zx(t4) || (Zx(e4) && n3.remove(n3.createRangeIn(e4)), n3.move(n3.createRangeIn(t4), n3.createPositionAt(e4, "end"))), n3.remove(t4);
      }
      function Zx(t4) {
        const e4 = t4.getChild(0);
        return 1 == t4.childCount && e4.is("element", "paragraph") && e4.isEmpty;
      }
      function Qx(t4, e4, n3, o3) {
        const i3 = parseInt(t4.getAttribute(o3) || "1");
        return Math.max(n3, e4 + i3);
      }
      class Jx extends Qr {
        constructor(t4) {
          super(t4), this.affectsData = false;
        }
        refresh() {
          const t4 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = t4.length > 0;
        }
        execute() {
          const t4 = this.editor.model, e4 = this.editor.plugins.get("TableUtils"), n3 = e4.getSelectionAffectedTableCells(t4.document.selection), o3 = e4.getRowIndexes(n3), i3 = n3[0].findAncestor("table"), r3 = [];
          for (let e5 = o3.first; e5 <= o3.last; e5++)
            for (const n4 of i3.getChild(e5).getChildren())
              r3.push(t4.createRangeOn(n4));
          t4.change((t5) => {
            t5.setSelection(r3);
          });
        }
      }
      class Xx extends Qr {
        constructor(t4) {
          super(t4), this.affectsData = false;
        }
        refresh() {
          const t4 = this.editor.plugins.get("TableUtils").getSelectionAffectedTableCells(this.editor.model.document.selection);
          this.isEnabled = t4.length > 0;
        }
        execute() {
          const t4 = this.editor.plugins.get("TableUtils"), e4 = this.editor.model, n3 = t4.getSelectionAffectedTableCells(e4.document.selection), o3 = n3[0], i3 = n3.pop(), r3 = o3.findAncestor("table"), s3 = t4.getCellLocation(o3), a3 = t4.getCellLocation(i3), c3 = Math.min(s3.column, a3.column), l3 = Math.max(s3.column, a3.column), d3 = [];
          for (const t5 of new px(r3, { startColumn: c3, endColumn: l3 }))
            d3.push(e4.createRangeOn(t5.cell));
          e4.change((t5) => {
            t5.setSelection(d3);
          });
        }
      }
      function tE(t4) {
        t4.document.registerPostFixer((e4) => function(t5, e5) {
          const n3 = e5.document.differ.getChanges();
          let o3 = false;
          const i3 = /* @__PURE__ */ new Set();
          for (const e6 of n3) {
            let n4 = null;
            "insert" == e6.type && "table" == e6.name && (n4 = e6.position.nodeAfter), "insert" != e6.type && "remove" != e6.type || "tableRow" != e6.name && "tableCell" != e6.name || (n4 = e6.position.findAncestor("table")), oE(e6) && (n4 = e6.range.start.findAncestor("table")), n4 && !i3.has(n4) && (o3 = eE(n4, t5) || o3, o3 = nE(n4, t5) || o3, i3.add(n4));
          }
          return o3;
        }(e4, t4));
      }
      function eE(t4, e4) {
        let n3 = false;
        const o3 = function(t5) {
          const e5 = parseInt(t5.getAttribute("headingRows") || "0"), n4 = Array.from(t5.getChildren()).reduce((t6, e6) => e6.is("element", "tableRow") ? t6 + 1 : t6, 0), o4 = [];
          for (const { row: i3, cell: r3, cellHeight: s3 } of new px(t5)) {
            if (s3 < 2)
              continue;
            const t6 = i3 < e5 ? e5 : n4;
            if (i3 + s3 > t6) {
              const e6 = t6 - i3;
              o4.push({ cell: r3, rowspan: e6 });
            }
          }
          return o4;
        }(t4);
        if (o3.length) {
          n3 = true;
          for (const t5 of o3)
            cx("rowspan", t5.rowspan, t5.cell, e4, 1);
        }
        return n3;
      }
      function nE(t4, e4) {
        let n3 = false;
        const o3 = function(t5) {
          const e5 = new Array(t5.childCount).fill(0);
          for (const { rowIndex: n4 } of new px(t5, { includeAllSlots: true }))
            e5[n4]++;
          return e5;
        }(t4), i3 = [];
        for (const [e5, n4] of o3.entries())
          !n4 && t4.getChild(e5).is("element", "tableRow") && i3.push(e5);
        if (i3.length) {
          n3 = true;
          for (const n4 of i3.reverse())
            e4.remove(t4.getChild(n4)), o3.splice(n4, 1);
        }
        const r3 = o3.filter((e5, n4) => t4.getChild(n4).is("element", "tableRow")), s3 = r3[0];
        if (!r3.every((t5) => t5 === s3)) {
          const o4 = r3.reduce((t5, e5) => e5 > t5 ? e5 : t5, 0);
          for (const [i4, s4] of r3.entries()) {
            const r4 = o4 - s4;
            if (r4) {
              for (let n4 = 0; n4 < r4; n4++)
                lx(e4, e4.createPositionAt(t4.getChild(i4), "end"));
              n3 = true;
            }
          }
        }
        return n3;
      }
      function oE(t4) {
        if ("attribute" !== t4.type)
          return false;
        const e4 = t4.attributeKey;
        return "headingRows" === e4 || "colspan" === e4 || "rowspan" === e4;
      }
      function iE(t4) {
        t4.document.registerPostFixer((e4) => function(t5, e5) {
          const n3 = e5.document.differ.getChanges();
          let o3 = false;
          for (const e6 of n3)
            "insert" == e6.type && "table" == e6.name && (o3 = rE(e6.position.nodeAfter, t5) || o3), "insert" == e6.type && "tableRow" == e6.name && (o3 = sE(e6.position.nodeAfter, t5) || o3), "insert" == e6.type && "tableCell" == e6.name && (o3 = aE(e6.position.nodeAfter, t5) || o3), "remove" != e6.type && "insert" != e6.type || !cE(e6) || (o3 = aE(e6.position.parent, t5) || o3);
          return o3;
        }(e4, t4));
      }
      function rE(t4, e4) {
        let n3 = false;
        for (const o3 of t4.getChildren())
          o3.is("element", "tableRow") && (n3 = sE(o3, e4) || n3);
        return n3;
      }
      function sE(t4, e4) {
        let n3 = false;
        for (const o3 of t4.getChildren())
          n3 = aE(o3, e4) || n3;
        return n3;
      }
      function aE(t4, e4) {
        if (0 == t4.childCount)
          return e4.insertElement("paragraph", t4), true;
        const n3 = Array.from(t4.getChildren()).filter((t5) => t5.is("$text"));
        for (const t5 of n3)
          e4.wrap(e4.createRangeOn(t5), "paragraph");
        return !!n3.length;
      }
      function cE(t4) {
        return !!t4.position.parent.is("element", "tableCell") && ("insert" == t4.type && "$text" == t4.name || "remove" == t4.type);
      }
      function lE(t4, e4) {
        if (!t4.is("element", "paragraph"))
          return false;
        const n3 = e4.toViewElement(t4);
        return !!n3 && wx(t4) !== n3.is("element", "span");
      }
      var dE = n2(3881), hE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(dE.Z, hE);
      dE.Z.locals;
      class uE extends $r {
        constructor(t4) {
          super(t4), this._additionalSlots = [];
        }
        static get pluginName() {
          return "TableEditing";
        }
        static get requires() {
          return [Ux];
        }
        init() {
          const t4 = this.editor, e4 = t4.model, n3 = e4.schema, o3 = t4.conversion, i3 = t4.plugins.get(Ux);
          n3.register("table", { inheritAllFrom: "$blockObject", allowAttributes: ["headingRows", "headingColumns"] }), n3.register("tableRow", { allowIn: "table", isLimit: true }), n3.register("tableCell", { allowContentOf: "$container", allowIn: "tableRow", allowAttributes: ["colspan", "rowspan"], isLimit: true, isSelectable: true }), o3.for("upcast").add((t5) => {
            t5.on("element:figure", (t6, e5, n4) => {
              if (!n4.consumable.test(e5.viewItem, { name: true, classes: "table" }))
                return;
              const o4 = function(t7) {
                for (const e6 of t7.getChildren())
                  if (e6.is("element", "table"))
                    return e6;
              }(e5.viewItem);
              if (!o4 || !n4.consumable.test(o4, { name: true }))
                return;
              n4.consumable.consume(e5.viewItem, { name: true, classes: "table" });
              const i4 = Si2(n4.convertItem(o4, e5.modelCursor).modelRange.getItems());
              i4 ? (n4.convertChildren(e5.viewItem, n4.writer.createPositionAt(i4, "end")), n4.updateConversionResult(i4, e5)) : n4.consumable.revert(e5.viewItem, { name: true, classes: "table" });
            });
          }), o3.for("upcast").add(hx()), o3.for("editingDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: fx(i3, { asWidget: true, additionalSlots: this._additionalSlots }) }), o3.for("dataDowncast").elementToStructure({ model: { name: "table", attributes: ["headingRows"] }, view: fx(i3, { additionalSlots: this._additionalSlots }) }), o3.for("upcast").elementToElement({ model: "tableRow", view: "tr" }), o3.for("upcast").add((t5) => {
            t5.on("element:tr", (t6, e5) => {
              e5.viewItem.isEmpty && 0 == e5.modelCursor.index && t6.stop();
            }, { priority: "high" });
          }), o3.for("downcast").elementToElement({ model: "tableRow", view: (t5, { writer: e5 }) => t5.isEmpty ? e5.createEmptyElement("tr") : e5.createContainerElement("tr") }), o3.for("upcast").elementToElement({ model: "tableCell", view: "td" }), o3.for("upcast").elementToElement({ model: "tableCell", view: "th" }), o3.for("upcast").add(ux("td")), o3.for("upcast").add(ux("th")), o3.for("editingDowncast").elementToElement({ model: "tableCell", view: kx({ asWidget: true }) }), o3.for("dataDowncast").elementToElement({ model: "tableCell", view: kx() }), o3.for("editingDowncast").elementToElement({ model: "paragraph", view: bx({ asWidget: true }), converterPriority: "high" }), o3.for("dataDowncast").elementToElement({ model: "paragraph", view: bx(), converterPriority: "high" }), o3.for("downcast").attributeToAttribute({ model: "colspan", view: "colspan" }), o3.for("upcast").attributeToAttribute({ model: { key: "colspan", value: gE("colspan") }, view: "colspan" }), o3.for("downcast").attributeToAttribute({ model: "rowspan", view: "rowspan" }), o3.for("upcast").attributeToAttribute({ model: { key: "rowspan", value: gE("rowspan") }, view: "rowspan" }), t4.config.define("table.defaultHeadings.rows", 0), t4.config.define("table.defaultHeadings.columns", 0), t4.commands.add("insertTable", new Ax(t4)), t4.commands.add("insertTableRowAbove", new Cx(t4, { order: "above" })), t4.commands.add("insertTableRowBelow", new Cx(t4, { order: "below" })), t4.commands.add("insertTableColumnLeft", new _x(t4, { order: "left" })), t4.commands.add("insertTableColumnRight", new _x(t4, { order: "right" })), t4.commands.add("removeTableRow", new Lx(t4)), t4.commands.add("removeTableColumn", new jx(t4)), t4.commands.add("splitTableCellVertically", new vx(t4, { direction: "vertically" })), t4.commands.add("splitTableCellHorizontally", new vx(t4, { direction: "horizontally" })), t4.commands.add("mergeTableCells", new Yx(t4)), t4.commands.add("mergeTableCellRight", new zx(t4, { direction: "right" })), t4.commands.add("mergeTableCellLeft", new zx(t4, { direction: "left" })), t4.commands.add("mergeTableCellDown", new zx(t4, { direction: "down" })), t4.commands.add("mergeTableCellUp", new zx(t4, { direction: "up" })), t4.commands.add("setTableColumnHeader", new Fx(t4)), t4.commands.add("setTableRowHeader", new Rx(t4)), t4.commands.add("selectTableRow", new Jx(t4)), t4.commands.add("selectTableColumn", new Xx(t4)), tE(e4), iE(e4), this.listenTo(e4.document, "change:data", () => {
            !function(t5, e5) {
              const n4 = t5.document.differ;
              for (const t6 of n4.getChanges()) {
                let n5, o4 = false;
                if ("attribute" == t6.type) {
                  const e6 = t6.range.start.nodeAfter;
                  if (!e6 || !e6.is("element", "table"))
                    continue;
                  if ("headingRows" != t6.attributeKey && "headingColumns" != t6.attributeKey)
                    continue;
                  n5 = e6, o4 = "headingRows" == t6.attributeKey;
                } else
                  "tableRow" != t6.name && "tableCell" != t6.name || (n5 = t6.position.findAncestor("table"), o4 = "tableRow" == t6.name);
                if (!n5)
                  continue;
                const i4 = n5.getAttribute("headingRows") || 0, r3 = n5.getAttribute("headingColumns") || 0, s3 = new px(n5);
                for (const t7 of s3) {
                  const n6 = t7.row < i4 || t7.column < r3 ? "th" : "td", s4 = e5.mapper.toViewElement(t7.cell);
                  s4 && s4.is("element") && s4.name != n6 && e5.reconvertItem(o4 ? t7.cell.parent : t7.cell);
                }
              }
            }(e4, t4.editing), function(t5, e5) {
              const n4 = t5.document.differ, o4 = /* @__PURE__ */ new Set();
              for (const t6 of n4.getChanges()) {
                const e6 = "attribute" == t6.type ? t6.range.start.parent : t6.position.parent;
                e6.is("element", "tableCell") && o4.add(e6);
              }
              for (const t6 of o4.values()) {
                const n5 = Array.from(t6.getChildren()).filter((t7) => lE(t7, e5.mapper));
                for (const t7 of n5)
                  e5.reconvertItem(t7);
              }
            }(e4, t4.editing);
          });
        }
        registerAdditionalSlot(t4) {
          this._additionalSlots.push(t4);
        }
      }
      function gE(t4) {
        return (e4) => {
          const n3 = parseInt(e4.getAttribute(t4));
          return Number.isNaN(n3) || n3 <= 0 ? null : n3;
        };
      }
      var pE = n2(1613), mE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(pE.Z, mE);
      pE.Z.locals;
      class fE extends Hi2 {
        constructor(t4) {
          super(t4);
          const e4 = this.bindTemplate;
          this.items = this._createGridCollection(), this.keystrokes = new Ti2(), this.focusTracker = new Ii2(), this.set("rows", 0), this.set("columns", 0), this.bind("label").to(this, "columns", this, "rows", (t5, e5) => `${e5} × ${t5}`), this.setTemplate({ tag: "div", attributes: { class: ["ck"] }, children: [{ tag: "div", attributes: { class: ["ck-insert-table-dropdown__grid"] }, on: { "mouseover@.ck-insert-table-dropdown-grid-box": e4.to("boxover") }, children: this.items }, { tag: "div", attributes: { class: ["ck", "ck-insert-table-dropdown__label"], "aria-hidden": true }, children: [{ text: e4.to("label") }] }], on: { mousedown: e4.to((t5) => {
            t5.preventDefault();
          }), click: e4.to(() => {
            this.fire("execute");
          }) } }), this.on("boxover", (t5, e5) => {
            const { row: n3, column: o3 } = e5.target.dataset;
            this.items.get(10 * (parseInt(n3, 10) - 1) + (parseInt(o3, 10) - 1)).focus();
          }), this.focusTracker.on("change:focusedElement", (t5, e5, n3) => {
            if (!n3)
              return;
            const { row: o3, column: i3 } = n3.dataset;
            this.set({ rows: parseInt(o3), columns: parseInt(i3) });
          }), this.on("change:columns", () => this._highlightGridBoxes()), this.on("change:rows", () => this._highlightGridBoxes());
        }
        render() {
          super.render(), function({ keystrokeHandler: t4, focusTracker: e4, gridItems: n3, numberOfColumns: o3, uiLanguageDirection: i3 }) {
            const r3 = "number" == typeof o3 ? () => o3 : o3;
            function s3(t5) {
              return (o4) => {
                const i4 = n3.find((t6) => t6.element === e4.focusedElement), r4 = n3.getIndex(i4), s4 = t5(r4, n3);
                n3.get(s4).focus(), o4.stopPropagation(), o4.preventDefault();
              };
            }
            function a3(t5, e5) {
              return t5 === e5 - 1 ? 0 : t5 + 1;
            }
            function c3(t5, e5) {
              return 0 === t5 ? e5 - 1 : t5 - 1;
            }
            t4.set("arrowright", s3((t5, e5) => "rtl" === i3 ? c3(t5, e5.length) : a3(t5, e5.length))), t4.set("arrowleft", s3((t5, e5) => "rtl" === i3 ? a3(t5, e5.length) : c3(t5, e5.length))), t4.set("arrowup", s3((t5, e5) => {
              let n4 = t5 - r3();
              return n4 < 0 && (n4 = t5 + r3() * Math.floor(e5.length / r3()), n4 > e5.length - 1 && (n4 -= r3())), n4;
            })), t4.set("arrowdown", s3((t5, e5) => {
              let n4 = t5 + r3();
              return n4 > e5.length - 1 && (n4 = t5 % r3()), n4;
            }));
          }({ keystrokeHandler: this.keystrokes, focusTracker: this.focusTracker, gridItems: this.items, numberOfColumns: 10, uiLanguageDirection: this.locale && this.locale.uiLanguageDirection });
          for (const t4 of this.items)
            this.focusTracker.add(t4.element);
          this.keystrokes.listenTo(this.element);
        }
        focus() {
          this.items.get(0).focus();
        }
        focusLast() {
          this.items.get(0).focus();
        }
        _highlightGridBoxes() {
          const t4 = this.rows, e4 = this.columns;
          this.items.map((n3, o3) => {
            const i3 = Math.floor(o3 / 10) < t4 && o3 % 10 < e4;
            n3.set("isOn", i3);
          });
        }
        _createGridButton(t4, e4, n3, o3) {
          const i3 = new br(t4);
          return i3.set({ label: o3, class: "ck-insert-table-dropdown-grid-box" }), i3.extendTemplate({ attributes: { "data-row": e4, "data-column": n3 } }), i3;
        }
        _createGridCollection() {
          const t4 = [];
          for (let e4 = 0; e4 < 100; e4++) {
            const n3 = Math.floor(e4 / 10), o3 = e4 % 10, i3 = `${n3 + 1} × ${o3 + 1}`;
            t4.push(this._createGridButton(this.locale, n3 + 1, o3 + 1, i3));
          }
          return this.createCollection(t4);
        }
      }
      class kE extends $r {
        static get pluginName() {
          return "TableUI";
        }
        init() {
          const t4 = this.editor, e4 = this.editor.t, n3 = "ltr" === t4.locale.contentLanguageDirection;
          t4.ui.componentFactory.add("insertTable", (n4) => {
            const o3 = t4.commands.get("insertTable"), i3 = tp(n4);
            let r3;
            return i3.bind("isEnabled").to(o3), i3.buttonView.set({ icon: '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z"/></svg>', label: e4("Insert table"), tooltip: true }), i3.on("change:isOpen", () => {
              r3 || (r3 = new fE(n4), i3.panelView.children.add(r3), r3.delegate("execute").to(i3), i3.on("execute", () => {
                t4.execute("insertTable", { rows: r3.rows, columns: r3.columns }), t4.editing.view.focus();
              }));
            }), i3;
          }), t4.ui.componentFactory.add("tableColumn", (t5) => {
            const o3 = [{ type: "switchbutton", model: { commandName: "setTableColumnHeader", label: e4("Header column"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: n3 ? "insertTableColumnLeft" : "insertTableColumnRight", label: e4("Insert column left") } }, { type: "button", model: { commandName: n3 ? "insertTableColumnRight" : "insertTableColumnLeft", label: e4("Insert column right") } }, { type: "button", model: { commandName: "removeTableColumn", label: e4("Delete column") } }, { type: "button", model: { commandName: "selectTableColumn", label: e4("Select column") } }];
            return this._prepareDropdown(e4("Column"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M18 7v1H2V7h16zm0 5v1H2v-1h16z" opacity=".6"/><path d="M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z"/></svg>', o3, t5);
          }), t4.ui.componentFactory.add("tableRow", (t5) => {
            const n4 = [{ type: "switchbutton", model: { commandName: "setTableRowHeader", label: e4("Header row"), bindIsOn: true } }, { type: "separator" }, { type: "button", model: { commandName: "insertTableRowAbove", label: e4("Insert row above") } }, { type: "button", model: { commandName: "insertTableRowBelow", label: e4("Insert row below") } }, { type: "button", model: { commandName: "removeTableRow", label: e4("Delete row") } }, { type: "button", model: { commandName: "selectTableRow", label: e4("Select row") } }];
            return this._prepareDropdown(e4("Row"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v16h-1V2z" opacity=".6"/><path d="M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z"/></svg>', n4, t5);
          }), t4.ui.componentFactory.add("mergeTableCells", (t5) => {
            const o3 = [{ type: "button", model: { commandName: "mergeTableCellUp", label: e4("Merge cell up") } }, { type: "button", model: { commandName: n3 ? "mergeTableCellRight" : "mergeTableCellLeft", label: e4("Merge cell right") } }, { type: "button", model: { commandName: "mergeTableCellDown", label: e4("Merge cell down") } }, { type: "button", model: { commandName: n3 ? "mergeTableCellLeft" : "mergeTableCellRight", label: e4("Merge cell left") } }, { type: "separator" }, { type: "button", model: { commandName: "splitTableCellVertically", label: e4("Split cell vertically") } }, { type: "button", model: { commandName: "splitTableCellHorizontally", label: e4("Split cell horizontally") } }];
            return this._prepareMergeSplitButtonDropdown(e4("Merge cells"), '<svg viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg"><path d="M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z" opacity=".6"/><path d="M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z" opacity=".6"/><path d="M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z"/></svg>', o3, t5);
          });
        }
        _prepareDropdown(t4, e4, n3, o3) {
          const i3 = this.editor, r3 = tp(o3), s3 = this._fillDropdownWithListOptions(r3, n3);
          return r3.buttonView.set({ label: t4, icon: e4, tooltip: true }), r3.bind("isEnabled").toMany(s3, "isEnabled", (...t5) => t5.some((t6) => t6)), this.listenTo(r3, "execute", (t5) => {
            i3.execute(t5.source.commandName), t5.source instanceof Cr || i3.editing.view.focus();
          }), r3;
        }
        _prepareMergeSplitButtonDropdown(t4, e4, n3, o3) {
          const i3 = this.editor, r3 = tp(o3, $g2), s3 = "mergeTableCells", a3 = i3.commands.get(s3), c3 = this._fillDropdownWithListOptions(r3, n3);
          return r3.buttonView.set({ label: t4, icon: e4, tooltip: true, isEnabled: true }), r3.bind("isEnabled").toMany([a3, ...c3], "isEnabled", (...t5) => t5.some((t6) => t6)), this.listenTo(r3.buttonView, "execute", () => {
            i3.execute(s3), i3.editing.view.focus();
          }), this.listenTo(r3, "execute", (t5) => {
            i3.execute(t5.source.commandName), i3.editing.view.focus();
          }), r3;
        }
        _fillDropdownWithListOptions(t4, e4) {
          const n3 = this.editor, o3 = [], i3 = new Di2();
          for (const t5 of e4)
            bE(t5, n3, o3, i3);
          return op(t4, i3), o3;
        }
      }
      function bE(t4, e4, n3, o3) {
        if ("button" === t4.type || "switchbutton" === t4.type) {
          const o4 = t4.model = new Fm(t4.model), { commandName: i3, bindIsOn: r3 } = t4.model, s3 = e4.commands.get(i3);
          n3.push(s3), o4.set({ commandName: i3 }), o4.bind("isEnabled").to(s3), r3 && o4.bind("isOn").to(s3, "value"), o4.set({ withText: true });
        }
        o3.add(t4);
      }
      var wE = n2(6945), AE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(wE.Z, AE);
      wE.Z.locals;
      class CE extends $r {
        static get pluginName() {
          return "TableSelection";
        }
        static get requires() {
          return [Ux, Ux];
        }
        init() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.editing.view;
          this.listenTo(e4, "deleteContent", (t5, e5) => this._handleDeleteContent(t5, e5), { priority: "high" }), this.listenTo(n3.document, "insertText", (t5, e5) => this._handleInsertTextEvent(t5, e5), { priority: "high" }), this._defineSelectionConverter(), this._enablePluginDisabling();
        }
        getSelectedTableCells() {
          const t4 = this.editor.plugins.get(Ux), e4 = this.editor.model.document.selection, n3 = t4.getSelectedTableCells(e4);
          return 0 == n3.length ? null : n3;
        }
        getSelectionAsFragment() {
          const t4 = this.editor.plugins.get(Ux), e4 = this.getSelectedTableCells();
          return e4 ? this.editor.model.change((n3) => {
            const o3 = n3.createDocumentFragment(), { first: i3, last: r3 } = t4.getColumnIndexes(e4), { first: s3, last: a3 } = t4.getRowIndexes(e4), c3 = e4[0].findAncestor("table");
            let l3 = a3, d3 = r3;
            if (t4.isSelectionRectangular(e4)) {
              const t5 = { firstColumn: i3, lastColumn: r3, firstRow: s3, lastRow: a3 };
              l3 = Nx(c3, t5), d3 = Px(c3, t5);
            }
            const h3 = yx(c3, { startRow: s3, startColumn: i3, endRow: l3, endColumn: d3 }, n3);
            return n3.insert(h3, o3, 0), o3;
          }) : null;
        }
        setCellSelection(t4, e4) {
          const n3 = this._getCellsToSelect(t4, e4);
          this.editor.model.change((t5) => {
            t5.setSelection(n3.cells.map((e5) => t5.createRangeOn(e5)), { backward: n3.backward });
          });
        }
        getFocusCell() {
          const t4 = [...this.editor.model.document.selection.getRanges()].pop().getContainedElement();
          return t4 && t4.is("element", "tableCell") ? t4 : null;
        }
        getAnchorCell() {
          const t4 = Si2(this.editor.model.document.selection.getRanges()).getContainedElement();
          return t4 && t4.is("element", "tableCell") ? t4 : null;
        }
        _defineSelectionConverter() {
          const t4 = this.editor, e4 = /* @__PURE__ */ new Set();
          t4.conversion.for("editingDowncast").add((t5) => t5.on("selection", (t6, n3, o3) => {
            const i3 = o3.writer;
            !function(t7) {
              for (const n4 of e4)
                t7.removeClass("ck-editor__editable_selected", n4);
              e4.clear();
            }(i3);
            const r3 = this.getSelectedTableCells();
            if (!r3)
              return;
            for (const t7 of r3) {
              const n4 = o3.mapper.toViewElement(t7);
              i3.addClass("ck-editor__editable_selected", n4), e4.add(n4);
            }
            const s3 = o3.mapper.toViewElement(r3[r3.length - 1]);
            i3.setSelection(s3, 0);
          }, { priority: "lowest" }));
        }
        _enablePluginDisabling() {
          const t4 = this.editor;
          this.on("change:isEnabled", () => {
            if (!this.isEnabled) {
              const e4 = this.getSelectedTableCells();
              if (!e4)
                return;
              t4.model.change((n3) => {
                const o3 = n3.createPositionAt(e4[0], 0), i3 = t4.model.schema.getNearestSelectionRange(o3);
                n3.setSelection(i3);
              });
            }
          });
        }
        _handleDeleteContent(t4, e4) {
          const n3 = this.editor.plugins.get(Ux), o3 = e4[0], i3 = e4[1], r3 = this.editor.model, s3 = !i3 || "backward" == i3.direction, a3 = n3.getSelectedTableCells(o3);
          a3.length && (t4.stop(), r3.change((t5) => {
            const e5 = a3[s3 ? a3.length - 1 : 0];
            r3.change((t6) => {
              for (const e6 of a3)
                r3.deleteContent(t6.createSelection(e6, "in"));
            });
            const n4 = r3.schema.getNearestSelectionRange(t5.createPositionAt(e5, 0));
            o3.is("documentSelection") ? t5.setSelection(n4) : o3.setTo(n4);
          }));
        }
        _handleInsertTextEvent(t4, e4) {
          const n3 = this.editor, o3 = this.getSelectedTableCells();
          if (!o3)
            return;
          const i3 = n3.editing.view, r3 = n3.editing.mapper, s3 = o3.map((t5) => i3.createRangeOn(r3.toViewElement(t5)));
          e4.selection = i3.createSelection(s3);
        }
        _getCellsToSelect(t4, e4) {
          const n3 = this.editor.plugins.get("TableUtils"), o3 = n3.getCellLocation(t4), i3 = n3.getCellLocation(e4), r3 = Math.min(o3.row, i3.row), s3 = Math.max(o3.row, i3.row), a3 = Math.min(o3.column, i3.column), c3 = Math.max(o3.column, i3.column), l3 = new Array(s3 - r3 + 1).fill(null).map(() => []), d3 = { startRow: r3, endRow: s3, startColumn: a3, endColumn: c3 };
          for (const { row: e5, cell: n4 } of new px(t4.findAncestor("table"), d3))
            l3[e5 - r3].push(n4);
          const h3 = i3.row < o3.row, u3 = i3.column < o3.column;
          return h3 && l3.reverse(), u3 && l3.forEach((t5) => t5.reverse()), { cells: l3.flat(), backward: h3 || u3 };
        }
      }
      class _E extends $r {
        static get pluginName() {
          return "TableClipboard";
        }
        static get requires() {
          return [CE, Ux];
        }
        init() {
          const t4 = this.editor, e4 = t4.editing.view.document;
          this.listenTo(e4, "copy", (t5, e5) => this._onCopyCut(t5, e5)), this.listenTo(e4, "cut", (t5, e5) => this._onCopyCut(t5, e5)), this.listenTo(t4.model, "insertContent", (t5, [e5, n3]) => this._onInsertContent(t5, e5, n3), { priority: "high" }), this.decorate("_replaceTableSlotCell");
        }
        _onCopyCut(t4, e4) {
          const n3 = this.editor.plugins.get(CE);
          if (!n3.getSelectedTableCells())
            return;
          if ("cut" == t4.name && !this.editor.model.canEditAt(this.editor.model.document.selection))
            return;
          e4.preventDefault(), t4.stop();
          const o3 = this.editor.data, i3 = this.editor.editing.view.document, r3 = o3.toView(n3.getSelectionAsFragment());
          i3.fire("clipboardOutput", { dataTransfer: e4.dataTransfer, content: r3, method: t4.name });
        }
        _onInsertContent(t4, e4, n3) {
          if (n3 && !n3.is("documentSelection"))
            return;
          const o3 = this.editor.model, i3 = this.editor.plugins.get(Ux);
          let r3 = this.getTableIfOnlyTableInContent(e4, o3);
          if (!r3)
            return;
          const s3 = i3.getSelectionAffectedTableCells(o3.document.selection);
          s3.length ? (t4.stop(), o3.change((t5) => {
            const e5 = { width: i3.getColumns(r3), height: i3.getRows(r3) }, n4 = function(t6, e6, n5, o5) {
              const i4 = t6[0].findAncestor("table"), r4 = o5.getColumnIndexes(t6), s4 = o5.getRowIndexes(t6), a4 = { firstColumn: r4.first, lastColumn: r4.last, firstRow: s4.first, lastRow: s4.last }, c4 = 1 === t6.length;
              c4 && (a4.lastRow += e6.height - 1, a4.lastColumn += e6.width - 1, function(t7, e7, n6, o6) {
                const i5 = o6.getColumns(t7), r5 = o6.getRows(t7);
                n6 > i5 && o6.insertColumns(t7, { at: i5, columns: n6 - i5 });
                e7 > r5 && o6.insertRows(t7, { at: r5, rows: e7 - r5 });
              }(i4, a4.lastRow + 1, a4.lastColumn + 1, o5));
              c4 || !o5.isSelectionRectangular(t6) ? function(t7, e7, n6) {
                const { firstRow: o6, lastRow: i5, firstColumn: r5, lastColumn: s5 } = e7, a5 = { first: o6, last: i5 }, c5 = { first: r5, last: s5 };
                yE(t7, r5, a5, n6), yE(t7, s5 + 1, a5, n6), vE(t7, o6, c5, n6), vE(t7, i5 + 1, c5, n6, o6);
              }(i4, a4, n5) : (a4.lastRow = Nx(i4, a4), a4.lastColumn = Px(i4, a4));
              return a4;
            }(s3, e5, t5, i3), o4 = n4.lastRow - n4.firstRow + 1, a3 = n4.lastColumn - n4.firstColumn + 1, c3 = { startRow: 0, startColumn: 0, endRow: Math.min(o4, e5.height) - 1, endColumn: Math.min(a3, e5.width) - 1 };
            r3 = yx(r3, c3, t5);
            const l3 = s3[0].findAncestor("table"), d3 = this._replaceSelectedCellsWithPasted(r3, e5, l3, n4, t5);
            if (this.editor.plugins.get("TableSelection").isEnabled) {
              const e6 = i3.sortRanges(d3.map((e7) => t5.createRangeOn(e7)));
              t5.setSelection(e6);
            } else
              t5.setSelection(d3[0], 0);
          })) : Bx(r3, i3);
        }
        _replaceSelectedCellsWithPasted(t4, e4, n3, o3, i3) {
          const { width: r3, height: s3 } = e4, a3 = function(t5, e5, n4) {
            const o4 = new Array(n4).fill(null).map(() => new Array(e5).fill(null));
            for (const { column: e6, row: n5, cell: i4 } of new px(t5))
              o4[n5][e6] = i4;
            return o4;
          }(t4, r3, s3), c3 = [...new px(n3, { startRow: o3.firstRow, endRow: o3.lastRow, startColumn: o3.firstColumn, endColumn: o3.lastColumn, includeAllSlots: true })], l3 = [];
          let d3;
          for (const t5 of c3) {
            const { row: e5, column: n4 } = t5;
            n4 === o3.firstColumn && (d3 = t5.getPositionBefore());
            const c4 = e5 - o3.firstRow, h4 = n4 - o3.firstColumn, u4 = a3[c4 % s3][h4 % r3], g4 = u4 ? i3.cloneElement(u4) : null, p4 = this._replaceTableSlotCell(t5, g4, d3, i3);
            p4 && (Ix(p4, e5, n4, o3.lastRow, o3.lastColumn, i3), l3.push(p4), d3 = i3.createPositionAfter(p4));
          }
          const h3 = parseInt(n3.getAttribute("headingRows") || "0"), u3 = parseInt(n3.getAttribute("headingColumns") || "0"), g3 = o3.firstRow < h3 && h3 <= o3.lastRow, p3 = o3.firstColumn < u3 && u3 <= o3.lastColumn;
          if (g3) {
            const t5 = vE(n3, h3, { first: o3.firstColumn, last: o3.lastColumn }, i3, o3.firstRow);
            l3.push(...t5);
          }
          if (p3) {
            const t5 = yE(n3, u3, { first: o3.firstRow, last: o3.lastRow }, i3);
            l3.push(...t5);
          }
          return l3;
        }
        _replaceTableSlotCell(t4, e4, n3, o3) {
          const { cell: i3, isAnchor: r3 } = t4;
          return r3 && o3.remove(i3), e4 ? (o3.insert(e4, n3), e4) : null;
        }
        getTableIfOnlyTableInContent(t4, e4) {
          if (!t4.is("documentFragment") && !t4.is("element"))
            return null;
          if (t4.is("element", "table"))
            return t4;
          if (1 == t4.childCount && t4.getChild(0).is("element", "table"))
            return t4.getChild(0);
          const n3 = e4.createRangeIn(t4);
          for (const t5 of n3.getItems())
            if (t5.is("element", "table")) {
              const o3 = e4.createRange(n3.start, e4.createPositionBefore(t5));
              if (e4.hasContent(o3, { ignoreWhitespaces: true }))
                return null;
              const i3 = e4.createRange(e4.createPositionAfter(t5), n3.end);
              return e4.hasContent(i3, { ignoreWhitespaces: true }) ? null : t5;
            }
          return null;
        }
      }
      function vE(t4, e4, n3, o3, i3 = 0) {
        if (e4 < 1)
          return;
        return xx(t4, e4, i3).filter(({ column: t5, cellWidth: e5 }) => xE(t5, e5, n3)).map(({ cell: t5 }) => Ex(t5, e4, o3));
      }
      function yE(t4, e4, n3, o3) {
        if (e4 < 1)
          return;
        return Dx(t4, e4).filter(({ row: t5, cellHeight: e5 }) => xE(t5, e5, n3)).map(({ cell: t5, column: n4 }) => Sx(t5, n4, e4, o3));
      }
      function xE(t4, e4, n3) {
        const o3 = t4 + e4 - 1, { first: i3, last: r3 } = n3;
        return t4 >= i3 && t4 <= r3 || t4 < i3 && o3 >= i3;
      }
      class EE extends $r {
        static get pluginName() {
          return "TableKeyboard";
        }
        static get requires() {
          return [CE, Ux];
        }
        init() {
          const t4 = this.editor.editing.view.document;
          this.listenTo(t4, "arrowKey", (...t5) => this._onArrowKey(...t5), { context: "table" }), this.listenTo(t4, "tab", (...t5) => this._handleTabOnSelectedTable(...t5), { context: "figure" }), this.listenTo(t4, "tab", (...t5) => this._handleTab(...t5), { context: ["th", "td"] });
        }
        _handleTabOnSelectedTable(t4, e4) {
          const n3 = this.editor, o3 = n3.model.document.selection.getSelectedElement();
          o3 && o3.is("element", "table") && (e4.preventDefault(), e4.stopPropagation(), t4.stop(), n3.model.change((t5) => {
            t5.setSelection(t5.createRangeIn(o3.getChild(0).getChild(0)));
          }));
        }
        _handleTab(t4, e4) {
          const n3 = this.editor, o3 = this.editor.plugins.get(Ux), i3 = this.editor.plugins.get("TableSelection"), r3 = n3.model.document.selection, s3 = !e4.shiftKey;
          let a3 = o3.getTableCellsContainingSelection(r3)[0];
          if (a3 || (a3 = i3.getFocusCell()), !a3)
            return;
          e4.preventDefault(), e4.stopPropagation(), t4.stop();
          const c3 = a3.parent, l3 = c3.parent, d3 = l3.getChildIndex(c3), h3 = c3.getChildIndex(a3), u3 = 0 === h3;
          if (!s3 && u3 && 0 === d3)
            return void n3.model.change((t5) => {
              t5.setSelection(t5.createRangeOn(l3));
            });
          const g3 = h3 === c3.childCount - 1, p3 = d3 === o3.getRows(l3) - 1;
          if (s3 && p3 && g3 && (n3.execute("insertTableRowBelow"), d3 === o3.getRows(l3) - 1))
            return void n3.model.change((t5) => {
              t5.setSelection(t5.createRangeOn(l3));
            });
          let m3;
          if (s3 && g3) {
            const t5 = l3.getChild(d3 + 1);
            m3 = t5.getChild(0);
          } else if (!s3 && u3) {
            const t5 = l3.getChild(d3 - 1);
            m3 = t5.getChild(t5.childCount - 1);
          } else
            m3 = c3.getChild(h3 + (s3 ? 1 : -1));
          n3.model.change((t5) => {
            t5.setSelection(t5.createRangeIn(m3));
          });
        }
        _onArrowKey(t4, e4) {
          const n3 = this.editor, o3 = Ci2(e4.keyCode, n3.locale.contentLanguageDirection);
          this._handleArrowKeys(o3, e4.shiftKey) && (e4.preventDefault(), e4.stopPropagation(), t4.stop());
        }
        _handleArrowKeys(t4, e4) {
          const n3 = this.editor.plugins.get(Ux), o3 = this.editor.plugins.get("TableSelection"), i3 = this.editor.model, r3 = i3.document.selection, s3 = ["right", "down"].includes(t4), a3 = n3.getSelectedTableCells(r3);
          if (a3.length) {
            let n4;
            return n4 = e4 ? o3.getFocusCell() : s3 ? a3[a3.length - 1] : a3[0], this._navigateFromCellInDirection(n4, t4, e4), true;
          }
          const c3 = r3.focus.findAncestor("tableCell");
          if (!c3)
            return false;
          if (!r3.isCollapsed)
            if (e4) {
              if (r3.isBackward == s3 && !r3.containsEntireContent(c3))
                return false;
            } else {
              const t5 = r3.getSelectedElement();
              if (!t5 || !i3.schema.isObject(t5))
                return false;
            }
          return !!this._isSelectionAtCellEdge(r3, c3, s3) && (this._navigateFromCellInDirection(c3, t4, e4), true);
        }
        _isSelectionAtCellEdge(t4, e4, n3) {
          const o3 = this.editor.model, i3 = this.editor.model.schema, r3 = n3 ? t4.getLastPosition() : t4.getFirstPosition();
          if (!i3.getLimitElement(r3).is("element", "tableCell")) {
            return o3.createPositionAt(e4, n3 ? "end" : 0).isTouching(r3);
          }
          const s3 = o3.createSelection(r3);
          return o3.modifySelection(s3, { direction: n3 ? "forward" : "backward" }), r3.isEqual(s3.focus);
        }
        _navigateFromCellInDirection(t4, e4, n3 = false) {
          const o3 = this.editor.model, i3 = t4.findAncestor("table"), r3 = [...new px(i3, { includeAllSlots: true })], { row: s3, column: a3 } = r3[r3.length - 1], c3 = r3.find(({ cell: e5 }) => e5 == t4);
          let { row: l3, column: d3 } = c3;
          switch (e4) {
            case "left":
              d3--;
              break;
            case "up":
              l3--;
              break;
            case "right":
              d3 += c3.cellWidth;
              break;
            case "down":
              l3 += c3.cellHeight;
          }
          if (l3 < 0 || l3 > s3 || d3 < 0 && l3 <= 0 || d3 > a3 && l3 >= s3)
            return void o3.change((t5) => {
              t5.setSelection(t5.createRangeOn(i3));
            });
          d3 < 0 ? (d3 = n3 ? 0 : a3, l3--) : d3 > a3 && (d3 = n3 ? a3 : 0, l3++);
          const h3 = r3.find((t5) => t5.row == l3 && t5.column == d3).cell, u3 = ["right", "down"].includes(e4), g3 = this.editor.plugins.get("TableSelection");
          if (n3 && g3.isEnabled) {
            const e5 = g3.getAnchorCell() || t4;
            g3.setCellSelection(e5, h3);
          } else {
            const t5 = o3.createPositionAt(h3, u3 ? 0 : "end");
            o3.change((e5) => {
              e5.setSelection(t5);
            });
          }
        }
      }
      class DE extends Lc2 {
        constructor() {
          super(...arguments), this.domEventType = ["mousemove", "mouseleave"];
        }
        onDomEvent(t4) {
          this.fire(t4.type, t4);
        }
      }
      class SE extends $r {
        static get pluginName() {
          return "TableMouse";
        }
        static get requires() {
          return [CE, Ux];
        }
        init() {
          this.editor.editing.view.addObserver(DE), this._enableShiftClickSelection(), this._enableMouseDragSelection();
        }
        _enableShiftClickSelection() {
          const t4 = this.editor, e4 = t4.plugins.get(Ux);
          let n3 = false;
          const o3 = t4.plugins.get(CE);
          this.listenTo(t4.editing.view.document, "mousedown", (i3, r3) => {
            const s3 = t4.model.document.selection;
            if (!this.isEnabled || !o3.isEnabled)
              return;
            if (!r3.domEvent.shiftKey)
              return;
            const a3 = o3.getAnchorCell() || e4.getTableCellsContainingSelection(s3)[0];
            if (!a3)
              return;
            const c3 = this._getModelTableCellFromDomEvent(r3);
            c3 && IE(a3, c3) && (n3 = true, o3.setCellSelection(a3, c3), r3.preventDefault());
          }), this.listenTo(t4.editing.view.document, "mouseup", () => {
            n3 = false;
          }), this.listenTo(t4.editing.view.document, "selectionChange", (t5) => {
            n3 && t5.stop();
          }, { priority: "highest" });
        }
        _enableMouseDragSelection() {
          const t4 = this.editor;
          let e4, n3, o3 = false, i3 = false;
          const r3 = t4.plugins.get(CE);
          this.listenTo(t4.editing.view.document, "mousedown", (t5, n4) => {
            this.isEnabled && r3.isEnabled && (n4.domEvent.shiftKey || n4.domEvent.ctrlKey || n4.domEvent.altKey || (e4 = this._getModelTableCellFromDomEvent(n4)));
          }), this.listenTo(t4.editing.view.document, "mousemove", (t5, s3) => {
            if (!s3.domEvent.buttons)
              return;
            if (!e4)
              return;
            const a3 = this._getModelTableCellFromDomEvent(s3);
            a3 && IE(e4, a3) && (n3 = a3, o3 || n3 == e4 || (o3 = true)), o3 && (i3 = true, r3.setCellSelection(e4, n3), s3.preventDefault());
          }), this.listenTo(t4.editing.view.document, "mouseup", () => {
            o3 = false, i3 = false, e4 = null, n3 = null;
          }), this.listenTo(t4.editing.view.document, "selectionChange", (t5) => {
            i3 && t5.stop();
          }, { priority: "highest" });
        }
        _getModelTableCellFromDomEvent(t4) {
          const e4 = t4.target, n3 = this.editor.editing.view.createPositionAt(e4, 0);
          return this.editor.editing.mapper.toModelPosition(n3).parent.findAncestor("tableCell", { includeSelf: true });
        }
      }
      function IE(t4, e4) {
        return t4.parent.parent == e4.parent.parent;
      }
      var TE = n2(6306), ME = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(TE.Z, ME);
      TE.Z.locals;
      function BE(t4) {
        const e4 = t4.getSelectedElement();
        return e4 && PE(e4) ? e4 : null;
      }
      function NE(t4) {
        const e4 = t4.getFirstPosition();
        if (!e4)
          return null;
        let n3 = e4.parent;
        for (; n3; ) {
          if (n3.is("element") && PE(n3))
            return n3;
          n3 = n3.parent;
        }
        return null;
      }
      function PE(t4) {
        return !!t4.getCustomProperty("table") && Gk2(t4);
      }
      var zE = n2(7368), OE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(zE.Z, OE);
      zE.Z.locals;
      var LE = n2(9247), jE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(LE.Z, jE);
      LE.Z.locals;
      var RE = n2(4070), FE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(RE.Z, FE);
      RE.Z.locals;
      var VE = n2(6237), HE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(VE.Z, HE);
      VE.Z.locals;
      var UE = n2(5087), qE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(UE.Z, qE);
      UE.Z.locals;
      const GE = em.defaultPositions;
      GE.northArrowSouth, GE.northArrowSouthWest, GE.northArrowSouthEast, GE.southArrowNorth, GE.southArrowNorthWest, GE.southArrowNorthEast, GE.viewportStickyNorth;
      var WE = n2(7341), KE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(WE.Z, KE);
      WE.Z.locals;
      var YE = n2(2128), $E = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(YE.Z, $E);
      YE.Z.locals;
      var ZE = n2(4101), QE = { injectType: "singletonStyleTag", attributes: { "data-cke": true }, insert: "head", singleton: true };
      Ri2()(ZE.Z, QE);
      ZE.Z.locals;
      var JE = Object.defineProperty, XE = Object.getOwnPropertySymbols, tD = Object.prototype.hasOwnProperty, eD = Object.prototype.propertyIsEnumerable, nD = (t4, e4, n3) => e4 in t4 ? JE(t4, e4, { enumerable: true, configurable: true, writable: true, value: n3 }) : t4[e4] = n3, oD = (t4, e4) => {
        for (var n3 in e4 || (e4 = {}))
          tD.call(e4, n3) && nD(t4, n3, e4[n3]);
        if (XE)
          for (var n3 of XE(e4))
            eD.call(e4, n3) && nD(t4, n3, e4[n3]);
        return t4;
      };
      const iD = { autoRefresh: true }, rD = 36e5;
      class sD extends W2() {
        constructor(t4, e4 = {}) {
          if (super(), !t4)
            throw new A2("token-missing-token-url", this);
          e4.initValue && this._validateTokenValue(e4.initValue), this.set("value", e4.initValue), this._refresh = "function" == typeof t4 ? t4 : () => {
            return e5 = t4, new Promise((t5, n3) => {
              const o3 = new XMLHttpRequest();
              o3.open("GET", e5), o3.addEventListener("load", () => {
                const e6 = o3.status, i3 = o3.response;
                return e6 < 200 || e6 > 299 ? n3(new A2("token-cannot-download-new-token", null)) : t5(i3);
              }), o3.addEventListener("error", () => n3(new Error("Network Error"))), o3.addEventListener("abort", () => n3(new Error("Abort"))), o3.send();
            });
            var e5;
          }, this._options = oD(oD({}, iD), e4);
        }
        init() {
          return new Promise((t4, e4) => {
            this.value ? (this._options.autoRefresh && this._registerRefreshTokenTimeout(), t4(this)) : this.refreshToken().then(t4).catch(e4);
          });
        }
        refreshToken() {
          return this._refresh().then((t4) => (this._validateTokenValue(t4), this.set("value", t4), this._options.autoRefresh && this._registerRefreshTokenTimeout(), this));
        }
        destroy() {
          clearTimeout(this._tokenRefreshTimeout);
        }
        _validateTokenValue(t4) {
          const e4 = "string" == typeof t4, n3 = !/^".*"$/.test(t4), o3 = e4 && 3 === t4.split(".").length;
          if (!n3 || !o3)
            throw new A2("token-not-in-jwt-format", this);
        }
        _registerRefreshTokenTimeout() {
          const t4 = this._getTokenRefreshTimeoutTime();
          clearTimeout(this._tokenRefreshTimeout), this._tokenRefreshTimeout = setTimeout(() => {
            this.refreshToken();
          }, t4);
        }
        _getTokenRefreshTimeoutTime() {
          try {
            const [, t4] = this.value.split("."), { exp: e4 } = JSON.parse(atob(t4));
            if (!e4)
              return rD;
            return Math.floor((1e3 * e4 - Date.now()) / 2);
          } catch (t4) {
            return rD;
          }
        }
        static create(t4, e4 = {}) {
          return new sD(t4, e4).init();
        }
      }
      const aD = /^data:(\S*?);base64,/;
      class cD extends M2() {
        constructor(t4, e4, n3) {
          if (super(), !t4)
            throw new A2("fileuploader-missing-file", null);
          if (!e4)
            throw new A2("fileuploader-missing-token", null);
          if (!n3)
            throw new A2("fileuploader-missing-api-address", null);
          this.file = function(t5) {
            if ("string" != typeof t5)
              return false;
            const e5 = t5.match(aD);
            return !(!e5 || !e5.length);
          }(t4) ? function(t5, e5 = 512) {
            try {
              const n4 = t5.match(aD)[1], o3 = atob(t5.replace(aD, "")), i3 = [];
              for (let t6 = 0; t6 < o3.length; t6 += e5) {
                const n5 = o3.slice(t6, t6 + e5), r3 = new Array(n5.length);
                for (let t7 = 0; t7 < n5.length; t7++)
                  r3[t7] = n5.charCodeAt(t7);
                i3.push(new Uint8Array(r3));
              }
              return new Blob(i3, { type: n4 });
            } catch (t6) {
              throw new A2("fileuploader-decoding-image-data-error", null);
            }
          }(t4) : t4, this._token = e4, this._apiAddress = n3;
        }
        onProgress(t4) {
          return this.on("progress", (e4, n3) => t4(n3)), this;
        }
        onError(t4) {
          return this.once("error", (e4, n3) => t4(n3)), this;
        }
        abort() {
          this.xhr.abort();
        }
        send() {
          return this._prepareRequest(), this._attachXHRListeners(), this._sendRequest();
        }
        _prepareRequest() {
          const t4 = new XMLHttpRequest();
          t4.open("POST", this._apiAddress), t4.setRequestHeader("Authorization", this._token.value), t4.responseType = "json", this.xhr = t4;
        }
        _attachXHRListeners() {
          const t4 = this.xhr, e4 = (t5) => () => this.fire("error", t5);
          t4.addEventListener("error", e4("Network Error")), t4.addEventListener("abort", e4("Abort")), t4.upload && t4.upload.addEventListener("progress", (t5) => {
            t5.lengthComputable && this.fire("progress", { total: t5.total, uploaded: t5.loaded });
          }), t4.addEventListener("load", () => {
            const e5 = t4.status, n3 = t4.response;
            if (e5 < 200 || e5 > 299)
              return this.fire("error", n3.message || n3.error);
          });
        }
        _sendRequest() {
          const t4 = new FormData(), e4 = this.xhr;
          return t4.append("file", this.file), new Promise((n3, o3) => {
            e4.addEventListener("load", () => {
              const t5 = e4.status, i3 = e4.response;
              return t5 < 200 || t5 > 299 ? i3.message ? o3(new A2("fileuploader-uploading-data-failed", this, { message: i3.message })) : o3(i3.error) : n3(i3);
            }), e4.addEventListener("error", () => o3(new Error("Network Error"))), e4.addEventListener("abort", () => o3(new Error("Abort"))), e4.send(t4);
          });
        }
      }
      class lD {
        constructor(t4, e4) {
          if (!t4)
            throw new A2("uploadgateway-missing-token", null);
          if (!e4)
            throw new A2("uploadgateway-missing-api-address", null);
          this._token = t4, this._apiAddress = e4;
        }
        upload(t4) {
          return new cD(t4, this._token, this._apiAddress);
        }
      }
      class dD extends ns {
        static get pluginName() {
          return "CloudServicesCore";
        }
        createToken(t4, e4) {
          return new sD(t4, e4);
        }
        createUploadGateway(t4, e4) {
          return new lD(t4, e4);
        }
      }
      var hD = (t4, e4, n3) => new Promise((o3, i3) => {
        var r3 = (t5) => {
          try {
            a3(n3.next(t5));
          } catch (t6) {
            i3(t6);
          }
        }, s3 = (t5) => {
          try {
            a3(n3.throw(t5));
          } catch (t6) {
            i3(t6);
          }
        }, a3 = (t5) => t5.done ? o3(t5.value) : Promise.resolve(t5.value).then(r3, s3);
        a3((n3 = n3.apply(t4, e4)).next());
      });
      class uD extends Gf2 {
      }
      uD.builtinPlugins = [class extends $r {
        static get requires() {
          return [Ub2, Nk2, $b2, Lk2, hk2, dw];
        }
        static get pluginName() {
          return "Essentials";
        }
      }, class extends $r {
        static get requires() {
          return [uw];
        }
        static get pluginName() {
          return "CKFinderUploadAdapter";
        }
        init() {
          const t4 = this.editor.config.get("ckfinder.uploadUrl");
          t4 && (this.editor.plugins.get(uw).createUploadAdapter = (e4) => new ww(e4, t4, this.editor.t));
        }
      }, class extends $r {
        static get requires() {
          return [dk2];
        }
        static get pluginName() {
          return "Autoformat";
        }
        afterInit() {
          this._addListAutoformats(), this._addBasicStylesAutoformats(), this._addHeadingAutoformats(), this._addBlockQuoteAutoformats(), this._addCodeBlockAutoformats(), this._addHorizontalLineAutoformats();
        }
        _addListAutoformats() {
          const t4 = this.editor.commands;
          t4.get("bulletedList") && Aw(this.editor, this, /^[*-]\s$/, "bulletedList"), t4.get("numberedList") && Aw(this.editor, this, /^1[.|)]\s$/, "numberedList"), t4.get("todoList") && Aw(this.editor, this, /^\[\s?\]\s$/, "todoList"), t4.get("checkTodoList") && Aw(this.editor, this, /^\[\s?x\s?\]\s$/, () => {
            this.editor.execute("todoList"), this.editor.execute("checkTodoList");
          });
        }
        _addBasicStylesAutoformats() {
          const t4 = this.editor.commands;
          if (t4.get("bold")) {
            const t5 = vw(this.editor, "bold");
            Cw(this.editor, this, /(?:^|\s)(\*\*)([^*]+)(\*\*)$/g, t5), Cw(this.editor, this, /(?:^|\s)(__)([^_]+)(__)$/g, t5);
          }
          if (t4.get("italic")) {
            const t5 = vw(this.editor, "italic");
            Cw(this.editor, this, /(?:^|\s)(\*)([^*_]+)(\*)$/g, t5), Cw(this.editor, this, /(?:^|\s)(_)([^_]+)(_)$/g, t5);
          }
          if (t4.get("code")) {
            const t5 = vw(this.editor, "code");
            Cw(this.editor, this, /(`)([^`]+)(`)$/g, t5);
          }
          if (t4.get("strikethrough")) {
            const t5 = vw(this.editor, "strikethrough");
            Cw(this.editor, this, /(~~)([^~]+)(~~)$/g, t5);
          }
        }
        _addHeadingAutoformats() {
          const t4 = this.editor.commands.get("heading");
          t4 && t4.modelElements.filter((t5) => t5.match(/^heading[1-6]$/)).forEach((e4) => {
            const n3 = e4[7], o3 = new RegExp(`^(#{${n3}})\\s$`);
            Aw(this.editor, this, o3, () => {
              if (!t4.isEnabled || t4.value === e4)
                return false;
              this.editor.execute("heading", { value: e4 });
            });
          });
        }
        _addBlockQuoteAutoformats() {
          this.editor.commands.get("blockQuote") && Aw(this.editor, this, /^>\s$/, "blockQuote");
        }
        _addCodeBlockAutoformats() {
          const t4 = this.editor, e4 = t4.model.document.selection;
          t4.commands.get("codeBlock") && Aw(t4, this, /^```$/, () => {
            if (e4.getFirstPosition().parent.is("element", "listItem"))
              return false;
            this.editor.execute("codeBlock", { usePreviousLanguageChoice: true });
          });
        }
        _addHorizontalLineAutoformats() {
          this.editor.commands.get("horizontalLine") && Aw(this.editor, this, /^---$/, "horizontalLine");
        }
      }, class extends $r {
        static get requires() {
          return [Ew, Sw];
        }
        static get pluginName() {
          return "Bold";
        }
      }, class extends $r {
        static get requires() {
          return [Bw, Pw];
        }
        static get pluginName() {
          return "Italic";
        }
      }, class extends $r {
        static get requires() {
          return [Rw, Hw];
        }
        static get pluginName() {
          return "BlockQuote";
        }
      }, class extends $r {
        static get pluginName() {
          return "CKBox";
        }
        static get requires() {
          return [Jw, Uw];
        }
      }, class extends $r {
        static get pluginName() {
          return "CKFinder";
        }
        static get requires() {
          return ["Link", "CKFinderUploadAdapter", rA, nA];
        }
      }, class extends ns {
        constructor() {
          super(...arguments), this.token = null, this._tokens = /* @__PURE__ */ new Map();
        }
        static get pluginName() {
          return "CloudServices";
        }
        static get requires() {
          return [dD];
        }
        init() {
          return hD(this, null, function* () {
            const t4 = this.context.config.get("cloudServices") || {};
            for (const [e5, n3] of Object.entries(t4))
              this[e5] = n3;
            if (!this.tokenUrl)
              return void (this.token = null);
            const e4 = this.context.plugins.get("CloudServicesCore");
            this.token = yield e4.createToken(this.tokenUrl).init(), this._tokens.set(this.tokenUrl, this.token);
          });
        }
        registerTokenUrl(t4) {
          return hD(this, null, function* () {
            if (this._tokens.has(t4))
              return this.getTokenFor(t4);
            const e4 = this.context.plugins.get("CloudServicesCore"), n3 = yield e4.createToken(t4).init();
            return this._tokens.set(t4, n3), n3;
          });
        }
        getTokenFor(t4) {
          const e4 = this._tokens.get(t4);
          if (!e4)
            throw new A2("cloudservices-token-not-registered", this);
          return e4;
        }
        destroy() {
          super.destroy();
          for (const t4 of this._tokens.values())
            t4.destroy();
        }
      }, class extends $r {
        static get pluginName() {
          return "EasyImage";
        }
        static get requires() {
          return [sA, "ImageUpload"];
        }
        init() {
          const t4 = this.editor;
          t4.plugins.has("ImageBlockEditing") || t4.plugins.has("ImageInlineEditing") || C2("easy-image-image-feature-missing", t4);
        }
      }, class extends $r {
        static get requires() {
          return [fA, wA];
        }
        static get pluginName() {
          return "Heading";
        }
      }, class extends $r {
        static get requires() {
          return [aC, lC];
        }
        static get pluginName() {
          return "Image";
        }
      }, class extends $r {
        static get requires() {
          return [uC, gC];
        }
        static get pluginName() {
          return "ImageCaption";
        }
      }, class extends $r {
        static get requires() {
          return [p_, k_];
        }
        static get pluginName() {
          return "ImageStyle";
        }
      }, class extends $r {
        static get requires() {
          return [mb2, BA];
        }
        static get pluginName() {
          return "ImageToolbar";
        }
        afterInit() {
          const t4 = this.editor, e4 = t4.t, n3 = t4.plugins.get(mb2), o3 = t4.plugins.get("ImageUtils");
          var i3;
          n3.register("image", { ariaLabel: e4("Image toolbar"), items: (i3 = t4.config.get("image.toolbar") || [], i3.map((t5) => R2(t5) ? t5.name : t5)), getRelatedElement: (t5) => o3.getClosestSelectedImageWidget(t5) });
        }
      }, class extends $r {
        static get pluginName() {
          return "ImageUpload";
        }
        static get requires() {
          return [FC, wC, EC];
        }
      }, class extends $r {
        static get pluginName() {
          return "Indent";
        }
        static get requires() {
          return [C_, y_];
        }
      }, class extends $r {
        static get requires() {
          return [fv, Dv, Tv];
        }
        static get pluginName() {
          return "Link";
        }
      }, class extends $r {
        static get requires() {
          return [vy, Yv];
        }
        static get pluginName() {
          return "List";
        }
      }, class extends $r {
        static get requires() {
          return [Oy, Hy, jy, gb2];
        }
        static get pluginName() {
          return "MediaEmbed";
        }
      }, uA, class extends $r {
        static get pluginName() {
          return "PasteFromOffice";
        }
        static get requires() {
          return [Zf2];
        }
        init() {
          const t4 = this.editor, e4 = t4.plugins.get("ClipboardPipeline"), n3 = t4.editing.view.document, o3 = [];
          o3.push(new Xy(n3)), o3.push(new ox(n3)), o3.push(new rx(n3)), e4.on("inputTransformation", (e5, i3) => {
            if (i3._isTransformedWithPasteFromOffice)
              return;
            if (t4.model.document.selection.getFirstPosition().parent.is("element", "codeBlock"))
              return;
            const r3 = i3.dataTransfer.getData("text/html"), s3 = o3.find((t5) => t5.isActive(r3));
            s3 && (i3._parsedData || (i3._parsedData = ax(r3, n3.stylesProcessor)), s3.execute(i3), i3._isTransformedWithPasteFromOffice = true);
          }, { priority: "high" });
        }
      }, class extends $r {
        static get requires() {
          return [eC, BA];
        }
        static get pluginName() {
          return "PictureEditing";
        }
        afterInit() {
          const t4 = this.editor;
          t4.plugins.has("ImageBlockEditing") && t4.model.schema.extend("imageBlock", { allowAttributes: ["sources"] }), t4.plugins.has("ImageInlineEditing") && t4.model.schema.extend("imageInline", { allowAttributes: ["sources"] }), this._setupConversion(), this._setupImageUploadEditingIntegration();
        }
        _setupConversion() {
          const t4 = this.editor, e4 = t4.conversion, n3 = t4.plugins.get("ImageUtils");
          e4.for("upcast").add(function(t5) {
            const e5 = ["srcset", "media", "type", "sizes"], n4 = (n5, o3, i3) => {
              const r3 = o3.viewItem;
              if (!i3.consumable.test(r3, { name: true }))
                return;
              const s3 = /* @__PURE__ */ new Map();
              for (const t6 of r3.getChildren())
                if (t6.is("element", "source")) {
                  const n6 = {};
                  for (const o4 of e5)
                    t6.hasAttribute(o4) && i3.consumable.test(t6, { attributes: o4 }) && (n6[o4] = t6.getAttribute(o4));
                  Object.keys(n6).length && s3.set(t6, n6);
                }
              const a3 = t5.findViewImgElement(r3);
              if (!a3)
                return;
              let c3 = o3.modelCursor.parent;
              if (!c3.is("element", "imageBlock")) {
                const t6 = i3.convertItem(a3, o3.modelCursor);
                o3.modelRange = t6.modelRange, o3.modelCursor = t6.modelCursor, c3 = Si2(t6.modelRange.getItems());
              }
              i3.consumable.consume(r3, { name: true });
              for (const [t6, e6] of s3)
                i3.consumable.consume(t6, { attributes: Object.keys(e6) });
              s3.size && i3.writer.setAttribute("sources", Array.from(s3.values()), c3), i3.convertChildren(r3, c3);
            };
            return (t6) => {
              t6.on("element:picture", n4);
            };
          }(n3)), e4.for("downcast").add(function(t5) {
            const e5 = (e6, n4, o3) => {
              if (!o3.consumable.consume(n4.item, e6.name))
                return;
              const i3 = o3.writer, r3 = o3.mapper.toViewElement(n4.item), s3 = t5.findViewImgElement(r3), a3 = n4.attributeNewValue;
              if (a3 && a3.length) {
                const t6 = i3.createContainerElement("picture", null, a3.map((t7) => i3.createEmptyElement("source", t7))), e7 = [];
                let n5 = s3.parent;
                for (; n5 && n5.is("attributeElement"); ) {
                  const t7 = n5.parent;
                  i3.unwrap(i3.createRangeOn(s3), n5), e7.unshift(n5), n5 = t7;
                }
                i3.insert(i3.createPositionBefore(s3), t6), i3.move(i3.createRangeOn(s3), i3.createPositionAt(t6, "end"));
                for (const n6 of e7)
                  i3.wrap(i3.createRangeOn(t6), n6);
              } else if (s3.parent.is("element", "picture")) {
                const t6 = s3.parent;
                i3.move(i3.createRangeOn(s3), i3.createPositionBefore(t6)), i3.remove(t6);
              }
            };
            return (t6) => {
              t6.on("attribute:sources:imageBlock", e5), t6.on("attribute:sources:imageInline", e5);
            };
          }(n3));
        }
        _setupImageUploadEditingIntegration() {
          const t4 = this.editor;
          if (!t4.plugins.has("ImageUploadEditing"))
            return;
          const e4 = t4.plugins.get("ImageUploadEditing");
          this.listenTo(e4, "uploadComplete", (e5, { imageElement: n3, data: o3 }) => {
            const i3 = o3.sources;
            i3 && t4.model.change((t5) => {
              t5.setAttributes({ sources: i3 }, n3);
            });
          });
        }
      }, class extends $r {
        static get requires() {
          return [uE, kE, CE, SE, EE, _E, gb2];
        }
        static get pluginName() {
          return "Table";
        }
      }, class extends $r {
        static get requires() {
          return [mb2];
        }
        static get pluginName() {
          return "TableToolbar";
        }
        afterInit() {
          const t4 = this.editor, e4 = t4.t, n3 = t4.plugins.get(mb2), o3 = t4.config.get("table.contentToolbar"), i3 = t4.config.get("table.tableToolbar");
          o3 && n3.register("tableContent", { ariaLabel: e4("Table toolbar"), items: o3, getRelatedElement: NE }), i3 && n3.register("table", { ariaLabel: e4("Table toolbar"), items: i3, getRelatedElement: BE });
        }
      }, class extends $r {
        static get requires() {
          return ["Delete", "Input"];
        }
        static get pluginName() {
          return "TextTransformation";
        }
        constructor(t4) {
          super(t4), t4.config.define("typing", { transformations: { include: Ck2 } });
        }
        init() {
          const t4 = this.editor.model.document.selection;
          t4.on("change:range", () => {
            this.isEnabled = !t4.anchor.parent.is("element", "codeBlock");
          }), this._enableTransformationWatchers();
        }
        _enableTransformationWatchers() {
          const t4 = this.editor, e4 = t4.model, n3 = t4.plugins.get("Delete"), o3 = function(t5) {
            const e5 = t5.extra || [], n4 = t5.remove || [], o4 = (t6) => !n4.includes(t6);
            return function(t6) {
              const e6 = /* @__PURE__ */ new Set();
              for (const n5 of t6)
                if ("string" == typeof n5 && Ak2[n5])
                  for (const t7 of Ak2[n5])
                    e6.add(t7);
                else
                  e6.add(n5);
              return Array.from(e6);
            }(t5.include.concat(e5).filter(o4)).filter(o4).map((t6) => "string" == typeof t6 && wk2[t6] ? wk2[t6] : t6).filter((t6) => "object" == typeof t6).map((t6) => ({ from: _k(t6.from), to: vk2(t6.to) }));
          }(t4.config.get("typing.transformations")), i3 = new gk2(t4.model, (t5) => {
            for (const e5 of o3) {
              if (e5.from.test(t5))
                return { normalizedTransformation: e5 };
            }
          });
          i3.on("matched:data", (t5, o4) => {
            if (!o4.batch.isTyping)
              return;
            const { from: i4, to: r3 } = o4.normalizedTransformation, s3 = i4.exec(o4.text), a3 = r3(s3.slice(1)), c3 = o4.range;
            let l3 = s3.index;
            e4.enqueueChange((t6) => {
              for (let n4 = 1; n4 < s3.length; n4++) {
                const o5 = s3[n4], i5 = a3[n4 - 1];
                if (null == i5) {
                  l3 += o5.length;
                  continue;
                }
                const r4 = c3.start.getShiftedBy(l3), d3 = e4.createRange(r4, r4.getShiftedBy(o5.length)), h3 = yk2(r4);
                e4.insertContent(t6.createText(i5, h3), d3), l3 += i5.length;
              }
              e4.enqueueChange(() => {
                n3.requestUndoOnBackspace();
              });
            });
          }), i3.bind("isEnabled").to(this);
        }
      }], uD.defaultConfig = { toolbar: { items: ["undo", "redo", "|", "heading", "|", "bold", "italic", "|", "link", "uploadImage", "insertTable", "blockQuote", "mediaEmbed", "|", "bulletedList", "numberedList", "outdent", "indent"] }, image: { toolbar: ["imageStyle:inline", "imageStyle:block", "imageStyle:side", "|", "toggleImageCaption", "imageTextAlternative"] }, table: { contentToolbar: ["tableColumn", "tableRow", "mergeTableCells"] }, language: "en" };
    })(), o2 = o2.default;
  })());
})(ckeditor, ckeditor.exports);
var ckeditorExports = ckeditor.exports;
const ClassicEditor = /* @__PURE__ */ getDefaultExportFromCjs(ckeditorExports);
function bind(fn2, thisArg) {
  return function wrap() {
    return fn2.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache2) => (thing) => {
  const str = toString.call(thing);
  return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      a2[key] = bind(val, thisArg);
    } else {
      a2[key] = val;
    }
  }, { allOwnKeys });
  return a2;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position2) => {
  str = String(str);
  if (position2 === void 0 || position2 > str.length) {
    position2 = str.length;
  }
  position2 -= searchString.length;
  const lastIndex = str.indexOf(searchString, position2);
  return lastIndex !== -1 && lastIndex === position2;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn2) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer2) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer2(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter2) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length: length2 } = alphabet;
  while (size--) {
    str += alphabet[Math.random() * length2 | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable
};
function AxiosError(message, code, config2, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config2 && (this.config = config2);
  request && (this.request = request);
  response && (this.response = response);
}
utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code, config2, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config2, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token2, i2) {
    token2 = removeBrackets(token2);
    return !dots && i2 ? "[" + token2 + "]" : token2;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
  if (!utils$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils$1.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index) {
          !(utils$1.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils$1.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils$1.forEach(value, function each(el2, key) {
      const result = !(utils$1.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils$1.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append2(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id2) {
    if (this.handlers[id2]) {
      this.handlers[id2] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn2) {
    utils$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const platform$1 = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const utils = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv
}, Symbol.toStringTag, { value: "Module" }));
const platform = {
  ...utils,
  ...platform$1
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name) {
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils$1.isObject(data);
    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils$1.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data)) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
    i2 = line2.indexOf(":");
    key = line2.substring(0, i2).trim().toLowerCase();
    val = line2.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils$1.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils$1.isString(value))
    return;
  if (utils$1.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils$1.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
    return char2.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils$1.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config2 = this || defaults$1;
  const context = response || config2;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils$1.forEach(fns, function transform(fn2) {
    data = fn2.call(config2, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config2, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config2, request);
  this.name = "CanceledError";
}
utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  function standardBrowserEnv() {
    return {
      write: function write(name, value, expires, path, domain, secure) {
        const cookie = [];
        cookie.push(name + "=" + encodeURIComponent(value));
        if (utils$1.isNumber(expires)) {
          cookie.push("expires=" + new Date(expires).toGMTString());
        }
        if (utils$1.isString(path)) {
          cookie.push("path=" + path);
        }
        if (utils$1.isString(domain)) {
          cookie.push("domain=" + domain);
        }
        if (secure === true) {
          cookie.push("secure");
        }
        document.cookie = cookie.join("; ");
      },
      read: function read(name) {
        const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
        return match2 ? decodeURIComponent(match2[3]) : null;
      },
      remove: function remove(name) {
        this.write(name, "", Date.now() - 864e5);
      }
    };
  }()
) : (
  // Non standard browser env (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv() {
    return {
      write: function write() {
      },
      read: function read() {
        return null;
      },
      remove: function remove() {
      }
    };
  }()
);
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv2() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  function nonStandardBrowserEnv2() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now2 = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now2;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now2;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now2 - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now2 - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    let requestData = config2.data;
    const requestHeaders = AxiosHeaders$1.from(config2.headers).normalize();
    const responseType = config2.responseType;
    let onCanceled;
    function done() {
      if (config2.cancelToken) {
        config2.cancelToken.unsubscribe(onCanceled);
      }
      if (config2.signal) {
        config2.signal.removeEventListener("abort", onCanceled);
      }
    }
    let contentType;
    if (utils$1.isFormData(requestData)) {
      if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
        requestHeaders.setContentType(false);
      } else if ((contentType = requestHeaders.getContentType()) !== false) {
        const [type, ...tokens] = contentType ? contentType.split(";").map((token2) => token2.trim()).filter(Boolean) : [];
        requestHeaders.setContentType([type || "multipart/form-data", ...tokens].join("; "));
      }
    }
    let request = new XMLHttpRequest();
    if (config2.auth) {
      const username = config2.auth.username || "";
      const password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    request.open(config2.method.toUpperCase(), buildURL(fullPath, config2.params, config2.paramsSerializer), true);
    request.timeout = config2.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config2,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config2, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config2, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config2.timeout ? "timeout of " + config2.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config2.transitional || transitionalDefaults;
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config2,
        request
      ));
      request = null;
    };
    if (platform.hasStandardBrowserEnv) {
      const xsrfValue = isURLSameOrigin(fullPath) && config2.xsrfCookieName && cookies.read(config2.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config2.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils$1.isUndefined(config2.withCredentials)) {
      request.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config2.onDownloadProgress, true));
    }
    if (typeof config2.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config2.onUploadProgress));
    }
    if (config2.cancelToken || config2.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config2, request) : cancel);
        request.abort();
        request = null;
      };
      config2.cancelToken && config2.cancelToken.subscribe(onCanceled);
      if (config2.signal) {
        config2.signal.aborted ? onCanceled() : config2.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config2));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils$1.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length: length2 } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length2; i2++) {
      nameOrAdapter = adapters2[i2];
      let id2;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id2 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id2}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id2 || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id2, state]) => `adapter ${id2} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
  if (config2.signal && config2.signal.aborted) {
    throw new CanceledError(null, config2);
  }
}
function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = AxiosHeaders$1.from(config2.headers);
  config2.data = transformData.call(
    config2,
    config2.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config2.method) !== -1) {
    config2.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config2.adapter || defaults$1.adapter);
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData.call(
      config2,
      config2.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config2,
          config2.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config3 = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({ caseless }, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, caseless) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(a2, b2, caseless);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils$1.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils$1.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), true)
  };
  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config3[prop] = configValue);
  });
  return config3;
}
const VERSION = "1.6.1";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  request(configOrUrl, config2) {
    if (typeof configOrUrl === "string") {
      config2 = config2 || {};
      config2.url = configOrUrl;
    } else {
      config2 = configOrUrl || {};
    }
    config2 = mergeConfig(this.defaults, config2);
    const { transitional: transitional2, paramsSerializer, headers } = config2;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config2.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config2.method = (config2.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config2.method]
    );
    headers && utils$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config2.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config2);
      while (i2 < len) {
        promise2 = promise2.then(chain[i2++], chain[i2++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config2;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise2 = promise2.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise2;
  }
  getUri(config2) {
    config2 = mergeConfig(this.defaults, config2);
    const fullPath = buildFullPath(config2.baseURL, config2.url);
    return buildURL(fullPath, config2.params, config2.paramsSerializer);
  }
}
utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config2) {
    return this.request(mergeConfig(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config2) {
      return this.request(mergeConfig(config2 || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token2 = this;
    this.promise.then((cancel) => {
      if (!token2._listeners)
        return;
      let i2 = token2._listeners.length;
      while (i2-- > 0) {
        token2._listeners[i2](cancel);
      }
      token2._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve) => {
        token2.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise2.cancel = function reject() {
        token2.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message, config2, request) {
      if (token2.reason) {
        return;
      }
      token2.reason = new CanceledError(message, config2, request);
      resolvePromise(token2.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token2 = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token: token2,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils$1.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
function uploadAdapter(loader) {
  const csrf = document.querySelector('meta[name="csrf-token"]').content;
  return {
    upload: () => {
      return new Promise(async (resolve, reject) => {
        try {
          const file = await loader.file;
          const response = await axios$1.request({
            method: "POST",
            url: `/api/course/upload-temp-image`,
            data: {
              image: file
            },
            headers: {
              "Content-Type": "multipart/form-data",
              "X-CSRF-Token": csrf
            }
          });
          resolve({
            default: response.data.file.url
          });
        } catch (error) {
          reject("Hello");
        }
      });
    },
    abort: () => {
    }
  };
}
function uploadPlugin(editor2) {
  editor2.plugins.get("FileRepository").createUploadAdapter = (loader) => {
    return uploadAdapter(loader);
  };
}
function CkEditor({ onChange }) {
  const [editor2, setEditor] = reactExports.useState("");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    distExports.CKEditor,
    {
      editor: ClassicEditor,
      config: { extraPlugins: [uploadPlugin] },
      data: editor2,
      onReady: (editor22) => {
        console.log("Editor is ready to use!", editor22);
      },
      onChange: (event, editor22) => {
        setEditor(editor22.getData());
        onChange(editor22.getData());
      },
      onBlur: (event, editor22) => {
        console.log("Blur.", editor22);
      },
      onFocus: (event, editor22) => {
        console.log("Focus.", editor22);
      }
    }
  ) });
}
function CreateLessonForm({ type }) {
  const { themeId, courseId, chapterId, lessonId } = useParams();
  const { data, isError, isFetching } = useGetLessonByIdQuery(`${lessonId}`, {
    skip: !lessonId
  });
  const tests = useTypedSelector((state) => state.lesson.tests);
  const { addEmptyTest, setTestsData, setLoaderActive } = useActions();
  const [createLesson] = useCreateLessonMutation();
  const [updateLesson] = useUpdateLessonMutation();
  const [lessonName, setLessonName] = reactExports.useState("");
  const [isValidName, setValidName] = reactExports.useState(false);
  const [isChangedName, setChangedName] = reactExports.useState(false);
  const navigation = useNavigate();
  const [ckEditorData, setCkEditorData] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (data) {
      setLessonName(data.data.title);
      setValidName(true);
      setChangedName(false);
      setTestsData(data.data.tests);
    }
  }, [data, isError, isFetching, setTestsData]);
  const testsDataWithoutFrontIds = reactExports.useMemo(() => {
    return tests.map((test) => {
      const { id: id2, answers, ...rest } = test;
      const clearAnswers = answers.map((answer) => {
        const { id: id22, ...rest2 } = answer;
        if (id22.length === 21 && typeof id22 === "string") {
          return rest2;
        }
        return answer;
      });
      if (id2.length === 21 && typeof id2 === "string") {
        return {
          ...rest,
          answers: clearAnswers
        };
      }
      return {
        ...rest,
        answers: clearAnswers,
        id: id2
      };
    });
  }, [tests]);
  const handleChange = (event) => {
    setValidName(event.target.value.length > 1);
    setLessonName(event.target.value);
    if (!isChangedName) {
      setChangedName(true);
    }
  };
  const handleConfirm = async () => {
    if (!isValidName) {
      setChangedName(true);
      return;
    }
    if (type === "edit") {
      updateLesson({
        id: Number(lessonId),
        theme_id: Number(data == null ? void 0 : data.data.theme_id),
        title: lessonName,
        description: ckEditorData,
        tests: testsDataWithoutFrontIds
      }).then((res) => {
        if ("data" in res) {
          navigation(`/courses/${courseId}/${chapterId}/${themeId}/${res.data.data.id}`);
        }
      }).catch((error) => {
        console.error(error);
      });
      setLoaderActive(true);
      return;
    }
    createLesson({
      title: lessonName,
      theme_id: Number(themeId),
      description: ckEditorData,
      tests: testsDataWithoutFrontIds
    }).then((res) => {
      if ("data" in res) {
        navigation(`/courses/${courseId}/${chapterId}/${themeId}/${res.data.data.id}`);
      }
    }).catch((error) => {
      console.error(error);
    });
    setLoaderActive(true);
  };
  const controlsData = {
    names: {
      confirm: type === "create" ? "Создать урок" : "Сохранить",
      cancel: "Отмена"
    },
    handlers: {
      confirm: handleConfirm,
      cancel: () => {
        navigation(`/courses/${courseId}/${chapterId}/${themeId}`);
      }
    }
  };
  const handleAddEmptyTest = () => {
    addEmptyTest();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title$4, { children: type === "create" ? "Создание урока" : "Редактирование урока" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      LessonNameInput,
      {
        $isValid: isValidName,
        $isChanged: isChangedName,
        value: lessonName,
        onChange: handleChange,
        type: "text",
        placeholder: "Введите название урока (обязательно)"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditor, { onChange: setCkEditorData }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TestWrapper, { children: [
      tests.length > 0 && tests.map((test) => /* @__PURE__ */ jsxRuntimeExports.jsx(CreateTestForm, { data: test })),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(AddTest, { onClick: handleAddEmptyTest, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AddTestIcon, {}),
        "добавить тест"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$2, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControls,
      {
        ...controlsData,
        containerStyles: { padding: "25px 0px 25px" }
      }
    )
  ] });
}
const ChangeBodyBg$2 = at$1`
  body {
    background-color: ${(props) => props.theme.colors.realWhite} !important;
  }
`;
function CreateLesson({ type }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultContainer, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ChangeBodyBg$2, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CreateLessonForm, { type })
  ] }) });
}
const Title$1 = st$1(Text$6)`
  margin-bottom: 20px;
  font-size: 92.5px;
`;
const NewsNameInput = st$1(InputWithState)`
  margin-bottom: 15px;
`;
st$1.div`
  width: 100%;
  min-height: 472px;
  padding: 25px;
  padding-left: 75px;
  margin-bottom: 25px;
  border: 1px solid ${(props) => props.theme.colors.greyEO};
  border-radius: ${(props) => props.theme.utils.br};
`;
st$1.div`
  margin-bottom: 60px;
`;
const Divider$1 = st$1.div`
  position: relative;
  width: 100%;
  height: 1px;
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 100vw;
    height: 100%;
    background-color: ${(props) => props.theme.colors.greyF1};
    transform: translateX(-50%);
  }
`;
st$1.div`
  position: relative;
  margin-bottom: 50px;
`;
const AddCategory = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  width: fit-content;
  padding: 0 20px;
  margin-bottom: 115px;
`;
const AddIcon = st$1(Icon$2)`
  margin-right: 10px;
  background-image: url(${addIcon});
`;
const CategoriesList$1 = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 10px;
  margin-bottom: 20px;
`;
const Category$1 = st$1(Text$6)``;
let editor$1;
function CreateNewsForm({ type }) {
  const { setModalOpen, setModalType, setNewsCategories, setLoaderActive } = useActions();
  const [createNews] = useCreateNewsMutation();
  const navigate = useNavigate();
  const { newsId } = useParams();
  const [NewsName, setNewsName] = reactExports.useState("");
  const [isValidName, setValidName] = reactExports.useState(false);
  const [isChangedName, setChangedName] = reactExports.useState(false);
  const categories = useTypedSelector((state) => state.news.newsCategories);
  const { data, isFetching } = useGetNewsByIdQuery(Number(newsId), {
    skip: !newsId
  });
  const [updateNews] = useUpdateNewsMutation();
  const [ckEditorData, setCkEditorData] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (type === "edit" && data) {
      setNewsName(data.data.title);
      setValidName(true);
      setChangedName(false);
      setNewsCategories(data.data.categories || []);
    }
  }, [data, setNewsCategories, type]);
  const handleConfirm = async () => {
    const editorData = await (editor$1 == null ? void 0 : editor$1.save().then((data2) => data2));
    if (!isValidName) {
      setChangedName(true);
      return;
    }
    if (type !== "edit") {
      createNews({
        title: NewsName,
        text: ckEditorData,
        NewsCategory: categories
      }).then((res) => {
        if ("data" in res && res.data.result) {
          navigate("/news");
        } else {
          alert("Произошла ошибка при создании новости. Попробуйте ещё раз!");
        }
      }).catch((err) => {
        setLoaderActive(false);
        console.error(err);
        alert("Произошла ошибка при создании новости. Попробуйте ещё раз!");
      });
      setLoaderActive(true);
    }
    if (type === "edit") {
      updateNews({
        id: Number(newsId),
        title: NewsName,
        text: JSON.stringify(editorData ? editorData.blocks : []),
        NewsCategory: categories
      }).then((res) => {
        if ("data" in res && res.data.result) {
          navigate("/news");
        }
      }).catch((err) => {
        setLoaderActive(false);
        console.error(err);
        alert("Произошла ошибка при редактировании новости. Попробуйте ещё раз!");
      });
      setLoaderActive(true);
    }
  };
  const handleCancel = () => {
    navigate("/news");
  };
  const handleChange = (event) => {
    setValidName(event.target.value.length > 1);
    setNewsName(event.target.value);
    if (!isChangedName) {
      setChangedName(true);
    }
  };
  const handleOpenCategoriesModal = () => {
    setModalType(MODAL_TYPES.newsCategory);
    setModalOpen(true);
  };
  const controlsData = {
    names: {
      confirm: type === "edit" ? "Сохранить" : "Создать новость",
      cancel: "Отмена"
    },
    handlers: {
      confirm: handleConfirm,
      cancel: handleCancel
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title$1, { children: type === "create" ? "Создание новости" : "Редактирование новости" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      NewsNameInput,
      {
        $isValid: isValidName,
        $isChanged: isChangedName,
        value: NewsName,
        onChange: handleChange,
        type: "text",
        placeholder: "Введите название новости (обязательно)"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditor, { onChange: setCkEditorData }),
    categories.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(CategoriesList$1, { children: categories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsx(Category$1, { children: category.title })) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(AddCategory, { onClick: handleOpenCategoriesModal, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AddIcon, {}),
      "добавить категории"
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Divider$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControls,
      {
        ...controlsData,
        containerStyles: { padding: "25px 0px 25px" }
      }
    )
  ] });
}
const ChangeBodyBg$1 = at$1`
  body {
    background-color: ${(props) => props.theme.colors.realWhite} !important;
  }
`;
function CreateNews({ type }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultContainer, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ChangeBodyBg$1, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CreateNewsForm, { type })
  ] });
}
const Overlay = st$1(FlexContainer)`
  align-items: center;
  justify-content: center;
  position: fixed;
  z-index: ${(props) => props.theme.utils.zIndex.loading};
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  opacity: ${(props) => props.$state === "exited" || props.$state === "exiting" ? 0 : 1};
  background-color: rgba(0, 0, 0, 0.5);
  transition: opacity .2s ease-in-out;
`;
const Container$1 = st$1(FlexContainer)`
  align-items: center;
  width: fit-content;
  padding: 18px 24px;
  border-radius: ${(props) => props.theme.utils.br};
  background-color: ${(props) => props.theme.colors.realWhite};
`;
const Logo = st$1.img`
  width: 30px;
  margin-right: 15px;
`;
const Text$1 = st$1(Text$6)`
  font-size: 22.714px;
`;
function Loading({ styles: styles2 = {}, state, innerRef }) {
  const modalRoot = document.getElementById("modal-root");
  if (!modalRoot)
    return;
  return ReactDOM.createPortal(
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Overlay,
      {
        $state: state,
        style: styles2,
        ref: innerRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Container$1, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Logo, { src: loadingLogo }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Text$1, { children: "Загрузка..." })
        ] })
      }
    ),
    modalRoot
  );
}
const bookIcon = "/assets/book.svg";
const homeIcon = "/assets/home.svg";
const Header$1 = st$1.header`
  display: flex;
  align-items: center;
  padding: 3.125vw;
  border-bottom: 1px solid ${(props) => props.theme.colors.greyF1};
  background-color: ${(props) => props.theme.colors.realWhite};
`;
const OpenNavBtn = st$1(Icon$2)`
  padding: 0;
  margin: 0;
  margin-right: auto;
  background-image: url(${bookIcon});
  background-color: transparent;
`;
const HomeLink = st$1(Icon$2)`
  background-image: url(${homeIcon});
`;
function Header() {
  const { setNavPopup } = useActions();
  const navigate = useNavigate();
  const handleOpenNavPopup = () => {
    setNavPopup(true);
  };
  const handleGoHome = () => {
    navigate("/courses");
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Header$1, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      OpenNavBtn,
      {
        onClick: handleOpenNavPopup,
        as: "button"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(HomeLink, { onClick: handleGoHome, as: "a" })
  ] });
}
const bodyOverflow = at$1`
  body {
    overflow: hidden;
    background-color: ${(props) => props.theme.colors.realWhite};
  }
`;
function CourseMob() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(bodyOverflow, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Course, {})
  ] });
}
const CategoriesList = st$1(FlexContainer)`
  flex-direction: column;
  row-gap: 10px;
  margin-bottom: 20px;
`;
const AddCategoryBtn = st$1(DefaultBtn)`
  display: flex;
  align-items: center;
  justify-content: center;
  width: fit-content;
  padding: 0 20px;
`;
const AddCategoryIcon = st$1(Icon$2)`
  margin-right: 10px;
  background-image: url(${addIcon});
`;
const saveIcon = "/assets/Save.svg";
const Container = st$1(FlexContainer)`
  align-items: center;
  justify-content: space-between;
`;
const Input$1 = st$1(InputWithState)`
  max-width: 80%;
`;
const SaveBtn = st$1(Icon$2)`
  padding: 0;
  background-color: transparent;
  background-image: url(${saveIcon});
`;
const DeleteBtn = st$1(SaveBtn)`
  background-image: url(${deleteIcon$1});
`;
const checkboxIcon = "/assets/checkbox.svg";
const checkboxIconChecked = "/assets/checkbox-checked.svg";
const Label = st$1.label`
  display: flex;
  align-items: center;
  cursor: pointer;
`;
const Input2 = st$1.input`
  display: none;
`;
const CustomCheckbox$1 = st$1.div`
  width: 24px;
  height: 24px;
  margin-right: 11px;
  background-image: url(${(props) => props.$checked ? checkboxIconChecked : checkboxIcon});
  background-repeat: no-repeat;
  background-position: center;
  background-size: 100%;

  ${(props) => {
  if (props.$isRadio) {
    return nt$1`
        position: relative;
        width: 16px;
        height: 16px;
        margin-right: 14px;
        border-radius: 50%;
        position: relative;
        border: 1px solid #333;
        background-image: unset;
      `;
  }
}}

  &::before {
    content: '';
    display: ${(props) => props.$checked && props.$isRadio ? "block" : "none"};
    position: absolute;
    top: 50%;
    left: 50%;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background-color: #333;
    transform: translate(-50%, -50%);
  }
`;
const CheckboxDescr = st$1(Text$6)`
line-height100%`;
function CustomCheckbox({ descr, onChange = () => {
}, children, checked = false, isRadio = false }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Label, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input2,
      {
        type: "checkbox",
        onChange,
        checked
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomCheckbox$1,
      {
        $checked: checked,
        $isRadio: isRadio
      }
    ),
    children,
    descr && /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxDescr, { children: descr })
  ] });
}
function Category({ data, isAdded, onSave, onDelete, onToggle }) {
  const [categoryTitle, setCategoryTitle] = reactExports.useState(data.title);
  const [isValid, setValid] = reactExports.useState(false);
  const [isEdit, setEdit] = reactExports.useState(false);
  const inputRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    setValid(categoryTitle.length > 1);
  }, [categoryTitle.length]);
  const handleChange = (e2) => {
    setCategoryTitle(e2.target.value);
  };
  const handleEdit = () => {
    if (isEdit) {
      return;
    }
    const isConfirm = confirm("Вы хотите отредактировать категорию?");
    if (!isConfirm && inputRef.current) {
      inputRef.current.blur();
      return;
    }
    setEdit(true);
  };
  const handleDelete = () => {
    const isConfirm = confirm("Вы хотите удалить категорию?");
    if (!isConfirm) {
      return;
    }
    onDelete();
  };
  const handleSave = () => {
    onSave(data.id, categoryTitle);
    setEdit(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Container, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CustomCheckbox,
      {
        checked: isAdded,
        onChange: onToggle
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Input$1,
      {
        ref: inputRef,
        type: "text",
        value: categoryTitle,
        onChange: handleChange,
        $isValid: isValid,
        onFocus: handleEdit
      }
    ),
    !isEdit && /* @__PURE__ */ jsxRuntimeExports.jsx(DeleteBtn, { onClick: handleDelete }),
    isEdit && /* @__PURE__ */ jsxRuntimeExports.jsx(SaveBtn, { onClick: handleSave })
  ] });
}
function NewsCategoryForm() {
  const { data, isError, isFetching } = useGetNewsCategoryQuery();
  const [createCategory] = useCreateNewsCategoryMutation();
  const [deleteCategory] = useDeleteNewsCategoryMutation();
  const [updateCategory] = useUpdateNewsCategoryMutation();
  const currentCategories = useTypedSelector((state) => state.news.newsCategories);
  const { setLoaderActive, deleteNewsCategory, addNewsCategory, setModalOpen } = useActions();
  const handleCreateCategory = () => {
    createCategory({ title: "Новая категория" }).then(() => {
      setLoaderActive(false);
    });
    setLoaderActive(true);
  };
  const handleDeleteCategory = (id2) => {
    deleteCategory({ id: id2 }).then(() => {
      setLoaderActive(false);
    });
    setLoaderActive(true);
  };
  const handleUpdateCategory = (id2, title) => {
    updateCategory({ id: id2, title }).then(() => {
      setLoaderActive(false);
    });
    setLoaderActive(true);
  };
  const handeleToggleCategory = (isAdded, category) => {
    if (isAdded) {
      deleteNewsCategory({ id: category.id });
      return;
    }
    addNewsCategory(category);
  };
  const handleClose = () => {
    setModalOpen(false);
  };
  const handlers = {
    cancel: handleClose,
    confirm: handleClose
  };
  const names = {
    cancel: "Отмена",
    confirm: "Сохранить"
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    ModalForm,
    {
      width: "510px",
      handlers,
      names,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CategoriesList, { children: data && !isError && !isFetching && data.data.map((category) => {
          const isAdded = currentCategories.some((cat) => cat.id === category.id);
          if (category.is_deleted) {
            return null;
          }
          return /* @__PURE__ */ jsxRuntimeExports.jsx(
            Category,
            {
              data: category,
              isAdded,
              onDelete: () => {
                handleDeleteCategory(category.id);
              },
              onSave: handleUpdateCategory,
              onToggle: () => handeleToggleCategory(isAdded, category)
            },
            category.id
          );
        }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(AddCategoryBtn, { onClick: handleCreateCategory, children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AddCategoryIcon, {}),
          "добавить категорию"
        ] })
      ]
    }
  );
}
const ChangeBodyBg = at$1`
  body {
    background-color: ${(props) => props.theme.colors.realWhite} !important;
  }
`;
const Title = st$1(Text$6)`
  margin-bottom: 20px;
  font-size: 92.5px;
`;
const CompetitionNameInput = st$1(InputWithState)`
  margin-bottom: 15px;
`;
const EditorJsWrapper = st$1.div`
  width: 100%;
  min-height: 472px;
  padding: 25px;
  padding-left: 75px;
  margin-bottom: 25px;
  border: 1px solid ${(props) => props.theme.colors.greyEO};
  border-radius: ${(props) => props.theme.utils.br};
`;
st$1.div`
margin-bottom: 60px;
`;
const Divider = st$1.div`
  position: relative;
  width: 100%;
  height: 1px;
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 50%;
    width: 100vw;
    height: 100%;
    background-color: ${(props) => props.theme.colors.greyF1};
    transform: translateX(-50%);
  }
`;
st$1.div`
  position: relative;
  margin-bottom: 50px;
`;
var Nt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ye(s2) {
  return s2 && s2.__esModule && Object.prototype.hasOwnProperty.call(s2, "default") ? s2.default : s2;
}
function Te() {
}
Object.assign(Te, {
  default: Te,
  register: Te,
  revert: function() {
  },
  __esModule: true
});
Element.prototype.matches || (Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s2) {
  const e2 = (this.document || this.ownerDocument).querySelectorAll(s2);
  let t2 = e2.length;
  for (; --t2 >= 0 && e2.item(t2) !== this; )
    ;
  return t2 > -1;
});
Element.prototype.closest || (Element.prototype.closest = function(s2) {
  let e2 = this;
  if (!document.documentElement.contains(e2))
    return null;
  do {
    if (e2.matches(s2))
      return e2;
    e2 = e2.parentElement || e2.parentNode;
  } while (e2 !== null);
  return null;
});
Element.prototype.prepend || (Element.prototype.prepend = function(e2) {
  const t2 = document.createDocumentFragment();
  Array.isArray(e2) || (e2 = [e2]), e2.forEach((o2) => {
    const i2 = o2 instanceof Node;
    t2.appendChild(i2 ? o2 : document.createTextNode(o2));
  }), this.insertBefore(t2, this.firstChild);
});
Element.prototype.scrollIntoViewIfNeeded || (Element.prototype.scrollIntoViewIfNeeded = function(s2) {
  s2 = arguments.length === 0 ? true : !!s2;
  const e2 = this.parentNode, t2 = window.getComputedStyle(e2, null), o2 = parseInt(t2.getPropertyValue("border-top-width")), i2 = parseInt(t2.getPropertyValue("border-left-width")), n2 = this.offsetTop - e2.offsetTop < e2.scrollTop, r2 = this.offsetTop - e2.offsetTop + this.clientHeight - o2 > e2.scrollTop + e2.clientHeight, a2 = this.offsetLeft - e2.offsetLeft < e2.scrollLeft, l2 = this.offsetLeft - e2.offsetLeft + this.clientWidth - i2 > e2.scrollLeft + e2.clientWidth, c2 = n2 && !r2;
  (n2 || r2) && s2 && (e2.scrollTop = this.offsetTop - e2.offsetTop - e2.clientHeight / 2 - o2 + this.clientHeight / 2), (a2 || l2) && s2 && (e2.scrollLeft = this.offsetLeft - e2.offsetLeft - e2.clientWidth / 2 - i2 + this.clientWidth / 2), (n2 || r2 || a2 || l2) && !s2 && this.scrollIntoView(c2);
});
window.requestIdleCallback = window.requestIdleCallback || function(s2) {
  const e2 = Date.now();
  return setTimeout(function() {
    s2({
      didTimeout: false,
      timeRemaining: function() {
        return Math.max(0, 50 - (Date.now() - e2));
      }
    });
  }, 1);
};
window.cancelIdleCallback = window.cancelIdleCallback || function(s2) {
  clearTimeout(s2);
};
let Rt = (s2 = 21) => crypto.getRandomValues(new Uint8Array(s2)).reduce((e2, t2) => (t2 &= 63, t2 < 36 ? e2 += t2.toString(36) : t2 < 62 ? e2 += (t2 - 26).toString(36).toUpperCase() : t2 > 62 ? e2 += "-" : e2 += "_", e2), "");
var rt = /* @__PURE__ */ ((s2) => (s2.VERBOSE = "VERBOSE", s2.INFO = "INFO", s2.WARN = "WARN", s2.ERROR = "ERROR", s2))(rt || {});
const B = {
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  SHIFT: 16,
  CTRL: 17,
  ALT: 18,
  ESC: 27,
  SPACE: 32,
  LEFT: 37,
  UP: 38,
  DOWN: 40,
  RIGHT: 39,
  DELETE: 46,
  META: 91
}, Dt = {
  LEFT: 0,
  WHEEL: 1,
  RIGHT: 2,
  BACKWARD: 3,
  FORWARD: 4
};
function ke(s2, e2, t2 = "log", o2, i2 = "color: inherit") {
  if (!("console" in window) || !window.console[t2])
    return;
  const n2 = ["info", "log", "warn", "error"].includes(t2), r2 = [];
  switch (ke.logLevel) {
    case "ERROR":
      if (t2 !== "error")
        return;
      break;
    case "WARN":
      if (!["error", "warn"].includes(t2))
        return;
      break;
    case "INFO":
      if (!n2 || s2)
        return;
      break;
  }
  o2 && r2.push(o2);
  const a2 = "Editor.js 2.29.0-rc.1", l2 = `line-height: 1em;
            color: #006FEA;
            display: inline-block;
            font-size: 11px;
            line-height: 1em;
            background-color: #fff;
            padding: 4px 9px;
            border-radius: 30px;
            border: 1px solid rgba(56, 138, 229, 0.16);
            margin: 4px 5px 4px 0;`;
  s2 && (n2 ? (r2.unshift(l2, i2), e2 = `%c${a2}%c ${e2}`) : e2 = `( ${a2} )${e2}`);
  try {
    n2 ? o2 ? console[t2](`${e2} %o`, ...r2) : console[t2](e2, ...r2) : console[t2](e2);
  } catch {
  }
}
ke.logLevel = "VERBOSE";
function Pt(s2) {
  ke.logLevel = s2;
}
const L = ke.bind(window, false), X = ke.bind(window, true);
function ie(s2) {
  return Object.prototype.toString.call(s2).match(/\s([a-zA-Z]+)/)[1].toLowerCase();
}
function D(s2) {
  return ie(s2) === "function" || ie(s2) === "asyncfunction";
}
function z(s2) {
  return ie(s2) === "object";
}
function Q(s2) {
  return ie(s2) === "string";
}
function Ft(s2) {
  return ie(s2) === "boolean";
}
function Je(s2) {
  return ie(s2) === "number";
}
function Qe(s2) {
  return ie(s2) === "undefined";
}
function q(s2) {
  return s2 ? Object.keys(s2).length === 0 && s2.constructor === Object : true;
}
function at(s2) {
  return s2 > 47 && s2 < 58 || // number keys
  s2 === 32 || s2 === 13 || // Space bar & return key(s)
  s2 === 229 || // processing key input for certain languages — Chinese, Japanese, etc.
  s2 > 64 && s2 < 91 || // letter keys
  s2 > 95 && s2 < 112 || // Numpad keys
  s2 > 185 && s2 < 193 || // ;=,-./` (in order)
  s2 > 218 && s2 < 223;
}
async function Ht(s2, e2 = () => {
}, t2 = () => {
}) {
  async function o2(i2, n2, r2) {
    try {
      await i2.function(i2.data), await n2(Qe(i2.data) ? {} : i2.data);
    } catch {
      r2(Qe(i2.data) ? {} : i2.data);
    }
  }
  return s2.reduce(async (i2, n2) => (await i2, o2(n2, e2, t2)), Promise.resolve());
}
function lt(s2) {
  return Array.prototype.slice.call(s2);
}
function ge(s2, e2) {
  return function() {
    const t2 = this, o2 = arguments;
    window.setTimeout(() => s2.apply(t2, o2), e2);
  };
}
function jt(s2) {
  return s2.name.split(".").pop();
}
function zt(s2) {
  return /^[-\w]+\/([-+\w]+|\*)$/.test(s2);
}
function Ut(s2, e2, t2) {
  let o2;
  return (...i2) => {
    const n2 = this, r2 = () => {
      o2 = null, t2 || s2.apply(n2, i2);
    }, a2 = t2 && !o2;
    window.clearTimeout(o2), o2 = window.setTimeout(r2, e2), a2 && s2.apply(n2, i2);
  };
}
function Ie(s2, e2, t2 = void 0) {
  let o2, i2, n2, r2 = null, a2 = 0;
  t2 || (t2 = {});
  const l2 = function() {
    a2 = t2.leading === false ? 0 : Date.now(), r2 = null, n2 = s2.apply(o2, i2), r2 || (o2 = i2 = null);
  };
  return function() {
    const c2 = Date.now();
    !a2 && t2.leading === false && (a2 = c2);
    const u2 = e2 - (c2 - a2);
    return o2 = this, i2 = arguments, u2 <= 0 || u2 > e2 ? (r2 && (clearTimeout(r2), r2 = null), a2 = c2, n2 = s2.apply(o2, i2), r2 || (o2 = i2 = null)) : !r2 && t2.trailing !== false && (r2 = setTimeout(l2, u2)), n2;
  };
}
function $t() {
  const s2 = {
    win: false,
    mac: false,
    x11: false,
    linux: false
  }, e2 = Object.keys(s2).find((t2) => window.navigator.appVersion.toLowerCase().indexOf(t2) !== -1);
  return e2 && (s2[e2] = true), s2;
}
function ae(s2) {
  return s2[0].toUpperCase() + s2.slice(1);
}
function Me(s2, ...e2) {
  if (!e2.length)
    return s2;
  const t2 = e2.shift();
  if (z(s2) && z(t2))
    for (const o2 in t2)
      z(t2[o2]) ? (s2[o2] || Object.assign(s2, { [o2]: {} }), Me(s2[o2], t2[o2])) : Object.assign(s2, { [o2]: t2[o2] });
  return Me(s2, ...e2);
}
function Fe(s2) {
  const e2 = $t();
  return s2 = s2.replace(/shift/gi, "⇧").replace(/backspace/gi, "⌫").replace(/enter/gi, "⏎").replace(/up/gi, "↑").replace(/left/gi, "→").replace(/down/gi, "↓").replace(/right/gi, "←").replace(/escape/gi, "⎋").replace(/insert/gi, "Ins").replace(/delete/gi, "␡").replace(/\+/gi, " + "), e2.mac ? s2 = s2.replace(/ctrl|cmd/gi, "⌘").replace(/alt/gi, "⌥") : s2 = s2.replace(/cmd/gi, "Ctrl").replace(/windows/gi, "WIN"), s2;
}
function Wt(s2) {
  try {
    return new URL(s2).href;
  } catch {
  }
  return s2.substring(0, 2) === "//" ? window.location.protocol + s2 : window.location.origin + s2;
}
function Yt() {
  return Rt(10);
}
function Kt(s2) {
  window.open(s2, "_blank");
}
function Xt(s2 = "") {
  return `${s2}${Math.floor(Math.random() * 1e8).toString(16)}`;
}
function Le(s2, e2, t2) {
  const o2 = `«${e2}» is deprecated and will be removed in the next major release. Please use the «${t2}» instead.`;
  s2 && X(o2, "warn");
}
function ce(s2, e2, t2) {
  const o2 = t2.value ? "value" : "get", i2 = t2[o2], n2 = `#${e2}Cache`;
  if (t2[o2] = function(...r2) {
    return this[n2] === void 0 && (this[n2] = i2.apply(this, ...r2)), this[n2];
  }, o2 === "get" && t2.set) {
    const r2 = t2.set;
    t2.set = function(a2) {
      delete s2[n2], r2.apply(this, a2);
    };
  }
  return t2;
}
const ct = 650;
function oe() {
  return window.matchMedia(`(max-width: ${ct}px)`).matches;
}
const et = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1);
function Vt(s2, e2) {
  const t2 = Array.isArray(s2) || z(s2), o2 = Array.isArray(e2) || z(e2);
  return t2 || o2 ? JSON.stringify(s2) === JSON.stringify(e2) : s2 === e2;
}
class d {
  /**
   * Check if passed tag has no closed tag
   *
   * @param {HTMLElement} tag - element to check
   * @returns {boolean}
   */
  static isSingleTag(e2) {
    return e2.tagName && [
      "AREA",
      "BASE",
      "BR",
      "COL",
      "COMMAND",
      "EMBED",
      "HR",
      "IMG",
      "INPUT",
      "KEYGEN",
      "LINK",
      "META",
      "PARAM",
      "SOURCE",
      "TRACK",
      "WBR"
    ].includes(e2.tagName);
  }
  /**
   * Check if element is BR or WBR
   *
   * @param {HTMLElement} element - element to check
   * @returns {boolean}
   */
  static isLineBreakTag(e2) {
    return e2 && e2.tagName && [
      "BR",
      "WBR"
    ].includes(e2.tagName);
  }
  /**
   * Helper for making Elements with class name and attributes
   *
   * @param  {string} tagName - new Element tag name
   * @param  {string[]|string} [classNames] - list or name of CSS class name(s)
   * @param  {object} [attributes] - any attributes
   * @returns {HTMLElement}
   */
  static make(e2, t2 = null, o2 = {}) {
    const i2 = document.createElement(e2);
    Array.isArray(t2) ? i2.classList.add(...t2) : t2 && i2.classList.add(t2);
    for (const n2 in o2)
      Object.prototype.hasOwnProperty.call(o2, n2) && (i2[n2] = o2[n2]);
    return i2;
  }
  /**
   * Creates Text Node with the passed content
   *
   * @param {string} content - text content
   * @returns {Text}
   */
  static text(e2) {
    return document.createTextNode(e2);
  }
  /**
   * Append one or several elements to the parent
   *
   * @param  {Element|DocumentFragment} parent - where to append
   * @param  {Element|Element[]|DocumentFragment|Text|Text[]} elements - element or elements list
   */
  static append(e2, t2) {
    Array.isArray(t2) ? t2.forEach((o2) => e2.appendChild(o2)) : e2.appendChild(t2);
  }
  /**
   * Append element or a couple to the beginning of the parent elements
   *
   * @param {Element} parent - where to append
   * @param {Element|Element[]} elements - element or elements list
   */
  static prepend(e2, t2) {
    Array.isArray(t2) ? (t2 = t2.reverse(), t2.forEach((o2) => e2.prepend(o2))) : e2.prepend(t2);
  }
  /**
   * Swap two elements in parent
   *
   * @param {HTMLElement} el1 - from
   * @param {HTMLElement} el2 - to
   * @deprecated
   */
  static swap(e2, t2) {
    const o2 = document.createElement("div"), i2 = e2.parentNode;
    i2.insertBefore(o2, e2), i2.insertBefore(e2, t2), i2.insertBefore(t2, o2), i2.removeChild(o2);
  }
  /**
   * Selector Decorator
   *
   * Returns first match
   *
   * @param {Element} el - element we searching inside. Default - DOM Document
   * @param {string} selector - searching string
   * @returns {Element}
   */
  static find(e2 = document, t2) {
    return e2.querySelector(t2);
  }
  /**
   * Get Element by Id
   *
   * @param {string} id - id to find
   * @returns {HTMLElement | null}
   */
  static get(e2) {
    return document.getElementById(e2);
  }
  /**
   * Selector Decorator.
   *
   * Returns all matches
   *
   * @param {Element|Document} el - element we searching inside. Default - DOM Document
   * @param {string} selector - searching string
   * @returns {NodeList}
   */
  static findAll(e2 = document, t2) {
    return e2.querySelectorAll(t2);
  }
  /**
   * Returns CSS selector for all text inputs
   */
  static get allInputsSelector() {
    return "[contenteditable=true], textarea, input:not([type]), " + ["text", "password", "email", "number", "search", "tel", "url"].map((t2) => `input[type="${t2}"]`).join(", ");
  }
  /**
   * Find all contenteditable, textarea and editable input elements passed holder contains
   *
   * @param holder - element where to find inputs
   */
  static findAllInputs(e2) {
    return lt(e2.querySelectorAll(d.allInputsSelector)).reduce((t2, o2) => d.isNativeInput(o2) || d.containsOnlyInlineElements(o2) ? [...t2, o2] : [...t2, ...d.getDeepestBlockElements(o2)], []);
  }
  /**
   * Search for deepest node which is Leaf.
   * Leaf is the vertex that doesn't have any child nodes
   *
   * @description Method recursively goes throw the all Node until it finds the Leaf
   * @param {Node} node - root Node. From this vertex we start Deep-first search
   *                      {@link https://en.wikipedia.org/wiki/Depth-first_search}
   * @param {boolean} [atLast] - find last text node
   * @returns {Node} - it can be text Node or Element Node, so that caret will able to work with it
   */
  static getDeepestNode(e2, t2 = false) {
    const o2 = t2 ? "lastChild" : "firstChild", i2 = t2 ? "previousSibling" : "nextSibling";
    if (e2 && e2.nodeType === Node.ELEMENT_NODE && e2[o2]) {
      let n2 = e2[o2];
      if (d.isSingleTag(n2) && !d.isNativeInput(n2) && !d.isLineBreakTag(n2))
        if (n2[i2])
          n2 = n2[i2];
        else if (n2.parentNode[i2])
          n2 = n2.parentNode[i2];
        else
          return n2.parentNode;
      return this.getDeepestNode(n2, t2);
    }
    return e2;
  }
  /**
   * Check if object is DOM node
   *
   * @param {*} node - object to check
   * @returns {boolean}
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isElement(e2) {
    return Je(e2) ? false : e2 && e2.nodeType && e2.nodeType === Node.ELEMENT_NODE;
  }
  /**
   * Check if object is DocumentFragment node
   *
   * @param {object} node - object to check
   * @returns {boolean}
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isFragment(e2) {
    return Je(e2) ? false : e2 && e2.nodeType && e2.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
  }
  /**
   * Check if passed element is contenteditable
   *
   * @param {HTMLElement} element - html element to check
   * @returns {boolean}
   */
  static isContentEditable(e2) {
    return e2.contentEditable === "true";
  }
  /**
   * Checks target if it is native input
   *
   * @param {*} target - HTML element or string
   * @returns {boolean}
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static isNativeInput(e2) {
    const t2 = [
      "INPUT",
      "TEXTAREA"
    ];
    return e2 && e2.tagName ? t2.includes(e2.tagName) : false;
  }
  /**
   * Checks if we can set caret
   *
   * @param {HTMLElement} target - target to check
   * @returns {boolean}
   */
  static canSetCaret(e2) {
    let t2 = true;
    if (d.isNativeInput(e2))
      switch (e2.type) {
        case "file":
        case "checkbox":
        case "radio":
        case "hidden":
        case "submit":
        case "button":
        case "image":
        case "reset":
          t2 = false;
          break;
      }
    else
      t2 = d.isContentEditable(e2);
    return t2;
  }
  /**
   * Checks node if it is empty
   *
   * @description Method checks simple Node without any childs for emptiness
   * If you have Node with 2 or more children id depth, you better use {@link Dom#isEmpty} method
   * @param {Node} node - node to check
   * @returns {boolean} true if it is empty
   */
  static isNodeEmpty(e2) {
    let t2;
    return this.isSingleTag(e2) && !this.isLineBreakTag(e2) ? false : (this.isElement(e2) && this.isNativeInput(e2) ? t2 = e2.value : t2 = e2.textContent.replace("​", ""), t2.trim().length === 0);
  }
  /**
   * checks node if it is doesn't have any child nodes
   *
   * @param {Node} node - node to check
   * @returns {boolean}
   */
  static isLeaf(e2) {
    return e2 ? e2.childNodes.length === 0 : false;
  }
  /**
   * breadth-first search (BFS)
   * {@link https://en.wikipedia.org/wiki/Breadth-first_search}
   *
   * @description Pushes to stack all DOM leafs and checks for emptiness
   * @param {Node} node - node to check
   * @returns {boolean}
   */
  static isEmpty(e2) {
    e2.normalize();
    const t2 = [e2];
    for (; t2.length > 0; )
      if (e2 = t2.shift(), !!e2) {
        if (this.isLeaf(e2) && !this.isNodeEmpty(e2))
          return false;
        e2.childNodes && t2.push(...Array.from(e2.childNodes));
      }
    return true;
  }
  /**
   * Check if string contains html elements
   *
   * @param {string} str - string to check
   * @returns {boolean}
   */
  static isHTMLString(e2) {
    const t2 = d.make("div");
    return t2.innerHTML = e2, t2.childElementCount > 0;
  }
  /**
   * Return length of node`s text content
   *
   * @param {Node} node - node with content
   * @returns {number}
   */
  static getContentLength(e2) {
    return d.isNativeInput(e2) ? e2.value.length : e2.nodeType === Node.TEXT_NODE ? e2.length : e2.textContent.length;
  }
  /**
   * Return array of names of block html elements
   *
   * @returns {string[]}
   */
  static get blockElements() {
    return [
      "address",
      "article",
      "aside",
      "blockquote",
      "canvas",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "header",
      "hgroup",
      "hr",
      "li",
      "main",
      "nav",
      "noscript",
      "ol",
      "output",
      "p",
      "pre",
      "ruby",
      "section",
      "table",
      "tbody",
      "thead",
      "tr",
      "tfoot",
      "ul",
      "video"
    ];
  }
  /**
   * Check if passed content includes only inline elements
   *
   * @param {string|HTMLElement} data - element or html string
   * @returns {boolean}
   */
  static containsOnlyInlineElements(e2) {
    let t2;
    Q(e2) ? (t2 = document.createElement("div"), t2.innerHTML = e2) : t2 = e2;
    const o2 = (i2) => !d.blockElements.includes(i2.tagName.toLowerCase()) && Array.from(i2.children).every(o2);
    return Array.from(t2.children).every(o2);
  }
  /**
   * Find and return all block elements in the passed parent (including subtree)
   *
   * @param {HTMLElement} parent - root element
   * @returns {HTMLElement[]}
   */
  static getDeepestBlockElements(e2) {
    return d.containsOnlyInlineElements(e2) ? [e2] : Array.from(e2.children).reduce((t2, o2) => [...t2, ...d.getDeepestBlockElements(o2)], []);
  }
  /**
   * Helper for get holder from {string} or return HTMLElement
   *
   * @param {string | HTMLElement} element - holder's id or holder's HTML Element
   * @returns {HTMLElement}
   */
  static getHolder(e2) {
    return Q(e2) ? document.getElementById(e2) : e2;
  }
  /**
   * Returns true if element is anchor (is A tag)
   *
   * @param {Element} element - element to check
   * @returns {boolean}
   */
  static isAnchor(e2) {
    return e2.tagName.toLowerCase() === "a";
  }
  /**
   * Return element's offset related to the document
   *
   * @todo handle case when editor initialized in scrollable popup
   * @param el - element to compute offset
   */
  static offset(e2) {
    const t2 = e2.getBoundingClientRect(), o2 = window.pageXOffset || document.documentElement.scrollLeft, i2 = window.pageYOffset || document.documentElement.scrollTop, n2 = t2.top + i2, r2 = t2.left + o2;
    return {
      top: n2,
      left: r2,
      bottom: n2 + t2.height,
      right: r2 + t2.width
    };
  }
}
const qt = {
  blockTunes: {
    toggler: {
      "Click to tune": "",
      "or drag to move": ""
    }
  },
  inlineToolbar: {
    converter: {
      "Convert to": ""
    }
  },
  toolbar: {
    toolbox: {
      Add: ""
    }
  },
  popover: {
    Filter: "",
    "Nothing found": ""
  }
}, Zt = {
  Text: "",
  Link: "",
  Bold: "",
  Italic: ""
}, Gt = {
  link: {
    "Add a link": ""
  },
  stub: {
    "The block can not be displayed correctly.": ""
  }
}, Jt = {
  delete: {
    Delete: "",
    "Click to delete": ""
  },
  moveUp: {
    "Move up": ""
  },
  moveDown: {
    "Move down": ""
  }
}, dt = {
  ui: qt,
  toolNames: Zt,
  tools: Gt,
  blockTunes: Jt
}, ne = class {
  /**
   * Type-safe translation for internal UI texts:
   * Perform translation of the string by namespace and a key
   *
   * @example I18n.ui(I18nInternalNS.ui.blockTunes.toggler, 'Click to tune')
   * @param internalNamespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */
  static ui(s2, e2) {
    return ne._t(s2, e2);
  }
  /**
   * Translate for external strings that is not presented in default dictionary.
   * For example, for user-specified tool names
   *
   * @param namespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */
  static t(s2, e2) {
    return ne._t(s2, e2);
  }
  /**
   * Adjust module for using external dictionary
   *
   * @param dictionary - new messages list to override default
   */
  static setDictionary(s2) {
    ne.currentDictionary = s2;
  }
  /**
   * Perform translation both for internal and external namespaces
   * If there is no translation found, returns passed key as a translated message
   *
   * @param namespace - path to translated string in dictionary
   * @param dictKey - dictionary key. Better to use default locale original text
   */
  static _t(s2, e2) {
    const t2 = ne.getNamespace(s2);
    return !t2 || !t2[e2] ? e2 : t2[e2];
  }
  /**
   * Find messages section by namespace path
   *
   * @param namespace - path to section
   */
  static getNamespace(s2) {
    return s2.split(".").reduce((t2, o2) => !t2 || !Object.keys(t2).length ? {} : t2[o2], ne.currentDictionary);
  }
};
let W = ne;
W.currentDictionary = dt;
class ht extends Error {
}
class Ee {
  constructor() {
    this.subscribers = {};
  }
  /**
   * Subscribe any event on callback
   *
   * @param eventName - event name
   * @param callback - subscriber
   */
  on(e2, t2) {
    e2 in this.subscribers || (this.subscribers[e2] = []), this.subscribers[e2].push(t2);
  }
  /**
   * Subscribe any event on callback. Callback will be called once and be removed from subscribers array after call.
   *
   * @param eventName - event name
   * @param callback - subscriber
   */
  once(e2, t2) {
    e2 in this.subscribers || (this.subscribers[e2] = []);
    const o2 = (i2) => {
      const n2 = t2(i2), r2 = this.subscribers[e2].indexOf(o2);
      return r2 !== -1 && this.subscribers[e2].splice(r2, 1), n2;
    };
    this.subscribers[e2].push(o2);
  }
  /**
   * Emit callbacks with passed data
   *
   * @param eventName - event name
   * @param data - subscribers get this data when they were fired
   */
  emit(e2, t2) {
    q(this.subscribers) || !this.subscribers[e2] || this.subscribers[e2].reduce((o2, i2) => {
      const n2 = i2(o2);
      return n2 !== void 0 ? n2 : o2;
    }, t2);
  }
  /**
   * Unsubscribe callback from event
   *
   * @param eventName - event name
   * @param callback - event handler
   */
  off(e2, t2) {
    if (this.subscribers[e2] === void 0) {
      console.warn(`EventDispatcher .off(): there is no subscribers for event "${e2.toString()}". Probably, .off() called before .on()`);
      return;
    }
    for (let o2 = 0; o2 < this.subscribers[e2].length; o2++)
      if (this.subscribers[e2][o2] === t2) {
        delete this.subscribers[e2][o2];
        break;
      }
  }
  /**
   * Destroyer
   * clears subscribers list
   */
  destroy() {
    this.subscribers = {};
  }
}
function te(s2) {
  Object.setPrototypeOf(this, {
    /**
     * Block id
     *
     * @returns {string}
     */
    get id() {
      return s2.id;
    },
    /**
     * Tool name
     *
     * @returns {string}
     */
    get name() {
      return s2.name;
    },
    /**
     * Tool config passed on Editor's initialization
     *
     * @returns {ToolConfig}
     */
    get config() {
      return s2.config;
    },
    /**
     * .ce-block element, that wraps plugin contents
     *
     * @returns {HTMLElement}
     */
    get holder() {
      return s2.holder;
    },
    /**
     * True if Block content is empty
     *
     * @returns {boolean}
     */
    get isEmpty() {
      return s2.isEmpty;
    },
    /**
     * True if Block is selected with Cross-Block selection
     *
     * @returns {boolean}
     */
    get selected() {
      return s2.selected;
    },
    /**
     * Set Block's stretch state
     *
     * @param {boolean} state — state to set
     */
    set stretched(t2) {
      s2.stretched = t2;
    },
    /**
     * True if Block is stretched
     *
     * @returns {boolean}
     */
    get stretched() {
      return s2.stretched;
    },
    /**
     * Call Tool method with errors handler under-the-hood
     *
     * @param {string} methodName - method to call
     * @param {object} param - object with parameters
     * @returns {unknown}
     */
    call(t2, o2) {
      return s2.call(t2, o2);
    },
    /**
     * Save Block content
     *
     * @returns {Promise<void|SavedData>}
     */
    save() {
      return s2.save();
    },
    /**
     * Validate Block data
     *
     * @param {BlockToolData} data - data to validate
     * @returns {Promise<boolean>}
     */
    validate(t2) {
      return s2.validate(t2);
    },
    /**
     * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback
     * Can be useful for block changes invisible for editor core.
     */
    dispatchChange() {
      s2.dispatchChange();
    }
  });
}
class He {
  constructor() {
    this.allListeners = [];
  }
  /**
   * Assigns event listener on element and returns unique identifier
   *
   * @param {EventTarget} element - DOM element that needs to be listened
   * @param {string} eventType - event type
   * @param {Function} handler - method that will be fired on event
   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}
   */
  on(e2, t2, o2, i2 = false) {
    const n2 = Xt("l"), r2 = {
      id: n2,
      element: e2,
      eventType: t2,
      handler: o2,
      options: i2
    };
    if (!this.findOne(e2, t2, o2))
      return this.allListeners.push(r2), e2.addEventListener(t2, o2, i2), n2;
  }
  /**
   * Removes event listener from element
   *
   * @param {EventTarget} element - DOM element that we removing listener
   * @param {string} eventType - event type
   * @param {Function} handler - remove handler, if element listens several handlers on the same event type
   * @param {boolean|AddEventListenerOptions} options - useCapture or {capture, passive, once}
   */
  off(e2, t2, o2, i2) {
    const n2 = this.findAll(e2, t2, o2);
    n2.forEach((r2, a2) => {
      const l2 = this.allListeners.indexOf(n2[a2]);
      l2 > -1 && (this.allListeners.splice(l2, 1), r2.element.removeEventListener(r2.eventType, r2.handler, r2.options));
    });
  }
  /**
   * Removes listener by id
   *
   * @param {string} id - listener identifier
   */
  offById(e2) {
    const t2 = this.findById(e2);
    t2 && t2.element.removeEventListener(t2.eventType, t2.handler, t2.options);
  }
  /**
   * Finds and returns first listener by passed params
   *
   * @param {EventTarget} element - event target
   * @param {string} [eventType] - event type
   * @param {Function} [handler] - event handler
   * @returns {ListenerData|null}
   */
  findOne(e2, t2, o2) {
    const i2 = this.findAll(e2, t2, o2);
    return i2.length > 0 ? i2[0] : null;
  }
  /**
   * Return all stored listeners by passed params
   *
   * @param {EventTarget} element - event target
   * @param {string} eventType - event type
   * @param {Function} handler - event handler
   * @returns {ListenerData[]}
   */
  findAll(e2, t2, o2) {
    let i2;
    const n2 = e2 ? this.findByEventTarget(e2) : [];
    return e2 && t2 && o2 ? i2 = n2.filter((r2) => r2.eventType === t2 && r2.handler === o2) : e2 && t2 ? i2 = n2.filter((r2) => r2.eventType === t2) : i2 = n2, i2;
  }
  /**
   * Removes all listeners
   */
  removeAll() {
    this.allListeners.map((e2) => {
      e2.element.removeEventListener(e2.eventType, e2.handler, e2.options);
    }), this.allListeners = [];
  }
  /**
   * Module cleanup on destruction
   */
  destroy() {
    this.removeAll();
  }
  /**
   * Search method: looks for listener by passed element
   *
   * @param {EventTarget} element - searching element
   * @returns {Array} listeners that found on element
   */
  findByEventTarget(e2) {
    return this.allListeners.filter((t2) => {
      if (t2.element === e2)
        return t2;
    });
  }
  /**
   * Search method: looks for listener by passed event type
   *
   * @param {string} eventType - event type
   * @returns {ListenerData[]} listeners that found on element
   */
  findByType(e2) {
    return this.allListeners.filter((t2) => {
      if (t2.eventType === e2)
        return t2;
    });
  }
  /**
   * Search method: looks for listener by passed handler
   *
   * @param {Function} handler - event handler
   * @returns {ListenerData[]} listeners that found on element
   */
  findByHandler(e2) {
    return this.allListeners.filter((t2) => {
      if (t2.handler === e2)
        return t2;
    });
  }
  /**
   * Returns listener data found by id
   *
   * @param {string} id - listener identifier
   * @returns {ListenerData}
   */
  findById(e2) {
    return this.allListeners.find((t2) => t2.id === e2);
  }
}
class T {
  /**
   * @class
   * @param options - Module options
   * @param options.config - Module config
   * @param options.eventsDispatcher - Common event bus
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    if (this.nodes = {}, this.listeners = new He(), this.readOnlyMutableListeners = {
      /**
       * Assigns event listener on DOM element and pushes into special array that might be removed
       *
       * @param {EventTarget} element - DOM Element
       * @param {string} eventType - Event name
       * @param {Function} handler - Event handler
       * @param {boolean|AddEventListenerOptions} options - Listening options
       */
      on: (o2, i2, n2, r2 = false) => {
        this.mutableListenerIds.push(
          this.listeners.on(o2, i2, n2, r2)
        );
      },
      /**
       * Clears all mutable listeners
       */
      clearAll: () => {
        for (const o2 of this.mutableListenerIds)
          this.listeners.offById(o2);
        this.mutableListenerIds = [];
      }
    }, this.mutableListenerIds = [], new.target === T)
      throw new TypeError("Constructors for abstract class Module are not allowed.");
    this.config = e2, this.eventsDispatcher = t2;
  }
  /**
   * Editor modules setter
   *
   * @param {EditorModules} Editor - Editor's Modules
   */
  set state(e2) {
    this.Editor = e2;
  }
  /**
   * Remove memorized nodes
   */
  removeAllNodes() {
    for (const e2 in this.nodes) {
      const t2 = this.nodes[e2];
      t2 instanceof HTMLElement && t2.remove();
    }
  }
  /**
   * Returns true if current direction is RTL (Right-To-Left)
   */
  get isRtl() {
    return this.config.i18n.direction === "rtl";
  }
}
class m {
  constructor() {
    this.instance = null, this.selection = null, this.savedSelectionRange = null, this.isFakeBackgroundEnabled = false, this.commandBackground = "backColor", this.commandRemoveFormat = "removeFormat";
  }
  /**
   * Editor styles
   *
   * @returns {{editorWrapper: string, editorZone: string}}
   */
  static get CSS() {
    return {
      editorWrapper: "codex-editor",
      editorZone: "codex-editor__redactor"
    };
  }
  /**
   * Returns selected anchor
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorNode}
   *
   * @returns {Node|null}
   */
  static get anchorNode() {
    const e2 = window.getSelection();
    return e2 ? e2.anchorNode : null;
  }
  /**
   * Returns selected anchor element
   *
   * @returns {Element|null}
   */
  static get anchorElement() {
    const e2 = window.getSelection();
    if (!e2)
      return null;
    const t2 = e2.anchorNode;
    return t2 ? d.isElement(t2) ? t2 : t2.parentElement : null;
  }
  /**
   * Returns selection offset according to the anchor node
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Selection/anchorOffset}
   *
   * @returns {number|null}
   */
  static get anchorOffset() {
    const e2 = window.getSelection();
    return e2 ? e2.anchorOffset : null;
  }
  /**
   * Is current selection range collapsed
   *
   * @returns {boolean|null}
   */
  static get isCollapsed() {
    const e2 = window.getSelection();
    return e2 ? e2.isCollapsed : null;
  }
  /**
   * Check current selection if it is at Editor's zone
   *
   * @returns {boolean}
   */
  static get isAtEditor() {
    return this.isSelectionAtEditor(m.get());
  }
  /**
   * Check if passed selection is at Editor's zone
   *
   * @param selection - Selection object to check
   */
  static isSelectionAtEditor(e2) {
    if (!e2)
      return false;
    let t2 = e2.anchorNode || e2.focusNode;
    t2 && t2.nodeType === Node.TEXT_NODE && (t2 = t2.parentNode);
    let o2 = null;
    return t2 && t2 instanceof Element && (o2 = t2.closest(`.${m.CSS.editorZone}`)), o2 ? o2.nodeType === Node.ELEMENT_NODE : false;
  }
  /**
   * Check if passed range at Editor zone
   *
   * @param range - range to check
   */
  static isRangeAtEditor(e2) {
    if (!e2)
      return;
    let t2 = e2.startContainer;
    t2 && t2.nodeType === Node.TEXT_NODE && (t2 = t2.parentNode);
    let o2 = null;
    return t2 && t2 instanceof Element && (o2 = t2.closest(`.${m.CSS.editorZone}`)), o2 ? o2.nodeType === Node.ELEMENT_NODE : false;
  }
  /**
   * Methods return boolean that true if selection exists on the page
   */
  static get isSelectionExists() {
    return !!m.get().anchorNode;
  }
  /**
   * Return first range
   *
   * @returns {Range|null}
   */
  static get range() {
    return this.getRangeFromSelection(this.get());
  }
  /**
   * Returns range from passed Selection object
   *
   * @param selection - Selection object to get Range from
   */
  static getRangeFromSelection(e2) {
    return e2 && e2.rangeCount ? e2.getRangeAt(0) : null;
  }
  /**
   * Calculates position and size of selected text
   *
   * @returns {DOMRect | ClientRect}
   */
  static get rect() {
    let e2 = document.selection, t2, o2 = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
    if (e2 && e2.type !== "Control")
      return e2 = e2, t2 = e2.createRange(), o2.x = t2.boundingLeft, o2.y = t2.boundingTop, o2.width = t2.boundingWidth, o2.height = t2.boundingHeight, o2;
    if (!window.getSelection)
      return L("Method window.getSelection is not supported", "warn"), o2;
    if (e2 = window.getSelection(), e2.rangeCount === null || isNaN(e2.rangeCount))
      return L("Method SelectionUtils.rangeCount is not supported", "warn"), o2;
    if (e2.rangeCount === 0)
      return o2;
    if (t2 = e2.getRangeAt(0).cloneRange(), t2.getBoundingClientRect && (o2 = t2.getBoundingClientRect()), o2.x === 0 && o2.y === 0) {
      const i2 = document.createElement("span");
      if (i2.getBoundingClientRect) {
        i2.appendChild(document.createTextNode("​")), t2.insertNode(i2), o2 = i2.getBoundingClientRect();
        const n2 = i2.parentNode;
        n2.removeChild(i2), n2.normalize();
      }
    }
    return o2;
  }
  /**
   * Returns selected text as String
   *
   * @returns {string}
   */
  static get text() {
    return window.getSelection ? window.getSelection().toString() : "";
  }
  /**
   * Returns window SelectionUtils
   * {@link https://developer.mozilla.org/ru/docs/Web/API/Window/getSelection}
   *
   * @returns {Selection}
   */
  static get() {
    return window.getSelection();
  }
  /**
   * Set focus to contenteditable or native input element
   *
   * @param element - element where to set focus
   * @param offset - offset of cursor
   */
  static setCursor(e2, t2 = 0) {
    const o2 = document.createRange(), i2 = window.getSelection();
    return d.isNativeInput(e2) ? d.canSetCaret(e2) ? (e2.focus(), e2.selectionStart = e2.selectionEnd = t2, e2.getBoundingClientRect()) : void 0 : (o2.setStart(e2, t2), o2.setEnd(e2, t2), i2.removeAllRanges(), i2.addRange(o2), o2.getBoundingClientRect());
  }
  /**
   * Check if current range exists and belongs to container
   *
   * @param container - where range should be
   */
  static isRangeInsideContainer(e2) {
    const t2 = m.range;
    return t2 === null ? false : e2.contains(t2.startContainer);
  }
  /**
   * Adds fake cursor to the current range
   */
  static addFakeCursor() {
    const e2 = m.range;
    if (e2 === null)
      return;
    const t2 = d.make("span", "codex-editor__fake-cursor");
    t2.dataset.mutationFree = "true", e2.collapse(), e2.insertNode(t2);
  }
  /**
   * Check if passed element contains a fake cursor
   *
   * @param el - where to check
   */
  static isFakeCursorInsideContainer(e2) {
    return d.find(e2, ".codex-editor__fake-cursor") !== null;
  }
  /**
   * Removes fake cursor from a container
   *
   * @param container - container to look for
   */
  static removeFakeCursor(e2 = document.body) {
    const t2 = d.find(e2, ".codex-editor__fake-cursor");
    t2 && t2.remove();
  }
  /**
   * Removes fake background
   */
  removeFakeBackground() {
    this.isFakeBackgroundEnabled && (this.isFakeBackgroundEnabled = false, document.execCommand(this.commandRemoveFormat));
  }
  /**
   * Sets fake background
   */
  setFakeBackground() {
    document.execCommand(this.commandBackground, false, "#a8d6ff"), this.isFakeBackgroundEnabled = true;
  }
  /**
   * Save SelectionUtils's range
   */
  save() {
    this.savedSelectionRange = m.range;
  }
  /**
   * Restore saved SelectionUtils's range
   */
  restore() {
    if (!this.savedSelectionRange)
      return;
    const e2 = window.getSelection();
    e2.removeAllRanges(), e2.addRange(this.savedSelectionRange);
  }
  /**
   * Clears saved selection
   */
  clearSaved() {
    this.savedSelectionRange = null;
  }
  /**
   * Collapse current selection
   */
  collapseToEnd() {
    const e2 = window.getSelection(), t2 = document.createRange();
    t2.selectNodeContents(e2.focusNode), t2.collapse(false), e2.removeAllRanges(), e2.addRange(t2);
  }
  /**
   * Looks ahead to find passed tag from current selection
   *
   * @param  {string} tagName       - tag to found
   * @param  {string} [className]   - tag's class name
   * @param  {number} [searchDepth] - count of tags that can be included. For better performance.
   * @returns {HTMLElement|null}
   */
  findParentTag(e2, t2, o2 = 10) {
    const i2 = window.getSelection();
    let n2 = null;
    return !i2 || !i2.anchorNode || !i2.focusNode ? null : ([
      /** the Node in which the selection begins */
      i2.anchorNode,
      /** the Node in which the selection ends */
      i2.focusNode
    ].forEach((a2) => {
      let l2 = o2;
      for (; l2 > 0 && a2.parentNode && !(a2.tagName === e2 && (n2 = a2, t2 && a2.classList && !a2.classList.contains(t2) && (n2 = null), n2)); )
        a2 = a2.parentNode, l2--;
    }), n2);
  }
  /**
   * Expands selection range to the passed parent node
   *
   * @param {HTMLElement} element - element which contents should be selected
   */
  expandToTag(e2) {
    const t2 = window.getSelection();
    t2.removeAllRanges();
    const o2 = document.createRange();
    o2.selectNodeContents(e2), t2.addRange(o2);
  }
}
function Qt(s2, e2) {
  const { type: t2, target: o2, addedNodes: i2, removedNodes: n2 } = s2;
  if (o2 === e2)
    return true;
  if (["characterData", "attributes"].includes(t2)) {
    const l2 = o2.nodeType === Node.TEXT_NODE ? o2.parentNode : o2;
    return e2.contains(l2);
  }
  const r2 = Array.from(i2).some((l2) => e2.contains(l2)), a2 = Array.from(n2).some((l2) => e2.contains(l2));
  return r2 || a2;
}
const Oe = "redactor dom changed", ut = "block changed", pt = "fake cursor is about to be toggled", ft = "fake cursor have been set";
function tt(s2, e2) {
  return s2.mergeable && s2.name === e2.name;
}
function eo(s2, e2) {
  const t2 = e2 == null ? void 0 : e2.export;
  return D(t2) ? t2(s2) : Q(t2) ? s2[t2] : (t2 !== void 0 && L("Conversion «export» property must be a string or function. String means key of saved data object to export. Function should export processed string to export."), "");
}
function to(s2, e2) {
  const t2 = e2 == null ? void 0 : e2.import;
  return D(t2) ? t2(s2) : Q(t2) ? {
    [t2]: s2
  } : (t2 !== void 0 && L("Conversion «import» property must be a string or function. String means key of tool data to import. Function accepts a imported string and return composed tool data."), {});
}
var Z = /* @__PURE__ */ ((s2) => (s2.APPEND_CALLBACK = "appendCallback", s2.RENDERED = "rendered", s2.MOVED = "moved", s2.UPDATED = "updated", s2.REMOVED = "removed", s2.ON_PASTE = "onPaste", s2))(Z || {});
class F extends Ee {
  /**
   * @param options - block constructor options
   * @param [options.id] - block's id. Will be generated if omitted.
   * @param options.data - Tool's initial data
   * @param options.tool — block's tool
   * @param options.api - Editor API module for pass it to the Block Tunes
   * @param options.readOnly - Read-Only flag
   * @param [eventBus] - Editor common event bus. Allows to subscribe on some Editor events. Could be omitted when "virtual" Block is created. See BlocksAPI@composeBlockData.
   */
  constructor({
    id: e2 = Yt(),
    data: t2,
    tool: o2,
    api: i2,
    readOnly: n2,
    tunesData: r2
  }, a2) {
    super(), this.cachedInputs = [], this.toolRenderedElement = null, this.tunesInstances = /* @__PURE__ */ new Map(), this.defaultTunesInstances = /* @__PURE__ */ new Map(), this.unavailableTunesData = {}, this.inputIndex = 0, this.editorEventBus = null, this.handleFocus = () => {
      this.dropInputsCache(), this.updateCurrentInput();
    }, this.didMutated = (l2 = void 0) => {
      console.log("didMutated", l2);
      const c2 = l2 === void 0, u2 = l2 instanceof InputEvent;
      !c2 && !u2 && this.detectToolRootChange(l2);
      let h2;
      c2 || u2 ? h2 = true : h2 = !(l2.length > 0 && l2.every((k2) => {
        const { addedNodes: p2, removedNodes: v2, target: A2 } = k2;
        return [
          ...Array.from(p2),
          ...Array.from(v2),
          A2
        ].some((_2) => d.isElement(_2) ? _2.dataset.mutationFree === "true" : false);
      })), h2 && (this.dropInputsCache(), this.updateCurrentInput(), this.call(
        "updated"
        /* UPDATED */
      ), this.emit("didMutated", this));
    }, this.name = o2.name, this.id = e2, this.settings = o2.settings, this.config = o2.settings.config || {}, this.api = i2, this.editorEventBus = a2 || null, this.blockAPI = new te(this), this.tool = o2, this.toolInstance = o2.create(t2, this.blockAPI, n2), this.tunes = o2.tunes, this.composeTunes(r2), this.holder = this.compose(), window.requestIdleCallback(() => {
      this.watchBlockMutations(), this.addInputEvents();
    });
  }
  /**
   * CSS classes for the Block
   *
   * @returns {{wrapper: string, content: string}}
   */
  static get CSS() {
    return {
      wrapper: "ce-block",
      wrapperStretched: "ce-block--stretched",
      content: "ce-block__content",
      focused: "ce-block--focused",
      selected: "ce-block--selected",
      dropTarget: "ce-block--drop-target"
    };
  }
  /**
   * Find and return all editable elements (contenteditable and native inputs) in the Tool HTML
   *
   * @returns {HTMLElement[]}
   */
  get inputs() {
    if (this.cachedInputs.length !== 0)
      return this.cachedInputs;
    const e2 = d.findAllInputs(this.holder);
    return this.inputIndex > e2.length - 1 && (this.inputIndex = e2.length - 1), this.cachedInputs = e2, e2;
  }
  /**
   * Return current Tool`s input
   *
   * @returns {HTMLElement}
   */
  get currentInput() {
    return this.inputs[this.inputIndex];
  }
  /**
   * Set input index to the passed element
   *
   * @param {HTMLElement | Node} element - HTML Element to set as current input
   */
  set currentInput(e2) {
    const t2 = this.inputs.findIndex((o2) => o2 === e2 || o2.contains(e2));
    t2 !== -1 && (this.inputIndex = t2);
  }
  /**
   * Return first Tool`s input
   *
   * @returns {HTMLElement}
   */
  get firstInput() {
    return this.inputs[0];
  }
  /**
   * Return first Tool`s input
   *
   * @returns {HTMLElement}
   */
  get lastInput() {
    const e2 = this.inputs;
    return e2[e2.length - 1];
  }
  /**
   * Return next Tool`s input or undefined if it doesn't exist
   *
   * @returns {HTMLElement}
   */
  get nextInput() {
    return this.inputs[this.inputIndex + 1];
  }
  /**
   * Return previous Tool`s input or undefined if it doesn't exist
   *
   * @returns {HTMLElement}
   */
  get previousInput() {
    return this.inputs[this.inputIndex - 1];
  }
  /**
   * Get Block's JSON data
   *
   * @returns {object}
   */
  get data() {
    return this.save().then((e2) => e2 && !q(e2.data) ? e2.data : {});
  }
  /**
   * Returns tool's sanitizer config
   *
   * @returns {object}
   */
  get sanitize() {
    return this.tool.sanitizeConfig;
  }
  /**
   * is block mergeable
   * We plugin have merge function then we call it mergeable
   *
   * @returns {boolean}
   */
  get mergeable() {
    return D(this.toolInstance.merge);
  }
  /**
   * Check block for emptiness
   *
   * @returns {boolean}
   */
  get isEmpty() {
    const e2 = d.isEmpty(this.pluginsContent), t2 = !this.hasMedia;
    return e2 && t2;
  }
  /**
   * Check if block has a media content such as images, iframe and other
   *
   * @returns {boolean}
   */
  get hasMedia() {
    const e2 = [
      "img",
      "iframe",
      "video",
      "audio",
      "source",
      "input",
      "textarea",
      "twitterwidget"
    ];
    return !!this.holder.querySelector(e2.join(","));
  }
  /**
   * Set focused state
   *
   * @param {boolean} state - 'true' to select, 'false' to remove selection
   */
  set focused(e2) {
    this.holder.classList.toggle(F.CSS.focused, e2);
  }
  /**
   * Get Block's focused state
   */
  get focused() {
    return this.holder.classList.contains(F.CSS.focused);
  }
  /**
   * Set selected state
   * We don't need to mark Block as Selected when it is empty
   *
   * @param {boolean} state - 'true' to select, 'false' to remove selection
   */
  set selected(e2) {
    var i2, n2;
    this.holder.classList.toggle(F.CSS.selected, e2);
    const t2 = e2 === true && m.isRangeInsideContainer(this.holder), o2 = e2 === false && m.isFakeCursorInsideContainer(this.holder);
    (t2 || o2) && ((i2 = this.editorEventBus) == null || i2.emit(pt, { state: e2 }), t2 ? m.addFakeCursor() : m.removeFakeCursor(this.holder), (n2 = this.editorEventBus) == null || n2.emit(ft, { state: e2 }));
  }
  /**
   * Returns True if it is Selected
   *
   * @returns {boolean}
   */
  get selected() {
    return this.holder.classList.contains(F.CSS.selected);
  }
  /**
   * Set stretched state
   *
   * @param {boolean} state - 'true' to enable, 'false' to disable stretched state
   */
  set stretched(e2) {
    this.holder.classList.toggle(F.CSS.wrapperStretched, e2);
  }
  /**
   * Return Block's stretched state
   *
   * @returns {boolean}
   */
  get stretched() {
    return this.holder.classList.contains(F.CSS.wrapperStretched);
  }
  /**
   * Toggle drop target state
   *
   * @param {boolean} state - 'true' if block is drop target, false otherwise
   */
  set dropTarget(e2) {
    this.holder.classList.toggle(F.CSS.dropTarget, e2);
  }
  /**
   * Returns Plugins content
   *
   * @returns {HTMLElement}
   */
  get pluginsContent() {
    return this.toolRenderedElement;
  }
  /**
   * Calls Tool's method
   *
   * Method checks tool property {MethodName}. Fires method with passes params If it is instance of Function
   *
   * @param {string} methodName - method to call
   * @param {object} params - method argument
   */
  call(e2, t2) {
    if (D(this.toolInstance[e2])) {
      e2 === "appendCallback" && L(
        "`appendCallback` hook is deprecated and will be removed in the next major release. Use `rendered` hook instead",
        "warn"
      );
      try {
        this.toolInstance[e2].call(this.toolInstance, t2);
      } catch (o2) {
        L(`Error during '${e2}' call: ${o2.message}`, "error");
      }
    }
  }
  /**
   * Call plugins merge method
   *
   * @param {BlockToolData} data - data to merge
   */
  async mergeWith(e2) {
    await this.toolInstance.merge(e2);
  }
  /**
   * Extracts data from Block
   * Groups Tool's save processing time
   *
   * @returns {object}
   */
  async save() {
    const e2 = await this.toolInstance.save(this.pluginsContent), t2 = this.unavailableTunesData;
    [
      ...this.tunesInstances.entries(),
      ...this.defaultTunesInstances.entries()
    ].forEach(([n2, r2]) => {
      if (D(r2.save))
        try {
          t2[n2] = r2.save();
        } catch (a2) {
          L(`Tune ${r2.constructor.name} save method throws an Error %o`, "warn", a2);
        }
    });
    const o2 = window.performance.now();
    let i2;
    return Promise.resolve(e2).then((n2) => (i2 = window.performance.now(), {
      id: this.id,
      tool: this.name,
      data: n2,
      tunes: t2,
      time: i2 - o2
    })).catch((n2) => {
      L(`Saving process for ${this.name} tool failed due to the ${n2}`, "log", "red");
    });
  }
  /**
   * Uses Tool's validation method to check the correctness of output data
   * Tool's validation method is optional
   *
   * @description Method returns true|false whether data passed the validation or not
   * @param {BlockToolData} data - data to validate
   * @returns {Promise<boolean>} valid
   */
  async validate(e2) {
    let t2 = true;
    return this.toolInstance.validate instanceof Function && (t2 = await this.toolInstance.validate(e2)), t2;
  }
  /**
   * Returns data to render in tunes menu.
   * Splits block tunes settings into 2 groups: popover items and custom html.
   */
  getTunes() {
    const e2 = document.createElement("div"), t2 = [], o2 = typeof this.toolInstance.renderSettings == "function" ? this.toolInstance.renderSettings() : [], i2 = [
      ...this.tunesInstances.values(),
      ...this.defaultTunesInstances.values()
    ].map((n2) => n2.render());
    return [o2, i2].flat().forEach((n2) => {
      d.isElement(n2) ? e2.appendChild(n2) : Array.isArray(n2) ? t2.push(...n2) : t2.push(n2);
    }), [t2, e2];
  }
  /**
   * Update current input index with selection anchor node
   */
  updateCurrentInput() {
    this.currentInput = d.isNativeInput(document.activeElement) || !m.anchorNode ? document.activeElement : m.anchorNode;
  }
  /**
   * Allows to say Editor that Block was changed. Used to manually trigger Editor's 'onChange' callback
   * Can be useful for block changes invisible for editor core.
   */
  dispatchChange() {
    this.didMutated();
  }
  /**
   * Call Tool instance destroy method
   */
  destroy() {
    this.unwatchBlockMutations(), this.removeInputEvents(), super.destroy(), D(this.toolInstance.destroy) && this.toolInstance.destroy();
  }
  /**
   * Tool could specify several entries to be displayed at the Toolbox (for example, "Heading 1", "Heading 2", "Heading 3")
   * This method returns the entry that is related to the Block (depended on the Block data)
   */
  async getActiveToolboxEntry() {
    const e2 = this.tool.toolbox;
    if (e2.length === 1)
      return Promise.resolve(this.tool.toolbox[0]);
    const t2 = await this.data;
    return e2.find((i2) => Object.entries(i2.data).some(([n2, r2]) => t2[n2] && Vt(t2[n2], r2)));
  }
  /**
   * Exports Block data as string using conversion config
   */
  async exportDataAsString() {
    const e2 = await this.data;
    return eo(e2, this.tool.conversionConfig);
  }
  /**
   * Make default Block wrappers and put Tool`s content there
   *
   * @returns {HTMLDivElement}
   */
  compose() {
    const e2 = d.make("div", F.CSS.wrapper), t2 = d.make("div", F.CSS.content), o2 = this.toolInstance.render();
    e2.dataset.id = this.id, this.toolRenderedElement = o2, t2.appendChild(this.toolRenderedElement);
    let i2 = t2;
    return [...this.tunesInstances.values(), ...this.defaultTunesInstances.values()].forEach((n2) => {
      if (D(n2.wrap))
        try {
          i2 = n2.wrap(i2);
        } catch (r2) {
          L(`Tune ${n2.constructor.name} wrap method throws an Error %o`, "warn", r2);
        }
    }), e2.appendChild(i2), e2;
  }
  /**
   * Instantiate Block Tunes
   *
   * @param tunesData - current Block tunes data
   * @private
   */
  composeTunes(e2) {
    Array.from(this.tunes.values()).forEach((t2) => {
      (t2.isInternal ? this.defaultTunesInstances : this.tunesInstances).set(t2.name, t2.create(e2[t2.name], this.blockAPI));
    }), Object.entries(e2).forEach(([t2, o2]) => {
      this.tunesInstances.has(t2) || (this.unavailableTunesData[t2] = o2);
    });
  }
  /**
   * Adds focus event listeners to all inputs and contenteditable
   */
  addInputEvents() {
    this.inputs.forEach((e2) => {
      e2.addEventListener("focus", this.handleFocus), d.isNativeInput(e2) && e2.addEventListener("input", this.didMutated);
    });
  }
  /**
   * removes focus event listeners from all inputs and contenteditable
   */
  removeInputEvents() {
    this.inputs.forEach((e2) => {
      e2.removeEventListener("focus", this.handleFocus), d.isNativeInput(e2) && e2.removeEventListener("input", this.didMutated);
    });
  }
  /**
   * Listen common editor Dom Changed event and detect mutations related to the  Block
   */
  watchBlockMutations() {
    var e2;
    this.redactorDomChangedCallback = (t2) => {
      const { mutations: o2 } = t2, i2 = o2.some((n2) => Qt(n2, this.toolRenderedElement));
      this.name === "header" && console.log("mutationBelongsToBlock", i2, o2), i2 && this.didMutated(o2);
    }, (e2 = this.editorEventBus) == null || e2.on(Oe, this.redactorDomChangedCallback);
  }
  /**
   * Remove redactor dom change event listener
   */
  unwatchBlockMutations() {
    var e2;
    (e2 = this.editorEventBus) == null || e2.off(Oe, this.redactorDomChangedCallback);
  }
  /**
   * Sometimes Tool can replace own main element, for example H2 -> H4 or UL -> OL
   * We need to detect such changes and update a link to tools main element with the new one
   *
   * @param mutations - records of block content mutations
   */
  detectToolRootChange(e2) {
    e2.forEach((t2) => {
      if (Array.from(t2.removedNodes).includes(this.toolRenderedElement)) {
        const i2 = t2.addedNodes[t2.addedNodes.length - 1];
        this.toolRenderedElement = i2;
      }
    });
  }
  /**
   * Clears inputs cached value
   */
  dropInputsCache() {
    this.cachedInputs = [];
  }
}
class oo extends T {
  constructor() {
    super(...arguments), this.insert = (e2 = this.config.defaultBlock, t2 = {}, o2 = {}, i2, n2, r2, a2) => {
      const l2 = this.Editor.BlockManager.insert({
        id: a2,
        tool: e2,
        data: t2,
        index: i2,
        needToFocus: n2,
        replace: r2
      });
      return new te(l2);
    }, this.composeBlockData = async (e2) => {
      const t2 = this.Editor.Tools.blockTools.get(e2);
      return new F({
        tool: t2,
        api: this.Editor.API,
        readOnly: true,
        data: {},
        tunesData: {}
      }).data;
    }, this.update = async (e2, t2) => {
      const { BlockManager: o2 } = this.Editor, i2 = o2.getBlockById(e2);
      if (i2 === void 0)
        throw new Error(`Block with id "${e2}" not found`);
      const n2 = await o2.update(i2, t2);
      return new te(n2);
    }, this.convert = (e2, t2, o2) => {
      var h2, f2;
      const { BlockManager: i2, Tools: n2 } = this.Editor, r2 = i2.getBlockById(e2);
      if (!r2)
        throw new Error(`Block with id "${e2}" not found`);
      const a2 = n2.blockTools.get(r2.name), l2 = n2.blockTools.get(t2);
      if (!l2)
        throw new Error(`Block Tool with type "${t2}" not found`);
      const c2 = ((h2 = a2 == null ? void 0 : a2.conversionConfig) == null ? void 0 : h2.export) !== void 0, u2 = ((f2 = l2.conversionConfig) == null ? void 0 : f2.import) !== void 0;
      if (c2 && u2)
        i2.convert(r2, t2, o2);
      else {
        const k2 = [
          c2 ? false : ae(r2.name),
          u2 ? false : ae(t2)
        ].filter(Boolean).join(" and ");
        throw new Error(`Conversion from "${r2.name}" to "${t2}" is not possible. ${k2} tool(s) should provide a "conversionConfig"`);
      }
    }, this.insertMany = (e2, t2 = this.Editor.BlockManager.blocks.length - 1) => {
      this.validateIndex(t2);
      const o2 = e2.map(({ id: i2, type: n2, data: r2 }) => this.Editor.BlockManager.composeBlock({
        id: i2,
        tool: n2 || this.config.defaultBlock,
        data: r2
      }));
      return this.Editor.BlockManager.insertMany(o2, t2), o2.map((i2) => new te(i2));
    };
  }
  /**
   * Available methods
   *
   * @returns {Blocks}
   */
  get methods() {
    return {
      clear: () => this.clear(),
      render: (e2) => this.render(e2),
      renderFromHTML: (e2) => this.renderFromHTML(e2),
      delete: (e2) => this.delete(e2),
      swap: (e2, t2) => this.swap(e2, t2),
      move: (e2, t2) => this.move(e2, t2),
      getBlockByIndex: (e2) => this.getBlockByIndex(e2),
      getById: (e2) => this.getById(e2),
      getCurrentBlockIndex: () => this.getCurrentBlockIndex(),
      getBlockIndex: (e2) => this.getBlockIndex(e2),
      getBlocksCount: () => this.getBlocksCount(),
      stretchBlock: (e2, t2 = true) => this.stretchBlock(e2, t2),
      insertNewBlock: () => this.insertNewBlock(),
      insert: this.insert,
      insertMany: this.insertMany,
      update: this.update,
      composeBlockData: this.composeBlockData,
      convert: this.convert
    };
  }
  /**
   * Returns Blocks count
   *
   * @returns {number}
   */
  getBlocksCount() {
    return this.Editor.BlockManager.blocks.length;
  }
  /**
   * Returns current block index
   *
   * @returns {number}
   */
  getCurrentBlockIndex() {
    return this.Editor.BlockManager.currentBlockIndex;
  }
  /**
   * Returns the index of Block by id;
   *
   * @param id - block id
   */
  getBlockIndex(e2) {
    const t2 = this.Editor.BlockManager.getBlockById(e2);
    if (!t2) {
      X("There is no block with id `" + e2 + "`", "warn");
      return;
    }
    return this.Editor.BlockManager.getBlockIndex(t2);
  }
  /**
   * Returns BlockAPI object by Block index
   *
   * @param {number} index - index to get
   */
  getBlockByIndex(e2) {
    const t2 = this.Editor.BlockManager.getBlockByIndex(e2);
    if (t2 === void 0) {
      X("There is no block at index `" + e2 + "`", "warn");
      return;
    }
    return new te(t2);
  }
  /**
   * Returns BlockAPI object by Block id
   *
   * @param id - id of block to get
   */
  getById(e2) {
    const t2 = this.Editor.BlockManager.getBlockById(e2);
    return t2 === void 0 ? (X("There is no block with id `" + e2 + "`", "warn"), null) : new te(t2);
  }
  /**
   * Call Block Manager method that swap Blocks
   *
   * @param {number} fromIndex - position of first Block
   * @param {number} toIndex - position of second Block
   * @deprecated — use 'move' instead
   */
  swap(e2, t2) {
    L(
      "`blocks.swap()` method is deprecated and will be removed in the next major release. Use `block.move()` method instead",
      "info"
    ), this.Editor.BlockManager.swap(e2, t2);
  }
  /**
   * Move block from one index to another
   *
   * @param {number} toIndex - index to move to
   * @param {number} fromIndex - index to move from
   */
  move(e2, t2) {
    this.Editor.BlockManager.move(e2, t2);
  }
  /**
   * Deletes Block
   *
   * @param {number} blockIndex - index of Block to delete
   */
  delete(e2 = this.Editor.BlockManager.currentBlockIndex) {
    try {
      const t2 = this.Editor.BlockManager.getBlockByIndex(e2);
      this.Editor.BlockManager.removeBlock(t2);
    } catch (t2) {
      X(t2, "warn");
      return;
    }
    this.Editor.BlockManager.blocks.length === 0 && this.Editor.BlockManager.insert(), this.Editor.BlockManager.currentBlock && this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock, this.Editor.Caret.positions.END), this.Editor.Toolbar.close();
  }
  /**
   * Clear Editor's area
   */
  async clear() {
    await this.Editor.BlockManager.clear(true), this.Editor.InlineToolbar.close();
  }
  /**
   * Fills Editor with Blocks data
   *
   * @param {OutputData} data — Saved Editor data
   */
  async render(e2) {
    if (e2 === void 0 || e2.blocks === void 0)
      throw new Error("Incorrect data passed to the render() method");
    this.Editor.ModificationsObserver.disable(), await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(e2.blocks), this.Editor.ModificationsObserver.enable();
  }
  /**
   * Render passed HTML string
   *
   * @param {string} data - HTML string to render
   * @returns {Promise<void>}
   */
  renderFromHTML(e2) {
    return this.Editor.BlockManager.clear(), this.Editor.Paste.processText(e2, true);
  }
  /**
   * Stretch Block's content
   *
   * @param {number} index - index of Block to stretch
   * @param {boolean} status - true to enable, false to disable
   * @deprecated Use BlockAPI interface to stretch Blocks
   */
  stretchBlock(e2, t2 = true) {
    Le(
      true,
      "blocks.stretchBlock()",
      "BlockAPI"
    );
    const o2 = this.Editor.BlockManager.getBlockByIndex(e2);
    o2 && (o2.stretched = t2);
  }
  /**
   * Insert new Block
   * After set caret to this Block
   *
   * @todo remove in 3.0.0
   * @deprecated with insert() method
   */
  insertNewBlock() {
    L("Method blocks.insertNewBlock() is deprecated and it will be removed in the next major release. Use blocks.insert() instead.", "warn"), this.insert();
  }
  /**
   * Validated block index and throws an error if it's invalid
   *
   * @param index - index to validate
   */
  validateIndex(e2) {
    if (typeof e2 != "number")
      throw new Error("Index should be a number");
    if (e2 < 0)
      throw new Error("Index should be greater than or equal to 0");
    if (e2 === null)
      throw new Error("Index should be greater than or equal to 0");
  }
}
class io extends T {
  constructor() {
    super(...arguments), this.setToFirstBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.firstBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.firstBlock, e2, t2), true) : false, this.setToLastBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.lastBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.lastBlock, e2, t2), true) : false, this.setToPreviousBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.previousBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.previousBlock, e2, t2), true) : false, this.setToNextBlock = (e2 = this.Editor.Caret.positions.DEFAULT, t2 = 0) => this.Editor.BlockManager.nextBlock ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.nextBlock, e2, t2), true) : false, this.setToBlock = (e2, t2 = this.Editor.Caret.positions.DEFAULT, o2 = 0) => this.Editor.BlockManager.blocks[e2] ? (this.Editor.Caret.setToBlock(this.Editor.BlockManager.blocks[e2], t2, o2), true) : false, this.focus = (e2 = false) => e2 ? this.setToLastBlock(this.Editor.Caret.positions.END) : this.setToFirstBlock(this.Editor.Caret.positions.START);
  }
  /**
   * Available methods
   *
   * @returns {Caret}
   */
  get methods() {
    return {
      setToFirstBlock: this.setToFirstBlock,
      setToLastBlock: this.setToLastBlock,
      setToPreviousBlock: this.setToPreviousBlock,
      setToNextBlock: this.setToNextBlock,
      setToBlock: this.setToBlock,
      focus: this.focus
    };
  }
}
class no extends T {
  /**
   * Available methods
   *
   * @returns {Events}
   */
  get methods() {
    return {
      emit: (e2, t2) => this.emit(e2, t2),
      off: (e2, t2) => this.off(e2, t2),
      on: (e2, t2) => this.on(e2, t2)
    };
  }
  /**
   * Subscribe on Events
   *
   * @param {string} eventName - event name to subscribe
   * @param {Function} callback - event handler
   */
  on(e2, t2) {
    this.eventsDispatcher.on(e2, t2);
  }
  /**
   * Emit event with data
   *
   * @param {string} eventName - event to emit
   * @param {object} data - event's data
   */
  emit(e2, t2) {
    this.eventsDispatcher.emit(e2, t2);
  }
  /**
   * Unsubscribe from Event
   *
   * @param {string} eventName - event to unsubscribe
   * @param {Function} callback - event handler
   */
  off(e2, t2) {
    this.eventsDispatcher.off(e2, t2);
  }
}
class je extends T {
  /**
   * Return namespace section for tool or block tune
   *
   * @param tool - tool object
   */
  static getNamespace(e2) {
    return e2.isTune() ? `blockTunes.${e2.name}` : `tools.${e2.name}`;
  }
  /**
   * Return I18n API methods with global dictionary access
   */
  get methods() {
    return {
      t: () => {
        X("I18n.t() method can be accessed only from Tools", "warn");
      }
    };
  }
  /**
   * Return I18n API methods with tool namespaced dictionary
   *
   * @param tool - Tool object
   */
  getMethodsForTool(e2) {
    return Object.assign(
      this.methods,
      {
        t: (t2) => W.t(je.getNamespace(e2), t2)
      }
    );
  }
}
class so extends T {
  /**
   * Editor.js Core API modules
   */
  get methods() {
    return {
      blocks: this.Editor.BlocksAPI.methods,
      caret: this.Editor.CaretAPI.methods,
      events: this.Editor.EventsAPI.methods,
      listeners: this.Editor.ListenersAPI.methods,
      notifier: this.Editor.NotifierAPI.methods,
      sanitizer: this.Editor.SanitizerAPI.methods,
      saver: this.Editor.SaverAPI.methods,
      selection: this.Editor.SelectionAPI.methods,
      styles: this.Editor.StylesAPI.classes,
      toolbar: this.Editor.ToolbarAPI.methods,
      inlineToolbar: this.Editor.InlineToolbarAPI.methods,
      tooltip: this.Editor.TooltipAPI.methods,
      i18n: this.Editor.I18nAPI.methods,
      readOnly: this.Editor.ReadOnlyAPI.methods,
      ui: this.Editor.UiAPI.methods
    };
  }
  /**
   * Returns Editor.js Core API methods for passed tool
   *
   * @param tool - tool object
   */
  getMethodsForTool(e2) {
    return Object.assign(
      this.methods,
      {
        i18n: this.Editor.I18nAPI.getMethodsForTool(e2)
      }
    );
  }
}
class ro extends T {
  /**
   * Available methods
   *
   * @returns {InlineToolbar}
   */
  get methods() {
    return {
      close: () => this.close(),
      open: () => this.open()
    };
  }
  /**
   * Open Inline Toolbar
   */
  open() {
    this.Editor.InlineToolbar.tryToShow();
  }
  /**
   * Close Inline Toolbar
   */
  close() {
    this.Editor.InlineToolbar.close();
  }
}
class ao extends T {
  /**
   * Available methods
   *
   * @returns {Listeners}
   */
  get methods() {
    return {
      on: (e2, t2, o2, i2) => this.on(e2, t2, o2, i2),
      off: (e2, t2, o2, i2) => this.off(e2, t2, o2, i2),
      offById: (e2) => this.offById(e2)
    };
  }
  /**
   * Ads a DOM event listener. Return it's id.
   *
   * @param {HTMLElement} element - Element to set handler to
   * @param {string} eventType - event type
   * @param {() => void} handler - event handler
   * @param {boolean} useCapture - capture event or not
   */
  on(e2, t2, o2, i2) {
    return this.listeners.on(e2, t2, o2, i2);
  }
  /**
   * Removes DOM listener from element
   *
   * @param {Element} element - Element to remove handler from
   * @param eventType - event type
   * @param handler - event handler
   * @param {boolean} useCapture - capture event or not
   */
  off(e2, t2, o2, i2) {
    this.listeners.off(e2, t2, o2, i2);
  }
  /**
   * Removes DOM listener by the listener id
   *
   * @param id - id of the listener to remove
   */
  offById(e2) {
    this.listeners.offById(e2);
  }
}
var Ae = {}, lo = {
  get exports() {
    return Ae;
  },
  set exports(s2) {
    Ae = s2;
  }
};
(function(s2, e2) {
  (function(t2, o2) {
    s2.exports = o2();
  })(window, function() {
    return function(t2) {
      var o2 = {};
      function i2(n2) {
        if (o2[n2])
          return o2[n2].exports;
        var r2 = o2[n2] = { i: n2, l: false, exports: {} };
        return t2[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
      }
      return i2.m = t2, i2.c = o2, i2.d = function(n2, r2, a2) {
        i2.o(n2, r2) || Object.defineProperty(n2, r2, { enumerable: true, get: a2 });
      }, i2.r = function(n2) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
      }, i2.t = function(n2, r2) {
        if (1 & r2 && (n2 = i2(n2)), 8 & r2 || 4 & r2 && typeof n2 == "object" && n2 && n2.__esModule)
          return n2;
        var a2 = /* @__PURE__ */ Object.create(null);
        if (i2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: n2 }), 2 & r2 && typeof n2 != "string")
          for (var l2 in n2)
            i2.d(a2, l2, (function(c2) {
              return n2[c2];
            }).bind(null, l2));
        return a2;
      }, i2.n = function(n2) {
        var r2 = n2 && n2.__esModule ? function() {
          return n2.default;
        } : function() {
          return n2;
        };
        return i2.d(r2, "a", r2), r2;
      }, i2.o = function(n2, r2) {
        return Object.prototype.hasOwnProperty.call(n2, r2);
      }, i2.p = "/", i2(i2.s = 0);
    }([function(t2, o2, i2) {
      i2(1), /*!
      * Codex JavaScript Notification module
      * https://github.com/codex-team/js-notifier
      */
      t2.exports = function() {
        var n2 = i2(6), r2 = "cdx-notify--bounce-in", a2 = null;
        return { show: function(l2) {
          if (l2.message) {
            (function() {
              if (a2)
                return true;
              a2 = n2.getWrapper(), document.body.appendChild(a2);
            })();
            var c2 = null, u2 = l2.time || 8e3;
            switch (l2.type) {
              case "confirm":
                c2 = n2.confirm(l2);
                break;
              case "prompt":
                c2 = n2.prompt(l2);
                break;
              default:
                c2 = n2.alert(l2), window.setTimeout(function() {
                  c2.remove();
                }, u2);
            }
            a2.appendChild(c2), c2.classList.add(r2);
          }
        } };
      }();
    }, function(t2, o2, i2) {
      var n2 = i2(2);
      typeof n2 == "string" && (n2 = [[t2.i, n2, ""]]);
      var r2 = { hmr: true, transform: void 0, insertInto: void 0 };
      i2(4)(n2, r2), n2.locals && (t2.exports = n2.locals);
    }, function(t2, o2, i2) {
      (t2.exports = i2(3)(false)).push([t2.i, `.cdx-notify--error{background:#fffbfb!important}.cdx-notify--error::before{background:#fb5d5d!important}.cdx-notify__input{max-width:130px;padding:5px 10px;background:#f7f7f7;border:0;border-radius:3px;font-size:13px;color:#656b7c;outline:0}.cdx-notify__input:-ms-input-placeholder{color:#656b7c}.cdx-notify__input::placeholder{color:#656b7c}.cdx-notify__input:focus:-ms-input-placeholder{color:rgba(101,107,124,.3)}.cdx-notify__input:focus::placeholder{color:rgba(101,107,124,.3)}.cdx-notify__button{border:none;border-radius:3px;font-size:13px;padding:5px 10px;cursor:pointer}.cdx-notify__button:last-child{margin-left:10px}.cdx-notify__button--cancel{background:#f2f5f7;box-shadow:0 2px 1px 0 rgba(16,19,29,0);color:#656b7c}.cdx-notify__button--cancel:hover{background:#eee}.cdx-notify__button--confirm{background:#34c992;box-shadow:0 1px 1px 0 rgba(18,49,35,.05);color:#fff}.cdx-notify__button--confirm:hover{background:#33b082}.cdx-notify__btns-wrapper{display:-ms-flexbox;display:flex;-ms-flex-flow:row nowrap;flex-flow:row nowrap;margin-top:5px}.cdx-notify__cross{position:absolute;top:5px;right:5px;width:10px;height:10px;padding:5px;opacity:.54;cursor:pointer}.cdx-notify__cross::after,.cdx-notify__cross::before{content:'';position:absolute;left:9px;top:5px;height:12px;width:2px;background:#575d67}.cdx-notify__cross::before{transform:rotate(-45deg)}.cdx-notify__cross::after{transform:rotate(45deg)}.cdx-notify__cross:hover{opacity:1}.cdx-notifies{position:fixed;z-index:2;bottom:20px;left:20px;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Fira Sans","Droid Sans","Helvetica Neue",sans-serif}.cdx-notify{position:relative;width:220px;margin-top:15px;padding:13px 16px;background:#fff;box-shadow:0 11px 17px 0 rgba(23,32,61,.13);border-radius:5px;font-size:14px;line-height:1.4em;word-wrap:break-word}.cdx-notify::before{content:'';position:absolute;display:block;top:0;left:0;width:3px;height:calc(100% - 6px);margin:3px;border-radius:5px;background:0 0}@keyframes bounceIn{0%{opacity:0;transform:scale(.3)}50%{opacity:1;transform:scale(1.05)}70%{transform:scale(.9)}100%{transform:scale(1)}}.cdx-notify--bounce-in{animation-name:bounceIn;animation-duration:.6s;animation-iteration-count:1}.cdx-notify--success{background:#fafffe!important}.cdx-notify--success::before{background:#41ffb1!important}`, ""]);
    }, function(t2, o2) {
      t2.exports = function(i2) {
        var n2 = [];
        return n2.toString = function() {
          return this.map(function(r2) {
            var a2 = function(l2, c2) {
              var u2 = l2[1] || "", h2 = l2[3];
              if (!h2)
                return u2;
              if (c2 && typeof btoa == "function") {
                var f2 = (p2 = h2, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(p2)))) + " */"), k2 = h2.sources.map(function(v2) {
                  return "/*# sourceURL=" + h2.sourceRoot + v2 + " */";
                });
                return [u2].concat(k2).concat([f2]).join(`
`);
              }
              var p2;
              return [u2].join(`
`);
            }(r2, i2);
            return r2[2] ? "@media " + r2[2] + "{" + a2 + "}" : a2;
          }).join("");
        }, n2.i = function(r2, a2) {
          typeof r2 == "string" && (r2 = [[null, r2, ""]]);
          for (var l2 = {}, c2 = 0; c2 < this.length; c2++) {
            var u2 = this[c2][0];
            typeof u2 == "number" && (l2[u2] = true);
          }
          for (c2 = 0; c2 < r2.length; c2++) {
            var h2 = r2[c2];
            typeof h2[0] == "number" && l2[h2[0]] || (a2 && !h2[2] ? h2[2] = a2 : a2 && (h2[2] = "(" + h2[2] + ") and (" + a2 + ")"), n2.push(h2));
          }
        }, n2;
      };
    }, function(t2, o2, i2) {
      var n2, r2, a2 = {}, l2 = (n2 = function() {
        return window && document && document.all && !window.atob;
      }, function() {
        return r2 === void 0 && (r2 = n2.apply(this, arguments)), r2;
      }), c2 = function(b2) {
        var g2 = {};
        return function(E2) {
          if (typeof E2 == "function")
            return E2();
          if (g2[E2] === void 0) {
            var C2 = (function(O2) {
              return document.querySelector(O2);
            }).call(this, E2);
            if (window.HTMLIFrameElement && C2 instanceof window.HTMLIFrameElement)
              try {
                C2 = C2.contentDocument.head;
              } catch {
                C2 = null;
              }
            g2[E2] = C2;
          }
          return g2[E2];
        };
      }(), u2 = null, h2 = 0, f2 = [], k2 = i2(5);
      function p2(b2, g2) {
        for (var E2 = 0; E2 < b2.length; E2++) {
          var C2 = b2[E2], O2 = a2[C2.id];
          if (O2) {
            O2.refs++;
            for (var S2 = 0; S2 < O2.parts.length; S2++)
              O2.parts[S2](C2.parts[S2]);
            for (; S2 < C2.parts.length; S2++)
              O2.parts.push(x2(C2.parts[S2], g2));
          } else {
            var H2 = [];
            for (S2 = 0; S2 < C2.parts.length; S2++)
              H2.push(x2(C2.parts[S2], g2));
            a2[C2.id] = { id: C2.id, refs: 1, parts: H2 };
          }
        }
      }
      function v2(b2, g2) {
        for (var E2 = [], C2 = {}, O2 = 0; O2 < b2.length; O2++) {
          var S2 = b2[O2], H2 = g2.base ? S2[0] + g2.base : S2[0], M2 = { css: S2[1], media: S2[2], sourceMap: S2[3] };
          C2[H2] ? C2[H2].parts.push(M2) : E2.push(C2[H2] = { id: H2, parts: [M2] });
        }
        return E2;
      }
      function A2(b2, g2) {
        var E2 = c2(b2.insertInto);
        if (!E2)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        var C2 = f2[f2.length - 1];
        if (b2.insertAt === "top")
          C2 ? C2.nextSibling ? E2.insertBefore(g2, C2.nextSibling) : E2.appendChild(g2) : E2.insertBefore(g2, E2.firstChild), f2.push(g2);
        else if (b2.insertAt === "bottom")
          E2.appendChild(g2);
        else {
          if (typeof b2.insertAt != "object" || !b2.insertAt.before)
            throw new Error(`[Style Loader]

 Invalid value for parameter 'insertAt' ('options.insertAt') found.
 Must be 'top', 'bottom', or Object.
 (https://github.com/webpack-contrib/style-loader#insertat)
`);
          var O2 = c2(b2.insertInto + " " + b2.insertAt.before);
          E2.insertBefore(g2, O2);
        }
      }
      function N2(b2) {
        if (b2.parentNode === null)
          return false;
        b2.parentNode.removeChild(b2);
        var g2 = f2.indexOf(b2);
        g2 >= 0 && f2.splice(g2, 1);
      }
      function _2(b2) {
        var g2 = document.createElement("style");
        return b2.attrs.type === void 0 && (b2.attrs.type = "text/css"), y2(g2, b2.attrs), A2(b2, g2), g2;
      }
      function y2(b2, g2) {
        Object.keys(g2).forEach(function(E2) {
          b2.setAttribute(E2, g2[E2]);
        });
      }
      function x2(b2, g2) {
        var E2, C2, O2, S2;
        if (g2.transform && b2.css) {
          if (!(S2 = g2.transform(b2.css)))
            return function() {
            };
          b2.css = S2;
        }
        if (g2.singleton) {
          var H2 = h2++;
          E2 = u2 || (u2 = _2(g2)), C2 = R2.bind(null, E2, H2, false), O2 = R2.bind(null, E2, H2, true);
        } else
          b2.sourceMap && typeof URL == "function" && typeof URL.createObjectURL == "function" && typeof URL.revokeObjectURL == "function" && typeof Blob == "function" && typeof btoa == "function" ? (E2 = function(M2) {
            var Y2 = document.createElement("link");
            return M2.attrs.type === void 0 && (M2.attrs.type = "text/css"), M2.attrs.rel = "stylesheet", y2(Y2, M2.attrs), A2(M2, Y2), Y2;
          }(g2), C2 = (function(M2, Y2, de2) {
            var ee2 = de2.css, Ce2 = de2.sourceMap, At = Y2.convertToAbsoluteUrls === void 0 && Ce2;
            (Y2.convertToAbsoluteUrls || At) && (ee2 = k2(ee2)), Ce2 && (ee2 += `
/*# sourceMappingURL=data:application/json;base64,` + btoa(unescape(encodeURIComponent(JSON.stringify(Ce2)))) + " */");
            var _t5 = new Blob([ee2], { type: "text/css" }), Ge2 = M2.href;
            M2.href = URL.createObjectURL(_t5), Ge2 && URL.revokeObjectURL(Ge2);
          }).bind(null, E2, g2), O2 = function() {
            N2(E2), E2.href && URL.revokeObjectURL(E2.href);
          }) : (E2 = _2(g2), C2 = (function(M2, Y2) {
            var de2 = Y2.css, ee2 = Y2.media;
            if (ee2 && M2.setAttribute("media", ee2), M2.styleSheet)
              M2.styleSheet.cssText = de2;
            else {
              for (; M2.firstChild; )
                M2.removeChild(M2.firstChild);
              M2.appendChild(document.createTextNode(de2));
            }
          }).bind(null, E2), O2 = function() {
            N2(E2);
          });
        return C2(b2), function(M2) {
          if (M2) {
            if (M2.css === b2.css && M2.media === b2.media && M2.sourceMap === b2.sourceMap)
              return;
            C2(b2 = M2);
          } else
            O2();
        };
      }
      t2.exports = function(b2, g2) {
        if (typeof DEBUG < "u" && DEBUG && typeof document != "object")
          throw new Error("The style-loader cannot be used in a non-browser environment");
        (g2 = g2 || {}).attrs = typeof g2.attrs == "object" ? g2.attrs : {}, g2.singleton || typeof g2.singleton == "boolean" || (g2.singleton = l2()), g2.insertInto || (g2.insertInto = "head"), g2.insertAt || (g2.insertAt = "bottom");
        var E2 = v2(b2, g2);
        return p2(E2, g2), function(C2) {
          for (var O2 = [], S2 = 0; S2 < E2.length; S2++) {
            var H2 = E2[S2];
            (M2 = a2[H2.id]).refs--, O2.push(M2);
          }
          for (C2 && p2(v2(C2, g2), g2), S2 = 0; S2 < O2.length; S2++) {
            var M2;
            if ((M2 = O2[S2]).refs === 0) {
              for (var Y2 = 0; Y2 < M2.parts.length; Y2++)
                M2.parts[Y2]();
              delete a2[M2.id];
            }
          }
        };
      };
      var w2, I2 = (w2 = [], function(b2, g2) {
        return w2[b2] = g2, w2.filter(Boolean).join(`
`);
      });
      function R2(b2, g2, E2, C2) {
        var O2 = E2 ? "" : C2.css;
        if (b2.styleSheet)
          b2.styleSheet.cssText = I2(g2, O2);
        else {
          var S2 = document.createTextNode(O2), H2 = b2.childNodes;
          H2[g2] && b2.removeChild(H2[g2]), H2.length ? b2.insertBefore(S2, H2[g2]) : b2.appendChild(S2);
        }
      }
    }, function(t2, o2) {
      t2.exports = function(i2) {
        var n2 = typeof window < "u" && window.location;
        if (!n2)
          throw new Error("fixUrls requires window.location");
        if (!i2 || typeof i2 != "string")
          return i2;
        var r2 = n2.protocol + "//" + n2.host, a2 = r2 + n2.pathname.replace(/\/[^\/]*$/, "/");
        return i2.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(l2, c2) {
          var u2, h2 = c2.trim().replace(/^"(.*)"$/, function(f2, k2) {
            return k2;
          }).replace(/^'(.*)'$/, function(f2, k2) {
            return k2;
          });
          return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(h2) ? l2 : (u2 = h2.indexOf("//") === 0 ? h2 : h2.indexOf("/") === 0 ? r2 + h2 : a2 + h2.replace(/^\.\//, ""), "url(" + JSON.stringify(u2) + ")");
        });
      };
    }, function(t2, o2, i2) {
      var n2, r2, a2, l2, c2, u2, h2, f2, k2;
      t2.exports = (n2 = "cdx-notifies", r2 = "cdx-notify", a2 = "cdx-notify__cross", l2 = "cdx-notify__button--confirm", c2 = "cdx-notify__button--cancel", u2 = "cdx-notify__input", h2 = "cdx-notify__button", f2 = "cdx-notify__btns-wrapper", { alert: k2 = function(p2) {
        var v2 = document.createElement("DIV"), A2 = document.createElement("DIV"), N2 = p2.message, _2 = p2.style;
        return v2.classList.add(r2), _2 && v2.classList.add(r2 + "--" + _2), v2.innerHTML = N2, A2.classList.add(a2), A2.addEventListener("click", v2.remove.bind(v2)), v2.appendChild(A2), v2;
      }, confirm: function(p2) {
        var v2 = k2(p2), A2 = document.createElement("div"), N2 = document.createElement("button"), _2 = document.createElement("button"), y2 = v2.querySelector("." + a2), x2 = p2.cancelHandler, w2 = p2.okHandler;
        return A2.classList.add(f2), N2.innerHTML = p2.okText || "Confirm", _2.innerHTML = p2.cancelText || "Cancel", N2.classList.add(h2), _2.classList.add(h2), N2.classList.add(l2), _2.classList.add(c2), x2 && typeof x2 == "function" && (_2.addEventListener("click", x2), y2.addEventListener("click", x2)), w2 && typeof w2 == "function" && N2.addEventListener("click", w2), N2.addEventListener("click", v2.remove.bind(v2)), _2.addEventListener("click", v2.remove.bind(v2)), A2.appendChild(N2), A2.appendChild(_2), v2.appendChild(A2), v2;
      }, prompt: function(p2) {
        var v2 = k2(p2), A2 = document.createElement("div"), N2 = document.createElement("button"), _2 = document.createElement("input"), y2 = v2.querySelector("." + a2), x2 = p2.cancelHandler, w2 = p2.okHandler;
        return A2.classList.add(f2), N2.innerHTML = p2.okText || "Ok", N2.classList.add(h2), N2.classList.add(l2), _2.classList.add(u2), p2.placeholder && _2.setAttribute("placeholder", p2.placeholder), p2.default && (_2.value = p2.default), p2.inputType && (_2.type = p2.inputType), x2 && typeof x2 == "function" && y2.addEventListener("click", x2), w2 && typeof w2 == "function" && N2.addEventListener("click", function() {
          w2(_2.value);
        }), N2.addEventListener("click", v2.remove.bind(v2)), A2.appendChild(_2), A2.appendChild(N2), v2.appendChild(A2), v2;
      }, getWrapper: function() {
        var p2 = document.createElement("DIV");
        return p2.classList.add(n2), p2;
      } });
    }]);
  });
})(lo);
const co = /* @__PURE__ */ ye(Ae);
class ho {
  /**
   * Show web notification
   *
   * @param {NotifierOptions | ConfirmNotifierOptions | PromptNotifierOptions} options - notification options
   */
  show(e2) {
    co.show(e2);
  }
}
class uo extends T {
  /**
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    }), this.notifier = new ho();
  }
  /**
   * Available methods
   */
  get methods() {
    return {
      show: (e2) => this.show(e2)
    };
  }
  /**
   * Show notification
   *
   * @param {NotifierOptions} options - message option
   */
  show(e2) {
    return this.notifier.show(e2);
  }
}
class po extends T {
  /**
   * Available methods
   */
  get methods() {
    const e2 = () => this.isEnabled;
    return {
      toggle: (t2) => this.toggle(t2),
      get isEnabled() {
        return e2();
      }
    };
  }
  /**
   * Set or toggle read-only state
   *
   * @param {boolean|undefined} state - set or toggle state
   * @returns {boolean} current value
   */
  toggle(e2) {
    return this.Editor.ReadOnly.toggle(e2);
  }
  /**
   * Returns current read-only state
   */
  get isEnabled() {
    return this.Editor.ReadOnly.isEnabled;
  }
}
var _e = {}, fo = {
  get exports() {
    return _e;
  },
  set exports(s2) {
    _e = s2;
  }
};
(function(s2, e2) {
  (function(t2, o2) {
    s2.exports = o2();
  })(Nt, function() {
    function t2(h2) {
      var f2 = h2.tags, k2 = Object.keys(f2), p2 = k2.map(function(v2) {
        return typeof f2[v2];
      }).every(function(v2) {
        return v2 === "object" || v2 === "boolean" || v2 === "function";
      });
      if (!p2)
        throw new Error("The configuration was invalid");
      this.config = h2;
    }
    var o2 = ["P", "LI", "TD", "TH", "DIV", "H1", "H2", "H3", "H4", "H5", "H6", "PRE"];
    function i2(h2) {
      return o2.indexOf(h2.nodeName) !== -1;
    }
    var n2 = ["A", "B", "STRONG", "I", "EM", "SUB", "SUP", "U", "STRIKE"];
    function r2(h2) {
      return n2.indexOf(h2.nodeName) !== -1;
    }
    t2.prototype.clean = function(h2) {
      const f2 = document.implementation.createHTMLDocument(), k2 = f2.createElement("div");
      return k2.innerHTML = h2, this._sanitize(f2, k2), k2.innerHTML;
    }, t2.prototype._sanitize = function(h2, f2) {
      var k2 = a2(h2, f2), p2 = k2.firstChild();
      if (p2)
        do {
          if (p2.nodeType === Node.TEXT_NODE)
            if (p2.data.trim() === "" && (p2.previousElementSibling && i2(p2.previousElementSibling) || p2.nextElementSibling && i2(p2.nextElementSibling))) {
              f2.removeChild(p2), this._sanitize(h2, f2);
              break;
            } else
              continue;
          if (p2.nodeType === Node.COMMENT_NODE) {
            f2.removeChild(p2), this._sanitize(h2, f2);
            break;
          }
          var v2 = r2(p2), A2;
          v2 && (A2 = Array.prototype.some.call(p2.childNodes, i2));
          var N2 = !!f2.parentNode, _2 = i2(f2) && i2(p2) && N2, y2 = p2.nodeName.toLowerCase(), x2 = l2(this.config, y2, p2), w2 = v2 && A2;
          if (w2 || c2(p2, x2) || !this.config.keepNestedBlockElements && _2) {
            if (!(p2.nodeName === "SCRIPT" || p2.nodeName === "STYLE"))
              for (; p2.childNodes.length > 0; )
                f2.insertBefore(p2.childNodes[0], p2);
            f2.removeChild(p2), this._sanitize(h2, f2);
            break;
          }
          for (var I2 = 0; I2 < p2.attributes.length; I2 += 1) {
            var R2 = p2.attributes[I2];
            u2(R2, x2, p2) && (p2.removeAttribute(R2.name), I2 = I2 - 1);
          }
          this._sanitize(h2, p2);
        } while (p2 = k2.nextSibling());
    };
    function a2(h2, f2) {
      return h2.createTreeWalker(
        f2,
        NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,
        null,
        false
      );
    }
    function l2(h2, f2, k2) {
      return typeof h2.tags[f2] == "function" ? h2.tags[f2](k2) : h2.tags[f2];
    }
    function c2(h2, f2) {
      return typeof f2 > "u" ? true : typeof f2 == "boolean" ? !f2 : false;
    }
    function u2(h2, f2, k2) {
      var p2 = h2.name.toLowerCase();
      return f2 === true ? false : typeof f2[p2] == "function" ? !f2[p2](h2.value, k2) : typeof f2[p2] > "u" || f2[p2] === false ? true : typeof f2[p2] == "string" ? f2[p2] !== h2.value : false;
    }
    return t2;
  });
})(fo);
const go = _e;
function gt(s2, e2) {
  return s2.map((t2) => {
    const o2 = D(e2) ? e2(t2.tool) : e2;
    return q(o2) || (t2.data = ze(t2.data, o2)), t2;
  });
}
function G(s2, e2 = {}) {
  const t2 = {
    tags: e2
  };
  return new go(t2).clean(s2);
}
function ze(s2, e2) {
  return Array.isArray(s2) ? bo(s2, e2) : z(s2) ? mo(s2, e2) : Q(s2) ? ko(s2, e2) : s2;
}
function bo(s2, e2) {
  return s2.map((t2) => ze(t2, e2));
}
function mo(s2, e2) {
  const t2 = {};
  for (const o2 in s2) {
    if (!Object.prototype.hasOwnProperty.call(s2, o2))
      continue;
    const i2 = s2[o2], n2 = vo(e2[o2]) ? e2[o2] : e2;
    t2[o2] = ze(i2, n2);
  }
  return t2;
}
function ko(s2, e2) {
  return z(e2) ? G(s2, e2) : e2 === false ? G(s2, {}) : s2;
}
function vo(s2) {
  return z(s2) || Ft(s2) || D(s2);
}
class xo extends T {
  /**
   * Available methods
   *
   * @returns {SanitizerConfig}
   */
  get methods() {
    return {
      clean: (e2, t2) => this.clean(e2, t2)
    };
  }
  /**
   * Perform sanitizing of a string
   *
   * @param {string} taintString - what to sanitize
   * @param {SanitizerConfig} config - sanitizer config
   * @returns {string}
   */
  clean(e2, t2) {
    return G(e2, t2);
  }
}
class wo extends T {
  /**
   * Available methods
   *
   * @returns {Saver}
   */
  get methods() {
    return {
      save: () => this.save()
    };
  }
  /**
   * Return Editor's data
   *
   * @returns {OutputData}
   */
  save() {
    const e2 = "Editor's content can not be saved in read-only mode";
    return this.Editor.ReadOnly.isEnabled ? (X(e2, "warn"), Promise.reject(new Error(e2))) : this.Editor.Saver.save();
  }
}
class yo extends T {
  /**
   * Available methods
   *
   * @returns {SelectionAPIInterface}
   */
  get methods() {
    return {
      findParentTag: (e2, t2) => this.findParentTag(e2, t2),
      expandToTag: (e2) => this.expandToTag(e2)
    };
  }
  /**
   * Looks ahead from selection and find passed tag with class name
   *
   * @param {string} tagName - tag to find
   * @param {string} className - tag's class name
   * @returns {HTMLElement|null}
   */
  findParentTag(e2, t2) {
    return new m().findParentTag(e2, t2);
  }
  /**
   * Expand selection to passed tag
   *
   * @param {HTMLElement} node - tag that should contain selection
   */
  expandToTag(e2) {
    new m().expandToTag(e2);
  }
}
class Eo extends T {
  /**
   * Exported classes
   */
  get classes() {
    return {
      /**
       * Base Block styles
       */
      block: "cdx-block",
      /**
       * Inline Tools styles
       */
      inlineToolButton: "ce-inline-tool",
      inlineToolButtonActive: "ce-inline-tool--active",
      /**
       * UI elements
       */
      input: "cdx-input",
      loader: "cdx-loader",
      button: "cdx-button",
      /**
       * Settings styles
       */
      settingsButton: "cdx-settings-button",
      settingsButtonActive: "cdx-settings-button--active"
    };
  }
}
class Bo extends T {
  /**
   * Available methods
   *
   * @returns {Toolbar}
   */
  get methods() {
    return {
      close: () => this.close(),
      open: () => this.open(),
      toggleBlockSettings: (e2) => this.toggleBlockSettings(e2),
      toggleToolbox: (e2) => this.toggleToolbox(e2)
    };
  }
  /**
   * Open toolbar
   */
  open() {
    this.Editor.Toolbar.moveAndOpen();
  }
  /**
   * Close toolbar and all included elements
   */
  close() {
    this.Editor.Toolbar.close();
  }
  /**
   * Toggles Block Setting of the current block
   *
   * @param {boolean} openingState —  opening state of Block Setting
   */
  toggleBlockSettings(e2) {
    if (this.Editor.BlockManager.currentBlockIndex === -1) {
      X("Could't toggle the Toolbar because there is no block selected ", "warn");
      return;
    }
    e2 ?? !this.Editor.BlockSettings.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.BlockSettings.open()) : this.Editor.BlockSettings.close();
  }
  /**
   * Open toolbox
   *
   * @param {boolean} openingState - Opening state of toolbox
   */
  toggleToolbox(e2) {
    if (this.Editor.BlockManager.currentBlockIndex === -1) {
      X("Could't toggle the Toolbox because there is no block selected ", "warn");
      return;
    }
    e2 ?? !this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open()) : this.Editor.Toolbar.toolbox.close();
  }
}
var Ne = {}, Co = {
  get exports() {
    return Ne;
  },
  set exports(s2) {
    Ne = s2;
  }
};
/*!
 * CodeX.Tooltips
 * 
 * @version 1.0.5
 * 
 * @licence MIT
 * @author CodeX <https://codex.so>
 * 
 * 
 */
(function(s2, e2) {
  (function(t2, o2) {
    s2.exports = o2();
  })(window, function() {
    return function(t2) {
      var o2 = {};
      function i2(n2) {
        if (o2[n2])
          return o2[n2].exports;
        var r2 = o2[n2] = { i: n2, l: false, exports: {} };
        return t2[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
      }
      return i2.m = t2, i2.c = o2, i2.d = function(n2, r2, a2) {
        i2.o(n2, r2) || Object.defineProperty(n2, r2, { enumerable: true, get: a2 });
      }, i2.r = function(n2) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
      }, i2.t = function(n2, r2) {
        if (1 & r2 && (n2 = i2(n2)), 8 & r2 || 4 & r2 && typeof n2 == "object" && n2 && n2.__esModule)
          return n2;
        var a2 = /* @__PURE__ */ Object.create(null);
        if (i2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: n2 }), 2 & r2 && typeof n2 != "string")
          for (var l2 in n2)
            i2.d(a2, l2, (function(c2) {
              return n2[c2];
            }).bind(null, l2));
        return a2;
      }, i2.n = function(n2) {
        var r2 = n2 && n2.__esModule ? function() {
          return n2.default;
        } : function() {
          return n2;
        };
        return i2.d(r2, "a", r2), r2;
      }, i2.o = function(n2, r2) {
        return Object.prototype.hasOwnProperty.call(n2, r2);
      }, i2.p = "", i2(i2.s = 0);
    }([function(t2, o2, i2) {
      t2.exports = i2(1);
    }, function(t2, o2, i2) {
      i2.r(o2), i2.d(o2, "default", function() {
        return n2;
      });
      class n2 {
        constructor() {
          this.nodes = { wrapper: null, content: null }, this.showed = false, this.offsetTop = 10, this.offsetLeft = 10, this.offsetRight = 10, this.hidingDelay = 0, this.handleWindowScroll = () => {
            this.showed && this.hide(true);
          }, this.loadStyles(), this.prepare(), window.addEventListener("scroll", this.handleWindowScroll, { passive: true });
        }
        get CSS() {
          return { tooltip: "ct", tooltipContent: "ct__content", tooltipShown: "ct--shown", placement: { left: "ct--left", bottom: "ct--bottom", right: "ct--right", top: "ct--top" } };
        }
        show(a2, l2, c2) {
          this.nodes.wrapper || this.prepare(), this.hidingTimeout && clearTimeout(this.hidingTimeout);
          const u2 = Object.assign({ placement: "bottom", marginTop: 0, marginLeft: 0, marginRight: 0, marginBottom: 0, delay: 70, hidingDelay: 0 }, c2);
          if (u2.hidingDelay && (this.hidingDelay = u2.hidingDelay), this.nodes.content.innerHTML = "", typeof l2 == "string")
            this.nodes.content.appendChild(document.createTextNode(l2));
          else {
            if (!(l2 instanceof Node))
              throw Error("[CodeX Tooltip] Wrong type of «content» passed. It should be an instance of Node or String. But " + typeof l2 + " given.");
            this.nodes.content.appendChild(l2);
          }
          switch (this.nodes.wrapper.classList.remove(...Object.values(this.CSS.placement)), u2.placement) {
            case "top":
              this.placeTop(a2, u2);
              break;
            case "left":
              this.placeLeft(a2, u2);
              break;
            case "right":
              this.placeRight(a2, u2);
              break;
            case "bottom":
            default:
              this.placeBottom(a2, u2);
          }
          u2 && u2.delay ? this.showingTimeout = setTimeout(() => {
            this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true;
          }, u2.delay) : (this.nodes.wrapper.classList.add(this.CSS.tooltipShown), this.showed = true);
        }
        hide(a2 = false) {
          if (this.hidingDelay && !a2)
            return this.hidingTimeout && clearTimeout(this.hidingTimeout), void (this.hidingTimeout = setTimeout(() => {
              this.hide(true);
            }, this.hidingDelay));
          this.nodes.wrapper.classList.remove(this.CSS.tooltipShown), this.showed = false, this.showingTimeout && clearTimeout(this.showingTimeout);
        }
        onHover(a2, l2, c2) {
          a2.addEventListener("mouseenter", () => {
            this.show(a2, l2, c2);
          }), a2.addEventListener("mouseleave", () => {
            this.hide();
          });
        }
        destroy() {
          this.nodes.wrapper.remove(), window.removeEventListener("scroll", this.handleWindowScroll);
        }
        prepare() {
          this.nodes.wrapper = this.make("div", this.CSS.tooltip), this.nodes.content = this.make("div", this.CSS.tooltipContent), this.append(this.nodes.wrapper, this.nodes.content), this.append(document.body, this.nodes.wrapper);
        }
        loadStyles() {
          const a2 = "codex-tooltips-style";
          if (document.getElementById(a2))
            return;
          const l2 = i2(2), c2 = this.make("style", null, { textContent: l2.toString(), id: a2 });
          this.prepend(document.head, c2);
        }
        placeBottom(a2, l2) {
          const c2 = a2.getBoundingClientRect(), u2 = c2.left + a2.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h2 = c2.bottom + window.pageYOffset + this.offsetTop + l2.marginTop;
          this.applyPlacement("bottom", u2, h2);
        }
        placeTop(a2, l2) {
          const c2 = a2.getBoundingClientRect(), u2 = c2.left + a2.clientWidth / 2 - this.nodes.wrapper.offsetWidth / 2, h2 = c2.top + window.pageYOffset - this.nodes.wrapper.clientHeight - this.offsetTop;
          this.applyPlacement("top", u2, h2);
        }
        placeLeft(a2, l2) {
          const c2 = a2.getBoundingClientRect(), u2 = c2.left - this.nodes.wrapper.offsetWidth - this.offsetLeft - l2.marginLeft, h2 = c2.top + window.pageYOffset + a2.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
          this.applyPlacement("left", u2, h2);
        }
        placeRight(a2, l2) {
          const c2 = a2.getBoundingClientRect(), u2 = c2.right + this.offsetRight + l2.marginRight, h2 = c2.top + window.pageYOffset + a2.clientHeight / 2 - this.nodes.wrapper.offsetHeight / 2;
          this.applyPlacement("right", u2, h2);
        }
        applyPlacement(a2, l2, c2) {
          this.nodes.wrapper.classList.add(this.CSS.placement[a2]), this.nodes.wrapper.style.left = l2 + "px", this.nodes.wrapper.style.top = c2 + "px";
        }
        make(a2, l2 = null, c2 = {}) {
          const u2 = document.createElement(a2);
          Array.isArray(l2) ? u2.classList.add(...l2) : l2 && u2.classList.add(l2);
          for (const h2 in c2)
            c2.hasOwnProperty(h2) && (u2[h2] = c2[h2]);
          return u2;
        }
        append(a2, l2) {
          Array.isArray(l2) ? l2.forEach((c2) => a2.appendChild(c2)) : a2.appendChild(l2);
        }
        prepend(a2, l2) {
          Array.isArray(l2) ? (l2 = l2.reverse()).forEach((c2) => a2.prepend(c2)) : a2.prepend(l2);
        }
      }
    }, function(t2, o2) {
      t2.exports = `.ct{z-index:999;opacity:0;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;pointer-events:none;-webkit-transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1);transition:opacity 50ms ease-in,transform 70ms cubic-bezier(.215,.61,.355,1),-webkit-transform 70ms cubic-bezier(.215,.61,.355,1);will-change:opacity,top,left;-webkit-box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);box-shadow:0 8px 12px 0 rgba(29,32,43,.17),0 4px 5px -3px rgba(5,6,12,.49);border-radius:9px}.ct,.ct:before{position:absolute;top:0;left:0}.ct:before{content:"";bottom:0;right:0;background-color:#1d202b;z-index:-1;border-radius:4px}@supports(-webkit-mask-box-image:url("")){.ct:before{border-radius:0;-webkit-mask-box-image:url('data:image/svg+xml;charset=utf-8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M10.71 0h2.58c3.02 0 4.64.42 6.1 1.2a8.18 8.18 0 013.4 3.4C23.6 6.07 24 7.7 24 10.71v2.58c0 3.02-.42 4.64-1.2 6.1a8.18 8.18 0 01-3.4 3.4c-1.47.8-3.1 1.21-6.11 1.21H10.7c-3.02 0-4.64-.42-6.1-1.2a8.18 8.18 0 01-3.4-3.4C.4 17.93 0 16.3 0 13.29V10.7c0-3.02.42-4.64 1.2-6.1a8.18 8.18 0 013.4-3.4C6.07.4 7.7 0 10.71 0z"/></svg>') 48% 41% 37.9% 53.3%}}@media (--mobile){.ct{display:none}}.ct__content{padding:6px 10px;color:#cdd1e0;font-size:12px;text-align:center;letter-spacing:.02em;line-height:1em}.ct:after{content:"";width:8px;height:8px;position:absolute;background-color:#1d202b;z-index:-1}.ct--bottom{-webkit-transform:translateY(5px);transform:translateY(5px)}.ct--bottom:after{top:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--top{-webkit-transform:translateY(-5px);transform:translateY(-5px)}.ct--top:after{top:auto;bottom:-3px;left:50%;-webkit-transform:translateX(-50%) rotate(-45deg);transform:translateX(-50%) rotate(-45deg)}.ct--left{-webkit-transform:translateX(-5px);transform:translateX(-5px)}.ct--left:after{top:50%;left:auto;right:0;-webkit-transform:translate(41.6%,-50%) rotate(-45deg);transform:translate(41.6%,-50%) rotate(-45deg)}.ct--right{-webkit-transform:translateX(5px);transform:translateX(5px)}.ct--right:after{top:50%;left:0;-webkit-transform:translate(-41.6%,-50%) rotate(-45deg);transform:translate(-41.6%,-50%) rotate(-45deg)}.ct--shown{opacity:1;-webkit-transform:none;transform:none}`;
    }]).default;
  });
})(Co);
const To = /* @__PURE__ */ ye(Ne);
let $ = null;
function Ue() {
  $ || ($ = new To());
}
function So(s2, e2, t2) {
  Ue(), $ == null || $.show(s2, e2, t2);
}
function Re(s2 = false) {
  Ue(), $ == null || $.hide(s2);
}
function be(s2, e2, t2) {
  Ue(), $ == null || $.onHover(s2, e2, t2);
}
function Io() {
  $ == null || $.destroy(), $ = null;
}
class Mo extends T {
  /**
   * @class
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    });
  }
  /**
   * Available methods
   */
  get methods() {
    return {
      show: (e2, t2, o2) => this.show(e2, t2, o2),
      hide: () => this.hide(),
      onHover: (e2, t2, o2) => this.onHover(e2, t2, o2)
    };
  }
  /**
   * Method show tooltip on element with passed HTML content
   *
   * @param {HTMLElement} element - element on which tooltip should be shown
   * @param {TooltipContent} content - tooltip content
   * @param {TooltipOptions} options - tooltip options
   */
  show(e2, t2, o2) {
    So(e2, t2, o2);
  }
  /**
   * Method hides tooltip on HTML page
   */
  hide() {
    Re();
  }
  /**
   * Decorator for showing Tooltip by mouseenter/mouseleave
   *
   * @param {HTMLElement} element - element on which tooltip should be shown
   * @param {TooltipContent} content - tooltip content
   * @param {TooltipOptions} options - tooltip options
   */
  onHover(e2, t2, o2) {
    be(e2, t2, o2);
  }
}
class Lo extends T {
  /**
   * Available methods / getters
   */
  get methods() {
    return {
      nodes: this.editorNodes
      /**
       * There can be added some UI methods, like toggleThinMode() etc
       */
    };
  }
  /**
   * Exported classes
   */
  get editorNodes() {
    return {
      /**
       * Top-level editor instance wrapper
       */
      wrapper: this.Editor.UI.nodes.wrapper,
      /**
       * Element that holds all the Blocks
       */
      redactor: this.Editor.UI.nodes.redactor
    };
  }
}
function bt(s2, e2) {
  const t2 = {};
  return Object.entries(s2).forEach(([o2, i2]) => {
    if (z(i2)) {
      const n2 = e2 ? `${e2}.${o2}` : o2;
      Object.values(i2).every((a2) => Q(a2)) ? t2[o2] = n2 : t2[o2] = bt(i2, n2);
      return;
    }
    t2[o2] = i2;
  }), t2;
}
const V = bt(dt);
function Oo(s2, e2) {
  const t2 = {};
  return Object.keys(s2).forEach((o2) => {
    const i2 = e2[o2];
    i2 !== void 0 ? t2[i2] = s2[o2] : t2[o2] = s2[o2];
  }), t2;
}
const Ao = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9 12L9 7.1C9 7.04477 9.04477 7 9.1 7H10.4C11.5 7 14 7.1 14 9.5C14 9.5 14 12 11 12M9 12V16.8C9 16.9105 9.08954 17 9.2 17H12.5C14 17 15 16 15 14.5C15 11.7046 11 12 11 12M9 12H11"/></svg>', mt = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 10L11.8586 14.8586C11.9367 14.9367 12.0633 14.9367 12.1414 14.8586L17 10"/></svg>', _o = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7 15L11.8586 10.1414C11.9367 10.0633 12.0633 10.0633 12.1414 10.1414L17 15"/></svg>', No = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 8L12 12M12 12L16 16M12 12L16 8M12 12L8 16"/></svg>', Ro = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="12" cy="12" r="4" stroke="currentColor" stroke-width="2"/></svg>', Do = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M13.34 10C12.4223 12.7337 11 17 11 17"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.21 7H14.2"/></svg>', ot = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72"/></svg>', Po = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 7.29999H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 7.29999H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.30999 12H9.3"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 12H14.59"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M9.40999 16.7H9.4"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2.6" d="M14.6 16.7H14.59"/></svg>', Fo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 7V12M12 17V12M17 12H12M12 12H7"/></svg>', Ho = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><circle cx="10.5" cy="10.5" r="5.5" stroke="currentColor" stroke-width="2"/><line x1="15.4142" x2="19" y1="15" y2="18.5858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>', jo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M15.7795 11.5C15.7795 11.5 16.053 11.1962 16.5497 10.6722C17.4442 9.72856 17.4701 8.2475 16.5781 7.30145V7.30145C15.6482 6.31522 14.0873 6.29227 13.1288 7.25073L11.8796 8.49999"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8.24517 12.3883C8.24517 12.3883 7.97171 12.6922 7.47504 13.2161C6.58051 14.1598 6.55467 15.6408 7.44666 16.5869V16.5869C8.37653 17.5731 9.93744 17.5961 10.8959 16.6376L12.1452 15.3883"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M17.7802 15.1032L16.597 14.9422C16.0109 14.8624 15.4841 15.3059 15.4627 15.8969L15.4199 17.0818"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M6.39064 9.03238L7.58432 9.06668C8.17551 9.08366 8.6522 8.58665 8.61056 7.99669L8.5271 6.81397"/><line x1="12.1142" x2="11.7" y1="12.2" y2="11.7858" stroke="currentColor" stroke-linecap="round" stroke-width="2"/></svg>', zo = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><line x1="12" x2="12" y1="9" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M12 15.02V15.01"/></svg>';
class P {
  /**
   * Constructs popover item instance
   *
   * @param params - popover item construction params
   */
  constructor(e2) {
    this.nodes = {
      root: null,
      icon: null
    }, this.confirmationState = null, this.removeSpecialFocusBehavior = () => {
      this.nodes.root.classList.remove(P.CSS.noFocus);
    }, this.removeSpecialHoverBehavior = () => {
      this.nodes.root.classList.remove(P.CSS.noHover);
    }, this.onErrorAnimationEnd = () => {
      this.nodes.icon.classList.remove(P.CSS.wobbleAnimation), this.nodes.icon.removeEventListener("animationend", this.onErrorAnimationEnd);
    }, this.params = e2, this.nodes.root = this.make(e2);
  }
  /**
   * True if item is disabled and hence not clickable
   */
  get isDisabled() {
    return this.params.isDisabled;
  }
  /**
   * Exposes popover item toggle parameter
   */
  get toggle() {
    return this.params.toggle;
  }
  /**
   * Item title
   */
  get title() {
    return this.params.title;
  }
  /**
   * True if popover should close once item is activated
   */
  get closeOnActivate() {
    return this.params.closeOnActivate;
  }
  /**
   * True if confirmation state is enabled for popover item
   */
  get isConfirmationStateEnabled() {
    return this.confirmationState !== null;
  }
  /**
   * True if item is focused in keyboard navigation process
   */
  get isFocused() {
    return this.nodes.root.classList.contains(P.CSS.focused);
  }
  /**
   * Popover item CSS classes
   */
  static get CSS() {
    return {
      container: "ce-popover-item",
      title: "ce-popover-item__title",
      secondaryTitle: "ce-popover-item__secondary-title",
      icon: "ce-popover-item__icon",
      active: "ce-popover-item--active",
      disabled: "ce-popover-item--disabled",
      focused: "ce-popover-item--focused",
      hidden: "ce-popover-item--hidden",
      confirmationState: "ce-popover-item--confirmation",
      noHover: "ce-popover-item--no-hover",
      noFocus: "ce-popover-item--no-focus",
      wobbleAnimation: "wobble"
    };
  }
  /**
   * Returns popover item root element
   */
  getElement() {
    return this.nodes.root;
  }
  /**
   * Called on popover item click
   */
  handleClick() {
    if (this.isConfirmationStateEnabled) {
      this.activateOrEnableConfirmationMode(this.confirmationState);
      return;
    }
    this.activateOrEnableConfirmationMode(this.params);
  }
  /**
   * Toggles item active state
   *
   * @param isActive - true if item should strictly should become active
   */
  toggleActive(e2) {
    this.nodes.root.classList.toggle(P.CSS.active, e2);
  }
  /**
   * Toggles item hidden state
   *
   * @param isHidden - true if item should be hidden
   */
  toggleHidden(e2) {
    this.nodes.root.classList.toggle(P.CSS.hidden, e2);
  }
  /**
   * Resets popover item to its original state
   */
  reset() {
    this.isConfirmationStateEnabled && this.disableConfirmationMode();
  }
  /**
   * Method called once item becomes focused during keyboard navigation
   */
  onFocus() {
    this.disableSpecialHoverAndFocusBehavior();
  }
  /**
   * Constructs HTML element corresponding to popover item params
   *
   * @param params - item construction params
   */
  make(e2) {
    const t2 = d.make("div", P.CSS.container);
    return e2.name && (t2.dataset.itemName = e2.name), this.nodes.icon = d.make("div", P.CSS.icon, {
      innerHTML: e2.icon || Ro
    }), t2.appendChild(this.nodes.icon), t2.appendChild(d.make("div", P.CSS.title, {
      innerHTML: e2.title || ""
    })), e2.secondaryLabel && t2.appendChild(d.make("div", P.CSS.secondaryTitle, {
      textContent: e2.secondaryLabel
    })), e2.isActive && t2.classList.add(P.CSS.active), e2.isDisabled && t2.classList.add(P.CSS.disabled), t2;
  }
  /**
   * Activates confirmation mode for the item.
   *
   * @param newState - new popover item params that should be applied
   */
  enableConfirmationMode(e2) {
    const t2 = {
      ...this.params,
      ...e2,
      confirmation: e2.confirmation
    }, o2 = this.make(t2);
    this.nodes.root.innerHTML = o2.innerHTML, this.nodes.root.classList.add(P.CSS.confirmationState), this.confirmationState = e2, this.enableSpecialHoverAndFocusBehavior();
  }
  /**
   * Returns item to its original state
   */
  disableConfirmationMode() {
    const e2 = this.make(this.params);
    this.nodes.root.innerHTML = e2.innerHTML, this.nodes.root.classList.remove(P.CSS.confirmationState), this.confirmationState = null, this.disableSpecialHoverAndFocusBehavior();
  }
  /**
   * Enables special focus and hover behavior for item in confirmation state.
   * This is needed to prevent item from being highlighted as hovered/focused just after click.
   */
  enableSpecialHoverAndFocusBehavior() {
    this.nodes.root.classList.add(P.CSS.noHover), this.nodes.root.classList.add(P.CSS.noFocus), this.nodes.root.addEventListener("mouseleave", this.removeSpecialHoverBehavior, { once: true });
  }
  /**
   * Disables special focus and hover behavior
   */
  disableSpecialHoverAndFocusBehavior() {
    this.removeSpecialFocusBehavior(), this.removeSpecialHoverBehavior(), this.nodes.root.removeEventListener("mouseleave", this.removeSpecialHoverBehavior);
  }
  /**
   * Executes item's onActivate callback if the item has no confirmation configured
   *
   * @param item - item to activate or bring to confirmation mode
   */
  activateOrEnableConfirmationMode(e2) {
    if (e2.confirmation === void 0)
      try {
        e2.onActivate(e2), this.disableConfirmationMode();
      } catch {
        this.animateError();
      }
    else
      this.enableConfirmationMode(e2.confirmation);
  }
  /**
   * Animates item which symbolizes that error occured while executing 'onActivate()' callback
   */
  animateError() {
    this.nodes.icon.classList.contains(P.CSS.wobbleAnimation) || (this.nodes.icon.classList.add(P.CSS.wobbleAnimation), this.nodes.icon.addEventListener("animationend", this.onErrorAnimationEnd));
  }
}
const he = class {
  /**
   * @param {HTMLElement[]} nodeList — the list of iterable HTML-items
   * @param {string} focusedCssClass - user-provided CSS-class that will be set in flipping process
   */
  constructor(s2, e2) {
    this.cursor = -1, this.items = [], this.items = s2 || [], this.focusedCssClass = e2;
  }
  /**
   * Returns Focused button Node
   *
   * @returns {HTMLElement}
   */
  get currentItem() {
    return this.cursor === -1 ? null : this.items[this.cursor];
  }
  /**
   * Sets cursor to specified position
   *
   * @param cursorPosition - new cursor position
   */
  setCursor(s2) {
    s2 < this.items.length && s2 >= -1 && (this.dropCursor(), this.cursor = s2, this.items[this.cursor].classList.add(this.focusedCssClass));
  }
  /**
   * Sets items. Can be used when iterable items changed dynamically
   *
   * @param {HTMLElement[]} nodeList - nodes to iterate
   */
  setItems(s2) {
    this.items = s2;
  }
  /**
   * Sets cursor next to the current
   */
  next() {
    this.cursor = this.leafNodesAndReturnIndex(he.directions.RIGHT);
  }
  /**
   * Sets cursor before current
   */
  previous() {
    this.cursor = this.leafNodesAndReturnIndex(he.directions.LEFT);
  }
  /**
   * Sets cursor to the default position and removes CSS-class from previously focused item
   */
  dropCursor() {
    this.cursor !== -1 && (this.items[this.cursor].classList.remove(this.focusedCssClass), this.cursor = -1);
  }
  /**
   * Leafs nodes inside the target list from active element
   *
   * @param {string} direction - leaf direction. Can be 'left' or 'right'
   * @returns {number} index of focused node
   */
  leafNodesAndReturnIndex(s2) {
    if (this.items.length === 0)
      return this.cursor;
    let e2 = this.cursor;
    return e2 === -1 ? e2 = s2 === he.directions.RIGHT ? -1 : 0 : this.items[e2].classList.remove(this.focusedCssClass), s2 === he.directions.RIGHT ? e2 = (e2 + 1) % this.items.length : e2 = (this.items.length + e2 - 1) % this.items.length, d.canSetCaret(this.items[e2]) && ge(() => m.setCursor(this.items[e2]), 50)(), this.items[e2].classList.add(this.focusedCssClass), e2;
  }
};
let se = he;
se.directions = {
  RIGHT: "right",
  LEFT: "left"
};
class J {
  /**
   * @param {FlipperOptions} options - different constructing settings
   */
  constructor(e2) {
    this.iterator = null, this.activated = false, this.flipCallbacks = [], this.onKeyDown = (t2) => {
      if (this.isEventReadyForHandling(t2))
        switch (J.usedKeys.includes(t2.keyCode) && t2.preventDefault(), t2.keyCode) {
          case B.TAB:
            this.handleTabPress(t2);
            break;
          case B.LEFT:
          case B.UP:
            this.flipLeft();
            break;
          case B.RIGHT:
          case B.DOWN:
            this.flipRight();
            break;
          case B.ENTER:
            this.handleEnterPress(t2);
            break;
        }
    }, this.iterator = new se(e2.items, e2.focusedItemClass), this.activateCallback = e2.activateCallback, this.allowedKeys = e2.allowedKeys || J.usedKeys;
  }
  /**
   * True if flipper is currently activated
   */
  get isActivated() {
    return this.activated;
  }
  /**
   * Array of keys (codes) that is handled by Flipper
   * Used to:
   *  - preventDefault only for this keys, not all keydowns (@see constructor)
   *  - to skip external behaviours only for these keys, when filler is activated (@see BlockEvents@arrowRightAndDown)
   */
  static get usedKeys() {
    return [
      B.TAB,
      B.LEFT,
      B.RIGHT,
      B.ENTER,
      B.UP,
      B.DOWN
    ];
  }
  /**
   * Active tab/arrows handling by flipper
   *
   * @param items - Some modules (like, InlineToolbar, BlockSettings) might refresh buttons dynamically
   * @param cursorPosition - index of the item that should be focused once flipper is activated
   */
  activate(e2, t2) {
    this.activated = true, e2 && this.iterator.setItems(e2), t2 !== void 0 && this.iterator.setCursor(t2), document.addEventListener("keydown", this.onKeyDown, true);
  }
  /**
   * Disable tab/arrows handling by flipper
   */
  deactivate() {
    this.activated = false, this.dropCursor(), document.removeEventListener("keydown", this.onKeyDown);
  }
  /**
   * Focus first item
   */
  focusFirst() {
    this.dropCursor(), this.flipRight();
  }
  /**
   * Focuses previous flipper iterator item
   */
  flipLeft() {
    this.iterator.previous(), this.flipCallback();
  }
  /**
   * Focuses next flipper iterator item
   */
  flipRight() {
    this.iterator.next(), this.flipCallback();
  }
  /**
   * Return true if some button is focused
   */
  hasFocus() {
    return !!this.iterator.currentItem;
  }
  /**
   * Registeres function that should be executed on each navigation action
   *
   * @param cb - function to execute
   */
  onFlip(e2) {
    this.flipCallbacks.push(e2);
  }
  /**
   * Unregisteres function that is executed on each navigation action
   *
   * @param cb - function to stop executing
   */
  removeOnFlip(e2) {
    this.flipCallbacks = this.flipCallbacks.filter((t2) => t2 !== e2);
  }
  /**
   * Drops flipper's iterator cursor
   *
   * @see DomIterator#dropCursor
   */
  dropCursor() {
    this.iterator.dropCursor();
  }
  /**
   * This function is fired before handling flipper keycodes
   * The result of this function defines if it is need to be handled or not
   *
   * @param {KeyboardEvent} event - keydown keyboard event
   * @returns {boolean}
   */
  isEventReadyForHandling(e2) {
    return this.activated && this.allowedKeys.includes(e2.keyCode);
  }
  /**
   * When flipper is activated tab press will leaf the items
   *
   * @param {KeyboardEvent} event - tab keydown event
   */
  handleTabPress(e2) {
    switch (e2.shiftKey ? se.directions.LEFT : se.directions.RIGHT) {
      case se.directions.RIGHT:
        this.flipRight();
        break;
      case se.directions.LEFT:
        this.flipLeft();
        break;
    }
  }
  /**
   * Enter press will click current item if flipper is activated
   *
   * @param {KeyboardEvent} event - enter keydown event
   */
  handleEnterPress(e2) {
    this.activated && (this.iterator.currentItem && (e2.stopPropagation(), e2.preventDefault(), this.iterator.currentItem.click()), D(this.activateCallback) && this.activateCallback(this.iterator.currentItem));
  }
  /**
   * Fired after flipping in any direction
   */
  flipCallback() {
    this.iterator.currentItem && this.iterator.currentItem.scrollIntoViewIfNeeded(), this.flipCallbacks.forEach((e2) => e2());
  }
}
class pe {
  /**
   * Styles
   */
  static get CSS() {
    return {
      wrapper: "cdx-search-field",
      icon: "cdx-search-field__icon",
      input: "cdx-search-field__input"
    };
  }
  /**
   * @param options - available config
   * @param options.items - searchable items list
   * @param options.onSearch - search callback
   * @param options.placeholder - input placeholder
   */
  constructor({ items: e2, onSearch: t2, placeholder: o2 }) {
    this.listeners = new He(), this.items = e2, this.onSearch = t2, this.render(o2);
  }
  /**
   * Returns search field element
   */
  getElement() {
    return this.wrapper;
  }
  /**
   * Sets focus to the input
   */
  focus() {
    this.input.focus();
  }
  /**
   * Clears search query and results
   */
  clear() {
    this.input.value = "", this.searchQuery = "", this.onSearch("", this.foundItems);
  }
  /**
   * Clears memory
   */
  destroy() {
    this.listeners.removeAll();
  }
  /**
   * Creates the search field
   *
   * @param placeholder - input placeholder
   */
  render(e2) {
    this.wrapper = d.make("div", pe.CSS.wrapper);
    const t2 = d.make("div", pe.CSS.icon, {
      innerHTML: Ho
    });
    this.input = d.make("input", pe.CSS.input, {
      placeholder: e2
    }), this.wrapper.appendChild(t2), this.wrapper.appendChild(this.input), this.listeners.on(this.input, "input", () => {
      this.searchQuery = this.input.value, this.onSearch(this.searchQuery, this.foundItems);
    });
  }
  /**
   * Returns list of found items for the current search query
   */
  get foundItems() {
    return this.items.filter((e2) => this.checkItem(e2));
  }
  /**
   * Contains logic for checking whether passed item conforms the search query
   *
   * @param item - item to be checked
   */
  checkItem(e2) {
    var i2;
    const t2 = ((i2 = e2.title) == null ? void 0 : i2.toLowerCase()) || "", o2 = this.searchQuery.toLowerCase();
    return t2.includes(o2);
  }
}
const ue = class {
  /**
   * Locks body element scroll
   */
  lock() {
    et ? this.lockHard() : document.body.classList.add(ue.CSS.scrollLocked);
  }
  /**
   * Unlocks body element scroll
   */
  unlock() {
    et ? this.unlockHard() : document.body.classList.remove(ue.CSS.scrollLocked);
  }
  /**
   * Locks scroll in a hard way (via setting fixed position to body element)
   */
  lockHard() {
    this.scrollPosition = window.pageYOffset, document.documentElement.style.setProperty(
      "--window-scroll-offset",
      `${this.scrollPosition}px`
    ), document.body.classList.add(ue.CSS.scrollLockedHard);
  }
  /**
   * Unlocks hard scroll lock
   */
  unlockHard() {
    document.body.classList.remove(ue.CSS.scrollLockedHard), this.scrollPosition !== null && window.scrollTo(0, this.scrollPosition), this.scrollPosition = null;
  }
};
let kt = ue;
kt.CSS = {
  scrollLocked: "ce-scroll-locked",
  scrollLockedHard: "ce-scroll-locked--hard"
};
var Uo = Object.defineProperty, $o = Object.getOwnPropertyDescriptor, Wo = (s2, e2, t2, o2) => {
  for (var i2 = o2 > 1 ? void 0 : o2 ? $o(e2, t2) : e2, n2 = s2.length - 1, r2; n2 >= 0; n2--)
    (r2 = s2[n2]) && (i2 = (o2 ? r2(e2, t2, i2) : r2(i2)) || i2);
  return o2 && i2 && Uo(e2, t2, i2), i2;
}, me = /* @__PURE__ */ ((s2) => (s2.Close = "close", s2))(me || {});
const j = class extends Ee {
  /**
   * Constructs the instance
   *
   * @param params - popover construction params
   */
  constructor(s2) {
    super(), this.scopeElement = document.body, this.listeners = new He(), this.scrollLocker = new kt(), this.nodes = {
      wrapper: null,
      popover: null,
      nothingFoundMessage: null,
      customContent: null,
      items: null,
      overlay: null
    }, this.messages = {
      nothingFound: "Nothing found",
      search: "Search"
    }, this.onFlip = () => {
      this.items.find((t2) => t2.isFocused).onFocus();
    }, this.items = s2.items.map((e2) => new P(e2)), s2.scopeElement !== void 0 && (this.scopeElement = s2.scopeElement), s2.messages && (this.messages = {
      ...this.messages,
      ...s2.messages
    }), s2.customContentFlippableItems && (this.customContentFlippableItems = s2.customContentFlippableItems), this.make(), s2.customContent && this.addCustomContent(s2.customContent), s2.searchable && this.addSearch(), this.initializeFlipper();
  }
  /**
   * Popover CSS classes
   */
  static get CSS() {
    return {
      popover: "ce-popover",
      popoverOpenTop: "ce-popover--open-top",
      popoverOpened: "ce-popover--opened",
      search: "ce-popover__search",
      nothingFoundMessage: "ce-popover__nothing-found-message",
      nothingFoundMessageDisplayed: "ce-popover__nothing-found-message--displayed",
      customContent: "ce-popover__custom-content",
      customContentHidden: "ce-popover__custom-content--hidden",
      items: "ce-popover__items",
      overlay: "ce-popover__overlay",
      overlayHidden: "ce-popover__overlay--hidden"
    };
  }
  /**
   * Returns HTML element corresponding to the popover
   */
  getElement() {
    return this.nodes.wrapper;
  }
  /**
   * Returns true if some item inside popover is focused
   */
  hasFocus() {
    return this.flipper.hasFocus();
  }
  /**
   * Open popover
   */
  show() {
    this.shouldOpenBottom || (this.nodes.popover.style.setProperty("--popover-height", this.height + "px"), this.nodes.popover.classList.add(j.CSS.popoverOpenTop)), this.nodes.overlay.classList.remove(j.CSS.overlayHidden), this.nodes.popover.classList.add(j.CSS.popoverOpened), this.flipper.activate(this.flippableElements), this.search !== void 0 && setTimeout(() => {
      this.search.focus();
    }, 100), oe() && this.scrollLocker.lock();
  }
  /**
   * Closes popover
   */
  hide() {
    this.nodes.popover.classList.remove(j.CSS.popoverOpened), this.nodes.popover.classList.remove(j.CSS.popoverOpenTop), this.nodes.overlay.classList.add(j.CSS.overlayHidden), this.flipper.deactivate(), this.items.forEach((s2) => s2.reset()), this.search !== void 0 && this.search.clear(), oe() && this.scrollLocker.unlock(), this.emit(
      "close"
      /* Close */
    );
  }
  /**
   * Clears memory
   */
  destroy() {
    this.flipper.deactivate(), this.listeners.removeAll(), oe() && this.scrollLocker.unlock();
  }
  /**
   * Constructs HTML element corresponding to popover
   */
  make() {
    this.nodes.popover = d.make("div", [j.CSS.popover]), this.nodes.nothingFoundMessage = d.make("div", [j.CSS.nothingFoundMessage], {
      textContent: this.messages.nothingFound
    }), this.nodes.popover.appendChild(this.nodes.nothingFoundMessage), this.nodes.items = d.make("div", [j.CSS.items]), this.items.forEach((s2) => {
      this.nodes.items.appendChild(s2.getElement());
    }), this.nodes.popover.appendChild(this.nodes.items), this.listeners.on(this.nodes.popover, "click", (s2) => {
      const e2 = this.getTargetItem(s2);
      e2 !== void 0 && this.handleItemClick(e2);
    }), this.nodes.wrapper = d.make("div"), this.nodes.overlay = d.make("div", [j.CSS.overlay, j.CSS.overlayHidden]), this.listeners.on(this.nodes.overlay, "click", () => {
      this.hide();
    }), this.nodes.wrapper.appendChild(this.nodes.overlay), this.nodes.wrapper.appendChild(this.nodes.popover);
  }
  /**
   * Adds search to the popover
   */
  addSearch() {
    this.search = new pe({
      items: this.items,
      placeholder: this.messages.search,
      onSearch: (e2, t2) => {
        this.items.forEach((i2) => {
          const n2 = !t2.includes(i2);
          i2.toggleHidden(n2);
        }), this.toggleNothingFoundMessage(t2.length === 0), this.toggleCustomContent(e2 !== "");
        const o2 = e2 === "" ? this.flippableElements : t2.map((i2) => i2.getElement());
        this.flipper.isActivated && (this.flipper.deactivate(), this.flipper.activate(o2));
      }
    });
    const s2 = this.search.getElement();
    s2.classList.add(j.CSS.search), this.nodes.popover.insertBefore(s2, this.nodes.popover.firstChild);
  }
  /**
   * Adds custom html content to the popover
   *
   * @param content - html content to append
   */
  addCustomContent(s2) {
    this.nodes.customContent = s2, this.nodes.customContent.classList.add(j.CSS.customContent), this.nodes.popover.insertBefore(s2, this.nodes.popover.firstChild);
  }
  /**
   * Retrieves popover item that is the target of the specified event
   *
   * @param event - event to retrieve popover item from
   */
  getTargetItem(s2) {
    return this.items.find((e2) => s2.composedPath().includes(e2.getElement()));
  }
  /**
   * Handles item clicks
   *
   * @param item - item to handle click of
   */
  handleItemClick(s2) {
    s2.isDisabled || (this.items.filter((e2) => e2 !== s2).forEach((e2) => e2.reset()), s2.handleClick(), this.toggleItemActivenessIfNeeded(s2), s2.closeOnActivate && this.hide());
  }
  /**
   * Creates Flipper instance which allows to navigate between popover items via keyboard
   */
  initializeFlipper() {
    this.flipper = new J({
      items: this.flippableElements,
      focusedItemClass: P.CSS.focused,
      allowedKeys: [
        B.TAB,
        B.UP,
        B.DOWN,
        B.ENTER
      ]
    }), this.flipper.onFlip(this.onFlip);
  }
  /**
   * Returns list of elements available for keyboard navigation.
   * Contains both usual popover items elements and custom html content.
   */
  get flippableElements() {
    const s2 = this.items.map((t2) => t2.getElement());
    return (this.customContentFlippableItems || []).concat(s2);
  }
  get height() {
    let s2 = 0;
    if (this.nodes.popover === null)
      return s2;
    const e2 = this.nodes.popover.cloneNode(true);
    return e2.style.visibility = "hidden", e2.style.position = "absolute", e2.style.top = "-1000px", e2.classList.add(j.CSS.popoverOpened), document.body.appendChild(e2), s2 = e2.offsetHeight, e2.remove(), s2;
  }
  /**
   * Checks if popover should be opened bottom.
   * It should happen when there is enough space below or not enough space above
   */
  get shouldOpenBottom() {
    const s2 = this.nodes.popover.getBoundingClientRect(), e2 = this.scopeElement.getBoundingClientRect(), t2 = this.height, o2 = s2.top + t2, i2 = s2.top - t2, n2 = Math.min(window.innerHeight, e2.bottom);
    return i2 < e2.top || o2 <= n2;
  }
  /**
   * Toggles nothing found message visibility
   *
   * @param isDisplayed - true if the message should be displayed
   */
  toggleNothingFoundMessage(s2) {
    this.nodes.nothingFoundMessage.classList.toggle(j.CSS.nothingFoundMessageDisplayed, s2);
  }
  /**
   * Toggles custom content visibility
   *
   * @param isDisplayed - true if custom content should be displayed
   */
  toggleCustomContent(s2) {
    var e2;
    (e2 = this.nodes.customContent) == null || e2.classList.toggle(j.CSS.customContentHidden, s2);
  }
  /**
   * - Toggles item active state, if clicked popover item has property 'toggle' set to true.
   *
   * - Performs radiobutton-like behavior if the item has property 'toggle' set to string key.
   * (All the other items with the same key get inactive, and the item gets active)
   *
   * @param clickedItem - popover item that was clicked
   */
  toggleItemActivenessIfNeeded(s2) {
    if (s2.toggle === true && s2.toggleActive(), typeof s2.toggle == "string") {
      const e2 = this.items.filter((t2) => t2.toggle === s2.toggle);
      if (e2.length === 1) {
        s2.toggleActive();
        return;
      }
      e2.forEach((t2) => {
        t2.toggleActive(t2 === s2);
      });
    }
  }
};
let $e = j;
Wo([
  ce
], $e.prototype, "height", 1);
class Yo extends T {
  constructor() {
    super(...arguments), this.opened = false, this.selection = new m(), this.onPopoverClose = () => {
      this.close();
    };
  }
  /**
   * Module Events
   *
   * @returns {{opened: string, closed: string}}
   */
  get events() {
    return {
      opened: "block-settings-opened",
      closed: "block-settings-closed"
    };
  }
  /**
   * Block Settings CSS
   */
  get CSS() {
    return {
      settings: "ce-settings"
    };
  }
  /**
   * Getter for inner popover's flipper instance
   *
   * @todo remove once BlockSettings becomes standalone non-module class
   */
  get flipper() {
    var e2;
    return (e2 = this.popover) == null ? void 0 : e2.flipper;
  }
  /**
   * Panel with block settings with 2 sections:
   *  - Tool's Settings
   *  - Default Settings [Move, Remove, etc]
   */
  make() {
    this.nodes.wrapper = d.make("div", [this.CSS.settings]);
  }
  /**
   * Destroys module
   */
  destroy() {
    this.removeAllNodes();
  }
  /**
   * Open Block Settings pane
   *
   * @param targetBlock - near which Block we should open BlockSettings
   */
  open(e2 = this.Editor.BlockManager.currentBlock) {
    this.opened = true, this.selection.save(), e2.selected = true, this.Editor.BlockSelection.clearCache();
    const [t2, o2] = e2.getTunes();
    this.eventsDispatcher.emit(this.events.opened), this.popover = new $e({
      searchable: true,
      items: t2.map((i2) => this.resolveTuneAliases(i2)),
      customContent: o2,
      customContentFlippableItems: this.getControls(o2),
      scopeElement: this.Editor.API.methods.ui.nodes.redactor,
      messages: {
        nothingFound: W.ui(V.ui.popover, "Nothing found"),
        search: W.ui(V.ui.popover, "Filter")
      }
    }), this.popover.on(me.Close, this.onPopoverClose), this.nodes.wrapper.append(this.popover.getElement()), this.popover.show();
  }
  /**
   * Returns root block settings element
   */
  getElement() {
    return this.nodes.wrapper;
  }
  /**
   * Close Block Settings pane
   */
  close() {
    this.opened = false, m.isAtEditor || this.selection.restore(), this.selection.clearSaved(), !this.Editor.CrossBlockSelection.isCrossBlockSelectionStarted && this.Editor.BlockManager.currentBlock && (this.Editor.BlockManager.currentBlock.selected = false), this.eventsDispatcher.emit(this.events.closed), this.popover && (this.popover.off(me.Close, this.onPopoverClose), this.popover.destroy(), this.popover.getElement().remove(), this.popover = null);
  }
  /**
   * Returns list of buttons and inputs inside specified container
   *
   * @param container - container to query controls inside of
   */
  getControls(e2) {
    const { StylesAPI: t2 } = this.Editor, o2 = e2.querySelectorAll(
      `.${t2.classes.settingsButton}, ${d.allInputsSelector}`
    );
    return Array.from(o2);
  }
  /**
   * Resolves aliases in tunes menu items
   *
   * @param item - item with resolved aliases
   */
  resolveTuneAliases(e2) {
    const t2 = Oo(e2, { label: "title" });
    return e2.confirmation && (t2.confirmation = this.resolveTuneAliases(e2.confirmation)), t2;
  }
}
class K extends T {
  constructor() {
    super(...arguments), this.opened = false, this.tools = [], this.flipper = null, this.togglingCallback = null;
  }
  /**
   * CSS getter
   */
  static get CSS() {
    return {
      conversionToolbarWrapper: "ce-conversion-toolbar",
      conversionToolbarShowed: "ce-conversion-toolbar--showed",
      conversionToolbarTools: "ce-conversion-toolbar__tools",
      conversionToolbarLabel: "ce-conversion-toolbar__label",
      conversionTool: "ce-conversion-tool",
      conversionToolHidden: "ce-conversion-tool--hidden",
      conversionToolIcon: "ce-conversion-tool__icon",
      conversionToolSecondaryLabel: "ce-conversion-tool__secondary-label",
      conversionToolFocused: "ce-conversion-tool--focused",
      conversionToolActive: "ce-conversion-tool--active"
    };
  }
  /**
   * Create UI of Conversion Toolbar
   */
  make() {
    this.nodes.wrapper = d.make("div", [
      K.CSS.conversionToolbarWrapper,
      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []
    ]), this.nodes.tools = d.make("div", K.CSS.conversionToolbarTools);
    const e2 = d.make("div", K.CSS.conversionToolbarLabel, {
      textContent: W.ui(V.ui.inlineToolbar.converter, "Convert to")
    });
    return this.addTools(), this.enableFlipper(), d.append(this.nodes.wrapper, e2), d.append(this.nodes.wrapper, this.nodes.tools), this.nodes.wrapper;
  }
  /**
   * Deactivates flipper and removes all nodes
   */
  destroy() {
    this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();
  }
  /**
   * Toggle conversion dropdown visibility
   *
   * @param {Function} [togglingCallback] — callback that will accept opening state
   */
  toggle(e2) {
    this.opened ? this.close() : this.open(), D(e2) && (this.togglingCallback = e2);
  }
  /**
   * Shows Conversion Toolbar
   */
  open() {
    this.filterTools(), this.opened = true, this.nodes.wrapper.classList.add(K.CSS.conversionToolbarShowed), window.requestAnimationFrame(() => {
      this.flipper.activate(this.tools.map((e2) => e2.button).filter((e2) => !e2.classList.contains(K.CSS.conversionToolHidden))), this.flipper.focusFirst(), D(this.togglingCallback) && this.togglingCallback(true);
    });
  }
  /**
   * Closes Conversion Toolbar
   */
  close() {
    this.opened = false, this.flipper.deactivate(), this.nodes.wrapper.classList.remove(K.CSS.conversionToolbarShowed), D(this.togglingCallback) && this.togglingCallback(false);
  }
  /**
   * Returns true if it has more than one tool available for convert in
   */
  hasTools() {
    return this.tools.length === 1 ? this.tools[0].name !== this.config.defaultBlock : true;
  }
  /**
   * Replaces one Block with another
   * For that Tools must provide import/export methods
   *
   * @param {string} replacingToolName - name of Tool which replaces current
   * @param blockDataOverrides - If this conversion fired by the one of multiple Toolbox items, extend converted data with this item's "data" overrides
   */
  async replaceWithBlock(e2, t2) {
    const { BlockManager: o2, BlockSelection: i2, InlineToolbar: n2, Caret: r2 } = this.Editor;
    o2.convert(this.Editor.BlockManager.currentBlock, e2, t2), i2.clearSelection(), this.close(), n2.close(), window.requestAnimationFrame(() => {
      r2.setToBlock(this.Editor.BlockManager.currentBlock, r2.positions.END);
    });
  }
  /**
   * Iterates existing Tools and inserts to the ConversionToolbar
   * if tools have ability to import
   */
  addTools() {
    const e2 = this.Editor.Tools.blockTools;
    Array.from(e2.entries()).forEach(([t2, o2]) => {
      var n2;
      const i2 = o2.conversionConfig;
      !i2 || !i2.import || (n2 = o2.toolbox) == null || n2.forEach(
        (r2) => this.addToolIfValid(t2, r2)
      );
    });
  }
  /**
   * Inserts a tool to the ConversionToolbar if the tool's toolbox config is valid
   *
   * @param name - tool's name
   * @param toolboxSettings - tool's single toolbox setting
   */
  addToolIfValid(e2, t2) {
    q(t2) || !t2.icon || this.addTool(e2, t2);
  }
  /**
   * Add tool to the Conversion Toolbar
   *
   * @param toolName - name of Tool to add
   * @param toolboxItem - tool's toolbox item data
   */
  addTool(e2, t2) {
    var r2;
    const o2 = d.make("div", [K.CSS.conversionTool]), i2 = d.make("div", [K.CSS.conversionToolIcon]);
    o2.dataset.tool = e2, i2.innerHTML = t2.icon, d.append(o2, i2), d.append(o2, d.text(W.t(V.toolNames, t2.title || ae(e2))));
    const n2 = (r2 = this.Editor.Tools.blockTools.get(e2)) == null ? void 0 : r2.shortcut;
    if (n2) {
      const a2 = d.make("span", K.CSS.conversionToolSecondaryLabel, {
        innerText: Fe(n2)
      });
      d.append(o2, a2);
    }
    d.append(this.nodes.tools, o2), this.tools.push({
      name: e2,
      button: o2,
      toolboxItem: t2
    }), this.listeners.on(o2, "click", async () => {
      await this.replaceWithBlock(e2, t2.data);
    });
  }
  /**
   * Hide current Tool and show others
   */
  async filterTools() {
    const { currentBlock: e2 } = this.Editor.BlockManager, t2 = await e2.getActiveToolboxEntry();
    function o2(i2, n2) {
      return i2.icon === n2.icon && i2.title === n2.title;
    }
    this.tools.forEach((i2) => {
      let n2 = false;
      if (t2) {
        const r2 = o2(t2, i2.toolboxItem);
        n2 = i2.button.dataset.tool === e2.name && r2;
      }
      i2.button.hidden = n2, i2.button.classList.toggle(K.CSS.conversionToolHidden, n2);
    });
  }
  /**
   * Prepare Flipper to be able to leaf tools by arrows/tab
   */
  enableFlipper() {
    this.flipper = new J({
      focusedItemClass: K.CSS.conversionToolFocused
    });
  }
}
var De = {}, Ko = {
  get exports() {
    return De;
  },
  set exports(s2) {
    De = s2;
  }
};
/*!
 * Library for handling keyboard shortcuts
 * @copyright CodeX (https://codex.so)
 * @license MIT
 * @author CodeX (https://codex.so)
 * @version 1.2.0
 */
(function(s2, e2) {
  (function(t2, o2) {
    s2.exports = o2();
  })(window, function() {
    return function(t2) {
      var o2 = {};
      function i2(n2) {
        if (o2[n2])
          return o2[n2].exports;
        var r2 = o2[n2] = { i: n2, l: false, exports: {} };
        return t2[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
      }
      return i2.m = t2, i2.c = o2, i2.d = function(n2, r2, a2) {
        i2.o(n2, r2) || Object.defineProperty(n2, r2, { enumerable: true, get: a2 });
      }, i2.r = function(n2) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
      }, i2.t = function(n2, r2) {
        if (1 & r2 && (n2 = i2(n2)), 8 & r2 || 4 & r2 && typeof n2 == "object" && n2 && n2.__esModule)
          return n2;
        var a2 = /* @__PURE__ */ Object.create(null);
        if (i2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: n2 }), 2 & r2 && typeof n2 != "string")
          for (var l2 in n2)
            i2.d(a2, l2, (function(c2) {
              return n2[c2];
            }).bind(null, l2));
        return a2;
      }, i2.n = function(n2) {
        var r2 = n2 && n2.__esModule ? function() {
          return n2.default;
        } : function() {
          return n2;
        };
        return i2.d(r2, "a", r2), r2;
      }, i2.o = function(n2, r2) {
        return Object.prototype.hasOwnProperty.call(n2, r2);
      }, i2.p = "", i2(i2.s = 0);
    }([function(t2, o2, i2) {
      function n2(l2, c2) {
        for (var u2 = 0; u2 < c2.length; u2++) {
          var h2 = c2[u2];
          h2.enumerable = h2.enumerable || false, h2.configurable = true, "value" in h2 && (h2.writable = true), Object.defineProperty(l2, h2.key, h2);
        }
      }
      function r2(l2, c2, u2) {
        return c2 && n2(l2.prototype, c2), u2 && n2(l2, u2), l2;
      }
      i2.r(o2);
      var a2 = function() {
        function l2(c2) {
          var u2 = this;
          (function(h2, f2) {
            if (!(h2 instanceof f2))
              throw new TypeError("Cannot call a class as a function");
          })(this, l2), this.commands = {}, this.keys = {}, this.name = c2.name, this.parseShortcutName(c2.name), this.element = c2.on, this.callback = c2.callback, this.executeShortcut = function(h2) {
            u2.execute(h2);
          }, this.element.addEventListener("keydown", this.executeShortcut, false);
        }
        return r2(l2, null, [{ key: "supportedCommands", get: function() {
          return { SHIFT: ["SHIFT"], CMD: ["CMD", "CONTROL", "COMMAND", "WINDOWS", "CTRL"], ALT: ["ALT", "OPTION"] };
        } }, { key: "keyCodes", get: function() {
          return { 0: 48, 1: 49, 2: 50, 3: 51, 4: 52, 5: 53, 6: 54, 7: 55, 8: 56, 9: 57, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, BACKSPACE: 8, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, INSERT: 45, DELETE: 46, ".": 190 };
        } }]), r2(l2, [{ key: "parseShortcutName", value: function(c2) {
          c2 = c2.split("+");
          for (var u2 = 0; u2 < c2.length; u2++) {
            c2[u2] = c2[u2].toUpperCase();
            var h2 = false;
            for (var f2 in l2.supportedCommands)
              if (l2.supportedCommands[f2].includes(c2[u2])) {
                h2 = this.commands[f2] = true;
                break;
              }
            h2 || (this.keys[c2[u2]] = true);
          }
          for (var k2 in l2.supportedCommands)
            this.commands[k2] || (this.commands[k2] = false);
        } }, { key: "execute", value: function(c2) {
          var u2, h2 = { CMD: c2.ctrlKey || c2.metaKey, SHIFT: c2.shiftKey, ALT: c2.altKey }, f2 = true;
          for (u2 in this.commands)
            this.commands[u2] !== h2[u2] && (f2 = false);
          var k2, p2 = true;
          for (k2 in this.keys)
            p2 = p2 && c2.keyCode === l2.keyCodes[k2];
          f2 && p2 && this.callback(c2);
        } }, { key: "remove", value: function() {
          this.element.removeEventListener("keydown", this.executeShortcut);
        } }]), l2;
      }();
      o2.default = a2;
    }]).default;
  });
})(Ko);
const Xo = /* @__PURE__ */ ye(De);
class Vo {
  constructor() {
    this.registeredShortcuts = /* @__PURE__ */ new Map();
  }
  /**
   * Register shortcut
   *
   * @param shortcut - shortcut options
   */
  add(e2) {
    if (this.findShortcut(e2.on, e2.name))
      throw Error(
        `Shortcut ${e2.name} is already registered for ${e2.on}. Please remove it before add a new handler.`
      );
    const o2 = new Xo({
      name: e2.name,
      on: e2.on,
      callback: e2.handler
    }), i2 = this.registeredShortcuts.get(e2.on) || [];
    this.registeredShortcuts.set(e2.on, [...i2, o2]);
  }
  /**
   * Remove shortcut
   *
   * @param element - Element shortcut is set for
   * @param name - shortcut name
   */
  remove(e2, t2) {
    const o2 = this.findShortcut(e2, t2);
    if (!o2)
      return;
    o2.remove();
    const i2 = this.registeredShortcuts.get(e2);
    this.registeredShortcuts.set(e2, i2.filter((n2) => n2 !== o2));
  }
  /**
   * Get Shortcut instance if exist
   *
   * @param element - Element shorcut is set for
   * @param shortcut - shortcut name
   * @returns {number} index - shortcut index if exist
   */
  findShortcut(e2, t2) {
    return (this.registeredShortcuts.get(e2) || []).find(({ name: i2 }) => i2 === t2);
  }
}
const le = new Vo();
var qo = Object.defineProperty, Zo = Object.getOwnPropertyDescriptor, vt = (s2, e2, t2, o2) => {
  for (var i2 = o2 > 1 ? void 0 : o2 ? Zo(e2, t2) : e2, n2 = s2.length - 1, r2; n2 >= 0; n2--)
    (r2 = s2[n2]) && (i2 = (o2 ? r2(e2, t2, i2) : r2(i2)) || i2);
  return o2 && i2 && qo(e2, t2, i2), i2;
}, ve = /* @__PURE__ */ ((s2) => (s2.Opened = "toolbox-opened", s2.Closed = "toolbox-closed", s2.BlockAdded = "toolbox-block-added", s2))(ve || {});
const xt = class extends Ee {
  /**
   * Toolbox constructor
   *
   * @param options - available parameters
   * @param options.api - Editor API methods
   * @param options.tools - Tools available to check whether some of them should be displayed at the Toolbox or not
   */
  constructor({ api: s2, tools: e2, i18nLabels: t2 }) {
    super(), this.opened = false, this.nodes = {
      toolbox: null
    }, this.onPopoverClose = () => {
      this.opened = false, this.emit(
        "toolbox-closed"
        /* Closed */
      );
    }, this.api = s2, this.tools = e2, this.i18nLabels = t2;
  }
  /**
   * Returns True if Toolbox is Empty and nothing to show
   *
   * @returns {boolean}
   */
  get isEmpty() {
    return this.toolsToBeDisplayed.length === 0;
  }
  /**
   * CSS styles
   *
   * @returns {Object<string, string>}
   */
  static get CSS() {
    return {
      toolbox: "ce-toolbox"
    };
  }
  /**
   * Makes the Toolbox
   */
  make() {
    return this.popover = new $e({
      scopeElement: this.api.ui.nodes.redactor,
      searchable: true,
      messages: {
        nothingFound: this.i18nLabels.nothingFound,
        search: this.i18nLabels.filter
      },
      items: this.toolboxItemsToBeDisplayed
    }), this.popover.on(me.Close, this.onPopoverClose), this.enableShortcuts(), this.nodes.toolbox = this.popover.getElement(), this.nodes.toolbox.classList.add(xt.CSS.toolbox), this.nodes.toolbox;
  }
  /**
   * Returns true if the Toolbox has the Flipper activated and the Flipper has selected button
   */
  hasFocus() {
    var s2;
    return (s2 = this.popover) == null ? void 0 : s2.hasFocus();
  }
  /**
   * Destroy Module
   */
  destroy() {
    var s2;
    super.destroy(), this.nodes && this.nodes.toolbox && (this.nodes.toolbox.remove(), this.nodes.toolbox = null), this.removeAllShortcuts(), (s2 = this.popover) == null || s2.off(me.Close, this.onPopoverClose);
  }
  /**
   * Toolbox Tool's button click handler
   *
   * @param toolName - tool type to be activated
   * @param blockDataOverrides - Block data predefined by the activated Toolbox item
   */
  toolButtonActivated(s2, e2) {
    this.insertNewBlock(s2, e2);
  }
  /**
   * Open Toolbox with Tools
   */
  open() {
    var s2;
    this.isEmpty || ((s2 = this.popover) == null || s2.show(), this.opened = true, this.emit(
      "toolbox-opened"
      /* Opened */
    ));
  }
  /**
   * Close Toolbox
   */
  close() {
    var s2;
    (s2 = this.popover) == null || s2.hide(), this.opened = false, this.emit(
      "toolbox-closed"
      /* Closed */
    );
  }
  /**
   * Close Toolbox
   */
  toggle() {
    this.opened ? this.close() : this.open();
  }
  get toolsToBeDisplayed() {
    const s2 = [];
    return this.tools.forEach((e2) => {
      e2.toolbox && s2.push(e2);
    }), s2;
  }
  get toolboxItemsToBeDisplayed() {
    const s2 = (e2, t2) => ({
      icon: e2.icon,
      title: W.t(V.toolNames, e2.title || ae(t2.name)),
      name: t2.name,
      onActivate: () => {
        this.toolButtonActivated(t2.name, e2.data);
      },
      secondaryLabel: t2.shortcut ? Fe(t2.shortcut) : ""
    });
    return this.toolsToBeDisplayed.reduce((e2, t2) => (Array.isArray(t2.toolbox) ? t2.toolbox.forEach((o2) => {
      e2.push(s2(o2, t2));
    }) : t2.toolbox !== void 0 && e2.push(s2(t2.toolbox, t2)), e2), []);
  }
  /**
   * Iterate all tools and enable theirs shortcuts if specified
   */
  enableShortcuts() {
    this.toolsToBeDisplayed.forEach((s2) => {
      const e2 = s2.shortcut;
      e2 && this.enableShortcutForTool(s2.name, e2);
    });
  }
  /**
   * Enable shortcut Block Tool implemented shortcut
   *
   * @param {string} toolName - Tool name
   * @param {string} shortcut - shortcut according to the ShortcutData Module format
   */
  enableShortcutForTool(s2, e2) {
    le.add({
      name: e2,
      on: this.api.ui.nodes.redactor,
      handler: (t2) => {
        t2.preventDefault();
        const o2 = this.api.blocks.getCurrentBlockIndex(), i2 = this.api.blocks.getBlockByIndex(o2);
        if (i2)
          try {
            this.api.blocks.convert(i2.id, s2), window.requestAnimationFrame(() => {
              this.api.caret.setToBlock(o2, "end");
            });
            return;
          } catch {
          }
        this.insertNewBlock(s2);
      }
    });
  }
  /**
   * Removes all added shortcuts
   * Fired when the Read-Only mode is activated
   */
  removeAllShortcuts() {
    this.toolsToBeDisplayed.forEach((s2) => {
      const e2 = s2.shortcut;
      e2 && le.remove(this.api.ui.nodes.redactor, e2);
    });
  }
  /**
   * Inserts new block
   * Can be called when button clicked on Toolbox or by ShortcutData
   *
   * @param {string} toolName - Tool name
   * @param blockDataOverrides - predefined Block data
   */
  async insertNewBlock(s2, e2) {
    const t2 = this.api.blocks.getCurrentBlockIndex(), o2 = this.api.blocks.getBlockByIndex(t2);
    if (!o2)
      return;
    const i2 = o2.isEmpty ? t2 : t2 + 1;
    let n2;
    if (e2) {
      const a2 = await this.api.blocks.composeBlockData(s2);
      n2 = Object.assign(a2, e2);
    }
    const r2 = this.api.blocks.insert(
      s2,
      n2,
      void 0,
      i2,
      void 0,
      o2.isEmpty
    );
    r2.call(Z.APPEND_CALLBACK), this.api.caret.setToBlock(i2), this.emit("toolbox-block-added", {
      block: r2
    }), this.api.toolbar.close();
  }
};
let We = xt;
vt([
  ce
], We.prototype, "toolsToBeDisplayed", 1);
vt([
  ce
], We.prototype, "toolboxItemsToBeDisplayed", 1);
const wt = "block hovered";
class Go extends T {
  /**
   * @class
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    }), this.toolboxInstance = null;
  }
  /**
   * CSS styles
   *
   * @returns {object}
   */
  get CSS() {
    return {
      toolbar: "ce-toolbar",
      content: "ce-toolbar__content",
      actions: "ce-toolbar__actions",
      actionsOpened: "ce-toolbar__actions--opened",
      toolbarOpened: "ce-toolbar--opened",
      openedToolboxHolderModifier: "codex-editor--toolbox-opened",
      plusButton: "ce-toolbar__plus",
      plusButtonShortcut: "ce-toolbar__plus-shortcut",
      settingsToggler: "ce-toolbar__settings-btn",
      settingsTogglerHidden: "ce-toolbar__settings-btn--hidden"
    };
  }
  /**
   * Returns the Toolbar opening state
   *
   * @returns {boolean}
   */
  get opened() {
    return this.nodes.wrapper.classList.contains(this.CSS.toolbarOpened);
  }
  /**
   * Public interface for accessing the Toolbox
   */
  get toolbox() {
    var e2;
    return {
      opened: (e2 = this.toolboxInstance) == null ? void 0 : e2.opened,
      close: () => {
        var t2;
        (t2 = this.toolboxInstance) == null || t2.close();
      },
      open: () => {
        if (this.toolboxInstance === null) {
          L("toolbox.open() called before initialization is finished", "warn");
          return;
        }
        this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.toolboxInstance.open();
      },
      toggle: () => {
        if (this.toolboxInstance === null) {
          L("toolbox.toggle() called before initialization is finished", "warn");
          return;
        }
        this.toolboxInstance.toggle();
      },
      hasFocus: () => {
        var t2;
        return (t2 = this.toolboxInstance) == null ? void 0 : t2.hasFocus();
      }
    };
  }
  /**
   * Block actions appearance manipulations
   */
  get blockActions() {
    return {
      hide: () => {
        this.nodes.actions.classList.remove(this.CSS.actionsOpened);
      },
      show: () => {
        this.nodes.actions.classList.add(this.CSS.actionsOpened);
      }
    };
  }
  /**
   * Methods for working with Block Tunes toggler
   */
  get blockTunesToggler() {
    return {
      hide: () => this.nodes.settingsToggler.classList.add(this.CSS.settingsTogglerHidden),
      show: () => this.nodes.settingsToggler.classList.remove(this.CSS.settingsTogglerHidden)
    };
  }
  /**
   * Toggles read-only mode
   *
   * @param {boolean} readOnlyEnabled - read-only mode
   */
  toggleReadOnly(e2) {
    e2 ? (this.destroy(), this.Editor.BlockSettings.destroy(), this.disableModuleBindings()) : window.requestIdleCallback(() => {
      this.drawUI(), this.enableModuleBindings();
    }, { timeout: 2e3 });
  }
  /**
   * Move Toolbar to the passed (or current) Block
   *
   * @param block - block to move Toolbar near it
   */
  moveAndOpen(e2 = this.Editor.BlockManager.currentBlock) {
    if (this.toolboxInstance === null) {
      L("Can't open Toolbar since Editor initialization is not finished yet", "warn");
      return;
    }
    if (this.toolboxInstance.opened && this.toolboxInstance.close(), this.Editor.BlockSettings.opened && this.Editor.BlockSettings.close(), !e2)
      return;
    this.hoveredBlock = e2;
    const t2 = e2.holder, { isMobile: o2 } = this.Editor.UI, i2 = e2.pluginsContent, n2 = window.getComputedStyle(i2), r2 = parseInt(n2.paddingTop, 10), a2 = t2.offsetHeight;
    let l2;
    o2 ? l2 = t2.offsetTop + a2 : l2 = t2.offsetTop + r2, this.nodes.wrapper.style.top = `${Math.floor(l2)}px`, this.Editor.BlockManager.blocks.length === 1 && e2.isEmpty ? this.blockTunesToggler.hide() : this.blockTunesToggler.show(), this.open();
  }
  /**
   * Close the Toolbar
   */
  close() {
    var e2;
    this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.toolbarOpened), this.blockActions.hide(), (e2 = this.toolboxInstance) == null || e2.close(), this.Editor.BlockSettings.close(), this.reset());
  }
  /**
   * Reset the Toolbar position to prevent DOM height growth, for example after blocks deletion
   */
  reset() {
    this.nodes.wrapper.style.top = "unset";
  }
  /**
   * Open Toolbar with Plus Button and Actions
   *
   * @param {boolean} withBlockActions - by default, Toolbar opens with Block Actions.
   *                                     This flag allows to open Toolbar without Actions.
   */
  open(e2 = true) {
    this.nodes.wrapper.classList.add(this.CSS.toolbarOpened), e2 ? this.blockActions.show() : this.blockActions.hide();
  }
  /**
   * Draws Toolbar elements
   */
  make() {
    this.nodes.wrapper = d.make("div", this.CSS.toolbar), ["content", "actions"].forEach((t2) => {
      this.nodes[t2] = d.make("div", this.CSS[t2]);
    }), d.append(this.nodes.wrapper, this.nodes.content), d.append(this.nodes.content, this.nodes.actions), this.nodes.plusButton = d.make("div", this.CSS.plusButton, {
      innerHTML: Fo
    }), d.append(this.nodes.actions, this.nodes.plusButton), this.readOnlyMutableListeners.on(this.nodes.plusButton, "click", () => {
      Re(true), this.plusButtonClicked();
    }, false);
    const e2 = d.make("div");
    e2.appendChild(document.createTextNode(W.ui(V.ui.toolbar.toolbox, "Add"))), e2.appendChild(d.make("div", this.CSS.plusButtonShortcut, {
      textContent: "⇥ Tab"
    })), be(this.nodes.plusButton, e2, {
      hidingDelay: 400
    }), this.nodes.settingsToggler = d.make("span", this.CSS.settingsToggler, {
      innerHTML: Po
    }), d.append(this.nodes.actions, this.nodes.settingsToggler), be(
      this.nodes.settingsToggler,
      W.ui(V.ui.blockTunes.toggler, "Click to tune"),
      {
        hidingDelay: 400
      }
    ), d.append(this.nodes.actions, this.makeToolbox()), d.append(this.nodes.actions, this.Editor.BlockSettings.getElement()), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper);
  }
  /**
   * Creates the Toolbox instance and return it's rendered element
   */
  makeToolbox() {
    return this.toolboxInstance = new We({
      api: this.Editor.API.methods,
      tools: this.Editor.Tools.blockTools,
      i18nLabels: {
        filter: W.ui(V.ui.popover, "Filter"),
        nothingFound: W.ui(V.ui.popover, "Nothing found")
      }
    }), this.toolboxInstance.on(ve.Opened, () => {
      this.Editor.UI.nodes.wrapper.classList.add(this.CSS.openedToolboxHolderModifier);
    }), this.toolboxInstance.on(ve.Closed, () => {
      this.Editor.UI.nodes.wrapper.classList.remove(this.CSS.openedToolboxHolderModifier);
    }), this.toolboxInstance.on(ve.BlockAdded, ({ block: e2 }) => {
      const { BlockManager: t2, Caret: o2 } = this.Editor, i2 = t2.getBlockById(e2.id);
      i2.inputs.length === 0 && (i2 === t2.lastBlock ? (t2.insertAtEnd(), o2.setToBlock(t2.lastBlock)) : o2.setToBlock(t2.nextBlock));
    }), this.toolboxInstance.make();
  }
  /**
   * Handler for Plus Button
   */
  plusButtonClicked() {
    var e2;
    this.Editor.BlockManager.currentBlock = this.hoveredBlock, (e2 = this.toolboxInstance) == null || e2.toggle();
  }
  /**
   * Enable bindings
   */
  enableModuleBindings() {
    this.readOnlyMutableListeners.on(this.nodes.settingsToggler, "mousedown", (e2) => {
      var t2;
      e2.stopPropagation(), this.settingsTogglerClicked(), (t2 = this.toolboxInstance) != null && t2.opened && this.toolboxInstance.close(), Re(true);
    }, true), oe() || this.eventsDispatcher.on(wt, (e2) => {
      var t2;
      this.Editor.BlockSettings.opened || (t2 = this.toolboxInstance) != null && t2.opened || this.moveAndOpen(e2.block);
    });
  }
  /**
   * Disable bindings
   */
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  /**
   * Clicks on the Block Settings toggler
   */
  settingsTogglerClicked() {
    this.Editor.BlockManager.currentBlock = this.hoveredBlock, this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.BlockSettings.open(this.hoveredBlock);
  }
  /**
   * Draws Toolbar UI
   *
   * Toolbar contains BlockSettings and Toolbox.
   * That's why at first we draw its components and then Toolbar itself
   *
   * Steps:
   *  - Make Toolbar dependent components like BlockSettings, Toolbox and so on
   *  - Make itself and append dependent nodes to itself
   *
   */
  drawUI() {
    this.Editor.BlockSettings.make(), this.make();
  }
  /**
   * Removes all created and saved HTMLElements
   * It is used in Read-Only mode
   */
  destroy() {
    this.removeAllNodes(), this.toolboxInstance && this.toolboxInstance.destroy();
  }
}
var Be = /* @__PURE__ */ ((s2) => (s2[s2.Block = 0] = "Block", s2[s2.Inline = 1] = "Inline", s2[s2.Tune = 2] = "Tune", s2))(Be || {}), xe = /* @__PURE__ */ ((s2) => (s2.Shortcut = "shortcut", s2.Toolbox = "toolbox", s2.EnabledInlineTools = "inlineToolbar", s2.EnabledBlockTunes = "tunes", s2.Config = "config", s2))(xe || {}), yt = /* @__PURE__ */ ((s2) => (s2.Shortcut = "shortcut", s2.SanitizeConfig = "sanitize", s2))(yt || {}), re = /* @__PURE__ */ ((s2) => (s2.IsEnabledLineBreaks = "enableLineBreaks", s2.Toolbox = "toolbox", s2.ConversionConfig = "conversionConfig", s2.IsReadOnlySupported = "isReadOnlySupported", s2.PasteConfig = "pasteConfig", s2))(re || {}), Ye = /* @__PURE__ */ ((s2) => (s2.IsInline = "isInline", s2.Title = "title", s2))(Ye || {}), Et = /* @__PURE__ */ ((s2) => (s2.IsTune = "isTune", s2))(Et || {});
class Ke {
  /**
   * @class
   * @param {ConstructorOptions} options - Constructor options
   */
  constructor({
    name: e2,
    constructable: t2,
    config: o2,
    api: i2,
    isDefault: n2,
    isInternal: r2 = false,
    defaultPlaceholder: a2
  }) {
    this.api = i2, this.name = e2, this.constructable = t2, this.config = o2, this.isDefault = n2, this.isInternal = r2, this.defaultPlaceholder = a2;
  }
  /**
   * Returns Tool user configuration
   */
  get settings() {
    const e2 = this.config.config || {};
    return this.isDefault && !("placeholder" in e2) && this.defaultPlaceholder && (e2.placeholder = this.defaultPlaceholder), e2;
  }
  /**
   * Calls Tool's reset method
   */
  reset() {
    if (D(this.constructable.reset))
      return this.constructable.reset();
  }
  /**
   * Calls Tool's prepare method
   */
  prepare() {
    if (D(this.constructable.prepare))
      return this.constructable.prepare({
        toolName: this.name,
        config: this.settings
      });
  }
  /**
   * Returns shortcut for Tool (internal or specified by user)
   */
  get shortcut() {
    const e2 = this.constructable.shortcut;
    return this.config.shortcut || e2;
  }
  /**
   * Returns Tool's sanitizer configuration
   */
  get sanitizeConfig() {
    return this.constructable.sanitize || {};
  }
  /**
   * Returns true if Tools is inline
   */
  isInline() {
    return this.type === 1;
  }
  /**
   * Returns true if Tools is block
   */
  isBlock() {
    return this.type === 0;
  }
  /**
   * Returns true if Tools is tune
   */
  isTune() {
    return this.type === 2;
  }
}
class Jo extends T {
  /**
   * @class
   * @param moduleConfiguration - Module Configuration
   * @param moduleConfiguration.config - Editor's config
   * @param moduleConfiguration.eventsDispatcher - Editor's event dispatcher
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    }), this.CSS = {
      inlineToolbar: "ce-inline-toolbar",
      inlineToolbarShowed: "ce-inline-toolbar--showed",
      inlineToolbarLeftOriented: "ce-inline-toolbar--left-oriented",
      inlineToolbarRightOriented: "ce-inline-toolbar--right-oriented",
      inlineToolbarShortcut: "ce-inline-toolbar__shortcut",
      buttonsWrapper: "ce-inline-toolbar__buttons",
      actionsWrapper: "ce-inline-toolbar__actions",
      inlineToolButton: "ce-inline-tool",
      inputField: "cdx-input",
      focusedButton: "ce-inline-tool--focused",
      conversionToggler: "ce-inline-toolbar__dropdown",
      conversionTogglerArrow: "ce-inline-toolbar__dropdown-arrow",
      conversionTogglerHidden: "ce-inline-toolbar__dropdown--hidden",
      conversionTogglerContent: "ce-inline-toolbar__dropdown-content",
      togglerAndButtonsWrapper: "ce-inline-toolbar__toggler-and-button-wrapper"
    }, this.opened = false, this.toolbarVerticalMargin = oe() ? 20 : 6, this.buttonsList = null, this.width = 0, this.flipper = null;
  }
  /**
   * Toggles read-only mode
   *
   * @param {boolean} readOnlyEnabled - read-only mode
   */
  toggleReadOnly(e2) {
    e2 ? (this.destroy(), this.Editor.ConversionToolbar.destroy()) : window.requestIdleCallback(() => {
      this.make();
    }, { timeout: 2e3 });
  }
  /**
   *  Moving / appearance
   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   */
  /**
   * Shows Inline Toolbar if something is selected
   *
   * @param [needToClose] - pass true to close toolbar if it is not allowed.
   *                                  Avoid to use it just for closing IT, better call .close() clearly.
   * @param [needToShowConversionToolbar] - pass false to not to show Conversion Toolbar
   */
  tryToShow(e2 = false, t2 = true) {
    if (!this.allowedToShow()) {
      e2 && this.close();
      return;
    }
    this.move(), this.open(t2), this.Editor.Toolbar.close();
  }
  /**
   * Hides Inline Toolbar
   */
  close() {
    this.opened && (this.Editor.ReadOnly.isEnabled || (this.nodes.wrapper.classList.remove(this.CSS.inlineToolbarShowed), Array.from(this.toolsInstances.entries()).forEach(([e2, t2]) => {
      const o2 = this.getToolShortcut(e2);
      o2 && le.remove(this.Editor.UI.nodes.redactor, o2), D(t2.clear) && t2.clear();
    }), this.reset(), this.opened = false, this.flipper.deactivate(), this.Editor.ConversionToolbar.close()));
  }
  /**
   * Shows Inline Toolbar
   *
   * @param [needToShowConversionToolbar] - pass false to not to show Conversion Toolbar
   */
  open(e2 = true) {
    if (this.opened)
      return;
    this.addToolsFiltered(), this.nodes.wrapper.classList.add(this.CSS.inlineToolbarShowed), this.buttonsList = this.nodes.buttons.querySelectorAll(`.${this.CSS.inlineToolButton}`), this.opened = true, e2 && this.Editor.ConversionToolbar.hasTools() ? this.setConversionTogglerContent() : this.nodes.conversionToggler.hidden = true;
    let t2 = Array.from(this.buttonsList);
    t2.unshift(this.nodes.conversionToggler), t2 = t2.filter((o2) => !o2.hidden), this.flipper.activate(t2);
  }
  /**
   * Check if node is contained by Inline Toolbar
   *
   * @param {Node} node — node to check
   */
  containsNode(e2) {
    return this.nodes.wrapper.contains(e2);
  }
  /**
   * Removes UI and its components
   */
  destroy() {
    this.flipper && (this.flipper.deactivate(), this.flipper = null), this.removeAllNodes();
  }
  /**
   * Making DOM
   */
  make() {
    this.nodes.wrapper = d.make("div", [
      this.CSS.inlineToolbar,
      ...this.isRtl ? [this.Editor.UI.CSS.editorRtlFix] : []
    ]), this.nodes.togglerAndButtonsWrapper = d.make("div", this.CSS.togglerAndButtonsWrapper), this.nodes.buttons = d.make("div", this.CSS.buttonsWrapper), this.nodes.actions = d.make("div", this.CSS.actionsWrapper), this.listeners.on(this.nodes.wrapper, "mousedown", (e2) => {
      e2.target.closest(`.${this.CSS.actionsWrapper}`) || e2.preventDefault();
    }), d.append(this.nodes.wrapper, [this.nodes.togglerAndButtonsWrapper, this.nodes.actions]), d.append(this.Editor.UI.nodes.wrapper, this.nodes.wrapper), this.addConversionToggler(), d.append(this.nodes.togglerAndButtonsWrapper, this.nodes.buttons), this.prepareConversionToolbar(), window.requestAnimationFrame(() => {
      this.recalculateWidth();
    }), this.enableFlipper();
  }
  /**
   * Move Toolbar to the selected text
   */
  move() {
    const e2 = m.rect, t2 = this.Editor.UI.nodes.wrapper.getBoundingClientRect(), o2 = {
      x: e2.x - t2.left,
      y: e2.y + e2.height - // + window.scrollY
      t2.top + this.toolbarVerticalMargin
    };
    e2.width && (o2.x += Math.floor(e2.width / 2));
    const i2 = o2.x - this.width / 2, n2 = o2.x + this.width / 2;
    this.nodes.wrapper.classList.toggle(
      this.CSS.inlineToolbarLeftOriented,
      i2 < this.Editor.UI.contentRect.left
    ), this.nodes.wrapper.classList.toggle(
      this.CSS.inlineToolbarRightOriented,
      n2 > this.Editor.UI.contentRect.right
    ), this.nodes.wrapper.style.left = Math.floor(o2.x) + "px", this.nodes.wrapper.style.top = Math.floor(o2.y) + "px";
  }
  /**
   * Clear orientation classes and reset position
   */
  reset() {
    this.nodes.wrapper.classList.remove(
      this.CSS.inlineToolbarLeftOriented,
      this.CSS.inlineToolbarRightOriented
    ), this.nodes.wrapper.style.left = "unset", this.nodes.wrapper.style.top = "unset";
  }
  /**
   * Need to show Inline Toolbar or not
   */
  allowedToShow() {
    const e2 = ["IMG", "INPUT"], t2 = m.get(), o2 = m.text;
    if (!t2 || !t2.anchorNode || t2.isCollapsed || o2.length < 1)
      return false;
    const i2 = d.isElement(t2.anchorNode) ? t2.anchorNode : t2.anchorNode.parentElement;
    if (t2 && e2.includes(i2.tagName) || i2.closest('[contenteditable="true"]') === null)
      return false;
    const r2 = this.Editor.BlockManager.getBlock(t2.anchorNode);
    return r2 ? r2.tool.inlineTools.size !== 0 : false;
  }
  /**
   * Recalculate inline toolbar width
   */
  recalculateWidth() {
    this.width = this.nodes.wrapper.offsetWidth;
  }
  /**
   * Create a toggler for Conversion Dropdown
   * and prepend it to the buttons list
   */
  addConversionToggler() {
    this.nodes.conversionToggler = d.make("div", this.CSS.conversionToggler), this.nodes.conversionTogglerContent = d.make("div", this.CSS.conversionTogglerContent);
    const e2 = d.make("div", this.CSS.conversionTogglerArrow, {
      innerHTML: mt
    });
    this.nodes.conversionToggler.appendChild(this.nodes.conversionTogglerContent), this.nodes.conversionToggler.appendChild(e2), this.nodes.togglerAndButtonsWrapper.appendChild(this.nodes.conversionToggler), this.listeners.on(this.nodes.conversionToggler, "click", () => {
      this.Editor.ConversionToolbar.toggle((t2) => {
        !t2 && this.opened ? this.flipper.activate() : this.opened && this.flipper.deactivate();
      });
    }), oe() === false && be(this.nodes.conversionToggler, W.ui(V.ui.inlineToolbar.converter, "Convert to"), {
      placement: "top",
      hidingDelay: 100
    });
  }
  /**
   * Changes Conversion Dropdown content for current block's Tool
   */
  async setConversionTogglerContent() {
    const { BlockManager: e2 } = this.Editor, { currentBlock: t2 } = e2, o2 = t2.name, i2 = t2.tool.conversionConfig, n2 = i2 && i2.export;
    this.nodes.conversionToggler.hidden = !n2, this.nodes.conversionToggler.classList.toggle(this.CSS.conversionTogglerHidden, !n2);
    const r2 = await t2.getActiveToolboxEntry() || {};
    this.nodes.conversionTogglerContent.innerHTML = r2.icon || r2.title || ae(o2);
  }
  /**
   * Makes the Conversion Dropdown
   */
  prepareConversionToolbar() {
    const e2 = this.Editor.ConversionToolbar.make();
    d.append(this.nodes.wrapper, e2);
  }
  /**
   *  Working with Tools
   *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
   */
  /**
   * Append only allowed Tools
   */
  addToolsFiltered() {
    const e2 = m.get(), t2 = this.Editor.BlockManager.getBlock(e2.anchorNode);
    this.nodes.buttons.innerHTML = "", this.nodes.actions.innerHTML = "", this.toolsInstances = /* @__PURE__ */ new Map(), Array.from(t2.tool.inlineTools.values()).forEach((o2) => {
      this.addTool(o2);
    }), this.recalculateWidth();
  }
  /**
   * Add tool button and activate clicks
   *
   * @param {InlineTool} tool - InlineTool object
   */
  addTool(e2) {
    const t2 = e2.create(), o2 = t2.render();
    if (!o2) {
      L("Render method must return an instance of Node", "warn", e2.name);
      return;
    }
    if (o2.dataset.tool = e2.name, this.nodes.buttons.appendChild(o2), this.toolsInstances.set(e2.name, t2), D(t2.renderActions)) {
      const a2 = t2.renderActions();
      this.nodes.actions.appendChild(a2);
    }
    this.listeners.on(o2, "click", (a2) => {
      this.toolClicked(t2), a2.preventDefault();
    });
    const i2 = this.getToolShortcut(e2.name);
    if (i2)
      try {
        this.enableShortcuts(t2, i2);
      } catch {
      }
    const n2 = d.make("div"), r2 = W.t(
      V.toolNames,
      e2.title || ae(e2.name)
    );
    n2.appendChild(d.text(r2)), i2 && n2.appendChild(d.make("div", this.CSS.inlineToolbarShortcut, {
      textContent: Fe(i2)
    })), oe() === false && be(o2, n2, {
      placement: "top",
      hidingDelay: 100
    }), t2.checkState(m.get());
  }
  /**
   * Get shortcut name for tool
   *
   * @param toolName — Tool name
   */
  getToolShortcut(e2) {
    const { Tools: t2 } = this.Editor, o2 = t2.inlineTools.get(e2), i2 = t2.internal.inlineTools;
    return Array.from(i2.keys()).includes(e2) ? this.inlineTools[e2][yt.Shortcut] : o2.shortcut;
  }
  /**
   * Enable Tool shortcut with Editor Shortcuts Module
   *
   * @param {InlineTool} tool - Tool instance
   * @param {string} shortcut - shortcut according to the ShortcutData Module format
   */
  enableShortcuts(e2, t2) {
    le.add({
      name: t2,
      handler: (o2) => {
        const { currentBlock: i2 } = this.Editor.BlockManager;
        i2 && i2.tool.enabledInlineTools && (o2.preventDefault(), this.toolClicked(e2));
      },
      on: this.Editor.UI.nodes.redactor
    });
  }
  /**
   * Inline Tool button clicks
   *
   * @param {InlineTool} tool - Tool's instance
   */
  toolClicked(e2) {
    const t2 = m.range;
    e2.surround(t2), this.checkToolsState(), e2.renderActions !== void 0 && this.flipper.deactivate();
  }
  /**
   * Check Tools` state by selection
   */
  checkToolsState() {
    this.toolsInstances.forEach((e2) => {
      e2.checkState(m.get());
    });
  }
  /**
   * Get inline tools tools
   * Tools that has isInline is true
   */
  get inlineTools() {
    const e2 = {};
    return Array.from(this.Editor.Tools.inlineTools.entries()).forEach(([t2, o2]) => {
      e2[t2] = o2.create();
    }), e2;
  }
  /**
   * Allow to leaf buttons by arrows / tab
   * Buttons will be filled on opening
   */
  enableFlipper() {
    this.flipper = new J({
      focusedItemClass: this.CSS.focusedButton,
      allowedKeys: [
        B.ENTER,
        B.TAB
      ]
    });
  }
}
class Qo extends T {
  /**
   * All keydowns on Block
   *
   * @param {KeyboardEvent} event - keydown
   */
  keydown(e2) {
    switch (this.beforeKeydownProcessing(e2), e2.keyCode) {
      case B.BACKSPACE:
        this.backspace(e2);
        break;
      case B.DELETE:
        this.delete(e2);
        break;
      case B.ENTER:
        this.enter(e2);
        break;
      case B.DOWN:
      case B.RIGHT:
        this.arrowRightAndDown(e2);
        break;
      case B.UP:
      case B.LEFT:
        this.arrowLeftAndUp(e2);
        break;
      case B.TAB:
        this.tabPressed(e2);
        break;
    }
  }
  /**
   * Fires on keydown before event processing
   *
   * @param {KeyboardEvent} event - keydown
   */
  beforeKeydownProcessing(e2) {
    this.needToolbarClosing(e2) && at(e2.keyCode) && (this.Editor.Toolbar.close(), this.Editor.ConversionToolbar.close(), e2.ctrlKey || e2.metaKey || e2.altKey || e2.shiftKey || (this.Editor.BlockManager.clearFocused(), this.Editor.BlockSelection.clearSelection(e2)));
  }
  /**
   * Key up on Block:
   * - shows Inline Toolbar if something selected
   * - shows conversion toolbar with 85% of block selection
   *
   * @param {KeyboardEvent} event - keyup event
   */
  keyup(e2) {
    e2.shiftKey || this.Editor.UI.checkEmptiness();
  }
  /**
   * Open Toolbox to leaf Tools
   *
   * @param {KeyboardEvent} event - tab keydown event
   */
  tabPressed(e2) {
    this.Editor.BlockSelection.clearSelection(e2);
    const { BlockManager: t2, InlineToolbar: o2, ConversionToolbar: i2 } = this.Editor, n2 = t2.currentBlock;
    if (!n2)
      return;
    const r2 = n2.isEmpty, a2 = n2.tool.isDefault && r2, l2 = !r2 && i2.opened, c2 = !r2 && !m.isCollapsed && o2.opened;
    a2 ? this.activateToolbox() : !l2 && !c2 && this.activateBlockSettings();
  }
  /**
   * Add drop target styles
   *
   * @param {DragEvent} event - drag over event
   */
  dragOver(e2) {
    const t2 = this.Editor.BlockManager.getBlockByChildNode(e2.target);
    t2.dropTarget = true;
  }
  /**
   * Remove drop target style
   *
   * @param {DragEvent} event - drag leave event
   */
  dragLeave(e2) {
    const t2 = this.Editor.BlockManager.getBlockByChildNode(e2.target);
    t2.dropTarget = false;
  }
  /**
   * Copying selected blocks
   * Before putting to the clipboard we sanitize all blocks and then copy to the clipboard
   *
   * @param {ClipboardEvent} event - clipboard event
   */
  handleCommandC(e2) {
    const { BlockSelection: t2 } = this.Editor;
    t2.anyBlockSelected && t2.copySelectedBlocks(e2);
  }
  /**
   * Copy and Delete selected Blocks
   *
   * @param {ClipboardEvent} event - clipboard event
   */
  handleCommandX(e2) {
    const { BlockSelection: t2, BlockManager: o2, Caret: i2 } = this.Editor;
    t2.anyBlockSelected && t2.copySelectedBlocks(e2).then(() => {
      const n2 = o2.removeSelectedBlocks(), r2 = o2.insertDefaultBlockAtIndex(n2, true);
      i2.setToBlock(r2, i2.positions.START), t2.clearSelection(e2);
    });
  }
  /**
   * ENTER pressed on block
   *
   * @param {KeyboardEvent} event - keydown
   */
  enter(e2) {
    const { BlockManager: t2, UI: o2 } = this.Editor;
    if (t2.currentBlock.tool.isLineBreaksEnabled || o2.someToolbarOpened && o2.someFlipperButtonFocused || e2.shiftKey)
      return;
    let n2 = this.Editor.BlockManager.currentBlock;
    this.Editor.Caret.isAtStart && !this.Editor.BlockManager.currentBlock.hasMedia ? this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex) : this.Editor.Caret.isAtEnd ? n2 = this.Editor.BlockManager.insertDefaultBlockAtIndex(this.Editor.BlockManager.currentBlockIndex + 1) : n2 = this.Editor.BlockManager.split(), this.Editor.Caret.setToBlock(n2), this.Editor.Toolbar.moveAndOpen(n2), e2.preventDefault();
  }
  /**
   * Handle backspace keydown on Block
   *
   * @param {KeyboardEvent} event - keydown
   */
  backspace(e2) {
    const { BlockManager: t2, Caret: o2 } = this.Editor, { currentBlock: i2, previousBlock: n2 } = t2;
    if (!m.isCollapsed || !o2.isAtStart)
      return;
    if (e2.preventDefault(), this.Editor.Toolbar.close(), !(i2.currentInput === i2.firstInput)) {
      o2.navigatePrevious();
      return;
    }
    if (n2 === null)
      return;
    if (n2.isEmpty) {
      t2.removeBlock(n2);
      return;
    }
    if (i2.isEmpty) {
      t2.removeBlock(i2);
      const l2 = t2.currentBlock;
      o2.setToBlock(l2, o2.positions.END);
      return;
    }
    tt(i2, n2) ? this.mergeBlocks(n2, i2) : o2.setToBlock(n2, o2.positions.END);
  }
  /**
   * Handles delete keydown on Block
   * Removes char after the caret.
   * If caret is at the end of the block, merge next block with current
   *
   * @param {KeyboardEvent} event - keydown
   */
  delete(e2) {
    const { BlockManager: t2, Caret: o2 } = this.Editor, { currentBlock: i2, nextBlock: n2 } = t2;
    if (!m.isCollapsed || !o2.isAtEnd)
      return;
    if (e2.preventDefault(), this.Editor.Toolbar.close(), !(i2.currentInput === i2.lastInput)) {
      o2.navigateNext();
      return;
    }
    if (n2 === null)
      return;
    if (n2.isEmpty) {
      t2.removeBlock(n2);
      return;
    }
    if (i2.isEmpty) {
      t2.removeBlock(i2), o2.setToBlock(n2, o2.positions.START);
      return;
    }
    tt(i2, n2) ? this.mergeBlocks(i2, n2) : o2.setToBlock(n2, o2.positions.START);
  }
  /**
   * Merge passed Blocks
   *
   * @param targetBlock - to which Block we want to merge
   * @param blockToMerge - what Block we want to merge
   */
  mergeBlocks(e2, t2) {
    const { BlockManager: o2, Caret: i2, Toolbar: n2 } = this.Editor;
    i2.createShadow(e2.pluginsContent), o2.mergeBlocks(e2, t2).then(() => {
      window.requestAnimationFrame(() => {
        i2.restoreCaret(e2.pluginsContent), e2.pluginsContent.normalize(), n2.close();
      });
    });
  }
  /**
   * Handle right and down keyboard keys
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  arrowRightAndDown(e2) {
    const t2 = J.usedKeys.includes(e2.keyCode) && (!e2.shiftKey || e2.keyCode === B.TAB);
    if (this.Editor.UI.someToolbarOpened && t2)
      return;
    this.Editor.BlockManager.clearFocused(), this.Editor.Toolbar.close();
    const o2 = this.Editor.Caret.isAtEnd || this.Editor.BlockSelection.anyBlockSelected;
    if (e2.shiftKey && e2.keyCode === B.DOWN && o2) {
      this.Editor.CrossBlockSelection.toggleBlockSelectedState();
      return;
    }
    (e2.keyCode === B.DOWN || e2.keyCode === B.RIGHT && !this.isRtl ? this.Editor.Caret.navigateNext() : this.Editor.Caret.navigatePrevious()) ? e2.preventDefault() : ge(() => {
      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
    }, 20)(), this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * Handle left and up keyboard keys
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  arrowLeftAndUp(e2) {
    if (this.Editor.UI.someToolbarOpened) {
      if (J.usedKeys.includes(e2.keyCode) && (!e2.shiftKey || e2.keyCode === B.TAB))
        return;
      this.Editor.UI.closeAllToolbars();
    }
    this.Editor.BlockManager.clearFocused(), this.Editor.Toolbar.close();
    const t2 = this.Editor.Caret.isAtStart || this.Editor.BlockSelection.anyBlockSelected;
    if (e2.shiftKey && e2.keyCode === B.UP && t2) {
      this.Editor.CrossBlockSelection.toggleBlockSelectedState(false);
      return;
    }
    (e2.keyCode === B.UP || e2.keyCode === B.LEFT && !this.isRtl ? this.Editor.Caret.navigatePrevious() : this.Editor.Caret.navigateNext()) ? e2.preventDefault() : ge(() => {
      this.Editor.BlockManager.currentBlock && this.Editor.BlockManager.currentBlock.updateCurrentInput();
    }, 20)(), this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * Cases when we need to close Toolbar
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  needToolbarClosing(e2) {
    const t2 = e2.keyCode === B.ENTER && this.Editor.Toolbar.toolbox.opened, o2 = e2.keyCode === B.ENTER && this.Editor.BlockSettings.opened, i2 = e2.keyCode === B.ENTER && this.Editor.InlineToolbar.opened, n2 = e2.keyCode === B.ENTER && this.Editor.ConversionToolbar.opened, r2 = e2.keyCode === B.TAB;
    return !(e2.shiftKey || r2 || t2 || o2 || i2 || n2);
  }
  /**
   * If Toolbox is not open, then just open it and show plus button
   */
  activateToolbox() {
    this.Editor.Toolbar.opened || this.Editor.Toolbar.moveAndOpen(), this.Editor.Toolbar.toolbox.open();
  }
  /**
   * Open Toolbar and show BlockSettings before flipping Tools
   */
  activateBlockSettings() {
    this.Editor.Toolbar.opened || (this.Editor.BlockManager.currentBlock.focused = true, this.Editor.Toolbar.moveAndOpen()), this.Editor.BlockSettings.opened || this.Editor.BlockSettings.open();
  }
}
class Se {
  /**
   * @class
   * @param {HTMLElement} workingArea — editor`s working node
   */
  constructor(e2) {
    this.blocks = [], this.workingArea = e2;
  }
  /**
   * Get length of Block instances array
   *
   * @returns {number}
   */
  get length() {
    return this.blocks.length;
  }
  /**
   * Get Block instances array
   *
   * @returns {Block[]}
   */
  get array() {
    return this.blocks;
  }
  /**
   * Get blocks html elements array
   *
   * @returns {HTMLElement[]}
   */
  get nodes() {
    return lt(this.workingArea.children);
  }
  /**
   * Proxy trap to implement array-like setter
   *
   * @example
   * blocks[0] = new Block(...)
   * @param {Blocks} instance — Blocks instance
   * @param {PropertyKey} property — block index or any Blocks class property key to set
   * @param {Block} value — value to set
   * @returns {boolean}
   */
  static set(e2, t2, o2) {
    return isNaN(Number(t2)) ? (Reflect.set(e2, t2, o2), true) : (e2.insert(+t2, o2), true);
  }
  /**
   * Proxy trap to implement array-like getter
   *
   * @param {Blocks} instance — Blocks instance
   * @param {PropertyKey} property — Blocks class property key
   * @returns {Block|*}
   */
  static get(e2, t2) {
    return isNaN(Number(t2)) ? Reflect.get(e2, t2) : e2.get(+t2);
  }
  /**
   * Push new Block to the blocks array and append it to working area
   *
   * @param {Block} block - Block to add
   */
  push(e2) {
    this.blocks.push(e2), this.insertToDOM(e2);
  }
  /**
   * Swaps blocks with indexes first and second
   *
   * @param {number} first - first block index
   * @param {number} second - second block index
   * @deprecated — use 'move' instead
   */
  swap(e2, t2) {
    const o2 = this.blocks[t2];
    d.swap(this.blocks[e2].holder, o2.holder), this.blocks[t2] = this.blocks[e2], this.blocks[e2] = o2;
  }
  /**
   * Move a block from one to another index
   *
   * @param {number} toIndex - new index of the block
   * @param {number} fromIndex - block to move
   */
  move(e2, t2) {
    const o2 = this.blocks.splice(t2, 1)[0], i2 = e2 - 1, n2 = Math.max(0, i2), r2 = this.blocks[n2];
    e2 > 0 ? this.insertToDOM(o2, "afterend", r2) : this.insertToDOM(o2, "beforebegin", r2), this.blocks.splice(e2, 0, o2);
    const a2 = this.composeBlockEvent("move", {
      fromIndex: t2,
      toIndex: e2
    });
    o2.call(Z.MOVED, a2);
  }
  /**
   * Insert new Block at passed index
   *
   * @param {number} index — index to insert Block
   * @param {Block} block — Block to insert
   * @param {boolean} replace — it true, replace block on given index
   */
  insert(e2, t2, o2 = false) {
    if (!this.length) {
      this.push(t2);
      return;
    }
    e2 > this.length && (e2 = this.length), o2 && (this.blocks[e2].holder.remove(), this.blocks[e2].call(Z.REMOVED));
    const i2 = o2 ? 1 : 0;
    if (this.blocks.splice(e2, i2, t2), e2 > 0) {
      const n2 = this.blocks[e2 - 1];
      this.insertToDOM(t2, "afterend", n2);
    } else {
      const n2 = this.blocks[e2 + 1];
      n2 ? this.insertToDOM(t2, "beforebegin", n2) : this.insertToDOM(t2);
    }
  }
  /**
   * Replaces block under passed index with passed block
   *
   * @param index - index of existed block
   * @param block - new block
   */
  replace(e2, t2) {
    if (this.blocks[e2] === void 0)
      throw Error("Incorrect index");
    this.blocks[e2].holder.replaceWith(t2.holder), this.blocks[e2] = t2;
  }
  /**
   * Inserts several blocks at once
   *
   * @param blocks - blocks to insert
   * @param index - index to insert blocks at
   */
  insertMany(e2, t2) {
    const o2 = new DocumentFragment();
    for (const i2 of e2)
      o2.appendChild(i2.holder);
    if (this.length > 0) {
      if (t2 > 0) {
        const i2 = Math.min(t2 - 1, this.length - 1);
        this.blocks[i2].holder.after(o2);
      } else
        t2 === 0 && this.workingArea.prepend(o2);
      this.blocks.splice(t2, 0, ...e2);
    } else
      this.blocks.push(...e2), this.workingArea.appendChild(o2);
    e2.forEach((i2) => i2.call(Z.RENDERED));
  }
  /**
   * Remove block
   *
   * @param {number} index - index of Block to remove
   */
  remove(e2) {
    isNaN(e2) && (e2 = this.length - 1), this.blocks[e2].holder.remove(), this.blocks[e2].call(Z.REMOVED), this.blocks.splice(e2, 1);
  }
  /**
   * Remove all blocks
   */
  removeAll() {
    this.workingArea.innerHTML = "", this.blocks.forEach((e2) => e2.call(Z.REMOVED)), this.blocks.length = 0;
  }
  /**
   * Insert Block after passed target
   *
   * @todo decide if this method is necessary
   * @param {Block} targetBlock — target after which Block should be inserted
   * @param {Block} newBlock — Block to insert
   */
  insertAfter(e2, t2) {
    const o2 = this.blocks.indexOf(e2);
    this.insert(o2 + 1, t2);
  }
  /**
   * Get Block by index
   *
   * @param {number} index — Block index
   * @returns {Block}
   */
  get(e2) {
    return this.blocks[e2];
  }
  /**
   * Return index of passed Block
   *
   * @param {Block} block - Block to find
   * @returns {number}
   */
  indexOf(e2) {
    return this.blocks.indexOf(e2);
  }
  /**
   * Insert new Block into DOM
   *
   * @param {Block} block - Block to insert
   * @param {InsertPosition} position — insert position (if set, will use insertAdjacentElement)
   * @param {Block} target — Block related to position
   */
  insertToDOM(e2, t2, o2) {
    t2 ? o2.holder.insertAdjacentElement(t2, e2.holder) : this.workingArea.appendChild(e2.holder), e2.call(Z.RENDERED);
  }
  /**
   * Composes Block event with passed type and details
   *
   * @param {string} type - event type
   * @param {object} detail - event detail
   */
  composeBlockEvent(e2, t2) {
    return new CustomEvent(e2, {
      detail: t2
    });
  }
}
const it = "block-removed", nt = "block-added", ei = "block-moved", st = "block-changed";
class ti {
  constructor() {
    this.completed = Promise.resolve();
  }
  /**
   * Add new promise to queue
   *
   * @param operation - promise should be added to queue
   */
  add(e2) {
    return new Promise((t2, o2) => {
      this.completed = this.completed.then(e2).then(t2).catch(o2);
    });
  }
}
class oi extends T {
  constructor() {
    super(...arguments), this._currentBlockIndex = -1, this._blocks = null;
  }
  /**
   * Returns current Block index
   *
   * @returns {number}
   */
  get currentBlockIndex() {
    return this._currentBlockIndex;
  }
  /**
   * Set current Block index and fire Block lifecycle callbacks
   *
   * @param {number} newIndex - index of Block to set as current
   */
  set currentBlockIndex(e2) {
    this._currentBlockIndex = e2;
  }
  /**
   * returns first Block
   *
   * @returns {Block}
   */
  get firstBlock() {
    return this._blocks[0];
  }
  /**
   * returns last Block
   *
   * @returns {Block}
   */
  get lastBlock() {
    return this._blocks[this._blocks.length - 1];
  }
  /**
   * Get current Block instance
   *
   * @returns {Block}
   */
  get currentBlock() {
    return this._blocks[this.currentBlockIndex];
  }
  /**
   * Set passed Block as a current
   *
   * @param block - block to set as a current
   */
  set currentBlock(e2) {
    this.currentBlockIndex = this.getBlockIndex(e2);
  }
  /**
   * Returns next Block instance
   *
   * @returns {Block|null}
   */
  get nextBlock() {
    return this.currentBlockIndex === this._blocks.length - 1 ? null : this._blocks[this.currentBlockIndex + 1];
  }
  /**
   * Return first Block with inputs after current Block
   *
   * @returns {Block | undefined}
   */
  get nextContentfulBlock() {
    return this.blocks.slice(this.currentBlockIndex + 1).find((t2) => !!t2.inputs.length);
  }
  /**
   * Return first Block with inputs before current Block
   *
   * @returns {Block | undefined}
   */
  get previousContentfulBlock() {
    return this.blocks.slice(0, this.currentBlockIndex).reverse().find((t2) => !!t2.inputs.length);
  }
  /**
   * Returns previous Block instance
   *
   * @returns {Block|null}
   */
  get previousBlock() {
    return this.currentBlockIndex === 0 ? null : this._blocks[this.currentBlockIndex - 1];
  }
  /**
   * Get array of Block instances
   *
   * @returns {Block[]} {@link Blocks#array}
   */
  get blocks() {
    return this._blocks.array;
  }
  /**
   * Check if each Block is empty
   *
   * @returns {boolean}
   */
  get isEditorEmpty() {
    return this.blocks.every((e2) => e2.isEmpty);
  }
  /**
   * Should be called after Editor.UI preparation
   * Define this._blocks property
   */
  prepare() {
    const e2 = new Se(this.Editor.UI.nodes.redactor);
    this._blocks = new Proxy(e2, {
      set: Se.set,
      get: Se.get
    }), this.listeners.on(
      document,
      "copy",
      (t2) => this.Editor.BlockEvents.handleCommandC(t2)
    );
  }
  /**
   * Toggle read-only state
   *
   * If readOnly is true:
   *  - Unbind event handlers from created Blocks
   *
   * if readOnly is false:
   *  - Bind event handlers to all existing Blocks
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */
  toggleReadOnly(e2) {
    e2 ? this.disableModuleBindings() : this.enableModuleBindings();
  }
  /**
   * Creates Block instance by tool name
   *
   * @param {object} options - block creation options
   * @param {string} options.tool - tools passed in editor config {@link EditorConfig#tools}
   * @param {string} [options.id] - unique id for this block
   * @param {BlockToolData} [options.data] - constructor params
   * @returns {Block}
   */
  composeBlock({
    tool: e2,
    data: t2 = {},
    id: o2 = void 0,
    tunes: i2 = {}
  }) {
    const n2 = this.Editor.ReadOnly.isEnabled, r2 = this.Editor.Tools.blockTools.get(e2), a2 = new F({
      id: o2,
      data: t2,
      tool: r2,
      api: this.Editor.API,
      readOnly: n2,
      tunesData: i2
    }, this.eventsDispatcher);
    return n2 || window.requestIdleCallback(() => {
      this.bindBlockEvents(a2);
    }, { timeout: 2e3 }), a2;
  }
  /**
   * Insert new block into _blocks
   *
   * @param {object} options - insert options
   * @param {string} [options.id] - block's unique id
   * @param {string} [options.tool] - plugin name, by default method inserts the default block type
   * @param {object} [options.data] - plugin data
   * @param {number} [options.index] - index where to insert new Block
   * @param {boolean} [options.needToFocus] - flag shows if needed to update current Block index
   * @param {boolean} [options.replace] - flag shows if block by passed index should be replaced with inserted one
   * @returns {Block}
   */
  insert({
    id: e2 = void 0,
    tool: t2 = this.config.defaultBlock,
    data: o2 = {},
    index: i2,
    needToFocus: n2 = true,
    replace: r2 = false,
    tunes: a2 = {}
  } = {}) {
    let l2 = i2;
    l2 === void 0 && (l2 = this.currentBlockIndex + (r2 ? 0 : 1));
    const c2 = this.composeBlock({
      id: e2,
      tool: t2,
      data: o2,
      tunes: a2
    });
    return r2 && this.blockDidMutated(it, this.getBlockByIndex(l2), {
      index: l2
    }), this._blocks.insert(l2, c2, r2), this.blockDidMutated(nt, c2, {
      index: l2
    }), n2 ? this.currentBlockIndex = l2 : l2 <= this.currentBlockIndex && this.currentBlockIndex++, c2;
  }
  /**
   * Inserts several blocks at once
   *
   * @param blocks - blocks to insert
   * @param index - index where to insert
   */
  insertMany(e2, t2 = 0) {
    this._blocks.insertMany(e2, t2);
  }
  /**
   * Update Block data.
   *
   * Currently we don't have an 'update' method in the Tools API, so we just create a new block with the same id and type
   * Should not trigger 'block-removed' or 'block-added' events
   *
   * @param block - block to update
   * @param data - new data
   */
  async update(e2, t2) {
    const o2 = await e2.data, i2 = this.composeBlock({
      id: e2.id,
      tool: e2.name,
      data: Object.assign({}, o2, t2),
      tunes: e2.tunes
    }), n2 = this.getBlockIndex(e2);
    return this._blocks.replace(n2, i2), this.blockDidMutated(st, i2, {
      index: n2
    }), i2;
  }
  /**
   * Replace passed Block with the new one with specified Tool and data
   *
   * @param block - block to replace
   * @param newTool - new Tool name
   * @param data - new Tool data
   */
  replace(e2, t2, o2) {
    const i2 = this.getBlockIndex(e2);
    this.insert({
      tool: t2,
      data: o2,
      index: i2,
      replace: true
    });
  }
  /**
   * Insert pasted content. Call onPaste callback after insert.
   *
   * @param {string} toolName - name of Tool to insert
   * @param {PasteEvent} pasteEvent - pasted data
   * @param {boolean} replace - should replace current block
   */
  paste(e2, t2, o2 = false) {
    const i2 = this.insert({
      tool: e2,
      replace: o2
    });
    try {
      window.requestIdleCallback(() => {
        i2.call(Z.ON_PASTE, t2);
      });
    } catch (n2) {
      L(`${e2}: onPaste callback call is failed`, "error", n2);
    }
    return i2;
  }
  /**
   * Insert new default block at passed index
   *
   * @param {number} index - index where Block should be inserted
   * @param {boolean} needToFocus - if true, updates current Block index
   *
   * TODO: Remove method and use insert() with index instead (?)
   * @returns {Block} inserted Block
   */
  insertDefaultBlockAtIndex(e2, t2 = false) {
    const o2 = this.composeBlock({ tool: this.config.defaultBlock });
    return this._blocks[e2] = o2, this.blockDidMutated(nt, o2, {
      index: e2
    }), t2 ? this.currentBlockIndex = e2 : e2 <= this.currentBlockIndex && this.currentBlockIndex++, o2;
  }
  /**
   * Always inserts at the end
   *
   * @returns {Block}
   */
  insertAtEnd() {
    return this.currentBlockIndex = this.blocks.length - 1, this.insert();
  }
  /**
   * Merge two blocks
   *
   * @param {Block} targetBlock - previous block will be append to this block
   * @param {Block} blockToMerge - block that will be merged with target block
   * @returns {Promise} - the sequence that can be continued
   */
  async mergeBlocks(e2, t2) {
    const o2 = await t2.data;
    q(o2) || await e2.mergeWith(o2), this.removeBlock(t2), this.currentBlockIndex = this._blocks.indexOf(e2);
  }
  /**
   * Remove passed Block
   *
   * @param block - Block to remove
   * @param addLastBlock - if true, adds new default block at the end. @todo remove this logic and use event-bus instead
   */
  removeBlock(e2, t2 = true) {
    return new Promise((o2) => {
      const i2 = this._blocks.indexOf(e2);
      if (!this.validateIndex(i2))
        throw new Error("Can't find a Block to remove");
      e2.destroy(), this._blocks.remove(i2), this.blockDidMutated(it, e2, {
        index: i2
      }), this.currentBlockIndex >= i2 && this.currentBlockIndex--, this.blocks.length ? i2 === 0 && (this.currentBlockIndex = 0) : (this.currentBlockIndex = -1, t2 && this.insert()), o2();
    });
  }
  /**
   * Remove only selected Blocks
   * and returns first Block index where started removing...
   *
   * @returns {number|undefined}
   */
  removeSelectedBlocks() {
    let e2;
    for (let t2 = this.blocks.length - 1; t2 >= 0; t2--)
      this.blocks[t2].selected && (this.removeBlock(this.blocks[t2]), e2 = t2);
    return e2;
  }
  /**
   * Attention!
   * After removing insert the new default typed Block and focus on it
   * Removes all blocks
   */
  removeAllBlocks() {
    for (let e2 = this.blocks.length - 1; e2 >= 0; e2--)
      this._blocks.remove(e2);
    this.currentBlockIndex = -1, this.insert(), this.currentBlock.firstInput.focus();
  }
  /**
   * Split current Block
   * 1. Extract content from Caret position to the Block`s end
   * 2. Insert a new Block below current one with extracted content
   *
   * @returns {Block}
   */
  split() {
    const e2 = this.Editor.Caret.extractFragmentFromCaretPosition(), t2 = d.make("div");
    t2.appendChild(e2);
    const o2 = {
      text: d.isEmpty(t2) ? "" : t2.innerHTML
    };
    return this.insert({ data: o2 });
  }
  /**
   * Returns Block by passed index
   *
   * @param {number} index - index to get. -1 to get last
   * @returns {Block}
   */
  getBlockByIndex(e2) {
    return e2 === -1 && (e2 = this._blocks.length - 1), this._blocks[e2];
  }
  /**
   * Returns an index for passed Block
   *
   * @param block - block to find index
   */
  getBlockIndex(e2) {
    return this._blocks.indexOf(e2);
  }
  /**
   * Returns the Block by passed id
   *
   * @param id - id of block to get
   * @returns {Block}
   */
  getBlockById(e2) {
    return this._blocks.array.find((t2) => t2.id === e2);
  }
  /**
   * Get Block instance by html element
   *
   * @param {Node} element - html element to get Block by
   */
  getBlock(e2) {
    d.isElement(e2) || (e2 = e2.parentNode);
    const t2 = this._blocks.nodes, o2 = e2.closest(`.${F.CSS.wrapper}`), i2 = t2.indexOf(o2);
    if (i2 >= 0)
      return this._blocks[i2];
  }
  /**
   * Remove selection from all Blocks then highlight only Current Block
   */
  highlightCurrentNode() {
    this.clearFocused(), this.currentBlock.focused = true;
  }
  /**
   * Remove selection from all Blocks
   */
  clearFocused() {
    this.blocks.forEach((e2) => {
      e2.focused = false;
    });
  }
  /**
   * 1) Find first-level Block from passed child Node
   * 2) Mark it as current
   *
   * @param {Node} childNode - look ahead from this node.
   * @returns {Block | undefined} can return undefined in case when the passed child note is not a part of the current editor instance
   */
  setCurrentBlockByChildNode(e2) {
    d.isElement(e2) || (e2 = e2.parentNode);
    const t2 = e2.closest(`.${F.CSS.wrapper}`);
    if (!t2)
      return;
    const o2 = t2.closest(`.${this.Editor.UI.CSS.editorWrapper}`);
    if (o2 != null && o2.isEqualNode(this.Editor.UI.nodes.wrapper))
      return this.currentBlockIndex = this._blocks.nodes.indexOf(t2), this.currentBlock.updateCurrentInput(), this.currentBlock;
  }
  /**
   * Return block which contents passed node
   *
   * @param {Node} childNode - node to get Block by
   * @returns {Block}
   */
  getBlockByChildNode(e2) {
    d.isElement(e2) || (e2 = e2.parentNode);
    const t2 = e2.closest(`.${F.CSS.wrapper}`);
    return this.blocks.find((o2) => o2.holder === t2);
  }
  /**
   * Swap Blocks Position
   *
   * @param {number} fromIndex - index of first block
   * @param {number} toIndex - index of second block
   * @deprecated — use 'move' instead
   */
  swap(e2, t2) {
    this._blocks.swap(e2, t2), this.currentBlockIndex = t2;
  }
  /**
   * Move a block to a new index
   *
   * @param {number} toIndex - index where to move Block
   * @param {number} fromIndex - index of Block to move
   */
  move(e2, t2 = this.currentBlockIndex) {
    if (isNaN(e2) || isNaN(t2)) {
      L("Warning during 'move' call: incorrect indices provided.", "warn");
      return;
    }
    if (!this.validateIndex(e2) || !this.validateIndex(t2)) {
      L("Warning during 'move' call: indices cannot be lower than 0 or greater than the amount of blocks.", "warn");
      return;
    }
    this._blocks.move(e2, t2), this.currentBlockIndex = e2, this.blockDidMutated(ei, this.currentBlock, {
      fromIndex: t2,
      toIndex: e2
    });
  }
  /**
   * Converts passed Block to the new Tool
   * Uses Conversion Config
   *
   * @param blockToConvert - Block that should be converted
   * @param targetToolName - name of the Tool to convert to
   * @param blockDataOverrides - optional new Block data overrides
   */
  async convert(e2, t2, o2) {
    if (!await e2.save())
      throw new Error("Could not convert Block. Failed to extract original Block data.");
    const n2 = this.Editor.Tools.blockTools.get(t2);
    if (!n2)
      throw new Error(`Could not convert Block. Tool «${t2}» not found.`);
    const r2 = await e2.exportDataAsString(), a2 = G(
      r2,
      n2.sanitizeConfig
    );
    let l2 = to(a2, n2.conversionConfig);
    o2 && (l2 = Object.assign(l2, o2)), this.replace(e2, n2.name, l2);
  }
  /**
   * Sets current Block Index -1 which means unknown
   * and clear highlights
   */
  dropPointer() {
    this.currentBlockIndex = -1, this.clearFocused();
  }
  /**
   * Clears Editor
   *
   * @param {boolean} needToAddDefaultBlock - 1) in internal calls (for example, in api.blocks.render)
   *                                             we don't need to add an empty default block
   *                                        2) in api.blocks.clear we should add empty block
   */
  async clear(e2 = false) {
    const t2 = new ti();
    this.blocks.forEach((o2) => {
      t2.add(async () => {
        await this.removeBlock(o2, false);
      });
    }), await t2.completed, this.dropPointer(), e2 && this.insert(), this.Editor.UI.checkEmptiness();
  }
  /**
   * Cleans up all the block tools' resources
   * This is called when editor is destroyed
   */
  async destroy() {
    await Promise.all(this.blocks.map((e2) => e2.destroy()));
  }
  /**
   * Bind Block events
   *
   * @param {Block} block - Block to which event should be bound
   */
  bindBlockEvents(e2) {
    const { BlockEvents: t2 } = this.Editor;
    this.readOnlyMutableListeners.on(e2.holder, "keydown", (o2) => {
      t2.keydown(o2);
    }), this.readOnlyMutableListeners.on(e2.holder, "keyup", (o2) => {
      t2.keyup(o2);
    }), this.readOnlyMutableListeners.on(e2.holder, "dragover", (o2) => {
      t2.dragOver(o2);
    }), this.readOnlyMutableListeners.on(e2.holder, "dragleave", (o2) => {
      t2.dragLeave(o2);
    }), e2.on("didMutated", (o2) => this.blockDidMutated(st, o2, {
      index: this.getBlockIndex(o2)
    }));
  }
  /**
   * Disable mutable handlers and bindings
   */
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  /**
   * Enables all module handlers and bindings for all Blocks
   */
  enableModuleBindings() {
    this.readOnlyMutableListeners.on(
      document,
      "cut",
      (e2) => this.Editor.BlockEvents.handleCommandX(e2)
    ), this.blocks.forEach((e2) => {
      this.bindBlockEvents(e2);
    });
  }
  /**
   * Validates that the given index is not lower than 0 or higher than the amount of blocks
   *
   * @param {number} index - index of blocks array to validate
   * @returns {boolean}
   */
  validateIndex(e2) {
    return !(e2 < 0 || e2 >= this._blocks.length);
  }
  /**
   * Block mutation callback
   *
   * @param mutationType - what happened with block
   * @param block - mutated block
   * @param detailData - additional data to pass with change event
   */
  blockDidMutated(e2, t2, o2) {
    const i2 = new CustomEvent(e2, {
      detail: {
        target: new te(t2),
        ...o2
      }
    });
    return this.eventsDispatcher.emit(ut, {
      event: i2
    }), t2;
  }
}
class ii extends T {
  constructor() {
    super(...arguments), this.anyBlockSelectedCache = null, this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
  }
  /**
   * Sanitizer Config
   *
   * @returns {SanitizerConfig}
   */
  get sanitizerConfig() {
    return {
      p: {},
      h1: {},
      h2: {},
      h3: {},
      h4: {},
      h5: {},
      h6: {},
      ol: {},
      ul: {},
      li: {},
      br: true,
      img: {
        src: true,
        width: true,
        height: true
      },
      a: {
        href: true
      },
      b: {},
      i: {},
      u: {}
    };
  }
  /**
   * Flag that identifies all Blocks selection
   *
   * @returns {boolean}
   */
  get allBlocksSelected() {
    const { BlockManager: e2 } = this.Editor;
    return e2.blocks.every((t2) => t2.selected === true);
  }
  /**
   * Set selected all blocks
   *
   * @param {boolean} state - state to set
   */
  set allBlocksSelected(e2) {
    const { BlockManager: t2 } = this.Editor;
    t2.blocks.forEach((o2) => {
      o2.selected = e2;
    }), this.clearCache();
  }
  /**
   * Flag that identifies any Block selection
   *
   * @returns {boolean}
   */
  get anyBlockSelected() {
    const { BlockManager: e2 } = this.Editor;
    return this.anyBlockSelectedCache === null && (this.anyBlockSelectedCache = e2.blocks.some((t2) => t2.selected === true)), this.anyBlockSelectedCache;
  }
  /**
   * Return selected Blocks array
   *
   * @returns {Block[]}
   */
  get selectedBlocks() {
    return this.Editor.BlockManager.blocks.filter((e2) => e2.selected);
  }
  /**
   * Module Preparation
   * Registers Shortcuts CMD+A and CMD+C
   * to select all and copy them
   */
  prepare() {
    this.selection = new m(), le.add({
      name: "CMD+A",
      handler: (e2) => {
        const { BlockManager: t2, ReadOnly: o2 } = this.Editor;
        if (o2.isEnabled) {
          e2.preventDefault(), this.selectAllBlocks();
          return;
        }
        t2.currentBlock && this.handleCommandA(e2);
      },
      on: this.Editor.UI.nodes.redactor
    });
  }
  /**
   * Toggle read-only state
   *
   *  - Remove all ranges
   *  - Unselect all Blocks
   */
  toggleReadOnly() {
    m.get().removeAllRanges(), this.allBlocksSelected = false;
  }
  /**
   * Remove selection of Block
   *
   * @param {number?} index - Block index according to the BlockManager's indexes
   */
  unSelectBlockByIndex(e2) {
    const { BlockManager: t2 } = this.Editor;
    let o2;
    isNaN(e2) ? o2 = t2.currentBlock : o2 = t2.getBlockByIndex(e2), o2.selected = false, this.clearCache();
  }
  /**
   * Clear selection from Blocks
   *
   * @param {Event} reason - event caused clear of selection
   * @param {boolean} restoreSelection - if true, restore saved selection
   */
  clearSelection(e2, t2 = false) {
    const { BlockManager: o2, Caret: i2, RectangleSelection: n2 } = this.Editor;
    this.needToSelectAll = false, this.nativeInputSelected = false, this.readyToBlockSelection = false;
    const r2 = e2 && e2 instanceof KeyboardEvent, a2 = r2 && at(e2.keyCode);
    if (this.anyBlockSelected && r2 && a2 && !m.isSelectionExists) {
      const l2 = o2.removeSelectedBlocks();
      o2.insertDefaultBlockAtIndex(l2, true), i2.setToBlock(o2.currentBlock), ge(() => {
        const c2 = e2.key;
        i2.insertContentAtCaretPosition(c2.length > 1 ? "" : c2);
      }, 20)();
    }
    if (this.Editor.CrossBlockSelection.clear(e2), !this.anyBlockSelected || n2.isRectActivated()) {
      this.Editor.RectangleSelection.clearSelection();
      return;
    }
    t2 && this.selection.restore(), this.allBlocksSelected = false;
  }
  /**
   * Reduce each Block and copy its content
   *
   * @param {ClipboardEvent} e - copy/cut event
   * @returns {Promise<void>}
   */
  copySelectedBlocks(e2) {
    e2.preventDefault();
    const t2 = d.make("div");
    this.selectedBlocks.forEach((n2) => {
      const r2 = G(n2.holder.innerHTML, this.sanitizerConfig), a2 = d.make("p");
      a2.innerHTML = r2, t2.appendChild(a2);
    });
    const o2 = Array.from(t2.childNodes).map((n2) => n2.textContent).join(`

`), i2 = t2.innerHTML;
    return e2.clipboardData.setData("text/plain", o2), e2.clipboardData.setData("text/html", i2), Promise.all(this.selectedBlocks.map((n2) => n2.save())).then((n2) => {
      try {
        e2.clipboardData.setData(this.Editor.Paste.MIME_TYPE, JSON.stringify(n2));
      } catch {
      }
    });
  }
  /**
   * select Block
   *
   * @param {number?} index - Block index according to the BlockManager's indexes
   */
  selectBlockByIndex(e2) {
    const { BlockManager: t2 } = this.Editor;
    t2.clearFocused();
    let o2;
    isNaN(e2) ? o2 = t2.currentBlock : o2 = t2.getBlockByIndex(e2), this.selection.save(), m.get().removeAllRanges(), o2.selected = true, this.clearCache(), this.Editor.InlineToolbar.close();
  }
  /**
   * Clear anyBlockSelected cache
   */
  clearCache() {
    this.anyBlockSelectedCache = null;
  }
  /**
   * Module destruction
   * De-registers Shortcut CMD+A
   */
  destroy() {
    le.remove(this.Editor.UI.nodes.redactor, "CMD+A");
  }
  /**
   * First CMD+A selects all input content by native behaviour,
   * next CMD+A keypress selects all blocks
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  handleCommandA(e2) {
    if (this.Editor.RectangleSelection.clearSelection(), d.isNativeInput(e2.target) && !this.readyToBlockSelection) {
      this.readyToBlockSelection = true;
      return;
    }
    const o2 = this.Editor.BlockManager.getBlock(e2.target).inputs;
    if (o2.length > 1 && !this.readyToBlockSelection) {
      this.readyToBlockSelection = true;
      return;
    }
    if (o2.length === 1 && !this.needToSelectAll) {
      this.needToSelectAll = true;
      return;
    }
    this.needToSelectAll ? (e2.preventDefault(), this.selectAllBlocks(), this.needToSelectAll = false, this.readyToBlockSelection = false, this.Editor.ConversionToolbar.close()) : this.readyToBlockSelection && (e2.preventDefault(), this.selectBlockByIndex(), this.needToSelectAll = true);
  }
  /**
   * Select All Blocks
   * Each Block has selected setter that makes Block copyable
   */
  selectAllBlocks() {
    this.selection.save(), m.get().removeAllRanges(), this.allBlocksSelected = true, this.Editor.InlineToolbar.close();
  }
}
class we extends T {
  /**
   * Allowed caret positions in input
   *
   * @static
   * @returns {{START: string, END: string, DEFAULT: string}}
   */
  get positions() {
    return {
      START: "start",
      END: "end",
      DEFAULT: "default"
    };
  }
  /**
   * Elements styles that can be useful for Caret Module
   */
  static get CSS() {
    return {
      shadowCaret: "cdx-shadow-caret"
    };
  }
  /**
   * Get's deepest first node and checks if offset is zero
   *
   * @returns {boolean}
   */
  get isAtStart() {
    const e2 = m.get(), t2 = d.getDeepestNode(this.Editor.BlockManager.currentBlock.currentInput);
    let o2 = e2.focusNode;
    if (d.isNativeInput(t2))
      return t2.selectionEnd === 0;
    if (!e2.anchorNode)
      return false;
    let i2 = o2.textContent.search(/\S/);
    i2 === -1 && (i2 = 0);
    let n2 = e2.focusOffset;
    return o2.nodeType !== Node.TEXT_NODE && o2.childNodes.length && (o2.childNodes[n2] ? (o2 = o2.childNodes[n2], n2 = 0) : (o2 = o2.childNodes[n2 - 1], n2 = o2.textContent.length)), (d.isLineBreakTag(t2) || d.isEmpty(t2)) && this.getHigherLevelSiblings(o2, "left").every((l2) => {
      const c2 = d.isLineBreakTag(l2), u2 = l2.children.length === 1 && d.isLineBreakTag(l2.children[0]), h2 = c2 || u2;
      return d.isEmpty(l2) && !h2;
    }) && n2 === i2 ? true : t2 === null || o2 === t2 && n2 <= i2;
  }
  /**
   * Get's deepest last node and checks if offset is last node text length
   *
   * @returns {boolean}
   */
  get isAtEnd() {
    const e2 = m.get();
    let t2 = e2.focusNode;
    const o2 = d.getDeepestNode(this.Editor.BlockManager.currentBlock.currentInput, true);
    if (d.isNativeInput(o2))
      return o2.selectionEnd === o2.value.length;
    if (!e2.focusNode)
      return false;
    let i2 = e2.focusOffset;
    if (t2.nodeType !== Node.TEXT_NODE && t2.childNodes.length && (t2.childNodes[i2 - 1] ? (t2 = t2.childNodes[i2 - 1], i2 = t2.textContent.length) : (t2 = t2.childNodes[0], i2 = 0)), d.isLineBreakTag(o2) || d.isEmpty(o2)) {
      const r2 = this.getHigherLevelSiblings(t2, "right");
      if (r2.every((l2, c2) => c2 === r2.length - 1 && d.isLineBreakTag(l2) || d.isEmpty(l2) && !d.isLineBreakTag(l2)) && i2 === t2.textContent.length)
        return true;
    }
    const n2 = o2.textContent.replace(/\s+$/, "");
    return t2 === o2 && i2 >= n2.length;
  }
  /**
   * Method gets Block instance and puts caret to the text node with offset
   * There two ways that method applies caret position:
   *   - first found text node: sets at the beginning, but you can pass an offset
   *   - last found text node: sets at the end of the node. Also, you can customize the behaviour
   *
   * @param {Block} block - Block class
   * @param {string} position - position where to set caret.
   *                            If default - leave default behaviour and apply offset if it's passed
   * @param {number} offset - caret offset regarding to the text node
   */
  setToBlock(e2, t2 = this.positions.DEFAULT, o2 = 0) {
    const { BlockManager: i2 } = this.Editor;
    let n2;
    switch (t2) {
      case this.positions.START:
        n2 = e2.firstInput;
        break;
      case this.positions.END:
        n2 = e2.lastInput;
        break;
      default:
        n2 = e2.currentInput;
    }
    if (!n2)
      return;
    const r2 = d.getDeepestNode(n2, t2 === this.positions.END), a2 = d.getContentLength(r2);
    switch (true) {
      case t2 === this.positions.START:
        o2 = 0;
        break;
      case t2 === this.positions.END:
      case o2 > a2:
        o2 = a2;
        break;
    }
    ge(() => {
      this.set(r2, o2);
    }, 20)(), i2.setCurrentBlockByChildNode(e2.holder), i2.currentBlock.currentInput = n2;
  }
  /**
   * Set caret to the current input of current Block.
   *
   * @param {HTMLElement} input - input where caret should be set
   * @param {string} position - position of the caret.
   *                            If default - leave default behaviour and apply offset if it's passed
   * @param {number} offset - caret offset regarding to the text node
   */
  setToInput(e2, t2 = this.positions.DEFAULT, o2 = 0) {
    const { currentBlock: i2 } = this.Editor.BlockManager, n2 = d.getDeepestNode(e2);
    switch (t2) {
      case this.positions.START:
        this.set(n2, 0);
        break;
      case this.positions.END:
        this.set(n2, d.getContentLength(n2));
        break;
      default:
        o2 && this.set(n2, o2);
    }
    i2.currentInput = e2;
  }
  /**
   * Creates Document Range and sets caret to the element with offset
   *
   * @param {HTMLElement} element - target node.
   * @param {number} offset - offset
   */
  set(e2, t2 = 0) {
    const { top: i2, bottom: n2 } = m.setCursor(e2, t2), { innerHeight: r2 } = window;
    i2 < 0 ? window.scrollBy(0, i2 - 30) : n2 > r2 && window.scrollBy(0, n2 - r2 + 30);
  }
  /**
   * Set Caret to the last Block
   * If last block is not empty, append another empty block
   */
  setToTheLastBlock() {
    const e2 = this.Editor.BlockManager.lastBlock;
    if (e2)
      if (e2.tool.isDefault && e2.isEmpty)
        this.setToBlock(e2);
      else {
        const t2 = this.Editor.BlockManager.insertAtEnd();
        this.setToBlock(t2);
      }
  }
  /**
   * Extract content fragment of current Block from Caret position to the end of the Block
   */
  extractFragmentFromCaretPosition() {
    const e2 = m.get();
    if (e2.rangeCount) {
      const t2 = e2.getRangeAt(0), o2 = this.Editor.BlockManager.currentBlock.currentInput;
      if (t2.deleteContents(), o2)
        if (d.isNativeInput(o2)) {
          const i2 = o2, n2 = document.createDocumentFragment(), r2 = i2.value.substring(0, i2.selectionStart), a2 = i2.value.substring(i2.selectionStart);
          return n2.textContent = a2, i2.value = r2, n2;
        } else {
          const i2 = t2.cloneRange();
          return i2.selectNodeContents(o2), i2.setStart(t2.endContainer, t2.endOffset), i2.extractContents();
        }
    }
  }
  /**
   * Set's caret to the next Block or Tool`s input
   * Before moving caret, we should check if caret position is at the end of Plugins node
   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection
   *
   * @returns {boolean}
   */
  navigateNext() {
    const { BlockManager: e2 } = this.Editor, { currentBlock: t2, nextContentfulBlock: o2 } = e2, { nextInput: i2 } = t2, n2 = this.isAtEnd;
    let r2 = o2;
    if (!r2 && !i2) {
      if (t2.tool.isDefault || !n2)
        return false;
      r2 = e2.insertAtEnd();
    }
    return n2 ? (i2 ? this.setToInput(i2, this.positions.START) : this.setToBlock(r2, this.positions.START), true) : false;
  }
  /**
   * Set's caret to the previous Tool`s input or Block
   * Before moving caret, we should check if caret position is start of the Plugins node
   * Using {@link Dom#getDeepestNode} to get a last node and match with current selection
   *
   * @returns {boolean}
   */
  navigatePrevious() {
    const { currentBlock: e2, previousContentfulBlock: t2 } = this.Editor.BlockManager;
    if (!e2)
      return false;
    const { previousInput: o2 } = e2;
    return !t2 && !o2 ? false : this.isAtStart ? (o2 ? this.setToInput(o2, this.positions.END) : this.setToBlock(t2, this.positions.END), true) : false;
  }
  /**
   * Inserts shadow element after passed element where caret can be placed
   *
   * @param {Element} element - element after which shadow caret should be inserted
   */
  createShadow(e2) {
    const t2 = document.createElement("span");
    t2.classList.add(we.CSS.shadowCaret), e2.insertAdjacentElement("beforeend", t2);
  }
  /**
   * Restores caret position
   *
   * @param {HTMLElement} element - element where caret should be restored
   */
  restoreCaret(e2) {
    const t2 = e2.querySelector(`.${we.CSS.shadowCaret}`);
    if (!t2)
      return;
    new m().expandToTag(t2);
    const i2 = document.createRange();
    i2.selectNode(t2), i2.extractContents();
  }
  /**
   * Inserts passed content at caret position
   *
   * @param {string} content - content to insert
   */
  insertContentAtCaretPosition(e2) {
    const t2 = document.createDocumentFragment(), o2 = document.createElement("div"), i2 = m.get(), n2 = m.range;
    o2.innerHTML = e2, Array.from(o2.childNodes).forEach((c2) => t2.appendChild(c2)), t2.childNodes.length === 0 && t2.appendChild(new Text());
    const r2 = t2.lastChild;
    n2.deleteContents(), n2.insertNode(t2);
    const a2 = document.createRange(), l2 = r2.nodeType === Node.TEXT_NODE ? r2 : r2.firstChild;
    l2 !== null && l2.textContent !== null && a2.setStart(l2, l2.textContent.length), i2.removeAllRanges(), i2.addRange(a2);
  }
  /**
   * Get all first-level (first child of [contenteditable]) siblings from passed node
   * Then you can check it for emptiness
   *
   * @example
   * <div contenteditable>
   * <p></p>                            |
   * <p></p>                            | left first-level siblings
   * <p></p>                            |
   * <blockquote><a><b>adaddad</b><a><blockquote>       <-- passed node for example <b>
   * <p></p>                            |
   * <p></p>                            | right first-level siblings
   * <p></p>                            |
   * </div>
   * @param {HTMLElement} from - element from which siblings should be searched
   * @param {'left' | 'right'} direction - direction of search
   * @returns {HTMLElement[]}
   */
  getHigherLevelSiblings(e2, t2) {
    let o2 = e2;
    const i2 = [];
    for (; o2.parentNode && o2.parentNode.contentEditable !== "true"; )
      o2 = o2.parentNode;
    const n2 = t2 === "left" ? "previousSibling" : "nextSibling";
    for (; o2[n2]; )
      o2 = o2[n2], i2.push(o2);
    return i2;
  }
}
class ni extends T {
  constructor() {
    super(...arguments), this.onMouseUp = () => {
      this.listeners.off(document, "mouseover", this.onMouseOver), this.listeners.off(document, "mouseup", this.onMouseUp);
    }, this.onMouseOver = (e2) => {
      const { BlockManager: t2, BlockSelection: o2 } = this.Editor, i2 = t2.getBlockByChildNode(e2.relatedTarget) || this.lastSelectedBlock, n2 = t2.getBlockByChildNode(e2.target);
      if (!(!i2 || !n2) && n2 !== i2) {
        if (i2 === this.firstSelectedBlock) {
          m.get().removeAllRanges(), i2.selected = true, n2.selected = true, o2.clearCache();
          return;
        }
        if (n2 === this.firstSelectedBlock) {
          i2.selected = false, n2.selected = false, o2.clearCache();
          return;
        }
        this.Editor.InlineToolbar.close(), this.toggleBlocksSelectedState(i2, n2), this.lastSelectedBlock = n2;
      }
    };
  }
  /**
   * Module preparation
   *
   * @returns {Promise}
   */
  async prepare() {
    this.listeners.on(document, "mousedown", (e2) => {
      this.enableCrossBlockSelection(e2);
    });
  }
  /**
   * Sets up listeners
   *
   * @param {MouseEvent} event - mouse down event
   */
  watchSelection(e2) {
    if (e2.button !== Dt.LEFT)
      return;
    const { BlockManager: t2 } = this.Editor;
    this.firstSelectedBlock = t2.getBlock(e2.target), this.lastSelectedBlock = this.firstSelectedBlock, this.listeners.on(document, "mouseover", this.onMouseOver), this.listeners.on(document, "mouseup", this.onMouseUp);
  }
  /**
   * return boolean is cross block selection started
   */
  get isCrossBlockSelectionStarted() {
    return !!this.firstSelectedBlock && !!this.lastSelectedBlock;
  }
  /**
   * Change selection state of the next Block
   * Used for CBS via Shift + arrow keys
   *
   * @param {boolean} next - if true, toggle next block. Previous otherwise
   */
  toggleBlockSelectedState(e2 = true) {
    const { BlockManager: t2, BlockSelection: o2 } = this.Editor;
    this.lastSelectedBlock || (this.lastSelectedBlock = this.firstSelectedBlock = t2.currentBlock), this.firstSelectedBlock === this.lastSelectedBlock && (this.firstSelectedBlock.selected = true, o2.clearCache(), m.get().removeAllRanges());
    const i2 = t2.blocks.indexOf(this.lastSelectedBlock) + (e2 ? 1 : -1), n2 = t2.blocks[i2];
    n2 && (this.lastSelectedBlock.selected !== n2.selected ? (n2.selected = true, o2.clearCache()) : (this.lastSelectedBlock.selected = false, o2.clearCache()), this.lastSelectedBlock = n2, this.Editor.InlineToolbar.close(), n2.holder.scrollIntoView({
      block: "nearest"
    }));
  }
  /**
   * Clear saved state
   *
   * @param {Event} reason - event caused clear of selection
   */
  clear(e2) {
    const { BlockManager: t2, BlockSelection: o2, Caret: i2 } = this.Editor, n2 = t2.blocks.indexOf(this.firstSelectedBlock), r2 = t2.blocks.indexOf(this.lastSelectedBlock);
    if (o2.anyBlockSelected && n2 > -1 && r2 > -1)
      if (e2 && e2 instanceof KeyboardEvent)
        switch (e2.keyCode) {
          case B.DOWN:
          case B.RIGHT:
            i2.setToBlock(t2.blocks[Math.max(n2, r2)], i2.positions.END);
            break;
          case B.UP:
          case B.LEFT:
            i2.setToBlock(t2.blocks[Math.min(n2, r2)], i2.positions.START);
            break;
          default:
            i2.setToBlock(t2.blocks[Math.max(n2, r2)], i2.positions.END);
        }
      else
        i2.setToBlock(t2.blocks[Math.max(n2, r2)], i2.positions.END);
    this.firstSelectedBlock = this.lastSelectedBlock = null;
  }
  /**
   * Enables Cross Block Selection
   *
   * @param {MouseEvent} event - mouse down event
   */
  enableCrossBlockSelection(e2) {
    const { UI: t2 } = this.Editor;
    m.isCollapsed || this.Editor.BlockSelection.clearSelection(e2), t2.nodes.redactor.contains(e2.target) ? this.watchSelection(e2) : this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * Change blocks selection state between passed two blocks.
   *
   * @param {Block} firstBlock - first block in range
   * @param {Block} lastBlock - last block in range
   */
  toggleBlocksSelectedState(e2, t2) {
    const { BlockManager: o2, BlockSelection: i2 } = this.Editor, n2 = o2.blocks.indexOf(e2), r2 = o2.blocks.indexOf(t2), a2 = e2.selected !== t2.selected;
    for (let l2 = Math.min(n2, r2); l2 <= Math.max(n2, r2); l2++) {
      const c2 = o2.blocks[l2];
      c2 !== this.firstSelectedBlock && c2 !== (a2 ? e2 : t2) && (o2.blocks[l2].selected = !o2.blocks[l2].selected, i2.clearCache());
    }
  }
}
class si extends T {
  constructor() {
    super(...arguments), this.isStartedAtEditor = false;
  }
  /**
   * Toggle read-only state
   *
   * if state is true:
   *  - disable all drag-n-drop event handlers
   *
   * if state is false:
   *  - restore drag-n-drop event handlers
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */
  toggleReadOnly(e2) {
    e2 ? this.disableModuleBindings() : this.enableModuleBindings();
  }
  /**
   * Add drag events listeners to editor zone
   */
  enableModuleBindings() {
    const { UI: e2 } = this.Editor;
    this.readOnlyMutableListeners.on(e2.nodes.holder, "drop", async (t2) => {
      await this.processDrop(t2);
    }, true), this.readOnlyMutableListeners.on(e2.nodes.holder, "dragstart", () => {
      this.processDragStart();
    }), this.readOnlyMutableListeners.on(e2.nodes.holder, "dragover", (t2) => {
      this.processDragOver(t2);
    }, true);
  }
  /**
   * Unbind drag-n-drop event handlers
   */
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  /**
   * Handle drop event
   *
   * @param {DragEvent} dropEvent - drop event
   */
  async processDrop(e2) {
    const {
      BlockManager: t2,
      Caret: o2,
      Paste: i2
    } = this.Editor;
    e2.preventDefault(), t2.blocks.forEach((r2) => {
      r2.dropTarget = false;
    }), m.isAtEditor && !m.isCollapsed && this.isStartedAtEditor && document.execCommand("delete"), this.isStartedAtEditor = false;
    const n2 = t2.setCurrentBlockByChildNode(e2.target);
    if (n2)
      this.Editor.Caret.setToBlock(n2, o2.positions.END);
    else {
      const r2 = t2.setCurrentBlockByChildNode(t2.lastBlock.holder);
      this.Editor.Caret.setToBlock(r2, o2.positions.END);
    }
    await i2.processDataTransfer(e2.dataTransfer, true);
  }
  /**
   * Handle drag start event
   */
  processDragStart() {
    m.isAtEditor && !m.isCollapsed && (this.isStartedAtEditor = true), this.Editor.InlineToolbar.close();
  }
  /**
   * @param {DragEvent} dragEvent - drag event
   */
  processDragOver(e2) {
    e2.preventDefault();
  }
}
class ri extends T {
  /**
   * Prepare the module
   *
   * @param options - options used by the modification observer module
   * @param options.config - Editor configuration object
   * @param options.eventsDispatcher - common Editor event bus
   */
  constructor({ config: e2, eventsDispatcher: t2 }) {
    super({
      config: e2,
      eventsDispatcher: t2
    }), this.disabled = false, this.batchingTimeout = null, this.batchingOnChangeQueue = /* @__PURE__ */ new Map(), this.batchTime = 400, this.mutationObserver = new MutationObserver((o2) => {
      this.redactorChanged(o2);
    }), this.eventsDispatcher.on(ut, (o2) => {
      this.particularBlockChanged(o2.event);
    }), this.eventsDispatcher.on(pt, () => {
      this.disable();
    }), this.eventsDispatcher.on(ft, () => {
      this.enable();
    });
  }
  /**
   * Enables onChange event
   */
  enable() {
    this.mutationObserver.observe(
      this.Editor.UI.nodes.redactor,
      {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: true
      }
    ), this.disabled = false;
  }
  /**
   * Disables onChange event
   */
  disable() {
    this.mutationObserver.disconnect(), this.disabled = true;
  }
  /**
   * Call onChange event passed to Editor.js configuration
   *
   * @param event - some of our custom change events
   */
  particularBlockChanged(e2) {
    this.disabled || !D(this.config.onChange) || (this.batchingOnChangeQueue.set(`block:${e2.detail.target.id}:event:${e2.type}`, e2), this.batchingTimeout && clearTimeout(this.batchingTimeout), this.batchingTimeout = setTimeout(() => {
      let t2;
      this.batchingOnChangeQueue.size === 1 ? t2 = this.batchingOnChangeQueue.values().next().value : t2 = Array.from(this.batchingOnChangeQueue.values()), this.config.onChange && this.config.onChange(this.Editor.API.methods, t2), this.batchingOnChangeQueue.clear();
    }, this.batchTime));
  }
  /**
   * Fired on every blocks wrapper dom change
   *
   * @param mutations - mutations happened
   */
  redactorChanged(e2) {
    this.eventsDispatcher.emit(Oe, {
      mutations: e2
    });
  }
}
const Bt = class extends T {
  constructor() {
    super(...arguments), this.MIME_TYPE = "application/x-editor-js", this.toolsTags = {}, this.tagsByTool = {}, this.toolsPatterns = [], this.toolsFiles = {}, this.exceptionList = [], this.processTool = (s2) => {
      try {
        const e2 = s2.create({}, {}, false);
        if (s2.pasteConfig === false) {
          this.exceptionList.push(s2.name);
          return;
        }
        if (!D(e2.onPaste))
          return;
        this.getTagsConfig(s2), this.getFilesConfig(s2), this.getPatternsConfig(s2);
      } catch (e2) {
        L(
          `Paste handling for «${s2.name}» Tool hasn't been set up because of the error`,
          "warn",
          e2
        );
      }
    }, this.handlePasteEvent = async (s2) => {
      const { BlockManager: e2, Toolbar: t2 } = this.Editor, o2 = e2.setCurrentBlockByChildNode(s2.target);
      !o2 || this.isNativeBehaviour(s2.target) && !s2.clipboardData.types.includes("Files") || o2 && this.exceptionList.includes(o2.name) || (s2.preventDefault(), this.processDataTransfer(s2.clipboardData), e2.clearFocused(), t2.close());
    };
  }
  /**
   * Set onPaste callback and collect tools` paste configurations
   */
  async prepare() {
    this.processTools();
  }
  /**
   * Set read-only state
   *
   * @param {boolean} readOnlyEnabled - read only flag value
   */
  toggleReadOnly(s2) {
    s2 ? this.unsetCallback() : this.setCallback();
  }
  /**
   * Handle pasted or dropped data transfer object
   *
   * @param {DataTransfer} dataTransfer - pasted or dropped data transfer object
   * @param {boolean} isDragNDrop - true if data transfer comes from drag'n'drop events
   */
  async processDataTransfer(s2, e2 = false) {
    const { Tools: t2 } = this.Editor, o2 = s2.types;
    if ((o2.includes ? o2.includes("Files") : o2.contains("Files")) && !q(this.toolsFiles)) {
      await this.processFiles(s2.files);
      return;
    }
    const n2 = s2.getData(this.MIME_TYPE), r2 = s2.getData("text/plain");
    let a2 = s2.getData("text/html");
    if (n2)
      try {
        this.insertEditorJSData(JSON.parse(n2));
        return;
      } catch {
      }
    e2 && r2.trim() && a2.trim() && (a2 = "<p>" + (a2.trim() ? a2 : r2) + "</p>");
    const l2 = Object.keys(this.toolsTags).reduce((h2, f2) => (h2[f2.toLowerCase()] = this.toolsTags[f2].sanitizationConfig ?? {}, h2), {}), c2 = Object.assign({}, l2, t2.getAllInlineToolsSanitizeConfig(), { br: {} }), u2 = G(a2, c2);
    !u2.trim() || u2.trim() === r2 || !d.isHTMLString(u2) ? await this.processText(r2) : await this.processText(u2, true);
  }
  /**
   * Process pasted text and divide them into Blocks
   *
   * @param {string} data - text to process. Can be HTML or plain.
   * @param {boolean} isHTML - if passed string is HTML, this parameter should be true
   */
  async processText(s2, e2 = false) {
    const { Caret: t2, BlockManager: o2 } = this.Editor, i2 = e2 ? this.processHTML(s2) : this.processPlain(s2);
    if (!i2.length)
      return;
    if (i2.length === 1) {
      i2[0].isBlock ? this.processSingleBlock(i2.pop()) : this.processInlinePaste(i2.pop());
      return;
    }
    const r2 = o2.currentBlock && o2.currentBlock.tool.isDefault && o2.currentBlock.isEmpty;
    i2.map(
      async (a2, l2) => this.insertBlock(a2, l2 === 0 && r2)
    ), o2.currentBlock && t2.setToBlock(o2.currentBlock, t2.positions.END);
  }
  /**
   * Set onPaste callback handler
   */
  setCallback() {
    this.listeners.on(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
  }
  /**
   * Unset onPaste callback handler
   */
  unsetCallback() {
    this.listeners.off(this.Editor.UI.nodes.holder, "paste", this.handlePasteEvent);
  }
  /**
   * Get and process tool`s paste configs
   */
  processTools() {
    const s2 = this.Editor.Tools.blockTools;
    Array.from(s2.values()).forEach(this.processTool);
  }
  /**
   * Get tags name list from either tag name or sanitization config.
   *
   * @param {string | object} tagOrSanitizeConfig - tag name or sanitize config object.
   * @returns {string[]} array of tags.
   */
  collectTagNames(s2) {
    return Q(s2) ? [s2] : z(s2) ? Object.keys(s2) : [];
  }
  /**
   * Get tags to substitute by Tool
   *
   * @param tool - BlockTool object
   */
  getTagsConfig(s2) {
    if (s2.pasteConfig === false)
      return;
    const e2 = s2.pasteConfig.tags || [], t2 = [];
    e2.forEach((o2) => {
      const i2 = this.collectTagNames(o2);
      t2.push(...i2), i2.forEach((n2) => {
        if (Object.prototype.hasOwnProperty.call(this.toolsTags, n2)) {
          L(
            `Paste handler for «${s2.name}» Tool on «${n2}» tag is skipped because it is already used by «${this.toolsTags[n2].tool.name}» Tool.`,
            "warn"
          );
          return;
        }
        const r2 = z(o2) ? o2[n2] : null;
        this.toolsTags[n2.toUpperCase()] = {
          tool: s2,
          sanitizationConfig: r2
        };
      });
    }), this.tagsByTool[s2.name] = t2.map((o2) => o2.toUpperCase());
  }
  /**
   * Get files` types and extensions to substitute by Tool
   *
   * @param tool - BlockTool object
   */
  getFilesConfig(s2) {
    if (s2.pasteConfig === false)
      return;
    const { files: e2 = {} } = s2.pasteConfig;
    let { extensions: t2, mimeTypes: o2 } = e2;
    !t2 && !o2 || (t2 && !Array.isArray(t2) && (L(`«extensions» property of the onDrop config for «${s2.name}» Tool should be an array`), t2 = []), o2 && !Array.isArray(o2) && (L(`«mimeTypes» property of the onDrop config for «${s2.name}» Tool should be an array`), o2 = []), o2 && (o2 = o2.filter((i2) => zt(i2) ? true : (L(`MIME type value «${i2}» for the «${s2.name}» Tool is not a valid MIME type`, "warn"), false))), this.toolsFiles[s2.name] = {
      extensions: t2 || [],
      mimeTypes: o2 || []
    });
  }
  /**
   * Get RegExp patterns to substitute by Tool
   *
   * @param tool - BlockTool object
   */
  getPatternsConfig(s2) {
    s2.pasteConfig === false || !s2.pasteConfig.patterns || q(s2.pasteConfig.patterns) || Object.entries(s2.pasteConfig.patterns).forEach(([e2, t2]) => {
      t2 instanceof RegExp || L(
        `Pattern ${t2} for «${s2.name}» Tool is skipped because it should be a Regexp instance.`,
        "warn"
      ), this.toolsPatterns.push({
        key: e2,
        pattern: t2,
        tool: s2
      });
    });
  }
  /**
   * Check if browser behavior suits better
   *
   * @param {EventTarget} element - element where content has been pasted
   * @returns {boolean}
   */
  isNativeBehaviour(s2) {
    return d.isNativeInput(s2);
  }
  /**
   * Get files from data transfer object and insert related Tools
   *
   * @param {FileList} items - pasted or dropped items
   */
  async processFiles(s2) {
    const { BlockManager: e2 } = this.Editor;
    let t2;
    t2 = await Promise.all(
      Array.from(s2).map((n2) => this.processFile(n2))
    ), t2 = t2.filter((n2) => !!n2);
    const i2 = e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty;
    t2.forEach(
      (n2, r2) => {
        e2.paste(n2.type, n2.event, r2 === 0 && i2);
      }
    );
  }
  /**
   * Get information about file and find Tool to handle it
   *
   * @param {File} file - file to process
   */
  async processFile(s2) {
    const e2 = jt(s2), t2 = Object.entries(this.toolsFiles).find(([n2, { mimeTypes: r2, extensions: a2 }]) => {
      const [l2, c2] = s2.type.split("/"), u2 = a2.find((f2) => f2.toLowerCase() === e2.toLowerCase()), h2 = r2.find((f2) => {
        const [k2, p2] = f2.split("/");
        return k2 === l2 && (p2 === c2 || p2 === "*");
      });
      return !!u2 || !!h2;
    });
    if (!t2)
      return;
    const [o2] = t2;
    return {
      event: this.composePasteEvent("file", {
        file: s2
      }),
      type: o2
    };
  }
  /**
   * Split HTML string to blocks and return it as array of Block data
   *
   * @param {string} innerHTML - html string to process
   * @returns {PasteData[]}
   */
  processHTML(s2) {
    const { Tools: e2 } = this.Editor, t2 = d.make("DIV");
    return t2.innerHTML = s2, this.getNodes(t2).map((i2) => {
      let n2, r2 = e2.defaultTool, a2 = false;
      switch (i2.nodeType) {
        case Node.DOCUMENT_FRAGMENT_NODE:
          n2 = d.make("div"), n2.appendChild(i2);
          break;
        case Node.ELEMENT_NODE:
          n2 = i2, a2 = true, this.toolsTags[n2.tagName] && (r2 = this.toolsTags[n2.tagName].tool);
          break;
      }
      const { tags: l2 } = r2.pasteConfig || { tags: [] }, c2 = l2.reduce((f2, k2) => (this.collectTagNames(k2).forEach((v2) => {
        const A2 = z(k2) ? k2[v2] : null;
        f2[v2.toLowerCase()] = A2 || {};
      }), f2), {}), u2 = Object.assign({}, c2, r2.baseSanitizeConfig);
      if (n2.tagName.toLowerCase() === "table") {
        const f2 = G(n2.outerHTML, u2);
        n2 = d.make("div", void 0, {
          innerHTML: f2
        }).firstChild;
      } else
        n2.innerHTML = G(n2.innerHTML, u2);
      const h2 = this.composePasteEvent("tag", {
        data: n2
      });
      return {
        content: n2,
        isBlock: a2,
        tool: r2.name,
        event: h2
      };
    }).filter((i2) => {
      const n2 = d.isEmpty(i2.content), r2 = d.isSingleTag(i2.content);
      return !n2 || r2;
    });
  }
  /**
   * Split plain text by new line symbols and return it as array of Block data
   *
   * @param {string} plain - string to process
   * @returns {PasteData[]}
   */
  processPlain(s2) {
    const { defaultBlock: e2 } = this.config;
    if (!s2)
      return [];
    const t2 = e2;
    return s2.split(/\r?\n/).filter((o2) => o2.trim()).map((o2) => {
      const i2 = d.make("div");
      i2.textContent = o2;
      const n2 = this.composePasteEvent("tag", {
        data: i2
      });
      return {
        content: i2,
        tool: t2,
        isBlock: false,
        event: n2
      };
    });
  }
  /**
   * Process paste of single Block tool content
   *
   * @param {PasteData} dataToInsert - data of Block to insert
   */
  async processSingleBlock(s2) {
    const { Caret: e2, BlockManager: t2 } = this.Editor, { currentBlock: o2 } = t2;
    if (!o2 || s2.tool !== o2.name || !d.containsOnlyInlineElements(s2.content.innerHTML)) {
      this.insertBlock(s2, (o2 == null ? void 0 : o2.tool.isDefault) && o2.isEmpty);
      return;
    }
    e2.insertContentAtCaretPosition(s2.content.innerHTML);
  }
  /**
   * Process paste to single Block:
   * 1. Find patterns` matches
   * 2. Insert new block if it is not the same type as current one
   * 3. Just insert text if there is no substitutions
   *
   * @param {PasteData} dataToInsert - data of Block to insert
   */
  async processInlinePaste(s2) {
    const { BlockManager: e2, Caret: t2 } = this.Editor, { content: o2 } = s2;
    if (e2.currentBlock && e2.currentBlock.tool.isDefault && o2.textContent.length < Bt.PATTERN_PROCESSING_MAX_LENGTH) {
      const n2 = await this.processPattern(o2.textContent);
      if (n2) {
        const r2 = e2.currentBlock && e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty, a2 = e2.paste(n2.tool, n2.event, r2);
        t2.setToBlock(a2, t2.positions.END);
        return;
      }
    }
    if (e2.currentBlock && e2.currentBlock.currentInput) {
      const n2 = e2.currentBlock.tool.baseSanitizeConfig;
      document.execCommand(
        "insertHTML",
        false,
        G(o2.innerHTML, n2)
      );
    } else
      this.insertBlock(s2);
  }
  /**
   * Get patterns` matches
   *
   * @param {string} text - text to process
   * @returns {Promise<{event: PasteEvent, tool: string}>}
   */
  async processPattern(s2) {
    const e2 = this.toolsPatterns.find((o2) => {
      const i2 = o2.pattern.exec(s2);
      return i2 ? s2 === i2.shift() : false;
    });
    return e2 ? {
      event: this.composePasteEvent("pattern", {
        key: e2.key,
        data: s2
      }),
      tool: e2.tool.name
    } : void 0;
  }
  /**
   * Insert pasted Block content to Editor
   *
   * @param {PasteData} data - data to insert
   * @param {boolean} canReplaceCurrentBlock - if true and is current Block is empty, will replace current Block
   * @returns {void}
   */
  insertBlock(s2, e2 = false) {
    const { BlockManager: t2, Caret: o2 } = this.Editor, { currentBlock: i2 } = t2;
    let n2;
    if (e2 && i2 && i2.isEmpty) {
      n2 = t2.paste(s2.tool, s2.event, true), o2.setToBlock(n2, o2.positions.END);
      return;
    }
    n2 = t2.paste(s2.tool, s2.event), o2.setToBlock(n2, o2.positions.END);
  }
  /**
   * Insert data passed as application/x-editor-js JSON
   *
   * @param {Array} blocks — Blocks' data to insert
   * @returns {void}
   */
  insertEditorJSData(s2) {
    const { BlockManager: e2, Caret: t2, Tools: o2 } = this.Editor;
    gt(
      s2,
      (n2) => o2.blockTools.get(n2).sanitizeConfig
    ).forEach(({ tool: n2, data: r2 }, a2) => {
      let l2 = false;
      a2 === 0 && (l2 = e2.currentBlock && e2.currentBlock.tool.isDefault && e2.currentBlock.isEmpty);
      const c2 = e2.insert({
        tool: n2,
        data: r2,
        replace: l2
      });
      t2.setToBlock(c2, t2.positions.END);
    });
  }
  /**
   * Fetch nodes from Element node
   *
   * @param {Node} node - current node
   * @param {Node[]} nodes - processed nodes
   * @param {Node} destNode - destination node
   */
  processElementNode(s2, e2, t2) {
    const o2 = Object.keys(this.toolsTags), i2 = s2, { tool: n2 } = this.toolsTags[i2.tagName] || {}, r2 = this.tagsByTool[n2 == null ? void 0 : n2.name] || [], a2 = o2.includes(i2.tagName), l2 = d.blockElements.includes(i2.tagName.toLowerCase()), c2 = Array.from(i2.children).some(
      ({ tagName: h2 }) => o2.includes(h2) && !r2.includes(h2)
    ), u2 = Array.from(i2.children).some(
      ({ tagName: h2 }) => d.blockElements.includes(h2.toLowerCase())
    );
    if (!l2 && !a2 && !c2)
      return t2.appendChild(i2), [...e2, t2];
    if (a2 && !c2 || l2 && !u2 && !c2)
      return [...e2, t2, i2];
  }
  /**
   * Recursively divide HTML string to two types of nodes:
   * 1. Block element
   * 2. Document Fragments contained text and markup tags like a, b, i etc.
   *
   * @param {Node} wrapper - wrapper of paster HTML content
   * @returns {Node[]}
   */
  getNodes(s2) {
    const e2 = Array.from(s2.childNodes);
    let t2;
    const o2 = (i2, n2) => {
      if (d.isEmpty(n2) && !d.isSingleTag(n2))
        return i2;
      const r2 = i2[i2.length - 1];
      let a2 = new DocumentFragment();
      switch (r2 && d.isFragment(r2) && (a2 = i2.pop()), n2.nodeType) {
        case Node.ELEMENT_NODE:
          if (t2 = this.processElementNode(n2, i2, a2), t2)
            return t2;
          break;
        case Node.TEXT_NODE:
          return a2.appendChild(n2), [...i2, a2];
        default:
          return [...i2, a2];
      }
      return [...i2, ...Array.from(n2.childNodes).reduce(o2, [])];
    };
    return e2.reduce(o2, []);
  }
  /**
   * Compose paste event with passed type and detail
   *
   * @param {string} type - event type
   * @param {PasteEventDetail} detail - event detail
   */
  composePasteEvent(s2, e2) {
    return new CustomEvent(s2, {
      detail: e2
    });
  }
};
let Ct = Bt;
Ct.PATTERN_PROCESSING_MAX_LENGTH = 450;
class ai extends T {
  constructor() {
    super(...arguments), this.toolsDontSupportReadOnly = [], this.readOnlyEnabled = false;
  }
  /**
   * Returns state of read only mode
   */
  get isEnabled() {
    return this.readOnlyEnabled;
  }
  /**
   * Set initial state
   */
  async prepare() {
    const { Tools: e2 } = this.Editor, { blockTools: t2 } = e2, o2 = [];
    Array.from(t2.entries()).forEach(([i2, n2]) => {
      n2.isReadOnlySupported || o2.push(i2);
    }), this.toolsDontSupportReadOnly = o2, this.config.readOnly && o2.length > 0 && this.throwCriticalError(), this.toggle(this.config.readOnly);
  }
  /**
   * Set read-only mode or toggle current state
   * Call all Modules `toggleReadOnly` method and re-render Editor
   *
   * @param {boolean} state - (optional) read-only state or toggle
   */
  async toggle(e2 = !this.readOnlyEnabled) {
    e2 && this.toolsDontSupportReadOnly.length > 0 && this.throwCriticalError();
    const t2 = this.readOnlyEnabled;
    this.readOnlyEnabled = e2;
    for (const i2 in this.Editor)
      this.Editor[i2].toggleReadOnly && this.Editor[i2].toggleReadOnly(e2);
    if (t2 === e2)
      return this.readOnlyEnabled;
    const o2 = await this.Editor.Saver.save();
    return await this.Editor.BlockManager.clear(), await this.Editor.Renderer.render(o2.blocks), this.readOnlyEnabled;
  }
  /**
   * Throws an error about tools which don't support read-only mode
   */
  throwCriticalError() {
    throw new ht(
      `To enable read-only mode all connected tools should support it. Tools ${this.toolsDontSupportReadOnly.join(", ")} don't support read-only mode.`
    );
  }
}
class fe extends T {
  constructor() {
    super(...arguments), this.isRectSelectionActivated = false, this.SCROLL_SPEED = 3, this.HEIGHT_OF_SCROLL_ZONE = 40, this.BOTTOM_SCROLL_ZONE = 1, this.TOP_SCROLL_ZONE = 2, this.MAIN_MOUSE_BUTTON = 0, this.mousedown = false, this.isScrolling = false, this.inScrollZone = null, this.startX = 0, this.startY = 0, this.mouseX = 0, this.mouseY = 0, this.stackOfSelected = [], this.listenerIds = [];
  }
  /**
   * CSS classes for the Block
   *
   * @returns {{wrapper: string, content: string}}
   */
  static get CSS() {
    return {
      overlay: "codex-editor-overlay",
      overlayContainer: "codex-editor-overlay__container",
      rect: "codex-editor-overlay__rectangle",
      topScrollZone: "codex-editor-overlay__scroll-zone--top",
      bottomScrollZone: "codex-editor-overlay__scroll-zone--bottom"
    };
  }
  /**
   * Module Preparation
   * Creating rect and hang handlers
   */
  prepare() {
    this.enableModuleBindings();
  }
  /**
   * Init rect params
   *
   * @param {number} pageX - X coord of mouse
   * @param {number} pageY - Y coord of mouse
   */
  startSelection(e2, t2) {
    const o2 = document.elementFromPoint(e2 - window.pageXOffset, t2 - window.pageYOffset);
    o2.closest(`.${this.Editor.Toolbar.CSS.toolbar}`) || (this.Editor.BlockSelection.allBlocksSelected = false, this.clearSelection(), this.stackOfSelected = []);
    const n2 = [
      `.${F.CSS.content}`,
      `.${this.Editor.Toolbar.CSS.toolbar}`,
      `.${this.Editor.InlineToolbar.CSS.inlineToolbar}`
    ], r2 = o2.closest("." + this.Editor.UI.CSS.editorWrapper), a2 = n2.some((l2) => !!o2.closest(l2));
    !r2 || a2 || (this.mousedown = true, this.startX = e2, this.startY = t2);
  }
  /**
   * Clear all params to end selection
   */
  endSelection() {
    this.mousedown = false, this.startX = 0, this.startY = 0, this.overlayRectangle.style.display = "none";
  }
  /**
   * is RectSelection Activated
   */
  isRectActivated() {
    return this.isRectSelectionActivated;
  }
  /**
   * Mark that selection is end
   */
  clearSelection() {
    this.isRectSelectionActivated = false;
  }
  /**
   * Sets Module necessary event handlers
   */
  enableModuleBindings() {
    const { container: e2 } = this.genHTML();
    this.listeners.on(e2, "mousedown", (t2) => {
      this.processMouseDown(t2);
    }, false), this.listeners.on(document.body, "mousemove", Ie((t2) => {
      this.processMouseMove(t2);
    }, 10), {
      passive: true
    }), this.listeners.on(document.body, "mouseleave", () => {
      this.processMouseLeave();
    }), this.listeners.on(window, "scroll", Ie((t2) => {
      this.processScroll(t2);
    }, 10), {
      passive: true
    }), this.listeners.on(document.body, "mouseup", () => {
      this.processMouseUp();
    }, false);
  }
  /**
   * Handle mouse down events
   *
   * @param {MouseEvent} mouseEvent - mouse event payload
   */
  processMouseDown(e2) {
    if (e2.button !== this.MAIN_MOUSE_BUTTON)
      return;
    e2.target.closest(d.allInputsSelector) !== null || this.startSelection(e2.pageX, e2.pageY);
  }
  /**
   * Handle mouse move events
   *
   * @param {MouseEvent} mouseEvent - mouse event payload
   */
  processMouseMove(e2) {
    this.changingRectangle(e2), this.scrollByZones(e2.clientY);
  }
  /**
   * Handle mouse leave
   */
  processMouseLeave() {
    this.clearSelection(), this.endSelection();
  }
  /**
   * @param {MouseEvent} mouseEvent - mouse event payload
   */
  processScroll(e2) {
    this.changingRectangle(e2);
  }
  /**
   * Handle mouse up
   */
  processMouseUp() {
    this.clearSelection(), this.endSelection();
  }
  /**
   * Scroll If mouse in scroll zone
   *
   * @param {number} clientY - Y coord of mouse
   */
  scrollByZones(e2) {
    if (this.inScrollZone = null, e2 <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.TOP_SCROLL_ZONE), document.documentElement.clientHeight - e2 <= this.HEIGHT_OF_SCROLL_ZONE && (this.inScrollZone = this.BOTTOM_SCROLL_ZONE), !this.inScrollZone) {
      this.isScrolling = false;
      return;
    }
    this.isScrolling || (this.scrollVertical(this.inScrollZone === this.TOP_SCROLL_ZONE ? -this.SCROLL_SPEED : this.SCROLL_SPEED), this.isScrolling = true);
  }
  /**
   * Generates required HTML elements
   *
   * @returns {Object<string, Element>}
   */
  genHTML() {
    const { UI: e2 } = this.Editor, t2 = e2.nodes.holder.querySelector("." + e2.CSS.editorWrapper), o2 = d.make("div", fe.CSS.overlay, {}), i2 = d.make("div", fe.CSS.overlayContainer, {}), n2 = d.make("div", fe.CSS.rect, {});
    return i2.appendChild(n2), o2.appendChild(i2), t2.appendChild(o2), this.overlayRectangle = n2, {
      container: t2,
      overlay: o2
    };
  }
  /**
   * Activates scrolling if blockSelection is active and mouse is in scroll zone
   *
   * @param {number} speed - speed of scrolling
   */
  scrollVertical(e2) {
    if (!(this.inScrollZone && this.mousedown))
      return;
    const t2 = window.pageYOffset;
    window.scrollBy(0, e2), this.mouseY += window.pageYOffset - t2, setTimeout(() => {
      this.scrollVertical(e2);
    }, 0);
  }
  /**
   * Handles the change in the rectangle and its effect
   *
   * @param {MouseEvent} event - mouse event
   */
  changingRectangle(e2) {
    if (!this.mousedown)
      return;
    e2.pageY !== void 0 && (this.mouseX = e2.pageX, this.mouseY = e2.pageY);
    const { rightPos: t2, leftPos: o2, index: i2 } = this.genInfoForMouseSelection(), n2 = this.startX > t2 && this.mouseX > t2, r2 = this.startX < o2 && this.mouseX < o2;
    this.rectCrossesBlocks = !(n2 || r2), this.isRectSelectionActivated || (this.rectCrossesBlocks = false, this.isRectSelectionActivated = true, this.shrinkRectangleToPoint(), this.overlayRectangle.style.display = "block"), this.updateRectangleSize(), this.Editor.Toolbar.close(), i2 !== void 0 && (this.trySelectNextBlock(i2), this.inverseSelection(), m.get().removeAllRanges());
  }
  /**
   * Shrink rect to singular point
   */
  shrinkRectangleToPoint() {
    this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`;
  }
  /**
   * Select or unselect all of blocks in array if rect is out or in selectable area
   */
  inverseSelection() {
    const t2 = this.Editor.BlockManager.getBlockByIndex(this.stackOfSelected[0]).selected;
    if (this.rectCrossesBlocks && !t2)
      for (const o2 of this.stackOfSelected)
        this.Editor.BlockSelection.selectBlockByIndex(o2);
    if (!this.rectCrossesBlocks && t2)
      for (const o2 of this.stackOfSelected)
        this.Editor.BlockSelection.unSelectBlockByIndex(o2);
  }
  /**
   * Updates size of rectangle
   */
  updateRectangleSize() {
    this.mouseY >= this.startY ? (this.overlayRectangle.style.top = `${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.bottom = `calc(100% - ${this.mouseY - window.pageYOffset}px`) : (this.overlayRectangle.style.bottom = `calc(100% - ${this.startY - window.pageYOffset}px`, this.overlayRectangle.style.top = `${this.mouseY - window.pageYOffset}px`), this.mouseX >= this.startX ? (this.overlayRectangle.style.left = `${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.right = `calc(100% - ${this.mouseX - window.pageXOffset}px`) : (this.overlayRectangle.style.right = `calc(100% - ${this.startX - window.pageXOffset}px`, this.overlayRectangle.style.left = `${this.mouseX - window.pageXOffset}px`);
  }
  /**
   * Collects information needed to determine the behavior of the rectangle
   *
   * @returns {object} index - index next Block, leftPos - start of left border of Block, rightPos - right border
   */
  genInfoForMouseSelection() {
    const t2 = document.body.offsetWidth / 2, o2 = this.mouseY - window.pageYOffset, i2 = document.elementFromPoint(t2, o2), n2 = this.Editor.BlockManager.getBlockByChildNode(i2);
    let r2;
    n2 !== void 0 && (r2 = this.Editor.BlockManager.blocks.findIndex((h2) => h2.holder === n2.holder));
    const a2 = this.Editor.BlockManager.lastBlock.holder.querySelector("." + F.CSS.content), l2 = Number.parseInt(window.getComputedStyle(a2).width, 10) / 2, c2 = t2 - l2, u2 = t2 + l2;
    return {
      index: r2,
      leftPos: c2,
      rightPos: u2
    };
  }
  /**
   * Select block with index index
   *
   * @param index - index of block in redactor
   */
  addBlockInSelection(e2) {
    this.rectCrossesBlocks && this.Editor.BlockSelection.selectBlockByIndex(e2), this.stackOfSelected.push(e2);
  }
  /**
   * Adds a block to the selection and determines which blocks should be selected
   *
   * @param {object} index - index of new block in the reactor
   */
  trySelectNextBlock(e2) {
    const t2 = this.stackOfSelected[this.stackOfSelected.length - 1] === e2, o2 = this.stackOfSelected.length, i2 = 1, n2 = -1, r2 = 0;
    if (t2)
      return;
    const a2 = this.stackOfSelected[o2 - 1] - this.stackOfSelected[o2 - 2] > 0;
    let l2 = r2;
    o2 > 1 && (l2 = a2 ? i2 : n2);
    const c2 = e2 > this.stackOfSelected[o2 - 1] && l2 === i2, u2 = e2 < this.stackOfSelected[o2 - 1] && l2 === n2, f2 = !(c2 || u2 || l2 === r2);
    if (!f2 && (e2 > this.stackOfSelected[o2 - 1] || this.stackOfSelected[o2 - 1] === void 0)) {
      let v2 = this.stackOfSelected[o2 - 1] + 1 || e2;
      for (v2; v2 <= e2; v2++)
        this.addBlockInSelection(v2);
      return;
    }
    if (!f2 && e2 < this.stackOfSelected[o2 - 1]) {
      for (let v2 = this.stackOfSelected[o2 - 1] - 1; v2 >= e2; v2--)
        this.addBlockInSelection(v2);
      return;
    }
    if (!f2)
      return;
    let k2 = o2 - 1, p2;
    for (e2 > this.stackOfSelected[o2 - 1] ? p2 = () => e2 > this.stackOfSelected[k2] : p2 = () => e2 < this.stackOfSelected[k2]; p2(); )
      this.rectCrossesBlocks && this.Editor.BlockSelection.unSelectBlockByIndex(this.stackOfSelected[k2]), this.stackOfSelected.pop(), k2--;
  }
}
class li extends T {
  /**
   * Renders passed blocks as one batch
   *
   * @param blocksData - blocks to render
   */
  async render(e2) {
    return new Promise((t2) => {
      const { Tools: o2, BlockManager: i2 } = this.Editor;
      if (e2.length === 0)
        i2.insert();
      else {
        const n2 = e2.map(({ type: r2, data: a2, tunes: l2, id: c2 }) => {
          o2.available.has(r2) === false && (X(`Tool «${r2}» is not found. Check 'tools' property at the Editor.js config.`, "warn"), a2 = this.composeStubDataForTool(r2, a2, c2), r2 = o2.stubTool);
          let u2;
          try {
            u2 = i2.composeBlock({
              id: c2,
              tool: r2,
              data: a2,
              tunes: l2
            });
          } catch (h2) {
            L(`Block «${r2}» skipped because of plugins error`, "error", {
              data: a2,
              error: h2
            }), a2 = this.composeStubDataForTool(r2, a2, c2), r2 = o2.stubTool, u2 = i2.composeBlock({
              id: c2,
              tool: r2,
              data: a2,
              tunes: l2
            });
          }
          return u2;
        });
        i2.insertMany(n2);
      }
      window.requestIdleCallback(() => {
        t2();
      }, { timeout: 2e3 });
    });
  }
  /**
   * Create data for the Stub Tool that will be used instead of unavailable tool
   *
   * @param tool - unavailable tool name to stub
   * @param data - data of unavailable block
   * @param [id] - id of unavailable block
   */
  composeStubDataForTool(e2, t2, o2) {
    const { Tools: i2 } = this.Editor;
    let n2 = e2;
    if (i2.unavailable.has(e2)) {
      const r2 = i2.unavailable.get(e2).toolbox;
      r2 !== void 0 && r2[0].title !== void 0 && (n2 = r2[0].title);
    }
    return {
      savedData: {
        id: o2,
        type: e2,
        data: t2
      },
      title: n2
    };
  }
}
class ci extends T {
  /**
   * Composes new chain of Promises to fire them alternatelly
   *
   * @returns {OutputData}
   */
  async save() {
    const { BlockManager: e2, Tools: t2 } = this.Editor, o2 = e2.blocks, i2 = [];
    try {
      o2.forEach((a2) => {
        i2.push(this.getSavedData(a2));
      });
      const n2 = await Promise.all(i2), r2 = await gt(n2, (a2) => t2.blockTools.get(a2).sanitizeConfig);
      return this.makeOutput(r2);
    } catch (n2) {
      X("Saving failed due to the Error %o", "error", n2);
    }
  }
  /**
   * Saves and validates
   *
   * @param {Block} block - Editor's Tool
   * @returns {ValidatedData} - Tool's validated data
   */
  async getSavedData(e2) {
    const t2 = await e2.save(), o2 = t2 && await e2.validate(t2.data);
    return {
      ...t2,
      isValid: o2
    };
  }
  /**
   * Creates output object with saved data, time and version of editor
   *
   * @param {ValidatedData} allExtractedData - data extracted from Blocks
   * @returns {OutputData}
   */
  makeOutput(e2) {
    const t2 = [];
    return e2.forEach(({ id: o2, tool: i2, data: n2, tunes: r2, isValid: a2 }) => {
      if (!a2) {
        L(`Block «${i2}» skipped because saved data is invalid`);
        return;
      }
      if (i2 === this.Editor.Tools.stubTool) {
        t2.push(n2);
        return;
      }
      const l2 = {
        id: o2,
        type: i2,
        data: n2,
        ...!q(r2) && {
          tunes: r2
        }
      };
      t2.push(l2);
    }), {
      time: +/* @__PURE__ */ new Date(),
      blocks: t2,
      version: "2.29.0-rc.1"
    };
  }
}
var Pe = {}, di = {
  get exports() {
    return Pe;
  },
  set exports(s2) {
    Pe = s2;
  }
};
(function(s2, e2) {
  (function(t2, o2) {
    s2.exports = o2();
  })(window, function() {
    return function(t2) {
      var o2 = {};
      function i2(n2) {
        if (o2[n2])
          return o2[n2].exports;
        var r2 = o2[n2] = { i: n2, l: false, exports: {} };
        return t2[n2].call(r2.exports, r2, r2.exports, i2), r2.l = true, r2.exports;
      }
      return i2.m = t2, i2.c = o2, i2.d = function(n2, r2, a2) {
        i2.o(n2, r2) || Object.defineProperty(n2, r2, { enumerable: true, get: a2 });
      }, i2.r = function(n2) {
        typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(n2, "__esModule", { value: true });
      }, i2.t = function(n2, r2) {
        if (1 & r2 && (n2 = i2(n2)), 8 & r2 || 4 & r2 && typeof n2 == "object" && n2 && n2.__esModule)
          return n2;
        var a2 = /* @__PURE__ */ Object.create(null);
        if (i2.r(a2), Object.defineProperty(a2, "default", { enumerable: true, value: n2 }), 2 & r2 && typeof n2 != "string")
          for (var l2 in n2)
            i2.d(a2, l2, (function(c2) {
              return n2[c2];
            }).bind(null, l2));
        return a2;
      }, i2.n = function(n2) {
        var r2 = n2 && n2.__esModule ? function() {
          return n2.default;
        } : function() {
          return n2;
        };
        return i2.d(r2, "a", r2), r2;
      }, i2.o = function(n2, r2) {
        return Object.prototype.hasOwnProperty.call(n2, r2);
      }, i2.p = "/", i2(i2.s = 4);
    }([function(t2, o2, i2) {
      var n2 = i2(1), r2 = i2(2);
      typeof (r2 = r2.__esModule ? r2.default : r2) == "string" && (r2 = [[t2.i, r2, ""]]);
      var a2 = { insert: "head", singleton: false };
      n2(r2, a2), t2.exports = r2.locals || {};
    }, function(t2, o2, i2) {
      var n2, r2 = function() {
        return n2 === void 0 && (n2 = !!(window && document && document.all && !window.atob)), n2;
      }, a2 = function() {
        var y2 = {};
        return function(x2) {
          if (y2[x2] === void 0) {
            var w2 = document.querySelector(x2);
            if (window.HTMLIFrameElement && w2 instanceof window.HTMLIFrameElement)
              try {
                w2 = w2.contentDocument.head;
              } catch {
                w2 = null;
              }
            y2[x2] = w2;
          }
          return y2[x2];
        };
      }(), l2 = [];
      function c2(y2) {
        for (var x2 = -1, w2 = 0; w2 < l2.length; w2++)
          if (l2[w2].identifier === y2) {
            x2 = w2;
            break;
          }
        return x2;
      }
      function u2(y2, x2) {
        for (var w2 = {}, I2 = [], R2 = 0; R2 < y2.length; R2++) {
          var b2 = y2[R2], g2 = x2.base ? b2[0] + x2.base : b2[0], E2 = w2[g2] || 0, C2 = "".concat(g2, " ").concat(E2);
          w2[g2] = E2 + 1;
          var O2 = c2(C2), S2 = { css: b2[1], media: b2[2], sourceMap: b2[3] };
          O2 !== -1 ? (l2[O2].references++, l2[O2].updater(S2)) : l2.push({ identifier: C2, updater: _2(S2, x2), references: 1 }), I2.push(C2);
        }
        return I2;
      }
      function h2(y2) {
        var x2 = document.createElement("style"), w2 = y2.attributes || {};
        if (w2.nonce === void 0) {
          var I2 = i2.nc;
          I2 && (w2.nonce = I2);
        }
        if (Object.keys(w2).forEach(function(b2) {
          x2.setAttribute(b2, w2[b2]);
        }), typeof y2.insert == "function")
          y2.insert(x2);
        else {
          var R2 = a2(y2.insert || "head");
          if (!R2)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          R2.appendChild(x2);
        }
        return x2;
      }
      var f2, k2 = (f2 = [], function(y2, x2) {
        return f2[y2] = x2, f2.filter(Boolean).join(`
`);
      });
      function p2(y2, x2, w2, I2) {
        var R2 = w2 ? "" : I2.media ? "@media ".concat(I2.media, " {").concat(I2.css, "}") : I2.css;
        if (y2.styleSheet)
          y2.styleSheet.cssText = k2(x2, R2);
        else {
          var b2 = document.createTextNode(R2), g2 = y2.childNodes;
          g2[x2] && y2.removeChild(g2[x2]), g2.length ? y2.insertBefore(b2, g2[x2]) : y2.appendChild(b2);
        }
      }
      function v2(y2, x2, w2) {
        var I2 = w2.css, R2 = w2.media, b2 = w2.sourceMap;
        if (R2 ? y2.setAttribute("media", R2) : y2.removeAttribute("media"), b2 && btoa && (I2 += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(b2)))), " */")), y2.styleSheet)
          y2.styleSheet.cssText = I2;
        else {
          for (; y2.firstChild; )
            y2.removeChild(y2.firstChild);
          y2.appendChild(document.createTextNode(I2));
        }
      }
      var A2 = null, N2 = 0;
      function _2(y2, x2) {
        var w2, I2, R2;
        if (x2.singleton) {
          var b2 = N2++;
          w2 = A2 || (A2 = h2(x2)), I2 = p2.bind(null, w2, b2, false), R2 = p2.bind(null, w2, b2, true);
        } else
          w2 = h2(x2), I2 = v2.bind(null, w2, x2), R2 = function() {
            (function(g2) {
              if (g2.parentNode === null)
                return false;
              g2.parentNode.removeChild(g2);
            })(w2);
          };
        return I2(y2), function(g2) {
          if (g2) {
            if (g2.css === y2.css && g2.media === y2.media && g2.sourceMap === y2.sourceMap)
              return;
            I2(y2 = g2);
          } else
            R2();
        };
      }
      t2.exports = function(y2, x2) {
        (x2 = x2 || {}).singleton || typeof x2.singleton == "boolean" || (x2.singleton = r2());
        var w2 = u2(y2 = y2 || [], x2);
        return function(I2) {
          if (I2 = I2 || [], Object.prototype.toString.call(I2) === "[object Array]") {
            for (var R2 = 0; R2 < w2.length; R2++) {
              var b2 = c2(w2[R2]);
              l2[b2].references--;
            }
            for (var g2 = u2(I2, x2), E2 = 0; E2 < w2.length; E2++) {
              var C2 = c2(w2[E2]);
              l2[C2].references === 0 && (l2[C2].updater(), l2.splice(C2, 1));
            }
            w2 = g2;
          }
        };
      };
    }, function(t2, o2, i2) {
      (o2 = i2(3)(false)).push([t2.i, `.ce-paragraph {
    line-height: 1.6em;
    outline: none;
}

.ce-paragraph[data-placeholder]:empty::before{
  content: attr(data-placeholder);
  color: #707684;
  font-weight: normal;
  opacity: 0;
}

/** Show placeholder at the first paragraph if Editor is empty */
.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before {
  opacity: 1;
}

.codex-editor--toolbox-opened .ce-block:first-child .ce-paragraph[data-placeholder]:empty::before,
.codex-editor--empty .ce-block:first-child .ce-paragraph[data-placeholder]:empty:focus::before {
  opacity: 0;
}

.ce-paragraph p:first-of-type{
    margin-top: 0;
}

.ce-paragraph p:last-of-type{
    margin-bottom: 0;
}
`, ""]), t2.exports = o2;
    }, function(t2, o2, i2) {
      t2.exports = function(n2) {
        var r2 = [];
        return r2.toString = function() {
          return this.map(function(a2) {
            var l2 = function(c2, u2) {
              var h2 = c2[1] || "", f2 = c2[3];
              if (!f2)
                return h2;
              if (u2 && typeof btoa == "function") {
                var k2 = (v2 = f2, A2 = btoa(unescape(encodeURIComponent(JSON.stringify(v2)))), N2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(A2), "/*# ".concat(N2, " */")), p2 = f2.sources.map(function(_2) {
                  return "/*# sourceURL=".concat(f2.sourceRoot || "").concat(_2, " */");
                });
                return [h2].concat(p2).concat([k2]).join(`
`);
              }
              var v2, A2, N2;
              return [h2].join(`
`);
            }(a2, n2);
            return a2[2] ? "@media ".concat(a2[2], " {").concat(l2, "}") : l2;
          }).join("");
        }, r2.i = function(a2, l2, c2) {
          typeof a2 == "string" && (a2 = [[null, a2, ""]]);
          var u2 = {};
          if (c2)
            for (var h2 = 0; h2 < this.length; h2++) {
              var f2 = this[h2][0];
              f2 != null && (u2[f2] = true);
            }
          for (var k2 = 0; k2 < a2.length; k2++) {
            var p2 = [].concat(a2[k2]);
            c2 && u2[p2[0]] || (l2 && (p2[2] ? p2[2] = "".concat(l2, " and ").concat(p2[2]) : p2[2] = l2), r2.push(p2));
          }
        }, r2;
      };
    }, function(t2, o2, i2) {
      i2.r(o2), i2.d(o2, "default", function() {
        return a2;
      }), i2(0);
      function n2(l2, c2) {
        for (var u2 = 0; u2 < c2.length; u2++) {
          var h2 = c2[u2];
          h2.enumerable = h2.enumerable || false, h2.configurable = true, "value" in h2 && (h2.writable = true), Object.defineProperty(l2, h2.key, h2);
        }
      }
      function r2(l2, c2, u2) {
        return c2 && n2(l2.prototype, c2), u2 && n2(l2, u2), l2;
      }
      /**
       * Base Paragraph Block for the Editor.js.
       * Represents a regular text block
       *
       * @author CodeX (team@codex.so)
       * @copyright CodeX 2018
       * @license The MIT License (MIT)
       */
      var a2 = function() {
        function l2(c2) {
          var u2 = c2.data, h2 = c2.config, f2 = c2.api, k2 = c2.readOnly;
          (function(p2, v2) {
            if (!(p2 instanceof v2))
              throw new TypeError("Cannot call a class as a function");
          })(this, l2), this.api = f2, this.readOnly = k2, this._CSS = { block: this.api.styles.block, wrapper: "ce-paragraph" }, this.readOnly || (this.onKeyUp = this.onKeyUp.bind(this)), this._placeholder = h2.placeholder ? h2.placeholder : l2.DEFAULT_PLACEHOLDER, this._data = {}, this._element = null, this._preserveBlank = h2.preserveBlank !== void 0 && h2.preserveBlank, this.data = u2;
        }
        return r2(l2, null, [{ key: "DEFAULT_PLACEHOLDER", get: function() {
          return "";
        } }]), r2(l2, [{ key: "onKeyUp", value: function(c2) {
          c2.code !== "Backspace" && c2.code !== "Delete" || this._element.textContent === "" && (this._element.innerHTML = "");
        } }, { key: "drawView", value: function() {
          var c2 = document.createElement("DIV");
          return c2.classList.add(this._CSS.wrapper, this._CSS.block), c2.contentEditable = false, c2.dataset.placeholder = this.api.i18n.t(this._placeholder), this.readOnly || (c2.contentEditable = true, c2.addEventListener("keyup", this.onKeyUp)), c2;
        } }, { key: "render", value: function() {
          return this._element === null && (this._element = this.drawView()), this.hydrate(), this._element;
        } }, { key: "merge", value: function(c2) {
          var u2 = { text: this.data.text + c2.text };
          this.data = u2;
        } }, { key: "validate", value: function(c2) {
          return !(c2.text.trim() === "" && !this._preserveBlank);
        } }, { key: "save", value: function(c2) {
          return { text: c2.innerHTML };
        } }, { key: "onPaste", value: function(c2) {
          var u2 = { text: c2.detail.data.innerHTML };
          this.data = u2;
        } }, { key: "hydrate", value: function() {
          var c2 = this;
          window.requestAnimationFrame(function() {
            c2._element.innerHTML = c2._data.text || "";
          });
        } }, { key: "data", get: function() {
          if (this._element !== null) {
            var c2 = this._element.innerHTML;
            this._data.text = c2;
          }
          return this._data;
        }, set: function(c2) {
          this._data = c2 || {}, this._element !== null && this.hydrate();
        } }], [{ key: "conversionConfig", get: function() {
          return { export: "text", import: "text" };
        } }, { key: "sanitize", get: function() {
          return { text: { br: true } };
        } }, { key: "isReadOnlySupported", get: function() {
          return true;
        } }, { key: "pasteConfig", get: function() {
          return { tags: ["P"] };
        } }, { key: "toolbox", get: function() {
          return { icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M8 9V7.2C8 7.08954 8.08954 7 8.2 7L12 7M16 9V7.2C16 7.08954 15.9105 7 15.8 7L12 7M12 7L12 17M12 17H10M12 17H14"/></svg>', title: "Text" };
        } }]), l2;
      }();
    }]).default;
  });
})(di);
const hi = /* @__PURE__ */ ye(Pe);
class Xe {
  constructor() {
    this.commandName = "bold", this.CSS = {
      button: "ce-inline-tool",
      buttonActive: "ce-inline-tool--active",
      buttonModifier: "ce-inline-tool--bold"
    }, this.nodes = {
      button: void 0
    };
  }
  /**
   * Sanitizer Rule
   * Leave <b> tags
   *
   * @returns {object}
   */
  static get sanitize() {
    return {
      b: {}
    };
  }
  /**
   * Create button for Inline Toolbar
   */
  render() {
    return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Ao, this.nodes.button;
  }
  /**
   * Wrap range with <b> tag
   */
  surround() {
    document.execCommand(this.commandName);
  }
  /**
   * Check selection and set activated state to button if there are <b> tag
   *
   * @returns {boolean}
   */
  checkState() {
    const e2 = document.queryCommandState(this.commandName);
    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e2), e2;
  }
  /**
   * Set a shortcut
   *
   * @returns {boolean}
   */
  get shortcut() {
    return "CMD+B";
  }
}
Xe.isInline = true;
Xe.title = "Bold";
class Ve {
  constructor() {
    this.commandName = "italic", this.CSS = {
      button: "ce-inline-tool",
      buttonActive: "ce-inline-tool--active",
      buttonModifier: "ce-inline-tool--italic"
    }, this.nodes = {
      button: null
    };
  }
  /**
   * Sanitizer Rule
   * Leave <i> tags
   *
   * @returns {object}
   */
  static get sanitize() {
    return {
      i: {}
    };
  }
  /**
   * Create button for Inline Toolbar
   */
  render() {
    return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = Do, this.nodes.button;
  }
  /**
   * Wrap range with <i> tag
   */
  surround() {
    document.execCommand(this.commandName);
  }
  /**
   * Check selection and set activated state to button if there are <i> tag
   */
  checkState() {
    const e2 = document.queryCommandState(this.commandName);
    return this.nodes.button.classList.toggle(this.CSS.buttonActive, e2), e2;
  }
  /**
   * Set a shortcut
   */
  get shortcut() {
    return "CMD+I";
  }
}
Ve.isInline = true;
Ve.title = "Italic";
class qe {
  /**
   * @param api - Editor.js API
   */
  constructor({ api: e2 }) {
    this.commandLink = "createLink", this.commandUnlink = "unlink", this.ENTER_KEY = 13, this.CSS = {
      button: "ce-inline-tool",
      buttonActive: "ce-inline-tool--active",
      buttonModifier: "ce-inline-tool--link",
      buttonUnlink: "ce-inline-tool--unlink",
      input: "ce-inline-tool-input",
      inputShowed: "ce-inline-tool-input--showed"
    }, this.nodes = {
      button: null,
      input: null
    }, this.inputOpened = false, this.toolbar = e2.toolbar, this.inlineToolbar = e2.inlineToolbar, this.notifier = e2.notifier, this.i18n = e2.i18n, this.selection = new m();
  }
  /**
   * Sanitizer Rule
   * Leave <a> tags
   *
   * @returns {object}
   */
  static get sanitize() {
    return {
      a: {
        href: true,
        target: "_blank",
        rel: "nofollow"
      }
    };
  }
  /**
   * Create button for Inline Toolbar
   */
  render() {
    return this.nodes.button = document.createElement("button"), this.nodes.button.type = "button", this.nodes.button.classList.add(this.CSS.button, this.CSS.buttonModifier), this.nodes.button.innerHTML = ot, this.nodes.button;
  }
  /**
   * Input for the link
   */
  renderActions() {
    return this.nodes.input = document.createElement("input"), this.nodes.input.placeholder = this.i18n.t("Add a link"), this.nodes.input.classList.add(this.CSS.input), this.nodes.input.addEventListener("keydown", (e2) => {
      e2.keyCode === this.ENTER_KEY && this.enterPressed(e2);
    }), this.nodes.input;
  }
  /**
   * Handle clicks on the Inline Toolbar icon
   *
   * @param {Range} range - range to wrap with link
   */
  surround(e2) {
    if (e2) {
      this.inputOpened ? (this.selection.restore(), this.selection.removeFakeBackground()) : (this.selection.setFakeBackground(), this.selection.save());
      const t2 = this.selection.findParentTag("A");
      if (t2) {
        this.selection.expandToTag(t2), this.unlink(), this.closeActions(), this.checkState(), this.toolbar.close();
        return;
      }
    }
    this.toggleActions();
  }
  /**
   * Check selection and set activated state to button if there are <a> tag
   */
  checkState() {
    const e2 = this.selection.findParentTag("A");
    if (e2) {
      this.nodes.button.innerHTML = jo, this.nodes.button.classList.add(this.CSS.buttonUnlink), this.nodes.button.classList.add(this.CSS.buttonActive), this.openActions();
      const t2 = e2.getAttribute("href");
      this.nodes.input.value = t2 !== "null" ? t2 : "", this.selection.save();
    } else
      this.nodes.button.innerHTML = ot, this.nodes.button.classList.remove(this.CSS.buttonUnlink), this.nodes.button.classList.remove(this.CSS.buttonActive);
    return !!e2;
  }
  /**
   * Function called with Inline Toolbar closing
   */
  clear() {
    this.closeActions();
  }
  /**
   * Set a shortcut
   */
  get shortcut() {
    return "CMD+K";
  }
  /**
   * Show/close link input
   */
  toggleActions() {
    this.inputOpened ? this.closeActions(false) : this.openActions(true);
  }
  /**
   * @param {boolean} needFocus - on link creation we need to focus input. On editing - nope.
   */
  openActions(e2 = false) {
    this.nodes.input.classList.add(this.CSS.inputShowed), e2 && this.nodes.input.focus(), this.inputOpened = true;
  }
  /**
   * Close input
   *
   * @param {boolean} clearSavedSelection — we don't need to clear saved selection
   *                                        on toggle-clicks on the icon of opened Toolbar
   */
  closeActions(e2 = true) {
    if (this.selection.isFakeBackgroundEnabled) {
      const t2 = new m();
      t2.save(), this.selection.restore(), this.selection.removeFakeBackground(), t2.restore();
    }
    this.nodes.input.classList.remove(this.CSS.inputShowed), this.nodes.input.value = "", e2 && this.selection.clearSaved(), this.inputOpened = false;
  }
  /**
   * Enter pressed on input
   *
   * @param {KeyboardEvent} event - enter keydown event
   */
  enterPressed(e2) {
    let t2 = this.nodes.input.value || "";
    if (!t2.trim()) {
      this.selection.restore(), this.unlink(), e2.preventDefault(), this.closeActions();
      return;
    }
    if (!this.validateURL(t2)) {
      this.notifier.show({
        message: "Pasted link is not valid.",
        style: "error"
      }), L("Incorrect Link pasted", "warn", t2);
      return;
    }
    t2 = this.prepareLink(t2), this.selection.restore(), this.selection.removeFakeBackground(), this.insertLink(t2), e2.preventDefault(), e2.stopPropagation(), e2.stopImmediatePropagation(), this.selection.collapseToEnd(), this.inlineToolbar.close();
  }
  /**
   * Detects if passed string is URL
   *
   * @param {string} str - string to validate
   * @returns {boolean}
   */
  validateURL(e2) {
    return !/\s/.test(e2);
  }
  /**
   * Process link before injection
   * - sanitize
   * - add protocol for links like 'google.com'
   *
   * @param {string} link - raw user input
   */
  prepareLink(e2) {
    return e2 = e2.trim(), e2 = this.addProtocol(e2), e2;
  }
  /**
   * Add 'http' protocol to the links like 'vc.ru', 'google.com'
   *
   * @param {string} link - string to process
   */
  addProtocol(e2) {
    if (/^(\w+):(\/\/)?/.test(e2))
      return e2;
    const t2 = /^\/[^/\s]/.test(e2), o2 = e2.substring(0, 1) === "#", i2 = /^\/\/[^/\s]/.test(e2);
    return !t2 && !o2 && !i2 && (e2 = "http://" + e2), e2;
  }
  /**
   * Inserts <a> tag with "href"
   *
   * @param {string} link - "href" value
   */
  insertLink(e2) {
    const t2 = this.selection.findParentTag("A");
    t2 && this.selection.expandToTag(t2), document.execCommand(this.commandLink, false, e2);
  }
  /**
   * Removes <a> tag
   */
  unlink() {
    document.execCommand(this.commandUnlink);
  }
}
qe.isInline = true;
qe.title = "Link";
class Tt {
  /**
   * @param options - constructor options
   * @param options.data - stub tool data
   * @param options.api - Editor.js API
   */
  constructor({ data: e2, api: t2 }) {
    this.CSS = {
      wrapper: "ce-stub",
      info: "ce-stub__info",
      title: "ce-stub__title",
      subtitle: "ce-stub__subtitle"
    }, this.api = t2, this.title = e2.title || this.api.i18n.t("Error"), this.subtitle = this.api.i18n.t("The block can not be displayed correctly."), this.savedData = e2.savedData, this.wrapper = this.make();
  }
  /**
   * Returns stub holder
   *
   * @returns {HTMLElement}
   */
  render() {
    return this.wrapper;
  }
  /**
   * Return original Tool data
   *
   * @returns {BlockToolData}
   */
  save() {
    return this.savedData;
  }
  /**
   * Create Tool html markup
   *
   * @returns {HTMLElement}
   */
  make() {
    const e2 = d.make("div", this.CSS.wrapper), t2 = zo, o2 = d.make("div", this.CSS.info), i2 = d.make("div", this.CSS.title, {
      textContent: this.title
    }), n2 = d.make("div", this.CSS.subtitle, {
      textContent: this.subtitle
    });
    return e2.innerHTML = t2, o2.appendChild(i2), o2.appendChild(n2), e2.appendChild(o2), e2;
  }
}
Tt.isReadOnlySupported = true;
class ui extends Ke {
  constructor() {
    super(...arguments), this.type = Be.Inline;
  }
  /**
   * Returns title for Inline Tool if specified by user
   */
  get title() {
    return this.constructable[Ye.Title];
  }
  /**
   * Constructs new InlineTool instance from constructable
   */
  create() {
    return new this.constructable({
      api: this.api.getMethodsForTool(this),
      config: this.settings
    });
  }
}
class pi extends Ke {
  constructor() {
    super(...arguments), this.type = Be.Tune;
  }
  /**
   * Constructs new BlockTune instance from constructable
   *
   * @param data - Tune data
   * @param block - Block API object
   */
  create(e2, t2) {
    return new this.constructable({
      api: this.api.getMethodsForTool(this),
      config: this.settings,
      block: t2,
      data: e2
    });
  }
}
class U extends Map {
  /**
   * Returns Block Tools collection
   */
  get blockTools() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isBlock());
    return new U(e2);
  }
  /**
   * Returns Inline Tools collection
   */
  get inlineTools() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isInline());
    return new U(e2);
  }
  /**
   * Returns Block Tunes collection
   */
  get blockTunes() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isTune());
    return new U(e2);
  }
  /**
   * Returns internal Tools collection
   */
  get internalTools() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => t2.isInternal);
    return new U(e2);
  }
  /**
   * Returns Tools collection provided by user
   */
  get externalTools() {
    const e2 = Array.from(this.entries()).filter(([, t2]) => !t2.isInternal);
    return new U(e2);
  }
}
var fi = Object.defineProperty, gi = Object.getOwnPropertyDescriptor, St = (s2, e2, t2, o2) => {
  for (var i2 = o2 > 1 ? void 0 : o2 ? gi(e2, t2) : e2, n2 = s2.length - 1, r2; n2 >= 0; n2--)
    (r2 = s2[n2]) && (i2 = (o2 ? r2(e2, t2, i2) : r2(i2)) || i2);
  return o2 && i2 && fi(e2, t2, i2), i2;
};
class Ze extends Ke {
  constructor() {
    super(...arguments), this.type = Be.Block, this.inlineTools = new U(), this.tunes = new U();
  }
  /**
   * Creates new Tool instance
   *
   * @param data - Tool data
   * @param block - BlockAPI for current Block
   * @param readOnly - True if Editor is in read-only mode
   */
  create(e2, t2, o2) {
    return new this.constructable({
      data: e2,
      block: t2,
      readOnly: o2,
      api: this.api.getMethodsForTool(this),
      config: this.settings
    });
  }
  /**
   * Returns true if read-only mode is supported by Tool
   */
  get isReadOnlySupported() {
    return this.constructable[re.IsReadOnlySupported] === true;
  }
  /**
   * Returns true if Tool supports linebreaks
   */
  get isLineBreaksEnabled() {
    return this.constructable[re.IsEnabledLineBreaks];
  }
  /**
   * Returns Tool toolbox configuration (internal or user-specified).
   *
   * Merges internal and user-defined toolbox configs based on the following rules:
   *
   * - If both internal and user-defined toolbox configs are arrays their items are merged.
   * Length of the second one is kept.
   *
   * - If both are objects their properties are merged.
   *
   * - If one is an object and another is an array than internal config is replaced with user-defined
   * config. This is made to allow user to override default tool's toolbox representation (single/multiple entries)
   */
  get toolbox() {
    const e2 = this.constructable[re.Toolbox], t2 = this.config[xe.Toolbox];
    if (!q(e2) && t2 !== false)
      return t2 ? Array.isArray(e2) ? Array.isArray(t2) ? t2.map((o2, i2) => {
        const n2 = e2[i2];
        return n2 ? {
          ...n2,
          ...o2
        } : o2;
      }) : [t2] : Array.isArray(t2) ? t2 : [
        {
          ...e2,
          ...t2
        }
      ] : Array.isArray(e2) ? e2 : [e2];
  }
  /**
   * Returns Tool conversion configuration
   */
  get conversionConfig() {
    return this.constructable[re.ConversionConfig];
  }
  /**
   * Returns enabled inline tools for Tool
   */
  get enabledInlineTools() {
    return this.config[xe.EnabledInlineTools] || false;
  }
  /**
   * Returns enabled tunes for Tool
   */
  get enabledBlockTunes() {
    return this.config[xe.EnabledBlockTunes];
  }
  /**
   * Returns Tool paste configuration
   */
  get pasteConfig() {
    return this.constructable[re.PasteConfig] ?? {};
  }
  get sanitizeConfig() {
    const e2 = super.sanitizeConfig, t2 = this.baseSanitizeConfig;
    if (q(e2))
      return t2;
    const o2 = {};
    for (const i2 in e2)
      if (Object.prototype.hasOwnProperty.call(e2, i2)) {
        const n2 = e2[i2];
        z(n2) ? o2[i2] = Object.assign({}, t2, n2) : o2[i2] = n2;
      }
    return o2;
  }
  get baseSanitizeConfig() {
    const e2 = {};
    return Array.from(this.inlineTools.values()).forEach((t2) => Object.assign(e2, t2.sanitizeConfig)), Array.from(this.tunes.values()).forEach((t2) => Object.assign(e2, t2.sanitizeConfig)), e2;
  }
}
St([
  ce
], Ze.prototype, "sanitizeConfig", 1);
St([
  ce
], Ze.prototype, "baseSanitizeConfig", 1);
class bi {
  /**
   * @class
   * @param config - tools config
   * @param editorConfig - EditorJS config
   * @param api - EditorJS API module
   */
  constructor(e2, t2, o2) {
    this.api = o2, this.config = e2, this.editorConfig = t2;
  }
  /**
   * Returns Tool object based on it's type
   *
   * @param name - tool name
   */
  get(e2) {
    const { class: t2, isInternal: o2 = false, ...i2 } = this.config[e2], n2 = this.getConstructor(t2);
    return new n2({
      name: e2,
      constructable: t2,
      config: i2,
      api: this.api,
      isDefault: e2 === this.editorConfig.defaultBlock,
      defaultPlaceholder: this.editorConfig.placeholder,
      isInternal: o2
    });
  }
  /**
   * Find appropriate Tool object constructor for Tool constructable
   *
   * @param constructable - Tools constructable
   */
  getConstructor(e2) {
    switch (true) {
      case e2[Ye.IsInline]:
        return ui;
      case e2[Et.IsTune]:
        return pi;
      default:
        return Ze;
    }
  }
}
class It {
  /**
   * MoveDownTune constructor
   *
   * @param {API} api — Editor's API
   */
  constructor({ api: e2 }) {
    this.CSS = {
      animation: "wobble"
    }, this.api = e2;
  }
  /**
   * Tune's appearance in block settings menu
   */
  render() {
    return {
      icon: mt,
      title: this.api.i18n.t("Move down"),
      onActivate: () => this.handleClick(),
      name: "move-down"
    };
  }
  /**
   * Handle clicks on 'move down' button
   */
  handleClick() {
    const e2 = this.api.blocks.getCurrentBlockIndex(), t2 = this.api.blocks.getBlockByIndex(e2 + 1);
    if (!t2)
      throw new Error("Unable to move Block down since it is already the last");
    const o2 = t2.holder, i2 = o2.getBoundingClientRect();
    let n2 = Math.abs(window.innerHeight - o2.offsetHeight);
    i2.top < window.innerHeight && (n2 = window.scrollY + o2.offsetHeight), window.scrollTo(0, n2), this.api.blocks.move(e2 + 1), this.api.toolbar.toggleBlockSettings(true);
  }
}
It.isTune = true;
class Mt {
  /**
   * DeleteTune constructor
   *
   * @param {API} api - Editor's API
   */
  constructor({ api: e2 }) {
    this.api = e2;
  }
  /**
   * Tune's appearance in block settings menu
   */
  render() {
    return {
      icon: No,
      title: this.api.i18n.t("Delete"),
      name: "delete",
      confirmation: {
        title: this.api.i18n.t("Click to delete"),
        onActivate: () => this.handleClick()
      }
    };
  }
  /**
   * Delete block conditions passed
   */
  handleClick() {
    this.api.blocks.delete();
  }
}
Mt.isTune = true;
class Lt {
  /**
   * MoveUpTune constructor
   *
   * @param {API} api - Editor's API
   */
  constructor({ api: e2 }) {
    this.CSS = {
      animation: "wobble"
    }, this.api = e2;
  }
  /**
   * Tune's appearance in block settings menu
   */
  render() {
    return {
      icon: _o,
      title: this.api.i18n.t("Move up"),
      onActivate: () => this.handleClick(),
      name: "move-up"
    };
  }
  /**
   * Move current block up
   */
  handleClick() {
    const e2 = this.api.blocks.getCurrentBlockIndex(), t2 = this.api.blocks.getBlockByIndex(e2), o2 = this.api.blocks.getBlockByIndex(e2 - 1);
    if (e2 === 0 || !t2 || !o2)
      throw new Error("Unable to move Block up since it is already the first");
    const i2 = t2.holder, n2 = o2.holder, r2 = i2.getBoundingClientRect(), a2 = n2.getBoundingClientRect();
    let l2;
    a2.top > 0 ? l2 = Math.abs(r2.top) - Math.abs(a2.top) : l2 = Math.abs(r2.top) + a2.height, window.scrollBy(0, -1 * l2), this.api.blocks.move(e2 - 1), this.api.toolbar.toggleBlockSettings(true);
  }
}
Lt.isTune = true;
var mi = Object.defineProperty, ki = Object.getOwnPropertyDescriptor, vi = (s2, e2, t2, o2) => {
  for (var i2 = o2 > 1 ? void 0 : o2 ? ki(e2, t2) : e2, n2 = s2.length - 1, r2; n2 >= 0; n2--)
    (r2 = s2[n2]) && (i2 = (o2 ? r2(e2, t2, i2) : r2(i2)) || i2);
  return o2 && i2 && mi(e2, t2, i2), i2;
};
class Ot extends T {
  constructor() {
    super(...arguments), this.stubTool = "stub", this.toolsAvailable = new U(), this.toolsUnavailable = new U();
  }
  /**
   * Returns available Tools
   */
  get available() {
    return this.toolsAvailable;
  }
  /**
   * Returns unavailable Tools
   */
  get unavailable() {
    return this.toolsUnavailable;
  }
  /**
   * Return Tools for the Inline Toolbar
   */
  get inlineTools() {
    return this.available.inlineTools;
  }
  /**
   * Return editor block tools
   */
  get blockTools() {
    return this.available.blockTools;
  }
  /**
   * Return available Block Tunes
   *
   * @returns {object} - object of Inline Tool's classes
   */
  get blockTunes() {
    return this.available.blockTunes;
  }
  /**
   * Returns default Tool object
   */
  get defaultTool() {
    return this.blockTools.get(this.config.defaultBlock);
  }
  /**
   * Returns internal tools
   */
  get internal() {
    return this.available.internalTools;
  }
  /**
   * Creates instances via passed or default configuration
   *
   * @returns {Promise<void>}
   */
  async prepare() {
    if (this.validateTools(), this.config.tools = Me({}, this.internalTools, this.config.tools), !Object.prototype.hasOwnProperty.call(this.config, "tools") || Object.keys(this.config.tools).length === 0)
      throw Error("Can't start without tools");
    const e2 = this.prepareConfig();
    this.factory = new bi(e2, this.config, this.Editor.API);
    const t2 = this.getListOfPrepareFunctions(e2);
    if (t2.length === 0)
      return Promise.resolve();
    await Ht(t2, (o2) => {
      this.toolPrepareMethodSuccess(o2);
    }, (o2) => {
      this.toolPrepareMethodFallback(o2);
    }), this.prepareBlockTools();
  }
  getAllInlineToolsSanitizeConfig() {
    const e2 = {};
    return Array.from(this.inlineTools.values()).forEach((t2) => {
      Object.assign(e2, t2.sanitizeConfig);
    }), e2;
  }
  /**
   * Calls each Tool reset method to clean up anything set by Tool
   */
  destroy() {
    Object.values(this.available).forEach(async (e2) => {
      D(e2.reset) && await e2.reset();
    });
  }
  /**
   * Returns internal tools
   * Includes Bold, Italic, Link and Paragraph
   */
  get internalTools() {
    return {
      bold: {
        class: Xe,
        isInternal: true
      },
      italic: {
        class: Ve,
        isInternal: true
      },
      link: {
        class: qe,
        isInternal: true
      },
      paragraph: {
        class: hi,
        inlineToolbar: true,
        isInternal: true
      },
      stub: {
        class: Tt,
        isInternal: true
      },
      moveUp: {
        class: Lt,
        isInternal: true
      },
      delete: {
        class: Mt,
        isInternal: true
      },
      moveDown: {
        class: It,
        isInternal: true
      }
    };
  }
  /**
   * Tool prepare method success callback
   *
   * @param {object} data - append tool to available list
   */
  toolPrepareMethodSuccess(e2) {
    const t2 = this.factory.get(e2.toolName);
    if (t2.isInline()) {
      const i2 = ["render", "surround", "checkState"].filter((n2) => !t2.create()[n2]);
      if (i2.length) {
        L(
          `Incorrect Inline Tool: ${t2.name}. Some of required methods is not implemented %o`,
          "warn",
          i2
        ), this.toolsUnavailable.set(t2.name, t2);
        return;
      }
    }
    this.toolsAvailable.set(t2.name, t2);
  }
  /**
   * Tool prepare method fail callback
   *
   * @param {object} data - append tool to unavailable list
   */
  toolPrepareMethodFallback(e2) {
    this.toolsUnavailable.set(e2.toolName, this.factory.get(e2.toolName));
  }
  /**
   * Binds prepare function of plugins with user or default config
   *
   * @returns {Array} list of functions that needs to be fired sequentially
   * @param config - tools config
   */
  getListOfPrepareFunctions(e2) {
    const t2 = [];
    return Object.entries(e2).forEach(([o2, i2]) => {
      t2.push({
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        function: D(i2.class.prepare) ? i2.class.prepare : () => {
        },
        data: {
          toolName: o2,
          config: i2.config
        }
      });
    }), t2;
  }
  /**
   * Assign enabled Inline Tools and Block Tunes for Block Tool
   */
  prepareBlockTools() {
    Array.from(this.blockTools.values()).forEach((e2) => {
      this.assignInlineToolsToBlockTool(e2), this.assignBlockTunesToBlockTool(e2);
    });
  }
  /**
   * Assign enabled Inline Tools for Block Tool
   *
   * @param tool - Block Tool
   */
  assignInlineToolsToBlockTool(e2) {
    if (this.config.inlineToolbar !== false) {
      if (e2.enabledInlineTools === true) {
        e2.inlineTools = new U(
          Array.isArray(this.config.inlineToolbar) ? this.config.inlineToolbar.map((t2) => [t2, this.inlineTools.get(t2)]) : Array.from(this.inlineTools.entries())
        );
        return;
      }
      Array.isArray(e2.enabledInlineTools) && (e2.inlineTools = new U(
        e2.enabledInlineTools.map((t2) => [t2, this.inlineTools.get(t2)])
      ));
    }
  }
  /**
   * Assign enabled Block Tunes for Block Tool
   *
   * @param tool — Block Tool
   */
  assignBlockTunesToBlockTool(e2) {
    if (e2.enabledBlockTunes !== false) {
      if (Array.isArray(e2.enabledBlockTunes)) {
        const t2 = new U(
          e2.enabledBlockTunes.map((o2) => [o2, this.blockTunes.get(o2)])
        );
        e2.tunes = new U([...t2, ...this.blockTunes.internalTools]);
        return;
      }
      if (Array.isArray(this.config.tunes)) {
        const t2 = new U(
          this.config.tunes.map((o2) => [o2, this.blockTunes.get(o2)])
        );
        e2.tunes = new U([...t2, ...this.blockTunes.internalTools]);
        return;
      }
      e2.tunes = this.blockTunes.internalTools;
    }
  }
  /**
   * Validate Tools configuration objects and throw Error for user if it is invalid
   */
  validateTools() {
    for (const e2 in this.config.tools)
      if (Object.prototype.hasOwnProperty.call(this.config.tools, e2)) {
        if (e2 in this.internalTools)
          return;
        const t2 = this.config.tools[e2];
        if (!D(t2) && !D(t2.class))
          throw Error(
            `Tool «${e2}» must be a constructor function or an object with function in the «class» property`
          );
      }
  }
  /**
   * Unify tools config
   */
  prepareConfig() {
    const e2 = {};
    for (const t2 in this.config.tools)
      z(this.config.tools[t2]) ? e2[t2] = this.config.tools[t2] : e2[t2] = { class: this.config.tools[t2] };
    return e2;
  }
}
vi([
  ce
], Ot.prototype, "getAllInlineToolsSanitizeConfig", 1);
const xi = `:root{--selectionColor: #e1f2ff;--inlineSelectionColor: #d4ecff;--bg-light: #eff2f5;--grayText: #707684;--color-dark: #1D202B;--color-active-icon: #388AE5;--color-gray-border: rgba(201, 201, 204, .48);--content-width: 650px;--narrow-mode-right-padding: 50px;--toolbox-buttons-size: 26px;--toolbox-buttons-size--mobile: 36px;--icon-size: 20px;--icon-size--mobile: 28px;--block-padding-vertical: .4em;--color-line-gray: #EFF0F1 }.codex-editor{position:relative;-webkit-box-sizing:border-box;box-sizing:border-box;z-index:1}.codex-editor .hide{display:none}.codex-editor__redactor [contenteditable]:empty:after{content:"\\feff"}@media (min-width: 651px){.codex-editor--narrow .codex-editor__redactor{margin-right:50px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .codex-editor__redactor{margin-left:50px;margin-right:0}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__actions{right:-5px}}.codex-editor-copyable{position:absolute;height:1px;width:1px;top:-400%;opacity:.001}.codex-editor-overlay{position:fixed;top:0px;left:0px;right:0px;bottom:0px;z-index:999;pointer-events:none;overflow:hidden}.codex-editor-overlay__container{position:relative;pointer-events:auto;z-index:0}.codex-editor-overlay__rectangle{position:absolute;pointer-events:none;background-color:#2eaadc33;border:1px solid transparent}.codex-editor svg{max-height:100%}.codex-editor path{stroke:currentColor}.codex-editor ::-moz-selection{background-color:#d4ecff}.codex-editor ::selection{background-color:#d4ecff}.codex-editor--toolbox-opened [contentEditable=true][data-placeholder]:focus:before{opacity:0!important}.ce-scroll-locked{overflow:hidden}.ce-scroll-locked--hard{overflow:hidden;top:calc(-1 * var(--window-scroll-offset));position:fixed;width:100%}.ce-toolbar{position:absolute;left:0;right:0;top:0;-webkit-transition:opacity .1s ease;transition:opacity .1s ease;will-change:opacity,top;display:none}.ce-toolbar--opened{display:block}.ce-toolbar__content{max-width:650px;margin:0 auto;position:relative}.ce-toolbar__plus{color:#1d202b;cursor:pointer;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-flex-negative:0;flex-shrink:0}@media (max-width: 650px){.ce-toolbar__plus{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__plus:hover{background-color:#eff2f5}}.ce-toolbar__plus--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-toolbar__plus-shortcut{opacity:.6;word-spacing:-2px;margin-top:5px}@media (max-width: 650px){.ce-toolbar__plus{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__plus--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__plus--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__actions{position:absolute;right:100%;opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;padding-right:5px}.ce-toolbar__actions--opened{opacity:1}@media (max-width: 650px){.ce-toolbar__actions{right:auto}}.ce-toolbar__settings-btn{color:#1d202b;width:26px;height:26px;border-radius:7px;display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;margin-left:3px;cursor:pointer;user-select:none}@media (max-width: 650px){.ce-toolbar__settings-btn{width:36px;height:36px}}@media (hover: hover){.ce-toolbar__settings-btn:hover{background-color:#eff2f5}}.ce-toolbar__settings-btn--active{background-color:#eff2f5;-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}@media (min-width: 651px){.ce-toolbar__settings-btn{width:24px}}.ce-toolbar__settings-btn--hidden{display:none}@media (max-width: 650px){.ce-toolbar__settings-btn{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;position:static}.ce-toolbar__settings-btn--left-oriented:before{left:15px;margin-left:0}.ce-toolbar__settings-btn--right-oriented:before{left:auto;right:15px;margin-left:0}}.ce-toolbar__plus svg,.ce-toolbar__settings-btn svg{width:24px;height:24px}@media (min-width: 651px){.codex-editor--narrow .ce-toolbar__plus{left:5px}}@media (min-width: 651px){.codex-editor--narrow .ce-toolbox .ce-popover{right:0;left:auto;left:initial}}.ce-inline-toolbar{--y-offset: 8px;position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;-webkit-transform:translateX(-50%) translateY(8px) scale(.94);transform:translate(-50%) translateY(8px) scale(.94);opacity:0;visibility:hidden;-webkit-transition:opacity .25s ease,-webkit-transform .15s ease;transition:opacity .25s ease,-webkit-transform .15s ease;transition:transform .15s ease,opacity .25s ease;transition:transform .15s ease,opacity .25s ease,-webkit-transform .15s ease;will-change:transform,opacity;top:0;left:0;z-index:3}.ce-inline-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-inline-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-inline-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:translateX(-50%);transform:translate(-50%)}.ce-inline-toolbar--left-oriented{-webkit-transform:translateX(-23px) translateY(8px) scale(.94);transform:translate(-23px) translateY(8px) scale(.94)}.ce-inline-toolbar--left-oriented.ce-inline-toolbar--showed{-webkit-transform:translateX(-23px);transform:translate(-23px)}.ce-inline-toolbar--right-oriented{-webkit-transform:translateX(-100%) translateY(8px) scale(.94);transform:translate(-100%) translateY(8px) scale(.94);margin-left:23px}.ce-inline-toolbar--right-oriented.ce-inline-toolbar--showed{-webkit-transform:translateX(-100%);transform:translate(-100%)}.ce-inline-toolbar [hidden]{display:none!important}.ce-inline-toolbar__toggler-and-button-wrapper{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;padding:0 6px}.ce-inline-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown{display:-webkit-box;display:-ms-flexbox;display:flex;padding:6px;margin:0 6px 0 -6px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-right:1px solid rgba(201,201,204,.48);-webkit-box-sizing:border-box;box-sizing:border-box}@media (hover: hover){.ce-inline-toolbar__dropdown:hover{background:#eff2f5}}.ce-inline-toolbar__dropdown--hidden{display:none}.ce-inline-toolbar__dropdown-content,.ce-inline-toolbar__dropdown-arrow{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-inline-toolbar__dropdown-content svg,.ce-inline-toolbar__dropdown-arrow svg{width:20px;height:20px}.ce-inline-toolbar__shortcut{opacity:.6;word-spacing:-3px;margin-top:3px}.ce-inline-tool{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;border-radius:0;line-height:normal}.ce-inline-tool svg{width:20px;height:20px}@media (max-width: 650px){.ce-inline-tool svg{width:28px;height:28px}}@media (hover: hover){.ce-inline-tool:hover{background-color:#eff2f5}}.ce-inline-tool--active{color:#388ae5}.ce-inline-tool--focused{background:rgba(34,186,255,.08)!important}.ce-inline-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-inline-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-inline-tool--link .icon--unlink,.ce-inline-tool--unlink .icon--link{display:none}.ce-inline-tool--unlink .icon--unlink{display:inline-block;margin-bottom:-1px}.ce-inline-tool-input{outline:none;border:0;border-radius:0 0 4px 4px;margin:0;font-size:13px;padding:10px;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box;display:none;font-weight:500;border-top:1px solid rgba(201,201,204,.48);-webkit-appearance:none;font-family:inherit}@media (max-width: 650px){.ce-inline-tool-input{font-size:15px;font-weight:500}}.ce-inline-tool-input::-webkit-input-placeholder{color:#707684}.ce-inline-tool-input::-moz-placeholder{color:#707684}.ce-inline-tool-input:-ms-input-placeholder{color:#707684}.ce-inline-tool-input::-ms-input-placeholder{color:#707684}.ce-inline-tool-input::placeholder{color:#707684}.ce-inline-tool-input--showed{display:block}.ce-conversion-toolbar{position:absolute;background-color:#fff;border:1px solid #E8E8EB;-webkit-box-shadow:0 3px 15px -3px rgba(13,20,33,.13);box-shadow:0 3px 15px -3px #0d142121;border-radius:6px;z-index:2;opacity:0;visibility:hidden;will-change:transform,opacity;-webkit-transition:opacity .1s ease,-webkit-transform .1s ease;transition:opacity .1s ease,-webkit-transform .1s ease;transition:transform .1s ease,opacity .1s ease;transition:transform .1s ease,opacity .1s ease,-webkit-transform .1s ease;-webkit-transform:translateY(-8px);transform:translateY(-8px);left:-1px;width:190px;margin-top:5px;-webkit-box-sizing:content-box;box-sizing:content-box}.ce-conversion-toolbar--left-oriented:before{left:15px;margin-left:0}.ce-conversion-toolbar--right-oriented:before{left:auto;right:15px;margin-left:0}.ce-conversion-toolbar--showed{opacity:1;visibility:visible;-webkit-transform:none;transform:none}.ce-conversion-toolbar [hidden]{display:none!important}.ce-conversion-toolbar__buttons{display:-webkit-box;display:-ms-flexbox;display:flex}.ce-conversion-toolbar__label{color:#707684;font-size:11px;font-weight:500;letter-spacing:.33px;padding:10px 10px 5px;text-transform:uppercase}.ce-conversion-tool{display:-webkit-box;display:-ms-flexbox;display:flex;padding:5px 10px;font-size:14px;line-height:20px;font-weight:500;cursor:pointer;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.ce-conversion-tool--hidden{display:none}.ce-conversion-tool--focused{background:rgba(34,186,255,.08)!important}.ce-conversion-tool--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-conversion-tool--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-conversion-tool:hover{background:#eff2f5}.ce-conversion-tool__icon{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px rgba(201,201,204,.48);box-shadow:0 0 0 1px #c9c9cc7a;border-radius:5px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;background:#fff;-webkit-box-sizing:content-box;box-sizing:content-box;-ms-flex-negative:0;flex-shrink:0;margin-right:10px}.ce-conversion-tool__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-conversion-tool__icon{width:36px;height:36px;border-radius:8px}.ce-conversion-tool__icon svg{width:28px;height:28px}}.ce-conversion-tool--last{margin-right:0!important}.ce-conversion-tool--active{color:#388ae5!important}.ce-conversion-tool--active{-webkit-animation:bounceIn .75s 1;animation:bounceIn .75s 1;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards}.ce-conversion-tool__secondary-label{color:#707684;font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-conversion-tool__secondary-label{display:none}}.ce-settings__button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;line-height:32px}.ce-settings__button svg{width:20px;height:20px}@media (max-width: 650px){.ce-settings__button svg{width:28px;height:28px}}@media (hover: hover){.ce-settings__button:hover{background-color:#eff2f5}}.ce-settings__button--active{color:#388ae5}.ce-settings__button--focused{background:rgba(34,186,255,.08)!important}.ce-settings__button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.ce-settings__button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.ce-settings__button:not(:nth-child(3n+3)){margin-right:3px}.ce-settings__button:nth-child(n+4){margin-top:3px}.ce-settings__button--disabled{cursor:not-allowed!important}.ce-settings__button--disabled{opacity:.3}.ce-settings__button--selected{color:#388ae5}@media (min-width: 651px){.codex-editor--narrow .ce-settings .ce-popover{right:0;left:auto;left:initial}}@-webkit-keyframes fade-in{0%{opacity:0}to{opacity:1}}@keyframes fade-in{0%{opacity:0}to{opacity:1}}.ce-block{-webkit-animation:fade-in .3s ease;animation:fade-in .3s ease;-webkit-animation-fill-mode:none;animation-fill-mode:none;-webkit-animation-fill-mode:initial;animation-fill-mode:initial}.ce-block:first-of-type{margin-top:0}.ce-block--selected .ce-block__content{background:#e1f2ff}.ce-block--selected .ce-block__content [contenteditable]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.ce-block--selected .ce-block__content img,.ce-block--selected .ce-block__content .ce-stub{opacity:.55}.ce-block--stretched .ce-block__content{max-width:none}.ce-block__content{position:relative;max-width:650px;margin:0 auto;-webkit-transition:background-color .15s ease;transition:background-color .15s ease}.ce-block--drop-target .ce-block__content:before{content:"";position:absolute;top:100%;left:-20px;margin-top:-1px;height:8px;width:8px;border:solid #388AE5;border-width:1px 1px 0 0;-webkit-transform-origin:right;transform-origin:right;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.ce-block--drop-target .ce-block__content:after{content:"";position:absolute;top:100%;height:1px;width:100%;color:#388ae5;background:repeating-linear-gradient(90deg,#388AE5,#388AE5 1px,#fff 1px,#fff 6px)}.ce-block a{cursor:pointer;-webkit-text-decoration:underline;text-decoration:underline}.ce-block b{font-weight:700}.ce-block i{font-style:italic}@media (min-width: 651px){.codex-editor--narrow .ce-block--focused{margin-right:-50px;padding-right:50px}}@-webkit-keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes bounceIn{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.9,.9,.9);transform:scale3d(.9,.9,.9)}20%{-webkit-transform:scale3d(1.03,1.03,1.03);transform:scale3d(1.03,1.03,1.03)}60%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes selectionBounce{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}50%{-webkit-transform:scale3d(1.01,1.01,1.01);transform:scale3d(1.01,1.01,1.01)}70%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@-webkit-keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}@keyframes buttonClicked{0%,20%,40%,60%,80%,to{-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}0%{-webkit-transform:scale3d(.95,.95,.95);transform:scale3d(.95,.95,.95)}60%{-webkit-transform:scale3d(1.02,1.02,1.02);transform:scale3d(1.02,1.02,1.02)}80%{-webkit-transform:scale3d(1,1,1);transform:scaleZ(1)}}.cdx-block{padding:.4em 0}.cdx-block::-webkit-input-placeholder{line-height:normal!important}.cdx-input{border:1px solid rgba(201,201,204,.48);-webkit-box-shadow:inset 0 1px 2px 0 rgba(35,44,72,.06);box-shadow:inset 0 1px 2px #232c480f;border-radius:3px;padding:10px 12px;outline:none;width:100%;-webkit-box-sizing:border-box;box-sizing:border-box}.cdx-input[data-placeholder]:before{position:static!important}.cdx-input[data-placeholder]:before{display:inline-block;width:0;white-space:nowrap;pointer-events:none}.cdx-settings-button{display:-webkit-inline-box;display:-ms-inline-flexbox;display:inline-flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;padding:6px 1px;border-radius:3px;cursor:pointer;border:0;outline:none;background-color:transparent;vertical-align:bottom;color:inherit;margin:0;min-width:26px;min-height:26px}.cdx-settings-button svg{width:20px;height:20px}@media (max-width: 650px){.cdx-settings-button svg{width:28px;height:28px}}@media (hover: hover){.cdx-settings-button:hover{background-color:#eff2f5}}.cdx-settings-button--focused{background:rgba(34,186,255,.08)!important}.cdx-settings-button--focused{-webkit-box-shadow:inset 0 0 0px 1px rgba(7,161,227,.08);box-shadow:inset 0 0 0 1px #07a1e314}.cdx-settings-button--focused-animated{-webkit-animation-name:buttonClicked;animation-name:buttonClicked;-webkit-animation-duration:.25s;animation-duration:.25s}.cdx-settings-button--active{color:#388ae5}.cdx-settings-button svg{width:auto;height:auto}@media (max-width: 650px){.cdx-settings-button{width:36px;height:36px;border-radius:8px}}.cdx-loader{position:relative;border:1px solid rgba(201,201,204,.48)}.cdx-loader:before{content:"";position:absolute;left:50%;top:50%;width:18px;height:18px;margin:-11px 0 0 -11px;border:2px solid rgba(201,201,204,.48);border-left-color:#388ae5;border-radius:50%;-webkit-animation:cdxRotation 1.2s infinite linear;animation:cdxRotation 1.2s infinite linear}@-webkit-keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes cdxRotation{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}.cdx-button{padding:13px;border-radius:3px;border:1px solid rgba(201,201,204,.48);font-size:14.9px;background:#fff;-webkit-box-shadow:0 2px 2px 0 rgba(18,30,57,.04);box-shadow:0 2px 2px #121e390a;color:#707684;text-align:center;cursor:pointer}@media (hover: hover){.cdx-button:hover{background:#FBFCFE;-webkit-box-shadow:0 1px 3px 0 rgba(18,30,57,.08);box-shadow:0 1px 3px #121e3914}}.cdx-button svg{height:20px;margin-right:.2em;margin-top:-2px}.ce-stub{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:12px 18px;margin:10px 0;border-radius:10px;background:#eff2f5;border:1px solid #EFF0F1;color:#707684;font-size:14px}.ce-stub svg{width:20px;height:20px}.ce-stub__info{margin-left:14px}.ce-stub__title{font-weight:500;text-transform:capitalize}.codex-editor.codex-editor--rtl{direction:rtl}.codex-editor.codex-editor--rtl .cdx-list{padding-left:0;padding-right:40px}.codex-editor.codex-editor--rtl .ce-toolbar__plus{right:-26px;left:auto}.codex-editor.codex-editor--rtl .ce-toolbar__actions{right:auto;left:-26px}@media (max-width: 650px){.codex-editor.codex-editor--rtl .ce-toolbar__actions{margin-left:0;margin-right:auto;padding-right:0;padding-left:10px}}.codex-editor.codex-editor--rtl .ce-settings{left:5px;right:auto}.codex-editor.codex-editor--rtl .ce-settings:before{right:auto;left:25px}.codex-editor.codex-editor--rtl .ce-settings__button:not(:nth-child(3n+3)){margin-left:3px;margin-right:0}.codex-editor.codex-editor--rtl .ce-conversion-tool__icon{margin-right:0;margin-left:10px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown{border-right:0px solid transparent;border-left:1px solid rgba(201,201,204,.48);margin:0 -6px 0 6px}.codex-editor.codex-editor--rtl .ce-inline-toolbar__dropdown .icon--toggler-down{margin-left:0;margin-right:4px}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__plus{left:0px;right:5px}}@media (min-width: 651px){.codex-editor--narrow.codex-editor--rtl .ce-toolbar__actions{left:-5px}}.cdx-search-field{--icon-margin-right: 10px;background:rgba(232,232,235,.49);border:1px solid rgba(226,226,229,.2);border-radius:6px;padding:2px;display:grid;grid-template-columns:auto auto 1fr;grid-template-rows:auto}.cdx-search-field__icon{width:26px;height:26px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:var(--icon-margin-right)}.cdx-search-field__icon svg{width:20px;height:20px;color:#707684}.cdx-search-field__input{font-size:14px;outline:none;font-weight:500;font-family:inherit;border:0;background:transparent;margin:0;padding:0;line-height:22px;min-width:calc(100% - 26px - var(--icon-margin-right))}.cdx-search-field__input::-webkit-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-moz-placeholder{color:#707684;font-weight:500}.cdx-search-field__input:-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::-ms-input-placeholder{color:#707684;font-weight:500}.cdx-search-field__input::placeholder{color:#707684;font-weight:500}.ce-popover{--border-radius: 6px;--width: 200px;--max-height: 270px;--padding: 6px;--offset-from-target: 8px;--color-border: #e8e8eb;--color-shadow: rgba(13,20,33,.13);--color-background: white;--color-text-primary: black;--color-text-secondary: #707684;--color-border-icon: rgba(201, 201, 204, .48);--color-border-icon-disabled: #EFF0F1;--color-text-icon-active: #388AE5;--color-background-icon-active: rgba(56, 138, 229, .1);--color-background-item-focus: rgba(34, 186, 255, .08);--color-shadow-item-focus: rgba(7, 161, 227, .08);--color-background-item-hover: #eff2f5;--color-background-item-confirm: #E24A4A;--color-background-item-confirm-hover: #CE4343;min-width:var(--width);width:var(--width);max-height:var(--max-height);border-radius:var(--border-radius);overflow:hidden;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-box-shadow:0 3px 15px -3px var(--color-shadow);box-shadow:0 3px 15px -3px var(--color-shadow);position:absolute;left:0;top:calc(100% + var(--offset-from-target));background:var(--color-background);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;z-index:4;opacity:0;max-height:0;pointer-events:none;padding:0;border:none}.ce-popover--opened{opacity:1;padding:var(--padding);max-height:var(--max-height);pointer-events:auto;-webkit-animation:panelShowing .1s ease;animation:panelShowing .1s ease;border:1px solid var(--color-border)}@media (max-width: 650px){.ce-popover--opened{-webkit-animation:panelShowingMobile .25s ease;animation:panelShowingMobile .25s ease}}.ce-popover__items{overflow-y:auto;-ms-scroll-chaining:none;overscroll-behavior:contain}@media (max-width: 650px){.ce-popover__overlay{position:fixed;top:0;bottom:0;left:0;right:0;background:#1D202B;z-index:3;opacity:.5;-webkit-transition:opacity .12s ease-in;transition:opacity .12s ease-in;will-change:opacity;visibility:visible}}.ce-popover__overlay--hidden{display:none}.ce-popover--open-top{top:calc(-1 * (var(--offset-from-target) + var(--popover-height)))}@media (max-width: 650px){.ce-popover{--offset: 5px;position:fixed;max-width:none;min-width:calc(100% - var(--offset) * 2);left:var(--offset);right:var(--offset);bottom:calc(var(--offset) + env(safe-area-inset-bottom));top:auto;border-radius:10px}.ce-popover .ce-popover__search{display:none}}.ce-popover__search,.ce-popover__custom-content:not(:empty){margin-bottom:5px}.ce-popover__nothing-found-message{color:#707684;display:none;cursor:default;padding:3px;font-size:14px;line-height:20px;font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.ce-popover__nothing-found-message--displayed{display:block}.ce-popover__custom-content:not(:empty){padding:4px}@media (min-width: 651px){.ce-popover__custom-content:not(:empty){padding:0}}.ce-popover__custom-content--hidden{display:none}.ce-popover-item{--border-radius: 6px;--icon-size: 20px;--icon-size-mobile: 28px;border-radius:var(--border-radius);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:3px;color:var(--color-text-primary);-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}@media (max-width: 650px){.ce-popover-item{padding:4px}}.ce-popover-item:not(:last-of-type){margin-bottom:1px}.ce-popover-item__icon{border-radius:5px;width:26px;height:26px;-webkit-box-shadow:0 0 0 1px var(--color-border-icon);box-shadow:0 0 0 1px var(--color-border-icon);background:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;margin-right:10px}.ce-popover-item__icon svg{width:20px;height:20px}@media (max-width: 650px){.ce-popover-item__icon{width:36px;height:36px;border-radius:8px}.ce-popover-item__icon svg{width:var(--icon-size-mobile);height:var(--icon-size-mobile)}}.ce-popover-item__title{font-size:14px;line-height:20px;font-weight:500;overflow:hidden;white-space:nowrap;text-overflow:ellipsis}@media (max-width: 650px){.ce-popover-item__title{font-size:16px}}.ce-popover-item__secondary-title{color:var(--color-text-secondary);font-size:12px;margin-left:auto;white-space:nowrap;letter-spacing:-.1em;padding-right:5px;margin-bottom:-2px;opacity:.6}@media (max-width: 650px){.ce-popover-item__secondary-title{display:none}}.ce-popover-item--active{background:var(--color-background-icon-active);color:var(--color-text-icon-active)}.ce-popover-item--active .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}.ce-popover-item--disabled{color:var(--color-text-secondary);cursor:default;pointer-events:none}.ce-popover-item--disabled .ce-popover-item__icon{-webkit-box-shadow:0 0 0 1px var(--color-border-icon-disabled);box-shadow:0 0 0 1px var(--color-border-icon-disabled)}.ce-popover-item--focused:not(.ce-popover-item--no-focus){background:var(--color-background-item-focus)!important}.ce-popover-item--focused:not(.ce-popover-item--no-focus){-webkit-box-shadow:inset 0 0 0px 1px var(--color-shadow-item-focus);box-shadow:inset 0 0 0 1px var(--color-shadow-item-focus)}.ce-popover-item--hidden{display:none}@media (hover: hover){.ce-popover-item:hover{cursor:pointer}.ce-popover-item:hover:not(.ce-popover-item--no-hover){background-color:var(--color-background-item-hover)}.ce-popover-item:hover .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}}.ce-popover-item--confirmation{background:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__icon{color:var(--color-background-item-confirm)}.ce-popover-item--confirmation .ce-popover-item__title{color:#fff}@media (hover: hover){.ce-popover-item--confirmation:not(.ce-popover-item--no-hover):hover{background:var(--color-background-item-confirm-hover)}}.ce-popover-item--confirmation:not(.ce-popover-item--no-focus).ce-popover-item--focused{background:var(--color-background-item-confirm-hover)!important}.ce-popover-item--confirmation .ce-popover-item__icon,.ce-popover-item--active .ce-popover-item__icon,.ce-popover-item--focused .ce-popover-item__icon{-webkit-box-shadow:none;box-shadow:none}@-webkit-keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowing{0%{opacity:0;-webkit-transform:translateY(-8px) scale(.9);transform:translateY(-8px) scale(.9)}70%{opacity:1;-webkit-transform:translateY(2px);transform:translateY(2px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes panelShowingMobile{0%{opacity:0;-webkit-transform:translateY(14px) scale(.98);transform:translateY(14px) scale(.98)}70%{opacity:1;-webkit-transform:translateY(-4px);transform:translateY(-4px)}to{-webkit-transform:translateY(0);transform:translateY(0)}}.wobble{-webkit-animation-name:wobble;animation-name:wobble;-webkit-animation-duration:.4s;animation-duration:.4s}@-webkit-keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}@keyframes wobble{0%{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}15%{-webkit-transform:translate3d(-9%,0,0);transform:translate3d(-9%,0,0)}30%{-webkit-transform:translate3d(9%,0,0);transform:translate3d(9%,0,0)}45%{-webkit-transform:translate3d(-4%,0,0);transform:translate3d(-4%,0,0)}60%{-webkit-transform:translate3d(4%,0,0);transform:translate3d(4%,0,0)}75%{-webkit-transform:translate3d(-1%,0,0);transform:translate3d(-1%,0,0)}to{-webkit-transform:translate3d(0,0,0);transform:translateZ(0)}}
`;
class wi extends T {
  constructor() {
    super(...arguments), this.isMobile = false, this.contentRectCache = void 0, this.resizeDebouncer = Ut(() => {
      this.windowResize();
    }, 200);
  }
  /**
   * Editor.js UI CSS class names
   *
   * @returns {{editorWrapper: string, editorZone: string}}
   */
  get CSS() {
    return {
      editorWrapper: "codex-editor",
      editorWrapperNarrow: "codex-editor--narrow",
      editorZone: "codex-editor__redactor",
      editorZoneHidden: "codex-editor__redactor--hidden",
      editorEmpty: "codex-editor--empty",
      editorRtlFix: "codex-editor--rtl"
    };
  }
  /**
   * Return Width of center column of Editor
   *
   * @returns {DOMRect}
   */
  get contentRect() {
    if (this.contentRectCache)
      return this.contentRectCache;
    const e2 = this.nodes.wrapper.querySelector(`.${F.CSS.content}`);
    return e2 ? (this.contentRectCache = e2.getBoundingClientRect(), this.contentRectCache) : {
      width: 650,
      left: 0,
      right: 0
    };
  }
  /**
   * Making main interface
   */
  async prepare() {
    this.checkIsMobile(), this.make(), this.loadStyles();
  }
  /**
   * Toggle read-only state
   *
   * If readOnly is true:
   *  - removes all listeners from main UI module elements
   *
   * if readOnly is false:
   *  - enables all listeners to UI module elements
   *
   * @param {boolean} readOnlyEnabled - "read only" state
   */
  toggleReadOnly(e2) {
    e2 ? this.disableModuleBindings() : this.enableModuleBindings();
  }
  /**
   * Check if Editor is empty and set CSS class to wrapper
   */
  checkEmptiness() {
    const { BlockManager: e2 } = this.Editor;
    this.nodes.wrapper.classList.toggle(this.CSS.editorEmpty, e2.isEditorEmpty);
  }
  /**
   * Check if one of Toolbar is opened
   * Used to prevent global keydowns (for example, Enter) conflicts with Enter-on-toolbar
   *
   * @returns {boolean}
   */
  get someToolbarOpened() {
    const { Toolbar: e2, BlockSettings: t2, InlineToolbar: o2, ConversionToolbar: i2 } = this.Editor;
    return t2.opened || o2.opened || i2.opened || e2.toolbox.opened;
  }
  /**
   * Check for some Flipper-buttons is under focus
   */
  get someFlipperButtonFocused() {
    return this.Editor.Toolbar.toolbox.hasFocus() ? true : Object.entries(this.Editor).filter(([e2, t2]) => t2.flipper instanceof J).some(([e2, t2]) => t2.flipper.hasFocus());
  }
  /**
   * Clean editor`s UI
   */
  destroy() {
    this.nodes.holder.innerHTML = "";
  }
  /**
   * Close all Editor's toolbars
   */
  closeAllToolbars() {
    const { Toolbar: e2, BlockSettings: t2, InlineToolbar: o2, ConversionToolbar: i2 } = this.Editor;
    t2.close(), o2.close(), i2.close(), e2.toolbox.close();
  }
  /**
   * Check for mobile mode and cache a result
   */
  checkIsMobile() {
    this.isMobile = window.innerWidth < ct;
  }
  /**
   * Makes Editor.js interface
   */
  make() {
    this.nodes.holder = d.getHolder(this.config.holder), this.nodes.wrapper = d.make("div", [
      this.CSS.editorWrapper,
      ...this.isRtl ? [this.CSS.editorRtlFix] : []
    ]), this.nodes.redactor = d.make("div", this.CSS.editorZone), this.nodes.holder.offsetWidth < this.contentRect.width && this.nodes.wrapper.classList.add(this.CSS.editorWrapperNarrow), this.nodes.redactor.style.paddingBottom = this.config.minHeight + "px", this.nodes.wrapper.appendChild(this.nodes.redactor), this.nodes.holder.appendChild(this.nodes.wrapper);
  }
  /**
   * Appends CSS
   */
  loadStyles() {
    const e2 = "editor-js-styles";
    if (d.get(e2))
      return;
    const t2 = d.make("style", null, {
      id: e2,
      textContent: xi.toString()
    });
    d.prepend(document.head, t2);
  }
  /**
   * Bind events on the Editor.js interface
   */
  enableModuleBindings() {
    this.readOnlyMutableListeners.on(this.nodes.redactor, "click", (e2) => {
      this.redactorClicked(e2);
    }, false), this.readOnlyMutableListeners.on(this.nodes.redactor, "mousedown", (e2) => {
      this.documentTouched(e2);
    }, {
      capture: true,
      passive: true
    }), this.readOnlyMutableListeners.on(this.nodes.redactor, "touchstart", (e2) => {
      this.documentTouched(e2);
    }, {
      capture: true,
      passive: true
    }), this.readOnlyMutableListeners.on(document, "keydown", (e2) => {
      this.documentKeydown(e2);
    }, true), this.readOnlyMutableListeners.on(document, "mousedown", (e2) => {
      this.documentClicked(e2);
    }, true), this.readOnlyMutableListeners.on(document, "selectionchange", () => {
      this.selectionChanged();
    }, true), this.readOnlyMutableListeners.on(window, "resize", () => {
      this.resizeDebouncer();
    }, {
      passive: true
    }), this.watchBlockHoveredEvents();
  }
  /**
   * Listen redactor mousemove to emit 'block-hovered' event
   */
  watchBlockHoveredEvents() {
    let e2;
    this.readOnlyMutableListeners.on(this.nodes.redactor, "mousemove", Ie((t2) => {
      const o2 = t2.target.closest(".ce-block");
      this.Editor.BlockSelection.anyBlockSelected || o2 && e2 !== o2 && (e2 = o2, this.eventsDispatcher.emit(wt, {
        block: this.Editor.BlockManager.getBlockByChildNode(o2)
      }));
    }, 20), {
      passive: true
    });
  }
  /**
   * Unbind events on the Editor.js interface
   */
  disableModuleBindings() {
    this.readOnlyMutableListeners.clearAll();
  }
  /**
   * Resize window handler
   */
  windowResize() {
    this.contentRectCache = null, this.checkIsMobile();
  }
  /**
   * All keydowns on document
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  documentKeydown(e2) {
    switch (e2.keyCode) {
      case B.ENTER:
        this.enterPressed(e2);
        break;
      case B.BACKSPACE:
      case B.DELETE:
        this.backspacePressed(e2);
        break;
      case B.ESC:
        this.escapePressed(e2);
        break;
      default:
        this.defaultBehaviour(e2);
        break;
    }
  }
  /**
   * Ignore all other document's keydown events
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  defaultBehaviour(e2) {
    const { currentBlock: t2 } = this.Editor.BlockManager, o2 = e2.target.closest(`.${this.CSS.editorWrapper}`), i2 = e2.altKey || e2.ctrlKey || e2.metaKey || e2.shiftKey;
    if (t2 !== void 0 && o2 === null) {
      this.Editor.BlockEvents.keydown(e2);
      return;
    }
    o2 || t2 && i2 || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());
  }
  /**
   * @param {KeyboardEvent} event - keyboard event
   */
  backspacePressed(e2) {
    const { BlockManager: t2, BlockSelection: o2, Caret: i2 } = this.Editor;
    if (o2.anyBlockSelected && !m.isSelectionExists) {
      const n2 = t2.removeSelectedBlocks(), r2 = t2.insertDefaultBlockAtIndex(n2, true);
      i2.setToBlock(r2, i2.positions.START), o2.clearSelection(e2), e2.preventDefault(), e2.stopPropagation(), e2.stopImmediatePropagation();
    }
  }
  /**
   * Escape pressed
   * If some of Toolbar components are opened, then close it otherwise close Toolbar
   *
   * @param {Event} event - escape keydown event
   */
  escapePressed(e2) {
    this.Editor.BlockSelection.clearSelection(e2), this.Editor.Toolbar.toolbox.opened ? (this.Editor.Toolbar.toolbox.close(), this.Editor.Caret.setToBlock(this.Editor.BlockManager.currentBlock)) : this.Editor.BlockSettings.opened ? this.Editor.BlockSettings.close() : this.Editor.ConversionToolbar.opened ? this.Editor.ConversionToolbar.close() : this.Editor.InlineToolbar.opened ? this.Editor.InlineToolbar.close() : this.Editor.Toolbar.close();
  }
  /**
   * Enter pressed on document
   *
   * @param {KeyboardEvent} event - keyboard event
   */
  enterPressed(e2) {
    const { BlockManager: t2, BlockSelection: o2 } = this.Editor, i2 = t2.currentBlockIndex >= 0;
    if (o2.anyBlockSelected && !m.isSelectionExists) {
      o2.clearSelection(e2), e2.preventDefault(), e2.stopImmediatePropagation(), e2.stopPropagation();
      return;
    }
    if (!this.someToolbarOpened && i2 && e2.target.tagName === "BODY") {
      const n2 = this.Editor.BlockManager.insert();
      this.Editor.Caret.setToBlock(n2), this.Editor.BlockManager.highlightCurrentNode(), this.Editor.Toolbar.moveAndOpen(n2);
    }
    this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * All clicks on document
   *
   * @param {MouseEvent} event - Click event
   */
  documentClicked(e2) {
    if (!e2.isTrusted)
      return;
    const t2 = e2.target;
    this.nodes.holder.contains(t2) || m.isAtEditor || (this.Editor.BlockManager.dropPointer(), this.Editor.Toolbar.close());
    const i2 = this.Editor.BlockSettings.nodes.wrapper.contains(t2), n2 = this.Editor.Toolbar.nodes.settingsToggler.contains(t2), r2 = i2 || n2;
    if (this.Editor.BlockSettings.opened && !r2) {
      this.Editor.BlockSettings.close();
      const a2 = this.Editor.BlockManager.getBlockByChildNode(t2);
      this.Editor.Toolbar.moveAndOpen(a2);
    }
    this.Editor.BlockSelection.clearSelection(e2);
  }
  /**
   * First touch on editor
   * Fired before click
   *
   * Used to change current block — we need to do it before 'selectionChange' event.
   * Also:
   * - Move and show the Toolbar
   * - Set a Caret
   *
   * @param {MouseEvent | TouchEvent} event - touch or mouse event
   */
  documentTouched(e2) {
    let t2 = e2.target;
    if (t2 === this.nodes.redactor) {
      const o2 = e2 instanceof MouseEvent ? e2.clientX : e2.touches[0].clientX, i2 = e2 instanceof MouseEvent ? e2.clientY : e2.touches[0].clientY;
      t2 = document.elementFromPoint(o2, i2);
    }
    try {
      this.Editor.BlockManager.setCurrentBlockByChildNode(t2), this.Editor.BlockManager.highlightCurrentNode();
    } catch {
      this.Editor.RectangleSelection.isRectActivated() || this.Editor.Caret.setToTheLastBlock();
    }
    this.Editor.Toolbar.moveAndOpen();
  }
  /**
   * All clicks on the redactor zone
   *
   * @param {MouseEvent} event - click event
   * @description
   * - By clicks on the Editor's bottom zone:
   *      - if last Block is empty, set a Caret to this
   *      - otherwise, add a new empty Block and set a Caret to that
   */
  redactorClicked(e2) {
    if (!m.isCollapsed)
      return;
    const t2 = e2.target, o2 = e2.metaKey || e2.ctrlKey;
    if (d.isAnchor(t2) && o2) {
      e2.stopImmediatePropagation(), e2.stopPropagation();
      const i2 = t2.getAttribute("href"), n2 = Wt(i2);
      Kt(n2);
      return;
    }
    this.processBottomZoneClick(e2);
  }
  /**
   * Check if user clicks on the Editor's bottom zone:
   *  - set caret to the last block
   *  - or add new empty block
   *
   * @param event - click event
   */
  processBottomZoneClick(e2) {
    const t2 = this.Editor.BlockManager.getBlockByIndex(-1), o2 = d.offset(t2.holder).bottom, i2 = e2.pageY, { BlockSelection: n2 } = this.Editor;
    if (e2.target instanceof Element && e2.target.isEqualNode(this.nodes.redactor) && /**
    * If there is cross block selection started, target will be equal to redactor so we need additional check
    */
    !n2.anyBlockSelected && /**
    * Prevent caret jumping (to last block) when clicking between blocks
    */
    o2 < i2) {
      e2.stopImmediatePropagation(), e2.stopPropagation();
      const { BlockManager: a2, Caret: l2, Toolbar: c2 } = this.Editor;
      (!a2.lastBlock.tool.isDefault || !a2.lastBlock.isEmpty) && a2.insertAtEnd(), l2.setToTheLastBlock(), c2.moveAndOpen(a2.lastBlock);
    }
  }
  /**
   * Handle selection changes on mobile devices
   * Uses for showing the Inline Toolbar
   */
  selectionChanged() {
    const { CrossBlockSelection: e2, BlockSelection: t2 } = this.Editor, o2 = m.anchorElement;
    if (e2.isCrossBlockSelectionStarted && t2.anyBlockSelected && m.get().removeAllRanges(), !o2) {
      m.range || this.Editor.InlineToolbar.close();
      return;
    }
    const i2 = o2.closest(`.${F.CSS.content}`) === null;
    if (i2 && (this.Editor.InlineToolbar.containsNode(o2) || this.Editor.InlineToolbar.close(), !(o2.dataset.inlineToolbar === "true")))
      return;
    this.Editor.BlockManager.currentBlock || this.Editor.BlockManager.setCurrentBlockByChildNode(o2);
    const n2 = i2 !== true;
    this.Editor.InlineToolbar.tryToShow(true, n2);
  }
}
const yi = {
  // API Modules
  BlocksAPI: oo,
  CaretAPI: io,
  EventsAPI: no,
  I18nAPI: je,
  API: so,
  InlineToolbarAPI: ro,
  ListenersAPI: ao,
  NotifierAPI: uo,
  ReadOnlyAPI: po,
  SanitizerAPI: xo,
  SaverAPI: wo,
  SelectionAPI: yo,
  StylesAPI: Eo,
  ToolbarAPI: Bo,
  TooltipAPI: Mo,
  UiAPI: Lo,
  // Toolbar Modules
  BlockSettings: Yo,
  ConversionToolbar: K,
  Toolbar: Go,
  InlineToolbar: Jo,
  // Modules
  BlockEvents: Qo,
  BlockManager: oi,
  BlockSelection: ii,
  Caret: we,
  CrossBlockSelection: ni,
  DragNDrop: si,
  ModificationsObserver: ri,
  Paste: Ct,
  ReadOnly: ai,
  RectangleSelection: fe,
  Renderer: li,
  Saver: ci,
  Tools: Ot,
  UI: wi
};
class Ei {
  /**
   * @param {EditorConfig} config - user configuration
   */
  constructor(e2) {
    this.moduleInstances = {}, this.eventsDispatcher = new Ee();
    let t2, o2;
    this.isReady = new Promise((i2, n2) => {
      t2 = i2, o2 = n2;
    }), Promise.resolve().then(async () => {
      this.configuration = e2, this.validate(), this.init(), await this.start(), await this.render();
      const { BlockManager: i2, Caret: n2, UI: r2, ModificationsObserver: a2 } = this.moduleInstances;
      r2.checkEmptiness(), a2.enable(), this.configuration.autofocus && (n2.setToBlock(i2.blocks[0], n2.positions.START), i2.highlightCurrentNode()), t2();
    }).catch((i2) => {
      L(`Editor.js is not ready because of ${i2}`, "error"), o2(i2);
    });
  }
  /**
   * Setting for configuration
   *
   * @param {EditorConfig|string} config - Editor's config to set
   */
  set configuration(e2) {
    var o2, i2;
    z(e2) ? this.config = {
      ...e2
    } : this.config = {
      holder: e2
    }, Le(!!this.config.holderId, "config.holderId", "config.holder"), this.config.holderId && !this.config.holder && (this.config.holder = this.config.holderId, this.config.holderId = null), this.config.holder == null && (this.config.holder = "editorjs"), this.config.logLevel || (this.config.logLevel = rt.VERBOSE), Pt(this.config.logLevel), Le(!!this.config.initialBlock, "config.initialBlock", "config.defaultBlock"), this.config.defaultBlock = this.config.defaultBlock || this.config.initialBlock || "paragraph", this.config.minHeight = this.config.minHeight !== void 0 ? this.config.minHeight : 300;
    const t2 = {
      type: this.config.defaultBlock,
      data: {}
    };
    this.config.placeholder = this.config.placeholder || false, this.config.sanitizer = this.config.sanitizer || {
      p: true,
      b: true,
      a: true
    }, this.config.hideToolbar = this.config.hideToolbar ? this.config.hideToolbar : false, this.config.tools = this.config.tools || {}, this.config.i18n = this.config.i18n || {}, this.config.data = this.config.data || { blocks: [] }, this.config.onReady = this.config.onReady || (() => {
    }), this.config.onChange = this.config.onChange || (() => {
    }), this.config.inlineToolbar = this.config.inlineToolbar !== void 0 ? this.config.inlineToolbar : true, (q(this.config.data) || !this.config.data.blocks || this.config.data.blocks.length === 0) && (this.config.data = { blocks: [t2] }), this.config.readOnly = this.config.readOnly || false, (o2 = this.config.i18n) != null && o2.messages && W.setDictionary(this.config.i18n.messages), this.config.i18n.direction = ((i2 = this.config.i18n) == null ? void 0 : i2.direction) || "ltr";
  }
  /**
   * Returns private property
   *
   * @returns {EditorConfig}
   */
  get configuration() {
    return this.config;
  }
  /**
   * Checks for required fields in Editor's config
   */
  validate() {
    const { holderId: e2, holder: t2 } = this.config;
    if (e2 && t2)
      throw Error("«holderId» and «holder» param can't assign at the same time.");
    if (Q(t2) && !d.get(t2))
      throw Error(`element with ID «${t2}» is missing. Pass correct holder's ID.`);
    if (t2 && z(t2) && !d.isElement(t2))
      throw Error("«holder» value must be an Element node");
  }
  /**
   * Initializes modules:
   *  - make and save instances
   *  - configure
   */
  init() {
    this.constructModules(), this.configureModules();
  }
  /**
   * Start Editor!
   *
   * Get list of modules that needs to be prepared and return a sequence (Promise)
   *
   * @returns {Promise<void>}
   */
  async start() {
    await [
      "Tools",
      "UI",
      "BlockManager",
      "Paste",
      "BlockSelection",
      "RectangleSelection",
      "CrossBlockSelection",
      "ReadOnly"
    ].reduce(
      (t2, o2) => t2.then(async () => {
        try {
          await this.moduleInstances[o2].prepare();
        } catch (i2) {
          if (i2 instanceof ht)
            throw new Error(i2.message);
          L(`Module ${o2} was skipped because of %o`, "warn", i2);
        }
      }),
      Promise.resolve()
    );
  }
  /**
   * Render initial data
   */
  render() {
    return this.moduleInstances.Renderer.render(this.config.data.blocks);
  }
  /**
   * Make modules instances and save it to the @property this.moduleInstances
   */
  constructModules() {
    Object.entries(yi).forEach(([e2, t2]) => {
      try {
        this.moduleInstances[e2] = new t2({
          config: this.configuration,
          eventsDispatcher: this.eventsDispatcher
        });
      } catch (o2) {
        L("[constructModules]", `Module ${e2} skipped because`, "error", o2);
      }
    });
  }
  /**
   * Modules instances configuration:
   *  - pass other modules to the 'state' property
   *  - ...
   */
  configureModules() {
    for (const e2 in this.moduleInstances)
      Object.prototype.hasOwnProperty.call(this.moduleInstances, e2) && (this.moduleInstances[e2].state = this.getModulesDiff(e2));
  }
  /**
   * Return modules without passed name
   *
   * @param {string} name - module for witch modules difference should be calculated
   */
  getModulesDiff(e2) {
    const t2 = {};
    for (const o2 in this.moduleInstances)
      o2 !== e2 && (t2[o2] = this.moduleInstances[o2]);
    return t2;
  }
}
/**
 * Editor.js
 *
 * @license Apache-2.0
 * @see Editor.js <https://editorjs.io>
 * @author CodeX Team <https://codex.so>
 */
class Bi {
  /** Editor version */
  static get version() {
    return "2.29.0-rc.1";
  }
  /**
   * @param {EditorConfig|string|undefined} [configuration] - user configuration
   */
  constructor(e2) {
    let t2 = () => {
    };
    z(e2) && D(e2.onReady) && (t2 = e2.onReady);
    const o2 = new Ei(e2);
    this.isReady = o2.isReady.then(() => {
      this.exportAPI(o2), t2();
    });
  }
  /**
   * Export external API methods
   *
   * @param {Core} editor — Editor's instance
   */
  exportAPI(e2) {
    const t2 = ["configuration"], o2 = () => {
      Object.values(e2.moduleInstances).forEach((n2) => {
        D(n2.destroy) && n2.destroy(), n2.listeners.removeAll();
      }), Io(), e2 = null;
      for (const n2 in this)
        Object.prototype.hasOwnProperty.call(this, n2) && delete this[n2];
      Object.setPrototypeOf(this, null);
    };
    t2.forEach((n2) => {
      this[n2] = e2[n2];
    }), this.destroy = o2, Object.setPrototypeOf(this, e2.moduleInstances.API.methods), delete this.exportAPI, Object.entries({
      blocks: {
        clear: "clear",
        render: "render"
      },
      caret: {
        focus: "focus"
      },
      events: {
        on: "on",
        off: "off",
        emit: "emit"
      },
      saver: {
        save: "save"
      }
    }).forEach(([n2, r2]) => {
      Object.entries(r2).forEach(([a2, l2]) => {
        this[l2] = e2.moduleInstances.API.methods[n2][a2];
      });
    });
  }
}
var bundle$4 = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(window, function() {
    return function(e2) {
      var t2 = {};
      function n2(r2) {
        if (t2[r2])
          return t2[r2].exports;
        var i2 = t2[r2] = { i: r2, l: false, exports: {} };
        return e2[r2].call(i2.exports, i2, i2.exports, n2), i2.l = true, i2.exports;
      }
      return n2.m = e2, n2.c = t2, n2.d = function(e3, t3, r2) {
        n2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: r2 });
      }, n2.r = function(e3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, n2.t = function(e3, t3) {
        if (1 & t3 && (e3 = n2(e3)), 8 & t3)
          return e3;
        if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule)
          return e3;
        var r2 = /* @__PURE__ */ Object.create(null);
        if (n2.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
          for (var i2 in e3)
            n2.d(r2, i2, (function(t4) {
              return e3[t4];
            }).bind(null, i2));
        return r2;
      }, n2.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return n2.d(t3, "a", t3), t3;
      }, n2.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, n2.p = "/", n2(n2.s = 14);
    }([function(e2, t2, n2) {
      var r2 = n2(5), i2 = n2(6), o2 = n2(7), a2 = n2(9);
      e2.exports = function(e3, t3) {
        return r2(e3) || i2(e3, t3) || o2(e3, t3) || a2();
      };
    }, function(e2, t2) {
      function n2(t3) {
        return "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? e2.exports = n2 = function(e3) {
          return typeof e3;
        } : e2.exports = n2 = function(e3) {
          return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
        }, n2(t3);
      }
      e2.exports = n2;
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        if (!(e3 instanceof t3))
          throw new TypeError("Cannot call a class as a function");
      };
    }, function(e2, t2) {
      function n2(e3, t3) {
        for (var n3 = 0; n3 < t3.length; n3++) {
          var r2 = t3[n3];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e3, r2.key, r2);
        }
      }
      e2.exports = function(e3, t3, r2) {
        return t3 && n2(e3.prototype, t3), r2 && n2(e3, r2), e3;
      };
    }, function(e2, t2) {
      function n2(e3, t3, n3) {
        var r2, i2, o2, a2, l2;
        function c2() {
          var s3 = Date.now() - a2;
          s3 < t3 && s3 >= 0 ? r2 = setTimeout(c2, t3 - s3) : (r2 = null, n3 || (l2 = e3.apply(o2, i2), o2 = i2 = null));
        }
        null == t3 && (t3 = 100);
        var s2 = function() {
          o2 = this, i2 = arguments, a2 = Date.now();
          var s3 = n3 && !r2;
          return r2 || (r2 = setTimeout(c2, t3)), s3 && (l2 = e3.apply(o2, i2), o2 = i2 = null), l2;
        };
        return s2.clear = function() {
          r2 && (clearTimeout(r2), r2 = null);
        }, s2.flush = function() {
          r2 && (l2 = e3.apply(o2, i2), o2 = i2 = null, clearTimeout(r2), r2 = null);
        }, s2;
      }
      n2.debounce = n2, e2.exports = n2;
    }, function(e2, t2) {
      e2.exports = function(e3) {
        if (Array.isArray(e3))
          return e3;
      };
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3)) {
          var n2 = [], r2 = true, i2 = false, o2 = void 0;
          try {
            for (var a2, l2 = e3[Symbol.iterator](); !(r2 = (a2 = l2.next()).done) && (n2.push(a2.value), !t3 || n2.length !== t3); r2 = true)
              ;
          } catch (e4) {
            i2 = true, o2 = e4;
          } finally {
            try {
              r2 || null == l2.return || l2.return();
            } finally {
              if (i2)
                throw o2;
            }
          }
          return n2;
        }
      };
    }, function(e2, t2, n2) {
      var r2 = n2(8);
      e2.exports = function(e3, t3) {
        if (e3) {
          if ("string" == typeof e3)
            return r2(e3, t3);
          var n3 = Object.prototype.toString.call(e3).slice(8, -1);
          return "Object" === n3 && e3.constructor && (n3 = e3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(n3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? r2(e3, t3) : void 0;
        }
      };
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        (null == t3 || t3 > e3.length) && (t3 = e3.length);
        for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++)
          r2[n2] = e3[n2];
        return r2;
      };
    }, function(e2, t2) {
      e2.exports = function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      };
    }, function(e2, t2, n2) {
      var r2 = n2(11), i2 = n2(12);
      "string" == typeof (i2 = i2.__esModule ? i2.default : i2) && (i2 = [[e2.i, i2, ""]]);
      var o2 = { insert: "head", singleton: false };
      r2(i2, o2);
      e2.exports = i2.locals || {};
    }, function(e2, t2, n2) {
      var r2, i2 = function() {
        return void 0 === r2 && (r2 = Boolean(window && document && document.all && !window.atob)), r2;
      }, o2 = function() {
        var e3 = {};
        return function(t3) {
          if (void 0 === e3[t3]) {
            var n3 = document.querySelector(t3);
            if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)
              try {
                n3 = n3.contentDocument.head;
              } catch (e4) {
                n3 = null;
              }
            e3[t3] = n3;
          }
          return e3[t3];
        };
      }(), a2 = [];
      function l2(e3) {
        for (var t3 = -1, n3 = 0; n3 < a2.length; n3++)
          if (a2[n3].identifier === e3) {
            t3 = n3;
            break;
          }
        return t3;
      }
      function c2(e3, t3) {
        for (var n3 = {}, r3 = [], i3 = 0; i3 < e3.length; i3++) {
          var o3 = e3[i3], c3 = t3.base ? o3[0] + t3.base : o3[0], s3 = n3[c3] || 0, d3 = "".concat(c3, " ").concat(s3);
          n3[c3] = s3 + 1;
          var u3 = l2(d3), h3 = { css: o3[1], media: o3[2], sourceMap: o3[3] };
          -1 !== u3 ? (a2[u3].references++, a2[u3].updater(h3)) : a2.push({ identifier: d3, updater: b2(h3, t3), references: 1 }), r3.push(d3);
        }
        return r3;
      }
      function s2(e3) {
        var t3 = document.createElement("style"), r3 = e3.attributes || {};
        if (void 0 === r3.nonce) {
          var i3 = n2.nc;
          i3 && (r3.nonce = i3);
        }
        if (Object.keys(r3).forEach(function(e4) {
          t3.setAttribute(e4, r3[e4]);
        }), "function" == typeof e3.insert)
          e3.insert(t3);
        else {
          var a3 = o2(e3.insert || "head");
          if (!a3)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          a3.appendChild(t3);
        }
        return t3;
      }
      var d2, u2 = (d2 = [], function(e3, t3) {
        return d2[e3] = t3, d2.filter(Boolean).join("\n");
      });
      function h2(e3, t3, n3, r3) {
        var i3 = n3 ? "" : r3.media ? "@media ".concat(r3.media, " {").concat(r3.css, "}") : r3.css;
        if (e3.styleSheet)
          e3.styleSheet.cssText = u2(t3, i3);
        else {
          var o3 = document.createTextNode(i3), a3 = e3.childNodes;
          a3[t3] && e3.removeChild(a3[t3]), a3.length ? e3.insertBefore(o3, a3[t3]) : e3.appendChild(o3);
        }
      }
      function m2(e3, t3, n3) {
        var r3 = n3.css, i3 = n3.media, o3 = n3.sourceMap;
        if (i3 ? e3.setAttribute("media", i3) : e3.removeAttribute("media"), o3 && btoa && (r3 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o3)))), " */")), e3.styleSheet)
          e3.styleSheet.cssText = r3;
        else {
          for (; e3.firstChild; )
            e3.removeChild(e3.firstChild);
          e3.appendChild(document.createTextNode(r3));
        }
      }
      var f2 = null, p2 = 0;
      function b2(e3, t3) {
        var n3, r3, i3;
        if (t3.singleton) {
          var o3 = p2++;
          n3 = f2 || (f2 = s2(t3)), r3 = h2.bind(null, n3, o3, false), i3 = h2.bind(null, n3, o3, true);
        } else
          n3 = s2(t3), r3 = m2.bind(null, n3, t3), i3 = function() {
            !function(e4) {
              if (null === e4.parentNode)
                return false;
              e4.parentNode.removeChild(e4);
            }(n3);
          };
        return r3(e3), function(t4) {
          if (t4) {
            if (t4.css === e3.css && t4.media === e3.media && t4.sourceMap === e3.sourceMap)
              return;
            r3(e3 = t4);
          } else
            i3();
        };
      }
      e2.exports = function(e3, t3) {
        (t3 = t3 || {}).singleton || "boolean" == typeof t3.singleton || (t3.singleton = i2());
        var n3 = c2(e3 = e3 || [], t3);
        return function(e4) {
          if (e4 = e4 || [], "[object Array]" === Object.prototype.toString.call(e4)) {
            for (var r3 = 0; r3 < n3.length; r3++) {
              var i3 = l2(n3[r3]);
              a2[i3].references--;
            }
            for (var o3 = c2(e4, t3), s3 = 0; s3 < n3.length; s3++) {
              var d3 = l2(n3[s3]);
              0 === a2[d3].references && (a2[d3].updater(), a2.splice(d3, 1));
            }
            n3 = o3;
          }
        };
      };
    }, function(e2, t2, n2) {
      (t2 = n2(13)(false)).push([e2.i, ".embed-tool--loading .embed-tool__caption {\n      display: none;\n    }\n\n    .embed-tool--loading .embed-tool__preloader {\n      display: block;\n    }\n\n    .embed-tool--loading .embed-tool__content {\n      display: none;\n    }\n  .embed-tool__preloader {\n    display: none;\n    position: relative;\n    height: 200px;\n    box-sizing: border-box;\n    border-radius: 5px;\n    border: 1px solid #e6e9eb;\n  }\n  .embed-tool__preloader::before {\n      content: '';\n      position: absolute;\n      z-index: 3;\n      left: 50%;\n      top: 50%;\n      width: 30px;\n      height: 30px;\n      margin-top: -25px;\n      margin-left: -15px;\n      border-radius: 50%;\n      border: 2px solid #cdd1e0;\n      border-top-color: #388ae5;\n      box-sizing: border-box;\n      animation: embed-preloader-spin 2s infinite linear;\n    }\n  .embed-tool__url {\n    position: absolute;\n    bottom: 20px;\n    left: 50%;\n    transform: translateX(-50%);\n    max-width: 250px;\n    color: #7b7e89;\n    font-size: 11px;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  .embed-tool__content {\n    width: 100%;\n  }\n  .embed-tool__caption {\n    margin-top: 7px;\n  }\n  .embed-tool__caption[contentEditable=true][data-placeholder]::before{\n      position: absolute;\n      content: attr(data-placeholder);\n      color: #707684;\n      font-weight: normal;\n      opacity: 0;\n    }\n  .embed-tool__caption[contentEditable=true][data-placeholder]:empty::before {\n         opacity: 1;\n      }\n  .embed-tool__caption[contentEditable=true][data-placeholder]:empty:focus::before {\n        opacity: 0;\n      }\n\n@keyframes embed-preloader-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n", ""]), e2.exports = t2;
    }, function(e2, t2, n2) {
      e2.exports = function(e3) {
        var t3 = [];
        return t3.toString = function() {
          return this.map(function(t4) {
            var n3 = function(e4, t5) {
              var n4 = e4[1] || "", r2 = e4[3];
              if (!r2)
                return n4;
              if (t5 && "function" == typeof btoa) {
                var i2 = (a2 = r2, l2 = btoa(unescape(encodeURIComponent(JSON.stringify(a2)))), c2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(l2), "/*# ".concat(c2, " */")), o2 = r2.sources.map(function(e5) {
                  return "/*# sourceURL=".concat(r2.sourceRoot || "").concat(e5, " */");
                });
                return [n4].concat(o2).concat([i2]).join("\n");
              }
              var a2, l2, c2;
              return [n4].join("\n");
            }(t4, e3);
            return t4[2] ? "@media ".concat(t4[2], " {").concat(n3, "}") : n3;
          }).join("");
        }, t3.i = function(e4, n3, r2) {
          "string" == typeof e4 && (e4 = [[null, e4, ""]]);
          var i2 = {};
          if (r2)
            for (var o2 = 0; o2 < this.length; o2++) {
              var a2 = this[o2][0];
              null != a2 && (i2[a2] = true);
            }
          for (var l2 = 0; l2 < e4.length; l2++) {
            var c2 = [].concat(e4[l2]);
            r2 && i2[c2[0]] || (n3 && (c2[2] ? c2[2] = "".concat(n3, " and ").concat(c2[2]) : c2[2] = n3), t3.push(c2));
          }
        }, t3;
      };
    }, function(e2, t2, n2) {
      n2.r(t2), n2.d(t2, "default", function() {
        return m2;
      });
      var r2 = n2(1), i2 = n2.n(r2), o2 = n2(0), a2 = n2.n(o2), l2 = n2(2), c2 = n2.n(l2), s2 = n2(3), d2 = n2.n(s2), u2 = { vimeo: { regex: /(?:http[s]?:\/\/)?(?:www.)?(?:player.)?vimeo\.co(?:.+\/([^\/]\d+)(?:#t=[\d]+)?s?$)/, embedUrl: "https://player.vimeo.com/video/<%= remote_id %>?title=0&byline=0", html: '<iframe style="width:100%;" height="320" frameborder="0"></iframe>', height: 320, width: 580 }, youtube: { regex: /(?:https?:\/\/)?(?:www\.)?(?:(?:youtu\.be\/)|(?:youtube\.com)\/(?:v\/|u\/\w\/|embed\/|watch))(?:(?:\?v=)?([^#&?=]*))?((?:[?&]\w*=\w*)*)/, embedUrl: "https://www.youtube.com/embed/<%= remote_id %>", html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>', height: 320, width: 580, id: function(e3) {
        var t3 = a2()(e3, 2), n3 = t3[0], r3 = t3[1];
        if (!r3 && n3)
          return n3;
        var i3 = { start: "start", end: "end", t: "start", time_continue: "start", list: "list" };
        return r3 = r3.slice(1).split("&").map(function(e4) {
          var t4 = e4.split("="), r4 = a2()(t4, 2), o3 = r4[0], l3 = r4[1];
          return n3 || "v" !== o3 ? i3[o3] ? "LL" === l3 || l3.startsWith("RDMM") || l3.startsWith("FL") ? null : "".concat(i3[o3], "=").concat(l3) : null : (n3 = l3, null);
        }).filter(function(e4) {
          return !!e4;
        }), n3 + "?" + r3.join("&");
      } }, coub: { regex: /https?:\/\/coub\.com\/view\/([^\/\?\&]+)/, embedUrl: "https://coub.com/embed/<%= remote_id %>", html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>', height: 320, width: 580 }, vine: { regex: /https?:\/\/vine\.co\/v\/([^\/\?\&]+)/, embedUrl: "https://vine.co/v/<%= remote_id %>/embed/simple/", html: '<iframe style="width:100%;" height="320" frameborder="0" allowfullscreen></iframe>', height: 320, width: 580 }, imgur: { regex: /https?:\/\/(?:i\.)?imgur\.com.*\/([a-zA-Z0-9]+)(?:\.gifv)?/, embedUrl: "http://imgur.com/<%= remote_id %>/embed", html: '<iframe allowfullscreen="true" scrolling="no" id="imgur-embed-iframe-pub-<%= remote_id %>" class="imgur-embed-iframe-pub" style="height: 500px; width: 100%; border: 1px solid #000"></iframe>', height: 500, width: 540 }, gfycat: { regex: /https?:\/\/gfycat\.com(?:\/detail)?\/([a-zA-Z]+)/, embedUrl: "https://gfycat.com/ifr/<%= remote_id %>", html: `<iframe frameborder='0' scrolling='no' style="width:100%;" height='436' allowfullscreen ></iframe>`, height: 436, width: 580 }, "twitch-channel": { regex: /https?:\/\/www\.twitch\.tv\/([^\/\?\&]*)\/?$/, embedUrl: "https://player.twitch.tv/?channel=<%= remote_id %>", html: '<iframe frameborder="0" allowfullscreen="true" scrolling="no" height="366" style="width:100%;"></iframe>', height: 366, width: 600 }, "twitch-video": { regex: /https?:\/\/www\.twitch\.tv\/(?:[^\/\?\&]*\/v|videos)\/([0-9]*)/, embedUrl: "https://player.twitch.tv/?video=v<%= remote_id %>", html: '<iframe frameborder="0" allowfullscreen="true" scrolling="no" height="366" style="width:100%;"></iframe>', height: 366, width: 600 }, "yandex-music-album": { regex: /https?:\/\/music\.yandex\.ru\/album\/([0-9]*)\/?$/, embedUrl: "https://music.yandex.ru/iframe/#album/<%= remote_id %>/", html: '<iframe frameborder="0" style="border:none;width:540px;height:400px;" style="width:100%;" height="400"></iframe>', height: 400, width: 540 }, "yandex-music-track": { regex: /https?:\/\/music\.yandex\.ru\/album\/([0-9]*)\/track\/([0-9]*)/, embedUrl: "https://music.yandex.ru/iframe/#track/<%= remote_id %>/", html: '<iframe frameborder="0" style="border:none;width:540px;height:100px;" style="width:100%;" height="100"></iframe>', height: 100, width: 540, id: function(e3) {
        return e3.join("/");
      } }, "yandex-music-playlist": { regex: /https?:\/\/music\.yandex\.ru\/users\/([^\/\?\&]*)\/playlists\/([0-9]*)/, embedUrl: "https://music.yandex.ru/iframe/#playlist/<%= remote_id %>/show/cover/description/", html: '<iframe frameborder="0" style="border:none;width:540px;height:400px;" width="540" height="400"></iframe>', height: 400, width: 540, id: function(e3) {
        return e3.join("/");
      } }, codepen: { regex: /https?:\/\/codepen\.io\/([^\/\?\&]*)\/pen\/([^\/\?\&]*)/, embedUrl: "https://codepen.io/<%= remote_id %>?height=300&theme-id=0&default-tab=css,result&embed-version=2", html: "<iframe height='300' scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'></iframe>", height: 300, width: 600, id: function(e3) {
        return e3.join("/embed/");
      } }, instagram: { regex: /https?:\/\/www\.instagram\.com\/p\/([^\/\?\&]+)\/?.*/, embedUrl: "https://www.instagram.com/p/<%= remote_id %>/embed", html: '<iframe width="400" height="505" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>', height: 505, width: 400 }, twitter: { regex: /^https?:\/\/twitter\.com\/(?:#!\/)?(\w+)\/status(?:es)?\/(\d+?.*)?$/, embedUrl: "https://twitframe.com/show?url=https://twitter.com/<%= remote_id %>", html: '<iframe width="600" height="600" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>', height: 300, width: 600, id: function(e3) {
        return e3.join("/status/");
      } }, pinterest: { regex: /https?:\/\/([^\/\?\&]*).pinterest.com\/pin\/([^\/\?\&]*)\/?$/, embedUrl: "https://assets.pinterest.com/ext/embed.html?id=<%= remote_id %>", html: "<iframe scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%; min-height: 400px; max-height: 1000px;'></iframe>", id: function(e3) {
        return e3[1];
      } }, facebook: { regex: /https?:\/\/www.facebook.com\/([^\/\?\&]*)\/(.*)/, embedUrl: "https://www.facebook.com/plugins/post.php?href=https://www.facebook.com/<%= remote_id %>&width=500", html: "<iframe scrolling='no' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%; min-height: 500px; max-height: 1000px;'></iframe>", id: function(e3) {
        return e3.join("/");
      } }, aparat: { regex: /(?:http[s]?:\/\/)?(?:www.)?aparat\.com\/v\/([^\/\?\&]+)\/?/, embedUrl: "https://www.aparat.com/video/video/embed/videohash/<%= remote_id %>/vt/frame", html: '<iframe width="600" height="300" style="margin: 0 auto;" frameborder="0" scrolling="no" allowtransparency="true"></iframe>', height: 300, width: 600 }, miro: { regex: /https:\/\/miro.com\/\S+(\S{12})\/(\S+)?/, embedUrl: "https://miro.com/app/live-embed/<%= remote_id %>", html: '<iframe width="700" height="500" style="margin: 0 auto;" allowFullScreen frameBorder="0" scrolling="no"></iframe>' } }, h2 = (n2(10), n2(4)), m2 = function() {
        function e3(t3) {
          var n3 = t3.data, r3 = t3.api, i3 = t3.readOnly;
          c2()(this, e3), this.api = r3, this._data = {}, this.element = null, this.readOnly = i3, this.data = n3;
        }
        return d2()(e3, [{ key: "render", value: function() {
          var t3 = this;
          if (!this.data.service) {
            var n3 = document.createElement("div");
            return this.element = n3, n3;
          }
          var r3 = e3.services[this.data.service].html, i3 = document.createElement("div"), o3 = document.createElement("div"), a3 = document.createElement("template"), l3 = this.createPreloader();
          i3.classList.add(this.CSS.baseClass, this.CSS.container, this.CSS.containerLoading), o3.classList.add(this.CSS.input, this.CSS.caption), i3.appendChild(l3), o3.contentEditable = !this.readOnly, o3.dataset.placeholder = this.api.i18n.t("Enter a caption"), o3.innerHTML = this.data.caption || "", a3.innerHTML = r3, a3.content.firstChild.setAttribute("src", this.data.embed), a3.content.firstChild.classList.add(this.CSS.content);
          var c3 = this.embedIsReady(i3);
          return i3.appendChild(a3.content.firstChild), i3.appendChild(o3), c3.then(function() {
            i3.classList.remove(t3.CSS.containerLoading);
          }), this.element = i3, i3;
        } }, { key: "createPreloader", value: function() {
          var e4 = document.createElement("preloader"), t3 = document.createElement("div");
          return t3.textContent = this.data.source, e4.classList.add(this.CSS.preloader), t3.classList.add(this.CSS.url), e4.appendChild(t3), e4;
        } }, { key: "save", value: function() {
          return this.data;
        } }, { key: "onPaste", value: function(t3) {
          var n3 = t3.detail, r3 = n3.key, i3 = n3.data, o3 = e3.services[r3], a3 = o3.regex, l3 = o3.embedUrl, c3 = o3.width, s3 = o3.height, d3 = o3.id, u3 = void 0 === d3 ? function(e4) {
            return e4.shift();
          } : d3, h3 = a3.exec(i3).slice(1), m3 = l3.replace(/<%= remote_id %>/g, u3(h3));
          this.data = { service: r3, source: i3, embed: m3, width: c3, height: s3 };
        } }, { key: "embedIsReady", value: function(e4) {
          var t3 = null;
          return new Promise(function(n3, r3) {
            (t3 = new MutationObserver(Object(h2.debounce)(n3, 450))).observe(e4, { childList: true, subtree: true });
          }).then(function() {
            t3.disconnect();
          });
        } }, { key: "data", set: function(e4) {
          if (!(e4 instanceof Object))
            throw Error("Embed Tool data should be object");
          var t3 = e4.service, n3 = e4.source, r3 = e4.embed, i3 = e4.width, o3 = e4.height, a3 = e4.caption, l3 = void 0 === a3 ? "" : a3;
          this._data = { service: t3 || this.data.service, source: n3 || this.data.source, embed: r3 || this.data.embed, width: i3 || this.data.width, height: o3 || this.data.height, caption: l3 || this.data.caption || "" };
          var c3 = this.element;
          c3 && c3.parentNode.replaceChild(this.render(), c3);
        }, get: function() {
          if (this.element) {
            var e4 = this.element.querySelector(".".concat(this.api.styles.input));
            this._data.caption = e4 ? e4.innerHTML : "";
          }
          return this._data;
        } }, { key: "CSS", get: function() {
          return { baseClass: this.api.styles.block, input: this.api.styles.input, container: "embed-tool", containerLoading: "embed-tool--loading", preloader: "embed-tool__preloader", caption: "embed-tool__caption", url: "embed-tool__url", content: "embed-tool__content" };
        } }], [{ key: "prepare", value: function(t3) {
          var n3 = t3.config, r3 = (void 0 === n3 ? {} : n3).services, o3 = void 0 === r3 ? {} : r3, l3 = Object.entries(u2), c3 = Object.entries(o3).filter(function(e4) {
            var t4 = a2()(e4, 2), n4 = (t4[0], t4[1]);
            return "boolean" == typeof n4 && true === n4;
          }).map(function(e4) {
            return a2()(e4, 1)[0];
          }), s3 = Object.entries(o3).filter(function(e4) {
            var t4 = a2()(e4, 2), n4 = (t4[0], t4[1]);
            return "object" === i2()(n4);
          }).filter(function(t4) {
            var n4 = a2()(t4, 2), r4 = (n4[0], n4[1]);
            return e3.checkServiceConfig(r4);
          }).map(function(e4) {
            var t4 = a2()(e4, 2), n4 = t4[0], r4 = t4[1];
            return [n4, { regex: r4.regex, embedUrl: r4.embedUrl, html: r4.html, height: r4.height, width: r4.width, id: r4.id }];
          });
          c3.length && (l3 = l3.filter(function(e4) {
            var t4 = a2()(e4, 1)[0];
            return c3.includes(t4);
          })), l3 = l3.concat(s3), e3.services = l3.reduce(function(e4, t4) {
            var n4 = a2()(t4, 2), r4 = n4[0], i3 = n4[1];
            return r4 in e4 ? (e4[r4] = Object.assign({}, e4[r4], i3), e4) : (e4[r4] = i3, e4);
          }, {}), e3.patterns = l3.reduce(function(e4, t4) {
            var n4 = a2()(t4, 2), r4 = n4[0], i3 = n4[1];
            return e4[r4] = i3.regex, e4;
          }, {});
        } }, { key: "checkServiceConfig", value: function(e4) {
          var t3 = e4.regex, n3 = e4.embedUrl, r3 = e4.html, i3 = e4.height, o3 = e4.width, a3 = e4.id, l3 = t3 && t3 instanceof RegExp && n3 && "string" == typeof n3 && r3 && "string" == typeof r3;
          return l3 = (l3 = (l3 = l3 && (void 0 === a3 || a3 instanceof Function)) && (void 0 === i3 || Number.isFinite(i3))) && (void 0 === o3 || Number.isFinite(o3));
        } }, { key: "pasteConfig", get: function() {
          return { patterns: e3.patterns };
        } }, { key: "isReadOnlySupported", get: function() {
          return true;
        } }]), e3;
      }();
    }]).default;
  });
})(bundle$4);
var bundleExports$4 = bundle$4.exports;
const Embed = /* @__PURE__ */ getDefaultExportFromCjs(bundleExports$4);
var bundle$3 = { exports: {} };
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(window, function() {
    return function(e2) {
      var t2 = {};
      function n2(r2) {
        if (t2[r2])
          return t2[r2].exports;
        var i2 = t2[r2] = { i: r2, l: false, exports: {} };
        return e2[r2].call(i2.exports, i2, i2.exports, n2), i2.l = true, i2.exports;
      }
      return n2.m = e2, n2.c = t2, n2.d = function(e3, t3, r2) {
        n2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: r2 });
      }, n2.r = function(e3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, n2.t = function(e3, t3) {
        if (1 & t3 && (e3 = n2(e3)), 8 & t3)
          return e3;
        if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule)
          return e3;
        var r2 = /* @__PURE__ */ Object.create(null);
        if (n2.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
          for (var i2 in e3)
            n2.d(r2, i2, (function(t4) {
              return e3[t4];
            }).bind(null, i2));
        return r2;
      }, n2.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return n2.d(t3, "a", t3), t3;
      }, n2.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, n2.p = "/", n2(n2.s = 4);
    }([function(e2, t2, n2) {
      var r2 = n2(1), i2 = n2(2);
      "string" == typeof (i2 = i2.__esModule ? i2.default : i2) && (i2 = [[e2.i, i2, ""]]);
      var o2 = { insert: "head", singleton: false };
      r2(i2, o2);
      e2.exports = i2.locals || {};
    }, function(e2, t2, n2) {
      var r2, i2 = function() {
        return void 0 === r2 && (r2 = Boolean(window && document && document.all && !window.atob)), r2;
      }, o2 = function() {
        var e3 = {};
        return function(t3) {
          if (void 0 === e3[t3]) {
            var n3 = document.querySelector(t3);
            if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)
              try {
                n3 = n3.contentDocument.head;
              } catch (e4) {
                n3 = null;
              }
            e3[t3] = n3;
          }
          return e3[t3];
        };
      }(), a2 = [];
      function s2(e3) {
        for (var t3 = -1, n3 = 0; n3 < a2.length; n3++)
          if (a2[n3].identifier === e3) {
            t3 = n3;
            break;
          }
        return t3;
      }
      function c2(e3, t3) {
        for (var n3 = {}, r3 = [], i3 = 0; i3 < e3.length; i3++) {
          var o3 = e3[i3], c3 = t3.base ? o3[0] + t3.base : o3[0], l3 = n3[c3] || 0, u3 = "".concat(c3, " ").concat(l3);
          n3[c3] = l3 + 1;
          var d3 = s2(u3), f3 = { css: o3[1], media: o3[2], sourceMap: o3[3] };
          -1 !== d3 ? (a2[d3].references++, a2[d3].updater(f3)) : a2.push({ identifier: u3, updater: y2(f3, t3), references: 1 }), r3.push(u3);
        }
        return r3;
      }
      function l2(e3) {
        var t3 = document.createElement("style"), r3 = e3.attributes || {};
        if (void 0 === r3.nonce) {
          var i3 = n2.nc;
          i3 && (r3.nonce = i3);
        }
        if (Object.keys(r3).forEach(function(e4) {
          t3.setAttribute(e4, r3[e4]);
        }), "function" == typeof e3.insert)
          e3.insert(t3);
        else {
          var a3 = o2(e3.insert || "head");
          if (!a3)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          a3.appendChild(t3);
        }
        return t3;
      }
      var u2, d2 = (u2 = [], function(e3, t3) {
        return u2[e3] = t3, u2.filter(Boolean).join("\n");
      });
      function f2(e3, t3, n3, r3) {
        var i3 = n3 ? "" : r3.media ? "@media ".concat(r3.media, " {").concat(r3.css, "}") : r3.css;
        if (e3.styleSheet)
          e3.styleSheet.cssText = d2(t3, i3);
        else {
          var o3 = document.createTextNode(i3), a3 = e3.childNodes;
          a3[t3] && e3.removeChild(a3[t3]), a3.length ? e3.insertBefore(o3, a3[t3]) : e3.appendChild(o3);
        }
      }
      function p2(e3, t3, n3) {
        var r3 = n3.css, i3 = n3.media, o3 = n3.sourceMap;
        if (i3 ? e3.setAttribute("media", i3) : e3.removeAttribute("media"), o3 && btoa && (r3 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(o3)))), " */")), e3.styleSheet)
          e3.styleSheet.cssText = r3;
        else {
          for (; e3.firstChild; )
            e3.removeChild(e3.firstChild);
          e3.appendChild(document.createTextNode(r3));
        }
      }
      var h2 = null, m2 = 0;
      function y2(e3, t3) {
        var n3, r3, i3;
        if (t3.singleton) {
          var o3 = m2++;
          n3 = h2 || (h2 = l2(t3)), r3 = f2.bind(null, n3, o3, false), i3 = f2.bind(null, n3, o3, true);
        } else
          n3 = l2(t3), r3 = p2.bind(null, n3, t3), i3 = function() {
            !function(e4) {
              if (null === e4.parentNode)
                return false;
              e4.parentNode.removeChild(e4);
            }(n3);
          };
        return r3(e3), function(t4) {
          if (t4) {
            if (t4.css === e3.css && t4.media === e3.media && t4.sourceMap === e3.sourceMap)
              return;
            r3(e3 = t4);
          } else
            i3();
        };
      }
      e2.exports = function(e3, t3) {
        (t3 = t3 || {}).singleton || "boolean" == typeof t3.singleton || (t3.singleton = i2());
        var n3 = c2(e3 = e3 || [], t3);
        return function(e4) {
          if (e4 = e4 || [], "[object Array]" === Object.prototype.toString.call(e4)) {
            for (var r3 = 0; r3 < n3.length; r3++) {
              var i3 = s2(n3[r3]);
              a2[i3].references--;
            }
            for (var o3 = c2(e4, t3), l3 = 0; l3 < n3.length; l3++) {
              var u3 = s2(n3[l3]);
              0 === a2[u3].references && (a2[u3].updater(), a2.splice(u3, 1));
            }
            n3 = o3;
          }
        };
      };
    }, function(e2, t2, n2) {
      (t2 = n2(3)(false)).push([e2.i, ".cdx-list {\n    margin: 0;\n    padding-left: 40px;\n    outline: none;\n}\n\n    .cdx-list__item {\n        padding: 5.5px 0 5.5px 3px;\n        line-height: 1.6em;\n    }\n\n    .cdx-list--unordered {\n        list-style: disc;\n    }\n\n    .cdx-list--ordered {\n        list-style: decimal;\n    }\n\n    .cdx-list-settings {\n        display: flex;\n    }\n\n    .cdx-list-settings .cdx-settings-button {\n            width: 50%;\n        }\n", ""]), e2.exports = t2;
    }, function(e2, t2, n2) {
      e2.exports = function(e3) {
        var t3 = [];
        return t3.toString = function() {
          return this.map(function(t4) {
            var n3 = function(e4, t5) {
              var n4 = e4[1] || "", r2 = e4[3];
              if (!r2)
                return n4;
              if (t5 && "function" == typeof btoa) {
                var i2 = (a2 = r2, s2 = btoa(unescape(encodeURIComponent(JSON.stringify(a2)))), c2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s2), "/*# ".concat(c2, " */")), o2 = r2.sources.map(function(e5) {
                  return "/*# sourceURL=".concat(r2.sourceRoot || "").concat(e5, " */");
                });
                return [n4].concat(o2).concat([i2]).join("\n");
              }
              var a2, s2, c2;
              return [n4].join("\n");
            }(t4, e3);
            return t4[2] ? "@media ".concat(t4[2], " {").concat(n3, "}") : n3;
          }).join("");
        }, t3.i = function(e4, n3, r2) {
          "string" == typeof e4 && (e4 = [[null, e4, ""]]);
          var i2 = {};
          if (r2)
            for (var o2 = 0; o2 < this.length; o2++) {
              var a2 = this[o2][0];
              null != a2 && (i2[a2] = true);
            }
          for (var s2 = 0; s2 < e4.length; s2++) {
            var c2 = [].concat(e4[s2]);
            r2 && i2[c2[0]] || (n3 && (c2[2] ? c2[2] = "".concat(n3, " and ").concat(c2[2]) : c2[2] = n3), t3.push(c2));
          }
        }, t3;
      };
    }, function(e2, t2, n2) {
      n2.r(t2), n2.d(t2, "default", function() {
        return d2;
      });
      n2(0);
      const r2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="9" x2="19" y1="7" y2="7" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="9" x2="19" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="9" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 17H4.99002"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 12H4.99002"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M5.00001 7H4.99002"/></svg>';
      function i2(e3) {
        return function(e4) {
          if (Array.isArray(e4))
            return o2(e4);
        }(e3) || function(e4) {
          if ("undefined" != typeof Symbol && Symbol.iterator in Object(e4))
            return Array.from(e4);
        }(e3) || function(e4, t3) {
          if (!e4)
            return;
          if ("string" == typeof e4)
            return o2(e4, t3);
          var n3 = Object.prototype.toString.call(e4).slice(8, -1);
          "Object" === n3 && e4.constructor && (n3 = e4.constructor.name);
          if ("Map" === n3 || "Set" === n3)
            return Array.from(e4);
          if ("Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3))
            return o2(e4, t3);
        }(e3) || function() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }();
      }
      function o2(e3, t3) {
        (null == t3 || t3 > e3.length) && (t3 = e3.length);
        for (var n3 = 0, r3 = new Array(t3); n3 < t3; n3++)
          r3[n3] = e3[n3];
        return r3;
      }
      function a2(e3, t3) {
        var n3 = Object.keys(e3);
        if (Object.getOwnPropertySymbols) {
          var r3 = Object.getOwnPropertySymbols(e3);
          t3 && (r3 = r3.filter(function(t4) {
            return Object.getOwnPropertyDescriptor(e3, t4).enumerable;
          })), n3.push.apply(n3, r3);
        }
        return n3;
      }
      function s2(e3) {
        for (var t3 = 1; t3 < arguments.length; t3++) {
          var n3 = null != arguments[t3] ? arguments[t3] : {};
          t3 % 2 ? a2(Object(n3), true).forEach(function(t4) {
            c2(e3, t4, n3[t4]);
          }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(n3)) : a2(Object(n3)).forEach(function(t4) {
            Object.defineProperty(e3, t4, Object.getOwnPropertyDescriptor(n3, t4));
          });
        }
        return e3;
      }
      function c2(e3, t3, n3) {
        return t3 in e3 ? Object.defineProperty(e3, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e3[t3] = n3, e3;
      }
      function l2(e3, t3) {
        for (var n3 = 0; n3 < t3.length; n3++) {
          var r3 = t3[n3];
          r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e3, r3.key, r3);
        }
      }
      function u2(e3, t3, n3) {
        return t3 && l2(e3.prototype, t3), n3 && l2(e3, n3), e3;
      }
      var d2 = function() {
        function e3(t3) {
          var n3 = t3.data, i3 = t3.config, o3 = t3.api, a3 = t3.readOnly;
          !function(e4, t4) {
            if (!(e4 instanceof t4))
              throw new TypeError("Cannot call a class as a function");
          }(this, e3), this._elements = { wrapper: null }, this.api = o3, this.readOnly = a3, this.settings = [{ name: "unordered", label: this.api.i18n.t("Unordered"), icon: r2, default: "unordered" === i3.defaultStyle || false }, { name: "ordered", label: this.api.i18n.t("Ordered"), icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><line x1="12" x2="19" y1="7" y2="7" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="12" x2="19" y1="12" y2="12" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><line x1="12" x2="19" y1="17" y2="17" stroke="currentColor" stroke-linecap="round" stroke-width="2"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.79999 14L7.79999 7.2135C7.79999 7.12872 7.7011 7.0824 7.63597 7.13668L4.79999 9.5"/></svg>', default: "ordered" === i3.defaultStyle || true }], this._data = { style: this.settings.find(function(e4) {
            return true === e4.default;
          }).name, items: [] }, this.data = n3;
        }
        return u2(e3, null, [{ key: "isReadOnlySupported", get: function() {
          return true;
        } }, { key: "enableLineBreaks", get: function() {
          return true;
        } }, { key: "toolbox", get: function() {
          return { icon: r2, title: "List" };
        } }]), u2(e3, [{ key: "render", value: function() {
          var e4 = this;
          return this._elements.wrapper = this.makeMainTag(this._data.style), this._data.items.length ? this._data.items.forEach(function(t3) {
            e4._elements.wrapper.appendChild(e4._make("li", e4.CSS.item, { innerHTML: t3 }));
          }) : this._elements.wrapper.appendChild(this._make("li", this.CSS.item)), this.readOnly || this._elements.wrapper.addEventListener("keydown", function(t3) {
            switch (t3.keyCode) {
              case 13:
                e4.getOutofList(t3);
                break;
              case 8:
                e4.backspace(t3);
            }
          }, false), this._elements.wrapper;
        } }, { key: "save", value: function() {
          return this.data;
        } }, { key: "renderSettings", value: function() {
          var e4 = this;
          return this.settings.map(function(t3) {
            return s2(s2({}, t3), {}, { isActive: e4._data.style === t3.name, closeOnActivate: true, onActivate: function() {
              return e4.toggleTune(t3.name);
            } });
          });
        } }, { key: "onPaste", value: function(e4) {
          var t3 = e4.detail.data;
          this.data = this.pasteHandler(t3);
        } }, { key: "makeMainTag", value: function(e4) {
          var t3 = "ordered" === e4 ? this.CSS.wrapperOrdered : this.CSS.wrapperUnordered, n3 = "ordered" === e4 ? "ol" : "ul";
          return this._make(n3, [this.CSS.baseBlock, this.CSS.wrapper, t3], { contentEditable: !this.readOnly });
        } }, { key: "toggleTune", value: function(e4) {
          for (var t3 = this.makeMainTag(e4); this._elements.wrapper.hasChildNodes(); )
            t3.appendChild(this._elements.wrapper.firstChild);
          this._elements.wrapper.replaceWith(t3), this._elements.wrapper = t3, this._data.style = e4;
        } }, { key: "_make", value: function(e4) {
          var t3, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o3 = document.createElement(e4);
          Array.isArray(n3) ? (t3 = o3.classList).add.apply(t3, i2(n3)) : n3 && o3.classList.add(n3);
          for (var a3 in r3)
            o3[a3] = r3[a3];
          return o3;
        } }, { key: "getOutofList", value: function(e4) {
          var t3 = this._elements.wrapper.querySelectorAll("." + this.CSS.item);
          if (!(t3.length < 2)) {
            var n3 = t3[t3.length - 1], r3 = this.currentItem;
            r3 !== n3 || n3.textContent.trim().length || (r3.parentElement.removeChild(r3), this.api.blocks.insert(), this.api.caret.setToBlock(this.api.blocks.getCurrentBlockIndex()), e4.preventDefault(), e4.stopPropagation());
          }
        } }, { key: "backspace", value: function(e4) {
          var t3 = this._elements.wrapper.querySelectorAll("." + this.CSS.item), n3 = t3[0];
          n3 && t3.length < 2 && !n3.innerHTML.replace("<br>", " ").trim() && e4.preventDefault();
        } }, { key: "selectItem", value: function(e4) {
          e4.preventDefault();
          var t3 = window.getSelection(), n3 = t3.anchorNode.parentNode.closest("." + this.CSS.item), r3 = new Range();
          r3.selectNodeContents(n3), t3.removeAllRanges(), t3.addRange(r3);
        } }, { key: "pasteHandler", value: function(e4) {
          var t3, n3 = e4.tagName;
          switch (n3) {
            case "OL":
              t3 = "ordered";
              break;
            case "UL":
            case "LI":
              t3 = "unordered";
          }
          var r3 = { style: t3, items: [] };
          if ("LI" === n3)
            r3.items = [e4.innerHTML];
          else {
            var i3 = Array.from(e4.querySelectorAll("LI"));
            r3.items = i3.map(function(e5) {
              return e5.innerHTML;
            }).filter(function(e5) {
              return !!e5.trim();
            });
          }
          return r3;
        } }, { key: "CSS", get: function() {
          return { baseBlock: this.api.styles.block, wrapper: "cdx-list", wrapperOrdered: "cdx-list--ordered", wrapperUnordered: "cdx-list--unordered", item: "cdx-list__item" };
        } }, { key: "data", set: function(e4) {
          e4 || (e4 = {}), this._data.style = e4.style || this.settings.find(function(e5) {
            return true === e5.default;
          }).name, this._data.items = e4.items || [];
          var t3 = this._elements.wrapper;
          t3 && t3.parentNode.replaceChild(this.render(), t3);
        }, get: function() {
          this._data.items = [];
          for (var e4 = this._elements.wrapper.querySelectorAll(".".concat(this.CSS.item)), t3 = 0; t3 < e4.length; t3++) {
            e4[t3].innerHTML.replace("<br>", " ").trim() && this._data.items.push(e4[t3].innerHTML);
          }
          return this._data;
        } }, { key: "currentItem", get: function() {
          var e4 = window.getSelection().anchorNode;
          return e4.nodeType !== Node.ELEMENT_NODE && (e4 = e4.parentNode), e4.closest(".".concat(this.CSS.item));
        } }], [{ key: "conversionConfig", get: function() {
          return { export: function(e4) {
            return e4.items.join(". ");
          }, import: function(e4) {
            return { items: [e4], style: "unordered" };
          } };
        } }, { key: "sanitize", get: function() {
          return { style: {}, items: { br: true } };
        } }, { key: "pasteConfig", get: function() {
          return { tags: ["OL", "UL", "LI"] };
        } }]), e3;
      }();
    }]).default;
  });
})(bundle$3);
var bundleExports$3 = bundle$3.exports;
const List2 = /* @__PURE__ */ getDefaultExportFromCjs(bundleExports$3);
var bundle$2 = { exports: {} };
/*!
 * Image tool
 * 
 * @version 2.8.1
 * 
 * @package https://github.com/editor-js/image
 * @licence MIT
 * @author CodeX <https://codex.so>
 */
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(window, function() {
    return function(e2) {
      var t2 = {};
      function n2(r2) {
        if (t2[r2])
          return t2[r2].exports;
        var o2 = t2[r2] = { i: r2, l: false, exports: {} };
        return e2[r2].call(o2.exports, o2, o2.exports, n2), o2.l = true, o2.exports;
      }
      return n2.m = e2, n2.c = t2, n2.d = function(e3, t3, r2) {
        n2.o(e3, t3) || Object.defineProperty(e3, t3, { enumerable: true, get: r2 });
      }, n2.r = function(e3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, n2.t = function(e3, t3) {
        if (1 & t3 && (e3 = n2(e3)), 8 & t3)
          return e3;
        if (4 & t3 && "object" == typeof e3 && e3 && e3.__esModule)
          return e3;
        var r2 = /* @__PURE__ */ Object.create(null);
        if (n2.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e3 }), 2 & t3 && "string" != typeof e3)
          for (var o2 in e3)
            n2.d(r2, o2, (function(t4) {
              return e3[t4];
            }).bind(null, o2));
        return r2;
      }, n2.n = function(e3) {
        var t3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return n2.d(t3, "a", t3), t3;
      }, n2.o = function(e3, t3) {
        return Object.prototype.hasOwnProperty.call(e3, t3);
      }, n2.p = "/", n2(n2.s = 9);
    }([function(e2, t2) {
      function n2(e3, t3) {
        for (var n3 = 0; n3 < t3.length; n3++) {
          var r2 = t3[n3];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(e3, r2.key, r2);
        }
      }
      e2.exports = function(e3, t3, r2) {
        return t3 && n2(e3.prototype, t3), r2 && n2(e3, r2), e3;
      };
    }, function(e2, t2, n2) {
      e2.exports = function(e3) {
        var t3 = {};
        function n3(r2) {
          if (t3[r2])
            return t3[r2].exports;
          var o2 = t3[r2] = { i: r2, l: false, exports: {} };
          return e3[r2].call(o2.exports, o2, o2.exports, n3), o2.l = true, o2.exports;
        }
        return n3.m = e3, n3.c = t3, n3.d = function(e4, t4, r2) {
          n3.o(e4, t4) || Object.defineProperty(e4, t4, { enumerable: true, get: r2 });
        }, n3.r = function(e4) {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e4, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e4, "__esModule", { value: true });
        }, n3.t = function(e4, t4) {
          if (1 & t4 && (e4 = n3(e4)), 8 & t4)
            return e4;
          if (4 & t4 && "object" == typeof e4 && e4 && e4.__esModule)
            return e4;
          var r2 = /* @__PURE__ */ Object.create(null);
          if (n3.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: e4 }), 2 & t4 && "string" != typeof e4)
            for (var o2 in e4)
              n3.d(r2, o2, (function(t5) {
                return e4[t5];
              }).bind(null, o2));
          return r2;
        }, n3.n = function(e4) {
          var t4 = e4 && e4.__esModule ? function() {
            return e4.default;
          } : function() {
            return e4;
          };
          return n3.d(t4, "a", t4), t4;
        }, n3.o = function(e4, t4) {
          return Object.prototype.hasOwnProperty.call(e4, t4);
        }, n3.p = "", n3(n3.s = 3);
      }([function(e3, t3) {
        var n3;
        n3 = function() {
          return this;
        }();
        try {
          n3 = n3 || new Function("return this")();
        } catch (e4) {
          "object" == typeof window && (n3 = window);
        }
        e3.exports = n3;
      }, function(e3, t3, n3) {
        (function(e4) {
          var r2 = n3(2), o2 = setTimeout;
          function i2() {
          }
          function a2(e5) {
            if (!(this instanceof a2))
              throw new TypeError("Promises must be constructed via new");
            if ("function" != typeof e5)
              throw new TypeError("not a function");
            this._state = 0, this._handled = false, this._value = void 0, this._deferreds = [], f2(e5, this);
          }
          function u2(e5, t4) {
            for (; 3 === e5._state; )
              e5 = e5._value;
            0 !== e5._state ? (e5._handled = true, a2._immediateFn(function() {
              var n4 = 1 === e5._state ? t4.onFulfilled : t4.onRejected;
              if (null !== n4) {
                var r3;
                try {
                  r3 = n4(e5._value);
                } catch (e6) {
                  return void s2(t4.promise, e6);
                }
                c2(t4.promise, r3);
              } else
                (1 === e5._state ? c2 : s2)(t4.promise, e5._value);
            })) : e5._deferreds.push(t4);
          }
          function c2(e5, t4) {
            try {
              if (t4 === e5)
                throw new TypeError("A promise cannot be resolved with itself.");
              if (t4 && ("object" == typeof t4 || "function" == typeof t4)) {
                var n4 = t4.then;
                if (t4 instanceof a2)
                  return e5._state = 3, e5._value = t4, void l2(e5);
                if ("function" == typeof n4)
                  return void f2((r3 = n4, o3 = t4, function() {
                    r3.apply(o3, arguments);
                  }), e5);
              }
              e5._state = 1, e5._value = t4, l2(e5);
            } catch (t5) {
              s2(e5, t5);
            }
            var r3, o3;
          }
          function s2(e5, t4) {
            e5._state = 2, e5._value = t4, l2(e5);
          }
          function l2(e5) {
            2 === e5._state && 0 === e5._deferreds.length && a2._immediateFn(function() {
              e5._handled || a2._unhandledRejectionFn(e5._value);
            });
            for (var t4 = 0, n4 = e5._deferreds.length; t4 < n4; t4++)
              u2(e5, e5._deferreds[t4]);
            e5._deferreds = null;
          }
          function d2(e5, t4, n4) {
            this.onFulfilled = "function" == typeof e5 ? e5 : null, this.onRejected = "function" == typeof t4 ? t4 : null, this.promise = n4;
          }
          function f2(e5, t4) {
            var n4 = false;
            try {
              e5(function(e6) {
                n4 || (n4 = true, c2(t4, e6));
              }, function(e6) {
                n4 || (n4 = true, s2(t4, e6));
              });
            } catch (e6) {
              if (n4)
                return;
              n4 = true, s2(t4, e6);
            }
          }
          a2.prototype.catch = function(e5) {
            return this.then(null, e5);
          }, a2.prototype.then = function(e5, t4) {
            var n4 = new this.constructor(i2);
            return u2(this, new d2(e5, t4, n4)), n4;
          }, a2.prototype.finally = r2.a, a2.all = function(e5) {
            return new a2(function(t4, n4) {
              if (!e5 || void 0 === e5.length)
                throw new TypeError("Promise.all accepts an array");
              var r3 = Array.prototype.slice.call(e5);
              if (0 === r3.length)
                return t4([]);
              var o3 = r3.length;
              function i3(e6, a4) {
                try {
                  if (a4 && ("object" == typeof a4 || "function" == typeof a4)) {
                    var u3 = a4.then;
                    if ("function" == typeof u3)
                      return void u3.call(a4, function(t5) {
                        i3(e6, t5);
                      }, n4);
                  }
                  r3[e6] = a4, 0 == --o3 && t4(r3);
                } catch (e7) {
                  n4(e7);
                }
              }
              for (var a3 = 0; a3 < r3.length; a3++)
                i3(a3, r3[a3]);
            });
          }, a2.resolve = function(e5) {
            return e5 && "object" == typeof e5 && e5.constructor === a2 ? e5 : new a2(function(t4) {
              t4(e5);
            });
          }, a2.reject = function(e5) {
            return new a2(function(t4, n4) {
              n4(e5);
            });
          }, a2.race = function(e5) {
            return new a2(function(t4, n4) {
              for (var r3 = 0, o3 = e5.length; r3 < o3; r3++)
                e5[r3].then(t4, n4);
            });
          }, a2._immediateFn = "function" == typeof e4 && function(t4) {
            e4(t4);
          } || function(e5) {
            o2(e5, 0);
          }, a2._unhandledRejectionFn = function(e5) {
            "undefined" != typeof console && console && console.warn("Possible Unhandled Promise Rejection:", e5);
          }, t3.a = a2;
        }).call(this, n3(5).setImmediate);
      }, function(e3, t3, n3) {
        t3.a = function(e4) {
          var t4 = this.constructor;
          return this.then(function(n4) {
            return t4.resolve(e4()).then(function() {
              return n4;
            });
          }, function(n4) {
            return t4.resolve(e4()).then(function() {
              return t4.reject(n4);
            });
          });
        };
      }, function(e3, t3, n3) {
        function r2(e4) {
          return (r2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e5) {
            return typeof e5;
          } : function(e5) {
            return e5 && "function" == typeof Symbol && e5.constructor === Symbol && e5 !== Symbol.prototype ? "symbol" : typeof e5;
          })(e4);
        }
        n3(4);
        var o2, i2, a2, u2, c2, s2, l2, d2 = n3(8), f2 = (i2 = function(e4) {
          return new Promise(function(t4, n4) {
            e4 = u2(e4), (e4 = c2(e4)).beforeSend && e4.beforeSend();
            var r3 = window.XMLHttpRequest ? new window.XMLHttpRequest() : new window.ActiveXObject("Microsoft.XMLHTTP");
            r3.open(e4.method, e4.url), r3.setRequestHeader("X-Requested-With", "XMLHttpRequest"), Object.keys(e4.headers).forEach(function(t5) {
              var n5 = e4.headers[t5];
              r3.setRequestHeader(t5, n5);
            });
            var o3 = e4.ratio;
            r3.upload.addEventListener("progress", function(t5) {
              var n5 = Math.round(t5.loaded / t5.total * 100), r4 = Math.ceil(n5 * o3 / 100);
              e4.progress(Math.min(r4, 100));
            }, false), r3.addEventListener("progress", function(t5) {
              var n5 = Math.round(t5.loaded / t5.total * 100), r4 = Math.ceil(n5 * (100 - o3) / 100) + o3;
              e4.progress(Math.min(r4, 100));
            }, false), r3.onreadystatechange = function() {
              if (4 === r3.readyState) {
                var e5 = r3.response;
                try {
                  e5 = JSON.parse(e5);
                } catch (e6) {
                }
                var o4 = d2.parseHeaders(r3.getAllResponseHeaders()), i3 = { body: e5, code: r3.status, headers: o4 };
                l2(r3.status) ? t4(i3) : n4(i3);
              }
            }, r3.send(e4.data);
          });
        }, a2 = function(e4) {
          return e4.method = "POST", i2(e4);
        }, u2 = function() {
          var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          if (e4.url && "string" != typeof e4.url)
            throw new Error("Url must be a string");
          if (e4.url = e4.url || "", e4.method && "string" != typeof e4.method)
            throw new Error("`method` must be a string or null");
          if (e4.method = e4.method ? e4.method.toUpperCase() : "GET", e4.headers && "object" !== r2(e4.headers))
            throw new Error("`headers` must be an object or null");
          if (e4.headers = e4.headers || {}, e4.type && ("string" != typeof e4.type || !Object.values(o2).includes(e4.type)))
            throw new Error("`type` must be taken from module's «contentType» library");
          if (e4.progress && "function" != typeof e4.progress)
            throw new Error("`progress` must be a function or null");
          if (e4.progress = e4.progress || function(e5) {
          }, e4.beforeSend = e4.beforeSend || function(e5) {
          }, e4.ratio && "number" != typeof e4.ratio)
            throw new Error("`ratio` must be a number");
          if (e4.ratio < 0 || e4.ratio > 100)
            throw new Error("`ratio` must be in a 0-100 interval");
          if (e4.ratio = e4.ratio || 90, e4.accept && "string" != typeof e4.accept)
            throw new Error("`accept` must be a string with a list of allowed mime-types");
          if (e4.accept = e4.accept || "*/*", e4.multiple && "boolean" != typeof e4.multiple)
            throw new Error("`multiple` must be a true or false");
          if (e4.multiple = e4.multiple || false, e4.fieldName && "string" != typeof e4.fieldName)
            throw new Error("`fieldName` must be a string");
          return e4.fieldName = e4.fieldName || "files", e4;
        }, c2 = function(e4) {
          switch (e4.method) {
            case "GET":
              var t4 = s2(e4.data, o2.URLENCODED);
              delete e4.data, e4.url = /\?/.test(e4.url) ? e4.url + "&" + t4 : e4.url + "?" + t4;
              break;
            case "POST":
            case "PUT":
            case "DELETE":
            case "UPDATE":
              var n4 = function() {
                return (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}).type || o2.JSON;
              }(e4);
              (d2.isFormData(e4.data) || d2.isFormElement(e4.data)) && (n4 = o2.FORM), e4.data = s2(e4.data, n4), n4 !== f2.contentType.FORM && (e4.headers["content-type"] = n4);
          }
          return e4;
        }, s2 = function() {
          var e4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
          switch (arguments.length > 1 ? arguments[1] : void 0) {
            case o2.URLENCODED:
              return d2.urlEncode(e4);
            case o2.JSON:
              return d2.jsonEncode(e4);
            case o2.FORM:
              return d2.formEncode(e4);
            default:
              return e4;
          }
        }, l2 = function(e4) {
          return e4 >= 200 && e4 < 300;
        }, { contentType: o2 = { URLENCODED: "application/x-www-form-urlencoded; charset=utf-8", FORM: "multipart/form-data", JSON: "application/json; charset=utf-8" }, request: i2, get: function(e4) {
          return e4.method = "GET", i2(e4);
        }, post: a2, transport: function(e4) {
          return e4 = u2(e4), d2.selectFiles(e4).then(function(t4) {
            for (var n4 = new FormData(), r3 = 0; r3 < t4.length; r3++)
              n4.append(e4.fieldName, t4[r3], t4[r3].name);
            d2.isObject(e4.data) && Object.keys(e4.data).forEach(function(t5) {
              var r4 = e4.data[t5];
              n4.append(t5, r4);
            });
            var o3 = e4.beforeSend;
            return e4.beforeSend = function() {
              return o3(t4);
            }, e4.data = n4, a2(e4);
          });
        }, selectFiles: function(e4) {
          return delete (e4 = u2(e4)).beforeSend, d2.selectFiles(e4);
        } });
        e3.exports = f2;
      }, function(e3, t3, n3) {
        n3.r(t3);
        var r2 = n3(1);
        window.Promise = window.Promise || r2.a;
      }, function(e3, t3, n3) {
        (function(e4) {
          var r2 = void 0 !== e4 && e4 || "undefined" != typeof self && self || window, o2 = Function.prototype.apply;
          function i2(e5, t4) {
            this._id = e5, this._clearFn = t4;
          }
          t3.setTimeout = function() {
            return new i2(o2.call(setTimeout, r2, arguments), clearTimeout);
          }, t3.setInterval = function() {
            return new i2(o2.call(setInterval, r2, arguments), clearInterval);
          }, t3.clearTimeout = t3.clearInterval = function(e5) {
            e5 && e5.close();
          }, i2.prototype.unref = i2.prototype.ref = function() {
          }, i2.prototype.close = function() {
            this._clearFn.call(r2, this._id);
          }, t3.enroll = function(e5, t4) {
            clearTimeout(e5._idleTimeoutId), e5._idleTimeout = t4;
          }, t3.unenroll = function(e5) {
            clearTimeout(e5._idleTimeoutId), e5._idleTimeout = -1;
          }, t3._unrefActive = t3.active = function(e5) {
            clearTimeout(e5._idleTimeoutId);
            var t4 = e5._idleTimeout;
            t4 >= 0 && (e5._idleTimeoutId = setTimeout(function() {
              e5._onTimeout && e5._onTimeout();
            }, t4));
          }, n3(6), t3.setImmediate = "undefined" != typeof self && self.setImmediate || void 0 !== e4 && e4.setImmediate || this && this.setImmediate, t3.clearImmediate = "undefined" != typeof self && self.clearImmediate || void 0 !== e4 && e4.clearImmediate || this && this.clearImmediate;
        }).call(this, n3(0));
      }, function(e3, t3, n3) {
        (function(e4, t4) {
          !function(e5, n4) {
            if (!e5.setImmediate) {
              var r2, o2, i2, a2, u2, c2 = 1, s2 = {}, l2 = false, d2 = e5.document, f2 = Object.getPrototypeOf && Object.getPrototypeOf(e5);
              f2 = f2 && f2.setTimeout ? f2 : e5, "[object process]" === {}.toString.call(e5.process) ? r2 = function(e6) {
                t4.nextTick(function() {
                  h2(e6);
                });
              } : function() {
                if (e5.postMessage && !e5.importScripts) {
                  var t5 = true, n5 = e5.onmessage;
                  return e5.onmessage = function() {
                    t5 = false;
                  }, e5.postMessage("", "*"), e5.onmessage = n5, t5;
                }
              }() ? (a2 = "setImmediate$" + Math.random() + "$", u2 = function(t5) {
                t5.source === e5 && "string" == typeof t5.data && 0 === t5.data.indexOf(a2) && h2(+t5.data.slice(a2.length));
              }, e5.addEventListener ? e5.addEventListener("message", u2, false) : e5.attachEvent("onmessage", u2), r2 = function(t5) {
                e5.postMessage(a2 + t5, "*");
              }) : e5.MessageChannel ? ((i2 = new MessageChannel()).port1.onmessage = function(e6) {
                h2(e6.data);
              }, r2 = function(e6) {
                i2.port2.postMessage(e6);
              }) : d2 && "onreadystatechange" in d2.createElement("script") ? (o2 = d2.documentElement, r2 = function(e6) {
                var t5 = d2.createElement("script");
                t5.onreadystatechange = function() {
                  h2(e6), t5.onreadystatechange = null, o2.removeChild(t5), t5 = null;
                }, o2.appendChild(t5);
              }) : r2 = function(e6) {
                setTimeout(h2, 0, e6);
              }, f2.setImmediate = function(e6) {
                "function" != typeof e6 && (e6 = new Function("" + e6));
                for (var t5 = new Array(arguments.length - 1), n5 = 0; n5 < t5.length; n5++)
                  t5[n5] = arguments[n5 + 1];
                var o3 = { callback: e6, args: t5 };
                return s2[c2] = o3, r2(c2), c2++;
              }, f2.clearImmediate = p2;
            }
            function p2(e6) {
              delete s2[e6];
            }
            function h2(e6) {
              if (l2)
                setTimeout(h2, 0, e6);
              else {
                var t5 = s2[e6];
                if (t5) {
                  l2 = true;
                  try {
                    !function(e7) {
                      var t6 = e7.callback, n5 = e7.args;
                      switch (n5.length) {
                        case 0:
                          t6();
                          break;
                        case 1:
                          t6(n5[0]);
                          break;
                        case 2:
                          t6(n5[0], n5[1]);
                          break;
                        case 3:
                          t6(n5[0], n5[1], n5[2]);
                          break;
                        default:
                          t6.apply(void 0, n5);
                      }
                    }(t5);
                  } finally {
                    p2(e6), l2 = false;
                  }
                }
              }
            }
          }("undefined" == typeof self ? void 0 === e4 ? this : e4 : self);
        }).call(this, n3(0), n3(7));
      }, function(e3, t3) {
        var n3, r2, o2 = e3.exports = {};
        function i2() {
          throw new Error("setTimeout has not been defined");
        }
        function a2() {
          throw new Error("clearTimeout has not been defined");
        }
        function u2(e4) {
          if (n3 === setTimeout)
            return setTimeout(e4, 0);
          if ((n3 === i2 || !n3) && setTimeout)
            return n3 = setTimeout, setTimeout(e4, 0);
          try {
            return n3(e4, 0);
          } catch (t4) {
            try {
              return n3.call(null, e4, 0);
            } catch (t5) {
              return n3.call(this, e4, 0);
            }
          }
        }
        !function() {
          try {
            n3 = "function" == typeof setTimeout ? setTimeout : i2;
          } catch (e4) {
            n3 = i2;
          }
          try {
            r2 = "function" == typeof clearTimeout ? clearTimeout : a2;
          } catch (e4) {
            r2 = a2;
          }
        }();
        var c2, s2 = [], l2 = false, d2 = -1;
        function f2() {
          l2 && c2 && (l2 = false, c2.length ? s2 = c2.concat(s2) : d2 = -1, s2.length && p2());
        }
        function p2() {
          if (!l2) {
            var e4 = u2(f2);
            l2 = true;
            for (var t4 = s2.length; t4; ) {
              for (c2 = s2, s2 = []; ++d2 < t4; )
                c2 && c2[d2].run();
              d2 = -1, t4 = s2.length;
            }
            c2 = null, l2 = false, function(e5) {
              if (r2 === clearTimeout)
                return clearTimeout(e5);
              if ((r2 === a2 || !r2) && clearTimeout)
                return r2 = clearTimeout, clearTimeout(e5);
              try {
                r2(e5);
              } catch (t5) {
                try {
                  return r2.call(null, e5);
                } catch (t6) {
                  return r2.call(this, e5);
                }
              }
            }(e4);
          }
        }
        function h2(e4, t4) {
          this.fun = e4, this.array = t4;
        }
        function m2() {
        }
        o2.nextTick = function(e4) {
          var t4 = new Array(arguments.length - 1);
          if (arguments.length > 1)
            for (var n4 = 1; n4 < arguments.length; n4++)
              t4[n4 - 1] = arguments[n4];
          s2.push(new h2(e4, t4)), 1 !== s2.length || l2 || u2(p2);
        }, h2.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, o2.title = "browser", o2.browser = true, o2.env = {}, o2.argv = [], o2.version = "", o2.versions = {}, o2.on = m2, o2.addListener = m2, o2.once = m2, o2.off = m2, o2.removeListener = m2, o2.removeAllListeners = m2, o2.emit = m2, o2.prependListener = m2, o2.prependOnceListener = m2, o2.listeners = function(e4) {
          return [];
        }, o2.binding = function(e4) {
          throw new Error("process.binding is not supported");
        }, o2.cwd = function() {
          return "/";
        }, o2.chdir = function(e4) {
          throw new Error("process.chdir is not supported");
        }, o2.umask = function() {
          return 0;
        };
      }, function(e3, t3, n3) {
        function r2(e4, t4) {
          for (var n4 = 0; n4 < t4.length; n4++) {
            var r3 = t4[n4];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        var o2 = n3(9);
        e3.exports = function() {
          function e4() {
            !function(e5, t5) {
              if (!(e5 instanceof t5))
                throw new TypeError("Cannot call a class as a function");
            }(this, e4);
          }
          var t4, n4;
          return t4 = e4, (n4 = [{ key: "urlEncode", value: function(e5) {
            return o2(e5);
          } }, { key: "jsonEncode", value: function(e5) {
            return JSON.stringify(e5);
          } }, { key: "formEncode", value: function(e5) {
            if (this.isFormData(e5))
              return e5;
            if (this.isFormElement(e5))
              return new FormData(e5);
            if (this.isObject(e5)) {
              var t5 = new FormData();
              return Object.keys(e5).forEach(function(n5) {
                var r3 = e5[n5];
                t5.append(n5, r3);
              }), t5;
            }
            throw new Error("`data` must be an instance of Object, FormData or <FORM> HTMLElement");
          } }, { key: "isObject", value: function(e5) {
            return "[object Object]" === Object.prototype.toString.call(e5);
          } }, { key: "isFormData", value: function(e5) {
            return e5 instanceof FormData;
          } }, { key: "isFormElement", value: function(e5) {
            return e5 instanceof HTMLFormElement;
          } }, { key: "selectFiles", value: function() {
            var e5 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
            return new Promise(function(t5, n5) {
              var r3 = document.createElement("INPUT");
              r3.type = "file", e5.multiple && r3.setAttribute("multiple", "multiple"), e5.accept && r3.setAttribute("accept", e5.accept), r3.style.display = "none", document.body.appendChild(r3), r3.addEventListener("change", function(e6) {
                var n6 = e6.target.files;
                t5(n6), document.body.removeChild(r3);
              }, false), r3.click();
            });
          } }, { key: "parseHeaders", value: function(e5) {
            var t5 = e5.trim().split(/[\r\n]+/), n5 = {};
            return t5.forEach(function(e6) {
              var t6 = e6.split(": "), r3 = t6.shift(), o3 = t6.join(": ");
              r3 && (n5[r3] = o3);
            }), n5;
          } }]) && r2(t4, n4), e4;
        }();
      }, function(e3, t3) {
        var n3 = function(e4) {
          return encodeURIComponent(e4).replace(/[!'()*]/g, escape).replace(/%20/g, "+");
        }, r2 = function(e4, t4, o2, i2) {
          return t4 = t4 || null, o2 = o2 || "&", i2 = i2 || null, e4 ? function(e5) {
            for (var t5 = new Array(), n4 = 0; n4 < e5.length; n4++)
              e5[n4] && t5.push(e5[n4]);
            return t5;
          }(Object.keys(e4).map(function(a2) {
            var u2, c2, s2 = a2;
            if (i2 && (s2 = i2 + "[" + s2 + "]"), "object" == typeof e4[a2] && null !== e4[a2])
              u2 = r2(e4[a2], null, o2, s2);
            else {
              t4 && (c2 = s2, s2 = !isNaN(parseFloat(c2)) && isFinite(c2) ? t4 + Number(s2) : s2);
              var l2 = e4[a2];
              l2 = (l2 = 0 === (l2 = false === (l2 = true === l2 ? "1" : l2) ? "0" : l2) ? "0" : l2) || "", u2 = n3(s2) + "=" + n3(l2);
            }
            return u2;
          })).join(o2).replace(/[!'()*]/g, "") : "";
        };
        e3.exports = r2;
      }]);
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        if (!(e3 instanceof t3))
          throw new TypeError("Cannot call a class as a function");
      };
    }, function(e2, t2, n2) {
      e2.exports = n2(10);
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        (null == t3 || t3 > e3.length) && (t3 = e3.length);
        for (var n2 = 0, r2 = new Array(t3); n2 < t3; n2++)
          r2[n2] = e3[n2];
        return r2;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(4);
      e2.exports = function(e3, t3) {
        if (e3) {
          if ("string" == typeof e3)
            return r2(e3, t3);
          var n3 = Object.prototype.toString.call(e3).slice(8, -1);
          return "Object" === n3 && e3.constructor && (n3 = e3.constructor.name), "Map" === n3 || "Set" === n3 ? Array.from(n3) : "Arguments" === n3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n3) ? r2(e3, t3) : void 0;
        }
      };
    }, function(e2, t2) {
      function n2(e3, t3, n3, r2, o2, i2, a2) {
        try {
          var u2 = e3[i2](a2), c2 = u2.value;
        } catch (e4) {
          return void n3(e4);
        }
        u2.done ? t3(c2) : Promise.resolve(c2).then(r2, o2);
      }
      e2.exports = function(e3) {
        return function() {
          var t3 = this, r2 = arguments;
          return new Promise(function(o2, i2) {
            var a2 = e3.apply(t3, r2);
            function u2(e4) {
              n2(a2, o2, i2, u2, c2, "next", e4);
            }
            function c2(e4) {
              n2(a2, o2, i2, u2, c2, "throw", e4);
            }
            u2(void 0);
          });
        };
      };
    }, function(e2, t2, n2) {
      var r2 = n2(15), o2 = n2(16), i2 = n2(5), a2 = n2(17);
      e2.exports = function(e3) {
        return r2(e3) || o2(e3) || i2(e3) || a2();
      };
    }, function(e2, t2, n2) {
      var r2 = n2(18), o2 = n2(19), i2 = n2(5), a2 = n2(20);
      e2.exports = function(e3, t3) {
        return r2(e3) || o2(e3, t3) || i2(e3, t3) || a2();
      };
    }, function(e2, t2, n2) {
      e2.exports = n2(21);
    }, function(e2, t2, n2) {
      var r2 = function(e3) {
        var t3 = Object.prototype, n3 = t3.hasOwnProperty, r3 = "function" == typeof Symbol ? Symbol : {}, o2 = r3.iterator || "@@iterator", i2 = r3.asyncIterator || "@@asyncIterator", a2 = r3.toStringTag || "@@toStringTag";
        function u2(e4, t4, n4, r4) {
          var o3 = t4 && t4.prototype instanceof l2 ? t4 : l2, i3 = Object.create(o3.prototype), a3 = new _2(r4 || []);
          return i3._invoke = function(e5, t5, n5) {
            var r5 = "suspendedStart";
            return function(o4, i4) {
              if ("executing" === r5)
                throw new Error("Generator is already running");
              if ("completed" === r5) {
                if ("throw" === o4)
                  throw i4;
                return E2();
              }
              for (n5.method = o4, n5.arg = i4; ; ) {
                var a4 = n5.delegate;
                if (a4) {
                  var u3 = b2(a4, n5);
                  if (u3) {
                    if (u3 === s2)
                      continue;
                    return u3;
                  }
                }
                if ("next" === n5.method)
                  n5.sent = n5._sent = n5.arg;
                else if ("throw" === n5.method) {
                  if ("suspendedStart" === r5)
                    throw r5 = "completed", n5.arg;
                  n5.dispatchException(n5.arg);
                } else
                  "return" === n5.method && n5.abrupt("return", n5.arg);
                r5 = "executing";
                var l3 = c2(e5, t5, n5);
                if ("normal" === l3.type) {
                  if (r5 = n5.done ? "completed" : "suspendedYield", l3.arg === s2)
                    continue;
                  return { value: l3.arg, done: n5.done };
                }
                "throw" === l3.type && (r5 = "completed", n5.method = "throw", n5.arg = l3.arg);
              }
            };
          }(e4, n4, a3), i3;
        }
        function c2(e4, t4, n4) {
          try {
            return { type: "normal", arg: e4.call(t4, n4) };
          } catch (e5) {
            return { type: "throw", arg: e5 };
          }
        }
        e3.wrap = u2;
        var s2 = {};
        function l2() {
        }
        function d2() {
        }
        function f2() {
        }
        var p2 = {};
        p2[o2] = function() {
          return this;
        };
        var h2 = Object.getPrototypeOf, m2 = h2 && h2(h2(x2([])));
        m2 && m2 !== t3 && n3.call(m2, o2) && (p2 = m2);
        var g2 = f2.prototype = l2.prototype = Object.create(p2);
        function y2(e4) {
          ["next", "throw", "return"].forEach(function(t4) {
            e4[t4] = function(e5) {
              return this._invoke(t4, e5);
            };
          });
        }
        function v2(e4, t4) {
          var r4;
          this._invoke = function(o3, i3) {
            function a3() {
              return new t4(function(r5, a4) {
                !function r6(o4, i4, a5, u3) {
                  var s3 = c2(e4[o4], e4, i4);
                  if ("throw" !== s3.type) {
                    var l3 = s3.arg, d3 = l3.value;
                    return d3 && "object" == typeof d3 && n3.call(d3, "__await") ? t4.resolve(d3.__await).then(function(e5) {
                      r6("next", e5, a5, u3);
                    }, function(e5) {
                      r6("throw", e5, a5, u3);
                    }) : t4.resolve(d3).then(function(e5) {
                      l3.value = e5, a5(l3);
                    }, function(e5) {
                      return r6("throw", e5, a5, u3);
                    });
                  }
                  u3(s3.arg);
                }(o3, i3, r5, a4);
              });
            }
            return r4 = r4 ? r4.then(a3, a3) : a3();
          };
        }
        function b2(e4, t4) {
          var n4 = e4.iterator[t4.method];
          if (void 0 === n4) {
            if (t4.delegate = null, "throw" === t4.method) {
              if (e4.iterator.return && (t4.method = "return", t4.arg = void 0, b2(e4, t4), "throw" === t4.method))
                return s2;
              t4.method = "throw", t4.arg = new TypeError("The iterator does not provide a 'throw' method");
            }
            return s2;
          }
          var r4 = c2(n4, e4.iterator, t4.arg);
          if ("throw" === r4.type)
            return t4.method = "throw", t4.arg = r4.arg, t4.delegate = null, s2;
          var o3 = r4.arg;
          return o3 ? o3.done ? (t4[e4.resultName] = o3.value, t4.next = e4.nextLoc, "return" !== t4.method && (t4.method = "next", t4.arg = void 0), t4.delegate = null, s2) : o3 : (t4.method = "throw", t4.arg = new TypeError("iterator result is not an object"), t4.delegate = null, s2);
        }
        function w2(e4) {
          var t4 = { tryLoc: e4[0] };
          1 in e4 && (t4.catchLoc = e4[1]), 2 in e4 && (t4.finallyLoc = e4[2], t4.afterLoc = e4[3]), this.tryEntries.push(t4);
        }
        function k2(e4) {
          var t4 = e4.completion || {};
          t4.type = "normal", delete t4.arg, e4.completion = t4;
        }
        function _2(e4) {
          this.tryEntries = [{ tryLoc: "root" }], e4.forEach(w2, this), this.reset(true);
        }
        function x2(e4) {
          if (e4) {
            var t4 = e4[o2];
            if (t4)
              return t4.call(e4);
            if ("function" == typeof e4.next)
              return e4;
            if (!isNaN(e4.length)) {
              var r4 = -1, i3 = function t5() {
                for (; ++r4 < e4.length; )
                  if (n3.call(e4, r4))
                    return t5.value = e4[r4], t5.done = false, t5;
                return t5.value = void 0, t5.done = true, t5;
              };
              return i3.next = i3;
            }
          }
          return { next: E2 };
        }
        function E2() {
          return { value: void 0, done: true };
        }
        return d2.prototype = g2.constructor = f2, f2.constructor = d2, f2[a2] = d2.displayName = "GeneratorFunction", e3.isGeneratorFunction = function(e4) {
          var t4 = "function" == typeof e4 && e4.constructor;
          return !!t4 && (t4 === d2 || "GeneratorFunction" === (t4.displayName || t4.name));
        }, e3.mark = function(e4) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(e4, f2) : (e4.__proto__ = f2, a2 in e4 || (e4[a2] = "GeneratorFunction")), e4.prototype = Object.create(g2), e4;
        }, e3.awrap = function(e4) {
          return { __await: e4 };
        }, y2(v2.prototype), v2.prototype[i2] = function() {
          return this;
        }, e3.AsyncIterator = v2, e3.async = function(t4, n4, r4, o3, i3) {
          void 0 === i3 && (i3 = Promise);
          var a3 = new v2(u2(t4, n4, r4, o3), i3);
          return e3.isGeneratorFunction(n4) ? a3 : a3.next().then(function(e4) {
            return e4.done ? e4.value : a3.next();
          });
        }, y2(g2), g2[a2] = "Generator", g2[o2] = function() {
          return this;
        }, g2.toString = function() {
          return "[object Generator]";
        }, e3.keys = function(e4) {
          var t4 = [];
          for (var n4 in e4)
            t4.push(n4);
          return t4.reverse(), function n5() {
            for (; t4.length; ) {
              var r4 = t4.pop();
              if (r4 in e4)
                return n5.value = r4, n5.done = false, n5;
            }
            return n5.done = true, n5;
          };
        }, e3.values = x2, _2.prototype = { constructor: _2, reset: function(e4) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(k2), !e4)
            for (var t4 in this)
              "t" === t4.charAt(0) && n3.call(this, t4) && !isNaN(+t4.slice(1)) && (this[t4] = void 0);
        }, stop: function() {
          this.done = true;
          var e4 = this.tryEntries[0].completion;
          if ("throw" === e4.type)
            throw e4.arg;
          return this.rval;
        }, dispatchException: function(e4) {
          if (this.done)
            throw e4;
          var t4 = this;
          function r4(n4, r5) {
            return a3.type = "throw", a3.arg = e4, t4.next = n4, r5 && (t4.method = "next", t4.arg = void 0), !!r5;
          }
          for (var o3 = this.tryEntries.length - 1; o3 >= 0; --o3) {
            var i3 = this.tryEntries[o3], a3 = i3.completion;
            if ("root" === i3.tryLoc)
              return r4("end");
            if (i3.tryLoc <= this.prev) {
              var u3 = n3.call(i3, "catchLoc"), c3 = n3.call(i3, "finallyLoc");
              if (u3 && c3) {
                if (this.prev < i3.catchLoc)
                  return r4(i3.catchLoc, true);
                if (this.prev < i3.finallyLoc)
                  return r4(i3.finallyLoc);
              } else if (u3) {
                if (this.prev < i3.catchLoc)
                  return r4(i3.catchLoc, true);
              } else {
                if (!c3)
                  throw new Error("try statement without catch or finally");
                if (this.prev < i3.finallyLoc)
                  return r4(i3.finallyLoc);
              }
            }
          }
        }, abrupt: function(e4, t4) {
          for (var r4 = this.tryEntries.length - 1; r4 >= 0; --r4) {
            var o3 = this.tryEntries[r4];
            if (o3.tryLoc <= this.prev && n3.call(o3, "finallyLoc") && this.prev < o3.finallyLoc) {
              var i3 = o3;
              break;
            }
          }
          i3 && ("break" === e4 || "continue" === e4) && i3.tryLoc <= t4 && t4 <= i3.finallyLoc && (i3 = null);
          var a3 = i3 ? i3.completion : {};
          return a3.type = e4, a3.arg = t4, i3 ? (this.method = "next", this.next = i3.finallyLoc, s2) : this.complete(a3);
        }, complete: function(e4, t4) {
          if ("throw" === e4.type)
            throw e4.arg;
          return "break" === e4.type || "continue" === e4.type ? this.next = e4.arg : "return" === e4.type ? (this.rval = this.arg = e4.arg, this.method = "return", this.next = "end") : "normal" === e4.type && t4 && (this.next = t4), s2;
        }, finish: function(e4) {
          for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
            var n4 = this.tryEntries[t4];
            if (n4.finallyLoc === e4)
              return this.complete(n4.completion, n4.afterLoc), k2(n4), s2;
          }
        }, catch: function(e4) {
          for (var t4 = this.tryEntries.length - 1; t4 >= 0; --t4) {
            var n4 = this.tryEntries[t4];
            if (n4.tryLoc === e4) {
              var r4 = n4.completion;
              if ("throw" === r4.type) {
                var o3 = r4.arg;
                k2(n4);
              }
              return o3;
            }
          }
          throw new Error("illegal catch attempt");
        }, delegateYield: function(e4, t4, n4) {
          return this.delegate = { iterator: x2(e4), resultName: t4, nextLoc: n4 }, "next" === this.method && (this.arg = void 0), s2;
        } }, e3;
      }(e2.exports);
      try {
        regeneratorRuntime = r2;
      } catch (e3) {
        Function("r", "regeneratorRuntime = r")(r2);
      }
    }, function(e2, t2, n2) {
      var r2 = n2(12), o2 = n2(13);
      "string" == typeof (o2 = o2.__esModule ? o2.default : o2) && (o2 = [[e2.i, o2, ""]]);
      var i2 = { insert: "head", singleton: false }, a2 = (r2(o2, i2), o2.locals ? o2.locals : {});
      e2.exports = a2;
    }, function(e2, t2, n2) {
      var r2, o2 = function() {
        return void 0 === r2 && (r2 = Boolean(window && document && document.all && !window.atob)), r2;
      }, i2 = function() {
        var e3 = {};
        return function(t3) {
          if (void 0 === e3[t3]) {
            var n3 = document.querySelector(t3);
            if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)
              try {
                n3 = n3.contentDocument.head;
              } catch (e4) {
                n3 = null;
              }
            e3[t3] = n3;
          }
          return e3[t3];
        };
      }(), a2 = [];
      function u2(e3) {
        for (var t3 = -1, n3 = 0; n3 < a2.length; n3++)
          if (a2[n3].identifier === e3) {
            t3 = n3;
            break;
          }
        return t3;
      }
      function c2(e3, t3) {
        for (var n3 = {}, r3 = [], o3 = 0; o3 < e3.length; o3++) {
          var i3 = e3[o3], c3 = t3.base ? i3[0] + t3.base : i3[0], s3 = n3[c3] || 0, l3 = "".concat(c3, " ").concat(s3);
          n3[c3] = s3 + 1;
          var d3 = u2(l3), f3 = { css: i3[1], media: i3[2], sourceMap: i3[3] };
          -1 !== d3 ? (a2[d3].references++, a2[d3].updater(f3)) : a2.push({ identifier: l3, updater: g2(f3, t3), references: 1 }), r3.push(l3);
        }
        return r3;
      }
      function s2(e3) {
        var t3 = document.createElement("style"), r3 = e3.attributes || {};
        if (void 0 === r3.nonce) {
          var o3 = n2.nc;
          o3 && (r3.nonce = o3);
        }
        if (Object.keys(r3).forEach(function(e4) {
          t3.setAttribute(e4, r3[e4]);
        }), "function" == typeof e3.insert)
          e3.insert(t3);
        else {
          var a3 = i2(e3.insert || "head");
          if (!a3)
            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
          a3.appendChild(t3);
        }
        return t3;
      }
      var l2, d2 = (l2 = [], function(e3, t3) {
        return l2[e3] = t3, l2.filter(Boolean).join("\n");
      });
      function f2(e3, t3, n3, r3) {
        var o3 = n3 ? "" : r3.media ? "@media ".concat(r3.media, " {").concat(r3.css, "}") : r3.css;
        if (e3.styleSheet)
          e3.styleSheet.cssText = d2(t3, o3);
        else {
          var i3 = document.createTextNode(o3), a3 = e3.childNodes;
          a3[t3] && e3.removeChild(a3[t3]), a3.length ? e3.insertBefore(i3, a3[t3]) : e3.appendChild(i3);
        }
      }
      function p2(e3, t3, n3) {
        var r3 = n3.css, o3 = n3.media, i3 = n3.sourceMap;
        if (o3 ? e3.setAttribute("media", o3) : e3.removeAttribute("media"), i3 && btoa && (r3 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i3)))), " */")), e3.styleSheet)
          e3.styleSheet.cssText = r3;
        else {
          for (; e3.firstChild; )
            e3.removeChild(e3.firstChild);
          e3.appendChild(document.createTextNode(r3));
        }
      }
      var h2 = null, m2 = 0;
      function g2(e3, t3) {
        var n3, r3, o3;
        if (t3.singleton) {
          var i3 = m2++;
          n3 = h2 || (h2 = s2(t3)), r3 = f2.bind(null, n3, i3, false), o3 = f2.bind(null, n3, i3, true);
        } else
          n3 = s2(t3), r3 = p2.bind(null, n3, t3), o3 = function() {
            !function(e4) {
              if (null === e4.parentNode)
                return false;
              e4.parentNode.removeChild(e4);
            }(n3);
          };
        return r3(e3), function(t4) {
          if (t4) {
            if (t4.css === e3.css && t4.media === e3.media && t4.sourceMap === e3.sourceMap)
              return;
            r3(e3 = t4);
          } else
            o3();
        };
      }
      e2.exports = function(e3, t3) {
        (t3 = t3 || {}).singleton || "boolean" == typeof t3.singleton || (t3.singleton = o2());
        var n3 = c2(e3 = e3 || [], t3);
        return function(e4) {
          if (e4 = e4 || [], "[object Array]" === Object.prototype.toString.call(e4)) {
            for (var r3 = 0; r3 < n3.length; r3++) {
              var o3 = u2(n3[r3]);
              a2[o3].references--;
            }
            for (var i3 = c2(e4, t3), s3 = 0; s3 < n3.length; s3++) {
              var l3 = u2(n3[s3]);
              0 === a2[l3].references && (a2[l3].updater(), a2.splice(l3, 1));
            }
            n3 = i3;
          }
        };
      };
    }, function(e2, t2, n2) {
      (t2 = n2(14)(false)).push([e2.i, '.image-tool {\n  --bg-color: #cdd1e0;\n  --front-color: #388ae5;\n  --border-color: #e8e8eb;\n\n}\n\n  .image-tool__image {\n    border-radius: 3px;\n    overflow: hidden;\n    margin-bottom: 10px;\n  }\n\n  .image-tool__image-picture {\n      max-width: 100%;\n      vertical-align: bottom;\n      display: block;\n    }\n\n  .image-tool__image-preloader {\n      width: 50px;\n      height: 50px;\n      border-radius: 50%;\n      background-size: cover;\n      margin: auto;\n      position: relative;\n      background-color: var(--bg-color);\n      background-position: center center;\n    }\n\n  .image-tool__image-preloader::after {\n        content: "";\n        position: absolute;\n        z-index: 3;\n        width: 60px;\n        height: 60px;\n        border-radius: 50%;\n        border: 2px solid var(--bg-color);\n        border-top-color: var(--front-color);\n        left: 50%;\n        top: 50%;\n        margin-top: -30px;\n        margin-left: -30px;\n        animation: image-preloader-spin 2s infinite linear;\n        box-sizing: border-box;\n      }\n\n  .image-tool__caption[contentEditable="true"][data-placeholder]::before {\n      position: absolute !important;\n      content: attr(data-placeholder);\n      color: #707684;\n      font-weight: normal;\n      display: none;\n    }\n\n  .image-tool__caption[contentEditable="true"][data-placeholder]:empty::before {\n        display: block;\n      }\n\n  .image-tool__caption[contentEditable="true"][data-placeholder]:empty:focus::before {\n        display: none;\n      }\n\n  .image-tool--empty .image-tool__image {\n      display: none;\n    }\n\n  .image-tool--empty .image-tool__caption, .image-tool--loading .image-tool__caption {\n      display: none;\n    }\n\n  .image-tool .cdx-button {\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n\n  .image-tool .cdx-button svg {\n      height: auto;\n      margin: 0 6px 0 0;\n    }\n\n  .image-tool--filled .cdx-button {\n      display: none;\n    }\n\n  .image-tool--filled .image-tool__image-preloader {\n        display: none;\n      }\n\n  .image-tool--loading .image-tool__image {\n      min-height: 200px;\n      display: flex;\n      border: 1px solid var(--border-color);\n      background-color: #fff;\n    }\n\n  .image-tool--loading .image-tool__image-picture {\n        display: none;\n      }\n\n  .image-tool--loading .cdx-button {\n      display: none;\n    }\n\n  /**\n   * Tunes\n   * ----------------\n   */\n\n  .image-tool--withBorder .image-tool__image {\n      border: 1px solid var(--border-color);\n    }\n\n  .image-tool--withBackground .image-tool__image {\n      padding: 15px;\n      background: var(--bg-color);\n    }\n\n  .image-tool--withBackground .image-tool__image-picture {\n        max-width: 60%;\n        margin: 0 auto;\n      }\n\n  .image-tool--stretched .image-tool__image-picture {\n        width: 100%;\n      }\n\n@keyframes image-preloader-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n', ""]), e2.exports = t2;
    }, function(e2, t2, n2) {
      e2.exports = function(e3) {
        var t3 = [];
        return t3.toString = function() {
          return this.map(function(t4) {
            var n3 = function(e4, t5) {
              var n4 = e4[1] || "", r2 = e4[3];
              if (!r2)
                return n4;
              if (t5 && "function" == typeof btoa) {
                var o2 = (a2 = r2, u2 = btoa(unescape(encodeURIComponent(JSON.stringify(a2)))), c2 = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(u2), "/*# ".concat(c2, " */")), i2 = r2.sources.map(function(e5) {
                  return "/*# sourceURL=".concat(r2.sourceRoot || "").concat(e5, " */");
                });
                return [n4].concat(i2).concat([o2]).join("\n");
              }
              var a2, u2, c2;
              return [n4].join("\n");
            }(t4, e3);
            return t4[2] ? "@media ".concat(t4[2], " {").concat(n3, "}") : n3;
          }).join("");
        }, t3.i = function(e4, n3, r2) {
          "string" == typeof e4 && (e4 = [[null, e4, ""]]);
          var o2 = {};
          if (r2)
            for (var i2 = 0; i2 < this.length; i2++) {
              var a2 = this[i2][0];
              null != a2 && (o2[a2] = true);
            }
          for (var u2 = 0; u2 < e4.length; u2++) {
            var c2 = [].concat(e4[u2]);
            r2 && o2[c2[0]] || (n3 && (c2[2] ? c2[2] = "".concat(n3, " and ").concat(c2[2]) : c2[2] = n3), t3.push(c2));
          }
        }, t3;
      };
    }, function(e2, t2, n2) {
      var r2 = n2(4);
      e2.exports = function(e3) {
        if (Array.isArray(e3))
          return r2(e3);
      };
    }, function(e2, t2) {
      e2.exports = function(e3) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3))
          return Array.from(e3);
      };
    }, function(e2, t2) {
      e2.exports = function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      };
    }, function(e2, t2) {
      e2.exports = function(e3) {
        if (Array.isArray(e3))
          return e3;
      };
    }, function(e2, t2) {
      e2.exports = function(e3, t3) {
        if ("undefined" != typeof Symbol && Symbol.iterator in Object(e3)) {
          var n2 = [], r2 = true, o2 = false, i2 = void 0;
          try {
            for (var a2, u2 = e3[Symbol.iterator](); !(r2 = (a2 = u2.next()).done) && (n2.push(a2.value), !t3 || n2.length !== t3); r2 = true)
              ;
          } catch (e4) {
            o2 = true, i2 = e4;
          } finally {
            try {
              r2 || null == u2.return || u2.return();
            } finally {
              if (o2)
                throw i2;
            }
          }
          return n2;
        }
      };
    }, function(e2, t2) {
      e2.exports = function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      };
    }, function(e2, t2, n2) {
      n2.r(t2), n2.d(t2, "default", function() {
        return _2;
      });
      var r2 = n2(3), o2 = n2.n(r2), i2 = n2(6), a2 = n2.n(i2), u2 = n2(2), c2 = n2.n(u2), s2 = n2(0), l2 = n2.n(s2);
      n2(11);
      const d2 = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><rect width="14" height="14" x="5" y="5" stroke="currentColor" stroke-width="2" rx="4"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5.13968 15.32L8.69058 11.5661C9.02934 11.2036 9.48873 11 9.96774 11C10.4467 11 10.9061 11.2036 11.2449 11.5661L15.3871 16M13.5806 14.0664L15.0132 12.533C15.3519 12.1705 15.8113 11.9668 16.2903 11.9668C16.7693 11.9668 17.2287 12.1705 17.5675 12.533L18.841 13.9634"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.7778 9.33331H13.7867"/></svg>';
      var f2 = n2(7), p2 = n2.n(f2);
      function h2(e3) {
        var t3, n3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null, r3 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, o3 = document.createElement(e3);
        Array.isArray(n3) ? (t3 = o3.classList).add.apply(t3, p2()(n3)) : n3 && o3.classList.add(n3);
        for (var i3 in r3)
          o3[i3] = r3[i3];
        return o3;
      }
      var m2 = function() {
        function e3(t3) {
          var n3 = t3.api, r3 = t3.config, o3 = t3.onSelectFile, i3 = t3.readOnly;
          c2()(this, e3), this.api = n3, this.config = r3, this.onSelectFile = o3, this.readOnly = i3, this.nodes = { wrapper: h2("div", [this.CSS.baseClass, this.CSS.wrapper]), imageContainer: h2("div", [this.CSS.imageContainer]), fileButton: this.createFileButton(), imageEl: void 0, imagePreloader: h2("div", this.CSS.imagePreloader), caption: h2("div", [this.CSS.input, this.CSS.caption], { contentEditable: !this.readOnly }) }, this.nodes.caption.dataset.placeholder = this.config.captionPlaceholder, this.nodes.imageContainer.appendChild(this.nodes.imagePreloader), this.nodes.wrapper.appendChild(this.nodes.imageContainer), this.nodes.wrapper.appendChild(this.nodes.caption), this.nodes.wrapper.appendChild(this.nodes.fileButton);
        }
        return l2()(e3, [{ key: "render", value: function(t3) {
          return t3.file && 0 !== Object.keys(t3.file).length ? this.toggleStatus(e3.status.UPLOADING) : this.toggleStatus(e3.status.EMPTY), this.nodes.wrapper;
        } }, { key: "createFileButton", value: function() {
          var e4 = this, t3 = h2("div", [this.CSS.button]);
          return t3.innerHTML = this.config.buttonContent || "".concat(d2, " ").concat(this.api.i18n.t("Select an Image")), t3.addEventListener("click", function() {
            e4.onSelectFile();
          }), t3;
        } }, { key: "showPreloader", value: function(t3) {
          this.nodes.imagePreloader.style.backgroundImage = "url(".concat(t3, ")"), this.toggleStatus(e3.status.UPLOADING);
        } }, { key: "hidePreloader", value: function() {
          this.nodes.imagePreloader.style.backgroundImage = "", this.toggleStatus(e3.status.EMPTY);
        } }, { key: "fillImage", value: function(t3) {
          var n3 = this, r3 = /\.mp4$/.test(t3) ? "VIDEO" : "IMG", o3 = { src: t3 }, i3 = "load";
          "VIDEO" === r3 && (o3.autoplay = true, o3.loop = true, o3.muted = true, o3.playsinline = true, i3 = "loadeddata"), this.nodes.imageEl = h2(r3, this.CSS.imageEl, o3), this.nodes.imageEl.addEventListener(i3, function() {
            n3.toggleStatus(e3.status.FILLED), n3.nodes.imagePreloader && (n3.nodes.imagePreloader.style.backgroundImage = "");
          }), this.nodes.imageContainer.appendChild(this.nodes.imageEl);
        } }, { key: "fillCaption", value: function(e4) {
          this.nodes.caption && (this.nodes.caption.innerHTML = e4);
        } }, { key: "toggleStatus", value: function(t3) {
          for (var n3 in e3.status)
            Object.prototype.hasOwnProperty.call(e3.status, n3) && this.nodes.wrapper.classList.toggle("".concat(this.CSS.wrapper, "--").concat(e3.status[n3]), t3 === e3.status[n3]);
        } }, { key: "applyTune", value: function(e4, t3) {
          this.nodes.wrapper.classList.toggle("".concat(this.CSS.wrapper, "--").concat(e4), t3);
        } }, { key: "CSS", get: function() {
          return { baseClass: this.api.styles.block, loading: this.api.styles.loader, input: this.api.styles.input, button: this.api.styles.button, wrapper: "image-tool", imageContainer: "image-tool__image", imagePreloader: "image-tool__image-preloader", imageEl: "image-tool__image-picture", caption: "image-tool__caption" };
        } }], [{ key: "status", get: function() {
          return { EMPTY: "empty", UPLOADING: "loading", FILLED: "filled" };
        } }]), e3;
      }(), g2 = n2(8), y2 = n2.n(g2), v2 = n2(1), b2 = n2.n(v2);
      function w2(e3) {
        return e3 && "function" == typeof e3.then;
      }
      var k2 = function() {
        function e3(t3) {
          var n3 = t3.config, r3 = t3.onUpload, o3 = t3.onError;
          c2()(this, e3), this.config = n3, this.onUpload = r3, this.onError = o3;
        }
        return l2()(e3, [{ key: "uploadSelectedFile", value: function(e4) {
          var t3 = this, n3 = e4.onPreview, r3 = function(e5) {
            var t4 = new FileReader();
            t4.readAsDataURL(e5), t4.onload = function(e6) {
              n3(e6.target.result);
            };
          };
          (this.config.uploader && "function" == typeof this.config.uploader.uploadByFile ? b2.a.selectFiles({ accept: this.config.types }).then(function(e5) {
            r3(e5[0]);
            var n4 = t3.config.uploader.uploadByFile(e5[0]);
            return w2(n4) || console.warn("Custom uploader method uploadByFile should return a Promise"), n4;
          }) : b2.a.transport({ url: this.config.endpoints.byFile, data: this.config.additionalRequestData, accept: this.config.types, headers: this.config.additionalRequestHeaders, beforeSend: function(e5) {
            r3(e5[0]);
          }, fieldName: this.config.field }).then(function(e5) {
            return e5.body;
          })).then(function(e5) {
            t3.onUpload(e5);
          }).catch(function(e5) {
            t3.onError(e5);
          });
        } }, { key: "uploadByUrl", value: function(e4) {
          var t3, n3 = this;
          this.config.uploader && "function" == typeof this.config.uploader.uploadByUrl ? w2(t3 = this.config.uploader.uploadByUrl(e4)) || console.warn("Custom uploader method uploadByUrl should return a Promise") : t3 = b2.a.post({ url: this.config.endpoints.byUrl, data: Object.assign({ url: e4 }, this.config.additionalRequestData), type: b2.a.contentType.JSON, headers: this.config.additionalRequestHeaders }).then(function(e5) {
            return e5.body;
          }), t3.then(function(e5) {
            n3.onUpload(e5);
          }).catch(function(e5) {
            n3.onError(e5);
          });
        } }, { key: "uploadByFile", value: function(e4, t3) {
          var n3, r3 = this, o3 = t3.onPreview, i3 = new FileReader();
          if (i3.readAsDataURL(e4), i3.onload = function(e5) {
            o3(e5.target.result);
          }, this.config.uploader && "function" == typeof this.config.uploader.uploadByFile)
            w2(n3 = this.config.uploader.uploadByFile(e4)) || console.warn("Custom uploader method uploadByFile should return a Promise");
          else {
            var a3 = new FormData();
            a3.append(this.config.field, e4), this.config.additionalRequestData && Object.keys(this.config.additionalRequestData).length && Object.entries(this.config.additionalRequestData).forEach(function(e5) {
              var t4 = y2()(e5, 2), n4 = t4[0], r4 = t4[1];
              a3.append(n4, r4);
            }), n3 = b2.a.post({ url: this.config.endpoints.byFile, data: a3, type: b2.a.contentType.JSON, headers: this.config.additionalRequestHeaders }).then(function(e5) {
              return e5.body;
            });
          }
          n3.then(function(e5) {
            r3.onUpload(e5);
          }).catch(function(e5) {
            r3.onError(e5);
          });
        } }]), e3;
      }(), _2 = function() {
        function e3(t4) {
          var n3 = this, r3 = t4.data, o3 = t4.config, i3 = t4.api, a3 = t4.readOnly;
          c2()(this, e3), this.api = i3, this.readOnly = a3, this.config = { endpoints: o3.endpoints || "", additionalRequestData: o3.additionalRequestData || {}, additionalRequestHeaders: o3.additionalRequestHeaders || {}, field: o3.field || "image", types: o3.types || "image/*", captionPlaceholder: this.api.i18n.t(o3.captionPlaceholder || "Caption"), buttonContent: o3.buttonContent || "", uploader: o3.uploader || void 0, actions: o3.actions || [] }, this.uploader = new k2({ config: this.config, onUpload: function(e4) {
            return n3.onUpload(e4);
          }, onError: function(e4) {
            return n3.uploadingFailed(e4);
          } }), this.ui = new m2({ api: i3, config: this.config, onSelectFile: function() {
            n3.uploader.uploadSelectedFile({ onPreview: function(e4) {
              n3.ui.showPreloader(e4);
            } });
          }, readOnly: a3 }), this._data = {}, this.data = r3;
        }
        var t3;
        return l2()(e3, null, [{ key: "isReadOnlySupported", get: function() {
          return true;
        } }, { key: "toolbox", get: function() {
          return { icon: d2, title: "Image" };
        } }, { key: "tunes", get: function() {
          return [{ name: "withBorder", icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.9919 9.5H19.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.5 5H14.5096"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M14.625 5H15C17.2091 5 19 6.79086 19 9V9.375"/><path stroke="currentColor" stroke-width="2" d="M9.375 5L9 5C6.79086 5 5 6.79086 5 9V9.375"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.3725 5H9.38207"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 9.5H5.00957"/><path stroke="currentColor" stroke-width="2" d="M9.375 19H9C6.79086 19 5 17.2091 5 15V14.625"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.3725 19H9.38207"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 14.55H5.00957"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 13V16M16 19V16M19 16H16M16 16H13"/></svg>', title: "With border", toggle: true }, { name: "stretched", icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 9L20 12L17 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 12H20"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 9L4 12L7 15"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12H10"/></svg>', title: "Stretch image", toggle: true }, { name: "withBackground", icon: '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 19V19C9.13623 19 8.20435 19 7.46927 18.6955C6.48915 18.2895 5.71046 17.5108 5.30448 16.5307C5 15.7956 5 14.8638 5 13V12C5 9.19108 5 7.78661 5.67412 6.77772C5.96596 6.34096 6.34096 5.96596 6.77772 5.67412C7.78661 5 9.19108 5 12 5H13.5C14.8956 5 15.5933 5 16.1611 5.17224C17.4395 5.56004 18.44 6.56046 18.8278 7.83886C19 8.40666 19 9.10444 19 10.5V10.5"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16 13V16M16 19V16M19 16H16M16 16H13"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6.5 17.5L17.5 6.5"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M18.9919 10.5H19.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.9919 19H11.0015"/><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13L13 5"/></svg>', title: "With background", toggle: true }];
        } }]), l2()(e3, [{ key: "render", value: function() {
          return this.ui.render(this.data);
        } }, { key: "validate", value: function(e4) {
          return e4.file && e4.file.url;
        } }, { key: "save", value: function() {
          var e4 = this.ui.nodes.caption;
          return this._data.caption = e4.innerHTML, this.data;
        } }, { key: "renderSettings", value: function() {
          var t4 = this;
          return e3.tunes.concat(this.config.actions).map(function(e4) {
            return { icon: e4.icon, label: t4.api.i18n.t(e4.title), name: e4.name, toggle: e4.toggle, isActive: t4.data[e4.name], onActivate: function() {
              "function" != typeof e4.action ? t4.tuneToggled(e4.name) : e4.action(e4.name);
            } };
          });
        } }, { key: "appendCallback", value: function() {
          this.ui.nodes.fileButton.click();
        } }, { key: "onPaste", value: (t3 = a2()(o2.a.mark(function e4(t4) {
          var n3, r3, i3, a3, u3;
          return o2.a.wrap(function(e5) {
            for (; ; )
              switch (e5.prev = e5.next) {
                case 0:
                  e5.t0 = t4.type, e5.next = "tag" === e5.t0 ? 3 : "pattern" === e5.t0 ? 15 : "file" === e5.t0 ? 18 : 21;
                  break;
                case 3:
                  if (n3 = t4.detail.data, !/^blob:/.test(n3.src)) {
                    e5.next = 13;
                    break;
                  }
                  return e5.next = 7, fetch(n3.src);
                case 7:
                  return r3 = e5.sent, e5.next = 10, r3.blob();
                case 10:
                  return i3 = e5.sent, this.uploadFile(i3), e5.abrupt("break", 21);
                case 13:
                  return this.uploadUrl(n3.src), e5.abrupt("break", 21);
                case 15:
                  return a3 = t4.detail.data, this.uploadUrl(a3), e5.abrupt("break", 21);
                case 18:
                  return u3 = t4.detail.file, this.uploadFile(u3), e5.abrupt("break", 21);
                case 21:
                case "end":
                  return e5.stop();
              }
          }, e4, this);
        })), function(e4) {
          return t3.apply(this, arguments);
        }) }, { key: "onUpload", value: function(e4) {
          e4.success && e4.file ? this.image = e4.file : this.uploadingFailed("incorrect response: " + JSON.stringify(e4));
        } }, { key: "uploadingFailed", value: function(e4) {
          console.log("Image Tool: uploading failed because of", e4), this.api.notifier.show({ message: this.api.i18n.t("Couldn’t upload image. Please try another."), style: "error" }), this.ui.hidePreloader();
        } }, { key: "tuneToggled", value: function(e4) {
          this.setTune(e4, !this._data[e4]);
        } }, { key: "setTune", value: function(e4, t4) {
          var n3 = this;
          this._data[e4] = t4, this.ui.applyTune(e4, t4), "stretched" === e4 && Promise.resolve().then(function() {
            var e5 = n3.api.blocks.getCurrentBlockIndex();
            n3.api.blocks.stretchBlock(e5, t4);
          }).catch(function(e5) {
            console.error(e5);
          });
        } }, { key: "uploadFile", value: function(e4) {
          var t4 = this;
          this.uploader.uploadByFile(e4, { onPreview: function(e5) {
            t4.ui.showPreloader(e5);
          } });
        } }, { key: "uploadUrl", value: function(e4) {
          this.ui.showPreloader(e4), this.uploader.uploadByUrl(e4);
        } }, { key: "data", set: function(t4) {
          var n3 = this;
          this.image = t4.file, this._data.caption = t4.caption || "", this.ui.fillCaption(this._data.caption), e3.tunes.forEach(function(e4) {
            var r3 = e4.name, o3 = void 0 !== t4[r3] && (true === t4[r3] || "true" === t4[r3]);
            n3.setTune(r3, o3);
          });
        }, get: function() {
          return this._data;
        } }, { key: "image", set: function(e4) {
          this._data.file = e4 || {}, e4 && e4.url && this.ui.fillImage(e4.url);
        } }], [{ key: "pasteConfig", get: function() {
          return { tags: [{ img: { src: true } }], patterns: { image: /https?:\/\/\S+\.(gif|jpe?g|tiff|png|svg|webp)(\?[a-z0-9=]*)?$/i }, files: { mimeTypes: ["image/*"] } };
        } }]), e3;
      }();
      /**
       * Image Tool for the Editor.js
       *
       * @author CodeX <team@codex.so>
       * @license MIT
       * @see {@link https://github.com/editor-js/image}
       *
       * To developers.
       * To simplify Tool structure, we split it to 4 parts:
       *  1) index.js — main Tool's interface, public API and methods for working with data
       *  2) uploader.js — module that has methods for sending files via AJAX: from device, by URL or File pasting
       *  3) ui.js — module for UI manipulations: render, showing preloader, etc
       *  4) tunes.js — working with Block Tunes: render buttons, handle clicks
       *
       * For debug purposes there is a testing server
       * that can save uploaded files and return a Response {@link UploadResponseFormat}
       *
       *       $ node dev/server.js
       *
       * It will expose 8008 port, so you can pass http://localhost:8008 with the Tools config:
       *
       * image: {
       *   class: ImageTool,
       *   config: {
       *     endpoints: {
       *       byFile: 'http://localhost:8008/uploadFile',
       *       byUrl: 'http://localhost:8008/fetchUrl',
       *     }
       *   },
       * },
       */
    }]).default;
  });
})(bundle$2);
var bundleExports$2 = bundle$2.exports;
const Image = /* @__PURE__ */ getDefaultExportFromCjs(bundleExports$2);
var bundle$1 = { exports: {} };
(function(module, exports) {
  !function(t2, e2) {
    module.exports = e2();
  }(window, function() {
    return function(t2) {
      var e2 = {};
      function n2(r2) {
        if (e2[r2])
          return e2[r2].exports;
        var o2 = e2[r2] = { i: r2, l: false, exports: {} };
        return t2[r2].call(o2.exports, o2, o2.exports, n2), o2.l = true, o2.exports;
      }
      return n2.m = t2, n2.c = e2, n2.d = function(t3, e3, r2) {
        n2.o(t3, e3) || Object.defineProperty(t3, e3, { enumerable: true, get: r2 });
      }, n2.r = function(t3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t3, "__esModule", { value: true });
      }, n2.t = function(t3, e3) {
        if (1 & e3 && (t3 = n2(t3)), 8 & e3)
          return t3;
        if (4 & e3 && "object" == typeof t3 && t3 && t3.__esModule)
          return t3;
        var r2 = /* @__PURE__ */ Object.create(null);
        if (n2.r(r2), Object.defineProperty(r2, "default", { enumerable: true, value: t3 }), 2 & e3 && "string" != typeof t3)
          for (var o2 in t3)
            n2.d(r2, o2, (function(e4) {
              return t3[e4];
            }).bind(null, o2));
        return r2;
      }, n2.n = function(t3) {
        var e3 = t3 && t3.__esModule ? function() {
          return t3.default;
        } : function() {
          return t3;
        };
        return n2.d(e3, "a", e3), e3;
      }, n2.o = function(t3, e3) {
        return Object.prototype.hasOwnProperty.call(t3, e3);
      }, n2.p = "/", n2(n2.s = 5);
    }([function(t2, e2, n2) {
      var r2 = n2(1);
      "string" == typeof r2 && (r2 = [[t2.i, r2, ""]]);
      var o2 = { hmr: true, transform: void 0, insertInto: void 0 };
      n2(3)(r2, o2);
      r2.locals && (t2.exports = r2.locals);
    }, function(t2, e2, n2) {
      (t2.exports = n2(2)(false)).push([t2.i, ".inline-code {\n  background: rgba(250, 239, 240, 0.78);\n  color: #b44437;\n  padding: 3px 4px;\n  border-radius: 5px;\n  margin: 0 1px;\n  font-family: inherit;\n  font-size: 0.86em;\n  font-weight: 500;\n  letter-spacing: 0.3px;\n}\n", ""]);
    }, function(t2, e2) {
      t2.exports = function(t3) {
        var e3 = [];
        return e3.toString = function() {
          return this.map(function(e4) {
            var n2 = function(t4, e5) {
              var n3 = t4[1] || "", r2 = t4[3];
              if (!r2)
                return n3;
              if (e5 && "function" == typeof btoa) {
                var o2 = (s2 = r2, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(s2)))) + " */"), i2 = r2.sources.map(function(t5) {
                  return "/*# sourceURL=" + r2.sourceRoot + t5 + " */";
                });
                return [n3].concat(i2).concat([o2]).join("\n");
              }
              var s2;
              return [n3].join("\n");
            }(e4, t3);
            return e4[2] ? "@media " + e4[2] + "{" + n2 + "}" : n2;
          }).join("");
        }, e3.i = function(t4, n2) {
          "string" == typeof t4 && (t4 = [[null, t4, ""]]);
          for (var r2 = {}, o2 = 0; o2 < this.length; o2++) {
            var i2 = this[o2][0];
            "number" == typeof i2 && (r2[i2] = true);
          }
          for (o2 = 0; o2 < t4.length; o2++) {
            var s2 = t4[o2];
            "number" == typeof s2[0] && r2[s2[0]] || (n2 && !s2[2] ? s2[2] = n2 : n2 && (s2[2] = "(" + s2[2] + ") and (" + n2 + ")"), e3.push(s2));
          }
        }, e3;
      };
    }, function(t2, e2, n2) {
      var r2, o2, i2 = {}, s2 = (r2 = function() {
        return window && document && document.all && !window.atob;
      }, function() {
        return void 0 === o2 && (o2 = r2.apply(this, arguments)), o2;
      }), a2 = function(t3) {
        var e3 = {};
        return function(t4) {
          if ("function" == typeof t4)
            return t4();
          if (void 0 === e3[t4]) {
            var n3 = (function(t5) {
              return document.querySelector(t5);
            }).call(this, t4);
            if (window.HTMLIFrameElement && n3 instanceof window.HTMLIFrameElement)
              try {
                n3 = n3.contentDocument.head;
              } catch (t5) {
                n3 = null;
              }
            e3[t4] = n3;
          }
          return e3[t4];
        };
      }(), u2 = null, c2 = 0, f2 = [], l2 = n2(4);
      function p2(t3, e3) {
        for (var n3 = 0; n3 < t3.length; n3++) {
          var r3 = t3[n3], o3 = i2[r3.id];
          if (o3) {
            o3.refs++;
            for (var s3 = 0; s3 < o3.parts.length; s3++)
              o3.parts[s3](r3.parts[s3]);
            for (; s3 < r3.parts.length; s3++)
              o3.parts.push(g2(r3.parts[s3], e3));
          } else {
            var a3 = [];
            for (s3 = 0; s3 < r3.parts.length; s3++)
              a3.push(g2(r3.parts[s3], e3));
            i2[r3.id] = { id: r3.id, refs: 1, parts: a3 };
          }
        }
      }
      function d2(t3, e3) {
        for (var n3 = [], r3 = {}, o3 = 0; o3 < t3.length; o3++) {
          var i3 = t3[o3], s3 = e3.base ? i3[0] + e3.base : i3[0], a3 = { css: i3[1], media: i3[2], sourceMap: i3[3] };
          r3[s3] ? r3[s3].parts.push(a3) : n3.push(r3[s3] = { id: s3, parts: [a3] });
        }
        return n3;
      }
      function h2(t3, e3) {
        var n3 = a2(t3.insertInto);
        if (!n3)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        var r3 = f2[f2.length - 1];
        if ("top" === t3.insertAt)
          r3 ? r3.nextSibling ? n3.insertBefore(e3, r3.nextSibling) : n3.appendChild(e3) : n3.insertBefore(e3, n3.firstChild), f2.push(e3);
        else if ("bottom" === t3.insertAt)
          n3.appendChild(e3);
        else {
          if ("object" != typeof t3.insertAt || !t3.insertAt.before)
            throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
          var o3 = a2(t3.insertInto + " " + t3.insertAt.before);
          n3.insertBefore(e3, o3);
        }
      }
      function v2(t3) {
        if (null === t3.parentNode)
          return false;
        t3.parentNode.removeChild(t3);
        var e3 = f2.indexOf(t3);
        e3 >= 0 && f2.splice(e3, 1);
      }
      function b2(t3) {
        var e3 = document.createElement("style");
        return void 0 === t3.attrs.type && (t3.attrs.type = "text/css"), y2(e3, t3.attrs), h2(t3, e3), e3;
      }
      function y2(t3, e3) {
        Object.keys(e3).forEach(function(n3) {
          t3.setAttribute(n3, e3[n3]);
        });
      }
      function g2(t3, e3) {
        var n3, r3, o3, i3;
        if (e3.transform && t3.css) {
          if (!(i3 = e3.transform(t3.css)))
            return function() {
            };
          t3.css = i3;
        }
        if (e3.singleton) {
          var s3 = c2++;
          n3 = u2 || (u2 = b2(e3)), r3 = x2.bind(null, n3, s3, false), o3 = x2.bind(null, n3, s3, true);
        } else
          t3.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (n3 = function(t4) {
            var e4 = document.createElement("link");
            return void 0 === t4.attrs.type && (t4.attrs.type = "text/css"), t4.attrs.rel = "stylesheet", y2(e4, t4.attrs), h2(t4, e4), e4;
          }(e3), r3 = (function(t4, e4, n4) {
            var r4 = n4.css, o4 = n4.sourceMap, i4 = void 0 === e4.convertToAbsoluteUrls && o4;
            (e4.convertToAbsoluteUrls || i4) && (r4 = l2(r4));
            o4 && (r4 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(o4)))) + " */");
            var s4 = new Blob([r4], { type: "text/css" }), a3 = t4.href;
            t4.href = URL.createObjectURL(s4), a3 && URL.revokeObjectURL(a3);
          }).bind(null, n3, e3), o3 = function() {
            v2(n3), n3.href && URL.revokeObjectURL(n3.href);
          }) : (n3 = b2(e3), r3 = (function(t4, e4) {
            var n4 = e4.css, r4 = e4.media;
            r4 && t4.setAttribute("media", r4);
            if (t4.styleSheet)
              t4.styleSheet.cssText = n4;
            else {
              for (; t4.firstChild; )
                t4.removeChild(t4.firstChild);
              t4.appendChild(document.createTextNode(n4));
            }
          }).bind(null, n3), o3 = function() {
            v2(n3);
          });
        return r3(t3), function(e4) {
          if (e4) {
            if (e4.css === t3.css && e4.media === t3.media && e4.sourceMap === t3.sourceMap)
              return;
            r3(t3 = e4);
          } else
            o3();
        };
      }
      t2.exports = function(t3, e3) {
        if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document)
          throw new Error("The style-loader cannot be used in a non-browser environment");
        (e3 = e3 || {}).attrs = "object" == typeof e3.attrs ? e3.attrs : {}, e3.singleton || "boolean" == typeof e3.singleton || (e3.singleton = s2()), e3.insertInto || (e3.insertInto = "head"), e3.insertAt || (e3.insertAt = "bottom");
        var n3 = d2(t3, e3);
        return p2(n3, e3), function(t4) {
          for (var r3 = [], o3 = 0; o3 < n3.length; o3++) {
            var s3 = n3[o3];
            (a3 = i2[s3.id]).refs--, r3.push(a3);
          }
          t4 && p2(d2(t4, e3), e3);
          for (o3 = 0; o3 < r3.length; o3++) {
            var a3;
            if (0 === (a3 = r3[o3]).refs) {
              for (var u3 = 0; u3 < a3.parts.length; u3++)
                a3.parts[u3]();
              delete i2[a3.id];
            }
          }
        };
      };
      var m2, w2 = (m2 = [], function(t3, e3) {
        return m2[t3] = e3, m2.filter(Boolean).join("\n");
      });
      function x2(t3, e3, n3, r3) {
        var o3 = n3 ? "" : r3.css;
        if (t3.styleSheet)
          t3.styleSheet.cssText = w2(e3, o3);
        else {
          var i3 = document.createTextNode(o3), s3 = t3.childNodes;
          s3[e3] && t3.removeChild(s3[e3]), s3.length ? t3.insertBefore(i3, s3[e3]) : t3.appendChild(i3);
        }
      }
    }, function(t2, e2) {
      t2.exports = function(t3) {
        var e3 = "undefined" != typeof window && window.location;
        if (!e3)
          throw new Error("fixUrls requires window.location");
        if (!t3 || "string" != typeof t3)
          return t3;
        var n2 = e3.protocol + "//" + e3.host, r2 = n2 + e3.pathname.replace(/\/[^\/]*$/, "/");
        return t3.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(t4, e4) {
          var o2, i2 = e4.trim().replace(/^"(.*)"$/, function(t5, e5) {
            return e5;
          }).replace(/^'(.*)'$/, function(t5, e5) {
            return e5;
          });
          return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(i2) ? t4 : (o2 = 0 === i2.indexOf("//") ? i2 : 0 === i2.indexOf("/") ? n2 + i2 : r2 + i2.replace(/^\.\//, ""), "url(" + JSON.stringify(o2) + ")");
        });
      };
    }, function(t2, e2, n2) {
      n2.r(e2);
      n2(0);
      function r2(t3, e3) {
        for (var n3 = 0; n3 < e3.length; n3++) {
          var r3 = e3[n3];
          r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(t3, r3.key, r3);
        }
      }
      function o2(t3, e3, n3) {
        return e3 && r2(t3.prototype, e3), n3 && r2(t3, n3), t3;
      }
      n2.d(e2, "default", function() {
        return i2;
      });
      var i2 = function() {
        function t3(e3) {
          var n3 = e3.api;
          !function(t4, e4) {
            if (!(t4 instanceof e4))
              throw new TypeError("Cannot call a class as a function");
          }(this, t3), this.api = n3, this.button = null, this.tag = "CODE", this.iconClasses = { base: this.api.styles.inlineToolButton, active: this.api.styles.inlineToolButtonActive };
        }
        return o2(t3, null, [{ key: "CSS", get: function() {
          return "inline-code";
        } }]), o2(t3, [{ key: "render", value: function() {
          return this.button = document.createElement("button"), this.button.type = "button", this.button.classList.add(this.iconClasses.base), this.button.innerHTML = this.toolboxIcon, this.button;
        } }, { key: "surround", value: function(e3) {
          if (e3) {
            var n3 = this.api.selection.findParentTag(this.tag, t3.CSS);
            n3 ? this.unwrap(n3) : this.wrap(e3);
          }
        } }, { key: "wrap", value: function(e3) {
          var n3 = document.createElement(this.tag);
          n3.classList.add(t3.CSS), n3.appendChild(e3.extractContents()), e3.insertNode(n3), this.api.selection.expandToTag(n3);
        } }, { key: "unwrap", value: function(t4) {
          this.api.selection.expandToTag(t4);
          var e3 = window.getSelection(), n3 = e3.getRangeAt(0), r3 = n3.extractContents();
          t4.parentNode.removeChild(t4), n3.insertNode(r3), e3.removeAllRanges(), e3.addRange(n3);
        } }, { key: "checkState", value: function() {
          var e3 = this.api.selection.findParentTag(this.tag, t3.CSS);
          this.button.classList.toggle(this.iconClasses.active, !!e3);
        } }, { key: "toolboxIcon", get: function() {
          return '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M9.5 8L6.11524 11.8683C6.04926 11.9437 6.04926 12.0563 6.11524 12.1317L9.5 16"/><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M15 8L18.3848 11.8683C18.4507 11.9437 18.4507 12.0563 18.3848 12.1317L15 16"/></svg>';
        } }], [{ key: "isInline", get: function() {
          return true;
        } }, { key: "sanitize", get: function() {
          return { code: { class: t3.CSS } };
        } }]), t3;
      }();
    }]).default;
  });
})(bundle$1);
var bundleExports$1 = bundle$1.exports;
const InlineCode = /* @__PURE__ */ getDefaultExportFromCjs(bundleExports$1);
var main = { exports: {} };
/*! For license information please see main.js.LICENSE.txt */
(function(module, exports) {
  !function(e2, t2) {
    module.exports = t2();
  }(self, function() {
    return (() => {
      var e2 = { 150: (e3, t3, n3) => {
        n3.d(t3, { Z: () => a2 });
        var r3 = n3(645), i2 = n3.n(r3)()(function(e4) {
          return e4[1];
        });
        i2.push([e3.id, ".block-wrapper {\n    padding: 20px 0;\n}\n\n.block-wrapper  input {\n    width: 100%;\n    padding: 10px;\n    border: 1px solid #e4e4e4;\n    border-radius: 3px;\n    outline: none;\n    font-size: 14px;\n}\n\n.video-wrapper {\n    position: relative;\n    padding-bottom: 56.25%; /* 16:9 */\n    height: 0;\n}\n\n.video-wrapper iframe {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    border: 0px;\n}\n\ninput.invalid {\n    border: 1px solid #eb5959cc;\n}", ""]);
        const a2 = i2;
      }, 645: (e3) => {
        e3.exports = function(e4) {
          var t3 = [];
          return t3.toString = function() {
            return this.map(function(t4) {
              var n3 = e4(t4);
              return t4[2] ? "@media ".concat(t4[2], " {").concat(n3, "}") : n3;
            }).join("");
          }, t3.i = function(e5, n3, r3) {
            "string" == typeof e5 && (e5 = [[null, e5, ""]]);
            var i2 = {};
            if (r3)
              for (var a2 = 0; a2 < this.length; a2++) {
                var o2 = this[a2][0];
                null != o2 && (i2[o2] = true);
              }
            for (var u2 = 0; u2 < e5.length; u2++) {
              var s2 = [].concat(e5[u2]);
              r3 && i2[s2[0]] || (n3 && (s2[2] ? s2[2] = "".concat(n3, " and ").concat(s2[2]) : s2[2] = n3), t3.push(s2));
            }
          }, t3;
        };
      }, 379: (e3, t3, n3) => {
        var r3, i2 = function() {
          var e4 = {};
          return function(t4) {
            if (void 0 === e4[t4]) {
              var n4 = document.querySelector(t4);
              if (window.HTMLIFrameElement && n4 instanceof window.HTMLIFrameElement)
                try {
                  n4 = n4.contentDocument.head;
                } catch (e5) {
                  n4 = null;
                }
              e4[t4] = n4;
            }
            return e4[t4];
          };
        }(), a2 = [];
        function o2(e4) {
          for (var t4 = -1, n4 = 0; n4 < a2.length; n4++)
            if (a2[n4].identifier === e4) {
              t4 = n4;
              break;
            }
          return t4;
        }
        function u2(e4, t4) {
          for (var n4 = {}, r4 = [], i3 = 0; i3 < e4.length; i3++) {
            var u3 = e4[i3], s3 = t4.base ? u3[0] + t4.base : u3[0], l3 = n4[s3] || 0, c3 = "".concat(s3, " ").concat(l3);
            n4[s3] = l3 + 1;
            var d3 = o2(c3), p3 = { css: u3[1], media: u3[2], sourceMap: u3[3] };
            -1 !== d3 ? (a2[d3].references++, a2[d3].updater(p3)) : a2.push({ identifier: c3, updater: h2(p3, t4), references: 1 }), r4.push(c3);
          }
          return r4;
        }
        function s2(e4) {
          var t4 = document.createElement("style"), r4 = e4.attributes || {};
          if (void 0 === r4.nonce) {
            var a3 = n3.nc;
            a3 && (r4.nonce = a3);
          }
          if (Object.keys(r4).forEach(function(e5) {
            t4.setAttribute(e5, r4[e5]);
          }), "function" == typeof e4.insert)
            e4.insert(t4);
          else {
            var o3 = i2(e4.insert || "head");
            if (!o3)
              throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
            o3.appendChild(t4);
          }
          return t4;
        }
        var l2, c2 = (l2 = [], function(e4, t4) {
          return l2[e4] = t4, l2.filter(Boolean).join("\n");
        });
        function d2(e4, t4, n4, r4) {
          var i3 = n4 ? "" : r4.media ? "@media ".concat(r4.media, " {").concat(r4.css, "}") : r4.css;
          if (e4.styleSheet)
            e4.styleSheet.cssText = c2(t4, i3);
          else {
            var a3 = document.createTextNode(i3), o3 = e4.childNodes;
            o3[t4] && e4.removeChild(o3[t4]), o3.length ? e4.insertBefore(a3, o3[t4]) : e4.appendChild(a3);
          }
        }
        function p2(e4, t4, n4) {
          var r4 = n4.css, i3 = n4.media, a3 = n4.sourceMap;
          if (i3 ? e4.setAttribute("media", i3) : e4.removeAttribute("media"), a3 && "undefined" != typeof btoa && (r4 += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a3)))), " */")), e4.styleSheet)
            e4.styleSheet.cssText = r4;
          else {
            for (; e4.firstChild; )
              e4.removeChild(e4.firstChild);
            e4.appendChild(document.createTextNode(r4));
          }
        }
        var f2 = null, v2 = 0;
        function h2(e4, t4) {
          var n4, r4, i3;
          if (t4.singleton) {
            var a3 = v2++;
            n4 = f2 || (f2 = s2(t4)), r4 = d2.bind(null, n4, a3, false), i3 = d2.bind(null, n4, a3, true);
          } else
            n4 = s2(t4), r4 = p2.bind(null, n4, t4), i3 = function() {
              !function(e5) {
                if (null === e5.parentNode)
                  return false;
                e5.parentNode.removeChild(e5);
              }(n4);
            };
          return r4(e4), function(t5) {
            if (t5) {
              if (t5.css === e4.css && t5.media === e4.media && t5.sourceMap === e4.sourceMap)
                return;
              r4(e4 = t5);
            } else
              i3();
          };
        }
        e3.exports = function(e4, t4) {
          (t4 = t4 || {}).singleton || "boolean" == typeof t4.singleton || (t4.singleton = (void 0 === r3 && (r3 = Boolean(window && document && document.all && !window.atob)), r3));
          var n4 = u2(e4 = e4 || [], t4);
          return function(e5) {
            if (e5 = e5 || [], "[object Array]" === Object.prototype.toString.call(e5)) {
              for (var r4 = 0; r4 < n4.length; r4++) {
                var i3 = o2(n4[r4]);
                a2[i3].references--;
              }
              for (var s3 = u2(e5, t4), l3 = 0; l3 < n4.length; l3++) {
                var c3 = o2(n4[l3]);
                0 === a2[c3].references && (a2[c3].updater(), a2.splice(c3, 1));
              }
              n4 = s3;
            }
          };
        };
      }, 884: (e3) => {
        e3.exports = '<svg xmlns="http://www.w3.org/2000/svg" height="20" width="30" viewBox="-35.20005 -41.33325 305.0671 247.9995"><path d="M229.763 25.817c-2.699-10.162-10.65-18.165-20.748-20.881C190.716 0 117.333 0 117.333 0S43.951 0 25.651 4.936C15.553 7.652 7.6 15.655 4.903 25.817 0 44.236 0 82.667 0 82.667s0 38.429 4.903 56.85C7.6 149.68 15.553 157.681 25.65 160.4c18.3 4.934 91.682 4.934 91.682 4.934s73.383 0 91.682-4.934c10.098-2.718 18.049-10.72 20.748-20.882 4.904-18.421 4.904-56.85 4.904-56.85s0-38.431-4.904-56.85" fill="red"></path><path d="M93.333 117.559l61.333-34.89-61.333-34.894z" fill="#fff"></path></svg>';
      } }, t2 = {};
      function n2(r3) {
        var i2 = t2[r3];
        if (void 0 !== i2)
          return i2.exports;
        var a2 = t2[r3] = { id: r3, exports: {} };
        return e2[r3](a2, a2.exports, n2), a2.exports;
      }
      n2.n = (e3) => {
        var t3 = e3 && e3.__esModule ? () => e3.default : () => e3;
        return n2.d(t3, { a: t3 }), t3;
      }, n2.d = (e3, t3) => {
        for (var r3 in t3)
          n2.o(t3, r3) && !n2.o(e3, r3) && Object.defineProperty(e3, r3, { enumerable: true, get: t3[r3] });
      }, n2.o = (e3, t3) => Object.prototype.hasOwnProperty.call(e3, t3), n2.r = (e3) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      };
      var r2 = {};
      return (() => {
        n2.r(r2), n2.d(r2, { default: () => s2 });
        var e3 = n2(379), t3 = n2.n(e3), i2 = n2(150);
        t3()(i2.Z, { insert: "head", singleton: false }), i2.Z.locals;
        var a2 = n2(884), o2 = n2.n(a2);
        function u2(e4, t4) {
          for (var n3 = 0; n3 < t4.length; n3++) {
            var r3 = t4[n3];
            r3.enumerable = r3.enumerable || false, r3.configurable = true, "value" in r3 && (r3.writable = true), Object.defineProperty(e4, r3.key, r3);
          }
        }
        var s2 = function() {
          function e4(t5) {
            var n4 = t5.data, r4 = (t5.config, t5.api, t5.readOnly);
            !function(e5, t6) {
              if (!(e5 instanceof t6))
                throw new TypeError("Cannot call a class as a function");
            }(this, e4), this.data = n4, this.readOnly = r4, this.wrapper = null, this.url = null, this.isEdited = false;
          }
          var t4, n3, r3;
          return t4 = e4, r3 = [{ key: "toolbox", get: function() {
            return { title: "YouTube", icon: o2() };
          } }, { key: "isReadOnlySupported", get: function() {
            return true;
          } }], (n3 = [{ key: "render", value: function() {
            var e5 = this;
            this.wrapper = document.createElement("div");
            var t5 = document.createElement("input");
            return t5.value = this.data && this.data.url ? this.data.url : "", this.url = t5.value, t5.placeholder = "Paste YouTube url here...", this.wrapper.classList.add("block-wrapper"), this.wrapper.appendChild(t5), this._createIframe(t5.value), t5.addEventListener("change", function(n4) {
              e5.isEdited = true, e5.url = t5.value, e5._createIframe(t5.value);
            }), this.wrapper;
          } }, { key: "_createIframe", value: function(e5) {
            var t5 = e5.match(new RegExp("(?<=v=)[a-zA-Z0-9_]+(?=\\&?)"));
            if (null != t5) {
              this.wrapper.innerHTML = null;
              var n4 = document.createElement("div");
              n4.classList.add("video-wrapper");
              var r4 = document.createElement("iframe");
              r4.setAttribute("src", "https://www.youtube.com/embed/".concat(t5)), r4.setAttribute("allowfullscreen", true), n4.appendChild(r4), this.wrapper.appendChild(n4);
            } else
              this.isEdited && this.wrapper.querySelector("input").classList.add("invalid");
          } }, { key: "save", value: function(e5) {
            return e5.querySelector("input"), { url: this.url };
          } }]) && u2(t4.prototype, n3), r3 && u2(t4, r3), e4;
        }();
      })(), r2;
    })();
  });
})(main);
var mainExports = main.exports;
const Youtube = /* @__PURE__ */ getDefaultExportFromCjs(mainExports);
var bundle = { exports: {} };
(function(module, exports) {
  !function(e2, l2) {
    module.exports = l2();
  }(window, function() {
    return function(e2) {
      var l2 = {};
      function a2(_2) {
        if (l2[_2])
          return l2[_2].exports;
        var t2 = l2[_2] = { i: _2, l: false, exports: {} };
        return e2[_2].call(t2.exports, t2, t2.exports, a2), t2.l = true, t2.exports;
      }
      return a2.m = e2, a2.c = l2, a2.d = function(e3, l3, _2) {
        a2.o(e3, l3) || Object.defineProperty(e3, l3, { enumerable: true, get: _2 });
      }, a2.r = function(e3) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e3, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e3, "__esModule", { value: true });
      }, a2.t = function(e3, l3) {
        if (1 & l3 && (e3 = a2(e3)), 8 & l3)
          return e3;
        if (4 & l3 && "object" == typeof e3 && e3 && e3.__esModule)
          return e3;
        var _2 = /* @__PURE__ */ Object.create(null);
        if (a2.r(_2), Object.defineProperty(_2, "default", { enumerable: true, value: e3 }), 2 & l3 && "string" != typeof e3)
          for (var t2 in e3)
            a2.d(_2, t2, (function(l4) {
              return e3[l4];
            }).bind(null, t2));
        return _2;
      }, a2.n = function(e3) {
        var l3 = e3 && e3.__esModule ? function() {
          return e3.default;
        } : function() {
          return e3;
        };
        return a2.d(l3, "a", l3), l3;
      }, a2.o = function(e3, l3) {
        return Object.prototype.hasOwnProperty.call(e3, l3);
      }, a2.p = "", a2(a2.s = 2);
    }([function(e2, l2) {
      e2.exports = function(e3) {
        var l3 = [];
        return l3.toString = function() {
          return this.map(function(l4) {
            var a2 = function(e4, l5) {
              var a3 = e4[1] || "", _2 = e4[3];
              if (!_2)
                return a3;
              if (l5 && "function" == typeof btoa) {
                var t2 = (o2 = _2, "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(o2)))) + " */"), r2 = _2.sources.map(function(e5) {
                  return "/*# sourceURL=" + _2.sourceRoot + e5 + " */";
                });
                return [a3].concat(r2).concat([t2]).join("\n");
              }
              var o2;
              return [a3].join("\n");
            }(l4, e3);
            return l4[2] ? "@media " + l4[2] + "{" + a2 + "}" : a2;
          }).join("");
        }, l3.i = function(e4, a2) {
          "string" == typeof e4 && (e4 = [[null, e4, ""]]);
          for (var _2 = {}, t2 = 0; t2 < this.length; t2++) {
            var r2 = this[t2][0];
            "number" == typeof r2 && (_2[r2] = true);
          }
          for (t2 = 0; t2 < e4.length; t2++) {
            var o2 = e4[t2];
            "number" == typeof o2[0] && _2[o2[0]] || (a2 && !o2[2] ? o2[2] = a2 : a2 && (o2[2] = "(" + o2[2] + ") and (" + a2 + ")"), l3.push(o2));
          }
        }, l3;
      };
    }, function(e2, l2, a2) {
      var _2, t2, r2 = {}, o2 = (_2 = function() {
        return window && document && document.all && !window.atob;
      }, function() {
        return void 0 === t2 && (t2 = _2.apply(this, arguments)), t2;
      }), s2 = function(e3, l3) {
        return l3 ? l3.querySelector(e3) : document.querySelector(e3);
      }, c2 = function(e3) {
        var l3 = {};
        return function(e4, a3) {
          if ("function" == typeof e4)
            return e4();
          if (void 0 === l3[e4]) {
            var _3 = s2.call(this, e4, a3);
            if (window.HTMLIFrameElement && _3 instanceof window.HTMLIFrameElement)
              try {
                _3 = _3.contentDocument.head;
              } catch (e5) {
                _3 = null;
              }
            l3[e4] = _3;
          }
          return l3[e4];
        };
      }(), d2 = null, h2 = 0, n2 = [], i2 = a2(5);
      function v2(e3, l3) {
        for (var a3 = 0; a3 < e3.length; a3++) {
          var _3 = e3[a3], t3 = r2[_3.id];
          if (t3) {
            t3.refs++;
            for (var o3 = 0; o3 < t3.parts.length; o3++)
              t3.parts[o3](_3.parts[o3]);
            for (; o3 < _3.parts.length; o3++)
              t3.parts.push(b2(_3.parts[o3], l3));
          } else {
            var s3 = [];
            for (o3 = 0; o3 < _3.parts.length; o3++)
              s3.push(b2(_3.parts[o3], l3));
            r2[_3.id] = { id: _3.id, refs: 1, parts: s3 };
          }
        }
      }
      function w2(e3, l3) {
        for (var a3 = [], _3 = {}, t3 = 0; t3 < e3.length; t3++) {
          var r3 = e3[t3], o3 = l3.base ? r3[0] + l3.base : r3[0], s3 = { css: r3[1], media: r3[2], sourceMap: r3[3] };
          _3[o3] ? _3[o3].parts.push(s3) : a3.push(_3[o3] = { id: o3, parts: [s3] });
        }
        return a3;
      }
      function C2(e3, l3) {
        var a3 = c2(e3.insertInto);
        if (!a3)
          throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
        var _3 = n2[n2.length - 1];
        if ("top" === e3.insertAt)
          _3 ? _3.nextSibling ? a3.insertBefore(l3, _3.nextSibling) : a3.appendChild(l3) : a3.insertBefore(l3, a3.firstChild), n2.push(l3);
        else if ("bottom" === e3.insertAt)
          a3.appendChild(l3);
        else {
          if ("object" != typeof e3.insertAt || !e3.insertAt.before)
            throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
          var t3 = c2(e3.insertAt.before, a3);
          a3.insertBefore(l3, t3);
        }
      }
      function u2(e3) {
        if (null === e3.parentNode)
          return false;
        e3.parentNode.removeChild(e3);
        var l3 = n2.indexOf(e3);
        l3 >= 0 && n2.splice(l3, 1);
      }
      function f2(e3) {
        var l3 = document.createElement("style");
        if (void 0 === e3.attrs.type && (e3.attrs.type = "text/css"), void 0 === e3.attrs.nonce) {
          var _3 = function() {
            return a2.nc;
          }();
          _3 && (e3.attrs.nonce = _3);
        }
        return p2(l3, e3.attrs), C2(e3, l3), l3;
      }
      function p2(e3, l3) {
        Object.keys(l3).forEach(function(a3) {
          e3.setAttribute(a3, l3[a3]);
        });
      }
      function b2(e3, l3) {
        var a3, _3, t3, r3;
        if (l3.transform && e3.css) {
          if (!(r3 = "function" == typeof l3.transform ? l3.transform(e3.css) : l3.transform.default(e3.css)))
            return function() {
            };
          e3.css = r3;
        }
        if (l3.singleton) {
          var o3 = h2++;
          a3 = d2 || (d2 = f2(l3)), _3 = y2.bind(null, a3, o3, false), t3 = y2.bind(null, a3, o3, true);
        } else
          e3.sourceMap && "function" == typeof URL && "function" == typeof URL.createObjectURL && "function" == typeof URL.revokeObjectURL && "function" == typeof Blob && "function" == typeof btoa ? (a3 = function(e4) {
            var l4 = document.createElement("link");
            return void 0 === e4.attrs.type && (e4.attrs.type = "text/css"), e4.attrs.rel = "stylesheet", p2(l4, e4.attrs), C2(e4, l4), l4;
          }(l3), _3 = M2.bind(null, a3, l3), t3 = function() {
            u2(a3), a3.href && URL.revokeObjectURL(a3.href);
          }) : (a3 = f2(l3), _3 = x2.bind(null, a3), t3 = function() {
            u2(a3);
          });
        return _3(e3), function(l4) {
          if (l4) {
            if (l4.css === e3.css && l4.media === e3.media && l4.sourceMap === e3.sourceMap)
              return;
            _3(e3 = l4);
          } else
            t3();
        };
      }
      e2.exports = function(e3, l3) {
        if ("undefined" != typeof DEBUG && DEBUG && "object" != typeof document)
          throw new Error("The style-loader cannot be used in a non-browser environment");
        (l3 = l3 || {}).attrs = "object" == typeof l3.attrs ? l3.attrs : {}, l3.singleton || "boolean" == typeof l3.singleton || (l3.singleton = o2()), l3.insertInto || (l3.insertInto = "head"), l3.insertAt || (l3.insertAt = "bottom");
        var a3 = w2(e3, l3);
        return v2(a3, l3), function(e4) {
          for (var _3 = [], t3 = 0; t3 < a3.length; t3++) {
            var o3 = a3[t3];
            (s3 = r2[o3.id]).refs--, _3.push(s3);
          }
          e4 && v2(w2(e4, l3), l3);
          for (t3 = 0; t3 < _3.length; t3++) {
            var s3;
            if (0 === (s3 = _3[t3]).refs) {
              for (var c3 = 0; c3 < s3.parts.length; c3++)
                s3.parts[c3]();
              delete r2[s3.id];
            }
          }
        };
      };
      var m2, g2 = (m2 = [], function(e3, l3) {
        return m2[e3] = l3, m2.filter(Boolean).join("\n");
      });
      function y2(e3, l3, a3, _3) {
        var t3 = a3 ? "" : _3.css;
        if (e3.styleSheet)
          e3.styleSheet.cssText = g2(l3, t3);
        else {
          var r3 = document.createTextNode(t3), o3 = e3.childNodes;
          o3[l3] && e3.removeChild(o3[l3]), o3.length ? e3.insertBefore(r3, o3[l3]) : e3.appendChild(r3);
        }
      }
      function x2(e3, l3) {
        var a3 = l3.css, _3 = l3.media;
        if (_3 && e3.setAttribute("media", _3), e3.styleSheet)
          e3.styleSheet.cssText = a3;
        else {
          for (; e3.firstChild; )
            e3.removeChild(e3.firstChild);
          e3.appendChild(document.createTextNode(a3));
        }
      }
      function M2(e3, l3, a3) {
        var _3 = a3.css, t3 = a3.sourceMap, r3 = void 0 === l3.convertToAbsoluteUrls && t3;
        (l3.convertToAbsoluteUrls || r3) && (_3 = i2(_3)), t3 && (_3 += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(t3)))) + " */");
        var o3 = new Blob([_3], { type: "text/css" }), s3 = e3.href;
        e3.href = URL.createObjectURL(o3), s3 && URL.revokeObjectURL(s3);
      }
    }, function(e2, l2, a2) {
      const { TableConstructor: _2 } = a2(15), t2 = { Toolbox: a2(8), InsertColBefore: a2(9), InsertColAfter: a2(10), InsertRowBefore: a2(11), InsertRowAfter: a2(12), DeleteRow: a2(13), DeleteCol: a2(14) }, r2 = "tc-table__inp";
      e2.exports = class {
        static get enableLineBreaks() {
          return true;
        }
        static get toolbox() {
          return { icon: t2.Toolbox, title: "Table" };
        }
        constructor({ data: e3, config: l3, api: a3 }) {
          this.api = a3, this.wrapper = void 0, this.config = l3, this.data = e3, this._tableConstructor = new _2(e3, l3, a3), this.actions = [{ actionName: "InsertColBefore", icon: t2.InsertColBefore, label: "Insert column before" }, { actionName: "InsertColAfter", icon: t2.InsertColAfter, label: "Insert column after" }, { actionName: "InsertRowBefore", icon: t2.InsertRowBefore, label: "Insert row before" }, { actionName: "InsertRowAfter", icon: t2.InsertRowAfter, label: "Insert row after" }, { actionName: "DeleteRow", icon: t2.DeleteRow, label: "Delete row" }, { actionName: "DeleteCol", icon: t2.DeleteCol, label: "Delete column" }];
        }
        performAction(e3) {
          switch (e3) {
            case "InsertColBefore":
              this._tableConstructor.table.insertColumnBefore();
              break;
            case "InsertColAfter":
              this._tableConstructor.table.insertColumnAfter();
              break;
            case "InsertRowBefore":
              this._tableConstructor.table.insertRowBefore();
              break;
            case "InsertRowAfter":
              this._tableConstructor.table.insertRowAfter();
              break;
            case "DeleteRow":
              this._tableConstructor.table.deleteRow();
              break;
            case "DeleteCol":
              this._tableConstructor.table.deleteColumn();
          }
        }
        renderSettings() {
          const e3 = document.createElement("div");
          return this.actions.forEach(({ actionName: l3, label: a3, icon: _3 }) => {
            const t3 = this.api.i18n.t(a3), r3 = document.createElement("div");
            r3.classList.add("cdx-settings-button"), r3.innerHTML = _3, r3.title = l3, this.api.tooltip.onHover(r3, t3, { placement: "top" }), r3.addEventListener("click", this.performAction.bind(this, l3)), e3.appendChild(r3), this._tableConstructor.table.selectedCell && this._tableConstructor.table.focusCellOnSelectedCell();
          }), e3;
        }
        render() {
          if (this.wrapper = document.createElement("div"), this.data && this.data.content)
            this._createTableConfiguration();
          else {
            this.wrapper.classList.add("table-selector"), this.wrapper.setAttribute("data-hoveredClass", "m,n");
            const e3 = 6;
            this.createCells(e3), "table-selector" === this.wrapper.className && this.wrapper.addEventListener("mouseover", (e4) => {
              if (e4.target.id.length) {
                const l3 = e4.target.attributes.row.value, a3 = e4.target.attributes.column.value;
                this.wrapper.setAttribute("data-hoveredClass", `${l3},${a3}`);
              }
            }), this.wrapper.addEventListener("click", (e4) => {
              if (e4.target.id.length) {
                const l3 = e4.target.attributes.row.value, a3 = e4.target.attributes.column.value;
                this.wrapper.removeEventListener("mouseover", () => {
                }), this.config.rows = l3, this.config.cols = a3, this._createTableConfiguration();
              }
            });
          }
          return this.wrapper;
        }
        createCells(e3) {
          if (0 !== e3)
            for (let l4 = 0; l4 < e3; l4++) {
              let a3 = document.createElement("div");
              a3.setAttribute("class", "table-row");
              for (let _3 = 0; _3 < e3; _3++) {
                let e4 = document.createElement("div"), t3 = document.createElement("div");
                e4.setAttribute("class", "table-cell-container"), t3.setAttribute("class", "table-cell"), e4.setAttribute("id", `row_${l4 + 1}_cell_${_3 + 1}`), e4.setAttribute("column", _3 + 1), e4.setAttribute("row", l4 + 1), t3.setAttribute("id", "cell_" + (_3 + 1)), t3.setAttribute("column", _3 + 1), t3.setAttribute("row", l4 + 1), e4.appendChild(t3), a3.appendChild(e4);
              }
              this.wrapper.appendChild(a3);
            }
          const l3 = document.createElement("input");
          l3.classList.add("hidden-element"), l3.setAttribute("tabindex", 0), this.wrapper.appendChild(l3);
        }
        _createTableConfiguration() {
          this.wrapper.innerHTML = "", this._tableConstructor = new _2(this.data, this.config, this.api), this.wrapper.appendChild(this._tableConstructor.htmlElement);
        }
        save(e3) {
          const l3 = e3.querySelector("table"), a3 = [], _3 = l3 ? l3.rows : 0;
          if (_3.length) {
            for (let e4 = 0; e4 < _3.length; e4++) {
              const l4 = _3[e4], t3 = Array.from(l4.cells).map((e5) => e5.querySelector("." + r2));
              t3.every(this._isEmpty) || a3.push(t3.map((e5) => e5.innerHTML));
            }
            return { content: a3 };
          }
        }
        _isEmpty(e3) {
          return !e3.textContent.trim();
        }
        static get pasteConfig() {
          return { tags: ["TABLE", "TR", "TD", "TBODY", "TH"] };
        }
        async onPaste(e3) {
          const l3 = e3.detail.data;
          this.data = this.pasteHandler(l3), this._createTableConfiguration();
        }
        pasteHandler(e3) {
          const { tagName: l3 } = e3, a3 = { content: [], config: { rows: 0, cols: 0 } };
          if ("TABLE" === l3) {
            let l4 = Array.from(e3.childNodes);
            l4 = l4.find((e4) => "TBODY" === e4.nodeName);
            let _3 = Array.from(l4.childNodes);
            _3 = [_3].map((e4) => e4.filter((e5) => "TR" === e5.nodeName)), a3.config.rows = _3[0].length, a3.content = _3[0].map((e4) => {
              let l5 = e4.childNodes;
              return a3.config.cols = l5.length, l5 = [...l5].map((e5) => e5.innerHTML), l5;
            });
          }
          return a3;
        }
      };
    }, function(e2, l2, a2) {
      var _2 = a2(4);
      "string" == typeof _2 && (_2 = [[e2.i, _2, ""]]);
      var t2 = { hmr: true, transform: void 0, insertInto: void 0 };
      a2(1)(_2, t2);
      _2.locals && (e2.exports = _2.locals);
    }, function(e2, l2, a2) {
      (e2.exports = a2(0)(false)).push([e2.i, ".tc-editor{padding:10px;position:relative;box-sizing:content-box;width:100%;left:-10px}", ""]);
    }, function(e2, l2) {
      e2.exports = function(e3) {
        var l3 = "undefined" != typeof window && window.location;
        if (!l3)
          throw new Error("fixUrls requires window.location");
        if (!e3 || "string" != typeof e3)
          return e3;
        var a2 = l3.protocol + "//" + l3.host, _2 = a2 + l3.pathname.replace(/\/[^\/]*$/, "/");
        return e3.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(e4, l4) {
          var t2, r2 = l4.trim().replace(/^"(.*)"$/, function(e5, l5) {
            return l5;
          }).replace(/^'(.*)'$/, function(e5, l5) {
            return l5;
          });
          return /^(#|data:|http:\/\/|https:\/\/|file:\/\/\/|\s*$)/i.test(r2) ? e4 : (t2 = 0 === r2.indexOf("//") ? r2 : 0 === r2.indexOf("/") ? a2 + r2 : _2 + r2.replace(/^\.\//, ""), "url(" + JSON.stringify(t2) + ")");
        });
      };
    }, function(e2, l2, a2) {
      var _2 = a2(7);
      "string" == typeof _2 && (_2 = [[e2.i, _2, ""]]);
      var t2 = { hmr: true, transform: void 0, insertInto: void 0 };
      a2(1)(_2, t2);
      _2.locals && (e2.exports = _2.locals);
    }, function(e2, l2, a2) {
      (e2.exports = a2(0)(false)).push([e2.i, '.tc-table{width:100%;height:100%;border-collapse:collapse;table-layout:fixed;}.tc-table__wrap{border:1px solid #dbdbe2;border-radius:3px;position:relative;height:100%;width:100%;box-sizing:border-box}.tc-table__cell{border:1px solid #dbdbe2;padding:0;vertical-align:top}.tc-table__area{padding:10px;height:100%}.tc-table__inp{outline:none;flex-grow:100;min-height:1.5em;height:100%;overflow:hidden}.tc-table__highlight:focus-within{background-color:rgba(173,164,176,.1)}.tc-table tbody tr:first-child td{border-top:none}.tc-table tbody tr:last-child td{border-bottom:none}.tc-table tbody tr td:last-child{border-right:none}.tc-table tbody tr td:first-child{border-left:none}.table-selector{display:flex;flex-direction:column;}.table-selector .hidden-element{display:none}.table-row{display:flex;flex-direction:row}.table-cell-container{width:30px;height:30px}.table-cell{width:25px;height:25px;background:#f6f6f6;border:1px solid #e4e4e4;cursor:pointer}[data-hoveredClass="1,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="1,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="1,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="1,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="1,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="1,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="1,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="1,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="1,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="1,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="1,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="1,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="2,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="2,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="2,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="2,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="2,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="2,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="2,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="2,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="2,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="2,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="2,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="2,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="2,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="2,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="2,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="2,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="2,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="2,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="2,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="2,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="2,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="2,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="2,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="2,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="3,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,1"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,2"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,2"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="3,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="3,3"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,3"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,3"] #row_3_cell_3 #cell_3,[data-hoveredClass="3,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="3,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="3,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="3,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="3,4"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,4"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,4"] #row_3_cell_3 #cell_3,[data-hoveredClass="3,4"] #row_3_cell_4 #cell_4,[data-hoveredClass="3,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="3,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="3,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="3,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="3,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="3,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="3,5"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,5"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,5"] #row_3_cell_3 #cell_3,[data-hoveredClass="3,5"] #row_3_cell_4 #cell_4,[data-hoveredClass="3,5"] #row_3_cell_5 #cell_5,[data-hoveredClass="3,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="3,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="3,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="3,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="3,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="3,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="3,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="3,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="3,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="3,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="3,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="3,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="3,6"] #row_3_cell_1 #cell_1,[data-hoveredClass="3,6"] #row_3_cell_2 #cell_2,[data-hoveredClass="3,6"] #row_3_cell_3 #cell_3,[data-hoveredClass="3,6"] #row_3_cell_4 #cell_4,[data-hoveredClass="3,6"] #row_3_cell_5 #cell_5,[data-hoveredClass="3,6"] #row_3_cell_6 #cell_6,[data-hoveredClass="4,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,1"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,1"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,2"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,2"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,2"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="4,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="4,3"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,3"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_3_cell_3 #cell_3,[data-hoveredClass="4,3"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,3"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,3"] #row_4_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="4,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="4,4"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,4"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,4"] #row_3_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_3_cell_4 #cell_4,[data-hoveredClass="4,4"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,4"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,4"] #row_4_cell_3 #cell_3,[data-hoveredClass="4,4"] #row_4_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="4,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="4,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="4,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="4,5"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,5"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,5"] #row_3_cell_3 #cell_3,[data-hoveredClass="4,5"] #row_3_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_3_cell_5 #cell_5,[data-hoveredClass="4,5"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,5"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,5"] #row_4_cell_3 #cell_3,[data-hoveredClass="4,5"] #row_4_cell_4 #cell_4,[data-hoveredClass="4,5"] #row_4_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="4,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="4,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="4,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="4,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="4,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="4,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="4,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="4,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="4,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="4,6"] #row_3_cell_1 #cell_1,[data-hoveredClass="4,6"] #row_3_cell_2 #cell_2,[data-hoveredClass="4,6"] #row_3_cell_3 #cell_3,[data-hoveredClass="4,6"] #row_3_cell_4 #cell_4,[data-hoveredClass="4,6"] #row_3_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_3_cell_6 #cell_6,[data-hoveredClass="4,6"] #row_4_cell_1 #cell_1,[data-hoveredClass="4,6"] #row_4_cell_2 #cell_2,[data-hoveredClass="4,6"] #row_4_cell_3 #cell_3,[data-hoveredClass="4,6"] #row_4_cell_4 #cell_4,[data-hoveredClass="4,6"] #row_4_cell_5 #cell_5,[data-hoveredClass="4,6"] #row_4_cell_6 #cell_6,[data-hoveredClass="5,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,1"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,1"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,1"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,2"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,2"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,2"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,2"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="5,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="5,3"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_3_cell_3 #cell_3,[data-hoveredClass="5,3"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_4_cell_3 #cell_3,[data-hoveredClass="5,3"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,3"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,3"] #row_5_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="5,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="5,4"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_3_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_3_cell_4 #cell_4,[data-hoveredClass="5,4"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_4_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_4_cell_4 #cell_4,[data-hoveredClass="5,4"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,4"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,4"] #row_5_cell_3 #cell_3,[data-hoveredClass="5,4"] #row_5_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="5,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="5,5"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_3_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_3_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_3_cell_5 #cell_5,[data-hoveredClass="5,5"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_4_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_4_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_4_cell_5 #cell_5,[data-hoveredClass="5,5"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,5"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,5"] #row_5_cell_3 #cell_3,[data-hoveredClass="5,5"] #row_5_cell_4 #cell_4,[data-hoveredClass="5,5"] #row_5_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="5,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="5,6"] #row_3_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_3_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_3_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_3_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_3_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_3_cell_6 #cell_6,[data-hoveredClass="5,6"] #row_4_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_4_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_4_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_4_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_4_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_4_cell_6 #cell_6,[data-hoveredClass="5,6"] #row_5_cell_1 #cell_1,[data-hoveredClass="5,6"] #row_5_cell_2 #cell_2,[data-hoveredClass="5,6"] #row_5_cell_3 #cell_3,[data-hoveredClass="5,6"] #row_5_cell_4 #cell_4,[data-hoveredClass="5,6"] #row_5_cell_5 #cell_5,[data-hoveredClass="5,6"] #row_5_cell_6 #cell_6,[data-hoveredClass="6,1"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,1"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,2"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,2"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_1_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_2_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_3_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_4_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_5_cell_3 #cell_3,[data-hoveredClass="6,3"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,3"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,3"] #row_6_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_1_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_1_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_2_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_2_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_3_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_3_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_4_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_4_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_5_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_5_cell_4 #cell_4,[data-hoveredClass="6,4"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,4"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,4"] #row_6_cell_3 #cell_3,[data-hoveredClass="6,4"] #row_6_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_1_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_1_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_1_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_2_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_2_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_2_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_3_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_3_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_3_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_4_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_4_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_4_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_5_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_5_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_5_cell_5 #cell_5,[data-hoveredClass="6,5"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,5"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,5"] #row_6_cell_3 #cell_3,[data-hoveredClass="6,5"] #row_6_cell_4 #cell_4,[data-hoveredClass="6,5"] #row_6_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_1_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_1_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_1_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_1_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_1_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_1_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_2_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_2_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_2_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_2_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_2_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_2_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_3_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_3_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_3_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_3_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_3_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_3_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_4_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_4_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_4_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_4_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_4_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_4_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_5_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_5_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_5_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_5_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_5_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_5_cell_6 #cell_6,[data-hoveredClass="6,6"] #row_6_cell_1 #cell_1,[data-hoveredClass="6,6"] #row_6_cell_2 #cell_2,[data-hoveredClass="6,6"] #row_6_cell_3 #cell_3,[data-hoveredClass="6,6"] #row_6_cell_4 #cell_4,[data-hoveredClass="6,6"] #row_6_cell_5 #cell_5,[data-hoveredClass="6,6"] #row_6_cell_6 #cell_6{background:#d5e4f9;border:1px solid #c0cffd}', ""]);
    }, function(e2, l2) {
      e2.exports = '<svg width="18" height="14"><path d="M2.833 8v1.95a1.7 1.7 0 0 0 1.7 1.7h3.45V8h-5.15zm0-2h5.15V2.35h-3.45a1.7 1.7 0 0 0-1.7 1.7V6zm12.3 2h-5.15v3.65h3.45a1.7 1.7 0 0 0 1.7-1.7V8zm0-2V4.05a1.7 1.7 0 0 0-1.7-1.7h-3.45V6h5.15zM4.533.1h8.9a3.95 3.95 0 0 1 3.95 3.95v5.9a3.95 3.95 0 0 1-3.95 3.95h-8.9a3.95 3.95 0 0 1-3.95-3.95v-5.9A3.95 3.95 0 0 1 4.533.1z"></path></svg>';
    }, function(e2, l2) {
      e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="-21 0 512 512" width="18" height="18"><path d="M181.332031 106.667969c-3.925781 0-7.828125-1.429688-10.921875-4.3125l-80-74.664063c-4.820312-4.480468-6.378906-11.457031-3.96875-17.558594C88.851562 4.011719 94.761719 0 101.332031 0h160c6.570313 0 12.480469 4.011719 14.871094 10.132812 2.410156 6.125.851563 13.078126-3.96875 17.558594l-80 74.664063c-3.070313 2.882812-6.976563 4.3125-10.902344 4.3125zM141.910156 32l39.421875 36.777344L220.757812 32zm0 0M90.667969 512H37.332031C16.746094 512 0 495.253906 0 474.667969V144c0-20.585938 16.746094-37.332031 37.332031-37.332031h53.335938C111.253906 106.667969 128 123.414062 128 144v330.667969C128 495.253906 111.253906 512 90.667969 512zM37.332031 138.667969C34.390625 138.667969 32 141.054688 32 144v330.667969C32 477.609375 34.390625 480 37.332031 480h53.335938C93.609375 480 96 477.609375 96 474.667969V144c0-2.945312-2.390625-5.332031-5.332031-5.332031zm0 0M432 512H272c-20.585938 0-37.332031-16.746094-37.332031-37.332031V144c0-20.585938 16.746093-37.332031 37.332031-37.332031h160c20.585938 0 37.332031 16.746093 37.332031 37.332031v330.667969C469.332031 495.253906 452.585938 512 432 512zM272 138.667969c-2.945312 0-5.332031 2.386719-5.332031 5.332031v330.667969C266.667969 477.609375 269.054688 480 272 480h160c2.945312 0 5.332031-2.390625 5.332031-5.332031V144c0-2.945312-2.386719-5.332031-5.332031-5.332031zm0 0"></path><path d="M112 325.332031H16c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16h96c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0M453.332031 325.332031H250.667969c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16h202.664062c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0"></path><path d="M352 512c-8.832031 0-16-7.167969-16-16V122.667969c0-8.832031 7.167969-16 16-16s16 7.167969 16 16V496c0 8.832031-7.167969 16-16 16zm0 0"></path></svg>';
    }, function(e2, l2) {
      e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="-21 0 512 512" width="18" height="18"><path d="M288 106.667969c-3.925781 0-7.851562-1.429688-10.921875-4.3125l-80-74.664063c-4.800781-4.480468-6.378906-11.457031-3.96875-17.558594C195.519531 4.03125 201.429688 0 208 0h160c6.570312 0 12.480469 4.011719 14.890625 10.132812 2.410156 6.125.832031 13.078126-3.96875 17.558594l-80 74.664063c-3.070313 2.882812-6.996094 4.3125-10.921875 4.3125zM248.597656 32L288 68.777344 327.402344 32zm0 0M432 512h-53.332031c-20.589844 0-37.335938-16.746094-37.335938-37.332031V144c0-20.585938 16.746094-37.332031 37.335938-37.332031H432c20.585938 0 37.332031 16.746093 37.332031 37.332031v330.667969C469.332031 495.253906 452.585938 512 432 512zm-53.332031-373.332031c-2.945313 0-5.335938 2.386719-5.335938 5.332031v330.667969c0 2.941406 2.390625 5.332031 5.335938 5.332031H432c2.945312 0 5.332031-2.390625 5.332031-5.332031V144c0-2.945312-2.386719-5.332031-5.332031-5.332031zm0 0M197.332031 512h-160C16.746094 512 0 495.253906 0 474.667969V144c0-20.585938 16.746094-37.332031 37.332031-37.332031h160c20.589844 0 37.335938 16.746093 37.335938 37.332031v330.667969c0 20.585937-16.746094 37.332031-37.335938 37.332031zm-160-373.332031C34.390625 138.667969 32 141.054688 32 144v330.667969C32 477.609375 34.390625 480 37.332031 480h160c2.945313 0 5.335938-2.390625 5.335938-5.332031V144c0-2.945312-2.390625-5.332031-5.335938-5.332031zm0 0"></path><path d="M453.332031 325.332031h-96c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16h96c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0M218.667969 325.332031H16c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16h202.667969c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0"></path><path d="M117.332031 512c-8.832031 0-16-7.167969-16-16V122.667969c0-8.832031 7.167969-16 16-16s16 7.167969 16 16V496c0 8.832031-7.167969 16-16 16zm0 0"></path></svg>';
    }, function(e2, l2) {
      e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -21 512 512" width="18" height="18"><path d="M16 277.332031c-1.984375 0-3.96875-.363281-5.867188-1.109375C4.011719 273.8125 0 267.902344 0 261.332031v-160c0-6.570312 4.011719-12.480469 10.132812-14.890625 6.144532-2.410156 13.078126-.851562 17.558594 3.96875l74.664063 80c5.761719 6.144532 5.761719 15.679688 0 21.824219l-74.664063 80C24.597656 275.5625 20.351562 277.332031 16 277.332031zm16-135.402343v78.804687l36.777344-39.402344zm0 0M474.667969 128H144c-20.585938 0-37.332031-16.746094-37.332031-37.332031V37.332031C106.667969 16.746094 123.414062 0 144 0h330.667969C495.253906 0 512 16.746094 512 37.332031v53.335938C512 111.253906 495.253906 128 474.667969 128zM144 32c-2.945312 0-5.332031 2.390625-5.332031 5.332031v53.335938C138.667969 93.609375 141.054688 96 144 96h330.667969C477.609375 96 480 93.609375 480 90.667969V37.332031C480 34.390625 477.609375 32 474.667969 32zm0 0M474.667969 469.332031H144c-20.585938 0-37.332031-16.746093-37.332031-37.332031V272c0-20.585938 16.746093-37.332031 37.332031-37.332031h330.667969C495.253906 234.667969 512 251.414062 512 272v160c0 20.585938-16.746094 37.332031-37.332031 37.332031zM144 266.667969c-2.945312 0-5.332031 2.386719-5.332031 5.332031v160c0 2.945312 2.386719 5.332031 5.332031 5.332031h330.667969C477.609375 437.332031 480 434.945312 480 432V272c0-2.945312-2.390625-5.332031-5.332031-5.332031zm0 0"></path><path d="M309.332031 128c-8.832031 0-16-7.167969-16-16V16c0-8.832031 7.167969-16 16-16s16 7.167969 16 16v96c0 8.832031-7.167969 16-16 16zm0 0M309.332031 469.332031c-8.832031 0-16-7.167969-16-16V250.667969c0-8.832031 7.167969-16 16-16s16 7.167969 16 16v202.664062c0 8.832031-7.167969 16-16 16zm0 0"></path><path d="M496 368H122.667969c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16H496c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0"></path></svg>';
    }, function(e2, l2) {
      e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -21 512 512" width="18" height="18"><path d="M16 384c-1.984375 0-3.96875-.363281-5.867188-1.109375C4.011719 380.480469 0 374.570312 0 368V208c0-6.570312 4.011719-12.480469 10.132812-14.890625 6.144532-2.410156 13.078126-.851563 17.558594 3.96875l74.664063 80c5.761719 6.144531 5.761719 15.679687 0 21.824219l-74.664063 80C24.597656 382.230469 20.351562 384 16 384zm16-135.402344v78.804688L68.777344 288zm0 0M474.667969 469.332031H144c-20.585938 0-37.332031-16.746093-37.332031-37.332031v-53.332031c0-20.589844 16.746093-37.335938 37.332031-37.335938h330.667969c20.585937 0 37.332031 16.746094 37.332031 37.335938V432c0 20.585938-16.746094 37.332031-37.332031 37.332031zm-330.667969-96c-2.945312 0-5.332031 2.390625-5.332031 5.335938V432c0 2.945312 2.386719 5.332031 5.332031 5.332031h330.667969C477.609375 437.332031 480 434.945312 480 432v-53.332031c0-2.945313-2.390625-5.335938-5.332031-5.335938zm0 0M474.667969 234.667969H144c-20.585938 0-37.332031-16.746094-37.332031-37.335938v-160C106.667969 16.746094 123.414062 0 144 0h330.667969C495.253906 0 512 16.746094 512 37.332031v160c0 20.589844-16.746094 37.335938-37.332031 37.335938zM144 32c-2.945312 0-5.332031 2.390625-5.332031 5.332031v160c0 2.945313 2.386719 5.335938 5.332031 5.335938h330.667969c2.941406 0 5.332031-2.390625 5.332031-5.335938v-160C480 34.390625 477.609375 32 474.667969 32zm0 0"></path><path d="M309.332031 469.332031c-8.832031 0-16-7.167969-16-16v-96c0-8.832031 7.167969-16 16-16s16 7.167969 16 16v96c0 8.832031-7.167969 16-16 16zm0 0M309.332031 234.667969c-8.832031 0-16-7.167969-16-16V16c0-8.832031 7.167969-16 16-16s16 7.167969 16 16v202.667969c0 8.832031-7.167969 16-16 16zm0 0"></path><path d="M496 133.332031H122.667969c-8.832031 0-16-7.167969-16-16s7.167969-16 16-16H496c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0"></path></svg>';
    }, function(e2, l2) {
      e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.381 15.381" width="18" height="18"><g><path d="M0 1.732v7.732h6.053c0-.035-.004-.07-.004-.104 0-.434.061-.854.165-1.255H1.36V3.092h12.662v2.192c.546.396 1.01.897 1.359 1.477V1.732H0z"></path><path d="M11.196 5.28c-2.307 0-4.183 1.877-4.183 4.184 0 2.308 1.876 4.185 4.183 4.185 2.309 0 4.185-1.877 4.185-4.185 0-2.307-1.876-4.184-4.185-4.184zm0 7.233c-1.679 0-3.047-1.367-3.047-3.049 0-1.68 1.368-3.049 3.047-3.049 1.684 0 3.05 1.369 3.05 3.049 0 1.682-1.366 3.049-3.05 3.049z"></path><path d="M9.312 8.759h3.844v1.104H9.312z"></path></g></svg>';
    }, function(e2, l2) {
      e2.exports = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 26 26" width="18" height="18"><path d="M13.594 20.85V24h-10V2h10v3.15c.633-.323 1.304-.565 2-.727V1c0-.551-.448-1-1-1h-12c-.55 0-1 .449-1 1v24c0 .551.449 1 1 1h12c.552 0 1-.449 1-1v-3.424c-.696-.161-1.367-.403-2-.726z"></path><path d="M17.594 6.188c-3.762 0-6.813 3.051-6.812 6.813-.001 3.761 3.05 6.812 6.812 6.812s6.813-3.051 6.813-6.813-3.052-6.812-6.813-6.812zm3.632 7.802l-7.267.001v-1.982h7.268l-.001 1.981z"></path></svg>';
    }, function(e2, l2, a2) {
      a2.r(l2), a2.d(l2, "TableConstructor", function() {
        return w2;
      });
      a2(3);
      function _2(e3) {
        return !(null == e3);
      }
      function t2(e3, l3 = null, a3 = null, t3 = null) {
        const r3 = document.createElement(e3);
        if (_2(l3))
          for (let e4 = 0; e4 < l3.length; e4++)
            _2(l3[e4]) && r3.classList.add(l3[e4]);
        if (_2(a3))
          for (let e4 in a3)
            r3.setAttribute(e4, a3[e4]);
        if (_2(t3))
          for (let e4 = 0; e4 < t3.length; e4++)
            _2(t3[e4]) && r3.appendChild(t3[e4]);
        return r3;
      }
      a2(6);
      const r2 = "tc-table", o2 = "tc-table__inp", s2 = "tc-table__cell", c2 = "tc-table__wrap", d2 = "tc-table__area", h2 = "tc-table__highlight";
      class n2 {
        constructor() {
          this._numberOfColumns = 0, this._numberOfRows = 0, this._element = this._createTableWrapper(), this._table = this._element.querySelector("table"), this._selectedCell = null, this._attachEvents();
        }
        get selectedCell() {
          return this._selectedCell;
        }
        set selectedCell(e3) {
          this._selectedCell && this._selectedCell.classList.remove(h2), this._selectedCell = e3, this._selectedCell && this._selectedCell.classList.add(h2);
        }
        get selectedRow() {
          return this.selectedCell ? this.selectedCell.closest("tr") : null;
        }
        insertColumnAfter() {
          this.insertColumn(1), this.focusCellOnSelectedCell();
        }
        insertColumnBefore() {
          this.insertColumn(), this.focusCellOnSelectedCell();
        }
        insertRowBefore() {
          this.insertRow(), this.focusCellOnSelectedCell();
        }
        insertRowAfter() {
          this.insertRow(1), this.focusCellOnSelectedCell();
        }
        insertColumn(e3 = 0) {
          e3 = Math.min(Math.max(e3, 0), 1);
          const l3 = this.selectedCell ? this.selectedCell.cellIndex + e3 : 0;
          this._numberOfColumns++;
          const a3 = this._table.rows;
          for (let e4 = 0; e4 < a3.length; e4++) {
            const _3 = a3[e4].insertCell(l3);
            this._fillCell(_3);
          }
        }
        deleteColumn() {
          if (!this.selectedCell)
            return;
          const e3 = this.selectedCell.cellIndex;
          this._numberOfColumns--;
          const l3 = this._table.rows;
          for (let a3 = 0; a3 < l3.length; a3++)
            l3[a3].deleteCell(e3);
        }
        insertRow(e3 = 0) {
          e3 = Math.min(Math.max(e3, 0), 1);
          const l3 = this.selectedRow ? this.selectedRow.rowIndex + e3 : 0, a3 = this._table.insertRow(l3);
          return this._numberOfRows++, this._fillRow(a3), a3;
        }
        deleteRow(e3 = -1) {
          if (!this.selectedRow)
            return;
          const l3 = this.selectedRow.rowIndex;
          this._table.deleteRow(l3), this._numberOfRows--;
        }
        get htmlElement() {
          return this._element;
        }
        get body() {
          return this._table;
        }
        _createTableWrapper() {
          return t2("div", [c2], null, [t2("table", [r2])]);
        }
        _createContenteditableArea() {
          return t2("div", [o2], { contenteditable: "true" });
        }
        _fillCell(e3) {
          e3.classList.add(s2);
          const l3 = this._createContenteditableArea();
          e3.appendChild(t2("div", [d2], null, [l3]));
        }
        _fillRow(e3) {
          for (let l3 = 0; l3 < this._numberOfColumns; l3++) {
            const l4 = e3.insertCell();
            this._fillCell(l4);
          }
        }
        _attachEvents() {
          this._table.addEventListener("focus", (e3) => {
            this._focusEditField(e3);
          }, true), this._table.addEventListener("keydown", (e3) => {
            this._pressedEnterInEditField(e3);
          }), this._table.addEventListener("click", (e3) => {
            this._clickedOnCell(e3);
          }), this.htmlElement.addEventListener("keydown", (e3) => {
            this._containerKeydown(e3);
          });
        }
        _focusEditField(e3) {
          this.selectedCell = "TD" === e3.target.tagName ? e3.target : e3.target.closest("td");
        }
        focusCellOnSelectedCell() {
          this.selectedCell.childNodes[0].childNodes[0].focus();
        }
        _pressedEnterInEditField(e3) {
          e3.target.classList.contains(o2) && ("Enter" !== e3.key || e3.shiftKey || e3.preventDefault());
        }
        _clickedOnCell(e3) {
          if (!e3.target.classList.contains(s2))
            return;
          e3.target.querySelector("." + o2).focus();
        }
        _containerKeydown(e3) {
          "Enter" === e3.key && e3.ctrlKey && this._containerEnterPressed(e3);
        }
        _containerEnterPressed(e3) {
          this.insertRow(1).cells[0].click();
        }
      }
      const i2 = "tc-editor", v2 = "tc-table__inp";
      class w2 {
        constructor(e3, l3, a3) {
          this._table = new n2();
          const _3 = this._resizeTable(e3, l3);
          this._fillTable(e3, _3), this._container = t2("div", [i2, a3.styles && a3.styles.block], null, [this._table.htmlElement]);
        }
        get htmlElement() {
          return this._container;
        }
        get table() {
          return this._table;
        }
        _fillTable(e3, l3) {
          if (void 0 !== e3.content)
            for (let a3 = 0; a3 < l3.rows && a3 < e3.content.length; a3++)
              for (let _3 = 0; _3 < l3.cols && _3 < e3.content[a3].length; _3++) {
                this._table.body.rows[a3].cells[_3].querySelector("." + v2).innerHTML = e3.content[a3][_3];
              }
        }
        _resizeTable(e3, l3) {
          const a3 = Array.isArray(e3.content), _3 = !!a3 && e3.content.length, t3 = a3 ? e3.content.length : void 0, r3 = _3 ? e3.content[0].length : void 0, o3 = Number.parseInt(l3.rows), s3 = Number.parseInt(l3.cols), c3 = !isNaN(o3) && o3 > 0 ? o3 : void 0, d3 = !isNaN(s3) && s3 > 0 ? s3 : void 0, h3 = t3 || c3 || 1, n3 = r3 || d3 || 1;
          for (let e4 = 0; e4 < h3; e4++)
            this._table.insertRow();
          for (let e4 = 0; e4 < n3; e4++)
            this._table.insertColumn();
          return { rows: h3, cols: n3 };
        }
      }
    }]);
  });
})(bundle);
var bundleExports = bundle.exports;
const Table = /* @__PURE__ */ getDefaultExportFromCjs(bundleExports);
const EDITOR_JS_TOOLS = {
  embed: { class: Embed, inlineToolbar: true },
  // table: Table,
  list: {
    class: List2,
    inlineToolbar: true
  },
  table: Table,
  // warning: Warning,
  youtube: {
    class: Youtube,
    inlineToolbar: true
  },
  // code: Code,
  // linkTool: { class: LinkTool, inlineToolbar: true },
  image: {
    class: Image,
    inlineToolbar: true,
    config: {
      endpoints: {
        byFile: "/api/course/upload-temp-image"
        // byUrl: 'http://127.0.0.1:5173/assets/images/',
      }
    }
  },
  // raw: { class: Raw, inlineToolbar: true },
  // header: { class: Header, inlineToolbar: true },
  // quote: Quote,
  // marker: Marker,
  // checklist: { class: CheckList, inlineToolbar: true },
  // delimiter: Delimiter,
  inlineCode: InlineCode
  // image: { class: SimpleImage, inlineToolbar: true },
};
const EDITOR_INTERNATIONALIZATION_CONFIG = {
  /**
   * @type {I18nDictionary}
   */
  messages: {
    /**
     * Other below: translation of different UI components of the editor.js core
     */
    ui: {
      blockTunes: {
        toggler: {
          "Click to tune": "Нажмите, чтобы настроить",
          "or drag to move": "или перетащите"
        }
      },
      inlineToolbar: {
        converter: {
          "Convert to": "Конвертировать в"
        }
      },
      toolbar: {
        toolbox: {
          Add: "Добавить"
        }
      }
    },
    /**
     * Section for translation Tool Names: both block and inline tools
     */
    toolNames: {
      Text: "Параграф",
      // Heading: 'Заголовок',
      List: "Список",
      // Warning: 'Примечание',
      // Checklist: 'Чеклист',
      // Quote: 'Цитата',
      // Code: 'Код',
      // Delimiter: 'Разделитель',
      // 'Raw HTML': 'HTML-фрагмент',
      // Table: 'Таблица',
      Link: "Ссылка",
      // Marker: 'Маркер',
      Bold: "Полужирный",
      Italic: "Курсив",
      InlineCode: "Моноширинный",
      Image: "Изображение"
    },
    /**
     * Section for passing translations to the external tools classes
     */
    tools: {
      /**
       * Each subsection is the i18n dictionary that will be passed to the corresponded plugin
       * The name of a plugin should be equal the name you specify in the 'tool' section for that plugin
       */
      warning: {
        // <-- 'Warning' tool will accept this dictionary section
        Title: "Название",
        Message: "Сообщение"
      },
      /**
       * Link is the internal Inline Tool
       */
      link: {
        "Add a link": "Вставьте ссылку"
      },
      /**
       * The "stub" is an internal block tool, used to fit blocks that does not have the corresponded plugin
       */
      stub: {
        "The block can not be displayed correctly.": "Блок не может быть отображен"
      },
      list: {
        Unordered: "Неупорядоченный",
        Ordered: "Пронумерованный"
      }
    },
    /**
     * Section allows to translate Block Tunes
     */
    blockTunes: {
      /**
       * Each subsection is the i18n dictionary that will be passed to the corresponded Block Tune plugin
       * The name of a plugin should be equal the name you specify in the 'tunes' section for that plugin
       *
       * Also, there are few internal block tunes: "delete", "moveUp" and "moveDown"
       */
      delete: {
        Delete: "Удалить"
      },
      moveUp: {
        "Move up": "Переместить вверх"
      },
      moveDown: {
        "Move down": "Переместить вниз"
      }
    }
  }
};
let editor;
function CreateCompetitionForm({ type }) {
  const { setLoaderActive } = useActions();
  const navigate = useNavigate();
  const { competitionId } = useParams();
  const [competitionName, setCompetitionName] = reactExports.useState("");
  const [competitionLink, setCompetitionLink] = reactExports.useState("");
  const [isValidName, setValidName] = reactExports.useState(false);
  const [isChangedName, setChangedName] = reactExports.useState(false);
  const [createCompetition] = useCreateCompetitionMutation();
  const [updateCompetition] = useUpdateCompetitionMutation();
  const { data, isFetching } = useGetCompetitionByIdQuery(Number(competitionId), {
    skip: !competitionId
  });
  const [ckEditorData, setCkEditorData] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (data && type === "edit") {
      setCompetitionName(data.data.title);
      setCompetitionLink(data.data.link);
      if (!editor) {
        try {
          editor = new Bi({
            holder: "editorjs",
            tools: EDITOR_JS_TOOLS,
            i18n: EDITOR_INTERNATIONALIZATION_CONFIG,
            inlineToolbar: true,
            data: {
              blocks: JSON.parse(data.data.text || "[]")
            }
          });
        } catch (e2) {
          console.log(e2);
        }
      }
    }
  }, [data, type]);
  reactExports.useEffect(() => {
    if (!editor && !isFetching && !data) {
      try {
        editor = new Bi({
          holder: "editorjs",
          tools: EDITOR_JS_TOOLS,
          i18n: EDITOR_INTERNATIONALIZATION_CONFIG,
          inlineToolbar: true
        });
      } catch (e2) {
        console.log(e2);
      }
    }
    return () => {
      editor = void 0;
    };
  }, [data, isFetching]);
  const handleConfirm = async () => {
    const editorData = await (editor == null ? void 0 : editor.save().then((data2) => data2));
    if (!isValidName) {
      setChangedName(true);
      return;
    }
    if (type !== "create") {
      updateCompetition({
        id: Number(competitionId),
        title: competitionName,
        text: JSON.stringify(editorData ? editorData.blocks : []),
        link: competitionLink
      }).then((res) => {
        setLoaderActive(false);
        if ("data" in res && res.data.result) {
          navigate("/news");
        } else {
          alert("Произошла ошибка при сохранении конкурса. Попробуйте ещё раз!");
        }
      }).catch((err) => {
        setLoaderActive(false);
        console.error(err);
        alert("Произошла ошибка при сохранении конкурса. Попробуйте ещё раз!");
      });
      setLoaderActive(true);
    } else {
      createCompetition({
        title: competitionName,
        text: ckEditorData,
        link: competitionLink
      }).then((res) => {
        setLoaderActive(false);
        if ("data" in res && res.data.result) {
          navigate("/news");
        } else {
          alert("Произошла ошибка при создании конкурса. Попробуйте ещё раз!");
        }
      }).catch((err) => {
        setLoaderActive(false);
        console.error(err);
        alert("Произошла ошибка при создании конкурса. Попробуйте ещё раз!");
      });
      setLoaderActive(true);
    }
  };
  const handleCancel = () => {
    navigate("/news");
  };
  const handleChangeName = (event) => {
    setValidName(event.target.value.length > 1);
    setCompetitionName(event.target.value);
    if (!isChangedName) {
      setChangedName(true);
    }
  };
  const handleChangeLink = (event) => {
    setValidName(event.target.value.length > 1);
    setCompetitionLink(event.target.value);
  };
  const controlsData = {
    names: {
      confirm: type === "create" ? "Создать конкурс" : "Изменить конкурс",
      cancel: "Отмена"
    },
    handlers: {
      confirm: handleConfirm,
      cancel: handleCancel
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Title, { children: type === "create" ? "Создание конкурса" : "Редактирование конкурса" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CompetitionNameInput,
      {
        $isValid: isValidName,
        $isChanged: isChangedName,
        value: competitionName,
        onChange: handleChangeName,
        type: "text",
        placeholder: type === "create" ? "Введите название конкурса (обязательно)" : "Новое название"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CkEditor, { onChange: setCkEditorData }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(EditorJsWrapper, { id: "editorjs" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      CompetitionNameInput,
      {
        $isValid: isValidName,
        $isChanged: isChangedName,
        value: competitionLink,
        onChange: handleChangeLink,
        type: "text",
        placeholder: type === "create" ? "Ссылка на конкурс в борбозе" : "Новая ссылка"
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Divider, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormControls,
      {
        ...controlsData,
        containerStyles: { padding: "25px 0px 25px" }
      }
    )
  ] });
}
function CreateCompetition({ type }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DefaultContainer, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(ChangeBodyBg, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCompetitionForm, { type })
  ] });
}
function App() {
  const { isLoading } = useCheckUserQuery();
  const { setAuthToken, setLoaderActive: setActive } = useActions();
  const { isModalOpen, modalType } = useTypedSelector((state) => state.modal);
  const active = useTypedSelector((state) => state.loader.active);
  const loaderRef = reactExports.useRef(null);
  const isMobile = useMediaQuery$1(MediaQueries.mobile);
  reactExports.useEffect(() => {
    setActive(isLoading);
  }, [isLoading, setActive]);
  reactExports.useEffect(() => {
    const csrfHolder = document.querySelector('meta[name="csrf-token"]');
    if (csrfHolder) {
      const CSRF_TOKEN = csrfHolder.content;
      setAuthToken(CSRF_TOKEN);
    }
  }, [setAuthToken]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(BrowserRouter, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Layout, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/*",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(Main, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/courses/:courseId/:chapterId/:themeId/create-lesson",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateLesson, { type: "create" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/courses/:courseId/:chapterId/:themeId/:lessonId/edit-lesson",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateLesson, { type: "edit" })
        }
      ),
      isMobile && /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/courses/:courseId/:chapterId/:themeId?/:lessonId?",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(CourseMob, {})
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/news/create-news",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateNews, { type: "create" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/news/edit-news/:newsId",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateNews, { type: "edit" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/news/competition/create-competition",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCompetition, { type: "create" })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/news/competition/edit-competition/:competitionId",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCompetition, { type: "edit" })
        }
      )
    ] }),
    isModalOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs(ModalLayout, { modalType, children: [
      modalType === MODAL_TYPES.createCourse && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCourseForm, {}),
      modalType === MODAL_TYPES.editCourse && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateCourseForm, {}),
      modalType === MODAL_TYPES.createChapter && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateChapterForm, {}),
      modalType === MODAL_TYPES.editChapter && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateChapterForm, {}),
      modalType === MODAL_TYPES.createTheme && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateThemeForm, {}),
      modalType === MODAL_TYPES.editTheme && /* @__PURE__ */ jsxRuntimeExports.jsx(CreateThemeForm, {}),
      modalType === MODAL_TYPES.newsCategory && /* @__PURE__ */ jsxRuntimeExports.jsx(NewsCategoryForm, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Transition$1,
      {
        unmountOnExit: true,
        nodeRef: loaderRef,
        timeout: 300,
        in: active,
        children: (state) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Loading,
          {
            innerRef: loaderRef,
            state
          }
        )
      }
    )
  ] }) });
}
const reducer = combineReducers({
  auth: reducer$6,
  modal: reducer$7,
  course: reducer$5,
  loader: reducer$4,
  lesson: reducer$3,
  competition: reducer$2,
  news: reducer$1,
  [api.reducerPath]: api.reducer
});
const store = configureStore({
  reducer,
  middleware: (getDefaultMiddleware2) => getDefaultMiddleware2({
    serializableCheck: false
  }).concat(api.middleware)
});
const normalize = nt$1`
 html {
  line-height: 1.15;
  -webkit-text-size-adjust: 100%;
}
body {
  margin: 0;
}
main {
  display: block;
}
h1 {
  font-size: 2em;
  margin: 0.67em 0;
}
hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}
pre {
  font-family: monospace, monospace;
  font-size: 1em;
}
a {
  background-color: transparent;
}
abbr[title] {
  border-bottom: none;
  text-decoration: underline;
  text-decoration: underline dotted;
}
b,
strong {
  font-weight: bolder;
}
code,
kbd,
samp {
  font-family: monospace, monospace;
  font-size: 1em;
}
small {
  font-size: 80%;
}
sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
sub {
  bottom: -0.25em;
}
sup {
  top: -0.5em;
}
img {
  border-style: none;
}
button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  font-size: 100%;
  line-height: 1.15;
  margin: 0;
}
button,
input {
  overflow: visible;
}
button,
select {
  text-transform: none;
}
button,
[type="button"],
[type="reset"],
[type="submit"] {
  -webkit-appearance: button;
}
button::-moz-focus-inner,
[type="button"]::-moz-focus-inner,
[type="reset"]::-moz-focus-inner,
[type="submit"]::-moz-focus-inner {
  border-style: none;
  padding: 0;
}
button:-moz-focusring,
[type="button"]:-moz-focusring,
[type="reset"]:-moz-focusring,
[type="submit"]:-moz-focusring {
  outline: 1px dotted ButtonText;
}
fieldset {
  padding: 0.35em 0.75em 0.625em;
}
legend {
  box-sizing: border-box;
  color: inherit;
  display: table;
  max-width: 100%;
  padding: 0; /* 3 */
  white-space: normal;
}
progress {
  vertical-align: baseline;
}
textarea {
  overflow: auto;
}
[type="checkbox"],
[type="radio"] {
  box-sizing: border-box;
  padding: 0;
}
[type="number"]::-webkit-inner-spin-button,
[type="number"]::-webkit-outer-spin-button {
  height: auto;
}
[type="search"] {
  -webkit-appearance: textfield;
  outline-offset: -2px;
}
[type="search"]::-webkit-search-decoration {
  -webkit-appearance: none;
}
::-webkit-file-upload-button {
  -webkit-appearance: button;
  font: inherit;
}
details {
  display: block;
}
summary {
  display: list-item;
}
template {
  display: none;
}
[hidden] {
  display: none;
}
`;
const GlobalStyle = at$1`
${normalize}



html,
body,
div,
span,
applet,
object,
iframe,
h1,
h2,
h3,
h4,
h5,
h6,
p,
blockquote,
pre,
a,
abbr,
acronym,
address,
big,
cite,
code,
del,
dfn,
em,
img,
ins,
kbd,
q,
s,
samp,
small,
strike,
strong,
sub,
sup,
tt,
var,
b,
u,
i,
center,
dl,
dt,
dd,
ol,
ul,
li,
fieldset,
form,
label,
legend,
table,
caption,
tbody,
tfoot,
thead,
tr,
th,
td,
article,
aside,
canvas,
details,
embed,
figure,
figcaption,
footer,
header,
hgroup,
menu,
nav,
output,
ruby,
section,
summary,
time,
mark,
audio,
video {
  margin: 0;
  padding: 0;
  border: 0;
  /* font-size: 100%; */
  /* font: inherit; */
  vertical-align: baseline;
  outline: none;
}

ol,
ul {
  list-style: none;
}

input {
  outline: none;
}

img {
  border: 0;
  max-width: 100%;
}

a {
  text-decoration: none;

  &:hover {
    text-decoration: underline;
  }
}

button {
  padding: 0;
  margin: 0;
  border: 0;
  cursor: pointer;
}

body {
  font-family: 'Montserrat', sans-serif;
  font-size: 14px;
  line-height: 1;
  background-color: ${(props) => props.theme.colors.greyF1};
}

*,
::after,
::before {
  box-sizing: border-box;
}
`;
const baseTheme = {
  colors: {
    realWhite: "#fff",
    realBlack: "#000",
    dark: "#181818",
    mainBlue: "#007AFF",
    darkBlue: "#0068d6",
    lightBlue: "#4BF2FD",
    greyF1: "#f1f1f1",
    greyF5: "#f5f5f5",
    greyEO: "#E0E0E0",
    grey93: "#939393",
    grey57: "#575757",
    yRed: "#E03638",
    darkRed: "#940f0f",
    mainGreen: "#5B8930",
    mainYellow: "#F1FF0D"
  },
  utils: {
    transition: "all .2s ease-in-out",
    br: "15px",
    zIndex: {
      popup: "100",
      burgerMenu: "250",
      modalControls: "200",
      darkOverlay: "500",
      overDarkOverlay: "501",
      loading: "1000"
    }
  },
  media: {
    mobile: "(max-width: 768px)",
    desktop: "(min-width: 769px)"
  }
};
const typography = "";
client.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Provider, { store, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Xe$1, { theme: baseTheme, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalStyle, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(App, {})
  ] }) }) })
);
